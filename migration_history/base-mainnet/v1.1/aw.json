{
  "language": "Vyper",
  "sources": {
    "interfaces/Wallet.vyi": {
      "content": "# @version 0.4.3\n\nstruct SwapInstruction:\n    legoId: uint256\n    amountIn: uint256\n    minAmountOut: uint256\n    tokenPath: DynArray[address, MAX_TOKEN_PATH]\n    poolPath: DynArray[address, MAX_TOKEN_PATH - 1]\n\nMAX_SWAP_INSTRUCTIONS: constant(uint256) = 5\nMAX_TOKEN_PATH: constant(uint256) = 5\nMAX_PROOFS: constant(uint256) = 25\n\n\n@view\n@external\ndef onERC721Received(_operator: address, _owner: address, _tokenId: uint256, _data: Bytes[1024]) -> bytes4:\n    ...\n\n\n@pure\n@external\ndef apiVersion() -> String[28]:\n    ...\n\n\n##################\n# Transfer Funds #\n##################\n\n\n@external\ndef transferFunds(\n    _recipient: address,\n    _asset: address = empty(address),\n    _amount: uint256 = max_value(uint256),\n    _isCheque: bool = False,\n    _isSpecialTx: bool = False,\n) -> (uint256, uint256):\n    ...\n\n\n#########\n# Yield #\n#########\n\n\n# deposit\n\n\n@external\ndef depositForYield(\n    _legoId: uint256,\n    _asset: address,\n    _vaultAddr: address = empty(address),\n    _amount: uint256 = max_value(uint256),\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, address, uint256, uint256):\n    ...\n\n\n# withdraw\n\n\n@external\ndef withdrawFromYield(\n    _legoId: uint256,\n    _vaultToken: address,\n    _amount: uint256 = max_value(uint256),\n    _extraData: bytes32 = empty(bytes32),\n    _isSpecialTx: bool = False,\n) -> (uint256, address, uint256, uint256):\n    ...\n\n\n# rebalance position\n\n\n@external\ndef rebalanceYieldPosition(\n    _fromLegoId: uint256,\n    _fromVaultToken: address,\n    _toLegoId: uint256,\n    _toVaultAddr: address = empty(address),\n    _fromVaultAmount: uint256 = max_value(uint256),\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, address, uint256, uint256):\n    ...\n\n\n###################\n# Swap / Exchange #\n###################\n\n\n@external\ndef swapTokens(_instructions: DynArray[SwapInstruction, MAX_SWAP_INSTRUCTIONS]) -> (address, uint256, address, uint256, uint256):\n    ...\n\n\n# mint / redeem\n\n\n@external\ndef mintOrRedeemAsset(\n    _legoId: uint256,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256 = max_value(uint256),\n    _minAmountOut: uint256 = 0,\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, uint256, bool, uint256):\n    ...\n\n\n@external\ndef confirmMintOrRedeemAsset(\n    _legoId: uint256,\n    _tokenIn: address,\n    _tokenOut: address,\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, uint256):\n    ...\n\n\n###################\n# Debt Management #\n###################\n\n\n# add collateral\n\n\n@external\ndef addCollateral(\n    _legoId: uint256,\n    _asset: address,\n    _amount: uint256 = max_value(uint256),\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, uint256):\n    ...\n\n\n# remove collateral\n\n\n@external\ndef removeCollateral(\n    _legoId: uint256,\n    _asset: address,\n    _amount: uint256 = max_value(uint256),\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, uint256):\n    ...\n\n\n# borrow\n\n\n@external\ndef borrow(\n    _legoId: uint256,\n    _borrowAsset: address,\n    _amount: uint256 = max_value(uint256),\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, uint256):\n    ...\n\n\n# repay debt\n\n\n@external\ndef repayDebt(\n    _legoId: uint256,\n    _paymentAsset: address,\n    _paymentAmount: uint256 = max_value(uint256),\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, uint256):\n    ...\n\n\n#################\n# Claim Rewards #\n#################\n\n\n@external\ndef claimIncentives(\n    _legoId: uint256,\n    _rewardToken: address = empty(address),\n    _rewardAmount: uint256 = max_value(uint256),\n    _proofs: DynArray[bytes32, MAX_PROOFS] = [],\n) -> (uint256, uint256):\n    ...\n\n\n################\n# Wrapped ETH #\n################\n\n\n# eth -> weth\n\n\n@payable\n@external\ndef convertEthToWeth(_amount: uint256 = max_value(uint256)) -> (uint256, uint256):\n    ...\n\n\n# weth -> eth\n\n\n@external\ndef convertWethToEth(_amount: uint256 = max_value(uint256)) -> (uint256, uint256):\n    ...\n\n\n#################\n# Add Liquidity #\n#################\n\n\n# add / remove liquidity (simple)\n\n\n@external\ndef addLiquidity(\n    _legoId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _amountA: uint256 = max_value(uint256),\n    _amountB: uint256 = max_value(uint256),\n    _minAmountA: uint256 = 0,\n    _minAmountB: uint256 = 0,\n    _minLpAmount: uint256 = 0,\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, uint256, uint256, uint256):\n    ...\n\n\n@external\ndef removeLiquidity(\n    _legoId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpToken: address,\n    _lpAmount: uint256 = max_value(uint256),\n    _minAmountA: uint256 = 0,\n    _minAmountB: uint256 = 0,\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, uint256, uint256, uint256):\n    ...\n\n\n# add / remove liquidity (concentrated)\n\n\n@external\ndef addLiquidityConcentrated(\n    _legoId: uint256,\n    _nftAddr: address,\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _amountA: uint256 = max_value(uint256),\n    _amountB: uint256 = max_value(uint256),\n    _tickLower: int24 = min_value(int24),\n    _tickUpper: int24 = max_value(int24),\n    _minAmountA: uint256 = 0,\n    _minAmountB: uint256 = 0,\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, uint256, uint256, uint256, uint256):\n    ...\n\n\n@external\ndef removeLiquidityConcentrated(\n    _legoId: uint256,\n    _nftAddr: address,\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _liqToRemove: uint256 = max_value(uint256),\n    _minAmountA: uint256 = 0,\n    _minAmountB: uint256 = 0,\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, uint256, uint256, uint256):\n    ...\n\n\n#############\n# Utilities #\n#############\n\n\n# recover nft\n\n\n@external\ndef recoverNft(_collection: address, _nftTokenId: uint256, _recipient: address):\n    ...\n",
      "sha256sum": "5fd15f8da6c599f20c3c5a765632b224190eede7c05057d45df54563b94cd15c"
    },
    "interfaces/AgentWrapper.vyi": {
      "content": "# @version 0.4.3\n\nfrom interfaces import Wallet\n\n##################\n# Transfer Funds #\n##################\n\n@external\ndef transferFunds(\n    _userWallet: address,\n    _recipient: address,\n    _asset: address,\n    _amount: uint256,\n    _isCheque: bool,\n) -> (uint256, uint256):\n    ...\n\n#########\n# Yield #\n#########\n\n@external\ndef depositForYield(\n    _userWallet: address,\n    _legoId: uint256,\n    _asset: address,\n    _vaultAddr: address,\n    _amount: uint256,\n    _extraData: bytes32,\n) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef withdrawFromYield(\n    _userWallet: address,\n    _legoId: uint256,\n    _vaultToken: address,\n    _amount: uint256,\n    _extraData: bytes32,\n) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef rebalanceYieldPosition(\n    _userWallet: address,\n    _fromLegoId: uint256,\n    _fromVaultToken: address,\n    _toLegoId: uint256,\n    _toVaultAddr: address,\n    _fromVaultAmount: uint256,\n    _extraData: bytes32,\n) -> (uint256, address, uint256, uint256):\n    ...\n\n###################\n# Swap / Exchange #\n###################\n\n@external\ndef swapTokens(\n    _userWallet: address,\n    _swapInstructions: DynArray[Wallet.SwapInstruction, 5],\n) -> (address, uint256, address, uint256, uint256):\n    ...\n\n@external\ndef mintOrRedeemAsset(\n    _userWallet: address,\n    _legoId: uint256,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n    _minAmountOut: uint256,\n    _extraData: bytes32,\n) -> (uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef confirmMintOrRedeemAsset(\n    _userWallet: address,\n    _legoId: uint256,\n    _tokenIn: address,\n    _tokenOut: address,\n    _extraData: bytes32,\n) -> (uint256, uint256):\n    ...\n\n###################\n# Debt Management #\n###################\n\n@external\ndef addCollateral(\n    _userWallet: address,\n    _legoId: uint256,\n    _asset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n) -> (uint256, uint256):\n    ...\n\n@external\ndef removeCollateral(\n    _userWallet: address,\n    _legoId: uint256,\n    _asset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n) -> (uint256, uint256):\n    ...\n\n@external\ndef borrow(\n    _userWallet: address,\n    _legoId: uint256,\n    _borrowAsset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n) -> (uint256, uint256):\n    ...\n\n@external\ndef repayDebt(\n    _userWallet: address,\n    _legoId: uint256,\n    _paymentAsset: address,\n    _paymentAmount: uint256,\n    _extraData: bytes32,\n) -> (uint256, uint256):\n    ...\n\n#################\n# Claim Rewards #\n#################\n\n@external\ndef claimIncentives(\n    _userWallet: address,\n    _legoId: uint256,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _proofs: DynArray[bytes32, 25],\n) -> (uint256, uint256):\n    ...\n\n###############\n# Wrapped ETH #\n###############\n\n@external\ndef convertWethToEth(_userWallet: address, _amount: uint256) -> (uint256, uint256):\n    ...\n\n@external\ndef convertEthToWeth(_userWallet: address, _amount: uint256) -> (uint256, uint256):\n    ...\n\n#############\n# Liquidity #\n#############\n\n@external\ndef addLiquidity(\n    _userWallet: address,\n    _legoId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _amountA: uint256,\n    _amountB: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _minLpAmount: uint256,\n    _extraData: bytes32,\n) -> (uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef removeLiquidity(\n    _userWallet: address,\n    _legoId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpToken: address,\n    _lpAmount: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n) -> (uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef addLiquidityConcentrated(\n    _userWallet: address,\n    _legoId: uint256,\n    _nftAddr: address,\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _amountA: uint256,\n    _amountB: uint256,\n    _tickLower: int24,\n    _tickUpper: int24,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n) -> (uint256, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef removeLiquidityConcentrated(\n    _userWallet: address,\n    _legoId: uint256,\n    _nftAddr: address,\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _liqToRemove: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n) -> (uint256, uint256, uint256, uint256):\n    ...\n\n#####################\n# Sender Management #\n#####################\n\n@view\n@external\ndef isSender(_address: address) -> bool:\n    ...\n\n@external\ndef addSender(_sender: address):\n    ...\n\n@external\ndef removeSender(_sender: address):\n    ...\n\n###################\n# Public Mappings #\n###################\n\n@view\n@external\ndef senders(arg0: uint256) -> address:\n    ...\n\n@view\n@external\ndef indexOfSender(arg0: address) -> uint256:\n    ...\n\n@view\n@external\ndef numSenders() -> uint256:\n    ...\n",
      "sha256sum": "c6e24b6e140e87d77002d23a6e69b425435fb7605c59056f9d8ab68f97552309"
    },
    "contracts/core/agent/AgentWrapper.vy": {
      "content": "#             _                   _                 _               _                 _\n#            / /\\                /\\ \\              /\\ \\            /\\ \\     _        /\\ \\\n#           / /  \\              /  \\ \\            /  \\ \\          /  \\ \\   /\\_\\      \\_\\ \\\n#          / / /\\ \\            / /\\ \\_\\          / /\\ \\ \\        / /\\ \\ \\_/ / /      /\\__ \\\n#         / / /\\ \\ \\          / / /\\/_/         / / /\\ \\_\\      / / /\\ \\___/ /      / /_ \\ \\\n#        / / /  \\ \\ \\        / / / ______      / /_/_ \\/_/     / / /  \\/____/      / / /\\ \\ \\\n#       / / /___/ /\\ \\      / / / /\\_____\\    / /____/\\       / / /    / / /      / / /  \\/_/\n#      / / /_____/ /\\ \\    / / /  \\/____ /   / /\\____\\/      / / /    / / /      / / /\n#     / /_________/\\ \\ \\  / / /_____/ / /   / / /______     / / /    / / /      / / /\n#    / / /_       __\\ \\_\\/ / /______\\/ /   / / /_______\\   / / /    / / /      /_/ /\n#    \\_\\___\\     /____/_/\\/___________/    \\/__________/   \\/_/     \\/_/       \\_\\/\n#\n#     \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n#     \u2551  ** Agent Wrapper **                                         \u2551\n#     \u2551  Thin wrapper for User Wallet with sender access control.    \u2551\n#     \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n#\n#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nimplements: AgentWrapper\n\nfrom interfaces import Wallet\nfrom interfaces import AgentWrapper\n\ninterface Switchboard:\n    def isSwitchboardAddr(_addr: address) -> bool: view\n\ninterface UndyHq:\n    def getAddr(_regId: uint256) -> address: view\n\nevent AgentAction:\n    action: uint8\n    userWallet: indexed(address)\n    sender: indexed(address)\n\ngroupId: public(uint256)\n\n# senders management\nsenders: public(HashMap[uint256, address]) # index -> sender\nindexOfSender: public(HashMap[address, uint256]) # sender -> index\nnumSenders: public(uint256) # num senders\n\nUNDY_HQ: immutable(address)\n\nMAX_SWAP_INSTRUCTIONS: constant(uint256) = 5\nMAX_PROOFS: constant(uint256) = 25\nSWITCHBOARD_ID: constant(uint256) = 4\n\n\n@deploy\ndef __init__(_undyHq: address, _groupId: uint256):\n    assert _undyHq != empty(address) # dev: invalid undy hq\n    UNDY_HQ = _undyHq\n\n    # group id\n    self.groupId = _groupId\n\n    # not using 0 index\n    self.numSenders = 1\n\n\n##################\n# Transfer Funds #\n##################\n\n\n@external\ndef transferFunds(\n    _userWallet: address,\n    _recipient: address,\n    _asset: address = empty(address),\n    _amount: uint256 = max_value(uint256),\n    _isCheque: bool = False,\n) -> (uint256, uint256):\n    assert self.indexOfSender[msg.sender] != 0 # dev: not approved sender\n    log AgentAction(action = 1, userWallet = _userWallet, sender = msg.sender)\n    return extcall Wallet(_userWallet).transferFunds(_recipient, _asset, _amount, _isCheque, False)\n\n\n#########\n# Yield #\n#########\n\n\n@external\ndef depositForYield(\n    _userWallet: address,\n    _legoId: uint256,\n    _asset: address,\n    _vaultAddr: address = empty(address),\n    _amount: uint256 = max_value(uint256),\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, address, uint256, uint256):\n    assert self.indexOfSender[msg.sender] != 0 # dev: not approved sender\n    log AgentAction(action = 10, userWallet = _userWallet, sender = msg.sender)\n    return extcall Wallet(_userWallet).depositForYield(_legoId, _asset, _vaultAddr, _amount, _extraData)\n\n\n@external\ndef withdrawFromYield(\n    _userWallet: address,\n    _legoId: uint256,\n    _vaultToken: address,\n    _amount: uint256 = max_value(uint256),\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, address, uint256, uint256):\n    assert self.indexOfSender[msg.sender] != 0 # dev: not approved sender\n    log AgentAction(action = 11, userWallet = _userWallet, sender = msg.sender)\n    return extcall Wallet(_userWallet).withdrawFromYield(_legoId, _vaultToken, _amount, _extraData, False)\n\n\n@external\ndef rebalanceYieldPosition(\n    _userWallet: address,\n    _fromLegoId: uint256,\n    _fromVaultToken: address,\n    _toLegoId: uint256,\n    _toVaultAddr: address = empty(address),\n    _fromVaultAmount: uint256 = max_value(uint256),\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, address, uint256, uint256):\n    assert self.indexOfSender[msg.sender] != 0 # dev: not approved sender\n    log AgentAction(action = 12, userWallet = _userWallet, sender = msg.sender)\n    return extcall Wallet(_userWallet).rebalanceYieldPosition(_fromLegoId, _fromVaultToken, _toLegoId, _toVaultAddr, _fromVaultAmount, _extraData)\n\n\n###################\n# Swap / Exchange #\n###################\n\n\n@external\ndef swapTokens(\n    _userWallet: address,\n    _swapInstructions: DynArray[Wallet.SwapInstruction, MAX_SWAP_INSTRUCTIONS],\n) -> (address, uint256, address, uint256, uint256):\n    assert self.indexOfSender[msg.sender] != 0 # dev: not approved sender\n    log AgentAction(action = 20, userWallet = _userWallet, sender = msg.sender)\n    return extcall Wallet(_userWallet).swapTokens(_swapInstructions)\n\n\n@external\ndef mintOrRedeemAsset(\n    _userWallet: address,\n    _legoId: uint256,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256 = max_value(uint256),\n    _minAmountOut: uint256 = 0,\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, uint256, bool, uint256):\n    assert self.indexOfSender[msg.sender] != 0 # dev: not approved sender\n    log AgentAction(action = 21, userWallet = _userWallet, sender = msg.sender)\n    return extcall Wallet(_userWallet).mintOrRedeemAsset(_legoId, _tokenIn, _tokenOut, _amountIn, _minAmountOut, _extraData)\n\n\n@external\ndef confirmMintOrRedeemAsset(\n    _userWallet: address,\n    _legoId: uint256,\n    _tokenIn: address,\n    _tokenOut: address,\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, uint256):\n    assert self.indexOfSender[msg.sender] != 0 # dev: not approved sender\n    log AgentAction(action = 22, userWallet = _userWallet, sender = msg.sender)\n    return extcall Wallet(_userWallet).confirmMintOrRedeemAsset(_legoId, _tokenIn, _tokenOut, _extraData)\n\n\n###################\n# Debt Management #\n###################\n\n\n@external\ndef addCollateral(\n    _userWallet: address,\n    _legoId: uint256,\n    _asset: address,\n    _amount: uint256 = max_value(uint256),\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, uint256):\n    assert self.indexOfSender[msg.sender] != 0 # dev: not approved sender\n    log AgentAction(action = 40, userWallet = _userWallet, sender = msg.sender)\n    return extcall Wallet(_userWallet).addCollateral(_legoId, _asset, _amount, _extraData)\n\n\n@external\ndef removeCollateral(\n    _userWallet: address,\n    _legoId: uint256,\n    _asset: address,\n    _amount: uint256 = max_value(uint256),\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, uint256):\n    assert self.indexOfSender[msg.sender] != 0 # dev: not approved sender\n    log AgentAction(action = 41, userWallet = _userWallet, sender = msg.sender)\n    return extcall Wallet(_userWallet).removeCollateral(_legoId, _asset, _amount, _extraData)\n\n\n@external\ndef borrow(\n    _userWallet: address,\n    _legoId: uint256,\n    _borrowAsset: address,\n    _amount: uint256 = max_value(uint256),\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, uint256):\n    assert self.indexOfSender[msg.sender] != 0 # dev: not approved sender\n    log AgentAction(action = 42, userWallet = _userWallet, sender = msg.sender)\n    return extcall Wallet(_userWallet).borrow(_legoId, _borrowAsset, _amount, _extraData)\n\n\n@external\ndef repayDebt(\n    _userWallet: address,\n    _legoId: uint256,\n    _paymentAsset: address,\n    _paymentAmount: uint256 = max_value(uint256),\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, uint256):\n    assert self.indexOfSender[msg.sender] != 0 # dev: not approved sender\n    log AgentAction(action = 43, userWallet = _userWallet, sender = msg.sender)\n    return extcall Wallet(_userWallet).repayDebt(_legoId, _paymentAsset, _paymentAmount, _extraData)\n\n\n#################\n# Claim Rewards #\n#################\n\n\n@external\ndef claimIncentives(\n    _userWallet: address,\n    _legoId: uint256,\n    _rewardToken: address = empty(address),\n    _rewardAmount: uint256 = max_value(uint256),\n    _proofs: DynArray[bytes32, MAX_PROOFS] = [],\n) -> (uint256, uint256):\n    assert self.indexOfSender[msg.sender] != 0 # dev: not approved sender\n    log AgentAction(action = 50, userWallet = _userWallet, sender = msg.sender)\n    return extcall Wallet(_userWallet).claimIncentives(_legoId, _rewardToken, _rewardAmount, _proofs)\n\n\n###############\n# Wrapped ETH #\n###############\n\n\n@external\ndef convertWethToEth(_userWallet: address, _amount: uint256 = max_value(uint256)) -> (uint256, uint256):\n    assert self.indexOfSender[msg.sender] != 0 # dev: not approved sender\n    log AgentAction(action = 2, userWallet = _userWallet, sender = msg.sender)\n    return extcall Wallet(_userWallet).convertWethToEth(_amount)\n\n\n@external\ndef convertEthToWeth(_userWallet: address, _amount: uint256 = max_value(uint256)) -> (uint256, uint256):\n    assert self.indexOfSender[msg.sender] != 0 # dev: not approved sender\n    log AgentAction(action = 3, userWallet = _userWallet, sender = msg.sender)\n    return extcall Wallet(_userWallet).convertEthToWeth(_amount)\n\n\n#############\n# Liquidity #\n#############\n\n\n@external\ndef addLiquidity(\n    _userWallet: address,\n    _legoId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _amountA: uint256 = max_value(uint256),\n    _amountB: uint256 = max_value(uint256),\n    _minAmountA: uint256 = 0,\n    _minAmountB: uint256 = 0,\n    _minLpAmount: uint256 = 0,\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, uint256, uint256, uint256):\n    assert self.indexOfSender[msg.sender] != 0 # dev: not approved sender\n    log AgentAction(action = 30, userWallet = _userWallet, sender = msg.sender)\n    return extcall Wallet(_userWallet).addLiquidity(_legoId, _pool, _tokenA, _tokenB, _amountA, _amountB, _minAmountA, _minAmountB, _minLpAmount, _extraData)\n\n\n@external\ndef removeLiquidity(\n    _userWallet: address,\n    _legoId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpToken: address,\n    _lpAmount: uint256 = max_value(uint256),\n    _minAmountA: uint256 = 0,\n    _minAmountB: uint256 = 0,\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, uint256, uint256, uint256):\n    assert self.indexOfSender[msg.sender] != 0 # dev: not approved sender\n    log AgentAction(action = 31, userWallet = _userWallet, sender = msg.sender)\n    return extcall Wallet(_userWallet).removeLiquidity(_legoId, _pool, _tokenA, _tokenB, _lpToken, _lpAmount, _minAmountA, _minAmountB, _extraData)\n\n\n@external\ndef addLiquidityConcentrated(\n    _userWallet: address,\n    _legoId: uint256,\n    _nftAddr: address,\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _amountA: uint256 = max_value(uint256),\n    _amountB: uint256 = max_value(uint256),\n    _tickLower: int24 = min_value(int24),\n    _tickUpper: int24 = max_value(int24),\n    _minAmountA: uint256 = 0,\n    _minAmountB: uint256 = 0,\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, uint256, uint256, uint256, uint256):\n    assert self.indexOfSender[msg.sender] != 0 # dev: not approved sender\n    log AgentAction(action = 32, userWallet = _userWallet, sender = msg.sender)\n    return extcall Wallet(_userWallet).addLiquidityConcentrated(_legoId, _nftAddr, _nftTokenId, _pool, _tokenA, _tokenB, _amountA, _amountB, _tickLower, _tickUpper, _minAmountA, _minAmountB, _extraData)\n\n\n@external\ndef removeLiquidityConcentrated(\n    _userWallet: address,\n    _legoId: uint256,\n    _nftAddr: address,\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _liqToRemove: uint256 = max_value(uint256),\n    _minAmountA: uint256 = 0,\n    _minAmountB: uint256 = 0,\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, uint256, uint256, uint256):\n    assert self.indexOfSender[msg.sender] != 0 # dev: not approved sender\n    log AgentAction(action = 33, userWallet = _userWallet, sender = msg.sender)\n    return extcall Wallet(_userWallet).removeLiquidityConcentrated(_legoId, _nftAddr, _nftTokenId, _pool, _tokenA, _tokenB, _liqToRemove, _minAmountA, _minAmountB, _extraData)\n\n\n#####################\n# Sender Management #\n#####################\n\n\n@view\n@external\ndef isSender(_address: address) -> bool:\n    return self.indexOfSender[_address] != 0\n\n\n@external\ndef addSender(_sender: address):\n    assert self._isSwitchboardAddr(msg.sender) # dev: no perms\n    self._registerSender(_sender)\n\n\n@external\ndef removeSender(_sender: address):\n    assert self._isSwitchboardAddr(msg.sender) # dev: no perms\n\n    numSenders: uint256 = self.numSenders\n    if numSenders == 1:\n        return\n\n    targetIndex: uint256 = self.indexOfSender[_sender]\n    if targetIndex == 0:\n        return\n\n    # update data\n    lastIndex: uint256 = numSenders - 1\n    self.numSenders = lastIndex\n    self.indexOfSender[_sender] = 0\n\n    # get last item, replace the removed item\n    if targetIndex != lastIndex:\n        lastItem: address = self.senders[lastIndex]\n        self.senders[targetIndex] = lastItem\n        self.indexOfSender[lastItem] = targetIndex\n\n\n@internal\ndef _registerSender(_sender: address):\n    if self.indexOfSender[_sender] != 0:\n        return\n    sid: uint256 = self.numSenders\n    self.senders[sid] = _sender\n    self.indexOfSender[_sender] = sid\n    self.numSenders = sid + 1\n\n\n# permissions\n\n\n@view\n@internal\ndef _isSwitchboardAddr(_addr: address) -> bool:\n    switchboard: address = staticcall UndyHq(UNDY_HQ).getAddr(SWITCHBOARD_ID)\n    if switchboard == empty(address):\n        return False\n    return staticcall Switchboard(switchboard).isSwitchboardAddr(_addr)",
      "sha256sum": "eb707dd16428cdf20e18ec2d5d721cd010c883f5840bdfa589ccbbee64be2ee4"
    }
  },
  "settings": {
    "outputSelection": { "contracts/core/agent/AgentWrapper.vy": ["*"] },
    "search_paths": ["."]
  },
  "compiler_version": "v0.4.3+commit.bff19ea2",
  "integrity": "0b067ec7c68059f37a5eb6dc9f58067ae83f7da8edc94563fb35d41c93cfd6a4"
}
