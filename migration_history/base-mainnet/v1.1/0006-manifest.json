{
  "contracts": {
    "LootDistributor": {
      "address": "0x23d69D99061acf04c6e86f58692F533E4f039dE8",
      "abi": [
        {
          "name": "TransactionFeePaid",
          "inputs": [
            {
              "name": "user",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "feeAmount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "action",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "RevenueTransferredToGov",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "action",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "YieldPerformanceFeePaid",
          "inputs": [
            {
              "name": "user",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "feeAmount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "yieldRealized",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AmbassadorTxFeePaid",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "totalFee",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "ambassadorFeeRatio",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "ambassadorFee",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "ambassador",
              "type": "address",
              "indexed": true
            },
            {
              "name": "action",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "YieldBonusPaid",
          "inputs": [
            {
              "name": "bonusAsset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "bonusAmount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "bonusRatio",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "yieldRealized",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "isAmbassador",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LootAdjusted",
          "inputs": [
            {
              "name": "user",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newClaimable",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LootClaimed",
          "inputs": [
            {
              "name": "user",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "DepositRewardsAdded",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "addedAmount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "newTotalAmount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "adder",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "DepositRewardsClaimed",
          "inputs": [
            {
              "name": "user",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "userRewards",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "remainingRewards",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "DepositRewardsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "RipeRewardsConfigSet",
          "inputs": [
            {
              "name": "ripeStakeRatio",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "ripeLockDuration",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "DepartmentPauseModified",
          "inputs": [
            {
              "name": "isPaused",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "DepartmentFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "balance",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddys",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "undyToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "hatchery",
                  "type": "address"
                },
                {
                  "name": "lootDistributor",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                },
                {
                  "name": "walletBackpack",
                  "type": "address"
                },
                {
                  "name": "billing",
                  "type": "address"
                },
                {
                  "name": "vaultRegistry",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUndyHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canMintUndy",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pause",
          "inputs": [
            {
              "name": "_shouldPause",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFundsMany",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_assets",
              "type": "address[]"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isPaused",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLootFromSwapOrRewards",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_feeAmount",
              "type": "uint256"
            },
            {
              "name": "_action",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLootFromSwapOrRewards",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_feeAmount",
              "type": "uint256"
            },
            {
              "name": "_action",
              "type": "uint256"
            },
            {
              "name": "_missionControl",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLootFromYieldProfit",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_feeAmount",
              "type": "uint256"
            },
            {
              "name": "_yieldRealized",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLootFromYieldProfit",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_feeAmount",
              "type": "uint256"
            },
            {
              "name": "_yieldRealized",
              "type": "uint256"
            },
            {
              "name": "_missionControl",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLootFromYieldProfit",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_feeAmount",
              "type": "uint256"
            },
            {
              "name": "_yieldRealized",
              "type": "uint256"
            },
            {
              "name": "_missionControl",
              "type": "address"
            },
            {
              "name": "_appraiser",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLootFromYieldProfit",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_feeAmount",
              "type": "uint256"
            },
            {
              "name": "_yieldRealized",
              "type": "uint256"
            },
            {
              "name": "_missionControl",
              "type": "address"
            },
            {
              "name": "_appraiser",
              "type": "address"
            },
            {
              "name": "_legoBook",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRevShareAndBonusLoot",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getClaimableLootForAsset",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getTotalClaimableAssets",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "adjustLoot",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_newClaimable",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "updateDepositPoints",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "updateDepositPointsWithNewValue",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_newUsdValue",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "updateDepositPointsOnEjection",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLatestDepositPoints",
          "inputs": [
            {
              "name": "_usdValue",
              "type": "uint256"
            },
            {
              "name": "_lastUpdate",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidWalletConfig",
          "inputs": [
            {
              "name": "_wallet",
              "type": "address"
            },
            {
              "name": "_caller",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimDepositRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getClaimableDepositRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addDepositRewards",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverDepositRewards",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getSwapFee",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getSwapFee",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_missionControl",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRewardsFee",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRewardsFee",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_missionControl",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimAllLoot",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "validateCanClaimLoot",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_caller",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setRipeRewardsConfig",
          "inputs": [
            {
              "name": "_ripeStakeRatio",
              "type": "uint256"
            },
            {
              "name": "_ripeLockDuration",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "lastClaim",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalClaimableLoot",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "claimableLoot",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "claimableAssets",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfClaimableAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numClaimableAssets",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "depositRewards",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "amount",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ripeStakeRatio",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ripeLockDuration",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "RIPE_TOKEN",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "RIPE_REGISTRY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_undyHq",
              "type": "address"
            },
            {
              "name": "_ripeToken",
              "type": "address"
            },
            {
              "name": "_ripeRegistry",
              "type": "address"
            },
            {
              "name": "_ripeStakeRatio",
              "type": "uint256"
            },
            {
              "name": "_ripeLockDuration",
              "type": "uint256"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/modules/Addys.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\ninterface UndyHq:\n    def isValidAddr(_addr: address) -> bool: view\n    def getAddr(_regId: uint256) -> address: view\n    def undyToken() -> address: view\n\ninterface Switchboard:\n    def isSwitchboardAddr(_addr: address) -> bool: view\n\ninterface LegoBook:\n    def isLegoAddr(_addr: address) -> bool: view\n\nstruct Addys:\n    hq: address\n    undyToken: address\n    ledger: address\n    missionControl: address\n    legoBook: address\n    switchboard: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    walletBackpack: address\n    billing: address\n    vaultRegistry: address\n\n# hq\nUNDY_HQ_FOR_ADDYS: immutable(address)\n\n# core addys\nLEDGER_ID: constant(uint256) = 1\nMISSION_CONTROL_ID: constant(uint256) = 2\nLEGO_BOOK_ID: constant(uint256) = 3\nSWITCHBOARD_ID: constant(uint256) = 4\nHATCHERY_ID: constant(uint256) = 5\nLOOT_DISTRIBUTOR_ID: constant(uint256) = 6\nAPPRAISER_ID: constant(uint256) = 7\nWALLET_BACKPACK_ID: constant(uint256) = 8\nBILLING_ID: constant(uint256) = 9\nVAULT_REGISTRY_ID: constant(uint256) = 10\n\n\n@deploy\ndef __init__(_undyHq: address):\n    assert _undyHq != empty(address) # dev: invalid undy hq\n    UNDY_HQ_FOR_ADDYS = _undyHq\n\n\n########\n# Core #\n########\n\n\n@view\n@external\ndef getAddys() -> Addys:\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _getAddys(_addys: Addys = empty(Addys)) -> Addys:\n    if _addys.hq != empty(address):\n        return _addys\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _generateAddys() -> Addys:\n    hq: address = UNDY_HQ_FOR_ADDYS\n    return Addys(\n        hq = hq,\n        undyToken = staticcall UndyHq(hq).undyToken(),\n        ledger = staticcall UndyHq(hq).getAddr(LEDGER_ID),\n        missionControl = staticcall UndyHq(hq).getAddr(MISSION_CONTROL_ID),\n        legoBook = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID),\n        switchboard = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID),\n        hatchery = staticcall UndyHq(hq).getAddr(HATCHERY_ID),\n        lootDistributor = staticcall UndyHq(hq).getAddr(LOOT_DISTRIBUTOR_ID),\n        appraiser = staticcall UndyHq(hq).getAddr(APPRAISER_ID),\n        walletBackpack = staticcall UndyHq(hq).getAddr(WALLET_BACKPACK_ID),\n        billing = staticcall UndyHq(hq).getAddr(BILLING_ID),\n        vaultRegistry = staticcall UndyHq(hq).getAddr(VAULT_REGISTRY_ID),\n    )\n\n\n##########\n# Tokens #\n##########\n\n\n@view\n@internal\ndef _getUndyToken() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).undyToken()\n\n\n###########\n# Helpers #\n###########\n\n\n# undy hq\n\n\n@view\n@external\ndef getUndyHq() -> address:\n    return self._getUndyHq()\n\n\n@view\n@internal\ndef _getUndyHq() -> address:\n    return UNDY_HQ_FOR_ADDYS\n\n\n# utils\n\n\n@view\n@internal\ndef _isValidUndyAddr(_addr: address, _hq: address = empty(address)) -> bool:\n    hq: address = _hq\n    if _hq == empty(address):\n        hq = UNDY_HQ_FOR_ADDYS\n    \n    # core departments\n    if staticcall UndyHq(hq).isValidAddr(_addr):\n        return True\n\n    # lego book\n    legoBook: address = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID)\n    if legoBook != empty(address) and staticcall LegoBook(legoBook).isLegoAddr(_addr):\n        return True\n\n    # switchboard config\n    switchboard: address = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID)\n    if switchboard != empty(address) and staticcall Switchboard(switchboard).isSwitchboardAddr(_addr):\n        return True\n\n    return False\n\n\n@view\n@internal\ndef _isSwitchboardAddr(_addr: address) -> bool:\n    switchboard: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n    if switchboard == empty(address):\n        return False\n    return staticcall Switchboard(switchboard).isSwitchboardAddr(_addr)\n\n\n@view\n@internal\ndef _isLegoBookAddr(_addr: address) -> bool:\n    legoBook: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n    if legoBook == empty(address):\n        return False\n    return staticcall LegoBook(legoBook).isLegoAddr(_addr)\n\n\n###############\n# Departments #\n###############\n\n\n# ledger\n\n\n@view\n@internal\ndef _getLedgerId() -> uint256:\n    return LEDGER_ID\n\n\n@view\n@internal\ndef _getLedgerAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEDGER_ID)\n\n\n# mission control\n\n\n@view\n@internal\ndef _getMissionControlId() -> uint256:\n    return MISSION_CONTROL_ID\n\n\n@view\n@internal\ndef _getMissionControlAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(MISSION_CONTROL_ID)\n\n\n# lego book\n\n\n@view\n@internal\ndef _getLegoBookId() -> uint256:\n    return LEGO_BOOK_ID\n\n\n@view\n@internal\ndef _getLegoBookAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n\n\n# switchboard\n\n\n@view\n@internal\ndef _getSwitchboardId() -> uint256:\n    return SWITCHBOARD_ID\n\n\n@view\n@internal\ndef _getSwitchboardAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n\n\n# hatchery\n\n\n@view\n@internal\ndef _getHatcheryId() -> uint256:\n    return HATCHERY_ID\n\n\n@view\n@internal\ndef _getHatcheryAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(HATCHERY_ID)\n\n\n# loot distributor\n\n\n@view\n@internal\ndef _getLootDistributorId() -> uint256:\n    return LOOT_DISTRIBUTOR_ID\n\n\n@view\n@internal\ndef _getLootDistributorAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LOOT_DISTRIBUTOR_ID)\n\n\n# appraiser\n\n\n@view\n@internal\ndef _getAppraiserId() -> uint256:\n    return APPRAISER_ID\n\n\n@view\n@internal\ndef _getAppraiserAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(APPRAISER_ID)\n\n\n# wallet backpack\n\n\n@view\n@internal\ndef _getWalletBackpackId() -> uint256:\n    return WALLET_BACKPACK_ID\n\n\n@view\n@internal\ndef _getWalletBackpackAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(WALLET_BACKPACK_ID)\n\n\n# billing\n\n\n@view\n@internal\ndef _getBillingId() -> uint256:\n    return BILLING_ID\n\n\n@view\n@internal\ndef _getBillingAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(BILLING_ID)\n\n\n# vault registry\n\n\n@view\n@internal\ndef _getVaultRegistryId() -> uint256:\n    return VAULT_REGISTRY_ID\n\n\n@view\n@internal\ndef _getVaultRegistryAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(VAULT_REGISTRY_ID)",
            "sha256sum": "4df6b72db9bb417d1af81660175be1450cfb7b3575f3d17a5b8a130bff87b781"
          },
          "interfaces/Department.vyi": {
            "content": "# @version 0.4.3\n\n\n###########\n# Minting #\n###########\n\n\n@view\n@external\ndef canMintUndy() -> bool:\n    # used in UndyHq.vy\n    ...\n\n\n########\n# Undy #\n########\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "53e48da591c4ee36045a8950c9d3a01458456b471b797df536e9a9f54404e721"
          },
          "contracts/modules/DeptBasics.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nuses: addys\nimplements: dept\n\nimport contracts.modules.Addys as addys\nimport interfaces.Department as dept\nfrom ethereum.ercs import IERC20\n\nevent DepartmentPauseModified:\n    isPaused: bool\n\nevent DepartmentFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    balance: uint256\n\nisPaused: public(bool)\n\nCAN_MINT_UNDY: immutable(bool)\nMAX_RECOVER_ASSETS: constant(uint256) = 20\n\n\n@deploy\ndef __init__(_shouldPause: bool, _canMintUndy: bool):\n    self.isPaused = _shouldPause\n    CAN_MINT_UNDY = _canMintUndy\n\n\n###########\n# Minting #\n###########\n\n\n@view\n@external\ndef canMintUndy() -> bool:\n    return CAN_MINT_UNDY\n\n\n########\n# Undy #\n########\n\n\n# activate\n\n\n@external\ndef pause(_shouldPause: bool):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert _shouldPause != self.isPaused # dev: no change\n    self.isPaused = _shouldPause\n    log DepartmentPauseModified(isPaused=_shouldPause)\n\n\n# recover funds\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    self._recoverFunds(_recipient, _asset)\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, MAX_RECOVER_ASSETS]):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    for a: address in _assets:\n        self._recoverFunds(_recipient, a)\n\n\n@internal\ndef _recoverFunds(_recipient: address, _asset: address):\n    assert empty(address) not in [_recipient, _asset] # dev: invalid recipient or asset\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    assert balance != 0 # dev: nothing to recover\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log DepartmentFundsRecovered(asset=_asset, recipient=_recipient, balance=balance)\n",
            "sha256sum": "976a50a3807bcf71f3f1c57de5cd7a59fe4e8f27b4d4560e774073962f44d1ac"
          },
          "interfaces/LegoStructs.vyi": {
            "content": "# @version 0.4.3\n\nstruct VaultTokenInfo:\n    underlyingAsset: address\n    decimals: uint256\n    lastAveragePricePerShare: uint256\n\nstruct SnapShotPriceConfig:\n    minSnapshotDelay: uint256\n    maxNumSnapshots: uint256\n    maxUpsideDeviation: uint256\n    staleTime: uint256\n\nstruct SingleSnapShot:\n    totalSupply: uint256\n    pricePerShare: uint256\n    lastUpdate: uint256\n\nstruct SnapShotData:\n    lastSnapShot: SingleSnapShot\n    nextIndex: uint256\n",
            "sha256sum": "8ae48be17d812d57fbd671bbf0593e8abf175ad0924e47c5997823cac19ec806"
          },
          "interfaces/YieldLego.vyi": {
            "content": "# @version 0.4.3\n\nfrom interfaces import LegoStructs as ls\n\n\n###################\n# Underlying Data #\n###################\n\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    ...\n\n\n@view\n@external\ndef getUnderlyingBalances(_vaultToken: address, _vaultTokenBalance: uint256) -> (uint256, uint256):\n    ...\n\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    ...\n\n\n@view\n@external\ndef getUnderlyingAmountSafe(_vaultToken: address, _vaultTokenBalance: uint256) -> uint256:\n    ...\n\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> (address, uint256, uint256):\n    ...\n\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> uint256:\n    ...\n\n\n###############\n# Other Utils #\n###############\n\n\n@view\n@external\ndef isRebasing() -> bool:\n    ...\n\n\n@view\n@external\ndef getPricePerShare(_vaultToken: address, _decimals: uint256 = 0) -> uint256:\n    ...\n\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef canRegisterVaultToken(_asset: address, _vaultToken: address) -> bool:\n    ...\n\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef getUtilizationRatio(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef getAvailLiquidity(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef isEligibleForYieldBonus(_asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef getWithdrawalFees(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    ...\n\n\n###################\n# Yield Lego Data #\n###################\n\n\n@view\n@external\ndef isLegoAsset(_asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, 40]:\n    ...\n\n\n@view\n@external\ndef getAssets() -> DynArray[address, 20]:\n    ...\n\n\n@view\n@external\ndef isAssetOpportunity(_asset: address, _vaultAddr: address) -> bool:\n    ...\n\n\n@view\n@external\ndef getNumLegoAssets() -> uint256:\n    ...\n\n\n@view\n@external\ndef assets(_index: uint256) -> address:\n    ...\n\n\n@view\n@external\ndef indexOfAsset(_asset: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef numAssets() -> uint256:\n    ...\n\n\n@view\n@external\ndef assetOpportunities(_asset: address, _index: uint256) -> address:\n    ...\n\n\n@view\n@external\ndef indexOfAssetOpportunity(_asset: address, _vaultAddr: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef numAssetOpportunities(_asset: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef vaultToAsset(_vaultAddr: address) -> ls.VaultTokenInfo:\n    ...\n\n\n# price snapshots\n\n\n@external\ndef addPriceSnapshot(_vaultToken: address) -> bool:\n    ...\n\n\n@view\n@external\ndef snapShotPriceConfig() -> ls.SnapShotPriceConfig:\n    ...\n\n\n@view\n@external\ndef snapShotData(_vaultToken: address) -> ls.SnapShotData:\n    ...\n\n\n@view\n@external\ndef snapShots(_vaultToken: address, _index: uint256) -> ls.SingleSnapShot:\n    ...\n\n\n@view\n@external\ndef getWeightedPricePerShare(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef getLatestSnapshot(_vaultToken: address, _pricePerShare: uint256) -> ls.SingleSnapShot:\n    ...\n\n\n@external\ndef setSnapShotPriceConfig(_config: ls.SnapShotPriceConfig):\n    ...\n",
            "sha256sum": "db91c139f6018f5218b389d08c8703bc16fb994aa948805dbfea27e072f382ec"
          },
          "interfaces/WalletStructs.vyi": {
            "content": "# @version 0.4.3\n\nflag ActionType:\n    TRANSFER\n    EARN_DEPOSIT\n    EARN_WITHDRAW\n    EARN_REBALANCE\n    SWAP\n    MINT_REDEEM\n    CONFIRM_MINT_REDEEM\n    ADD_COLLATERAL\n    REMOVE_COLLATERAL\n    BORROW\n    REPAY_DEBT\n    REWARDS\n    ETH_TO_WETH\n    WETH_TO_ETH\n    ADD_LIQ\n    REMOVE_LIQ\n    ADD_LIQ_CONC\n    REMOVE_LIQ_CONC\n    PAY_CHEQUE\n\nstruct WalletAssetData:\n    assetBalance: uint256\n    usdValue: uint256\n    isYieldAsset: bool\n    lastPricePerShare: uint256\n\nstruct ActionData:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    billing: address\n    vaultRegistry: address\n    wallet: address\n    walletConfig: address\n    walletOwner: address\n    inEjectMode: bool\n    isFrozen: bool\n    lastTotalUsdValue: uint256\n    signer: address\n    isManager: bool\n    legoId: uint256\n    legoAddr: address\n    eth: address\n    weth: address\n\nstruct MiniAddys:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    appraiser: address",
            "sha256sum": "466493c129135c95470aaf70eeddc936632f7b0f813396e5a7ddc03bea9da518"
          },
          "interfaces/WalletConfigStructs.vyi": {
            "content": "# @version 0.4.3\n\nMAX_CONFIG_ASSETS: constant(uint256) = 40\nMAX_CONFIG_LEGOS: constant(uint256) = 25\nMAX_ALLOWED_PAYEES: constant(uint256) = 40\n\nflag WhitelistAction:\n    ADD_PENDING\n    CONFIRM_WHITELIST\n    CANCEL_WHITELIST\n    REMOVE_WHITELIST\n\nflag BackpackType:\n    WALLET_KERNEL\n    WALLET_SENTINEL\n    WALLET_HIGH_COMMAND\n    WALLET_PAYMASTER\n    WALLET_CHEQUE_BOOK\n    WALLET_MIGRATOR\n\n# payees\n\nstruct PayeeData:\n    numTxsInPeriod: uint256\n    totalUnitsInPeriod: uint256\n    totalUsdValueInPeriod: uint256\n    totalNumTxs: uint256\n    totalUnits: uint256\n    totalUsdValue: uint256\n    lastTxBlock: uint256\n    periodStartBlock: uint256\n\nstruct PayeeSettings:\n    startBlock: uint256\n    expiryBlock: uint256\n    canPull: bool\n    periodLength: uint256\n    maxNumTxsPerPeriod: uint256\n    txCooldownBlocks: uint256\n    failOnZeroPrice: bool\n    primaryAsset: address\n    onlyPrimaryAsset: bool\n    unitLimits: PayeeLimits\n    usdLimits: PayeeLimits\n\nstruct GlobalPayeeSettings:\n    defaultPeriodLength: uint256\n    startDelay: uint256\n    activationLength: uint256\n    maxNumTxsPerPeriod: uint256\n    txCooldownBlocks: uint256\n    failOnZeroPrice: bool\n    usdLimits: PayeeLimits\n    canPayOwner: bool\n    canPull: bool\n\nstruct PayeeLimits:\n    perTxCap: uint256\n    perPeriodCap: uint256\n    lifetimeCap: uint256\n\nstruct PendingPayee:\n    settings: PayeeSettings\n    initiatedBlock: uint256\n    confirmBlock: uint256\n    currentOwner: address\n\nstruct PayeeManagementBundle:\n    owner: address\n    wallet: address\n    isRegisteredPayee: bool\n    isWhitelisted: bool\n    isExistingCheque: bool\n    payeeSettings: PayeeSettings\n    globalPayeeSettings: GlobalPayeeSettings\n    timeLock: uint256\n    walletConfig: address\n\nstruct RecipientConfigBundle:\n    isWhitelisted: bool\n    isOwner: bool\n    isPayee: bool\n    config: PayeeSettings\n    globalConfig: GlobalPayeeSettings\n    data: PayeeData\n\nstruct WhitelistConfigBundle:\n    owner: address\n    wallet: address\n    isWhitelisted: bool\n    pendingWhitelist: PendingWhitelist\n    isExistingPayee: bool\n    isExistingCheque: bool\n    timeLock: uint256\n    walletConfig: address\n    isManager: bool\n    isOwner: bool\n    whitelistPerms: WhitelistPerms\n    globalWhitelistPerms: WhitelistPerms\n\nstruct PendingWhitelist:\n    initiatedBlock: uint256\n    confirmBlock: uint256\n    currentOwner: address\n\n# cheques\n\nstruct Cheque:\n    recipient: address\n    asset: address\n    amount: uint256\n    creationBlock: uint256\n    unlockBlock: uint256\n    expiryBlock: uint256\n    usdValueOnCreation: uint256\n    canManagerPay: bool\n    canBePulled: bool\n    creator: address\n    active: bool\n\nstruct ChequeSettings:\n    maxNumActiveCheques: uint256\n    maxChequeUsdValue: uint256\n    instantUsdThreshold: uint256\n    perPeriodPaidUsdCap: uint256\n    maxNumChequesPaidPerPeriod: uint256\n    payCooldownBlocks: uint256\n    perPeriodCreatedUsdCap: uint256\n    maxNumChequesCreatedPerPeriod: uint256\n    createCooldownBlocks: uint256\n    periodLength: uint256\n    expensiveDelayBlocks: uint256\n    defaultExpiryBlocks: uint256\n    allowedAssets: DynArray[address, MAX_CONFIG_ASSETS]\n    canManagersCreateCheques: bool\n    canManagerPay: bool\n    canBePulled: bool\n\nstruct ChequeData:\n    numChequesPaidInPeriod: uint256\n    totalUsdValuePaidInPeriod: uint256\n    totalNumChequesPaid: uint256\n    totalUsdValuePaid: uint256\n    lastChequePaidBlock: uint256\n    numChequesCreatedInPeriod: uint256\n    totalUsdValueCreatedInPeriod: uint256\n    totalNumChequesCreated: uint256\n    totalUsdValueCreated: uint256\n    lastChequeCreatedBlock: uint256\n    periodStartBlock: uint256\n\nstruct ChequeManagementBundle:\n    wallet: address\n    walletConfig: address\n    owner: address\n    isRecipientOnWhitelist: bool\n    isCreatorManager: bool\n    managerSettings: ManagerSettings\n    chequeSettings: ChequeSettings\n    chequeData: ChequeData\n    isExistingCheque: bool\n    numActiveCheques: uint256\n    isExistingPayee: bool\n    timeLock: uint256\n\n# managers\n\nstruct ManagerData:\n    numTxsInPeriod: uint256\n    totalUsdValueInPeriod: uint256\n    totalNumTxs: uint256\n    totalUsdValue: uint256\n    lastTxBlock: uint256\n    periodStartBlock: uint256\n    numSwapsInPeriod: uint256\n\nstruct ManagerSettings:\n    startBlock: uint256\n    expiryBlock: uint256\n    limits: ManagerLimits\n    legoPerms: LegoPerms\n    swapPerms: SwapPerms\n    whitelistPerms: WhitelistPerms\n    transferPerms: TransferPerms\n    allowedAssets: DynArray[address, MAX_CONFIG_ASSETS]\n    canClaimLoot: bool\n\nstruct GlobalManagerSettings:\n    managerPeriod: uint256\n    startDelay: uint256\n    activationLength: uint256\n    canOwnerManage: bool\n    limits: ManagerLimits\n    legoPerms: LegoPerms\n    swapPerms: SwapPerms\n    whitelistPerms: WhitelistPerms\n    transferPerms: TransferPerms\n    allowedAssets: DynArray[address, MAX_CONFIG_ASSETS]\n\nstruct ManagerLimits:\n    maxUsdValuePerTx: uint256\n    maxUsdValuePerPeriod: uint256\n    maxUsdValueLifetime: uint256\n    maxNumTxsPerPeriod: uint256\n    txCooldownBlocks: uint256\n    failOnZeroPrice: bool\n\nstruct LegoPerms:\n    canManageYield: bool\n    canBuyAndSell: bool\n    canManageDebt: bool\n    canManageLiq: bool\n    canClaimRewards: bool\n    onlyApprovedYieldOpps: bool\n    allowedLegos: DynArray[uint256, MAX_CONFIG_LEGOS]\n\nstruct SwapPerms:\n    mustHaveUsdValue: bool\n    maxNumSwapsPerPeriod: uint256\n    maxSlippage: uint256\n\nstruct WhitelistPerms:\n    canAddPending: bool\n    canConfirm: bool\n    canCancel: bool\n    canRemove: bool\n\nstruct TransferPerms:\n    canTransfer: bool\n    canCreateCheque: bool\n    canAddPendingPayee: bool\n    allowedPayees: DynArray[address, MAX_ALLOWED_PAYEES]\n\nstruct ManagerConfigBundle:\n    isOwner: bool\n    isManager: bool\n    config: ManagerSettings\n    globalConfig: GlobalManagerSettings\n    data: ManagerData\n    payee: address\n\nstruct ManagerSettingsBundle:\n    owner: address\n    isManager: bool\n    timeLock: uint256\n    walletConfig: address\n    legoBook: address\n    globalManagerSettings: GlobalManagerSettings\n\n# migration\n\nstruct MigrationConfigBundle:\n    owner: address\n    isFrozen: bool\n    numPayees: uint256\n    numWhitelisted: uint256\n    numManagers: uint256\n    startingAgent: address\n    startingAgentIndex: uint256\n    hasPendingOwnerChange: bool\n    groupId: uint256\n    numActiveCheques: uint256\n",
            "sha256sum": "31165468feeac632a1376c70970ce5124f8951392c4deaa01a26176c7f26718a"
          },
          "interfaces/ConfigStructs.vyi": {
            "content": "# @version 0.4.3\n\nstruct UserWalletConfig:\n    walletTemplate: address\n    configTemplate: address\n    numUserWalletsAllowed: uint256\n    enforceCreatorWhitelist: bool\n    minKeyActionTimeLock: uint256\n    maxKeyActionTimeLock: uint256\n    depositRewardsAsset: address\n    lootClaimCoolOffPeriod: uint256\n    txFees: TxFees\n    ambassadorRevShare: AmbassadorRevShare\n    yieldConfig: YieldConfig\n\nstruct AssetConfig:\n    hasConfig: bool\n    txFees: TxFees\n    ambassadorRevShare: AmbassadorRevShare\n    yieldConfig: YieldConfig\n\nstruct TxFees:\n    swapFee: uint256\n    stableSwapFee: uint256\n    rewardsFee: uint256\n\nstruct AmbassadorRevShare:\n    swapRatio: uint256\n    rewardsRatio: uint256\n    yieldRatio: uint256\n\nstruct YieldConfig:\n    maxYieldIncrease: uint256\n    performanceFee: uint256\n    ambassadorBonusRatio: uint256\n    bonusRatio: uint256\n    bonusAsset: address\n\nstruct AgentConfig:\n    startingAgent: address\n    startingAgentActivationLength: uint256\n\nstruct ManagerConfig:\n    managerPeriod: uint256\n    managerActivationLength: uint256\n    mustHaveUsdValueOnSwaps: bool\n    maxNumSwapsPerPeriod: uint256\n    maxSlippageOnSwaps: uint256\n    onlyApprovedYieldOpps: bool\n\nstruct PayeeConfig:\n    payeePeriod: uint256\n    payeeActivationLength: uint256\n\nstruct ChequeConfig:\n    maxNumActiveCheques: uint256\n    instantUsdThreshold: uint256\n    periodLength: uint256\n    expensiveDelayBlocks: uint256\n    defaultExpiryBlocks: uint256",
            "sha256sum": "ae733bde84230a3664bb6496f91886e7546b7179fe0036f06e58631fffade3fe"
          },
          "contracts/core/LootDistributor.vy": {
            "content": "#     ___                     ___             ___                     ___                           \n#    (   )                   (   )           (   )  .-.              (   )                          \n#     | |    .--.     .--.    | |_         .-.| |  ( __)     .--.     | |_      ___ .-.      .--.   \n#     | |   /    \\   /    \\  (   __)      /   \\ |  (''\")   /  _  \\   (   __)   (   )   \\    /    \\  \n#     | |  |  .-. ; |  .-. ;  | |        |  .-. |   | |   . .' `. ;   | |       | ' .-. ;  |  .-. ; \n#     | |  | |  | | | |  | |  | | ___    | |  | |   | |   | '   | |   | | ___   |  / (___) | |  | | \n#     | |  | |  | | | |  | |  | |(   )   | |  | |   | |   _\\_`.(___)  | |(   )  | |        | |  | | \n#     | |  | |  | | | |  | |  | | | |    | |  | |   | |  (   ). '.    | | | |   | |        | |  | | \n#     | |  | '  | | | '  | |  | ' | |    | '  | |   | |   | |  `\\ |   | ' | |   | |        | '  | | \n#     | |  '  `-' / '  `-' /  ' `-' ;    ' `-'  /   | |   ; '._,' '   ' `-' ;   | |        '  `-' / \n#    (___)  `.__.'   `.__.'    `.__.      `.__,'   (___)   '.___.'     `.__.   (___)        `.__.'  \n#                                                                                \n#     \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n#     \u2551  ** Loot Distributor **                                 \u2551\n#     \u2551  Handles all rewards and revenue share functionality.   \u2551\n#     \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n#\n#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nimplements: Department\n\nexports: addys.__interface__\nexports: deptBasics.__interface__\n\ninitializes: addys\ninitializes: deptBasics[addys := addys]\n\nimport contracts.modules.Addys as addys\nimport contracts.modules.DeptBasics as deptBasics\n\nfrom interfaces import Department\nfrom interfaces import YieldLego as YieldLego\nfrom interfaces import WalletStructs as ws\nfrom interfaces import WalletConfigStructs as wcs\nimport interfaces.ConfigStructs as cs\n\nfrom ethereum.ercs import IERC20\n\ninterface MissionControl:\n    def getSwapFee(_tokenIn: address, _tokenOut: address) -> uint256: view\n    def getLootDistroConfig(_asset: address) -> LootDistroConfig: view\n    def getRewardsFee(_asset: address) -> uint256: view\n    def getLootClaimCoolOffPeriod() -> uint256: view\n    def getDepositRewardsAsset() -> address: view\n\ninterface Ledger:\n    def setUserAndGlobalPoints(_user: address, _userData: PointsData, _globalData: PointsData): nonpayable\n    def getUserAndGlobalPoints(_user: address) -> (PointsData, PointsData): view\n    def ambassadors(_user: address) -> address: view\n    def isUserWallet(_user: address) -> bool: view\n\ninterface Appraiser:\n    def getAssetAmountFromRipe(_asset: address, _usdValue: uint256) -> uint256: view\n    def getUnderlyingUsdValue(_asset: address, _amount: uint256) -> uint256: view\n\ninterface UserWalletConfig:\n    def managerSettings(_manager: address) -> wcs.ManagerSettings: view\n    def owner() -> address: view\n\ninterface RipeTeller:\n    def depositIntoGovVault(_asset: address, _amount: uint256, _lockDuration: uint256, _user: address = msg.sender) -> uint256: nonpayable\n\ninterface Registry:\n    def getAddr(_regId: uint256) -> address: view\n\ninterface UserWallet:\n    def walletConfig() -> address: view\n\ninterface UndyHq:\n    def governance() -> address: view\n\nstruct PointsData:\n    usdValue: uint256\n    depositPoints: uint256\n    lastUpdate: uint256\n\nstruct LootDistroConfig:\n    legoId: uint256\n    legoAddr: address\n    underlyingAsset: address\n    ambassador: address\n    ambassadorRevShare: cs.AmbassadorRevShare\n    ambassadorBonusRatio: uint256\n    bonusRatio: uint256\n    bonusAsset: address\n\nstruct DepositRewards:\n    asset: address\n    amount: uint256\n\nevent TransactionFeePaid:\n    user: indexed(address)\n    asset: indexed(address)\n    feeAmount: uint256\n    action: ws.ActionType\n\nevent RevenueTransferredToGov:\n    asset: indexed(address)\n    amount: uint256\n    action: ws.ActionType\n\nevent YieldPerformanceFeePaid:\n    user: indexed(address)\n    asset: indexed(address)\n    feeAmount: uint256\n    yieldRealized: uint256\n\nevent AmbassadorTxFeePaid:\n    asset: indexed(address)\n    totalFee: uint256\n    ambassadorFeeRatio: uint256\n    ambassadorFee: uint256\n    ambassador: indexed(address)\n    action: ws.ActionType\n\nevent YieldBonusPaid:\n    bonusAsset: indexed(address)\n    bonusAmount: uint256\n    bonusRatio: uint256\n    yieldRealized: uint256\n    recipient: indexed(address)\n    isAmbassador: bool\n\nevent LootAdjusted:\n    user: indexed(address)\n    asset: indexed(address)\n    newClaimable: uint256\n\nevent LootClaimed:\n    user: indexed(address)\n    asset: indexed(address)\n    amount: uint256\n\nevent DepositRewardsAdded:\n    asset: indexed(address)\n    addedAmount: uint256\n    newTotalAmount: uint256\n    adder: indexed(address)\n\nevent DepositRewardsClaimed:\n    user: indexed(address)\n    asset: indexed(address)\n    userRewards: uint256\n    remainingRewards: uint256\n\nevent DepositRewardsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    amount: uint256\n\nevent RipeRewardsConfigSet:\n    ripeStakeRatio: uint256\n    ripeLockDuration: uint256\n\n# claimable loot\nlastClaim: public(HashMap[address, uint256]) # user -> last claim block\ntotalClaimableLoot: public(HashMap[address, uint256]) # asset -> amount\nclaimableLoot: public(HashMap[address, HashMap[address, uint256]]) # ambassador -> asset -> amount\n\n# ambassador claimable loot\nclaimableAssets: public(HashMap[address, HashMap[uint256, address]]) # ambassador -> index -> asset\nindexOfClaimableAsset: public(HashMap[address, HashMap[address, uint256]]) # ambassador -> asset -> index\nnumClaimableAssets: public(HashMap[address, uint256]) # ambassador -> num assets\n\n# deposit rewards\ndepositRewards: public(DepositRewards)\nripeStakeRatio: public(uint256)\nripeLockDuration: public(uint256)\n\nRIPE_TOKEN: public(immutable(address))\nRIPE_REGISTRY: public(immutable(address))\n\nHUNDRED_PERCENT: constant(uint256) = 100_00 # 100.00%\nEIGHTEEN_DECIMALS: constant(uint256) = 10 ** 18\nMAX_DEREGISTER_ASSETS: constant(uint256) = 20\nRIPE_TELLER_ID: constant(uint256) = 17\n\n\n@deploy\ndef __init__(\n    _undyHq: address,\n    _ripeToken: address,\n    _ripeRegistry: address,\n    _ripeStakeRatio: uint256,\n    _ripeLockDuration: uint256,\n):\n    addys.__init__(_undyHq)\n    deptBasics.__init__(False, False) # no minting\n\n    assert empty(address) not in [_ripeToken, _ripeRegistry] # dev: invalid addresses\n    RIPE_TOKEN = _ripeToken\n    RIPE_REGISTRY = _ripeRegistry\n\n    assert _ripeStakeRatio <= HUNDRED_PERCENT # dev: invalid stake ratio\n    self.ripeStakeRatio = _ripeStakeRatio\n    assert _ripeLockDuration != 0 # dev: invalid lock duration\n    self.ripeLockDuration = _ripeLockDuration\n\n\n#################\n# Revenue Flows #\n#################\n\n\n# normal fee flow (swaps, rewards)\n\n\n@external\ndef addLootFromSwapOrRewards(\n    _asset: address,\n    _feeAmount: uint256,\n    _action: ws.ActionType,\n    _missionControl: address = empty(address),\n):\n    # if paused, fail gracefully\n    if deptBasics.isPaused:\n        return\n\n    ledger: address = addys._getLedgerAddr()\n    assert staticcall Ledger(ledger).isUserWallet(msg.sender) # dev: not a user wallet\n\n    # finalize amount\n    feeAmount: uint256 = min(_feeAmount, staticcall IERC20(_asset).balanceOf(msg.sender))\n    if feeAmount == 0:\n        return\n\n    assert extcall IERC20(_asset).transferFrom(msg.sender, self, feeAmount, default_return_value=True) # dev: transfer failed\n    log TransactionFeePaid(user = msg.sender, asset = _asset, feeAmount = feeAmount, action = _action)\n\n    ambFee: uint256 = 0\n    ambassador: address = staticcall Ledger(ledger).ambassadors(msg.sender)\n    if ambassador != empty(address):\n        missionControl: address = _missionControl if _missionControl != empty(address) else addys._getMissionControlAddr()\n        config: LootDistroConfig = staticcall MissionControl(missionControl).getLootDistroConfig(_asset)\n        config.ambassador = ambassador\n        ambFee = self._handleAmbassadorTxFee(_asset, feeAmount, _action, config)\n\n    # transfer leftover revenue to gov\n    leftoverFee: uint256 = feeAmount - min(feeAmount, ambFee)\n    if leftoverFee != 0:\n        self._transferRevenueToGov(_asset, leftoverFee, _action)\n\n\n# yield profit flow\n\n\n@external\ndef addLootFromYieldProfit(\n    _asset: address,\n    _feeAmount: uint256,\n    _yieldRealized: uint256,\n    _missionControl: address = empty(address),\n    _appraiser: address = empty(address),\n    _legoBook: address = empty(address),\n):\n    # if paused, fail gracefully\n    if deptBasics.isPaused:\n        return\n\n    ledger: address = addys._getLedgerAddr()\n    assert staticcall Ledger(ledger).isUserWallet(msg.sender) # dev: not a user wallet\n    log YieldPerformanceFeePaid(user = msg.sender, asset = _asset, feeAmount = _feeAmount, yieldRealized = _yieldRealized)\n\n    ambassador: address = staticcall Ledger(ledger).ambassadors(msg.sender)\n    missionControl: address = _missionControl if _missionControl != empty(address) else addys._getMissionControlAddr()\n    config: LootDistroConfig = staticcall MissionControl(missionControl).getLootDistroConfig(_asset)\n    config.ambassador = ambassador\n\n    # handle fee (this may be 0) -- no need to `transferFrom` in this case, it's already in this contract\n    ambFee: uint256 = 0\n    if _feeAmount != 0 and ambassador != empty(address):\n        ambFee = self._handleAmbassadorTxFee(_asset, _feeAmount, empty(ws.ActionType), config)\n\n    # transfer leftover revenue to gov\n    leftoverFee: uint256 = _feeAmount - min(_feeAmount, ambFee)\n    if leftoverFee != 0:\n        self._transferRevenueToGov(_asset, leftoverFee, ws.ActionType.EARN_WITHDRAW)\n\n    # yield bonus -- must be eligible\n    if config.legoAddr != empty(address) and staticcall YieldLego(config.legoAddr).isEligibleForYieldBonus(_asset):\n        self._handleYieldBonus(msg.sender, _asset, _yieldRealized, config, _appraiser)\n\n\n# ambassador rev share (transaction fees)\n\n\n@internal\ndef _handleAmbassadorTxFee(\n    _asset: address,\n    _feeAmount: uint256,\n    _action: ws.ActionType,\n    _config: LootDistroConfig,\n) -> uint256:\n    feeRatio: uint256 = _config.ambassadorRevShare.yieldRatio\n    if _action == ws.ActionType.SWAP:\n        feeRatio = _config.ambassadorRevShare.swapRatio\n    elif _action == ws.ActionType.REWARDS:\n        feeRatio = _config.ambassadorRevShare.rewardsRatio\n\n    # finalize fee\n    ambassadorRatio: uint256 = min(feeRatio, HUNDRED_PERCENT)\n    fee: uint256 = min(_feeAmount * ambassadorRatio // HUNDRED_PERCENT, staticcall IERC20(_asset).balanceOf(self))\n    if fee != 0:\n        self._addClaimableLootToUser(_config.ambassador, _asset, fee)\n        log AmbassadorTxFeePaid(asset = _asset, totalFee = _feeAmount, ambassadorFeeRatio = feeRatio, ambassadorFee = fee, ambassador = _config.ambassador, action = _action)\n    return fee\n\n\n# transfer revenue to gov\n\n\n@internal\ndef _transferRevenueToGov(_asset: address, _amount: uint256, _action: ws.ActionType):\n    amount: uint256 = min(_amount, staticcall IERC20(_asset).balanceOf(self))\n    if amount == 0:\n        return\n    governance: address = staticcall UndyHq(addys._getUndyHq()).governance()\n    if governance == empty(address):\n        return\n    assert extcall IERC20(_asset).transfer(governance, amount, default_return_value=True) # dev: transfer failed\n    log RevenueTransferredToGov(asset = _asset, amount = amount, action = _action)\n\n\n###############\n# Yield Bonus #\n###############\n\n\n@internal\ndef _handleYieldBonus(\n    _user: address,\n    _asset: address,\n    _yieldRealized: uint256,\n    _config: LootDistroConfig,\n    _appraiser: address,\n):\n    # early return if no bonusAsset (RIPE token) configured\n    if empty(address) in [_config.bonusAsset, _asset] or _yieldRealized == 0:\n        return\n\n    # get addys (if necessary)\n    appraiser: address = _appraiser\n    if _appraiser == empty(address):\n        appraiser = addys._getAppraiserAddr()\n\n    # convert yield realized to USD value\n    usdValue: uint256 = 0\n    if _config.underlyingAsset != empty(address):\n        underlyingAmount: uint256 = staticcall YieldLego(_config.legoAddr).getUnderlyingAmount(_asset, _yieldRealized)\n        usdValue = staticcall Appraiser(appraiser).getUnderlyingUsdValue(_config.underlyingAsset, underlyingAmount)\n    else:\n        usdValue = staticcall Appraiser(appraiser).getUnderlyingUsdValue(_asset, _yieldRealized)\n    if usdValue == 0:\n        return\n\n    # convert USD value to RIPE token amount\n    bonusAsset: address = _config.bonusAsset # RIPE token\n    bonusAssetYieldRealized: uint256 = staticcall Appraiser(appraiser).getAssetAmountFromRipe(bonusAsset, usdValue)\n\n    # no bonus to distribute\n    currentBalance: uint256 = staticcall IERC20(bonusAsset).balanceOf(self)\n    if bonusAssetYieldRealized == 0 or currentBalance == 0:\n        return\n\n    # check deposit rewards asset\n    reservedForDepositRewards: uint256 = 0\n    depositRewards: DepositRewards = self.depositRewards\n    if bonusAsset == depositRewards.asset:\n        reservedForDepositRewards = depositRewards.amount\n\n    # user bonus\n    if _config.bonusRatio != 0:\n        self._handleSpecificYieldBonus(False, bonusAsset, bonusAssetYieldRealized, _config.bonusRatio, _user, currentBalance, reservedForDepositRewards)\n\n    # ambassador bonus\n    if _config.ambassador != empty(address) and _config.ambassadorBonusRatio != 0:\n        self._handleSpecificYieldBonus(True, bonusAsset, bonusAssetYieldRealized, _config.ambassadorBonusRatio, _config.ambassador, currentBalance, reservedForDepositRewards)\n\n\n# handle specific yield bonus\n\n\n@internal\ndef _handleSpecificYieldBonus(\n    _isAmbassador: bool,\n    _bonusAsset: address,\n    _bonusAssetYieldRealized: uint256,\n    _bonusRatio: uint256,\n    _recipient: address,\n    _currentBalance: uint256,\n    _reservedForDepositRewards: uint256,\n) -> uint256:\n    bonusAmount: uint256 = min(_bonusAssetYieldRealized * _bonusRatio // HUNDRED_PERCENT, _bonusAssetYieldRealized)\n\n    # check what's available for bonus\n    availableForBonus: uint256 = 0\n    unavailableAmount: uint256 = self.totalClaimableLoot[_bonusAsset] + _reservedForDepositRewards\n    if _currentBalance > unavailableAmount:\n        availableForBonus = _currentBalance - unavailableAmount\n\n    bonusAmount = min(bonusAmount, availableForBonus)\n    if bonusAmount != 0:\n        self._addClaimableLootToUser(_recipient, _bonusAsset, bonusAmount)\n        log YieldBonusPaid(bonusAsset = _bonusAsset, bonusAmount = bonusAmount, bonusRatio = _bonusRatio, yieldRealized = _bonusAssetYieldRealized, recipient = _recipient, isAmbassador = _isAmbassador)\n\n    return bonusAmount\n\n\n################################\n# Claim Rev Share / Bonus Loot #\n################################\n\n\n@external\ndef claimRevShareAndBonusLoot(_user: address) -> uint256:\n    a: addys.Addys = addys._getAddys()\n    assert not deptBasics.isPaused # dev: contract paused\n\n    # permission check\n    assert self._validateCanClaimLoot(_user, msg.sender, a.ledger, a.missionControl) # dev: no perms\n\n    # ripe params\n    ripeTeller: address = staticcall Registry(RIPE_REGISTRY).getAddr(RIPE_TELLER_ID)\n    ripeLockDuration: uint256 = self.ripeLockDuration\n    ripeStakeRatio: uint256 = self.ripeStakeRatio\n\n    # claim rev share and bonus loot\n    assetsClaimed: uint256 = self._claimRevShareAndBonusLoot(_user, ripeStakeRatio, ripeLockDuration, ripeTeller)\n    assert assetsClaimed != 0 # dev: no assets claimed\n\n    self.lastClaim[_user] = block.number\n    return assetsClaimed\n\n\n@internal\ndef _claimRevShareAndBonusLoot(\n    _user: address,\n    _ripeStakeRatio: uint256,\n    _ripeLockDuration: uint256,\n    _ripeTeller: address,\n) -> uint256:\n    numAssets: uint256 = self.numClaimableAssets[_user]\n    if numAssets == 0:\n        return 0\n\n    assetsClaimed: uint256 = 0\n    assetsToDeregister: DynArray[address, MAX_DEREGISTER_ASSETS] = []\n\n    # iterate through all claimable assets for user\n    for i: uint256 in range(1, numAssets, bound=max_value(uint256)):\n        asset: address = self.claimableAssets[_user][i]\n        if asset == empty(address):\n            continue\n\n        didClaim: bool = False\n        shouldDeregister: bool = False\n        didClaim, shouldDeregister = self._claimLootForAsset(_user, asset, _ripeStakeRatio, _ripeLockDuration, _ripeTeller)\n        if didClaim:\n            assetsClaimed += 1\n\n        # add to deregister list\n        if shouldDeregister and len(assetsToDeregister) < MAX_DEREGISTER_ASSETS:\n            assetsToDeregister.append(asset)\n\n    # deregister assets\n    if len(assetsToDeregister) != 0:\n        for asset: address in assetsToDeregister:\n            self._deregisterClaimableAssetForUser(_user, asset)\n\n    return assetsClaimed\n\n\n# specific asset claim\n\n\n@internal\ndef _claimLootForAsset(\n    _user: address,\n    _asset: address,\n    _ripeStakeRatio: uint256,\n    _ripeLockDuration: uint256,\n    _ripeTeller: address,\n) -> (bool, bool):\n    claimableAmount: uint256 = self.claimableLoot[_user][_asset]\n    if claimableAmount == 0:\n        return False, True\n\n    # check contract has enough balance\n    transferAmount: uint256 = min(claimableAmount, staticcall IERC20(_asset).balanceOf(self))\n    if transferAmount == 0:\n        return False, False\n\n    # transfer to user\n    if _ripeTeller != empty(address) and _asset == RIPE_TOKEN:\n        self._handleRipeRewards(_user, transferAmount, _ripeStakeRatio, _ripeLockDuration, _asset, _ripeTeller)\n    else:\n        assert extcall IERC20(_asset).transfer(_user, transferAmount, default_return_value=True) # dev: xfer fail\n\n    # update tracking\n    self.totalClaimableLoot[_asset] -= transferAmount\n    self.claimableLoot[_user][_asset] -= transferAmount\n\n    log LootClaimed(\n        user = _user,\n        asset = _asset,\n        amount = transferAmount,\n    )\n    return True, claimableAmount == transferAmount\n\n\n@view\n@external\ndef getClaimableLootForAsset(_user: address, _asset: address) -> uint256:\n    claimableAmount: uint256 = self.claimableLoot[_user][_asset]\n    return min(claimableAmount, staticcall IERC20(_asset).balanceOf(self))\n\n\n# claimable assets\n\n\n@view\n@external\ndef getTotalClaimableAssets(_user: address) -> uint256:\n    numAssets: uint256 = self.numClaimableAssets[_user]\n    if numAssets == 0:\n        return 0\n\n    totalAssets: uint256 = 0\n    for i: uint256 in range(1, numAssets, bound=max_value(uint256)):\n        asset: address = self.claimableAssets[_user][i]\n        if asset == empty(address):\n            continue\n\n        claimableAmount: uint256 = min(self.claimableLoot[_user][asset], staticcall IERC20(asset).balanceOf(self))\n        if claimableAmount != 0:\n            totalAssets += 1\n\n    return totalAssets\n\n\n# adjust loot (cheaters!)\n\n\n@external\ndef adjustLoot(_user: address, _asset: address, _newClaimable: uint256) -> bool:\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert not deptBasics.isPaused # dev: contract paused\n\n    # invalid inputs\n    if empty(address) in [_user, _asset]:\n        return False\n\n    # can only adjust down (not up)\n    claimableAmount: uint256 = self.claimableLoot[_user][_asset]\n    if claimableAmount == 0 or _newClaimable >= claimableAmount:\n        return False\n\n    # update claimable loot for user\n    self.claimableLoot[_user][_asset] = _newClaimable\n\n    # update total claimable loot\n    totalClaimableLoot: uint256 = self.totalClaimableLoot[_asset]\n    totalClaimableLoot -= claimableAmount\n    totalClaimableLoot += _newClaimable\n    self.totalClaimableLoot[_asset] = totalClaimableLoot\n\n    # deregister asset if necessary\n    if _newClaimable == 0:\n        self._deregisterClaimableAssetForUser(_user, _asset)\n\n    log LootAdjusted(user = _user, asset = _asset, newClaimable = _newClaimable)\n    return True\n\n\n#####################\n# Loot Registration #\n#####################\n\n\n# add loot to user\n\n\n@internal\ndef _addClaimableLootToUser(_user: address, _asset: address, _amount: uint256):\n    self.totalClaimableLoot[_asset] += _amount\n    self.claimableLoot[_user][_asset] += _amount\n    self._registerClaimableAssetForUser(_user, _asset)\n\n\n# register claimable asset\n\n\n@internal\ndef _registerClaimableAssetForUser(_user: address, _asset: address):\n    if self.indexOfClaimableAsset[_user][_asset] != 0:\n        return\n\n    aid: uint256 = self.numClaimableAssets[_user]\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.claimableAssets[_user][aid] = _asset\n    self.indexOfClaimableAsset[_user][_asset] = aid\n    self.numClaimableAssets[_user] = aid + 1\n\n\n# deregister asset\n\n\n@internal\ndef _deregisterClaimableAssetForUser(_user: address, _asset: address) -> bool:\n    numAssets: uint256 = self.numClaimableAssets[_user]\n    if numAssets == 0:\n        return False\n\n    targetIndex: uint256 = self.indexOfClaimableAsset[_user][_asset]\n    if targetIndex == 0:\n        return False\n\n    # update data\n    lastIndex: uint256 = numAssets - 1\n    self.numClaimableAssets[_user] = lastIndex\n    self.indexOfClaimableAsset[_user][_asset] = 0\n\n    # get last item, replace the removed item\n    if targetIndex != lastIndex:\n        lastItem: address = self.claimableAssets[_user][lastIndex]\n        self.claimableAssets[_user][targetIndex] = lastItem\n        self.indexOfClaimableAsset[_user][lastItem] = targetIndex\n\n    return True\n\n\n##################\n# Deposit Points #\n##################\n\n\n# update points\n\n\n@external\ndef updateDepositPoints(_user: address):\n    a: addys.Addys = addys._getAddys()\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert not deptBasics.isPaused # dev: contract paused\n    self._updateDepositPoints(_user, 0, False, a.ledger)\n\n\n@external\ndef updateDepositPointsWithNewValue(_user: address, _newUsdValue: uint256):\n    ledger: address = addys._getLedgerAddr()\n    if not staticcall Ledger(ledger).isUserWallet(msg.sender):\n        assert self._isValidWalletConfig(_user, msg.sender, ledger) # dev: invalid config\n\n    # if paused, fail gracefully\n    if deptBasics.isPaused:\n        return\n\n    self._updateDepositPoints(_user, _newUsdValue, True, ledger)\n\n\n@external\ndef updateDepositPointsOnEjection(_user: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    if deptBasics.isPaused:\n        return\n    self._updateDepositPoints(_user, 0, True, addys._getLedgerAddr())\n\n\n@internal\ndef _updateDepositPoints(\n    _user: address,\n    _newUsdValue: uint256,\n    _didUsdValueChange: bool,\n    _ledger: address,\n):\n    userPoints: PointsData = empty(PointsData)\n    globalPoints: PointsData = empty(PointsData)\n    userPoints, globalPoints = staticcall Ledger(_ledger).getUserAndGlobalPoints(_user)\n\n    prevUserValue: uint256 = userPoints.usdValue\n\n    # update user data\n    userPoints.depositPoints += self._getLatestDepositPoints(prevUserValue, userPoints.lastUpdate)\n    userPoints.lastUpdate = block.number\n    if _didUsdValueChange:\n        userPoints.usdValue = _newUsdValue\n\n    # update global data\n    globalPoints.depositPoints += self._getLatestDepositPoints(globalPoints.usdValue, globalPoints.lastUpdate)\n    globalPoints.lastUpdate = block.number\n    if _didUsdValueChange:\n        globalPoints.usdValue -= prevUserValue\n        globalPoints.usdValue += _newUsdValue\n\n    # save data\n    extcall Ledger(_ledger).setUserAndGlobalPoints(_user, userPoints, globalPoints)\n\n\n# latest points\n\n\n@view\n@external\ndef getLatestDepositPoints(_usdValue: uint256, _lastUpdate: uint256) -> uint256:\n    return self._getLatestDepositPoints(_usdValue, _lastUpdate)\n\n\n@view\n@internal\ndef _getLatestDepositPoints(_usdValue: uint256, _lastUpdate: uint256) -> uint256:\n    if _usdValue == 0 or _lastUpdate == 0 or block.number <= _lastUpdate:\n        return 0\n    points: uint256 = _usdValue * (block.number - _lastUpdate)\n    return points // EIGHTEEN_DECIMALS\n\n\n# validate wallet config\n\n\n@view\n@external\ndef isValidWalletConfig(_wallet: address, _caller: address) -> bool:\n    return self._isValidWalletConfig(_wallet, _caller, addys._getLedgerAddr())\n\n\n@view\n@internal\ndef _isValidWalletConfig(_wallet: address, _caller: address, _ledger: address) -> bool:\n    if not staticcall Ledger(_ledger).isUserWallet(_wallet):\n        return False\n    walletConfig: address = staticcall UserWallet(_wallet).walletConfig()\n    return walletConfig == _caller\n\n\n###################\n# Deposit Rewards #\n###################\n\n\n# claim deposit rewards\n\n\n@external\ndef claimDepositRewards(_user: address) -> uint256:\n    assert not deptBasics.isPaused # dev: contract paused\n    a: addys.Addys = addys._getAddys()\n\n    # cannot claim if this is not current loot distributor, likely migrated to new loot distributor\n    assert a.lootDistributor == self # dev: not current loot distributor\n\n    # permission check\n    assert self._validateCanClaimLoot(_user, msg.sender, a.ledger, a.missionControl) # dev: no perms\n\n    # ripe params\n    ripeTeller: address = staticcall Registry(RIPE_REGISTRY).getAddr(RIPE_TELLER_ID)\n    ripeLockDuration: uint256 = self.ripeLockDuration\n    ripeStakeRatio: uint256 = self.ripeStakeRatio\n\n    # claim rewards\n    userRewards: uint256 = self._claimDepositRewards(_user, ripeStakeRatio, ripeLockDuration, ripeTeller, a.ledger)\n    assert userRewards != 0 # dev: nothing to claim\n\n    self.lastClaim[_user] = block.number\n    return userRewards\n\n\n@internal\ndef _claimDepositRewards(\n    _user: address,\n    _ripeStakeRatio: uint256,\n    _ripeLockDuration: uint256,\n    _ripeTeller: address,\n    _ledger: address,\n) -> uint256:\n    self._updateDepositPoints(_user, 0, False, _ledger)\n\n    # get user and global points\n    userPoints: PointsData = empty(PointsData)\n    globalPoints: PointsData = empty(PointsData)\n    userPoints, globalPoints = staticcall Ledger(_ledger).getUserAndGlobalPoints(_user)\n    if userPoints.depositPoints == 0 or globalPoints.depositPoints == 0:\n        return 0\n\n    # check if there is anything available for rewards\n    data: DepositRewards = self.depositRewards\n    if data.asset == empty(address) or data.amount == 0:\n        return 0\n\n    # calculate user's share, transfer to user\n    availableRewards: uint256 = min(data.amount, staticcall IERC20(data.asset).balanceOf(self))\n    userRewards: uint256 = availableRewards * userPoints.depositPoints // globalPoints.depositPoints\n    if userRewards == 0:\n        return 0\n\n    # transfer to user\n    if _ripeTeller != empty(address) and data.asset == RIPE_TOKEN:\n        self._handleRipeRewards(_user, userRewards, _ripeStakeRatio, _ripeLockDuration, data.asset, _ripeTeller)\n    else:\n        assert extcall IERC20(data.asset).transfer(_user, userRewards, default_return_value=True) # dev: xfer fail\n\n    # save rewards data\n    data.amount -= userRewards\n    self.depositRewards = data\n\n    # save / update points\n    globalPoints.depositPoints -= userPoints.depositPoints\n    userPoints.depositPoints = 0\n    extcall Ledger(_ledger).setUserAndGlobalPoints(_user, userPoints, globalPoints)\n\n    log DepositRewardsClaimed(\n        user = _user,\n        asset = data.asset,\n        userRewards = userRewards,\n        remainingRewards = data.amount,\n    )\n    return userRewards\n\n\n@view\n@external\ndef getClaimableDepositRewards(_user: address) -> uint256:\n    userPoints: PointsData = empty(PointsData)\n    globalPoints: PointsData = empty(PointsData)\n    userPoints, globalPoints = staticcall Ledger(addys._getLedgerAddr()).getUserAndGlobalPoints(_user)\n\n    # get latest points\n    userPoints.depositPoints += self._getLatestDepositPoints(userPoints.usdValue, userPoints.lastUpdate)\n    globalPoints.depositPoints += self._getLatestDepositPoints(globalPoints.usdValue, globalPoints.lastUpdate)\n    if userPoints.depositPoints == 0 or globalPoints.depositPoints == 0:\n        return 0\n\n    # check if there is anything available for rewards\n    data: DepositRewards = self.depositRewards\n    if data.asset == empty(address) or data.amount == 0:\n        return 0\n\n    # calculate user's share\n    availableRewards: uint256 = min(data.amount, staticcall IERC20(data.asset).balanceOf(self))\n    userRewards: uint256 = availableRewards * userPoints.depositPoints // globalPoints.depositPoints\n    return userRewards\n\n\n# add rewards\n\n\n@external\ndef addDepositRewards(_asset: address, _amount: uint256):\n    assert not deptBasics.isPaused # dev: contract paused\n    a: addys.Addys = addys._getAddys()\n    depositRewardsAsset: address = staticcall MissionControl(a.missionControl).getDepositRewardsAsset() # dev: invalid asset\n    assert depositRewardsAsset == _asset # dev: invalid asset\n\n    data: DepositRewards = self.depositRewards\n    if data.asset != empty(address) and data.amount != 0:\n        # NOTE: if changing the rewards asset, need to recover the previous asset first (zero out the amount)\n        assert data.asset == depositRewardsAsset # dev: asset mismatch\n\n    # finalize amount\n    amount: uint256 = min(_amount, staticcall IERC20(depositRewardsAsset).balanceOf(msg.sender))\n    assert amount != 0 # dev: nothing to add\n    assert extcall IERC20(depositRewardsAsset).transferFrom(msg.sender, self, amount, default_return_value=True) # dev: transfer failed\n\n    # update data\n    data.asset = depositRewardsAsset\n    data.amount += amount\n    self.depositRewards = data\n\n    log DepositRewardsAdded(asset = depositRewardsAsset, addedAmount = amount, newTotalAmount = data.amount, adder = msg.sender)\n\n\n# recover deposit rewards\n\n\n@external\ndef recoverDepositRewards(_recipient: address):\n    assert not deptBasics.isPaused # dev: contract paused\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n\n    data: DepositRewards = self.depositRewards\n    assert data.asset != empty(address) # dev: nothing to recover\n    amount: uint256 = min(data.amount, staticcall IERC20(data.asset).balanceOf(self))\n    if amount != 0:\n        assert extcall IERC20(data.asset).transfer(_recipient, amount, default_return_value=True) # dev: recovery failed\n\n    self.depositRewards = empty(DepositRewards)\n    log DepositRewardsRecovered(asset=data.asset, recipient=_recipient, amount=amount)\n\n\n# handle ripe rewards\n\n\n@internal\ndef _handleRipeRewards(\n    _user: address,\n    _amount: uint256,\n    _ripeStakeRatio: uint256,\n    _ripeLockDuration: uint256,\n    _ripeToken: address,\n    _ripeTeller: address,\n):\n    # just transfer to user\n    if _ripeStakeRatio == 0:\n        assert extcall IERC20(_ripeToken).transfer(_user, _amount, default_return_value=True) # dev: xfer fail\n        return\n\n    # finalize amounts\n    amountToStake: uint256 = min(_amount * _ripeStakeRatio // HUNDRED_PERCENT, _amount)\n    amountToSend: uint256 = _amount - amountToStake\n\n    # stake ripe tokens\n    if amountToStake != 0:\n        assert extcall IERC20(_ripeToken).approve(_ripeTeller, amountToStake, default_return_value=True) # dev: ripe approval failed\n        extcall RipeTeller(_ripeTeller).depositIntoGovVault(_ripeToken, amountToStake, _ripeLockDuration, _user)\n        assert extcall IERC20(_ripeToken).approve(_ripeTeller, 0, default_return_value=True) # dev: ripe approval failed\n\n    # transfer ripe to user\n    if amountToSend != 0:\n        amount: uint256 = min(amountToSend, staticcall IERC20(_ripeToken).balanceOf(self))\n        assert extcall IERC20(_ripeToken).transfer(_user, amount, default_return_value=True) # dev: ripe transfer failed\n\n\n####################\n# Transaction Fees #\n####################\n\n\n@view\n@external\ndef getSwapFee(_user: address, _tokenIn: address, _tokenOut: address, _missionControl: address = empty(address)) -> uint256:\n    # NOTE: passing in `_user` in case we ever have different fees for different users in future\n\n    missionControl: address = _missionControl\n    if _missionControl == empty(address):\n        missionControl = addys._getMissionControlAddr()\n\n    return staticcall MissionControl(missionControl).getSwapFee(_tokenIn, _tokenOut)\n\n\n@view\n@external\ndef getRewardsFee(_user: address, _asset: address, _missionControl: address = empty(address)) -> uint256:\n    # NOTE: passing in `_user` in case we ever have different fees for different users in future\n\n    missionControl: address = _missionControl\n    if _missionControl == empty(address):\n        missionControl = addys._getMissionControlAddr()\n\n    return staticcall MissionControl(missionControl).getRewardsFee(_asset)\n\n\n#############\n# Utilities #\n#############\n\n\n# claim ALL loot (both rev share and deposit rewards)\n\n\n@external\ndef claimAllLoot(_user: address) -> bool:\n    assert not deptBasics.isPaused # dev: contract paused\n    a: addys.Addys = addys._getAddys()\n\n    # permission check\n    assert self._validateCanClaimLoot(_user, msg.sender, a.ledger, a.missionControl) # dev: no perms\n\n    # ripe params\n    ripeTeller: address = staticcall Registry(RIPE_REGISTRY).getAddr(RIPE_TELLER_ID)\n    ripeLockDuration: uint256 = self.ripeLockDuration\n    ripeStakeRatio: uint256 = self.ripeStakeRatio\n\n    # claim rev share and bonus loot\n    numAssetsClaimed: uint256 = self._claimRevShareAndBonusLoot(_user, ripeStakeRatio, ripeLockDuration, ripeTeller)\n\n    # can only claim rewards if this is current loot distributor\n    if a.lootDistributor == self:\n        userRewards: uint256 = self._claimDepositRewards(_user, ripeStakeRatio, ripeLockDuration, ripeTeller, a.ledger)\n        if userRewards != 0:\n            numAssetsClaimed += 1\n\n    # only save last claim block if there was something claimed\n    if numAssetsClaimed != 0:\n        self.lastClaim[_user] = block.number\n\n    return numAssetsClaimed != 0\n\n\n# validation\n\n\n@view\n@external\ndef validateCanClaimLoot(_user: address, _caller: address) -> bool:\n    a: addys.Addys = addys._getAddys()\n    return self._validateCanClaimLoot(_user, _caller, a.ledger, a.missionControl)\n\n\n@view\n@internal\ndef _validateCanClaimLoot(_user: address, _caller: address, _ledger: address, _missionControl: address) -> bool:\n    if not staticcall Ledger(_ledger).isUserWallet(_user):\n        return False\n\n    # cool off period\n    isSwitchboard: bool = addys._isSwitchboardAddr(_caller)\n    if not isSwitchboard:\n        lastClaimBlock: uint256 = self.lastClaim[_user]\n        coolOffPeriod: uint256 = staticcall MissionControl(_missionControl).getLootClaimCoolOffPeriod()\n        if lastClaimBlock != 0 and coolOffPeriod != 0:\n            if lastClaimBlock + coolOffPeriod > block.number:\n                return False\n\n    # lego check\n    if addys._isLegoBookAddr(_caller):\n        return True\n\n    # permission check\n    walletConfig: address = staticcall UserWallet(_user).walletConfig()\n    if _caller == staticcall UserWalletConfig(walletConfig).owner():\n        return True\n\n    # manager check\n    config: wcs.ManagerSettings = staticcall UserWalletConfig(walletConfig).managerSettings(_caller)\n    if config.canClaimLoot:\n        return True\n\n    return isSwitchboard\n\n\n# set ripe rewards config\n\n\n@external\ndef setRipeRewardsConfig(_ripeStakeRatio: uint256, _ripeLockDuration: uint256):\n    assert not deptBasics.isPaused # dev: contract paused\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert _ripeStakeRatio <= HUNDRED_PERCENT # dev: invalid stake ratio\n    assert _ripeLockDuration > 0 # dev: invalid lock duration\n    self.ripeStakeRatio = _ripeStakeRatio\n    self.ripeLockDuration = _ripeLockDuration\n    log RipeRewardsConfigSet(ripeStakeRatio=_ripeStakeRatio, ripeLockDuration=_ripeLockDuration)",
            "sha256sum": "0746b78045975fd0aea8fa3641bd31874e447cc7160938e132bce8ec8bc6312f"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/core/LootDistributor.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.3+commit.bff19ea2",
        "integrity": "b8361177daf5e6c49f7603fbc88c9608b5a225c0ce9b4bc938c7422ea3f30637"
      },
      "args": "00000000000000000000000044cf3c4f000dfd76a35d03298049d37be688d6f90000000000000000000000002a0a59d6b975828e781ecac125dba40d7ee5ddc00000000000000000000000006162df1b329e157479f8f1407e888260e0ec3d2b0000000000000000000000000000000000000000000000000000000000001f40000000000000000000000000000000000000000000000000000000000076a700",
      "file": "contracts/core/LootDistributor.vy"
    }
  }
}