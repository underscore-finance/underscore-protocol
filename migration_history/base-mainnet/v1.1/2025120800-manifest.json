{
  "contracts": {
    "RipeLego": {
      "address": "0x06Df9C710c96500D98f9eca1f838873e1Eb7e17F",
      "abi": [
        {
          "name": "RipeCollateralDeposit",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountDeposited",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultIdOrLock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "RipeCollateralWithdrawal",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "RipeBorrow",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountBorrowed",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "RipeRepay",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountRepaid",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "RipeClaimRewards",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "ripeClaimed",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "RipeSavingsGreenDeposit",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountDeposited",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultTokenAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "RipeSavingsGreenWithdrawal",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultTokenAmountBurned",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "RipeEndaomentPsmSwap",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenIn",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenOut",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amountIn",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "amountOut",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "numTokens",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LegoPauseModified",
          "inputs": [
            {
              "name": "isPaused",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LegoFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "balance",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "SnapShotPriceConfigSet",
          "inputs": [
            {
              "name": "minSnapshotDelay",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "maxNumSnapshots",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "maxUpsideDeviation",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "staleTime",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetOpportunityAdded",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultAddr",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetOpportunityRemoved",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultAddr",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PricePerShareSnapShotAdded",
          "inputs": [
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "totalSupply",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "pricePerShare",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "lastAveragePricePerShare",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddys",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "undyToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "hatchery",
                  "type": "address"
                },
                {
                  "name": "lootDistributor",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                },
                {
                  "name": "walletBackpack",
                  "type": "address"
                },
                {
                  "name": "billing",
                  "type": "address"
                },
                {
                  "name": "vaultRegistry",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUndyHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isLegoAsset",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssetOpportunities",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isAssetOpportunity",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getNumLegoAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pause",
          "inputs": [
            {
              "name": "_shouldPause",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFundsMany",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_assets",
              "type": "address[]"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getWeightedPricePerShare",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLatestSnapshot",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_pricePerShare",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "totalSupply",
                  "type": "uint256"
                },
                {
                  "name": "pricePerShare",
                  "type": "uint256"
                },
                {
                  "name": "lastUpdate",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setSnapShotPriceConfig",
          "inputs": [
            {
              "name": "_config",
              "type": "tuple",
              "components": [
                {
                  "name": "minSnapshotDelay",
                  "type": "uint256"
                },
                {
                  "name": "maxNumSnapshots",
                  "type": "uint256"
                },
                {
                  "name": "maxUpsideDeviation",
                  "type": "uint256"
                },
                {
                  "name": "staleTime",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidPriceConfig",
          "inputs": [
            {
              "name": "_config",
              "type": "tuple",
              "components": [
                {
                  "name": "minSnapshotDelay",
                  "type": "uint256"
                },
                {
                  "name": "maxNumSnapshots",
                  "type": "uint256"
                },
                {
                  "name": "maxUpsideDeviation",
                  "type": "uint256"
                },
                {
                  "name": "staleTime",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "vaultToAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "underlyingAsset",
                  "type": "address"
                },
                {
                  "name": "decimals",
                  "type": "uint256"
                },
                {
                  "name": "lastAveragePricePerShare",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assetOpportunities",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAssetOpportunity",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssetOpportunities",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assets",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "snapShotData",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "lastSnapShot",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "totalSupply",
                      "type": "uint256"
                    },
                    {
                      "name": "pricePerShare",
                      "type": "uint256"
                    },
                    {
                      "name": "lastUpdate",
                      "type": "uint256"
                    }
                  ]
                },
                {
                  "name": "nextIndex",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "snapShots",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "totalSupply",
                  "type": "uint256"
                },
                {
                  "name": "pricePerShare",
                  "type": "uint256"
                },
                {
                  "name": "lastUpdate",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "snapShotPriceConfig",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "minSnapshotDelay",
                  "type": "uint256"
                },
                {
                  "name": "maxNumSnapshots",
                  "type": "uint256"
                },
                {
                  "name": "maxUpsideDeviation",
                  "type": "uint256"
                },
                {
                  "name": "staleTime",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isPaused",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasCapability",
          "inputs": [
            {
              "name": "_action",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRegistries",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isYieldLego",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isDexLego",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAsset",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingBalances",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenBalance",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAmount",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAmountSafe",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenBalance",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingData",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingData",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            },
            {
              "name": "_appraiser",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValueOfVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValueOfVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            },
            {
              "name": "_appraiser",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isRebasing",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPricePerShare",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPricePerShare",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_decimals",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getVaultTokenAmount",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_assetAmount",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalAssets",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalBorrows",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAvailLiquidity",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUtilizationRatio",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isEligibleForYieldBonus",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getWithdrawalFees",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canRegisterVaultToken",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "registerVaultTokenLocally",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "underlyingAsset",
                  "type": "address"
                },
                {
                  "name": "decimals",
                  "type": "uint256"
                },
                {
                  "name": "lastAveragePricePerShare",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "deregisterVaultTokenLocally",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addPriceSnapshot",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositForYield",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositForYield",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawFromYield",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawFromYield",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_tokenPath",
              "type": "address[]"
            },
            {
              "name": "_poolPath",
              "type": "address[]"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_tokenPath",
              "type": "address[]"
            },
            {
              "name": "_poolPath",
              "type": "address[]"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_borrowAsset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_borrowAsset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_paymentAsset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_paymentAsset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "deleverageWithSpecificAssets",
          "inputs": [
            {
              "name": "_assets",
              "type": "tuple[]",
              "components": [
                {
                  "name": "vaultId",
                  "type": "uint256"
                },
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "targetRepayAmount",
                  "type": "uint256"
                }
              ]
            },
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "deleverageUser",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "deleverageUser",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_targetRepayAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimIncentives",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_proofs",
              "type": "bytes32[]"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimIncentives",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_proofs",
              "type": "bytes32[]"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasClaimableRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAccessForLego",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_action",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "string"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_tokenInAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_tokenInAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmMintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmMintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "RIPE_REGISTRY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "RIPE_GREEN_TOKEN",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "RIPE_SAVINGS_GREEN",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "RIPE_TOKEN",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "USDC",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_undyHq",
              "type": "address"
            },
            {
              "name": "_ripeRegistry",
              "type": "address"
            },
            {
              "name": "_usdc",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "interfaces/WalletStructs.vyi": {
            "content": "# @version 0.4.3\n\nflag ActionType:\n    TRANSFER\n    EARN_DEPOSIT\n    EARN_WITHDRAW\n    EARN_REBALANCE\n    SWAP\n    MINT_REDEEM\n    CONFIRM_MINT_REDEEM\n    ADD_COLLATERAL\n    REMOVE_COLLATERAL\n    BORROW\n    REPAY_DEBT\n    REWARDS\n    ETH_TO_WETH\n    WETH_TO_ETH\n    ADD_LIQ\n    REMOVE_LIQ\n    ADD_LIQ_CONC\n    REMOVE_LIQ_CONC\n    PAY_CHEQUE\n\nstruct WalletAssetData:\n    assetBalance: uint256\n    usdValue: uint256\n    isYieldAsset: bool\n    lastPricePerShare: uint256\n\nstruct ActionData:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    billing: address\n    vaultRegistry: address\n    wallet: address\n    walletConfig: address\n    walletOwner: address\n    inEjectMode: bool\n    isFrozen: bool\n    lastTotalUsdValue: uint256\n    signer: address\n    isManager: bool\n    legoId: uint256\n    legoAddr: address\n    eth: address\n    weth: address\n\nstruct MiniAddys:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    appraiser: address",
            "sha256sum": "466493c129135c95470aaf70eeddc936632f7b0f813396e5a7ddc03bea9da518"
          },
          "interfaces/LegoPartner.vyi": {
            "content": "# @version 0.4.3\n\nfrom interfaces import WalletStructs as ws\n\nMAX_TOKEN_PATH: constant(uint256) = 5\nMAX_RECOVER_ASSETS: constant(uint256) = 20\nMAX_PROOFS: constant(uint256) = 25\n\n@external\ndef addLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _tickLower: int24, _tickUpper: int24, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef addLiquidity(_pool: address, _tokenA: address, _tokenB: address, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _minLpAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (address, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef removeLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _liqToRemove: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef removeLiquidity(_pool: address, _tokenA: address, _tokenB: address, _lpToken: address, _lpAmount: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef mintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _tokenInAmount: uint256, _minAmountOut: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef swapTokens(_amountIn: uint256, _minAmountOut: uint256, _tokenPath: DynArray[address, MAX_TOKEN_PATH], _poolPath: DynArray[address, MAX_TOKEN_PATH - 1], _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256):\n    ...\n\n@external\ndef depositForYield(_asset: address, _amount: uint256, _vaultAddr: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef withdrawFromYield(_vaultToken: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef confirmMintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef borrow(_borrowAsset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef repayDebt(_paymentAsset: address, _paymentAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef claimIncentives(_user: address, _rewardToken: address, _rewardAmount: uint256, _proofs: DynArray[bytes32, MAX_PROOFS], _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef removeCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef addCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@view\n@external\ndef getAccessForLego(_user: address, _action: ws.ActionType) -> (address, String[64], uint256):\n    ...\n\n@view\n@external\ndef hasCapability(_action: ws.ActionType) -> bool:\n    ...\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    ...\n\n@view\n@external\ndef isYieldLego() -> bool:\n    ...\n\n@view\n@external\ndef isDexLego() -> bool:\n    ...\n\n\n# common\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "f2afb7bd72d4301aea77bbe4177b7ae954ba6f6b76af363965993eb92ad0b715"
          },
          "interfaces/LegoStructs.vyi": {
            "content": "# @version 0.4.3\n\nstruct VaultTokenInfo:\n    underlyingAsset: address\n    decimals: uint256\n    lastAveragePricePerShare: uint256\n\nstruct SnapShotPriceConfig:\n    minSnapshotDelay: uint256\n    maxNumSnapshots: uint256\n    maxUpsideDeviation: uint256\n    staleTime: uint256\n\nstruct SingleSnapShot:\n    totalSupply: uint256\n    pricePerShare: uint256\n    lastUpdate: uint256\n\nstruct SnapShotData:\n    lastSnapShot: SingleSnapShot\n    nextIndex: uint256\n",
            "sha256sum": "8ae48be17d812d57fbd671bbf0593e8abf175ad0924e47c5997823cac19ec806"
          },
          "interfaces/YieldLego.vyi": {
            "content": "# @version 0.4.3\n\nfrom interfaces import LegoStructs as ls\n\n\n###################\n# Underlying Data #\n###################\n\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    ...\n\n\n@view\n@external\ndef getUnderlyingBalances(_vaultToken: address, _vaultTokenBalance: uint256) -> (uint256, uint256):\n    ...\n\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    ...\n\n\n@view\n@external\ndef getUnderlyingAmountSafe(_vaultToken: address, _vaultTokenBalance: uint256) -> uint256:\n    ...\n\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> (address, uint256, uint256):\n    ...\n\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> uint256:\n    ...\n\n\n###############\n# Other Utils #\n###############\n\n\n@view\n@external\ndef isRebasing() -> bool:\n    ...\n\n\n@view\n@external\ndef getPricePerShare(_vaultToken: address, _decimals: uint256 = 0) -> uint256:\n    ...\n\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef canRegisterVaultToken(_asset: address, _vaultToken: address) -> bool:\n    ...\n\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef getUtilizationRatio(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef getAvailLiquidity(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef isEligibleForYieldBonus(_asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef getWithdrawalFees(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    ...\n\n\n###################\n# Yield Lego Data #\n###################\n\n\n@view\n@external\ndef isLegoAsset(_asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, 40]:\n    ...\n\n\n@view\n@external\ndef getAssets() -> DynArray[address, 20]:\n    ...\n\n\n@view\n@external\ndef isAssetOpportunity(_asset: address, _vaultAddr: address) -> bool:\n    ...\n\n\n@view\n@external\ndef getNumLegoAssets() -> uint256:\n    ...\n\n\n@view\n@external\ndef assets(_index: uint256) -> address:\n    ...\n\n\n@view\n@external\ndef indexOfAsset(_asset: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef numAssets() -> uint256:\n    ...\n\n\n@view\n@external\ndef assetOpportunities(_asset: address, _index: uint256) -> address:\n    ...\n\n\n@view\n@external\ndef indexOfAssetOpportunity(_asset: address, _vaultAddr: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef numAssetOpportunities(_asset: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef vaultToAsset(_vaultAddr: address) -> ls.VaultTokenInfo:\n    ...\n\n\n# price snapshots\n\n\n@external\ndef addPriceSnapshot(_vaultToken: address) -> bool:\n    ...\n\n\n@view\n@external\ndef snapShotPriceConfig() -> ls.SnapShotPriceConfig:\n    ...\n\n\n@view\n@external\ndef snapShotData(_vaultToken: address) -> ls.SnapShotData:\n    ...\n\n\n@view\n@external\ndef snapShots(_vaultToken: address, _index: uint256) -> ls.SingleSnapShot:\n    ...\n\n\n@view\n@external\ndef getWeightedPricePerShare(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef getLatestSnapshot(_vaultToken: address, _pricePerShare: uint256) -> ls.SingleSnapShot:\n    ...\n\n\n@external\ndef setSnapShotPriceConfig(_config: ls.SnapShotPriceConfig):\n    ...\n",
            "sha256sum": "db91c139f6018f5218b389d08c8703bc16fb994aa948805dbfea27e072f382ec"
          },
          "contracts/modules/Addys.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\ninterface UndyHq:\n    def isValidAddr(_addr: address) -> bool: view\n    def getAddr(_regId: uint256) -> address: view\n    def undyToken() -> address: view\n\ninterface Switchboard:\n    def isSwitchboardAddr(_addr: address) -> bool: view\n\ninterface LegoBook:\n    def isLegoAddr(_addr: address) -> bool: view\n\nstruct Addys:\n    hq: address\n    undyToken: address\n    ledger: address\n    missionControl: address\n    legoBook: address\n    switchboard: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    walletBackpack: address\n    billing: address\n    vaultRegistry: address\n\n# hq\nUNDY_HQ_FOR_ADDYS: immutable(address)\n\n# core addys\nLEDGER_ID: constant(uint256) = 1\nMISSION_CONTROL_ID: constant(uint256) = 2\nLEGO_BOOK_ID: constant(uint256) = 3\nSWITCHBOARD_ID: constant(uint256) = 4\nHATCHERY_ID: constant(uint256) = 5\nLOOT_DISTRIBUTOR_ID: constant(uint256) = 6\nAPPRAISER_ID: constant(uint256) = 7\nWALLET_BACKPACK_ID: constant(uint256) = 8\nBILLING_ID: constant(uint256) = 9\nVAULT_REGISTRY_ID: constant(uint256) = 10\n\n\n@deploy\ndef __init__(_undyHq: address):\n    assert _undyHq != empty(address) # dev: invalid undy hq\n    UNDY_HQ_FOR_ADDYS = _undyHq\n\n\n########\n# Core #\n########\n\n\n@view\n@external\ndef getAddys() -> Addys:\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _getAddys(_addys: Addys = empty(Addys)) -> Addys:\n    if _addys.hq != empty(address):\n        return _addys\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _generateAddys() -> Addys:\n    hq: address = UNDY_HQ_FOR_ADDYS\n    return Addys(\n        hq = hq,\n        undyToken = staticcall UndyHq(hq).undyToken(),\n        ledger = staticcall UndyHq(hq).getAddr(LEDGER_ID),\n        missionControl = staticcall UndyHq(hq).getAddr(MISSION_CONTROL_ID),\n        legoBook = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID),\n        switchboard = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID),\n        hatchery = staticcall UndyHq(hq).getAddr(HATCHERY_ID),\n        lootDistributor = staticcall UndyHq(hq).getAddr(LOOT_DISTRIBUTOR_ID),\n        appraiser = staticcall UndyHq(hq).getAddr(APPRAISER_ID),\n        walletBackpack = staticcall UndyHq(hq).getAddr(WALLET_BACKPACK_ID),\n        billing = staticcall UndyHq(hq).getAddr(BILLING_ID),\n        vaultRegistry = staticcall UndyHq(hq).getAddr(VAULT_REGISTRY_ID),\n    )\n\n\n##########\n# Tokens #\n##########\n\n\n@view\n@internal\ndef _getUndyToken() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).undyToken()\n\n\n###########\n# Helpers #\n###########\n\n\n# undy hq\n\n\n@view\n@external\ndef getUndyHq() -> address:\n    return self._getUndyHq()\n\n\n@view\n@internal\ndef _getUndyHq() -> address:\n    return UNDY_HQ_FOR_ADDYS\n\n\n# utils\n\n\n@view\n@internal\ndef _isValidUndyAddr(_addr: address, _hq: address = empty(address)) -> bool:\n    hq: address = _hq\n    if _hq == empty(address):\n        hq = UNDY_HQ_FOR_ADDYS\n    \n    # core departments\n    if staticcall UndyHq(hq).isValidAddr(_addr):\n        return True\n\n    # lego book\n    legoBook: address = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID)\n    if legoBook != empty(address) and staticcall LegoBook(legoBook).isLegoAddr(_addr):\n        return True\n\n    # switchboard config\n    switchboard: address = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID)\n    if switchboard != empty(address) and staticcall Switchboard(switchboard).isSwitchboardAddr(_addr):\n        return True\n\n    return False\n\n\n@view\n@internal\ndef _isSwitchboardAddr(_addr: address) -> bool:\n    switchboard: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n    if switchboard == empty(address):\n        return False\n    return staticcall Switchboard(switchboard).isSwitchboardAddr(_addr)\n\n\n@view\n@internal\ndef _isLegoBookAddr(_addr: address) -> bool:\n    legoBook: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n    if legoBook == empty(address):\n        return False\n    return staticcall LegoBook(legoBook).isLegoAddr(_addr)\n\n\n###############\n# Departments #\n###############\n\n\n# ledger\n\n\n@view\n@internal\ndef _getLedgerId() -> uint256:\n    return LEDGER_ID\n\n\n@view\n@internal\ndef _getLedgerAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEDGER_ID)\n\n\n# mission control\n\n\n@view\n@internal\ndef _getMissionControlId() -> uint256:\n    return MISSION_CONTROL_ID\n\n\n@view\n@internal\ndef _getMissionControlAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(MISSION_CONTROL_ID)\n\n\n# lego book\n\n\n@view\n@internal\ndef _getLegoBookId() -> uint256:\n    return LEGO_BOOK_ID\n\n\n@view\n@internal\ndef _getLegoBookAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n\n\n# switchboard\n\n\n@view\n@internal\ndef _getSwitchboardId() -> uint256:\n    return SWITCHBOARD_ID\n\n\n@view\n@internal\ndef _getSwitchboardAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n\n\n# hatchery\n\n\n@view\n@internal\ndef _getHatcheryId() -> uint256:\n    return HATCHERY_ID\n\n\n@view\n@internal\ndef _getHatcheryAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(HATCHERY_ID)\n\n\n# loot distributor\n\n\n@view\n@internal\ndef _getLootDistributorId() -> uint256:\n    return LOOT_DISTRIBUTOR_ID\n\n\n@view\n@internal\ndef _getLootDistributorAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LOOT_DISTRIBUTOR_ID)\n\n\n# appraiser\n\n\n@view\n@internal\ndef _getAppraiserId() -> uint256:\n    return APPRAISER_ID\n\n\n@view\n@internal\ndef _getAppraiserAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(APPRAISER_ID)\n\n\n# wallet backpack\n\n\n@view\n@internal\ndef _getWalletBackpackId() -> uint256:\n    return WALLET_BACKPACK_ID\n\n\n@view\n@internal\ndef _getWalletBackpackAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(WALLET_BACKPACK_ID)\n\n\n# billing\n\n\n@view\n@internal\ndef _getBillingId() -> uint256:\n    return BILLING_ID\n\n\n@view\n@internal\ndef _getBillingAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(BILLING_ID)\n\n\n# vault registry\n\n\n@view\n@internal\ndef _getVaultRegistryId() -> uint256:\n    return VAULT_REGISTRY_ID\n\n\n@view\n@internal\ndef _getVaultRegistryAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(VAULT_REGISTRY_ID)",
            "sha256sum": "4df6b72db9bb417d1af81660175be1450cfb7b3575f3d17a5b8a130bff87b781"
          },
          "contracts/modules/YieldLegoData.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nuses: addys\n\nimport contracts.modules.Addys as addys\n\nfrom interfaces import WalletStructs as ws\nfrom interfaces import LegoStructs as ls\nfrom ethereum.ercs import IERC20\nfrom ethereum.ercs import IERC20Detailed\n\nevent AssetOpportunityAdded:\n    asset: indexed(address)\n    vaultAddr: indexed(address)\n\nevent AssetOpportunityRemoved:\n    asset: indexed(address)\n    vaultAddr: indexed(address)\n\nevent LegoPauseModified:\n    isPaused: bool\n\nevent LegoFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    balance: uint256\n\nevent PricePerShareSnapShotAdded:\n    vaultToken: indexed(address)\n    totalSupply: uint256\n    pricePerShare: uint256\n    lastAveragePricePerShare: uint256\n\nevent SnapShotPriceConfigSet:\n    minSnapshotDelay: uint256\n    maxNumSnapshots: uint256\n    maxUpsideDeviation: uint256\n    staleTime: uint256\n\n# core\nvaultToAsset: public(HashMap[address, ls.VaultTokenInfo]) # vault addr -> data\n\n# asset opportunities\nassetOpportunities: public(HashMap[address, HashMap[uint256, address]]) # asset -> index -> vault addr\nindexOfAssetOpportunity: public(HashMap[address, HashMap[address, uint256]]) # asset -> vault addr -> index\nnumAssetOpportunities: public(HashMap[address, uint256]) # asset -> number of opportunities\n\n# lego assets (iterable)\nassets: public(HashMap[uint256, address]) # index -> asset\nindexOfAsset: public(HashMap[address, uint256]) # asset -> index\nnumAssets: public(uint256) # num assets\n\n# price snapshots\nsnapShotData: public(HashMap[address, ls.SnapShotData]) # vault token -> data\nsnapShots: public(HashMap[address, HashMap[uint256, ls.SingleSnapShot]]) # vault token -> index -> snapshot\nsnapShotPriceConfig: public(ls.SnapShotPriceConfig) # config\n\nisPaused: public(bool)\n\nMAX_VAULTS: constant(uint256) = 40\nMAX_ASSETS: constant(uint256) = 20\nMAX_RECOVER_ASSETS: constant(uint256) = 20\nONE_DAY_SECONDS: constant(uint256) = 60 * 60 * 24\nONE_WEEK_SECONDS: constant(uint256) = ONE_DAY_SECONDS * 7\nHUNDRED_PERCENT: constant(uint256) = 100_00\n\n\n@deploy\ndef __init__(_shouldPause: bool):\n    self.isPaused = _shouldPause\n    self.numAssets = 1 # not using 0 index\n\n    # default snapshot price config\n    self.snapShotPriceConfig = ls.SnapShotPriceConfig(\n        minSnapshotDelay = 60 * 10, # 10 minutes\n        maxNumSnapshots = 20,\n        maxUpsideDeviation = 10_00, # 10%\n        staleTime = ONE_DAY_SECONDS, # 1 day\n    )\n\n\n#########\n# Views #\n#########\n\n\n# is lego asset\n\n\n@view\n@external\ndef isLegoAsset(_asset: address) -> bool:\n    return self._isLegoAsset(_asset)\n\n\n@view\n@internal\ndef _isLegoAsset(_asset: address) -> bool:\n    return self.indexOfAsset[_asset] != 0\n\n\n# vault opportunities\n\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, MAX_VAULTS]:\n    numOpportunities: uint256 = self.numAssetOpportunities[_asset]\n    if numOpportunities == 0:\n        return []\n    opportunities: DynArray[address, MAX_VAULTS] = []\n    for i: uint256 in range(1, numOpportunities, bound=MAX_VAULTS):\n        opportunities.append(self.assetOpportunities[_asset][i])\n    return opportunities\n\n\n# all assets registered\n\n\n@view\n@external\ndef getAssets() -> DynArray[address, MAX_ASSETS]:\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return []\n    assets: DynArray[address, MAX_ASSETS] = []\n    for i: uint256 in range(1, numAssets, bound=MAX_ASSETS):\n        assets.append(self.assets[i])\n    return assets\n\n\n################\n# Registration #\n################\n\n\n@view\n@external\ndef isAssetOpportunity(_asset: address, _vaultAddr: address) -> bool:\n    return self._isAssetOpportunity(_asset, _vaultAddr)\n\n\n@view\n@internal\ndef _isAssetOpportunity(_asset: address, _vaultAddr: address) -> bool:\n    return self.indexOfAssetOpportunity[_asset][_vaultAddr] != 0\n\n\n# add asset opportunity\n\n\n@internal\ndef _addAssetOpportunity(_asset: address, _vaultAddr: address) -> ls.VaultTokenInfo:\n    if self.indexOfAssetOpportunity[_asset][_vaultAddr] != 0:\n        return self.vaultToAsset[_vaultAddr]\n\n    if empty(address) in [_asset, _vaultAddr]:\n        return empty(ls.VaultTokenInfo)\n\n    # add asset opportunity\n    aid: uint256 = self.numAssetOpportunities[_asset]\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.assetOpportunities[_asset][aid] = _vaultAddr\n    self.indexOfAssetOpportunity[_asset][_vaultAddr] = aid\n    self.numAssetOpportunities[_asset] = aid + 1\n\n    # add mapping\n    vaultInfo: ls.VaultTokenInfo = ls.VaultTokenInfo(\n        underlyingAsset = _asset,\n        decimals = convert(staticcall IERC20Detailed(_vaultAddr).decimals(), uint256),\n        lastAveragePricePerShare = 0,\n    )\n    self.vaultToAsset[_vaultAddr] = vaultInfo\n\n    # add asset\n    self._addAsset(_asset)\n\n    log AssetOpportunityAdded(asset=_asset, vaultAddr=_vaultAddr)\n    return vaultInfo\n\n\n# remove asset opportunity\n\n\n@internal\ndef _removeAssetOpportunity(_asset: address, _vaultAddr: address):\n    numOpportunities: uint256 = self.numAssetOpportunities[_asset]\n    if numOpportunities == 0:\n        return\n\n    targetIndex: uint256 = self.indexOfAssetOpportunity[_asset][_vaultAddr]\n    if targetIndex == 0:\n        return\n\n    # update data\n    lastIndex: uint256 = numOpportunities - 1\n    self.numAssetOpportunities[_asset] = lastIndex\n    self.indexOfAssetOpportunity[_asset][_vaultAddr] = 0\n\n    self.vaultToAsset[_vaultAddr] = empty(ls.VaultTokenInfo)\n\n    # clear all snapshot data for the vault token to prevent contamination on re-add\n    self.snapShotData[_vaultAddr] = empty(ls.SnapShotData)\n\n    # clear all historical snapshots\n    config: ls.SnapShotPriceConfig = self.snapShotPriceConfig\n    for i: uint256 in range(config.maxNumSnapshots, bound=max_value(uint256)):\n        if i >= config.maxNumSnapshots:\n            break\n        self.snapShots[_vaultAddr][i] = empty(ls.SingleSnapShot)\n\n    # shift to replace the removed one\n    if targetIndex != lastIndex:\n        lastVaultAddr: address = self.assetOpportunities[_asset][lastIndex]\n        self.assetOpportunities[_asset][targetIndex] = lastVaultAddr\n        self.indexOfAssetOpportunity[_asset][lastVaultAddr] = targetIndex\n\n    # remove asset\n    if lastIndex <= 1:\n        self._removeAsset(_asset)\n\n    log AssetOpportunityRemoved(asset=_asset, vaultAddr=_vaultAddr)\n\n\n# add asset\n\n\n@internal\ndef _addAsset(_asset: address):\n    if self.indexOfAsset[_asset] != 0:\n        return\n\n    aid: uint256 = self.numAssets\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.assets[aid] = _asset\n    self.indexOfAsset[_asset] = aid\n    self.numAssets = aid + 1\n\n\n# remove asset\n\n\n@internal\ndef _removeAsset(_asset: address):\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return\n\n    targetIndex: uint256 = self.indexOfAsset[_asset]\n    if targetIndex == 0:\n        return\n\n    # update data\n    lastIndex: uint256 = numAssets - 1\n    self.numAssets = lastIndex\n    self.indexOfAsset[_asset] = 0\n\n    # shift to replace the removed one\n    if targetIndex != lastIndex:\n        lastAsset: address = self.assets[lastIndex]\n        self.assets[targetIndex] = lastAsset\n        self.indexOfAsset[lastAsset] = targetIndex\n\n\n# num lego assets (true number, use `numAssets` for iteration)\n\n\n@view\n@external\ndef getNumLegoAssets() -> uint256:\n    return self._getNumLegoAssets()\n\n\n@view\n@internal\ndef _getNumLegoAssets() -> uint256:\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return 0\n    return numAssets - 1\n\n\n###########\n# General #\n###########\n\n\n# fill mini addys\n\n\n@view\n@internal\ndef _getMiniAddys(_miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> ws.MiniAddys:\n    if _miniAddys.ledger != empty(address):\n        return _miniAddys\n    return ws.MiniAddys(\n        ledger = addys._getLedgerAddr(),\n        missionControl = addys._getMissionControlAddr(),\n        legoBook = addys._getLegoBookAddr(),\n        appraiser = addys._getAppraiserAddr(),\n    )\n\n\n# activate\n\n\n@external\ndef pause(_shouldPause: bool):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert _shouldPause != self.isPaused # dev: no change\n    self.isPaused = _shouldPause\n    log LegoPauseModified(isPaused=_shouldPause)\n\n\n# recover funds\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    self._recoverFunds(_recipient, _asset)\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, MAX_RECOVER_ASSETS]):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    for a: address in _assets:\n        self._recoverFunds(_recipient, a)\n\n\n@internal\ndef _recoverFunds(_recipient: address, _asset: address):\n    assert empty(address) not in [_recipient, _asset] # dev: invalid recipient or asset\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    assert balance != 0 # dev: nothing to recover\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log LegoFundsRecovered(asset=_asset, recipient=_recipient, balance=balance)\n\n\n###################\n# Price Snapshots #\n###################\n\n\n# add price snapshot\n\n\n@internal\ndef _addPriceSnapshot(_vaultToken: address, _pricePerShare: uint256, _vaultTokenDecimals: uint256) -> bool:\n    config: ls.SnapShotPriceConfig = self.snapShotPriceConfig\n    if config.maxNumSnapshots == 0:\n        return False\n\n    data: ls.SnapShotData = self.snapShotData[_vaultToken]\n\n    # already have snapshot for this time\n    if data.lastSnapShot.lastUpdate == block.timestamp:\n        return False\n\n    # check if snapshot is too recent\n    if data.lastSnapShot.lastUpdate + config.minSnapshotDelay > block.timestamp:\n        return False\n\n    # create and store new snapshot\n    newSnapshot: ls.SingleSnapShot = self._getLatestSnapshot(_vaultToken, _pricePerShare, _vaultTokenDecimals, data.lastSnapShot, config)\n    data.lastSnapShot = newSnapshot\n    self.snapShots[_vaultToken][data.nextIndex] = newSnapshot\n\n    # update index\n    data.nextIndex += 1\n    if data.nextIndex >= config.maxNumSnapshots:\n        data.nextIndex = 0\n\n    # save snap shot data\n    self.snapShotData[_vaultToken] = data\n\n    # update cached weighted average price per share\n    lastAveragePricePerShare: uint256 = self._getWeightedPricePerShare(_vaultToken, _pricePerShare)\n    self.vaultToAsset[_vaultToken].lastAveragePricePerShare = lastAveragePricePerShare\n\n    log PricePerShareSnapShotAdded(\n        vaultToken = _vaultToken,\n        totalSupply = newSnapshot.totalSupply,\n        pricePerShare = newSnapshot.pricePerShare,\n        lastAveragePricePerShare = lastAveragePricePerShare,\n    )\n    return True\n\n\n# weighted price per share\n\n\n@view\n@external\ndef getWeightedPricePerShare(_vaultToken: address) -> uint256:\n    data: ls.SnapShotData = self.snapShotData[_vaultToken]\n    return self._getWeightedPricePerShare(_vaultToken, data.lastSnapShot.pricePerShare)\n\n\n@view\n@internal\ndef _getWeightedPricePerShare(_vaultToken: address, _lastPricePerShare: uint256) -> uint256:\n    config: ls.SnapShotPriceConfig = self.snapShotPriceConfig\n    if config.maxNumSnapshots == 0:\n        return 0\n\n    # calculate weighted average price using all valid snapshots\n    numerator: uint256 = 0\n    denominator: uint256 = 0\n    for i: uint256 in range(config.maxNumSnapshots, bound=max_value(uint256)):\n\n        snapShot: ls.SingleSnapShot = self.snapShots[_vaultToken][i]\n        if snapShot.pricePerShare == 0 or snapShot.totalSupply == 0 or snapShot.lastUpdate == 0:\n            continue\n\n        # too stale, skip\n        if config.staleTime != 0 and block.timestamp > snapShot.lastUpdate + config.staleTime:\n            continue\n\n        numerator += (snapShot.totalSupply * snapShot.pricePerShare)\n        denominator += snapShot.totalSupply\n\n    # weighted price per share\n    weightedPricePerShare: uint256 = 0\n    if numerator != 0:\n        weightedPricePerShare = numerator // denominator\n    else:\n        weightedPricePerShare = _lastPricePerShare\n\n    return weightedPricePerShare\n\n\n# latest snapshot\n\n\n@view\n@external\ndef getLatestSnapshot(_vaultToken: address, _pricePerShare: uint256) -> ls.SingleSnapShot:\n    data: ls.SnapShotData = self.snapShotData[_vaultToken]\n    config: ls.SnapShotPriceConfig = self.snapShotPriceConfig\n    vaultTokenDecimals: uint256 = self.vaultToAsset[_vaultToken].decimals\n    return self._getLatestSnapshot(_vaultToken, _pricePerShare, vaultTokenDecimals, data.lastSnapShot, config)\n\n\n@view\n@internal\ndef _getLatestSnapshot(\n    _vaultToken: address,\n    _pricePerShare: uint256,\n    _vaultTokenDecimals: uint256,\n    _lastSnapShot: ls.SingleSnapShot,\n    _config: ls.SnapShotPriceConfig,\n) -> ls.SingleSnapShot:\n\n    # total supply (adjusted)\n    totalSupply: uint256 = staticcall IERC20(_vaultToken).totalSupply() // (10 ** _vaultTokenDecimals)\n    if totalSupply == 0:\n        totalSupply = 1\n\n    # throttle upside (extra safety check)\n    pricePerShare: uint256 = self._throttleUpside(_pricePerShare, _lastSnapShot.pricePerShare, _config.maxUpsideDeviation)\n\n    return ls.SingleSnapShot(\n        totalSupply = totalSupply,\n        pricePerShare = pricePerShare,\n        lastUpdate = block.timestamp,\n    )\n\n\n@view\n@internal\ndef _throttleUpside(_newValue: uint256, _prevValue: uint256, _maxUpside: uint256) -> uint256:\n    if _maxUpside == 0 or _prevValue == 0 or _newValue == 0:\n        return _newValue\n    maxPricePerShare: uint256 = _prevValue + (_prevValue * _maxUpside // HUNDRED_PERCENT)\n    return min(_newValue, maxPricePerShare)\n\n\n# snapshot price config\n\n\n@external\ndef setSnapShotPriceConfig(_config: ls.SnapShotPriceConfig):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert self._isValidPriceConfig(_config) # dev: invalid config\n    self.snapShotPriceConfig = _config\n    log SnapShotPriceConfigSet(\n        minSnapshotDelay=_config.minSnapshotDelay,\n        maxNumSnapshots=_config.maxNumSnapshots,\n        maxUpsideDeviation=_config.maxUpsideDeviation,\n        staleTime=_config.staleTime\n    )\n\n\n@view\n@external\ndef isValidPriceConfig(_config: ls.SnapShotPriceConfig) -> bool:\n    return self._isValidPriceConfig(_config)\n\n\n@view\n@internal\ndef _isValidPriceConfig(_config: ls.SnapShotPriceConfig) -> bool:\n    if _config.minSnapshotDelay > ONE_WEEK_SECONDS:\n        return False\n    if _config.maxNumSnapshots == 0 or _config.maxNumSnapshots > 25:\n        return False\n    if _config.maxUpsideDeviation > HUNDRED_PERCENT:\n        return False\n    return _config.staleTime < ONE_WEEK_SECONDS",
            "sha256sum": "50440c96dc8a7af22e7ad927bb6d3e308f137d5d3632e633e084b05510c94c28"
          },
          "contracts/legos/RipeLego.vy": {
            "content": "#         _____   ____     _____       ______          ____            ______        _____           _____    \n#     ___|\\    \\ |    |___|\\    \\  ___|\\     \\        |    |       ___|\\     \\   ___|\\    \\     ____|\\    \\   \n#    |    |\\    \\|    |    |\\    \\|     \\     \\       |    |      |     \\     \\ /    /\\    \\   /     /\\    \\  \n#    |    | |    |    |    | |    |     ,_____/|      |    |      |     ,_____/|    |  |____| /     /  \\    \\ \n#    |    |/____/|    |    |/____/|     \\--'\\_|/      |    |  ____|     \\--'\\_|/    |    ____|     |    |    |\n#    |    |\\    \\|    |    ||    ||     /___/|        |    | |    |     /___/| |    |   |    |     |    |    |\n#    |    | |    |    |    ||____|/     \\____|\\       |    | |    |     \\____|\\|    |   |_,  |\\     \\  /    /|\n#    |____| |____|____|____|      |____ '     /|      |____|/____/|____ '     /|\\ ___\\___/  /| \\_____\\/____/ |\n#    |    | |    |    |    |      |    /_____/ |      |    |     ||    /_____/ | |   /____ / |\\ |    ||    | /\n#    |____| |____|____|____|      |____|     | /      |____|_____|/____|     | /\\|___|    | /  \\|____||____|/ \n#      \\(     )/   \\(   \\(          \\( |_____|/         \\(    )/    \\( |_____|/   \\( |____|/      \\(    )/    \n#       '     '     '    '           '    )/             '    '      '    )/       '   )/          '    '     \n#                                         '                               '            '                      \n#     \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n#     \u2551  ** Ripe Lego **                        \u2551\n#     \u2551  Integration with Ripe Protocol.        \u2551\n#     \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n#\n#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nimplements: Lego\nimplements: YieldLego\n\nexports: addys.__interface__\nexports: yld.__interface__\n\ninitializes: addys\ninitializes: yld[addys := addys]\n\nfrom interfaces import LegoPartner as Lego\nfrom interfaces import YieldLego as YieldLego\nfrom interfaces import WalletStructs as ws\nfrom interfaces import LegoStructs as ls\n\nimport contracts.modules.Addys as addys\nimport contracts.modules.YieldLegoData as yld\n\nfrom ethereum.ercs import IERC20\nfrom ethereum.ercs import IERC4626\nfrom ethereum.ercs import IERC20Detailed\n\ninterface RipeTeller:\n    def repay(_paymentAmount: uint256 = max_value(uint256), _user: address = msg.sender, _isPaymentSavingsGreen: bool = False, _shouldRefundSavingsGreen: bool = True) -> bool: nonpayable\n    def withdraw(_asset: address, _amount: uint256 = max_value(uint256), _user: address = msg.sender, _vaultAddr: address = empty(address), _vaultId: uint256 = 0) -> uint256: nonpayable\n    def deposit(_asset: address, _amount: uint256 = max_value(uint256), _user: address = msg.sender, _vaultAddr: address = empty(address), _vaultId: uint256 = 0) -> uint256: nonpayable\n    def borrow(_greenAmount: uint256 = max_value(uint256), _user: address = msg.sender, _wantsSavingsGreen: bool = True, _shouldEnterStabPool: bool = False) -> uint256: nonpayable\n    def deleverageWithSpecificAssets(_assets: DynArray[DeleverageAsset, MAX_DELEVERAGE_ASSETS], _user: address = msg.sender) -> uint256: nonpayable\n    def depositIntoGovVault(_asset: address, _amount: uint256, _lockDuration: uint256, _user: address = msg.sender) -> uint256: nonpayable\n    def deleverageUser(_user: address = msg.sender, _targetRepayAmount: uint256 = max_value(uint256)) -> uint256: nonpayable\n    def claimLoot(_user: address = msg.sender, _shouldStake: bool = True) -> uint256: nonpayable\n\ninterface Ledger:\n    def setVaultToken(_vaultToken: address, _legoId: uint256, _underlyingAsset: address, _decimals: uint256, _isRebasing: bool): nonpayable\n    def isRegisteredVaultToken(_vaultToken: address) -> bool: view\n    def isUserWallet(_user: address) -> bool: view\n\ninterface Registry:\n    def getRegId(_addr: address) -> uint256: view\n    def getAddr(_regId: uint256) -> address: view\n    def isValidAddr(_addr: address) -> bool: view\n\ninterface RipeRegistry:\n    def savingsGreen() -> address: view\n    def greenToken() -> address: view\n    def ripeToken() -> address: view\n\ninterface Appraiser:\n    def getUsdValue(_asset: address, _amount: uint256, _missionControl: address = empty(address), _legoBook: address = empty(address), _ledger: address = empty(address)) -> uint256: view\n    def getUnderlyingUsdValue(_asset: address, _amount: uint256) -> uint256: view\n\ninterface EndaomentPsm:\n    def redeemGreen(_paymentAmount: uint256 = max_value(uint256), _recipient: address = msg.sender, _isPaymentSavingsGreen: bool = False) -> uint256: nonpayable\n    def mintGreen(_usdcAmount: uint256 = max_value(uint256), _recipient: address = msg.sender, _wantsSavingsGreen: bool = False) -> uint256: nonpayable\n\ninterface RipeMissionControl:\n    def doesUndyLegoHaveAccess(_wallet: address, _legoAddr: address) -> bool: view\n\ninterface VaultRegistry:\n    def isEarnVault(_vaultAddr: address) -> bool: view\n\ninterface UserWalletConfig:\n    def isAgentSender(_addr: address) -> bool: view\n\ninterface UserWallet:\n    def walletConfig() -> address: view\n\ninterface LevgVault:\n    def indexOfManager(_manager: address) -> uint256: view\n\nstruct DeleverageAsset:\n    vaultId: uint256\n    asset: address\n    targetRepayAmount: uint256\n\nevent RipeCollateralDeposit:\n    sender: indexed(address)\n    asset: indexed(address)\n    assetAmountDeposited: uint256\n    vaultIdOrLock: uint256\n    usdValue: uint256\n    recipient: address\n\nevent RipeCollateralWithdrawal:\n    sender: indexed(address)\n    asset: indexed(address)\n    assetAmountReceived: uint256\n    vaultId: uint256\n    usdValue: uint256\n    recipient: address\n\nevent RipeBorrow:\n    sender: indexed(address)\n    asset: indexed(address)\n    assetAmountBorrowed: uint256\n    usdValue: uint256\n    recipient: address\n\nevent RipeRepay:\n    sender: indexed(address)\n    asset: indexed(address)\n    assetAmountRepaid: uint256\n    usdValue: uint256\n    recipient: address\n\nevent RipeClaimRewards:\n    sender: indexed(address)\n    asset: indexed(address)\n    ripeClaimed: uint256\n    usdValue: uint256\n    recipient: address\n\nevent RipeSavingsGreenDeposit:\n    sender: indexed(address)\n    asset: indexed(address)\n    vaultToken: indexed(address)\n    assetAmountDeposited: uint256\n    usdValue: uint256\n    vaultTokenAmountReceived: uint256\n    recipient: address\n\nevent RipeSavingsGreenWithdrawal:\n    sender: indexed(address)\n    asset: indexed(address)\n    vaultToken: indexed(address)\n    assetAmountReceived: uint256\n    usdValue: uint256\n    vaultTokenAmountBurned: uint256\n    recipient: address\n\nevent RipeEndaomentPsmSwap:\n    sender: indexed(address)\n    tokenIn: indexed(address)\n    tokenOut: indexed(address)\n    amountIn: uint256\n    amountOut: uint256\n    usdValue: uint256\n    numTokens: uint256\n    recipient: address\n\n# ripe addrs\nRIPE_REGISTRY: public(immutable(address))\nRIPE_GREEN_TOKEN: public(immutable(address))\nRIPE_SAVINGS_GREEN: public(immutable(address))\nRIPE_TOKEN: public(immutable(address))\nUSDC: public(immutable(address))\n\nRIPE_MISSION_CONTROL_ID: constant(uint256) = 5\nRIPE_TELLER_ID: constant(uint256) = 17\nRIPE_ENDAOMENT_PSM_ID: constant(uint256) = 22\n\nLEGO_ACCESS_ABI: constant(String[64]) = \"setUndyLegoAccess(address)\"\nMAX_TOKEN_PATH: constant(uint256) = 5\nMAX_PROOFS: constant(uint256) = 25\nMAX_DELEVERAGE_ASSETS: constant(uint256) = 25\n\n\n@deploy\ndef __init__(_undyHq: address, _ripeRegistry: address, _usdc: address):\n    addys.__init__(_undyHq)\n    yld.__init__(False)\n\n    assert _ripeRegistry != empty(address) # dev: invalid ripe registry\n    RIPE_REGISTRY = _ripeRegistry\n    RIPE_GREEN_TOKEN = staticcall RipeRegistry(RIPE_REGISTRY).greenToken()\n    RIPE_SAVINGS_GREEN = staticcall RipeRegistry(RIPE_REGISTRY).savingsGreen()\n    RIPE_TOKEN = staticcall RipeRegistry(RIPE_REGISTRY).ripeToken()\n\n    assert _usdc != empty(address) # dev: invalid usdc\n    USDC = _usdc\n\n\n@view\n@external\ndef hasCapability(_action: ws.ActionType) -> bool:\n    return _action in (\n        ws.ActionType.EARN_DEPOSIT | \n        ws.ActionType.EARN_WITHDRAW |\n        ws.ActionType.ADD_COLLATERAL |\n        ws.ActionType.REMOVE_COLLATERAL |\n        ws.ActionType.BORROW |\n        ws.ActionType.REPAY_DEBT |\n        ws.ActionType.REWARDS\n    )\n\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    return [RIPE_REGISTRY]\n\n\n@view\n@external\ndef isYieldLego() -> bool:\n    return True # savings green\n\n\n@view\n@external\ndef isDexLego() -> bool:\n    return False\n\n\n###################\n# Underlying Data #\n###################\n\n\n# underlying asset\n\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    return self._getUnderlyingAsset(_vaultToken)\n\n\n@view\n@internal\ndef _getUnderlyingAsset(_vaultToken: address) -> address:\n    asset: address = yld.vaultToAsset[_vaultToken].underlyingAsset\n    if asset != empty(address):\n        return asset\n    return RIPE_GREEN_TOKEN\n\n\n# underlying balances (both true and safe)\n\n\n@view\n@external\ndef getUnderlyingBalances(_vaultToken: address, _vaultTokenBalance: uint256) -> (uint256, uint256):\n    if _vaultTokenBalance == 0:\n        return 0, 0\n\n    trueUnderlying: uint256 = self._getUnderlyingAmount(_vaultToken, _vaultTokenBalance)\n    safeUnderlying: uint256 = self._getUnderlyingAmountSafe(_vaultToken, _vaultTokenBalance)\n    if safeUnderlying == 0:\n        safeUnderlying = trueUnderlying\n\n    return trueUnderlying, min(trueUnderlying, safeUnderlying)\n\n\n# underlying amount (true)\n\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    return self._getUnderlyingAmount(_vaultToken, _vaultTokenAmount)\n\n\n@view\n@internal\ndef _getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    return staticcall IERC4626(_vaultToken).convertToAssets(_vaultTokenAmount)\n\n\n# underlying amount (safe)\n\n\n@view\n@external\ndef getUnderlyingAmountSafe(_vaultToken: address, _vaultTokenBalance: uint256) -> uint256:\n    return self._getUnderlyingAmountSafe(_vaultToken, _vaultTokenBalance)\n\n\n@view\n@internal\ndef _getUnderlyingAmountSafe(_vaultToken: address, _vaultTokenBalance: uint256) -> uint256:\n    vaultInfo: ls.VaultTokenInfo = yld.vaultToAsset[_vaultToken]\n    if vaultInfo.decimals == 0:\n        return 0 # not registered\n\n    # safe underlying amount (using cached weighted average from snapshots)\n    return _vaultTokenBalance * vaultInfo.lastAveragePricePerShare // (10 ** vaultInfo.decimals)\n\n\n# underlying data (combined)\n\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> (address, uint256, uint256):\n    return self._getUnderlyingData(_vaultToken, _vaultTokenAmount, _appraiser)\n\n\n@view\n@internal\ndef _getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address) -> (address, uint256, uint256):\n    asset: address = self._getUnderlyingAsset(_vaultToken)\n    if asset == empty(address):\n        return empty(address), 0, 0 # invalid vault token\n    underlyingAmount: uint256 = self._getUnderlyingAmount(_vaultToken, _vaultTokenAmount)\n    usdValue: uint256 = self._getUsdValueViaAppraiser(asset, underlyingAmount, _appraiser)\n    return asset, underlyingAmount, usdValue\n\n\n# usd value\n\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> uint256:\n    return self._getUsdValueOfVaultToken(_vaultToken, _vaultTokenAmount, _appraiser)\n\n\n@view\n@internal\ndef _getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address) -> uint256:\n    return self._getUnderlyingData(_vaultToken, _vaultTokenAmount, _appraiser)[2]\n\n\n@view\n@internal\ndef _getUsdValueViaAppraiser(_asset: address, _amount: uint256, _appraiser: address) -> uint256:\n    appraiser: address = _appraiser\n    if _appraiser == empty(address):\n        appraiser = addys._getAppraiserAddr()\n    return staticcall Appraiser(appraiser).getUnderlyingUsdValue(_asset, _amount)\n\n\n###############\n# Other Utils #\n###############\n\n\n# basics\n\n\n@view\n@external\ndef isRebasing() -> bool:\n    return self._isRebasing()\n\n\n@view\n@internal\ndef _isRebasing() -> bool:\n    return False\n\n\n# price per share\n\n\n@view\n@external\ndef getPricePerShare(_vaultToken: address, _decimals: uint256 = 0) -> uint256:\n    decimals: uint256 = _decimals\n    if decimals == 0:\n        decimals = yld.vaultToAsset[_vaultToken].decimals\n    if decimals == 0:\n        decimals = convert(staticcall IERC20Detailed(_vaultToken).decimals(), uint256)\n    return self._getPricePerShare(_vaultToken, decimals)\n\n\n@view\n@internal\ndef _getPricePerShare(_vaultToken: address, _decimals: uint256) -> uint256:\n    return staticcall IERC4626(_vaultToken).convertToAssets(10 ** _decimals)\n\n\n# vault token amount\n\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    return staticcall IERC4626(_vaultToken).convertToShares(_assetAmount)\n\n\n# total assets\n\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    return staticcall IERC4626(_vaultToken).totalAssets()\n\n\n# total borrows\n\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    # no borrowing related to _vaultToken\n    return 0\n\n\n# avail liquidity\n\n\n@view\n@external\ndef getAvailLiquidity(_vaultToken: address) -> uint256:\n    return staticcall IERC4626(_vaultToken).totalAssets()\n\n\n# utilization\n\n\n@view\n@external\ndef getUtilizationRatio(_vaultToken: address) -> uint256:\n    # no borrowing related to _vaultToken\n    return 0\n\n\n# extras\n\n\n@view\n@external\ndef isEligibleForYieldBonus(_asset: address) -> bool:\n    return False\n\n\n@view\n@external\ndef getWithdrawalFees(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    return 0\n\n\n################\n# Registration #\n################\n\n\n# can vault be registered\n\n\n@view\n@external\ndef canRegisterVaultToken(_asset: address, _vaultToken: address) -> bool:\n    return self._canRegisterVaultToken(_asset, _vaultToken)\n\n\n@view\n@internal\ndef _canRegisterVaultToken(_asset: address, _vaultToken: address) -> bool:\n    if empty(address) in [_asset, _vaultToken]:\n        return False\n    return _asset == RIPE_GREEN_TOKEN and _vaultToken == RIPE_SAVINGS_GREEN\n\n\n# register vault token locally\n\n\n@external\ndef registerVaultTokenLocally(_asset: address, _vaultAddr: address) -> ls.VaultTokenInfo:\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert self._canRegisterVaultToken(_asset, _vaultAddr) # dev: cannot register vault token\n    assert not yld._isAssetOpportunity(_asset, _vaultAddr) # dev: already registered\n    vaultInfo: ls.VaultTokenInfo = self._registerVaultTokenLocally(_asset, _vaultAddr)\n    self._registerVaultTokenGlobally(_asset, _vaultAddr, vaultInfo.decimals, addys._getLedgerAddr(), addys._getLegoBookAddr())\n    return vaultInfo\n\n\n@internal\ndef _registerVaultTokenLocally(_asset: address, _vaultAddr: address) -> ls.VaultTokenInfo:\n    assert extcall IERC20(_asset).approve(_vaultAddr, max_value(uint256), default_return_value=True) # dev: max approval failed\n    vaultInfo: ls.VaultTokenInfo = yld._addAssetOpportunity(_asset, _vaultAddr)\n    assert vaultInfo.decimals != 0 # dev: invalid vault token\n    return vaultInfo\n\n\n# remove vault token locally\n\n\n@external\ndef deregisterVaultTokenLocally(_asset: address, _vaultAddr: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert yld._isAssetOpportunity(_asset, _vaultAddr) # dev: already registered\n    self._deregisterVaultTokenLocally(_asset, _vaultAddr)\n\n\n@internal\ndef _deregisterVaultTokenLocally(_asset: address, _vaultAddr: address):\n    assert extcall IERC20(_asset).approve(_vaultAddr, 0, default_return_value=True) # dev: max approval failed\n    yld._removeAssetOpportunity(_asset, _vaultAddr)\n\n\n# ledger registration\n\n\n@internal\ndef _registerVaultTokenGlobally(_underlyingAsset: address, _vaultToken: address, _decimals: uint256, _ledger: address, _legoBook: address):\n    if not staticcall Ledger(_ledger).isRegisteredVaultToken(_vaultToken):\n        legoId: uint256 = staticcall Registry(_legoBook).getRegId(self)\n        extcall Ledger(_ledger).setVaultToken(_vaultToken, legoId, _underlyingAsset, _decimals, self._isRebasing())\n\n\n#################\n# Yield Actions #\n#################\n\n\n# add price snapshot\n\n\n@external\ndef addPriceSnapshot(_vaultToken: address) -> bool:\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    vaultInfo: ls.VaultTokenInfo = yld.vaultToAsset[_vaultToken]\n    assert vaultInfo.decimals != 0 # dev: not registered\n    pricePerShare: uint256 = self._getPricePerShare(_vaultToken, vaultInfo.decimals)\n    return yld._addPriceSnapshot(_vaultToken, pricePerShare, vaultInfo.decimals)\n\n\n# deposit\n\n\n@external\ndef depositForYield(\n    _asset: address,\n    _amount: uint256,\n    _vaultAddr: address,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, address, uint256, uint256):\n    assert self._isAllowedToPerformAction(msg.sender) # dev: no perms\n    assert not yld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = yld._getMiniAddys(_miniAddys)\n    vaultInfo: ls.VaultTokenInfo = self._getVaultInfoOnDeposit(_asset, _vaultAddr, miniAddys.ledger, miniAddys.legoBook)\n\n    # pre balances\n    preLegoBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n\n    # transfer deposit asset to this contract\n    depositAmount: uint256 = min(_amount, staticcall IERC20(_asset).balanceOf(msg.sender))\n    assert depositAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_asset).transferFrom(msg.sender, self, depositAmount, default_return_value=True) # dev: transfer failed\n\n    # deposit assets into lego partner\n    vaultTokenAmountReceived: uint256 = extcall IERC4626(_vaultAddr).deposit(depositAmount, _recipient)\n    assert vaultTokenAmountReceived != 0 # dev: no vault tokens received\n\n    # refund if full deposit didn't get through\n    currentLegoBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    refundAssetAmount: uint256 = 0\n    if currentLegoBalance > preLegoBalance:\n        refundAssetAmount = currentLegoBalance - preLegoBalance\n        assert extcall IERC20(_asset).transfer(msg.sender, refundAssetAmount, default_return_value=True) # dev: transfer failed\n        depositAmount -= refundAssetAmount\n\n    usdValue: uint256 = staticcall Appraiser(miniAddys.appraiser).getUnderlyingUsdValue(_asset, depositAmount)\n    log RipeSavingsGreenDeposit(\n        sender = msg.sender,\n        asset = _asset,\n        vaultToken = _vaultAddr,\n        assetAmountDeposited = depositAmount,\n        usdValue = usdValue,\n        vaultTokenAmountReceived = vaultTokenAmountReceived,\n        recipient = _recipient,\n    )\n\n    # add price snapshot\n    pricePerShare: uint256 = self._getPricePerShare(_vaultAddr, vaultInfo.decimals)\n    yld._addPriceSnapshot(_vaultAddr, pricePerShare, vaultInfo.decimals)\n\n    return depositAmount, _vaultAddr, vaultTokenAmountReceived, usdValue\n\n\n# vault info on deposit\n\n\n@internal\ndef _getVaultInfoOnDeposit(_asset: address, _vaultAddr: address, _ledger: address, _legoBook: address) -> ls.VaultTokenInfo:\n    vaultInfo: ls.VaultTokenInfo = yld.vaultToAsset[_vaultAddr]\n    if vaultInfo.decimals == 0:\n        assert self._canRegisterVaultToken(_asset, _vaultAddr) # dev: cannot register vault token\n        vaultInfo = self._registerVaultTokenLocally(_asset, _vaultAddr)\n        self._registerVaultTokenGlobally(_asset, _vaultAddr, vaultInfo.decimals, _ledger, _legoBook)\n    else:\n        assert vaultInfo.underlyingAsset == _asset # dev: asset mismatch\n    return vaultInfo\n\n\n# withdraw\n\n\n@external\ndef withdrawFromYield(\n    _vaultToken: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, address, uint256, uint256):\n    assert self._isAllowedToPerformAction(msg.sender) # dev: no perms\n    assert not yld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = yld._getMiniAddys(_miniAddys)\n    vaultInfo: ls.VaultTokenInfo = self._getVaultInfoOnWithdrawal(_vaultToken, miniAddys.ledger, miniAddys.legoBook)\n\n    # pre balances\n    preLegoVaultBalance: uint256 = staticcall IERC20(_vaultToken).balanceOf(self)\n\n    # transfer vaults tokens to this contract\n    vaultTokenAmount: uint256 = min(_amount, staticcall IERC20(_vaultToken).balanceOf(msg.sender))\n    assert vaultTokenAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_vaultToken).transferFrom(msg.sender, self, vaultTokenAmount, default_return_value=True) # dev: transfer failed\n\n    # withdraw assets from lego partner\n    assetAmountReceived: uint256 = extcall IERC4626(_vaultToken).redeem(vaultTokenAmount, _recipient, self)\n    assert assetAmountReceived != 0 # dev: no asset amount received\n\n    # refund if full withdrawal didn't happen\n    currentLegoVaultBalance: uint256 = staticcall IERC20(_vaultToken).balanceOf(self)\n    refundVaultTokenAmount: uint256 = 0\n    if currentLegoVaultBalance > preLegoVaultBalance:\n        refundVaultTokenAmount = currentLegoVaultBalance - preLegoVaultBalance\n        assert extcall IERC20(_vaultToken).transfer(msg.sender, refundVaultTokenAmount, default_return_value=True) # dev: transfer failed\n        vaultTokenAmount -= refundVaultTokenAmount\n\n    usdValue: uint256 = staticcall Appraiser(miniAddys.appraiser).getUnderlyingUsdValue(vaultInfo.underlyingAsset, assetAmountReceived)\n    log RipeSavingsGreenWithdrawal(\n        sender = msg.sender,\n        asset = vaultInfo.underlyingAsset,\n        vaultToken = _vaultToken,\n        assetAmountReceived = assetAmountReceived,\n        usdValue = usdValue,\n        vaultTokenAmountBurned = vaultTokenAmount,\n        recipient = _recipient,\n    )\n\n    # add price snapshot\n    pricePerShare: uint256 = self._getPricePerShare(_vaultToken, vaultInfo.decimals)\n    yld._addPriceSnapshot(_vaultToken, pricePerShare, vaultInfo.decimals)\n\n    return vaultTokenAmount, vaultInfo.underlyingAsset, assetAmountReceived, usdValue\n\n\n# vault info on withdrawal\n\n\n@internal\ndef _getVaultInfoOnWithdrawal(_vaultAddr: address, _ledger: address, _legoBook: address) -> ls.VaultTokenInfo:\n    vaultInfo: ls.VaultTokenInfo = yld.vaultToAsset[_vaultAddr]\n    if vaultInfo.decimals == 0:\n        asset: address = staticcall IERC4626(_vaultAddr).asset()\n        assert self._canRegisterVaultToken(asset, _vaultAddr) # dev: cannot register vault token\n        vaultInfo = self._registerVaultTokenLocally(asset, _vaultAddr)\n        self._registerVaultTokenGlobally(asset, _vaultAddr, vaultInfo.decimals, _ledger, _legoBook)\n    return vaultInfo\n\n\n#################\n# Swaps via PSM #\n#################\n\n\n@external\ndef swapTokens(\n    _amountIn: uint256,\n    _minAmountOut: uint256,\n    _tokenPath: DynArray[address, MAX_TOKEN_PATH],\n    _poolPath: DynArray[address, MAX_TOKEN_PATH - 1],\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256):\n    assert not yld.isPaused # dev: paused\n    assert self._isAllowedToPerformAction(msg.sender) # dev: no perms\n    miniAddys: ws.MiniAddys = yld._getMiniAddys(_miniAddys)\n\n    assert len(_tokenPath) == 2 # dev: invalid token path\n    tokenIn: address = _tokenPath[0]\n    tokenOut: address = _tokenPath[1]\n    assert tokenIn != tokenOut # dev: same token\n\n    # must be GREEN and USDC\n    savingsGreen: address = RIPE_SAVINGS_GREEN\n    green: address = RIPE_GREEN_TOKEN\n    usdc: address = USDC\n    assert tokenIn in [green, savingsGreen, usdc] # dev: invalid tokens\n    assert tokenOut in [green, savingsGreen, usdc] # dev: invalid tokens\n\n    # prevent GREEN <-> SAVINGS_GREEN swaps (use depositForYield/withdrawFromYield instead)\n    bothAreGreenVariants: bool = (tokenIn in [green, savingsGreen]) and (tokenOut in [green, savingsGreen])\n    assert not bothAreGreenVariants # dev: cannot swap into or out of savings green\n\n    # pre balances\n    preLegoBalance: uint256 = staticcall IERC20(tokenIn).balanceOf(self)\n\n    # transfer swap asset to this contract\n    amountIn: uint256 = min(_amountIn, staticcall IERC20(tokenIn).balanceOf(msg.sender))\n    assert amountIn != 0 # dev: nothing to transfer\n    assert extcall IERC20(tokenIn).transferFrom(msg.sender, self, amountIn, default_return_value=True) # dev: transfer failed\n\n    # swap via endaoment psm\n    endaomentPsm: address = staticcall Registry(RIPE_REGISTRY).getAddr(RIPE_ENDAOMENT_PSM_ID)\n    assert extcall IERC20(tokenIn).approve(endaomentPsm, amountIn, default_return_value=True) # dev: approval failed\n\n    # swap GREEN -> USDC\n    amountOut: uint256 = 0\n    if tokenIn in [green, savingsGreen]:\n        amountOut = extcall EndaomentPsm(endaomentPsm).redeemGreen(amountIn, _recipient, tokenIn == savingsGreen)\n\n    # swap USDC -> GREEN\n    elif tokenIn == usdc:\n        amountOut = extcall EndaomentPsm(endaomentPsm).mintGreen(amountIn, _recipient, tokenOut == savingsGreen)\n\n    # reset approvals\n    assert extcall IERC20(tokenIn).approve(endaomentPsm, 0, default_return_value=True) # dev: approval failed\n\n    # refund if full swap didn't get through\n    currentLegoBalance: uint256 = staticcall IERC20(tokenIn).balanceOf(self)\n    refundAssetAmount: uint256 = 0\n    if currentLegoBalance > preLegoBalance:\n        refundAssetAmount = currentLegoBalance - preLegoBalance\n        assert extcall IERC20(tokenIn).transfer(msg.sender, refundAssetAmount, default_return_value=True) # dev: transfer failed\n        amountIn -= refundAssetAmount\n\n    # adjust min amount out\n    minAmountOut: uint256 = _minAmountOut\n    if amountIn < _amountIn and _amountIn != max_value(uint256):\n        minAmountOut = _minAmountOut * amountIn // _amountIn\n    assert amountOut >= minAmountOut # dev: min amount out not met\n\n    # get usd values\n    usdValue: uint256 = staticcall Appraiser(miniAddys.appraiser).getUsdValue(tokenIn, amountIn, miniAddys.missionControl, miniAddys.legoBook, miniAddys.ledger)\n    if usdValue == 0:\n        usdValue = staticcall Appraiser(miniAddys.appraiser).getUsdValue(tokenOut, amountOut, miniAddys.missionControl, miniAddys.legoBook, miniAddys.ledger)\n\n    log RipeEndaomentPsmSwap(\n        sender = msg.sender,\n        tokenIn = tokenIn,\n        tokenOut = tokenOut,\n        amountIn = amountIn,\n        amountOut = amountOut,\n        usdValue = usdValue,\n        numTokens = 2,\n        recipient = _recipient,\n    )\n    return amountIn, amountOut, usdValue\n\n\n###################\n# Debt Management #\n###################\n\n\n# add collateral on Ripe\n\n\n@external\ndef addCollateral(\n    _asset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    assert self._isAllowedToPerformAction(msg.sender) # dev: no perms\n    assert not yld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = yld._getMiniAddys(_miniAddys)\n\n    assert msg.sender == _recipient # dev: recipient must be caller\n\n    # pre balances\n    preLegoBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n\n    # transfer deposit asset to this contract\n    depositAmount: uint256 = min(_amount, staticcall IERC20(_asset).balanceOf(msg.sender))\n    assert depositAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_asset).transferFrom(msg.sender, self, depositAmount, default_return_value=True) # dev: transfer failed\n\n    vaultIdOrLock: uint256 = 0\n    if _extraData != empty(bytes32):\n        vaultIdOrLock = convert(_extraData, uint256)\n\n    # deposit into Ripe Protocol\n    teller: address = self._getRipeTellerAndApprove(_asset)\n    if _asset == RIPE_TOKEN:\n        depositAmount = extcall RipeTeller(teller).depositIntoGovVault(_asset, depositAmount, vaultIdOrLock, _recipient)\n    else:\n        depositAmount = extcall RipeTeller(teller).deposit(_asset, depositAmount, _recipient, empty(address), vaultIdOrLock)\n    self._resetTellerApproval(_asset, teller)\n\n    # refund if full deposit didn't get through\n    currentLegoBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    refundAssetAmount: uint256 = 0\n    if currentLegoBalance > preLegoBalance:\n        refundAssetAmount = currentLegoBalance - preLegoBalance\n        assert extcall IERC20(_asset).transfer(msg.sender, refundAssetAmount, default_return_value=True) # dev: transfer failed\n\n    usdValue: uint256 = staticcall Appraiser(miniAddys.appraiser).getUsdValue(_asset, depositAmount, miniAddys.missionControl, miniAddys.legoBook, miniAddys.ledger)\n    log RipeCollateralDeposit(\n        sender = msg.sender,\n        asset = _asset,\n        assetAmountDeposited = depositAmount,\n        vaultIdOrLock = vaultIdOrLock,\n        usdValue = usdValue,\n        recipient = _recipient,\n    )\n    return depositAmount, usdValue\n\n\n# remove collateral on ripe\n\n\n@external\ndef removeCollateral(\n    _asset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    assert self._isAllowedToPerformAction(msg.sender) # dev: no perms\n    assert not yld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = yld._getMiniAddys(_miniAddys)\n\n    assert msg.sender == _recipient # dev: recipient must be caller\n\n    vaultId: uint256 = 0\n    if _extraData != empty(bytes32):\n        vaultId = convert(_extraData, uint256)\n\n    # withdraw from Ripe Protocol\n    ripeHq: address = RIPE_REGISTRY\n    teller: address = staticcall Registry(ripeHq).getAddr(RIPE_TELLER_ID)\n    amountRemoved: uint256 = extcall RipeTeller(teller).withdraw(_asset, _amount, _recipient, empty(address), vaultId)\n    assert amountRemoved != 0 # dev: no asset amount received\n\n    usdValue: uint256 = staticcall Appraiser(miniAddys.appraiser).getUsdValue(_asset, amountRemoved, miniAddys.missionControl, miniAddys.legoBook, miniAddys.ledger)\n    log RipeCollateralWithdrawal(\n        sender = msg.sender,\n        asset = _asset,\n        assetAmountReceived = amountRemoved,\n        vaultId = vaultId,\n        usdValue = usdValue,\n        recipient = _recipient,\n    )\n    return amountRemoved, usdValue\n\n\n# borrow\n\n\n@external\ndef borrow(\n    _borrowAsset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    assert self._isAllowedToPerformAction(msg.sender) # dev: no perms\n    assert not yld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = yld._getMiniAddys(_miniAddys)\n\n    assert msg.sender == _recipient # dev: recipient must be caller\n\n    savingsGreen: address = RIPE_SAVINGS_GREEN\n    assert _borrowAsset in [RIPE_GREEN_TOKEN, savingsGreen] # dev: invalid borrow asset\n    wantsSavingsGreen: bool = _borrowAsset == savingsGreen\n\n    # Extract shouldEnterStabPool from extraData (1 bit in lowest position)\n    shouldEnterStabPool: bool = convert(convert(_extraData, uint256) & 1, bool)\n\n    # borrow from Ripe\n    teller: address = staticcall Registry(RIPE_REGISTRY).getAddr(RIPE_TELLER_ID)\n    borrowAmount: uint256 = extcall RipeTeller(teller).borrow(_amount, _recipient, wantsSavingsGreen, shouldEnterStabPool)\n    assert borrowAmount != 0 # dev: no borrow amount received\n\n    usdValue: uint256 = staticcall Appraiser(miniAddys.appraiser).getUnderlyingUsdValue(_borrowAsset, borrowAmount)\n    log RipeBorrow(\n        sender = msg.sender,\n        asset = _borrowAsset,\n        assetAmountBorrowed = borrowAmount,\n        usdValue = usdValue,\n        recipient = _recipient,\n    )\n    return borrowAmount, usdValue\n\n\n# repay debt\n\n\n@external\ndef repayDebt(\n    _paymentAsset: address,\n    _paymentAmount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    assert self._isAllowedToPerformAction(msg.sender) # dev: no perms\n    assert not yld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = yld._getMiniAddys(_miniAddys)\n\n    assert msg.sender == _recipient # dev: recipient must be caller\n\n    savingsGreen: address = RIPE_SAVINGS_GREEN\n    assert _paymentAsset in [RIPE_GREEN_TOKEN, savingsGreen] # dev: invalid payment asset\n    isPaymentSavingsGreen: bool = _paymentAsset == savingsGreen\n\n    # pre balances\n    preLegoBalance: uint256 = staticcall IERC20(_paymentAsset).balanceOf(self)\n\n    # transfer deposit asset to this contract\n    paymentAmount: uint256 = min(_paymentAmount, staticcall IERC20(_paymentAsset).balanceOf(msg.sender))\n    assert paymentAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_paymentAsset).transferFrom(msg.sender, self, paymentAmount, default_return_value=True) # dev: transfer failed\n\n    # deposit into Ripe Protocol\n    teller: address = self._getRipeTellerAndApprove(_paymentAsset)\n    extcall RipeTeller(teller).repay(paymentAmount, _recipient, isPaymentSavingsGreen, True)\n    self._resetTellerApproval(_paymentAsset, teller)\n\n    # refund if full deposit didn't get through\n    currentLegoBalance: uint256 = staticcall IERC20(_paymentAsset).balanceOf(self)\n    refundAssetAmount: uint256 = 0\n    if currentLegoBalance > preLegoBalance:\n        refundAssetAmount = currentLegoBalance - preLegoBalance\n        assert extcall IERC20(_paymentAsset).transfer(msg.sender, refundAssetAmount, default_return_value=True) # dev: transfer failed\n\n    usdValue: uint256 = staticcall Appraiser(miniAddys.appraiser).getUsdValue(_paymentAsset, paymentAmount, miniAddys.missionControl, miniAddys.legoBook, miniAddys.ledger)\n    log RipeRepay(\n        sender = msg.sender,\n        asset = _paymentAsset,\n        assetAmountRepaid = paymentAmount,\n        usdValue = usdValue,\n        recipient = _recipient,\n    )\n    return paymentAmount, usdValue\n\n\n# deleverage\n\n\n@external\ndef deleverageWithSpecificAssets(_assets: DynArray[DeleverageAsset, MAX_DELEVERAGE_ASSETS], _user: address) -> uint256:\n    assert self._canCallDeleverage(_user, msg.sender) # dev: no perms\n    teller: address = staticcall Registry(RIPE_REGISTRY).getAddr(RIPE_TELLER_ID)\n    return extcall RipeTeller(teller).deleverageWithSpecificAssets(_assets, _user)\n\n\n@external\ndef deleverageUser(_user: address, _targetRepayAmount: uint256 = max_value(uint256)) -> uint256:\n    assert self._canCallDeleverage(_user, msg.sender) # dev: no perms\n    teller: address = staticcall Registry(RIPE_REGISTRY).getAddr(RIPE_TELLER_ID)\n    return extcall RipeTeller(teller).deleverageUser(_user, _targetRepayAmount)\n\n\n# shared utils\n\n\n@internal\ndef _getRipeTellerAndApprove(_asset: address) -> address:\n    teller: address = staticcall Registry(RIPE_REGISTRY).getAddr(RIPE_TELLER_ID)\n    # some vault tokens require max value approval (comp v3)\n    assert extcall IERC20(_asset).approve(teller, max_value(uint256), default_return_value = True) # dev: appr\n    return teller\n\n\n@internal\ndef _resetTellerApproval(_asset: address, _teller: address):\n    if _teller != empty(address):\n        assert extcall IERC20(_asset).approve(_teller, 0, default_return_value = True) # dev: approval failed\n\n\n@view\n@internal\ndef _isUserWalletOrEarnVault(_user: address) -> bool:\n    return staticcall Ledger(addys._getLedgerAddr()).isUserWallet(_user) or staticcall VaultRegistry(addys._getVaultRegistryAddr()).isEarnVault(_user)\n\n\n@view\n@internal\ndef _canCallDeleverage(_user: address, _caller: address) -> bool:\n\n    # user wallets\n    if staticcall Ledger(addys._getLedgerAddr()).isUserWallet(_user):\n        walletConfig: address = staticcall UserWallet(_user).walletConfig()\n        return staticcall UserWalletConfig(walletConfig).isAgentSender(_caller)\n\n    # earn vaults\n    if staticcall VaultRegistry(addys._getVaultRegistryAddr()).isEarnVault(_user):\n        return staticcall LevgVault(_user).indexOfManager(_caller) != 0\n\n    return False\n\n\n#################\n# Claim Rewards #\n#################\n\n\n@external\ndef claimIncentives(\n    _user: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _proofs: DynArray[bytes32, MAX_PROOFS],\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    assert self._isAllowedToPerformAction(msg.sender) # dev: no perms\n    return self._claimRewards(_user, _rewardToken, _rewardAmount, _miniAddys)\n\n\n@external\ndef claimRewards(\n    _user: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _extraData: bytes32,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    assert self._isAllowedToPerformAction(msg.sender) # dev: no perms\n    return self._claimRewards(_user, _rewardToken, _rewardAmount, _miniAddys)\n\n\n@internal\ndef _claimRewards(\n    _user: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _miniAddys: ws.MiniAddys,\n) -> (uint256, uint256):\n    miniAddys: ws.MiniAddys = yld._getMiniAddys(_miniAddys)\n    assert not yld.isPaused # dev: paused\n    assert _rewardToken == RIPE_TOKEN # dev: invalid reward token\n\n    teller: address = staticcall Registry(RIPE_REGISTRY).getAddr(RIPE_TELLER_ID)\n    totalRipe: uint256 = extcall RipeTeller(teller).claimLoot(_user, True)\n    assert totalRipe != 0 # dev: no ripe tokens received\n\n    usdValue: uint256 = staticcall Appraiser(miniAddys.appraiser).getUnderlyingUsdValue(_rewardToken, totalRipe)\n    log RipeClaimRewards(\n        sender = msg.sender,\n        asset = _rewardToken,\n        ripeClaimed = totalRipe,\n        usdValue = usdValue,\n        recipient = _user,\n    )\n    return 0, usdValue\n\n\n# has claimable rewards\n\n\n@view\n@external\ndef hasClaimableRewards(_user: address) -> bool:\n    # TODO: implement\n    return False\n\n\n##################\n# Access Control #\n##################\n\n\n@view\n@internal\ndef _isAllowedToPerformAction(_caller: address) -> bool:\n    # NOTE: important to not trust `_miniAddys` here, that's why getting ledger and vault registry from addys\n    if staticcall VaultRegistry(addys._getVaultRegistryAddr()).isEarnVault(_caller):\n        return True\n    if staticcall Ledger(addys._getLedgerAddr()).isUserWallet(_caller):\n        return True\n    return staticcall Registry(RIPE_REGISTRY).isValidAddr(_caller) # Ripe Endaoment is allowed\n\n\n@view\n@external\ndef getAccessForLego(_user: address, _action: ws.ActionType) -> (address, String[64], uint256):\n    ripeHq: address = RIPE_REGISTRY\n\n    mc: address = staticcall Registry(ripeHq).getAddr(RIPE_MISSION_CONTROL_ID)\n    if staticcall RipeMissionControl(mc).doesUndyLegoHaveAccess(_user, self):\n        return empty(address), empty(String[64]), 0\n\n    else:\n        teller: address = staticcall Registry(ripeHq).getAddr(RIPE_TELLER_ID)\n        return teller, LEGO_ACCESS_ABI, 1\n\n\n#########\n# Other #\n#########\n\n\n@external\ndef mintOrRedeemAsset(\n    _tokenIn: address,\n    _tokenOut: address,\n    _tokenInAmount: uint256,\n    _minAmountOut: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, bool, uint256):\n    return 0, 0, False, 0\n\n\n@external\ndef confirmMintOrRedeemAsset(\n    _tokenIn: address,\n    _tokenOut: address,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef addLiquidity(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _amountA: uint256,\n    _amountB: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _minLpAmount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (address, uint256, uint256, uint256, uint256):\n    return empty(address), 0, 0, 0, 0\n\n\n@external\ndef removeLiquidity(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpToken: address,\n    _lpAmount: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, uint256):\n    return 0, 0, 0, 0\n\n\n@external\ndef addLiquidityConcentrated(\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _tickLower: int24,\n    _tickUpper: int24,\n    _amountA: uint256,\n    _amountB: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, uint256, uint256):\n    return 0, 0, 0, 0, 0\n\n\n@external\ndef removeLiquidityConcentrated(\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _liqToRemove: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, bool, uint256):\n    return 0, 0, 0, False, 0\n",
            "sha256sum": "1bb52befcb855046ab5761cab84ba1a0c54fc48cb4b4fb259e5054cccc1bc02c"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/legos/RipeLego.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.3+commit.bff19ea2",
        "integrity": "136b79ddebc69654b12ab93a2d9c4eaa7d1ed7132f265bc62ae4058e4eb0a846"
      },
      "args": "00000000000000000000000044cf3c4f000dfd76a35d03298049d37be688d6f90000000000000000000000006162df1b329e157479f8f1407e888260e0ec3d2b000000000000000000000000833589fcd6edb6e08f4c7c32d4f71b54bda02913",
      "file": "contracts/legos/RipeLego.vy"
    }
  }
}