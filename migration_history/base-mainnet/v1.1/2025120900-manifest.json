{
  "contracts": {
    "DefaultsBase": {
      "address": "0xdd1b957934efecE6b1097f3e4a5DC5cFb89b5f5d",
      "abi": [
        {
          "stateMutability": "view",
          "type": "function",
          "name": "userWalletConfig",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "walletTemplate",
                  "type": "address"
                },
                {
                  "name": "configTemplate",
                  "type": "address"
                },
                {
                  "name": "numUserWalletsAllowed",
                  "type": "uint256"
                },
                {
                  "name": "enforceCreatorWhitelist",
                  "type": "bool"
                },
                {
                  "name": "minKeyActionTimeLock",
                  "type": "uint256"
                },
                {
                  "name": "maxKeyActionTimeLock",
                  "type": "uint256"
                },
                {
                  "name": "depositRewardsAsset",
                  "type": "address"
                },
                {
                  "name": "lootClaimCoolOffPeriod",
                  "type": "uint256"
                },
                {
                  "name": "txFees",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "swapFee",
                      "type": "uint256"
                    },
                    {
                      "name": "stableSwapFee",
                      "type": "uint256"
                    },
                    {
                      "name": "rewardsFee",
                      "type": "uint256"
                    }
                  ]
                },
                {
                  "name": "ambassadorRevShare",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "swapRatio",
                      "type": "uint256"
                    },
                    {
                      "name": "rewardsRatio",
                      "type": "uint256"
                    },
                    {
                      "name": "yieldRatio",
                      "type": "uint256"
                    }
                  ]
                },
                {
                  "name": "yieldConfig",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "maxYieldIncrease",
                      "type": "uint256"
                    },
                    {
                      "name": "performanceFee",
                      "type": "uint256"
                    },
                    {
                      "name": "ambassadorBonusRatio",
                      "type": "uint256"
                    },
                    {
                      "name": "bonusRatio",
                      "type": "uint256"
                    },
                    {
                      "name": "bonusAsset",
                      "type": "address"
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "agentConfig",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "startingAgent",
                  "type": "address"
                },
                {
                  "name": "startingAgentActivationLength",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "managerConfig",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "managerPeriod",
                  "type": "uint256"
                },
                {
                  "name": "managerActivationLength",
                  "type": "uint256"
                },
                {
                  "name": "mustHaveUsdValueOnSwaps",
                  "type": "bool"
                },
                {
                  "name": "maxNumSwapsPerPeriod",
                  "type": "uint256"
                },
                {
                  "name": "maxSlippageOnSwaps",
                  "type": "uint256"
                },
                {
                  "name": "onlyApprovedYieldOpps",
                  "type": "bool"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "payeeConfig",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "payeePeriod",
                  "type": "uint256"
                },
                {
                  "name": "payeeActivationLength",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "chequeConfig",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "maxNumActiveCheques",
                  "type": "uint256"
                },
                {
                  "name": "instantUsdThreshold",
                  "type": "uint256"
                },
                {
                  "name": "periodLength",
                  "type": "uint256"
                },
                {
                  "name": "expensiveDelayBlocks",
                  "type": "uint256"
                },
                {
                  "name": "defaultExpiryBlocks",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ripeRewardsConfig",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "stakeRatio",
                  "type": "uint256"
                },
                {
                  "name": "lockDuration",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "securitySigners",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "whitelistedCreators",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "interfaces/ConfigStructs.vyi": {
            "content": "# @version 0.4.3\n\nstruct UserWalletConfig:\n    walletTemplate: address\n    configTemplate: address\n    numUserWalletsAllowed: uint256\n    enforceCreatorWhitelist: bool\n    minKeyActionTimeLock: uint256\n    maxKeyActionTimeLock: uint256\n    depositRewardsAsset: address\n    lootClaimCoolOffPeriod: uint256\n    txFees: TxFees\n    ambassadorRevShare: AmbassadorRevShare\n    yieldConfig: YieldConfig\n\nstruct AssetConfig:\n    hasConfig: bool\n    txFees: TxFees\n    ambassadorRevShare: AmbassadorRevShare\n    yieldConfig: YieldConfig\n\nstruct TxFees:\n    swapFee: uint256\n    stableSwapFee: uint256\n    rewardsFee: uint256\n\nstruct AmbassadorRevShare:\n    swapRatio: uint256\n    rewardsRatio: uint256\n    yieldRatio: uint256\n\nstruct YieldConfig:\n    maxYieldIncrease: uint256\n    performanceFee: uint256\n    ambassadorBonusRatio: uint256\n    bonusRatio: uint256\n    bonusAsset: address\n\nstruct AgentConfig:\n    startingAgent: address\n    startingAgentActivationLength: uint256\n\nstruct ManagerConfig:\n    managerPeriod: uint256\n    managerActivationLength: uint256\n    mustHaveUsdValueOnSwaps: bool\n    maxNumSwapsPerPeriod: uint256\n    maxSlippageOnSwaps: uint256\n    onlyApprovedYieldOpps: bool\n\nstruct PayeeConfig:\n    payeePeriod: uint256\n    payeeActivationLength: uint256\n\nstruct ChequeConfig:\n    maxNumActiveCheques: uint256\n    instantUsdThreshold: uint256\n    periodLength: uint256\n    expensiveDelayBlocks: uint256\n    defaultExpiryBlocks: uint256\n\nstruct RipeRewardsConfig:\n    stakeRatio: uint256\n    lockDuration: uint256",
            "sha256sum": "4a631b60c85398adcd4e8174532e69540dd8df9afff85b0876f3feeae196af74"
          },
          "interfaces/Defaults.vyi": {
            "content": "# @version 0.4.3\n\nimport interfaces.ConfigStructs as cs\n\n\n@view\n@external\ndef userWalletConfig() -> cs.UserWalletConfig:\n    ...\n\n\n@view\n@external\ndef agentConfig() -> cs.AgentConfig:\n    ...\n\n\n@view\n@external\ndef managerConfig() -> cs.ManagerConfig:\n    ...\n\n\n@view\n@external\ndef payeeConfig() -> cs.PayeeConfig:\n    ...\n\n\n\n@view\n@external\ndef chequeConfig() -> cs.ChequeConfig:\n    ...\n\n\n@view\n@external\ndef ripeRewardsConfig() -> cs.RipeRewardsConfig:\n    ...\n\n\n# security signers\n\n\n@view\n@external\ndef securitySigners() -> DynArray[address, 10]:\n    ...\n\n\n# whitelisted creators\n\n\n@view\n@external\ndef whitelistedCreators() -> DynArray[address, 50]:\n    ...",
            "sha256sum": "c67ee89c0075a08dbf030e76f9818aadd6a3c6b4a7fecb87038aa8ea1ec128ee"
          },
          "contracts/config/DefaultsBase.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nimplements: Defaults\nfrom interfaces import Defaults\nimport interfaces.ConfigStructs as cs\n\nEIGHTEEN_DECIMALS: constant(uint256) = 10 ** 18\n\n# blocks\nDAY_IN_BLOCKS: constant(uint256) = 43_200\nWEEK_IN_BLOCKS: constant(uint256) = 7 * DAY_IN_BLOCKS\nMONTH_IN_BLOCKS: constant(uint256) = 30 * DAY_IN_BLOCKS\nYEAR_IN_BLOCKS: constant(uint256) = 365 * DAY_IN_BLOCKS\n\n# user wallet templates\nUSER_WALLET_TEMPLATE: constant(address) = 0x880E453Ec494FB17bffba537BeaB4Cc6CD1B7C12\nUSER_WALLET_CONFIG_TEMPLATE: constant(address) = 0xbF7bAdf4c71102cA49b3f82D50348256cE6C10Fb\n\n# agent\nSTARTING_AGENT: constant(address) = 0x761fCDFfF8B187901eA11415237632A3F7E0203B\nWALLET_CREATOR: constant(address) = 0x84edC07f0Cead3275059373F8FA47A566Dd429df\n\n# rewards\nREWARDS_ASSET: constant(address) = 0x2A0a59d6B975828e781EcaC125dBA40d7ee5dDC0\nBONUS_ASSET: constant(address) = 0x2A0a59d6B975828e781EcaC125dBA40d7ee5dDC0\n\n\n# general configs\n\n\n@view\n@external\ndef userWalletConfig() -> cs.UserWalletConfig:\n    return cs.UserWalletConfig(\n        walletTemplate = USER_WALLET_TEMPLATE,\n        configTemplate = USER_WALLET_CONFIG_TEMPLATE,\n        numUserWalletsAllowed = 100_000,\n        enforceCreatorWhitelist = True,\n        minKeyActionTimeLock = DAY_IN_BLOCKS // 2,\n        maxKeyActionTimeLock = 2 * WEEK_IN_BLOCKS,\n        depositRewardsAsset = REWARDS_ASSET,\n        lootClaimCoolOffPeriod = 0,\n        txFees = cs.TxFees(\n            swapFee = 25,\n            stableSwapFee = 25,\n            rewardsFee = 20_00,\n        ),\n        ambassadorRevShare = cs.AmbassadorRevShare(\n            swapRatio = 0,\n            rewardsRatio = 0,\n            yieldRatio = 0,\n        ),\n        yieldConfig = cs.YieldConfig(\n            maxYieldIncrease = 5_00,\n            performanceFee = 20_00,\n            ambassadorBonusRatio = 100_00,\n            bonusRatio = 100_00,\n            bonusAsset = BONUS_ASSET,\n        ),\n    )\n\n\n@view\n@external\ndef agentConfig() -> cs.AgentConfig:\n    return cs.AgentConfig(\n        startingAgent = STARTING_AGENT,\n        startingAgentActivationLength = 2 * YEAR_IN_BLOCKS,\n    )\n\n\n@view\n@external\ndef managerConfig() -> cs.ManagerConfig:\n    return cs.ManagerConfig(\n        managerPeriod = DAY_IN_BLOCKS,\n        managerActivationLength = MONTH_IN_BLOCKS,\n        mustHaveUsdValueOnSwaps = True,\n        maxNumSwapsPerPeriod = 2,\n        maxSlippageOnSwaps = 5_00,\n        onlyApprovedYieldOpps = True,\n    )\n\n\n@view\n@external\ndef payeeConfig() -> cs.PayeeConfig:\n    return cs.PayeeConfig(\n        payeePeriod = MONTH_IN_BLOCKS,\n        payeeActivationLength = YEAR_IN_BLOCKS,\n    )\n\n\n@view\n@external\ndef chequeConfig() -> cs.ChequeConfig:\n    return cs.ChequeConfig(\n        maxNumActiveCheques = 3,\n        instantUsdThreshold = 100 * EIGHTEEN_DECIMALS,\n        periodLength = DAY_IN_BLOCKS,\n        expensiveDelayBlocks = DAY_IN_BLOCKS,\n        defaultExpiryBlocks = 2 * DAY_IN_BLOCKS,\n    )\n\n\n@view\n@external\ndef ripeRewardsConfig() -> cs.RipeRewardsConfig:\n    return cs.RipeRewardsConfig(\n        stakeRatio = 80_00,\n        lockDuration = 6 * MONTH_IN_BLOCKS,\n    )\n\n\n@view\n@external\ndef securitySigners() -> DynArray[address, 10]:\n    return [WALLET_CREATOR]\n\n\n@view\n@external\ndef whitelistedCreators() -> DynArray[address, 50]:\n    return [WALLET_CREATOR]\n",
            "sha256sum": "40a85f9fe8709cc13f491f1dd0a5473b5382b29527f1c0a396a116764e061b75"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/config/DefaultsBase.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.3+commit.bff19ea2",
        "integrity": "488f2995d821f5e01dd84de79050577cae189c06c14da26ca318180204f4a7bb"
      },
      "args": "",
      "file": "contracts/config/DefaultsBase.vy"
    },
    "MissionControl": {
      "address": "0x489205626b29e2Aa8e0d6f52C01C7786513CddB6",
      "abi": [
        {
          "name": "DepartmentPauseModified",
          "inputs": [
            {
              "name": "isPaused",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "DepartmentFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "balance",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddys",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "undyToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "hatchery",
                  "type": "address"
                },
                {
                  "name": "lootDistributor",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                },
                {
                  "name": "walletBackpack",
                  "type": "address"
                },
                {
                  "name": "billing",
                  "type": "address"
                },
                {
                  "name": "vaultRegistry",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUndyHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canMintUndy",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pause",
          "inputs": [
            {
              "name": "_shouldPause",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFundsMany",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_assets",
              "type": "address[]"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isPaused",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setUserWalletConfig",
          "inputs": [
            {
              "name": "_config",
              "type": "tuple",
              "components": [
                {
                  "name": "walletTemplate",
                  "type": "address"
                },
                {
                  "name": "configTemplate",
                  "type": "address"
                },
                {
                  "name": "numUserWalletsAllowed",
                  "type": "uint256"
                },
                {
                  "name": "enforceCreatorWhitelist",
                  "type": "bool"
                },
                {
                  "name": "minKeyActionTimeLock",
                  "type": "uint256"
                },
                {
                  "name": "maxKeyActionTimeLock",
                  "type": "uint256"
                },
                {
                  "name": "depositRewardsAsset",
                  "type": "address"
                },
                {
                  "name": "lootClaimCoolOffPeriod",
                  "type": "uint256"
                },
                {
                  "name": "txFees",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "swapFee",
                      "type": "uint256"
                    },
                    {
                      "name": "stableSwapFee",
                      "type": "uint256"
                    },
                    {
                      "name": "rewardsFee",
                      "type": "uint256"
                    }
                  ]
                },
                {
                  "name": "ambassadorRevShare",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "swapRatio",
                      "type": "uint256"
                    },
                    {
                      "name": "rewardsRatio",
                      "type": "uint256"
                    },
                    {
                      "name": "yieldRatio",
                      "type": "uint256"
                    }
                  ]
                },
                {
                  "name": "yieldConfig",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "maxYieldIncrease",
                      "type": "uint256"
                    },
                    {
                      "name": "performanceFee",
                      "type": "uint256"
                    },
                    {
                      "name": "ambassadorBonusRatio",
                      "type": "uint256"
                    },
                    {
                      "name": "bonusRatio",
                      "type": "uint256"
                    },
                    {
                      "name": "bonusAsset",
                      "type": "address"
                    }
                  ]
                }
              ]
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setManagerConfig",
          "inputs": [
            {
              "name": "_config",
              "type": "tuple",
              "components": [
                {
                  "name": "managerPeriod",
                  "type": "uint256"
                },
                {
                  "name": "managerActivationLength",
                  "type": "uint256"
                },
                {
                  "name": "mustHaveUsdValueOnSwaps",
                  "type": "bool"
                },
                {
                  "name": "maxNumSwapsPerPeriod",
                  "type": "uint256"
                },
                {
                  "name": "maxSlippageOnSwaps",
                  "type": "uint256"
                },
                {
                  "name": "onlyApprovedYieldOpps",
                  "type": "bool"
                }
              ]
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setPayeeConfig",
          "inputs": [
            {
              "name": "_config",
              "type": "tuple",
              "components": [
                {
                  "name": "payeePeriod",
                  "type": "uint256"
                },
                {
                  "name": "payeeActivationLength",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setChequeConfig",
          "inputs": [
            {
              "name": "_config",
              "type": "tuple",
              "components": [
                {
                  "name": "maxNumActiveCheques",
                  "type": "uint256"
                },
                {
                  "name": "instantUsdThreshold",
                  "type": "uint256"
                },
                {
                  "name": "periodLength",
                  "type": "uint256"
                },
                {
                  "name": "expensiveDelayBlocks",
                  "type": "uint256"
                },
                {
                  "name": "defaultExpiryBlocks",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUserWalletCreationConfig",
          "inputs": [
            {
              "name": "_creator",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "numUserWalletsAllowed",
                  "type": "uint256"
                },
                {
                  "name": "isCreatorAllowed",
                  "type": "bool"
                },
                {
                  "name": "walletTemplate",
                  "type": "address"
                },
                {
                  "name": "configTemplate",
                  "type": "address"
                },
                {
                  "name": "startingAgent",
                  "type": "address"
                },
                {
                  "name": "startingAgentActivationLength",
                  "type": "uint256"
                },
                {
                  "name": "managerPeriod",
                  "type": "uint256"
                },
                {
                  "name": "managerActivationLength",
                  "type": "uint256"
                },
                {
                  "name": "mustHaveUsdValueOnSwaps",
                  "type": "bool"
                },
                {
                  "name": "maxNumSwapsPerPeriod",
                  "type": "uint256"
                },
                {
                  "name": "maxSlippageOnSwaps",
                  "type": "uint256"
                },
                {
                  "name": "onlyApprovedYieldOpps",
                  "type": "bool"
                },
                {
                  "name": "payeePeriod",
                  "type": "uint256"
                },
                {
                  "name": "payeeActivationLength",
                  "type": "uint256"
                },
                {
                  "name": "chequeMaxNumActiveCheques",
                  "type": "uint256"
                },
                {
                  "name": "chequeInstantUsdThreshold",
                  "type": "uint256"
                },
                {
                  "name": "chequePeriodLength",
                  "type": "uint256"
                },
                {
                  "name": "chequeExpensiveDelayBlocks",
                  "type": "uint256"
                },
                {
                  "name": "chequeDefaultExpiryBlocks",
                  "type": "uint256"
                },
                {
                  "name": "minKeyActionTimeLock",
                  "type": "uint256"
                },
                {
                  "name": "maxKeyActionTimeLock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getDepositRewardsAsset",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLootClaimCoolOffPeriod",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setRipeRewardsConfig",
          "inputs": [
            {
              "name": "_config",
              "type": "tuple",
              "components": [
                {
                  "name": "stakeRatio",
                  "type": "uint256"
                },
                {
                  "name": "lockDuration",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRipeRewardsConfig",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "stakeRatio",
                  "type": "uint256"
                },
                {
                  "name": "lockDuration",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setAgentConfig",
          "inputs": [
            {
              "name": "_config",
              "type": "tuple",
              "components": [
                {
                  "name": "startingAgent",
                  "type": "address"
                },
                {
                  "name": "startingAgentActivationLength",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setStarterAgent",
          "inputs": [
            {
              "name": "_agent",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setAssetConfig",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_config",
              "type": "tuple",
              "components": [
                {
                  "name": "hasConfig",
                  "type": "bool"
                },
                {
                  "name": "txFees",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "swapFee",
                      "type": "uint256"
                    },
                    {
                      "name": "stableSwapFee",
                      "type": "uint256"
                    },
                    {
                      "name": "rewardsFee",
                      "type": "uint256"
                    }
                  ]
                },
                {
                  "name": "ambassadorRevShare",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "swapRatio",
                      "type": "uint256"
                    },
                    {
                      "name": "rewardsRatio",
                      "type": "uint256"
                    },
                    {
                      "name": "yieldRatio",
                      "type": "uint256"
                    }
                  ]
                },
                {
                  "name": "yieldConfig",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "maxYieldIncrease",
                      "type": "uint256"
                    },
                    {
                      "name": "performanceFee",
                      "type": "uint256"
                    },
                    {
                      "name": "ambassadorBonusRatio",
                      "type": "uint256"
                    },
                    {
                      "name": "bonusRatio",
                      "type": "uint256"
                    },
                    {
                      "name": "bonusAsset",
                      "type": "address"
                    }
                  ]
                }
              ]
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setIsStablecoin",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_isStablecoin",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getSwapFee",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRewardsFee",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getProfitCalcConfig",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "legoAddr",
                  "type": "address"
                },
                {
                  "name": "isYieldAsset",
                  "type": "bool"
                },
                {
                  "name": "underlyingAsset",
                  "type": "address"
                },
                {
                  "name": "maxYieldIncrease",
                  "type": "uint256"
                },
                {
                  "name": "performanceFee",
                  "type": "uint256"
                },
                {
                  "name": "isRebasing",
                  "type": "bool"
                },
                {
                  "name": "decimals",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssetUsdValueConfig",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "legoAddr",
                  "type": "address"
                },
                {
                  "name": "isYieldAsset",
                  "type": "bool"
                },
                {
                  "name": "underlyingAsset",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLootDistroConfig",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "legoAddr",
                  "type": "address"
                },
                {
                  "name": "underlyingAsset",
                  "type": "address"
                },
                {
                  "name": "ambassador",
                  "type": "address"
                },
                {
                  "name": "ambassadorRevShare",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "swapRatio",
                      "type": "uint256"
                    },
                    {
                      "name": "rewardsRatio",
                      "type": "uint256"
                    },
                    {
                      "name": "yieldRatio",
                      "type": "uint256"
                    }
                  ]
                },
                {
                  "name": "ambassadorBonusRatio",
                  "type": "uint256"
                },
                {
                  "name": "bonusRatio",
                  "type": "uint256"
                },
                {
                  "name": "bonusAsset",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setCanPerformSecurityAction",
          "inputs": [
            {
              "name": "_signer",
              "type": "address"
            },
            {
              "name": "_canPerform",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canPerformSecurityAction",
          "inputs": [
            {
              "name": "_signer",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setCreatorWhitelist",
          "inputs": [
            {
              "name": "_creator",
              "type": "address"
            },
            {
              "name": "_isWhitelisted",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "creatorWhitelist",
          "inputs": [
            {
              "name": "_creator",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setLockedSigner",
          "inputs": [
            {
              "name": "_signer",
              "type": "address"
            },
            {
              "name": "_isLocked",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "userWalletConfig",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "walletTemplate",
                  "type": "address"
                },
                {
                  "name": "configTemplate",
                  "type": "address"
                },
                {
                  "name": "numUserWalletsAllowed",
                  "type": "uint256"
                },
                {
                  "name": "enforceCreatorWhitelist",
                  "type": "bool"
                },
                {
                  "name": "minKeyActionTimeLock",
                  "type": "uint256"
                },
                {
                  "name": "maxKeyActionTimeLock",
                  "type": "uint256"
                },
                {
                  "name": "depositRewardsAsset",
                  "type": "address"
                },
                {
                  "name": "lootClaimCoolOffPeriod",
                  "type": "uint256"
                },
                {
                  "name": "txFees",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "swapFee",
                      "type": "uint256"
                    },
                    {
                      "name": "stableSwapFee",
                      "type": "uint256"
                    },
                    {
                      "name": "rewardsFee",
                      "type": "uint256"
                    }
                  ]
                },
                {
                  "name": "ambassadorRevShare",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "swapRatio",
                      "type": "uint256"
                    },
                    {
                      "name": "rewardsRatio",
                      "type": "uint256"
                    },
                    {
                      "name": "yieldRatio",
                      "type": "uint256"
                    }
                  ]
                },
                {
                  "name": "yieldConfig",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "maxYieldIncrease",
                      "type": "uint256"
                    },
                    {
                      "name": "performanceFee",
                      "type": "uint256"
                    },
                    {
                      "name": "ambassadorBonusRatio",
                      "type": "uint256"
                    },
                    {
                      "name": "bonusRatio",
                      "type": "uint256"
                    },
                    {
                      "name": "bonusAsset",
                      "type": "address"
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "agentConfig",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "startingAgent",
                  "type": "address"
                },
                {
                  "name": "startingAgentActivationLength",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "managerConfig",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "managerPeriod",
                  "type": "uint256"
                },
                {
                  "name": "managerActivationLength",
                  "type": "uint256"
                },
                {
                  "name": "mustHaveUsdValueOnSwaps",
                  "type": "bool"
                },
                {
                  "name": "maxNumSwapsPerPeriod",
                  "type": "uint256"
                },
                {
                  "name": "maxSlippageOnSwaps",
                  "type": "uint256"
                },
                {
                  "name": "onlyApprovedYieldOpps",
                  "type": "bool"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "payeeConfig",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "payeePeriod",
                  "type": "uint256"
                },
                {
                  "name": "payeeActivationLength",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "chequeConfig",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "maxNumActiveCheques",
                  "type": "uint256"
                },
                {
                  "name": "instantUsdThreshold",
                  "type": "uint256"
                },
                {
                  "name": "periodLength",
                  "type": "uint256"
                },
                {
                  "name": "expensiveDelayBlocks",
                  "type": "uint256"
                },
                {
                  "name": "defaultExpiryBlocks",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ripeRewardsConfig",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "stakeRatio",
                  "type": "uint256"
                },
                {
                  "name": "lockDuration",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assetConfig",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "hasConfig",
                  "type": "bool"
                },
                {
                  "name": "txFees",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "swapFee",
                      "type": "uint256"
                    },
                    {
                      "name": "stableSwapFee",
                      "type": "uint256"
                    },
                    {
                      "name": "rewardsFee",
                      "type": "uint256"
                    }
                  ]
                },
                {
                  "name": "ambassadorRevShare",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "swapRatio",
                      "type": "uint256"
                    },
                    {
                      "name": "rewardsRatio",
                      "type": "uint256"
                    },
                    {
                      "name": "yieldRatio",
                      "type": "uint256"
                    }
                  ]
                },
                {
                  "name": "yieldConfig",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "maxYieldIncrease",
                      "type": "uint256"
                    },
                    {
                      "name": "performanceFee",
                      "type": "uint256"
                    },
                    {
                      "name": "ambassadorBonusRatio",
                      "type": "uint256"
                    },
                    {
                      "name": "bonusRatio",
                      "type": "uint256"
                    },
                    {
                      "name": "bonusAsset",
                      "type": "address"
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isStablecoin",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isLockedSigner",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "securitySigners",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfSecuritySigner",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numSecuritySigners",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "whitelistedCreators",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfWhitelistedCreator",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numWhitelistedCreators",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_undyHq",
              "type": "address"
            },
            {
              "name": "_defaults",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/modules/Addys.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\ninterface UndyHq:\n    def isValidAddr(_addr: address) -> bool: view\n    def getAddr(_regId: uint256) -> address: view\n    def undyToken() -> address: view\n\ninterface Switchboard:\n    def isSwitchboardAddr(_addr: address) -> bool: view\n\ninterface LegoBook:\n    def isLegoAddr(_addr: address) -> bool: view\n\nstruct Addys:\n    hq: address\n    undyToken: address\n    ledger: address\n    missionControl: address\n    legoBook: address\n    switchboard: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    walletBackpack: address\n    billing: address\n    vaultRegistry: address\n\n# hq\nUNDY_HQ_FOR_ADDYS: immutable(address)\n\n# core addys\nLEDGER_ID: constant(uint256) = 1\nMISSION_CONTROL_ID: constant(uint256) = 2\nLEGO_BOOK_ID: constant(uint256) = 3\nSWITCHBOARD_ID: constant(uint256) = 4\nHATCHERY_ID: constant(uint256) = 5\nLOOT_DISTRIBUTOR_ID: constant(uint256) = 6\nAPPRAISER_ID: constant(uint256) = 7\nWALLET_BACKPACK_ID: constant(uint256) = 8\nBILLING_ID: constant(uint256) = 9\nVAULT_REGISTRY_ID: constant(uint256) = 10\n\n\n@deploy\ndef __init__(_undyHq: address):\n    assert _undyHq != empty(address) # dev: invalid undy hq\n    UNDY_HQ_FOR_ADDYS = _undyHq\n\n\n########\n# Core #\n########\n\n\n@view\n@external\ndef getAddys() -> Addys:\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _getAddys(_addys: Addys = empty(Addys)) -> Addys:\n    if _addys.hq != empty(address):\n        return _addys\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _generateAddys() -> Addys:\n    hq: address = UNDY_HQ_FOR_ADDYS\n    return Addys(\n        hq = hq,\n        undyToken = staticcall UndyHq(hq).undyToken(),\n        ledger = staticcall UndyHq(hq).getAddr(LEDGER_ID),\n        missionControl = staticcall UndyHq(hq).getAddr(MISSION_CONTROL_ID),\n        legoBook = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID),\n        switchboard = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID),\n        hatchery = staticcall UndyHq(hq).getAddr(HATCHERY_ID),\n        lootDistributor = staticcall UndyHq(hq).getAddr(LOOT_DISTRIBUTOR_ID),\n        appraiser = staticcall UndyHq(hq).getAddr(APPRAISER_ID),\n        walletBackpack = staticcall UndyHq(hq).getAddr(WALLET_BACKPACK_ID),\n        billing = staticcall UndyHq(hq).getAddr(BILLING_ID),\n        vaultRegistry = staticcall UndyHq(hq).getAddr(VAULT_REGISTRY_ID),\n    )\n\n\n##########\n# Tokens #\n##########\n\n\n@view\n@internal\ndef _getUndyToken() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).undyToken()\n\n\n###########\n# Helpers #\n###########\n\n\n# undy hq\n\n\n@view\n@external\ndef getUndyHq() -> address:\n    return self._getUndyHq()\n\n\n@view\n@internal\ndef _getUndyHq() -> address:\n    return UNDY_HQ_FOR_ADDYS\n\n\n# utils\n\n\n@view\n@internal\ndef _isValidUndyAddr(_addr: address, _hq: address = empty(address)) -> bool:\n    hq: address = _hq\n    if _hq == empty(address):\n        hq = UNDY_HQ_FOR_ADDYS\n    \n    # core departments\n    if staticcall UndyHq(hq).isValidAddr(_addr):\n        return True\n\n    # lego book\n    legoBook: address = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID)\n    if legoBook != empty(address) and staticcall LegoBook(legoBook).isLegoAddr(_addr):\n        return True\n\n    # switchboard config\n    switchboard: address = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID)\n    if switchboard != empty(address) and staticcall Switchboard(switchboard).isSwitchboardAddr(_addr):\n        return True\n\n    return False\n\n\n@view\n@internal\ndef _isSwitchboardAddr(_addr: address) -> bool:\n    switchboard: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n    if switchboard == empty(address):\n        return False\n    return staticcall Switchboard(switchboard).isSwitchboardAddr(_addr)\n\n\n@view\n@internal\ndef _isLegoBookAddr(_addr: address) -> bool:\n    legoBook: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n    if legoBook == empty(address):\n        return False\n    return staticcall LegoBook(legoBook).isLegoAddr(_addr)\n\n\n###############\n# Departments #\n###############\n\n\n# ledger\n\n\n@view\n@internal\ndef _getLedgerId() -> uint256:\n    return LEDGER_ID\n\n\n@view\n@internal\ndef _getLedgerAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEDGER_ID)\n\n\n# mission control\n\n\n@view\n@internal\ndef _getMissionControlId() -> uint256:\n    return MISSION_CONTROL_ID\n\n\n@view\n@internal\ndef _getMissionControlAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(MISSION_CONTROL_ID)\n\n\n# lego book\n\n\n@view\n@internal\ndef _getLegoBookId() -> uint256:\n    return LEGO_BOOK_ID\n\n\n@view\n@internal\ndef _getLegoBookAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n\n\n# switchboard\n\n\n@view\n@internal\ndef _getSwitchboardId() -> uint256:\n    return SWITCHBOARD_ID\n\n\n@view\n@internal\ndef _getSwitchboardAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n\n\n# hatchery\n\n\n@view\n@internal\ndef _getHatcheryId() -> uint256:\n    return HATCHERY_ID\n\n\n@view\n@internal\ndef _getHatcheryAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(HATCHERY_ID)\n\n\n# loot distributor\n\n\n@view\n@internal\ndef _getLootDistributorId() -> uint256:\n    return LOOT_DISTRIBUTOR_ID\n\n\n@view\n@internal\ndef _getLootDistributorAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LOOT_DISTRIBUTOR_ID)\n\n\n# appraiser\n\n\n@view\n@internal\ndef _getAppraiserId() -> uint256:\n    return APPRAISER_ID\n\n\n@view\n@internal\ndef _getAppraiserAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(APPRAISER_ID)\n\n\n# wallet backpack\n\n\n@view\n@internal\ndef _getWalletBackpackId() -> uint256:\n    return WALLET_BACKPACK_ID\n\n\n@view\n@internal\ndef _getWalletBackpackAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(WALLET_BACKPACK_ID)\n\n\n# billing\n\n\n@view\n@internal\ndef _getBillingId() -> uint256:\n    return BILLING_ID\n\n\n@view\n@internal\ndef _getBillingAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(BILLING_ID)\n\n\n# vault registry\n\n\n@view\n@internal\ndef _getVaultRegistryId() -> uint256:\n    return VAULT_REGISTRY_ID\n\n\n@view\n@internal\ndef _getVaultRegistryAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(VAULT_REGISTRY_ID)",
            "sha256sum": "4df6b72db9bb417d1af81660175be1450cfb7b3575f3d17a5b8a130bff87b781"
          },
          "interfaces/Department.vyi": {
            "content": "# @version 0.4.3\n\n\n###########\n# Minting #\n###########\n\n\n@view\n@external\ndef canMintUndy() -> bool:\n    # used in UndyHq.vy\n    ...\n\n\n########\n# Undy #\n########\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "53e48da591c4ee36045a8950c9d3a01458456b471b797df536e9a9f54404e721"
          },
          "contracts/modules/DeptBasics.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nuses: addys\nimplements: dept\n\nimport contracts.modules.Addys as addys\nimport interfaces.Department as dept\nfrom ethereum.ercs import IERC20\n\nevent DepartmentPauseModified:\n    isPaused: bool\n\nevent DepartmentFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    balance: uint256\n\nisPaused: public(bool)\n\nCAN_MINT_UNDY: immutable(bool)\nMAX_RECOVER_ASSETS: constant(uint256) = 20\n\n\n@deploy\ndef __init__(_shouldPause: bool, _canMintUndy: bool):\n    self.isPaused = _shouldPause\n    CAN_MINT_UNDY = _canMintUndy\n\n\n###########\n# Minting #\n###########\n\n\n@view\n@external\ndef canMintUndy() -> bool:\n    return CAN_MINT_UNDY\n\n\n########\n# Undy #\n########\n\n\n# activate\n\n\n@external\ndef pause(_shouldPause: bool):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert _shouldPause != self.isPaused # dev: no change\n    self.isPaused = _shouldPause\n    log DepartmentPauseModified(isPaused=_shouldPause)\n\n\n# recover funds\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    self._recoverFunds(_recipient, _asset)\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, MAX_RECOVER_ASSETS]):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    for a: address in _assets:\n        self._recoverFunds(_recipient, a)\n\n\n@internal\ndef _recoverFunds(_recipient: address, _asset: address):\n    assert empty(address) not in [_recipient, _asset] # dev: invalid recipient or asset\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    assert balance != 0 # dev: nothing to recover\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log DepartmentFundsRecovered(asset=_asset, recipient=_recipient, balance=balance)\n",
            "sha256sum": "976a50a3807bcf71f3f1c57de5cd7a59fe4e8f27b4d4560e774073962f44d1ac"
          },
          "interfaces/ConfigStructs.vyi": {
            "content": "# @version 0.4.3\n\nstruct UserWalletConfig:\n    walletTemplate: address\n    configTemplate: address\n    numUserWalletsAllowed: uint256\n    enforceCreatorWhitelist: bool\n    minKeyActionTimeLock: uint256\n    maxKeyActionTimeLock: uint256\n    depositRewardsAsset: address\n    lootClaimCoolOffPeriod: uint256\n    txFees: TxFees\n    ambassadorRevShare: AmbassadorRevShare\n    yieldConfig: YieldConfig\n\nstruct AssetConfig:\n    hasConfig: bool\n    txFees: TxFees\n    ambassadorRevShare: AmbassadorRevShare\n    yieldConfig: YieldConfig\n\nstruct TxFees:\n    swapFee: uint256\n    stableSwapFee: uint256\n    rewardsFee: uint256\n\nstruct AmbassadorRevShare:\n    swapRatio: uint256\n    rewardsRatio: uint256\n    yieldRatio: uint256\n\nstruct YieldConfig:\n    maxYieldIncrease: uint256\n    performanceFee: uint256\n    ambassadorBonusRatio: uint256\n    bonusRatio: uint256\n    bonusAsset: address\n\nstruct AgentConfig:\n    startingAgent: address\n    startingAgentActivationLength: uint256\n\nstruct ManagerConfig:\n    managerPeriod: uint256\n    managerActivationLength: uint256\n    mustHaveUsdValueOnSwaps: bool\n    maxNumSwapsPerPeriod: uint256\n    maxSlippageOnSwaps: uint256\n    onlyApprovedYieldOpps: bool\n\nstruct PayeeConfig:\n    payeePeriod: uint256\n    payeeActivationLength: uint256\n\nstruct ChequeConfig:\n    maxNumActiveCheques: uint256\n    instantUsdThreshold: uint256\n    periodLength: uint256\n    expensiveDelayBlocks: uint256\n    defaultExpiryBlocks: uint256\n\nstruct RipeRewardsConfig:\n    stakeRatio: uint256\n    lockDuration: uint256",
            "sha256sum": "4a631b60c85398adcd4e8174532e69540dd8df9afff85b0876f3feeae196af74"
          },
          "interfaces/Defaults.vyi": {
            "content": "# @version 0.4.3\n\nimport interfaces.ConfigStructs as cs\n\n\n@view\n@external\ndef userWalletConfig() -> cs.UserWalletConfig:\n    ...\n\n\n@view\n@external\ndef agentConfig() -> cs.AgentConfig:\n    ...\n\n\n@view\n@external\ndef managerConfig() -> cs.ManagerConfig:\n    ...\n\n\n@view\n@external\ndef payeeConfig() -> cs.PayeeConfig:\n    ...\n\n\n\n@view\n@external\ndef chequeConfig() -> cs.ChequeConfig:\n    ...\n\n\n@view\n@external\ndef ripeRewardsConfig() -> cs.RipeRewardsConfig:\n    ...\n\n\n# security signers\n\n\n@view\n@external\ndef securitySigners() -> DynArray[address, 10]:\n    ...\n\n\n# whitelisted creators\n\n\n@view\n@external\ndef whitelistedCreators() -> DynArray[address, 50]:\n    ...",
            "sha256sum": "c67ee89c0075a08dbf030e76f9818aadd6a3c6b4a7fecb87038aa8ea1ec128ee"
          },
          "contracts/data/MissionControl.vy": {
            "content": "#     _     _  __  __  _  ___  _         __   ___  _   ________  ___  _    \n#    | |\\/|| |( (`( (`| |/ / \\| |\\ |    / /` / / \\| |\\ || || |_)/ / \\| |   \n#    |_|  ||_|_)_)_)_)|_|\\_\\_/|_| \\|    \\_\\_,\\_\\_/|_| \\||_||_| \\\\_\\_/|_|__ \n#\n#     \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n#     \u2551  ** Mission Control **                             \u2551\n#     \u2551  Stores all configuration data for Underscore      \u2551\n#     \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n#\n#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nimplements: Department\n\nexports: addys.__interface__\nexports: deptBasics.__interface__\n\ninitializes: addys\ninitializes: deptBasics[addys := addys]\n\nimport contracts.modules.Addys as addys\nimport contracts.modules.DeptBasics as deptBasics\n\nfrom interfaces import Department\nimport interfaces.ConfigStructs as cs\nfrom interfaces import Defaults\n\ninterface Ledger:\n    def vaultTokens(_vaultToken: address) -> VaultToken: view\n\ninterface Registry:\n    def getAddr(_regId: uint256) -> address: view\n\nstruct VaultToken:\n    legoId: uint256\n    underlyingAsset: address\n    decimals: uint256\n    isRebasing: bool\n\nstruct AssetUsdValueConfig:\n    legoId: uint256\n    legoAddr: address\n    isYieldAsset: bool\n    underlyingAsset: address\n\nstruct ProfitCalcConfig:\n    legoId: uint256\n    legoAddr: address\n    isYieldAsset: bool\n    underlyingAsset: address\n    maxYieldIncrease: uint256\n    performanceFee: uint256\n    isRebasing: bool\n    decimals: uint256\n\nstruct LootDistroConfig:\n    legoId: uint256\n    legoAddr: address\n    underlyingAsset: address\n    ambassador: address\n    ambassadorRevShare: cs.AmbassadorRevShare\n    ambassadorBonusRatio: uint256\n    bonusRatio: uint256\n    bonusAsset: address\n\nstruct UserWalletCreationConfig:\n    numUserWalletsAllowed: uint256\n    isCreatorAllowed: bool\n    walletTemplate: address\n    configTemplate: address\n    startingAgent: address\n    startingAgentActivationLength: uint256\n    managerPeriod: uint256\n    managerActivationLength: uint256\n    mustHaveUsdValueOnSwaps: bool\n    maxNumSwapsPerPeriod: uint256\n    maxSlippageOnSwaps: uint256\n    onlyApprovedYieldOpps: bool\n    payeePeriod: uint256\n    payeeActivationLength: uint256\n    chequeMaxNumActiveCheques: uint256\n    chequeInstantUsdThreshold: uint256\n    chequePeriodLength: uint256\n    chequeExpensiveDelayBlocks: uint256\n    chequeDefaultExpiryBlocks: uint256\n    minKeyActionTimeLock: uint256\n    maxKeyActionTimeLock: uint256\n\n# global configs\nuserWalletConfig: public(cs.UserWalletConfig)\nagentConfig: public(cs.AgentConfig)\nmanagerConfig: public(cs.ManagerConfig)\npayeeConfig: public(cs.PayeeConfig)\nchequeConfig: public(cs.ChequeConfig)\nripeRewardsConfig: public(cs.RipeRewardsConfig)\n\n# asset config\nassetConfig: public(HashMap[address, cs.AssetConfig])\nisStablecoin: public(HashMap[address, bool])\n\n# security / limits\nisLockedSigner: public(HashMap[address, bool]) # signer -> is locked\n\n# security signers (iterable)\nsecuritySigners: public(HashMap[uint256, address]) # index -> signer\nindexOfSecuritySigner: public(HashMap[address, uint256]) # signer -> index\nnumSecuritySigners: public(uint256)\n\n# whitelisted creators (iterable)\nwhitelistedCreators: public(HashMap[uint256, address]) # index -> creator\nindexOfWhitelistedCreator: public(HashMap[address, uint256]) # creator -> index\nnumWhitelistedCreators: public(uint256)\n\n\n@deploy\ndef __init__(_undyHq: address, _defaults: address):\n    addys.__init__(_undyHq)\n    deptBasics.__init__(False, False) # no minting\n\n    # start at 1, index 0 means \"not in list\"\n    self.numSecuritySigners = 1\n    self.numWhitelistedCreators = 1\n\n    if _defaults != empty(address):\n        self.userWalletConfig = staticcall Defaults(_defaults).userWalletConfig()\n        self.agentConfig = staticcall Defaults(_defaults).agentConfig()\n        self.managerConfig = staticcall Defaults(_defaults).managerConfig()\n        self.payeeConfig = staticcall Defaults(_defaults).payeeConfig()\n        self.chequeConfig = staticcall Defaults(_defaults).chequeConfig()\n        self.ripeRewardsConfig = staticcall Defaults(_defaults).ripeRewardsConfig()\n\n        # security signers\n        securitySigners: DynArray[address, 10] = staticcall Defaults(_defaults).securitySigners()\n        for signer: address in securitySigners:\n            self._addSecuritySigner(signer)\n\n        # whitelisted creators\n        whitelistedCreators: DynArray[address, 50] = staticcall Defaults(_defaults).whitelistedCreators()\n        for creator: address in whitelistedCreators:\n            self._addWhitelistedCreator(creator)\n\n\n######################\n# User Wallet Config #\n######################\n\n\n@external\ndef setUserWalletConfig(_config: cs.UserWalletConfig):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert not deptBasics.isPaused # dev: not activated\n    self.userWalletConfig = _config\n\n\n@external\ndef setManagerConfig(_config: cs.ManagerConfig):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert not deptBasics.isPaused # dev: not activated\n    self.managerConfig = _config\n\n\n@external\ndef setPayeeConfig(_config: cs.PayeeConfig):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert not deptBasics.isPaused # dev: not activated\n    self.payeeConfig = _config\n\n\n@external\ndef setChequeConfig(_config: cs.ChequeConfig):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert not deptBasics.isPaused # dev: not activated\n    self.chequeConfig = _config\n\n\n# helper\n\n\n@view\n@external\ndef getUserWalletCreationConfig(_creator: address) -> UserWalletCreationConfig:\n    config: cs.UserWalletConfig = self.userWalletConfig\n    managerConfig: cs.ManagerConfig = self.managerConfig\n    payeeConfig: cs.PayeeConfig = self.payeeConfig\n    agentConfig: cs.AgentConfig = self.agentConfig\n    chequeConfig: cs.ChequeConfig = self.chequeConfig\n    return UserWalletCreationConfig(\n        numUserWalletsAllowed = config.numUserWalletsAllowed,\n        isCreatorAllowed = self._isCreatorAllowed(config.enforceCreatorWhitelist, _creator),\n        walletTemplate = config.walletTemplate,\n        configTemplate = config.configTemplate,\n        startingAgent = agentConfig.startingAgent,\n        startingAgentActivationLength = agentConfig.startingAgentActivationLength,\n        managerPeriod = managerConfig.managerPeriod,\n        managerActivationLength = managerConfig.managerActivationLength,\n        mustHaveUsdValueOnSwaps = managerConfig.mustHaveUsdValueOnSwaps,\n        maxNumSwapsPerPeriod = managerConfig.maxNumSwapsPerPeriod,\n        maxSlippageOnSwaps = managerConfig.maxSlippageOnSwaps,\n        onlyApprovedYieldOpps = managerConfig.onlyApprovedYieldOpps,\n        payeePeriod = payeeConfig.payeePeriod,\n        payeeActivationLength = payeeConfig.payeeActivationLength,\n        chequeMaxNumActiveCheques = chequeConfig.maxNumActiveCheques,\n        chequeInstantUsdThreshold = chequeConfig.instantUsdThreshold,\n        chequePeriodLength = chequeConfig.periodLength,\n        chequeExpensiveDelayBlocks = chequeConfig.expensiveDelayBlocks,\n        chequeDefaultExpiryBlocks = chequeConfig.defaultExpiryBlocks,\n        minKeyActionTimeLock = config.minKeyActionTimeLock,\n        maxKeyActionTimeLock = config.maxKeyActionTimeLock,\n    )\n\n\n@view\n@external\ndef getDepositRewardsAsset() -> address:\n    return self.userWalletConfig.depositRewardsAsset\n\n\n@view\n@external\ndef getLootClaimCoolOffPeriod() -> uint256:\n    return self.userWalletConfig.lootClaimCoolOffPeriod\n\n\n#######################\n# Ripe Rewards Config #\n#######################\n\n\n@external\ndef setRipeRewardsConfig(_config: cs.RipeRewardsConfig):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert not deptBasics.isPaused # dev: not activated\n    self.ripeRewardsConfig = _config\n\n\n@view\n@external\ndef getRipeRewardsConfig() -> cs.RipeRewardsConfig:\n    return self.ripeRewardsConfig\n\n\n################\n# Agent Config #\n################\n\n\n@external\ndef setAgentConfig(_config: cs.AgentConfig):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert not deptBasics.isPaused # dev: not activated\n    self.agentConfig = _config\n\n\n@external\ndef setStarterAgent(_agent: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert not deptBasics.isPaused # dev: not activated\n    self.agentConfig.startingAgent = _agent\n\n\n########################\n# Asset / Yield Config #\n########################\n\n\n@external\ndef setAssetConfig(_asset: address, _config: cs.AssetConfig):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert not deptBasics.isPaused # dev: not activated\n    self.assetConfig[_asset] = _config\n\n\n@external\ndef setIsStablecoin(_asset: address, _isStablecoin: bool):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert not deptBasics.isPaused # dev: not activated\n    self.isStablecoin[_asset] = _isStablecoin\n\n\n# swap fee\n\n\n@view\n@external\ndef getSwapFee(_tokenIn: address, _tokenOut: address) -> uint256:\n\n    # stable swap fee\n    if self.isStablecoin[_tokenIn] and self.isStablecoin[_tokenOut]:\n        return self.userWalletConfig.txFees.stableSwapFee\n\n    # asset swap fee takes precedence over global swap fee\n    outConfig: cs.AssetConfig = self.assetConfig[_tokenOut]\n    if outConfig.hasConfig:\n        return outConfig.txFees.swapFee\n\n    return self.userWalletConfig.txFees.swapFee\n\n\n# rewards fee\n\n\n@view\n@external\ndef getRewardsFee(_asset: address) -> uint256:\n    config: cs.AssetConfig = self.assetConfig[_asset]\n    if config.hasConfig:\n        return config.txFees.rewardsFee\n    return self.userWalletConfig.txFees.rewardsFee\n\n\n# helpers\n\n\n@view\n@external\ndef getProfitCalcConfig(_asset: address) -> ProfitCalcConfig:\n    assetConfig: cs.AssetConfig = self.assetConfig[_asset]\n    maxYieldIncrease: uint256 = assetConfig.yieldConfig.maxYieldIncrease\n    performanceFee: uint256 = assetConfig.yieldConfig.performanceFee\n    if not assetConfig.hasConfig:\n        walletConfig: cs.UserWalletConfig = self.userWalletConfig\n        maxYieldIncrease = walletConfig.yieldConfig.maxYieldIncrease\n        performanceFee = walletConfig.yieldConfig.performanceFee\n\n    # vault token\n    ledger: address = addys._getLedgerAddr()\n    vaultToken: VaultToken = staticcall Ledger(ledger).vaultTokens(_asset)\n\n    # get lego addr\n    legoAddr: address = empty(address)\n    if vaultToken.legoId != 0:\n        legoBook: address = addys._getLegoBookAddr()\n        legoAddr = staticcall Registry(legoBook).getAddr(vaultToken.legoId)\n\n    return ProfitCalcConfig(\n        legoId = vaultToken.legoId,\n        legoAddr = legoAddr,\n        isYieldAsset = vaultToken.underlyingAsset != empty(address),\n        underlyingAsset = vaultToken.underlyingAsset,\n        maxYieldIncrease = maxYieldIncrease,\n        performanceFee = performanceFee,\n        isRebasing = vaultToken.isRebasing,\n        decimals = vaultToken.decimals,\n    )\n\n\n@view\n@external\ndef getAssetUsdValueConfig(_asset: address) -> AssetUsdValueConfig:\n    ledger: address = addys._getLedgerAddr()\n    vaultToken: VaultToken = staticcall Ledger(ledger).vaultTokens(_asset)\n\n    # get lego addr\n    legoAddr: address = empty(address)\n    if vaultToken.legoId != 0:\n        legoBook: address = addys._getLegoBookAddr()\n        legoAddr = staticcall Registry(legoBook).getAddr(vaultToken.legoId)\n\n    return AssetUsdValueConfig(\n        legoId = vaultToken.legoId,\n        legoAddr = legoAddr,\n        isYieldAsset = vaultToken.underlyingAsset != empty(address),\n        underlyingAsset = vaultToken.underlyingAsset,\n    )\n\n\n@view\n@external\ndef getLootDistroConfig(_asset: address) -> LootDistroConfig:\n    assetConfig: cs.AssetConfig = self.assetConfig[_asset]\n    ambassadorRevShare: cs.AmbassadorRevShare = assetConfig.ambassadorRevShare\n    ambassadorBonusRatio: uint256 = assetConfig.yieldConfig.ambassadorBonusRatio\n    bonusRatio: uint256 = assetConfig.yieldConfig.bonusRatio\n    bonusAsset: address = assetConfig.yieldConfig.bonusAsset\n    if not assetConfig.hasConfig:\n        walletConfig: cs.UserWalletConfig = self.userWalletConfig\n        ambassadorRevShare = walletConfig.ambassadorRevShare\n        ambassadorBonusRatio = walletConfig.yieldConfig.ambassadorBonusRatio\n        bonusRatio = walletConfig.yieldConfig.bonusRatio\n        bonusAsset = walletConfig.yieldConfig.bonusAsset\n\n    # vault token\n    ledger: address = addys._getLedgerAddr()\n    vaultToken: VaultToken = staticcall Ledger(ledger).vaultTokens(_asset)\n\n    # get lego addr\n    legoAddr: address = empty(address)\n    if vaultToken.legoId != 0:\n        legoBook: address = addys._getLegoBookAddr()\n        legoAddr = staticcall Registry(legoBook).getAddr(vaultToken.legoId)\n\n    return LootDistroConfig(\n        legoId = vaultToken.legoId,\n        legoAddr = legoAddr,\n        underlyingAsset = vaultToken.underlyingAsset,\n        ambassador = empty(address),\n        ambassadorRevShare = ambassadorRevShare,\n        ambassadorBonusRatio = ambassadorBonusRatio,\n        bonusRatio = bonusRatio,\n        bonusAsset = bonusAsset,\n    )\n\n\n####################\n# Security Signers #\n####################\n\n\n# set can perform security action\n\n\n@external\ndef setCanPerformSecurityAction(_signer: address, _canPerform: bool):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert not deptBasics.isPaused # dev: not activated\n    if _canPerform:\n        self._addSecuritySigner(_signer)\n    else:\n        self._removeSecuritySigner(_signer)\n\n\n# can perform security action\n\n\n@view\n@external\ndef canPerformSecurityAction(_signer: address) -> bool:\n    return self.indexOfSecuritySigner[_signer] != 0\n\n\n# add security signer\n\n\n@internal\ndef _addSecuritySigner(_signer: address):\n    if self.indexOfSecuritySigner[_signer] != 0:\n        return\n    idx: uint256 = self.numSecuritySigners\n    self.securitySigners[idx] = _signer\n    self.indexOfSecuritySigner[_signer] = idx\n    self.numSecuritySigners = idx + 1\n\n\n# remove security signer\n\n\n@internal\ndef _removeSecuritySigner(_signer: address):\n    targetIndex: uint256 = self.indexOfSecuritySigner[_signer]\n    if targetIndex == 0:\n        return\n\n    lastIndex: uint256 = self.numSecuritySigners - 1\n    self.numSecuritySigners = lastIndex\n    self.indexOfSecuritySigner[_signer] = 0\n\n    # swap with last item if not already last\n    if targetIndex != lastIndex:\n        lastItem: address = self.securitySigners[lastIndex]\n        self.securitySigners[targetIndex] = lastItem\n        self.indexOfSecuritySigner[lastItem] = targetIndex\n\n    self.securitySigners[lastIndex] = empty(address)\n\n\n#####################\n# Creator Whitelist #\n#####################\n\n\n# set creator whitelist\n\n\n@external\ndef setCreatorWhitelist(_creator: address, _isWhitelisted: bool):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert not deptBasics.isPaused # dev: not activated\n    if _isWhitelisted:\n        self._addWhitelistedCreator(_creator)\n    else:\n        self._removeWhitelistedCreator(_creator)\n\n\n# can create\n\n\n@view\n@external\ndef creatorWhitelist(_creator: address) -> bool:\n    return self.indexOfWhitelistedCreator[_creator] != 0\n\n\n@view\n@internal\ndef _isCreatorAllowed(_shouldEnforceWhitelist: bool, _creator: address) -> bool:\n    if _shouldEnforceWhitelist:\n        return self.indexOfWhitelistedCreator[_creator] != 0\n    return True\n\n\n# add creator\n\n\n@internal\ndef _addWhitelistedCreator(_creator: address):\n    if self.indexOfWhitelistedCreator[_creator] != 0:\n        return\n    idx: uint256 = self.numWhitelistedCreators\n    self.whitelistedCreators[idx] = _creator\n    self.indexOfWhitelistedCreator[_creator] = idx\n    self.numWhitelistedCreators = idx + 1\n\n\n# remove creator\n\n\n@internal\ndef _removeWhitelistedCreator(_creator: address):\n    targetIndex: uint256 = self.indexOfWhitelistedCreator[_creator]\n    if targetIndex == 0:\n        return\n\n    lastIndex: uint256 = self.numWhitelistedCreators - 1\n    self.numWhitelistedCreators = lastIndex\n    self.indexOfWhitelistedCreator[_creator] = 0\n\n    # swap with last item if not already last\n    if targetIndex != lastIndex:\n        lastItem: address = self.whitelistedCreators[lastIndex]\n        self.whitelistedCreators[targetIndex] = lastItem\n        self.indexOfWhitelistedCreator[lastItem] = targetIndex\n\n    self.whitelistedCreators[lastIndex] = empty(address)\n\n\n#################\n# Locked Signer #\n#################\n\n\n@external\ndef setLockedSigner(_signer: address, _isLocked: bool):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert not deptBasics.isPaused # dev: not activated\n    self.isLockedSigner[_signer] = _isLocked",
            "sha256sum": "d5e821fec25f5b5764e4f968ff9de21776c631fd8390b9cd102907fe69e71776"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/data/MissionControl.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.3+commit.bff19ea2",
        "integrity": "52c1f3a588e0d9db9f9c3ae271873fdbb1501f2c359b5e0a1971af572132c7b1"
      },
      "args": "00000000000000000000000044cf3c4f000dfd76a35d03298049d37be688d6f9000000000000000000000000dd1b957934efece6b1097f3e4a5dc5cfb89b5f5d",
      "file": "contracts/data/MissionControl.vy"
    },
    "LootDistributor": {
      "address": "0xFA1AB772E04cb8b462fD766cC8716a81e95d2879",
      "abi": [
        {
          "name": "TransactionFeePaid",
          "inputs": [
            {
              "name": "user",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "feeAmount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "action",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "RevenueTransferredToGov",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "action",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "YieldPerformanceFeePaid",
          "inputs": [
            {
              "name": "user",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "feeAmount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "yieldRealized",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AmbassadorTxFeePaid",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "totalFee",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "ambassadorFeeRatio",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "ambassadorFee",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "ambassador",
              "type": "address",
              "indexed": true
            },
            {
              "name": "action",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "YieldBonusPaid",
          "inputs": [
            {
              "name": "bonusAsset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "bonusAmount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "bonusRatio",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "yieldRealized",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "isAmbassador",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LootAdjusted",
          "inputs": [
            {
              "name": "user",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newClaimable",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LootClaimed",
          "inputs": [
            {
              "name": "user",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "DepositRewardsAdded",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "addedAmount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "newTotalAmount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "adder",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "DepositRewardsClaimed",
          "inputs": [
            {
              "name": "user",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "userRewards",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "remainingRewards",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "DepositRewardsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "DepartmentPauseModified",
          "inputs": [
            {
              "name": "isPaused",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "DepartmentFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "balance",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddys",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "undyToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "hatchery",
                  "type": "address"
                },
                {
                  "name": "lootDistributor",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                },
                {
                  "name": "walletBackpack",
                  "type": "address"
                },
                {
                  "name": "billing",
                  "type": "address"
                },
                {
                  "name": "vaultRegistry",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUndyHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canMintUndy",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pause",
          "inputs": [
            {
              "name": "_shouldPause",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFundsMany",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_assets",
              "type": "address[]"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isPaused",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLootFromSwapOrRewards",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_feeAmount",
              "type": "uint256"
            },
            {
              "name": "_action",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLootFromSwapOrRewards",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_feeAmount",
              "type": "uint256"
            },
            {
              "name": "_action",
              "type": "uint256"
            },
            {
              "name": "_missionControl",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLootFromYieldProfit",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_feeAmount",
              "type": "uint256"
            },
            {
              "name": "_yieldRealized",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLootFromYieldProfit",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_feeAmount",
              "type": "uint256"
            },
            {
              "name": "_yieldRealized",
              "type": "uint256"
            },
            {
              "name": "_missionControl",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLootFromYieldProfit",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_feeAmount",
              "type": "uint256"
            },
            {
              "name": "_yieldRealized",
              "type": "uint256"
            },
            {
              "name": "_missionControl",
              "type": "address"
            },
            {
              "name": "_appraiser",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLootFromYieldProfit",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_feeAmount",
              "type": "uint256"
            },
            {
              "name": "_yieldRealized",
              "type": "uint256"
            },
            {
              "name": "_missionControl",
              "type": "address"
            },
            {
              "name": "_appraiser",
              "type": "address"
            },
            {
              "name": "_legoBook",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRevShareAndBonusLoot",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getClaimableLootForAsset",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getTotalClaimableAssets",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "adjustLoot",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_newClaimable",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "updateDepositPoints",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "updateDepositPointsWithNewValue",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_newUsdValue",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "updateDepositPointsOnEjection",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLatestDepositPoints",
          "inputs": [
            {
              "name": "_usdValue",
              "type": "uint256"
            },
            {
              "name": "_lastUpdate",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidWalletConfig",
          "inputs": [
            {
              "name": "_wallet",
              "type": "address"
            },
            {
              "name": "_caller",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimDepositRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getClaimableDepositRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addDepositRewards",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverDepositRewards",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getSwapFee",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getSwapFee",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_missionControl",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRewardsFee",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRewardsFee",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_missionControl",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimAllLoot",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "validateCanClaimLoot",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_caller",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "lastClaim",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalClaimableLoot",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "claimableLoot",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "claimableAssets",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfClaimableAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numClaimableAssets",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "depositRewards",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "amount",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "RIPE_TOKEN",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "RIPE_REGISTRY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_undyHq",
              "type": "address"
            },
            {
              "name": "_ripeToken",
              "type": "address"
            },
            {
              "name": "_ripeRegistry",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/modules/Addys.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\ninterface UndyHq:\n    def isValidAddr(_addr: address) -> bool: view\n    def getAddr(_regId: uint256) -> address: view\n    def undyToken() -> address: view\n\ninterface Switchboard:\n    def isSwitchboardAddr(_addr: address) -> bool: view\n\ninterface LegoBook:\n    def isLegoAddr(_addr: address) -> bool: view\n\nstruct Addys:\n    hq: address\n    undyToken: address\n    ledger: address\n    missionControl: address\n    legoBook: address\n    switchboard: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    walletBackpack: address\n    billing: address\n    vaultRegistry: address\n\n# hq\nUNDY_HQ_FOR_ADDYS: immutable(address)\n\n# core addys\nLEDGER_ID: constant(uint256) = 1\nMISSION_CONTROL_ID: constant(uint256) = 2\nLEGO_BOOK_ID: constant(uint256) = 3\nSWITCHBOARD_ID: constant(uint256) = 4\nHATCHERY_ID: constant(uint256) = 5\nLOOT_DISTRIBUTOR_ID: constant(uint256) = 6\nAPPRAISER_ID: constant(uint256) = 7\nWALLET_BACKPACK_ID: constant(uint256) = 8\nBILLING_ID: constant(uint256) = 9\nVAULT_REGISTRY_ID: constant(uint256) = 10\n\n\n@deploy\ndef __init__(_undyHq: address):\n    assert _undyHq != empty(address) # dev: invalid undy hq\n    UNDY_HQ_FOR_ADDYS = _undyHq\n\n\n########\n# Core #\n########\n\n\n@view\n@external\ndef getAddys() -> Addys:\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _getAddys(_addys: Addys = empty(Addys)) -> Addys:\n    if _addys.hq != empty(address):\n        return _addys\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _generateAddys() -> Addys:\n    hq: address = UNDY_HQ_FOR_ADDYS\n    return Addys(\n        hq = hq,\n        undyToken = staticcall UndyHq(hq).undyToken(),\n        ledger = staticcall UndyHq(hq).getAddr(LEDGER_ID),\n        missionControl = staticcall UndyHq(hq).getAddr(MISSION_CONTROL_ID),\n        legoBook = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID),\n        switchboard = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID),\n        hatchery = staticcall UndyHq(hq).getAddr(HATCHERY_ID),\n        lootDistributor = staticcall UndyHq(hq).getAddr(LOOT_DISTRIBUTOR_ID),\n        appraiser = staticcall UndyHq(hq).getAddr(APPRAISER_ID),\n        walletBackpack = staticcall UndyHq(hq).getAddr(WALLET_BACKPACK_ID),\n        billing = staticcall UndyHq(hq).getAddr(BILLING_ID),\n        vaultRegistry = staticcall UndyHq(hq).getAddr(VAULT_REGISTRY_ID),\n    )\n\n\n##########\n# Tokens #\n##########\n\n\n@view\n@internal\ndef _getUndyToken() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).undyToken()\n\n\n###########\n# Helpers #\n###########\n\n\n# undy hq\n\n\n@view\n@external\ndef getUndyHq() -> address:\n    return self._getUndyHq()\n\n\n@view\n@internal\ndef _getUndyHq() -> address:\n    return UNDY_HQ_FOR_ADDYS\n\n\n# utils\n\n\n@view\n@internal\ndef _isValidUndyAddr(_addr: address, _hq: address = empty(address)) -> bool:\n    hq: address = _hq\n    if _hq == empty(address):\n        hq = UNDY_HQ_FOR_ADDYS\n    \n    # core departments\n    if staticcall UndyHq(hq).isValidAddr(_addr):\n        return True\n\n    # lego book\n    legoBook: address = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID)\n    if legoBook != empty(address) and staticcall LegoBook(legoBook).isLegoAddr(_addr):\n        return True\n\n    # switchboard config\n    switchboard: address = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID)\n    if switchboard != empty(address) and staticcall Switchboard(switchboard).isSwitchboardAddr(_addr):\n        return True\n\n    return False\n\n\n@view\n@internal\ndef _isSwitchboardAddr(_addr: address) -> bool:\n    switchboard: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n    if switchboard == empty(address):\n        return False\n    return staticcall Switchboard(switchboard).isSwitchboardAddr(_addr)\n\n\n@view\n@internal\ndef _isLegoBookAddr(_addr: address) -> bool:\n    legoBook: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n    if legoBook == empty(address):\n        return False\n    return staticcall LegoBook(legoBook).isLegoAddr(_addr)\n\n\n###############\n# Departments #\n###############\n\n\n# ledger\n\n\n@view\n@internal\ndef _getLedgerId() -> uint256:\n    return LEDGER_ID\n\n\n@view\n@internal\ndef _getLedgerAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEDGER_ID)\n\n\n# mission control\n\n\n@view\n@internal\ndef _getMissionControlId() -> uint256:\n    return MISSION_CONTROL_ID\n\n\n@view\n@internal\ndef _getMissionControlAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(MISSION_CONTROL_ID)\n\n\n# lego book\n\n\n@view\n@internal\ndef _getLegoBookId() -> uint256:\n    return LEGO_BOOK_ID\n\n\n@view\n@internal\ndef _getLegoBookAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n\n\n# switchboard\n\n\n@view\n@internal\ndef _getSwitchboardId() -> uint256:\n    return SWITCHBOARD_ID\n\n\n@view\n@internal\ndef _getSwitchboardAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n\n\n# hatchery\n\n\n@view\n@internal\ndef _getHatcheryId() -> uint256:\n    return HATCHERY_ID\n\n\n@view\n@internal\ndef _getHatcheryAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(HATCHERY_ID)\n\n\n# loot distributor\n\n\n@view\n@internal\ndef _getLootDistributorId() -> uint256:\n    return LOOT_DISTRIBUTOR_ID\n\n\n@view\n@internal\ndef _getLootDistributorAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LOOT_DISTRIBUTOR_ID)\n\n\n# appraiser\n\n\n@view\n@internal\ndef _getAppraiserId() -> uint256:\n    return APPRAISER_ID\n\n\n@view\n@internal\ndef _getAppraiserAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(APPRAISER_ID)\n\n\n# wallet backpack\n\n\n@view\n@internal\ndef _getWalletBackpackId() -> uint256:\n    return WALLET_BACKPACK_ID\n\n\n@view\n@internal\ndef _getWalletBackpackAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(WALLET_BACKPACK_ID)\n\n\n# billing\n\n\n@view\n@internal\ndef _getBillingId() -> uint256:\n    return BILLING_ID\n\n\n@view\n@internal\ndef _getBillingAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(BILLING_ID)\n\n\n# vault registry\n\n\n@view\n@internal\ndef _getVaultRegistryId() -> uint256:\n    return VAULT_REGISTRY_ID\n\n\n@view\n@internal\ndef _getVaultRegistryAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(VAULT_REGISTRY_ID)",
            "sha256sum": "4df6b72db9bb417d1af81660175be1450cfb7b3575f3d17a5b8a130bff87b781"
          },
          "interfaces/Department.vyi": {
            "content": "# @version 0.4.3\n\n\n###########\n# Minting #\n###########\n\n\n@view\n@external\ndef canMintUndy() -> bool:\n    # used in UndyHq.vy\n    ...\n\n\n########\n# Undy #\n########\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "53e48da591c4ee36045a8950c9d3a01458456b471b797df536e9a9f54404e721"
          },
          "contracts/modules/DeptBasics.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nuses: addys\nimplements: dept\n\nimport contracts.modules.Addys as addys\nimport interfaces.Department as dept\nfrom ethereum.ercs import IERC20\n\nevent DepartmentPauseModified:\n    isPaused: bool\n\nevent DepartmentFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    balance: uint256\n\nisPaused: public(bool)\n\nCAN_MINT_UNDY: immutable(bool)\nMAX_RECOVER_ASSETS: constant(uint256) = 20\n\n\n@deploy\ndef __init__(_shouldPause: bool, _canMintUndy: bool):\n    self.isPaused = _shouldPause\n    CAN_MINT_UNDY = _canMintUndy\n\n\n###########\n# Minting #\n###########\n\n\n@view\n@external\ndef canMintUndy() -> bool:\n    return CAN_MINT_UNDY\n\n\n########\n# Undy #\n########\n\n\n# activate\n\n\n@external\ndef pause(_shouldPause: bool):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert _shouldPause != self.isPaused # dev: no change\n    self.isPaused = _shouldPause\n    log DepartmentPauseModified(isPaused=_shouldPause)\n\n\n# recover funds\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    self._recoverFunds(_recipient, _asset)\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, MAX_RECOVER_ASSETS]):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    for a: address in _assets:\n        self._recoverFunds(_recipient, a)\n\n\n@internal\ndef _recoverFunds(_recipient: address, _asset: address):\n    assert empty(address) not in [_recipient, _asset] # dev: invalid recipient or asset\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    assert balance != 0 # dev: nothing to recover\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log DepartmentFundsRecovered(asset=_asset, recipient=_recipient, balance=balance)\n",
            "sha256sum": "976a50a3807bcf71f3f1c57de5cd7a59fe4e8f27b4d4560e774073962f44d1ac"
          },
          "interfaces/LegoStructs.vyi": {
            "content": "# @version 0.4.3\n\nstruct VaultTokenInfo:\n    underlyingAsset: address\n    decimals: uint256\n    lastAveragePricePerShare: uint256\n\nstruct SnapShotPriceConfig:\n    minSnapshotDelay: uint256\n    maxNumSnapshots: uint256\n    maxUpsideDeviation: uint256\n    staleTime: uint256\n\nstruct SingleSnapShot:\n    totalSupply: uint256\n    pricePerShare: uint256\n    lastUpdate: uint256\n\nstruct SnapShotData:\n    lastSnapShot: SingleSnapShot\n    nextIndex: uint256\n",
            "sha256sum": "8ae48be17d812d57fbd671bbf0593e8abf175ad0924e47c5997823cac19ec806"
          },
          "interfaces/YieldLego.vyi": {
            "content": "# @version 0.4.3\n\nfrom interfaces import LegoStructs as ls\n\n\n###################\n# Underlying Data #\n###################\n\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    ...\n\n\n@view\n@external\ndef getUnderlyingBalances(_vaultToken: address, _vaultTokenBalance: uint256) -> (uint256, uint256):\n    ...\n\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    ...\n\n\n@view\n@external\ndef getUnderlyingAmountSafe(_vaultToken: address, _vaultTokenBalance: uint256) -> uint256:\n    ...\n\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> (address, uint256, uint256):\n    ...\n\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> uint256:\n    ...\n\n\n###############\n# Other Utils #\n###############\n\n\n@view\n@external\ndef isRebasing() -> bool:\n    ...\n\n\n@view\n@external\ndef getPricePerShare(_vaultToken: address, _decimals: uint256 = 0) -> uint256:\n    ...\n\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef canRegisterVaultToken(_asset: address, _vaultToken: address) -> bool:\n    ...\n\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef getUtilizationRatio(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef getAvailLiquidity(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef isEligibleForYieldBonus(_asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef getWithdrawalFees(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    ...\n\n\n###################\n# Yield Lego Data #\n###################\n\n\n@view\n@external\ndef isLegoAsset(_asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, 40]:\n    ...\n\n\n@view\n@external\ndef getAssets() -> DynArray[address, 20]:\n    ...\n\n\n@view\n@external\ndef isAssetOpportunity(_asset: address, _vaultAddr: address) -> bool:\n    ...\n\n\n@view\n@external\ndef getNumLegoAssets() -> uint256:\n    ...\n\n\n@view\n@external\ndef assets(_index: uint256) -> address:\n    ...\n\n\n@view\n@external\ndef indexOfAsset(_asset: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef numAssets() -> uint256:\n    ...\n\n\n@view\n@external\ndef assetOpportunities(_asset: address, _index: uint256) -> address:\n    ...\n\n\n@view\n@external\ndef indexOfAssetOpportunity(_asset: address, _vaultAddr: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef numAssetOpportunities(_asset: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef vaultToAsset(_vaultAddr: address) -> ls.VaultTokenInfo:\n    ...\n\n\n# price snapshots\n\n\n@external\ndef addPriceSnapshot(_vaultToken: address) -> bool:\n    ...\n\n\n@view\n@external\ndef snapShotPriceConfig() -> ls.SnapShotPriceConfig:\n    ...\n\n\n@view\n@external\ndef snapShotData(_vaultToken: address) -> ls.SnapShotData:\n    ...\n\n\n@view\n@external\ndef snapShots(_vaultToken: address, _index: uint256) -> ls.SingleSnapShot:\n    ...\n\n\n@view\n@external\ndef getWeightedPricePerShare(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef getLatestSnapshot(_vaultToken: address, _pricePerShare: uint256) -> ls.SingleSnapShot:\n    ...\n\n\n@external\ndef setSnapShotPriceConfig(_config: ls.SnapShotPriceConfig):\n    ...\n",
            "sha256sum": "db91c139f6018f5218b389d08c8703bc16fb994aa948805dbfea27e072f382ec"
          },
          "interfaces/WalletStructs.vyi": {
            "content": "# @version 0.4.3\n\nflag ActionType:\n    TRANSFER\n    EARN_DEPOSIT\n    EARN_WITHDRAW\n    EARN_REBALANCE\n    SWAP\n    MINT_REDEEM\n    CONFIRM_MINT_REDEEM\n    ADD_COLLATERAL\n    REMOVE_COLLATERAL\n    BORROW\n    REPAY_DEBT\n    REWARDS\n    ETH_TO_WETH\n    WETH_TO_ETH\n    ADD_LIQ\n    REMOVE_LIQ\n    ADD_LIQ_CONC\n    REMOVE_LIQ_CONC\n    PAY_CHEQUE\n\nstruct WalletAssetData:\n    assetBalance: uint256\n    usdValue: uint256\n    isYieldAsset: bool\n    lastPricePerShare: uint256\n\nstruct ActionData:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    billing: address\n    vaultRegistry: address\n    wallet: address\n    walletConfig: address\n    walletOwner: address\n    inEjectMode: bool\n    isFrozen: bool\n    lastTotalUsdValue: uint256\n    signer: address\n    isManager: bool\n    legoId: uint256\n    legoAddr: address\n    eth: address\n    weth: address\n\nstruct MiniAddys:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    appraiser: address",
            "sha256sum": "466493c129135c95470aaf70eeddc936632f7b0f813396e5a7ddc03bea9da518"
          },
          "interfaces/WalletConfigStructs.vyi": {
            "content": "# @version 0.4.3\n\nMAX_CONFIG_ASSETS: constant(uint256) = 40\nMAX_CONFIG_LEGOS: constant(uint256) = 25\nMAX_ALLOWED_PAYEES: constant(uint256) = 40\n\nflag WhitelistAction:\n    ADD_PENDING\n    CONFIRM_WHITELIST\n    CANCEL_WHITELIST\n    REMOVE_WHITELIST\n\nflag BackpackType:\n    WALLET_KERNEL\n    WALLET_SENTINEL\n    WALLET_HIGH_COMMAND\n    WALLET_PAYMASTER\n    WALLET_CHEQUE_BOOK\n    WALLET_MIGRATOR\n\n# payees\n\nstruct PayeeData:\n    numTxsInPeriod: uint256\n    totalUnitsInPeriod: uint256\n    totalUsdValueInPeriod: uint256\n    totalNumTxs: uint256\n    totalUnits: uint256\n    totalUsdValue: uint256\n    lastTxBlock: uint256\n    periodStartBlock: uint256\n\nstruct PayeeSettings:\n    startBlock: uint256\n    expiryBlock: uint256\n    canPull: bool\n    periodLength: uint256\n    maxNumTxsPerPeriod: uint256\n    txCooldownBlocks: uint256\n    failOnZeroPrice: bool\n    primaryAsset: address\n    onlyPrimaryAsset: bool\n    unitLimits: PayeeLimits\n    usdLimits: PayeeLimits\n\nstruct GlobalPayeeSettings:\n    defaultPeriodLength: uint256\n    startDelay: uint256\n    activationLength: uint256\n    maxNumTxsPerPeriod: uint256\n    txCooldownBlocks: uint256\n    failOnZeroPrice: bool\n    usdLimits: PayeeLimits\n    canPayOwner: bool\n    canPull: bool\n\nstruct PayeeLimits:\n    perTxCap: uint256\n    perPeriodCap: uint256\n    lifetimeCap: uint256\n\nstruct PendingPayee:\n    settings: PayeeSettings\n    initiatedBlock: uint256\n    confirmBlock: uint256\n    currentOwner: address\n\nstruct PayeeManagementBundle:\n    owner: address\n    wallet: address\n    isRegisteredPayee: bool\n    isWhitelisted: bool\n    isExistingCheque: bool\n    payeeSettings: PayeeSettings\n    globalPayeeSettings: GlobalPayeeSettings\n    timeLock: uint256\n    walletConfig: address\n\nstruct RecipientConfigBundle:\n    isWhitelisted: bool\n    isOwner: bool\n    isPayee: bool\n    config: PayeeSettings\n    globalConfig: GlobalPayeeSettings\n    data: PayeeData\n\nstruct WhitelistConfigBundle:\n    owner: address\n    wallet: address\n    isWhitelisted: bool\n    pendingWhitelist: PendingWhitelist\n    isExistingPayee: bool\n    isExistingCheque: bool\n    timeLock: uint256\n    walletConfig: address\n    isManager: bool\n    isOwner: bool\n    whitelistPerms: WhitelistPerms\n    globalWhitelistPerms: WhitelistPerms\n\nstruct PendingWhitelist:\n    initiatedBlock: uint256\n    confirmBlock: uint256\n    currentOwner: address\n\n# cheques\n\nstruct Cheque:\n    recipient: address\n    asset: address\n    amount: uint256\n    creationBlock: uint256\n    unlockBlock: uint256\n    expiryBlock: uint256\n    usdValueOnCreation: uint256\n    canManagerPay: bool\n    canBePulled: bool\n    creator: address\n    active: bool\n\nstruct ChequeSettings:\n    maxNumActiveCheques: uint256\n    maxChequeUsdValue: uint256\n    instantUsdThreshold: uint256\n    perPeriodPaidUsdCap: uint256\n    maxNumChequesPaidPerPeriod: uint256\n    payCooldownBlocks: uint256\n    perPeriodCreatedUsdCap: uint256\n    maxNumChequesCreatedPerPeriod: uint256\n    createCooldownBlocks: uint256\n    periodLength: uint256\n    expensiveDelayBlocks: uint256\n    defaultExpiryBlocks: uint256\n    allowedAssets: DynArray[address, MAX_CONFIG_ASSETS]\n    canManagersCreateCheques: bool\n    canManagerPay: bool\n    canBePulled: bool\n\nstruct ChequeData:\n    numChequesPaidInPeriod: uint256\n    totalUsdValuePaidInPeriod: uint256\n    totalNumChequesPaid: uint256\n    totalUsdValuePaid: uint256\n    lastChequePaidBlock: uint256\n    numChequesCreatedInPeriod: uint256\n    totalUsdValueCreatedInPeriod: uint256\n    totalNumChequesCreated: uint256\n    totalUsdValueCreated: uint256\n    lastChequeCreatedBlock: uint256\n    periodStartBlock: uint256\n\nstruct ChequeManagementBundle:\n    wallet: address\n    walletConfig: address\n    owner: address\n    isRecipientOnWhitelist: bool\n    isCreatorManager: bool\n    managerSettings: ManagerSettings\n    chequeSettings: ChequeSettings\n    chequeData: ChequeData\n    isExistingCheque: bool\n    numActiveCheques: uint256\n    isExistingPayee: bool\n    timeLock: uint256\n\n# managers\n\nstruct ManagerData:\n    numTxsInPeriod: uint256\n    totalUsdValueInPeriod: uint256\n    totalNumTxs: uint256\n    totalUsdValue: uint256\n    lastTxBlock: uint256\n    periodStartBlock: uint256\n    numSwapsInPeriod: uint256\n\nstruct ManagerSettings:\n    startBlock: uint256\n    expiryBlock: uint256\n    limits: ManagerLimits\n    legoPerms: LegoPerms\n    swapPerms: SwapPerms\n    whitelistPerms: WhitelistPerms\n    transferPerms: TransferPerms\n    allowedAssets: DynArray[address, MAX_CONFIG_ASSETS]\n    canClaimLoot: bool\n\nstruct GlobalManagerSettings:\n    managerPeriod: uint256\n    startDelay: uint256\n    activationLength: uint256\n    canOwnerManage: bool\n    limits: ManagerLimits\n    legoPerms: LegoPerms\n    swapPerms: SwapPerms\n    whitelistPerms: WhitelistPerms\n    transferPerms: TransferPerms\n    allowedAssets: DynArray[address, MAX_CONFIG_ASSETS]\n\nstruct ManagerLimits:\n    maxUsdValuePerTx: uint256\n    maxUsdValuePerPeriod: uint256\n    maxUsdValueLifetime: uint256\n    maxNumTxsPerPeriod: uint256\n    txCooldownBlocks: uint256\n    failOnZeroPrice: bool\n\nstruct LegoPerms:\n    canManageYield: bool\n    canBuyAndSell: bool\n    canManageDebt: bool\n    canManageLiq: bool\n    canClaimRewards: bool\n    onlyApprovedYieldOpps: bool\n    allowedLegos: DynArray[uint256, MAX_CONFIG_LEGOS]\n\nstruct SwapPerms:\n    mustHaveUsdValue: bool\n    maxNumSwapsPerPeriod: uint256\n    maxSlippage: uint256\n\nstruct WhitelistPerms:\n    canAddPending: bool\n    canConfirm: bool\n    canCancel: bool\n    canRemove: bool\n\nstruct TransferPerms:\n    canTransfer: bool\n    canCreateCheque: bool\n    canAddPendingPayee: bool\n    allowedPayees: DynArray[address, MAX_ALLOWED_PAYEES]\n\nstruct ManagerConfigBundle:\n    isOwner: bool\n    isManager: bool\n    config: ManagerSettings\n    globalConfig: GlobalManagerSettings\n    data: ManagerData\n    payee: address\n\nstruct ManagerSettingsBundle:\n    owner: address\n    isManager: bool\n    timeLock: uint256\n    walletConfig: address\n    legoBook: address\n    globalManagerSettings: GlobalManagerSettings\n\n# migration\n\nstruct MigrationConfigBundle:\n    owner: address\n    isFrozen: bool\n    numPayees: uint256\n    numWhitelisted: uint256\n    numManagers: uint256\n    startingAgent: address\n    startingAgentIndex: uint256\n    hasPendingOwnerChange: bool\n    groupId: uint256\n    numActiveCheques: uint256\n",
            "sha256sum": "31165468feeac632a1376c70970ce5124f8951392c4deaa01a26176c7f26718a"
          },
          "interfaces/ConfigStructs.vyi": {
            "content": "# @version 0.4.3\n\nstruct UserWalletConfig:\n    walletTemplate: address\n    configTemplate: address\n    numUserWalletsAllowed: uint256\n    enforceCreatorWhitelist: bool\n    minKeyActionTimeLock: uint256\n    maxKeyActionTimeLock: uint256\n    depositRewardsAsset: address\n    lootClaimCoolOffPeriod: uint256\n    txFees: TxFees\n    ambassadorRevShare: AmbassadorRevShare\n    yieldConfig: YieldConfig\n\nstruct AssetConfig:\n    hasConfig: bool\n    txFees: TxFees\n    ambassadorRevShare: AmbassadorRevShare\n    yieldConfig: YieldConfig\n\nstruct TxFees:\n    swapFee: uint256\n    stableSwapFee: uint256\n    rewardsFee: uint256\n\nstruct AmbassadorRevShare:\n    swapRatio: uint256\n    rewardsRatio: uint256\n    yieldRatio: uint256\n\nstruct YieldConfig:\n    maxYieldIncrease: uint256\n    performanceFee: uint256\n    ambassadorBonusRatio: uint256\n    bonusRatio: uint256\n    bonusAsset: address\n\nstruct AgentConfig:\n    startingAgent: address\n    startingAgentActivationLength: uint256\n\nstruct ManagerConfig:\n    managerPeriod: uint256\n    managerActivationLength: uint256\n    mustHaveUsdValueOnSwaps: bool\n    maxNumSwapsPerPeriod: uint256\n    maxSlippageOnSwaps: uint256\n    onlyApprovedYieldOpps: bool\n\nstruct PayeeConfig:\n    payeePeriod: uint256\n    payeeActivationLength: uint256\n\nstruct ChequeConfig:\n    maxNumActiveCheques: uint256\n    instantUsdThreshold: uint256\n    periodLength: uint256\n    expensiveDelayBlocks: uint256\n    defaultExpiryBlocks: uint256\n\nstruct RipeRewardsConfig:\n    stakeRatio: uint256\n    lockDuration: uint256",
            "sha256sum": "4a631b60c85398adcd4e8174532e69540dd8df9afff85b0876f3feeae196af74"
          },
          "contracts/core/LootDistributor.vy": {
            "content": "#     ___                     ___             ___                     ___                           \n#    (   )                   (   )           (   )  .-.              (   )                          \n#     | |    .--.     .--.    | |_         .-.| |  ( __)     .--.     | |_      ___ .-.      .--.   \n#     | |   /    \\   /    \\  (   __)      /   \\ |  (''\")   /  _  \\   (   __)   (   )   \\    /    \\  \n#     | |  |  .-. ; |  .-. ;  | |        |  .-. |   | |   . .' `. ;   | |       | ' .-. ;  |  .-. ; \n#     | |  | |  | | | |  | |  | | ___    | |  | |   | |   | '   | |   | | ___   |  / (___) | |  | | \n#     | |  | |  | | | |  | |  | |(   )   | |  | |   | |   _\\_`.(___)  | |(   )  | |        | |  | | \n#     | |  | |  | | | |  | |  | | | |    | |  | |   | |  (   ). '.    | | | |   | |        | |  | | \n#     | |  | '  | | | '  | |  | ' | |    | '  | |   | |   | |  `\\ |   | ' | |   | |        | '  | | \n#     | |  '  `-' / '  `-' /  ' `-' ;    ' `-'  /   | |   ; '._,' '   ' `-' ;   | |        '  `-' / \n#    (___)  `.__.'   `.__.'    `.__.      `.__,'   (___)   '.___.'     `.__.   (___)        `.__.'  \n#                                                                                \n#     \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n#     \u2551  ** Loot Distributor **                                 \u2551\n#     \u2551  Handles all rewards and revenue share functionality.   \u2551\n#     \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n#\n#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nimplements: Department\n\nexports: addys.__interface__\nexports: deptBasics.__interface__\n\ninitializes: addys\ninitializes: deptBasics[addys := addys]\n\nimport contracts.modules.Addys as addys\nimport contracts.modules.DeptBasics as deptBasics\n\nfrom interfaces import Department\nfrom interfaces import YieldLego as YieldLego\nfrom interfaces import WalletStructs as ws\nfrom interfaces import WalletConfigStructs as wcs\nimport interfaces.ConfigStructs as cs\n\nfrom ethereum.ercs import IERC20\n\ninterface MissionControl:\n    def getSwapFee(_tokenIn: address, _tokenOut: address) -> uint256: view\n    def getLootDistroConfig(_asset: address) -> LootDistroConfig: view\n    def getRewardsFee(_asset: address) -> uint256: view\n    def getLootClaimCoolOffPeriod() -> uint256: view\n    def getDepositRewardsAsset() -> address: view\n    def getRipeRewardsConfig() -> cs.RipeRewardsConfig: view\n\ninterface Ledger:\n    def setUserAndGlobalPoints(_user: address, _userData: PointsData, _globalData: PointsData): nonpayable\n    def getUserAndGlobalPoints(_user: address) -> (PointsData, PointsData): view\n    def ambassadors(_user: address) -> address: view\n    def isUserWallet(_user: address) -> bool: view\n\ninterface Appraiser:\n    def getAssetAmountFromRipe(_asset: address, _usdValue: uint256) -> uint256: view\n    def getUnderlyingUsdValue(_asset: address, _amount: uint256) -> uint256: view\n\ninterface UserWalletConfig:\n    def managerSettings(_manager: address) -> wcs.ManagerSettings: view\n    def owner() -> address: view\n\ninterface RipeTeller:\n    def depositIntoGovVault(_asset: address, _amount: uint256, _lockDuration: uint256, _user: address = msg.sender) -> uint256: nonpayable\n\ninterface Registry:\n    def getAddr(_regId: uint256) -> address: view\n\ninterface UserWallet:\n    def walletConfig() -> address: view\n\ninterface UndyHq:\n    def governance() -> address: view\n\nstruct PointsData:\n    usdValue: uint256\n    depositPoints: uint256\n    lastUpdate: uint256\n\nstruct LootDistroConfig:\n    legoId: uint256\n    legoAddr: address\n    underlyingAsset: address\n    ambassador: address\n    ambassadorRevShare: cs.AmbassadorRevShare\n    ambassadorBonusRatio: uint256\n    bonusRatio: uint256\n    bonusAsset: address\n\nstruct DepositRewards:\n    asset: address\n    amount: uint256\n\nevent TransactionFeePaid:\n    user: indexed(address)\n    asset: indexed(address)\n    feeAmount: uint256\n    action: ws.ActionType\n\nevent RevenueTransferredToGov:\n    asset: indexed(address)\n    amount: uint256\n    action: ws.ActionType\n\nevent YieldPerformanceFeePaid:\n    user: indexed(address)\n    asset: indexed(address)\n    feeAmount: uint256\n    yieldRealized: uint256\n\nevent AmbassadorTxFeePaid:\n    asset: indexed(address)\n    totalFee: uint256\n    ambassadorFeeRatio: uint256\n    ambassadorFee: uint256\n    ambassador: indexed(address)\n    action: ws.ActionType\n\nevent YieldBonusPaid:\n    bonusAsset: indexed(address)\n    bonusAmount: uint256\n    bonusRatio: uint256\n    yieldRealized: uint256\n    recipient: indexed(address)\n    isAmbassador: bool\n\nevent LootAdjusted:\n    user: indexed(address)\n    asset: indexed(address)\n    newClaimable: uint256\n\nevent LootClaimed:\n    user: indexed(address)\n    asset: indexed(address)\n    amount: uint256\n\nevent DepositRewardsAdded:\n    asset: indexed(address)\n    addedAmount: uint256\n    newTotalAmount: uint256\n    adder: indexed(address)\n\nevent DepositRewardsClaimed:\n    user: indexed(address)\n    asset: indexed(address)\n    userRewards: uint256\n    remainingRewards: uint256\n\nevent DepositRewardsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    amount: uint256\n\n# claimable loot\nlastClaim: public(HashMap[address, uint256]) # user -> last claim block\ntotalClaimableLoot: public(HashMap[address, uint256]) # asset -> amount\nclaimableLoot: public(HashMap[address, HashMap[address, uint256]]) # ambassador -> asset -> amount\n\n# ambassador claimable loot\nclaimableAssets: public(HashMap[address, HashMap[uint256, address]]) # ambassador -> index -> asset\nindexOfClaimableAsset: public(HashMap[address, HashMap[address, uint256]]) # ambassador -> asset -> index\nnumClaimableAssets: public(HashMap[address, uint256]) # ambassador -> num assets\n\n# deposit rewards\ndepositRewards: public(DepositRewards)\n\nRIPE_TOKEN: public(immutable(address))\nRIPE_REGISTRY: public(immutable(address))\n\nHUNDRED_PERCENT: constant(uint256) = 100_00 # 100.00%\nEIGHTEEN_DECIMALS: constant(uint256) = 10 ** 18\nMAX_DEREGISTER_ASSETS: constant(uint256) = 20\nRIPE_TELLER_ID: constant(uint256) = 17\n\n\n@deploy\ndef __init__(\n    _undyHq: address,\n    _ripeToken: address,\n    _ripeRegistry: address,\n):\n    addys.__init__(_undyHq)\n    deptBasics.__init__(False, False) # no minting\n\n    assert empty(address) not in [_ripeToken, _ripeRegistry] # dev: invalid addresses\n    RIPE_TOKEN = _ripeToken\n    RIPE_REGISTRY = _ripeRegistry\n\n\n#################\n# Revenue Flows #\n#################\n\n\n# normal fee flow (swaps, rewards)\n\n\n@external\ndef addLootFromSwapOrRewards(\n    _asset: address,\n    _feeAmount: uint256,\n    _action: ws.ActionType,\n    _missionControl: address = empty(address),\n):\n    # if paused, fail gracefully\n    if deptBasics.isPaused:\n        return\n\n    ledger: address = addys._getLedgerAddr()\n    assert staticcall Ledger(ledger).isUserWallet(msg.sender) # dev: not a user wallet\n\n    # finalize amount\n    feeAmount: uint256 = min(_feeAmount, staticcall IERC20(_asset).balanceOf(msg.sender))\n    if feeAmount == 0:\n        return\n\n    assert extcall IERC20(_asset).transferFrom(msg.sender, self, feeAmount, default_return_value=True) # dev: transfer failed\n    log TransactionFeePaid(user = msg.sender, asset = _asset, feeAmount = feeAmount, action = _action)\n\n    ambFee: uint256 = 0\n    ambassador: address = staticcall Ledger(ledger).ambassadors(msg.sender)\n    if ambassador != empty(address):\n        missionControl: address = _missionControl if _missionControl != empty(address) else addys._getMissionControlAddr()\n        config: LootDistroConfig = staticcall MissionControl(missionControl).getLootDistroConfig(_asset)\n        config.ambassador = ambassador\n        ambFee = self._handleAmbassadorTxFee(_asset, feeAmount, _action, config)\n\n    # transfer leftover revenue to gov\n    leftoverFee: uint256 = feeAmount - min(feeAmount, ambFee)\n    if leftoverFee != 0:\n        self._transferRevenueToGov(_asset, leftoverFee, _action)\n\n\n# yield profit flow\n\n\n@external\ndef addLootFromYieldProfit(\n    _asset: address,\n    _feeAmount: uint256,\n    _yieldRealized: uint256,\n    _missionControl: address = empty(address),\n    _appraiser: address = empty(address),\n    _legoBook: address = empty(address),\n):\n    # if paused, fail gracefully\n    if deptBasics.isPaused:\n        return\n\n    ledger: address = addys._getLedgerAddr()\n    assert staticcall Ledger(ledger).isUserWallet(msg.sender) # dev: not a user wallet\n    log YieldPerformanceFeePaid(user = msg.sender, asset = _asset, feeAmount = _feeAmount, yieldRealized = _yieldRealized)\n\n    ambassador: address = staticcall Ledger(ledger).ambassadors(msg.sender)\n    missionControl: address = _missionControl if _missionControl != empty(address) else addys._getMissionControlAddr()\n    config: LootDistroConfig = staticcall MissionControl(missionControl).getLootDistroConfig(_asset)\n    config.ambassador = ambassador\n\n    # handle fee (this may be 0) -- no need to `transferFrom` in this case, it's already in this contract\n    ambFee: uint256 = 0\n    if _feeAmount != 0 and ambassador != empty(address):\n        ambFee = self._handleAmbassadorTxFee(_asset, _feeAmount, empty(ws.ActionType), config)\n\n    # transfer leftover revenue to gov\n    leftoverFee: uint256 = _feeAmount - min(_feeAmount, ambFee)\n    if leftoverFee != 0:\n        self._transferRevenueToGov(_asset, leftoverFee, ws.ActionType.EARN_WITHDRAW)\n\n    # yield bonus -- must be eligible\n    if config.legoAddr != empty(address) and staticcall YieldLego(config.legoAddr).isEligibleForYieldBonus(_asset):\n        self._handleYieldBonus(msg.sender, _asset, _yieldRealized, config, _appraiser)\n\n\n# ambassador rev share (transaction fees)\n\n\n@internal\ndef _handleAmbassadorTxFee(\n    _asset: address,\n    _feeAmount: uint256,\n    _action: ws.ActionType,\n    _config: LootDistroConfig,\n) -> uint256:\n    feeRatio: uint256 = _config.ambassadorRevShare.yieldRatio\n    if _action == ws.ActionType.SWAP:\n        feeRatio = _config.ambassadorRevShare.swapRatio\n    elif _action == ws.ActionType.REWARDS:\n        feeRatio = _config.ambassadorRevShare.rewardsRatio\n\n    # finalize fee\n    ambassadorRatio: uint256 = min(feeRatio, HUNDRED_PERCENT)\n    fee: uint256 = min(_feeAmount * ambassadorRatio // HUNDRED_PERCENT, staticcall IERC20(_asset).balanceOf(self))\n    if fee != 0:\n        self._addClaimableLootToUser(_config.ambassador, _asset, fee)\n        log AmbassadorTxFeePaid(asset = _asset, totalFee = _feeAmount, ambassadorFeeRatio = feeRatio, ambassadorFee = fee, ambassador = _config.ambassador, action = _action)\n    return fee\n\n\n# transfer revenue to gov\n\n\n@internal\ndef _transferRevenueToGov(_asset: address, _amount: uint256, _action: ws.ActionType):\n    amount: uint256 = min(_amount, staticcall IERC20(_asset).balanceOf(self))\n    if amount == 0:\n        return\n    governance: address = staticcall UndyHq(addys._getUndyHq()).governance()\n    if governance == empty(address):\n        return\n    assert extcall IERC20(_asset).transfer(governance, amount, default_return_value=True) # dev: transfer failed\n    log RevenueTransferredToGov(asset = _asset, amount = amount, action = _action)\n\n\n###############\n# Yield Bonus #\n###############\n\n\n@internal\ndef _handleYieldBonus(\n    _user: address,\n    _asset: address,\n    _yieldRealized: uint256,\n    _config: LootDistroConfig,\n    _appraiser: address,\n):\n    # early return if no bonusAsset (RIPE token) configured\n    if empty(address) in [_config.bonusAsset, _asset] or _yieldRealized == 0:\n        return\n\n    # get addys (if necessary)\n    appraiser: address = _appraiser\n    if _appraiser == empty(address):\n        appraiser = addys._getAppraiserAddr()\n\n    # convert yield realized to USD value\n    usdValue: uint256 = 0\n    if _config.underlyingAsset != empty(address):\n        underlyingAmount: uint256 = staticcall YieldLego(_config.legoAddr).getUnderlyingAmount(_asset, _yieldRealized)\n        usdValue = staticcall Appraiser(appraiser).getUnderlyingUsdValue(_config.underlyingAsset, underlyingAmount)\n    else:\n        usdValue = staticcall Appraiser(appraiser).getUnderlyingUsdValue(_asset, _yieldRealized)\n    if usdValue == 0:\n        return\n\n    # convert USD value to RIPE token amount\n    bonusAsset: address = _config.bonusAsset # RIPE token\n    bonusAssetYieldRealized: uint256 = staticcall Appraiser(appraiser).getAssetAmountFromRipe(bonusAsset, usdValue)\n\n    # no bonus to distribute\n    currentBalance: uint256 = staticcall IERC20(bonusAsset).balanceOf(self)\n    if bonusAssetYieldRealized == 0 or currentBalance == 0:\n        return\n\n    # check deposit rewards asset\n    reservedForDepositRewards: uint256 = 0\n    depositRewards: DepositRewards = self.depositRewards\n    if bonusAsset == depositRewards.asset:\n        reservedForDepositRewards = depositRewards.amount\n\n    # user bonus\n    if _config.bonusRatio != 0:\n        self._handleSpecificYieldBonus(False, bonusAsset, bonusAssetYieldRealized, _config.bonusRatio, _user, currentBalance, reservedForDepositRewards)\n\n    # ambassador bonus\n    if _config.ambassador != empty(address) and _config.ambassadorBonusRatio != 0:\n        self._handleSpecificYieldBonus(True, bonusAsset, bonusAssetYieldRealized, _config.ambassadorBonusRatio, _config.ambassador, currentBalance, reservedForDepositRewards)\n\n\n# handle specific yield bonus\n\n\n@internal\ndef _handleSpecificYieldBonus(\n    _isAmbassador: bool,\n    _bonusAsset: address,\n    _bonusAssetYieldRealized: uint256,\n    _bonusRatio: uint256,\n    _recipient: address,\n    _currentBalance: uint256,\n    _reservedForDepositRewards: uint256,\n) -> uint256:\n    bonusAmount: uint256 = min(_bonusAssetYieldRealized * _bonusRatio // HUNDRED_PERCENT, _bonusAssetYieldRealized)\n\n    # check what's available for bonus\n    availableForBonus: uint256 = 0\n    unavailableAmount: uint256 = self.totalClaimableLoot[_bonusAsset] + _reservedForDepositRewards\n    if _currentBalance > unavailableAmount:\n        availableForBonus = _currentBalance - unavailableAmount\n\n    bonusAmount = min(bonusAmount, availableForBonus)\n    if bonusAmount != 0:\n        self._addClaimableLootToUser(_recipient, _bonusAsset, bonusAmount)\n        log YieldBonusPaid(bonusAsset = _bonusAsset, bonusAmount = bonusAmount, bonusRatio = _bonusRatio, yieldRealized = _bonusAssetYieldRealized, recipient = _recipient, isAmbassador = _isAmbassador)\n\n    return bonusAmount\n\n\n################################\n# Claim Rev Share / Bonus Loot #\n################################\n\n\n@external\ndef claimRevShareAndBonusLoot(_user: address) -> uint256:\n    a: addys.Addys = addys._getAddys()\n    assert not deptBasics.isPaused # dev: contract paused\n\n    # permission check\n    assert self._validateCanClaimLoot(_user, msg.sender, a.ledger, a.missionControl) # dev: no perms\n\n    # ripe params\n    ripeTeller: address = staticcall Registry(RIPE_REGISTRY).getAddr(RIPE_TELLER_ID)\n    ripeConfig: cs.RipeRewardsConfig = staticcall MissionControl(a.missionControl).getRipeRewardsConfig()\n    ripeLockDuration: uint256 = ripeConfig.lockDuration\n    ripeStakeRatio: uint256 = ripeConfig.stakeRatio\n\n    # claim rev share and bonus loot\n    assetsClaimed: uint256 = self._claimRevShareAndBonusLoot(_user, ripeStakeRatio, ripeLockDuration, ripeTeller)\n    assert assetsClaimed != 0 # dev: no assets claimed\n\n    self.lastClaim[_user] = block.number\n    return assetsClaimed\n\n\n@internal\ndef _claimRevShareAndBonusLoot(\n    _user: address,\n    _ripeStakeRatio: uint256,\n    _ripeLockDuration: uint256,\n    _ripeTeller: address,\n) -> uint256:\n    numAssets: uint256 = self.numClaimableAssets[_user]\n    if numAssets == 0:\n        return 0\n\n    assetsClaimed: uint256 = 0\n    assetsToDeregister: DynArray[address, MAX_DEREGISTER_ASSETS] = []\n\n    # iterate through all claimable assets for user\n    for i: uint256 in range(1, numAssets, bound=max_value(uint256)):\n        asset: address = self.claimableAssets[_user][i]\n        if asset == empty(address):\n            continue\n\n        didClaim: bool = False\n        shouldDeregister: bool = False\n        didClaim, shouldDeregister = self._claimLootForAsset(_user, asset, _ripeStakeRatio, _ripeLockDuration, _ripeTeller)\n        if didClaim:\n            assetsClaimed += 1\n\n        # add to deregister list\n        if shouldDeregister and len(assetsToDeregister) < MAX_DEREGISTER_ASSETS:\n            assetsToDeregister.append(asset)\n\n    # deregister assets\n    if len(assetsToDeregister) != 0:\n        for asset: address in assetsToDeregister:\n            self._deregisterClaimableAssetForUser(_user, asset)\n\n    return assetsClaimed\n\n\n# specific asset claim\n\n\n@internal\ndef _claimLootForAsset(\n    _user: address,\n    _asset: address,\n    _ripeStakeRatio: uint256,\n    _ripeLockDuration: uint256,\n    _ripeTeller: address,\n) -> (bool, bool):\n    claimableAmount: uint256 = self.claimableLoot[_user][_asset]\n    if claimableAmount == 0:\n        return False, True\n\n    # check contract has enough balance\n    transferAmount: uint256 = min(claimableAmount, staticcall IERC20(_asset).balanceOf(self))\n    if transferAmount == 0:\n        return False, False\n\n    # transfer to user\n    if _ripeTeller != empty(address) and _asset == RIPE_TOKEN:\n        self._handleRipeRewards(_user, transferAmount, _ripeStakeRatio, _ripeLockDuration, _asset, _ripeTeller)\n    else:\n        assert extcall IERC20(_asset).transfer(_user, transferAmount, default_return_value=True) # dev: xfer fail\n\n    # update tracking\n    self.totalClaimableLoot[_asset] -= transferAmount\n    self.claimableLoot[_user][_asset] -= transferAmount\n\n    log LootClaimed(\n        user = _user,\n        asset = _asset,\n        amount = transferAmount,\n    )\n    return True, claimableAmount == transferAmount\n\n\n@view\n@external\ndef getClaimableLootForAsset(_user: address, _asset: address) -> uint256:\n    claimableAmount: uint256 = self.claimableLoot[_user][_asset]\n    return min(claimableAmount, staticcall IERC20(_asset).balanceOf(self))\n\n\n# claimable assets\n\n\n@view\n@external\ndef getTotalClaimableAssets(_user: address) -> uint256:\n    numAssets: uint256 = self.numClaimableAssets[_user]\n    if numAssets == 0:\n        return 0\n\n    totalAssets: uint256 = 0\n    for i: uint256 in range(1, numAssets, bound=max_value(uint256)):\n        asset: address = self.claimableAssets[_user][i]\n        if asset == empty(address):\n            continue\n\n        claimableAmount: uint256 = min(self.claimableLoot[_user][asset], staticcall IERC20(asset).balanceOf(self))\n        if claimableAmount != 0:\n            totalAssets += 1\n\n    return totalAssets\n\n\n# adjust loot (cheaters!)\n\n\n@external\ndef adjustLoot(_user: address, _asset: address, _newClaimable: uint256) -> bool:\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert not deptBasics.isPaused # dev: contract paused\n\n    # invalid inputs\n    if empty(address) in [_user, _asset]:\n        return False\n\n    # can only adjust down (not up)\n    claimableAmount: uint256 = self.claimableLoot[_user][_asset]\n    if claimableAmount == 0 or _newClaimable >= claimableAmount:\n        return False\n\n    # update claimable loot for user\n    self.claimableLoot[_user][_asset] = _newClaimable\n\n    # update total claimable loot\n    totalClaimableLoot: uint256 = self.totalClaimableLoot[_asset]\n    totalClaimableLoot -= claimableAmount\n    totalClaimableLoot += _newClaimable\n    self.totalClaimableLoot[_asset] = totalClaimableLoot\n\n    # deregister asset if necessary\n    if _newClaimable == 0:\n        self._deregisterClaimableAssetForUser(_user, _asset)\n\n    log LootAdjusted(user = _user, asset = _asset, newClaimable = _newClaimable)\n    return True\n\n\n#####################\n# Loot Registration #\n#####################\n\n\n# add loot to user\n\n\n@internal\ndef _addClaimableLootToUser(_user: address, _asset: address, _amount: uint256):\n    self.totalClaimableLoot[_asset] += _amount\n    self.claimableLoot[_user][_asset] += _amount\n    self._registerClaimableAssetForUser(_user, _asset)\n\n\n# register claimable asset\n\n\n@internal\ndef _registerClaimableAssetForUser(_user: address, _asset: address):\n    if self.indexOfClaimableAsset[_user][_asset] != 0:\n        return\n\n    aid: uint256 = self.numClaimableAssets[_user]\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.claimableAssets[_user][aid] = _asset\n    self.indexOfClaimableAsset[_user][_asset] = aid\n    self.numClaimableAssets[_user] = aid + 1\n\n\n# deregister asset\n\n\n@internal\ndef _deregisterClaimableAssetForUser(_user: address, _asset: address) -> bool:\n    numAssets: uint256 = self.numClaimableAssets[_user]\n    if numAssets == 0:\n        return False\n\n    targetIndex: uint256 = self.indexOfClaimableAsset[_user][_asset]\n    if targetIndex == 0:\n        return False\n\n    # update data\n    lastIndex: uint256 = numAssets - 1\n    self.numClaimableAssets[_user] = lastIndex\n    self.indexOfClaimableAsset[_user][_asset] = 0\n\n    # get last item, replace the removed item\n    if targetIndex != lastIndex:\n        lastItem: address = self.claimableAssets[_user][lastIndex]\n        self.claimableAssets[_user][targetIndex] = lastItem\n        self.indexOfClaimableAsset[_user][lastItem] = targetIndex\n\n    return True\n\n\n##################\n# Deposit Points #\n##################\n\n\n# update points\n\n\n@external\ndef updateDepositPoints(_user: address):\n    a: addys.Addys = addys._getAddys()\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert not deptBasics.isPaused # dev: contract paused\n    self._updateDepositPoints(_user, 0, False, a.ledger)\n\n\n@external\ndef updateDepositPointsWithNewValue(_user: address, _newUsdValue: uint256):\n    ledger: address = addys._getLedgerAddr()\n    if not staticcall Ledger(ledger).isUserWallet(msg.sender):\n        assert self._isValidWalletConfig(_user, msg.sender, ledger) # dev: invalid config\n\n    # if paused, fail gracefully\n    if deptBasics.isPaused:\n        return\n\n    self._updateDepositPoints(_user, _newUsdValue, True, ledger)\n\n\n@external\ndef updateDepositPointsOnEjection(_user: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    if deptBasics.isPaused:\n        return\n    self._updateDepositPoints(_user, 0, True, addys._getLedgerAddr())\n\n\n@internal\ndef _updateDepositPoints(\n    _user: address,\n    _newUsdValue: uint256,\n    _didUsdValueChange: bool,\n    _ledger: address,\n):\n    userPoints: PointsData = empty(PointsData)\n    globalPoints: PointsData = empty(PointsData)\n    userPoints, globalPoints = staticcall Ledger(_ledger).getUserAndGlobalPoints(_user)\n\n    prevUserValue: uint256 = userPoints.usdValue\n\n    # update user data\n    userPoints.depositPoints += self._getLatestDepositPoints(prevUserValue, userPoints.lastUpdate)\n    userPoints.lastUpdate = block.number\n    if _didUsdValueChange:\n        userPoints.usdValue = _newUsdValue\n\n    # update global data\n    globalPoints.depositPoints += self._getLatestDepositPoints(globalPoints.usdValue, globalPoints.lastUpdate)\n    globalPoints.lastUpdate = block.number\n    if _didUsdValueChange:\n        globalPoints.usdValue -= prevUserValue\n        globalPoints.usdValue += _newUsdValue\n\n    # save data\n    extcall Ledger(_ledger).setUserAndGlobalPoints(_user, userPoints, globalPoints)\n\n\n# latest points\n\n\n@view\n@external\ndef getLatestDepositPoints(_usdValue: uint256, _lastUpdate: uint256) -> uint256:\n    return self._getLatestDepositPoints(_usdValue, _lastUpdate)\n\n\n@view\n@internal\ndef _getLatestDepositPoints(_usdValue: uint256, _lastUpdate: uint256) -> uint256:\n    if _usdValue == 0 or _lastUpdate == 0 or block.number <= _lastUpdate:\n        return 0\n    points: uint256 = _usdValue * (block.number - _lastUpdate)\n    return points // EIGHTEEN_DECIMALS\n\n\n# validate wallet config\n\n\n@view\n@external\ndef isValidWalletConfig(_wallet: address, _caller: address) -> bool:\n    return self._isValidWalletConfig(_wallet, _caller, addys._getLedgerAddr())\n\n\n@view\n@internal\ndef _isValidWalletConfig(_wallet: address, _caller: address, _ledger: address) -> bool:\n    if not staticcall Ledger(_ledger).isUserWallet(_wallet):\n        return False\n    walletConfig: address = staticcall UserWallet(_wallet).walletConfig()\n    return walletConfig == _caller\n\n\n###################\n# Deposit Rewards #\n###################\n\n\n# claim deposit rewards\n\n\n@external\ndef claimDepositRewards(_user: address) -> uint256:\n    assert not deptBasics.isPaused # dev: contract paused\n    a: addys.Addys = addys._getAddys()\n\n    # cannot claim if this is not current loot distributor, likely migrated to new loot distributor\n    assert a.lootDistributor == self # dev: not current loot distributor\n\n    # permission check\n    assert self._validateCanClaimLoot(_user, msg.sender, a.ledger, a.missionControl) # dev: no perms\n\n    # ripe params\n    ripeTeller: address = staticcall Registry(RIPE_REGISTRY).getAddr(RIPE_TELLER_ID)\n    ripeConfig: cs.RipeRewardsConfig = staticcall MissionControl(a.missionControl).getRipeRewardsConfig()\n    ripeLockDuration: uint256 = ripeConfig.lockDuration\n    ripeStakeRatio: uint256 = ripeConfig.stakeRatio\n\n    # claim rewards\n    userRewards: uint256 = self._claimDepositRewards(_user, ripeStakeRatio, ripeLockDuration, ripeTeller, a.ledger)\n    assert userRewards != 0 # dev: nothing to claim\n\n    self.lastClaim[_user] = block.number\n    return userRewards\n\n\n@internal\ndef _claimDepositRewards(\n    _user: address,\n    _ripeStakeRatio: uint256,\n    _ripeLockDuration: uint256,\n    _ripeTeller: address,\n    _ledger: address,\n) -> uint256:\n    self._updateDepositPoints(_user, 0, False, _ledger)\n\n    # get user and global points\n    userPoints: PointsData = empty(PointsData)\n    globalPoints: PointsData = empty(PointsData)\n    userPoints, globalPoints = staticcall Ledger(_ledger).getUserAndGlobalPoints(_user)\n    if userPoints.depositPoints == 0 or globalPoints.depositPoints == 0:\n        return 0\n\n    # check if there is anything available for rewards\n    data: DepositRewards = self.depositRewards\n    if data.asset == empty(address) or data.amount == 0:\n        return 0\n\n    # calculate user's share, transfer to user\n    availableRewards: uint256 = min(data.amount, staticcall IERC20(data.asset).balanceOf(self))\n    userRewards: uint256 = availableRewards * userPoints.depositPoints // globalPoints.depositPoints\n    if userRewards == 0:\n        return 0\n\n    # transfer to user\n    if _ripeTeller != empty(address) and data.asset == RIPE_TOKEN:\n        self._handleRipeRewards(_user, userRewards, _ripeStakeRatio, _ripeLockDuration, data.asset, _ripeTeller)\n    else:\n        assert extcall IERC20(data.asset).transfer(_user, userRewards, default_return_value=True) # dev: xfer fail\n\n    # save rewards data\n    data.amount -= userRewards\n    self.depositRewards = data\n\n    # save / update points\n    globalPoints.depositPoints -= userPoints.depositPoints\n    userPoints.depositPoints = 0\n    extcall Ledger(_ledger).setUserAndGlobalPoints(_user, userPoints, globalPoints)\n\n    log DepositRewardsClaimed(\n        user = _user,\n        asset = data.asset,\n        userRewards = userRewards,\n        remainingRewards = data.amount,\n    )\n    return userRewards\n\n\n@view\n@external\ndef getClaimableDepositRewards(_user: address) -> uint256:\n    userPoints: PointsData = empty(PointsData)\n    globalPoints: PointsData = empty(PointsData)\n    userPoints, globalPoints = staticcall Ledger(addys._getLedgerAddr()).getUserAndGlobalPoints(_user)\n\n    # get latest points\n    userPoints.depositPoints += self._getLatestDepositPoints(userPoints.usdValue, userPoints.lastUpdate)\n    globalPoints.depositPoints += self._getLatestDepositPoints(globalPoints.usdValue, globalPoints.lastUpdate)\n    if userPoints.depositPoints == 0 or globalPoints.depositPoints == 0:\n        return 0\n\n    # check if there is anything available for rewards\n    data: DepositRewards = self.depositRewards\n    if data.asset == empty(address) or data.amount == 0:\n        return 0\n\n    # calculate user's share\n    availableRewards: uint256 = min(data.amount, staticcall IERC20(data.asset).balanceOf(self))\n    userRewards: uint256 = availableRewards * userPoints.depositPoints // globalPoints.depositPoints\n    return userRewards\n\n\n# add rewards\n\n\n@external\ndef addDepositRewards(_asset: address, _amount: uint256):\n    assert not deptBasics.isPaused # dev: contract paused\n    a: addys.Addys = addys._getAddys()\n    depositRewardsAsset: address = staticcall MissionControl(a.missionControl).getDepositRewardsAsset() # dev: invalid asset\n    assert depositRewardsAsset == _asset # dev: invalid asset\n\n    data: DepositRewards = self.depositRewards\n    if data.asset != empty(address) and data.amount != 0:\n        # NOTE: if changing the rewards asset, need to recover the previous asset first (zero out the amount)\n        assert data.asset == depositRewardsAsset # dev: asset mismatch\n\n    # finalize amount\n    amount: uint256 = min(_amount, staticcall IERC20(depositRewardsAsset).balanceOf(msg.sender))\n    assert amount != 0 # dev: nothing to add\n    assert extcall IERC20(depositRewardsAsset).transferFrom(msg.sender, self, amount, default_return_value=True) # dev: transfer failed\n\n    # update data\n    data.asset = depositRewardsAsset\n    data.amount += amount\n    self.depositRewards = data\n\n    log DepositRewardsAdded(asset = depositRewardsAsset, addedAmount = amount, newTotalAmount = data.amount, adder = msg.sender)\n\n\n# recover deposit rewards\n\n\n@external\ndef recoverDepositRewards(_recipient: address):\n    assert not deptBasics.isPaused # dev: contract paused\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n\n    data: DepositRewards = self.depositRewards\n    assert data.asset != empty(address) # dev: nothing to recover\n    amount: uint256 = min(data.amount, staticcall IERC20(data.asset).balanceOf(self))\n    if amount != 0:\n        assert extcall IERC20(data.asset).transfer(_recipient, amount, default_return_value=True) # dev: recovery failed\n\n    self.depositRewards = empty(DepositRewards)\n    log DepositRewardsRecovered(asset=data.asset, recipient=_recipient, amount=amount)\n\n\n# handle ripe rewards\n\n\n@internal\ndef _handleRipeRewards(\n    _user: address,\n    _amount: uint256,\n    _ripeStakeRatio: uint256,\n    _ripeLockDuration: uint256,\n    _ripeToken: address,\n    _ripeTeller: address,\n):\n    # just transfer to user\n    if _ripeStakeRatio == 0:\n        assert extcall IERC20(_ripeToken).transfer(_user, _amount, default_return_value=True) # dev: xfer fail\n        return\n\n    # finalize amounts\n    amountToStake: uint256 = min(_amount * _ripeStakeRatio // HUNDRED_PERCENT, _amount)\n    amountToSend: uint256 = _amount - amountToStake\n\n    # stake ripe tokens\n    if amountToStake != 0:\n        assert extcall IERC20(_ripeToken).approve(_ripeTeller, amountToStake, default_return_value=True) # dev: ripe approval failed\n        extcall RipeTeller(_ripeTeller).depositIntoGovVault(_ripeToken, amountToStake, _ripeLockDuration, _user)\n        assert extcall IERC20(_ripeToken).approve(_ripeTeller, 0, default_return_value=True) # dev: ripe approval failed\n\n    # transfer ripe to user\n    if amountToSend != 0:\n        amount: uint256 = min(amountToSend, staticcall IERC20(_ripeToken).balanceOf(self))\n        assert extcall IERC20(_ripeToken).transfer(_user, amount, default_return_value=True) # dev: ripe transfer failed\n\n\n####################\n# Transaction Fees #\n####################\n\n\n@view\n@external\ndef getSwapFee(_user: address, _tokenIn: address, _tokenOut: address, _missionControl: address = empty(address)) -> uint256:\n    # NOTE: passing in `_user` in case we ever have different fees for different users in future\n\n    missionControl: address = _missionControl\n    if _missionControl == empty(address):\n        missionControl = addys._getMissionControlAddr()\n\n    return staticcall MissionControl(missionControl).getSwapFee(_tokenIn, _tokenOut)\n\n\n@view\n@external\ndef getRewardsFee(_user: address, _asset: address, _missionControl: address = empty(address)) -> uint256:\n    # NOTE: passing in `_user` in case we ever have different fees for different users in future\n\n    missionControl: address = _missionControl\n    if _missionControl == empty(address):\n        missionControl = addys._getMissionControlAddr()\n\n    return staticcall MissionControl(missionControl).getRewardsFee(_asset)\n\n\n#############\n# Utilities #\n#############\n\n\n# claim ALL loot (both rev share and deposit rewards)\n\n\n@external\ndef claimAllLoot(_user: address) -> bool:\n    assert not deptBasics.isPaused # dev: contract paused\n    a: addys.Addys = addys._getAddys()\n\n    # permission check\n    assert self._validateCanClaimLoot(_user, msg.sender, a.ledger, a.missionControl) # dev: no perms\n\n    # ripe params\n    ripeTeller: address = staticcall Registry(RIPE_REGISTRY).getAddr(RIPE_TELLER_ID)\n    ripeConfig: cs.RipeRewardsConfig = staticcall MissionControl(a.missionControl).getRipeRewardsConfig()\n    ripeLockDuration: uint256 = ripeConfig.lockDuration\n    ripeStakeRatio: uint256 = ripeConfig.stakeRatio\n\n    # claim rev share and bonus loot\n    numAssetsClaimed: uint256 = self._claimRevShareAndBonusLoot(_user, ripeStakeRatio, ripeLockDuration, ripeTeller)\n\n    # can only claim rewards if this is current loot distributor\n    if a.lootDistributor == self:\n        userRewards: uint256 = self._claimDepositRewards(_user, ripeStakeRatio, ripeLockDuration, ripeTeller, a.ledger)\n        if userRewards != 0:\n            numAssetsClaimed += 1\n\n    # only save last claim block if there was something claimed\n    if numAssetsClaimed != 0:\n        self.lastClaim[_user] = block.number\n\n    return numAssetsClaimed != 0\n\n\n# validation\n\n\n@view\n@external\ndef validateCanClaimLoot(_user: address, _caller: address) -> bool:\n    a: addys.Addys = addys._getAddys()\n    return self._validateCanClaimLoot(_user, _caller, a.ledger, a.missionControl)\n\n\n@view\n@internal\ndef _validateCanClaimLoot(_user: address, _caller: address, _ledger: address, _missionControl: address) -> bool:\n    if not staticcall Ledger(_ledger).isUserWallet(_user):\n        return False\n\n    # cool off period\n    isSwitchboard: bool = addys._isSwitchboardAddr(_caller)\n    if not isSwitchboard:\n        lastClaimBlock: uint256 = self.lastClaim[_user]\n        coolOffPeriod: uint256 = staticcall MissionControl(_missionControl).getLootClaimCoolOffPeriod()\n        if lastClaimBlock != 0 and coolOffPeriod != 0:\n            if lastClaimBlock + coolOffPeriod > block.number:\n                return False\n\n    # lego check\n    if addys._isLegoBookAddr(_caller):\n        return True\n\n    # permission check\n    walletConfig: address = staticcall UserWallet(_user).walletConfig()\n    if _caller == staticcall UserWalletConfig(walletConfig).owner():\n        return True\n\n    # manager check\n    config: wcs.ManagerSettings = staticcall UserWalletConfig(walletConfig).managerSettings(_caller)\n    if config.canClaimLoot:\n        return True\n\n    return isSwitchboard",
            "sha256sum": "c56846b79e90409a4b9f861a2d9f0198fed9e265640cd97961c168a06e39d114"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/core/LootDistributor.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.3+commit.bff19ea2",
        "integrity": "78f45c605cda352ba73af6a1494e12339b2b6b99f6f5b5fb38d0eaa043f9ce7a"
      },
      "args": "00000000000000000000000044cf3c4f000dfd76a35d03298049d37be688d6f90000000000000000000000002a0a59d6b975828e781ecac125dba40d7ee5ddc00000000000000000000000006162df1b329e157479f8f1407e888260e0ec3d2b",
      "file": "contracts/core/LootDistributor.vy"
    },
    "SwitchboardAlpha": {
      "address": "0xD63278252E4306Dc2361F0353b8C681fccb15873",
      "abi": [
        {
          "name": "PendingUserWalletTemplatesChange",
          "inputs": [
            {
              "name": "walletTemplate",
              "type": "address",
              "indexed": false
            },
            {
              "name": "configTemplate",
              "type": "address",
              "indexed": false
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UserWalletTemplatesSet",
          "inputs": [
            {
              "name": "walletTemplate",
              "type": "address",
              "indexed": false
            },
            {
              "name": "configTemplate",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PendingWalletCreationLimitsChange",
          "inputs": [
            {
              "name": "numUserWalletsAllowed",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "enforceCreatorWhitelist",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "WalletCreationLimitsSet",
          "inputs": [
            {
              "name": "numUserWalletsAllowed",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "enforceCreatorWhitelist",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PendingKeyActionTimelockBoundsChange",
          "inputs": [
            {
              "name": "minKeyActionTimeLock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "maxKeyActionTimeLock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "KeyActionTimelockBoundsSet",
          "inputs": [
            {
              "name": "minKeyActionTimeLock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "maxKeyActionTimeLock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PendingTxFeesChange",
          "inputs": [
            {
              "name": "swapFee",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "stableSwapFee",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "rewardsFee",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "TxFeesSet",
          "inputs": [
            {
              "name": "swapFee",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "stableSwapFee",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "rewardsFee",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PendingAmbassadorRevShareChange",
          "inputs": [
            {
              "name": "swapRatio",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "rewardsRatio",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "yieldRatio",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AmbassadorRevShareSet",
          "inputs": [
            {
              "name": "swapRatio",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "rewardsRatio",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "yieldRatio",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PendingDefaultYieldParamsChange",
          "inputs": [
            {
              "name": "defaultYieldMaxIncrease",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "defaultYieldPerformanceFee",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "defaultYieldAmbassadorBonusRatio",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "defaultYieldBonusRatio",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "defaultYieldBonusAsset",
              "type": "address",
              "indexed": false
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "DefaultYieldParamsSet",
          "inputs": [
            {
              "name": "defaultYieldMaxIncrease",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "defaultYieldPerformanceFee",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "defaultYieldAmbassadorBonusRatio",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "defaultYieldBonusRatio",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "defaultYieldBonusAsset",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PendingLootParamsChange",
          "inputs": [
            {
              "name": "depositRewardsAsset",
              "type": "address",
              "indexed": false
            },
            {
              "name": "lootClaimCoolOffPeriod",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LootParamsSet",
          "inputs": [
            {
              "name": "depositRewardsAsset",
              "type": "address",
              "indexed": false
            },
            {
              "name": "lootClaimCoolOffPeriod",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PendingAssetConfigChange",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": false
            },
            {
              "name": "txFeesSwapFee",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "txFeesStableSwapFee",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "txFeesRewardsFee",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "ambassadorRevShareSwapRatio",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "ambassadorRevShareRewardsRatio",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "ambassadorRevShareYieldRatio",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "maxYieldIncrease",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "performanceFee",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "ambassadorBonusRatio",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "bonusRatio",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "bonusAsset",
              "type": "address",
              "indexed": false
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PendingIsStablecoinChange",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": false
            },
            {
              "name": "isStablecoin",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "IsStablecoinSet",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": false
            },
            {
              "name": "isStablecoin",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetConfigSet",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": false
            },
            {
              "name": "txFeesSwapFee",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "txFeesStableSwapFee",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "txFeesRewardsFee",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "ambassadorRevShareSwapRatio",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "ambassadorRevShareRewardsRatio",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "ambassadorRevShareYieldRatio",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "maxYieldIncrease",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "performanceFee",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "ambassadorBonusRatio",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "bonusRatio",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "bonusAsset",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PendingAssetTxFeesChange",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": false
            },
            {
              "name": "swapFee",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "stableSwapFee",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "rewardsFee",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetTxFeesSet",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": false
            },
            {
              "name": "swapFee",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "stableSwapFee",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "rewardsFee",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PendingAssetAmbassadorRevShareChange",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": false
            },
            {
              "name": "swapRatio",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "rewardsRatio",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "yieldRatio",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetAmbassadorRevShareSet",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": false
            },
            {
              "name": "swapRatio",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "rewardsRatio",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "yieldRatio",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PendingAssetYieldConfigChange",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": false
            },
            {
              "name": "maxYieldIncrease",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "performanceFee",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "ambassadorBonusRatio",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "bonusRatio",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "bonusAsset",
              "type": "address",
              "indexed": false
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetYieldConfigSet",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": false
            },
            {
              "name": "maxYieldIncrease",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "performanceFee",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "ambassadorBonusRatio",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "bonusRatio",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "bonusAsset",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PendingStarterAgentParamsChange",
          "inputs": [
            {
              "name": "startingAgent",
              "type": "address",
              "indexed": false
            },
            {
              "name": "startingAgentActivationLength",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "StarterAgentParamsSet",
          "inputs": [
            {
              "name": "startingAgent",
              "type": "address",
              "indexed": false
            },
            {
              "name": "startingAgentActivationLength",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PendingManagerConfigChange",
          "inputs": [
            {
              "name": "managerPeriod",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "managerActivationLength",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "mustHaveUsdValueOnSwaps",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "maxNumSwapsPerPeriod",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "maxSlippageOnSwaps",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "onlyApprovedYieldOpps",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PendingPayeeConfigChange",
          "inputs": [
            {
              "name": "payeePeriod",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "payeeActivationLength",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PendingCanPerformSecurityAction",
          "inputs": [
            {
              "name": "signer",
              "type": "address",
              "indexed": false
            },
            {
              "name": "canPerform",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "CreatorWhitelistSet",
          "inputs": [
            {
              "name": "creator",
              "type": "address",
              "indexed": false
            },
            {
              "name": "isWhitelisted",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "caller",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "ManagerConfigSet",
          "inputs": [
            {
              "name": "managerPeriod",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "managerActivationLength",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PayeeConfigSet",
          "inputs": [
            {
              "name": "payeePeriod",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "payeeActivationLength",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "CanPerformSecurityAction",
          "inputs": [
            {
              "name": "signer",
              "type": "address",
              "indexed": false
            },
            {
              "name": "canPerform",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LockedSignerSet",
          "inputs": [
            {
              "name": "signer",
              "type": "address",
              "indexed": false
            },
            {
              "name": "isLocked",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "caller",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PendingRipeRewardsConfigChange",
          "inputs": [
            {
              "name": "ripeStakeRatio",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "ripeLockDuration",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "RipeRewardsConfigSet",
          "inputs": [
            {
              "name": "ripeStakeRatio",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "ripeLockDuration",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PendingAgentWrapperSenderAdd",
          "inputs": [
            {
              "name": "agentWrapper",
              "type": "address",
              "indexed": true
            },
            {
              "name": "agentSender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AgentWrapperSenderAdded",
          "inputs": [
            {
              "name": "agentWrapper",
              "type": "address",
              "indexed": true
            },
            {
              "name": "agentSender",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AgentWrapperSenderRemoved",
          "inputs": [
            {
              "name": "agentWrapper",
              "type": "address",
              "indexed": true
            },
            {
              "name": "agentSender",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeTimeLockModified",
          "inputs": [
            {
              "name": "prevTimeLock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "newTimeLock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "ExpirationSet",
          "inputs": [
            {
              "name": "expiration",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "ActionTimeLockSet",
          "inputs": [
            {
              "name": "newTimeLock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "prevTimeLock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeStarted",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeConfirmed",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeCancelled",
          "inputs": [
            {
              "name": "cancelledGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovRelinquished",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UndyHqSetupFinished",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "timeLock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddys",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "undyToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "hatchery",
                  "type": "address"
                },
                {
                  "name": "lootDistributor",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                },
                {
                  "name": "walletBackpack",
                  "type": "address"
                },
                {
                  "name": "billing",
                  "type": "address"
                },
                {
                  "name": "vaultRegistry",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUndyHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUndyHqFromGov",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canGovern",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getGovernors",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPendingGovChange",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "startGovernanceChange",
          "inputs": [
            {
              "name": "_newGov",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "relinquishGov",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setGovTimeLock",
          "inputs": [
            {
              "name": "_numBlocks",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidGovTimeLock",
          "inputs": [
            {
              "name": "_newTimeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "minGovChangeTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "maxGovChangeTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "finishUndyHqSetup",
          "inputs": [
            {
              "name": "_newGov",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "finishUndyHqSetup",
          "inputs": [
            {
              "name": "_newGov",
              "type": "address"
            },
            {
              "name": "_timeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "governance",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingGov",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "newGov",
                  "type": "address"
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numGovChanges",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "govChangeTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canConfirmAction",
          "inputs": [
            {
              "name": "_actionId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isExpired",
          "inputs": [
            {
              "name": "_actionId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPendingAction",
          "inputs": [
            {
              "name": "_actionId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getActionConfirmationBlock",
          "inputs": [
            {
              "name": "_actionId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setActionTimeLock",
          "inputs": [
            {
              "name": "_newTimeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidActionTimeLock",
          "inputs": [
            {
              "name": "_newTimeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "minActionTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "maxActionTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setExpiration",
          "inputs": [
            {
              "name": "_expiration",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setActionTimeLockAfterSetup",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setActionTimeLockAfterSetup",
          "inputs": [
            {
              "name": "_newTimeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingActions",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                },
                {
                  "name": "expiration",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "actionId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "actionTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "expiration",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setUserWalletTemplates",
          "inputs": [
            {
              "name": "_walletTemplate",
              "type": "address"
            },
            {
              "name": "_configTemplate",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setUserWalletTemplates",
          "inputs": [
            {
              "name": "_walletTemplate",
              "type": "address"
            },
            {
              "name": "_configTemplate",
              "type": "address"
            },
            {
              "name": "_missionControl",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setWalletCreationLimits",
          "inputs": [
            {
              "name": "_numUserWalletsAllowed",
              "type": "uint256"
            },
            {
              "name": "_enforceCreatorWhitelist",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setWalletCreationLimits",
          "inputs": [
            {
              "name": "_numUserWalletsAllowed",
              "type": "uint256"
            },
            {
              "name": "_enforceCreatorWhitelist",
              "type": "bool"
            },
            {
              "name": "_missionControl",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setKeyActionTimelockBounds",
          "inputs": [
            {
              "name": "_minKeyActionTimeLock",
              "type": "uint256"
            },
            {
              "name": "_maxKeyActionTimeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setKeyActionTimelockBounds",
          "inputs": [
            {
              "name": "_minKeyActionTimeLock",
              "type": "uint256"
            },
            {
              "name": "_maxKeyActionTimeLock",
              "type": "uint256"
            },
            {
              "name": "_missionControl",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setTxFees",
          "inputs": [
            {
              "name": "_swapFee",
              "type": "uint256"
            },
            {
              "name": "_stableSwapFee",
              "type": "uint256"
            },
            {
              "name": "_rewardsFee",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setTxFees",
          "inputs": [
            {
              "name": "_swapFee",
              "type": "uint256"
            },
            {
              "name": "_stableSwapFee",
              "type": "uint256"
            },
            {
              "name": "_rewardsFee",
              "type": "uint256"
            },
            {
              "name": "_missionControl",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setAmbassadorRevShare",
          "inputs": [
            {
              "name": "_swapRatio",
              "type": "uint256"
            },
            {
              "name": "_rewardsRatio",
              "type": "uint256"
            },
            {
              "name": "_yieldRatio",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setAmbassadorRevShare",
          "inputs": [
            {
              "name": "_swapRatio",
              "type": "uint256"
            },
            {
              "name": "_rewardsRatio",
              "type": "uint256"
            },
            {
              "name": "_yieldRatio",
              "type": "uint256"
            },
            {
              "name": "_missionControl",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setDefaultYieldParams",
          "inputs": [
            {
              "name": "_defaultYieldMaxIncrease",
              "type": "uint256"
            },
            {
              "name": "_defaultYieldPerformanceFee",
              "type": "uint256"
            },
            {
              "name": "_defaultYieldAmbassadorBonusRatio",
              "type": "uint256"
            },
            {
              "name": "_defaultYieldBonusRatio",
              "type": "uint256"
            },
            {
              "name": "_defaultYieldBonusAsset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setDefaultYieldParams",
          "inputs": [
            {
              "name": "_defaultYieldMaxIncrease",
              "type": "uint256"
            },
            {
              "name": "_defaultYieldPerformanceFee",
              "type": "uint256"
            },
            {
              "name": "_defaultYieldAmbassadorBonusRatio",
              "type": "uint256"
            },
            {
              "name": "_defaultYieldBonusRatio",
              "type": "uint256"
            },
            {
              "name": "_defaultYieldBonusAsset",
              "type": "address"
            },
            {
              "name": "_missionControl",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setLootParams",
          "inputs": [
            {
              "name": "_depositRewardsAsset",
              "type": "address"
            },
            {
              "name": "_lootClaimCoolOffPeriod",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setLootParams",
          "inputs": [
            {
              "name": "_depositRewardsAsset",
              "type": "address"
            },
            {
              "name": "_lootClaimCoolOffPeriod",
              "type": "uint256"
            },
            {
              "name": "_missionControl",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setAssetConfig",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_txFeesSwapFee",
              "type": "uint256"
            },
            {
              "name": "_txFeesStableSwapFee",
              "type": "uint256"
            },
            {
              "name": "_txFeesRewardsFee",
              "type": "uint256"
            },
            {
              "name": "_ambassadorRevShareSwapRatio",
              "type": "uint256"
            },
            {
              "name": "_ambassadorRevShareRewardsRatio",
              "type": "uint256"
            },
            {
              "name": "_ambassadorRevShareYieldRatio",
              "type": "uint256"
            },
            {
              "name": "_maxYieldIncrease",
              "type": "uint256"
            },
            {
              "name": "_performanceFee",
              "type": "uint256"
            },
            {
              "name": "_ambassadorBonusRatio",
              "type": "uint256"
            },
            {
              "name": "_bonusRatio",
              "type": "uint256"
            },
            {
              "name": "_bonusAsset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setAssetConfig",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_txFeesSwapFee",
              "type": "uint256"
            },
            {
              "name": "_txFeesStableSwapFee",
              "type": "uint256"
            },
            {
              "name": "_txFeesRewardsFee",
              "type": "uint256"
            },
            {
              "name": "_ambassadorRevShareSwapRatio",
              "type": "uint256"
            },
            {
              "name": "_ambassadorRevShareRewardsRatio",
              "type": "uint256"
            },
            {
              "name": "_ambassadorRevShareYieldRatio",
              "type": "uint256"
            },
            {
              "name": "_maxYieldIncrease",
              "type": "uint256"
            },
            {
              "name": "_performanceFee",
              "type": "uint256"
            },
            {
              "name": "_ambassadorBonusRatio",
              "type": "uint256"
            },
            {
              "name": "_bonusRatio",
              "type": "uint256"
            },
            {
              "name": "_bonusAsset",
              "type": "address"
            },
            {
              "name": "_missionControl",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setAssetTxFees",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_swapFee",
              "type": "uint256"
            },
            {
              "name": "_stableSwapFee",
              "type": "uint256"
            },
            {
              "name": "_rewardsFee",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setAssetTxFees",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_swapFee",
              "type": "uint256"
            },
            {
              "name": "_stableSwapFee",
              "type": "uint256"
            },
            {
              "name": "_rewardsFee",
              "type": "uint256"
            },
            {
              "name": "_missionControl",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setAssetAmbassadorRevShare",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_swapRatio",
              "type": "uint256"
            },
            {
              "name": "_rewardsRatio",
              "type": "uint256"
            },
            {
              "name": "_yieldRatio",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setAssetAmbassadorRevShare",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_swapRatio",
              "type": "uint256"
            },
            {
              "name": "_rewardsRatio",
              "type": "uint256"
            },
            {
              "name": "_yieldRatio",
              "type": "uint256"
            },
            {
              "name": "_missionControl",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setAssetYieldConfig",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_maxYieldIncrease",
              "type": "uint256"
            },
            {
              "name": "_performanceFee",
              "type": "uint256"
            },
            {
              "name": "_ambassadorBonusRatio",
              "type": "uint256"
            },
            {
              "name": "_bonusRatio",
              "type": "uint256"
            },
            {
              "name": "_bonusAsset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setAssetYieldConfig",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_maxYieldIncrease",
              "type": "uint256"
            },
            {
              "name": "_performanceFee",
              "type": "uint256"
            },
            {
              "name": "_ambassadorBonusRatio",
              "type": "uint256"
            },
            {
              "name": "_bonusRatio",
              "type": "uint256"
            },
            {
              "name": "_bonusAsset",
              "type": "address"
            },
            {
              "name": "_missionControl",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setIsStablecoin",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_isStablecoin",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setIsStablecoin",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_isStablecoin",
              "type": "bool"
            },
            {
              "name": "_missionControl",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setStarterAgentParams",
          "inputs": [
            {
              "name": "_startingAgent",
              "type": "address"
            },
            {
              "name": "_startingAgentActivationLength",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setStarterAgentParams",
          "inputs": [
            {
              "name": "_startingAgent",
              "type": "address"
            },
            {
              "name": "_startingAgentActivationLength",
              "type": "uint256"
            },
            {
              "name": "_missionControl",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setAgentWrapperSender",
          "inputs": [
            {
              "name": "_agentWrapper",
              "type": "address"
            },
            {
              "name": "_agentSender",
              "type": "address"
            },
            {
              "name": "_shouldAdd",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setManagerConfig",
          "inputs": [
            {
              "name": "_managerPeriod",
              "type": "uint256"
            },
            {
              "name": "_managerActivationLength",
              "type": "uint256"
            },
            {
              "name": "_mustHaveUsdValueOnSwaps",
              "type": "bool"
            },
            {
              "name": "_maxNumSwapsPerPeriod",
              "type": "uint256"
            },
            {
              "name": "_maxSlippageOnSwaps",
              "type": "uint256"
            },
            {
              "name": "_onlyApprovedYieldOpps",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setManagerConfig",
          "inputs": [
            {
              "name": "_managerPeriod",
              "type": "uint256"
            },
            {
              "name": "_managerActivationLength",
              "type": "uint256"
            },
            {
              "name": "_mustHaveUsdValueOnSwaps",
              "type": "bool"
            },
            {
              "name": "_maxNumSwapsPerPeriod",
              "type": "uint256"
            },
            {
              "name": "_maxSlippageOnSwaps",
              "type": "uint256"
            },
            {
              "name": "_onlyApprovedYieldOpps",
              "type": "bool"
            },
            {
              "name": "_missionControl",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setPayeeConfig",
          "inputs": [
            {
              "name": "_payeePeriod",
              "type": "uint256"
            },
            {
              "name": "_payeeActivationLength",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setPayeeConfig",
          "inputs": [
            {
              "name": "_payeePeriod",
              "type": "uint256"
            },
            {
              "name": "_payeeActivationLength",
              "type": "uint256"
            },
            {
              "name": "_missionControl",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setCanPerformSecurityAction",
          "inputs": [
            {
              "name": "_signer",
              "type": "address"
            },
            {
              "name": "_canPerform",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setCanPerformSecurityAction",
          "inputs": [
            {
              "name": "_signer",
              "type": "address"
            },
            {
              "name": "_canPerform",
              "type": "bool"
            },
            {
              "name": "_missionControl",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setCreatorWhitelist",
          "inputs": [
            {
              "name": "_creator",
              "type": "address"
            },
            {
              "name": "_isWhitelisted",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setCreatorWhitelist",
          "inputs": [
            {
              "name": "_creator",
              "type": "address"
            },
            {
              "name": "_isWhitelisted",
              "type": "bool"
            },
            {
              "name": "_missionControl",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setLockedSigner",
          "inputs": [
            {
              "name": "_signer",
              "type": "address"
            },
            {
              "name": "_isLocked",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setLockedSigner",
          "inputs": [
            {
              "name": "_signer",
              "type": "address"
            },
            {
              "name": "_isLocked",
              "type": "bool"
            },
            {
              "name": "_missionControl",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setRipeRewardsConfig",
          "inputs": [
            {
              "name": "_ripeStakeRatio",
              "type": "uint256"
            },
            {
              "name": "_ripeLockDuration",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setRipeRewardsConfig",
          "inputs": [
            {
              "name": "_ripeStakeRatio",
              "type": "uint256"
            },
            {
              "name": "_ripeLockDuration",
              "type": "uint256"
            },
            {
              "name": "_missionControl",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "executePendingAction",
          "inputs": [
            {
              "name": "_aid",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelPendingAction",
          "inputs": [
            {
              "name": "_aid",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "actionType",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingUserWalletConfig",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "walletTemplate",
                  "type": "address"
                },
                {
                  "name": "configTemplate",
                  "type": "address"
                },
                {
                  "name": "numUserWalletsAllowed",
                  "type": "uint256"
                },
                {
                  "name": "enforceCreatorWhitelist",
                  "type": "bool"
                },
                {
                  "name": "minKeyActionTimeLock",
                  "type": "uint256"
                },
                {
                  "name": "maxKeyActionTimeLock",
                  "type": "uint256"
                },
                {
                  "name": "depositRewardsAsset",
                  "type": "address"
                },
                {
                  "name": "lootClaimCoolOffPeriod",
                  "type": "uint256"
                },
                {
                  "name": "txFees",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "swapFee",
                      "type": "uint256"
                    },
                    {
                      "name": "stableSwapFee",
                      "type": "uint256"
                    },
                    {
                      "name": "rewardsFee",
                      "type": "uint256"
                    }
                  ]
                },
                {
                  "name": "ambassadorRevShare",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "swapRatio",
                      "type": "uint256"
                    },
                    {
                      "name": "rewardsRatio",
                      "type": "uint256"
                    },
                    {
                      "name": "yieldRatio",
                      "type": "uint256"
                    }
                  ]
                },
                {
                  "name": "yieldConfig",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "maxYieldIncrease",
                      "type": "uint256"
                    },
                    {
                      "name": "performanceFee",
                      "type": "uint256"
                    },
                    {
                      "name": "ambassadorBonusRatio",
                      "type": "uint256"
                    },
                    {
                      "name": "bonusRatio",
                      "type": "uint256"
                    },
                    {
                      "name": "bonusAsset",
                      "type": "address"
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingAssetConfig",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "config",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "hasConfig",
                      "type": "bool"
                    },
                    {
                      "name": "txFees",
                      "type": "tuple",
                      "components": [
                        {
                          "name": "swapFee",
                          "type": "uint256"
                        },
                        {
                          "name": "stableSwapFee",
                          "type": "uint256"
                        },
                        {
                          "name": "rewardsFee",
                          "type": "uint256"
                        }
                      ]
                    },
                    {
                      "name": "ambassadorRevShare",
                      "type": "tuple",
                      "components": [
                        {
                          "name": "swapRatio",
                          "type": "uint256"
                        },
                        {
                          "name": "rewardsRatio",
                          "type": "uint256"
                        },
                        {
                          "name": "yieldRatio",
                          "type": "uint256"
                        }
                      ]
                    },
                    {
                      "name": "yieldConfig",
                      "type": "tuple",
                      "components": [
                        {
                          "name": "maxYieldIncrease",
                          "type": "uint256"
                        },
                        {
                          "name": "performanceFee",
                          "type": "uint256"
                        },
                        {
                          "name": "ambassadorBonusRatio",
                          "type": "uint256"
                        },
                        {
                          "name": "bonusRatio",
                          "type": "uint256"
                        },
                        {
                          "name": "bonusAsset",
                          "type": "address"
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingAssetTxFees",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "txFees",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "swapFee",
                      "type": "uint256"
                    },
                    {
                      "name": "stableSwapFee",
                      "type": "uint256"
                    },
                    {
                      "name": "rewardsFee",
                      "type": "uint256"
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingAssetAmbassadorRevShare",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "ambassadorRevShare",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "swapRatio",
                      "type": "uint256"
                    },
                    {
                      "name": "rewardsRatio",
                      "type": "uint256"
                    },
                    {
                      "name": "yieldRatio",
                      "type": "uint256"
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingAssetYieldConfig",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "yieldConfig",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "maxYieldIncrease",
                      "type": "uint256"
                    },
                    {
                      "name": "performanceFee",
                      "type": "uint256"
                    },
                    {
                      "name": "ambassadorBonusRatio",
                      "type": "uint256"
                    },
                    {
                      "name": "bonusRatio",
                      "type": "uint256"
                    },
                    {
                      "name": "bonusAsset",
                      "type": "address"
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingAgentConfig",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "startingAgent",
                  "type": "address"
                },
                {
                  "name": "startingAgentActivationLength",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingManagerConfig",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "managerPeriod",
                  "type": "uint256"
                },
                {
                  "name": "managerActivationLength",
                  "type": "uint256"
                },
                {
                  "name": "mustHaveUsdValueOnSwaps",
                  "type": "bool"
                },
                {
                  "name": "maxNumSwapsPerPeriod",
                  "type": "uint256"
                },
                {
                  "name": "maxSlippageOnSwaps",
                  "type": "uint256"
                },
                {
                  "name": "onlyApprovedYieldOpps",
                  "type": "bool"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingPayeeConfig",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "payeePeriod",
                  "type": "uint256"
                },
                {
                  "name": "payeeActivationLength",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingAddrToBool",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "addr",
                  "type": "address"
                },
                {
                  "name": "isAllowed",
                  "type": "bool"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingAgentWrapperSender",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "agentWrapper",
                  "type": "address"
                },
                {
                  "name": "agentSender",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingRipeRewardsConfig",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "stakeRatio",
                  "type": "uint256"
                },
                {
                  "name": "lockDuration",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingMissionControl",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_undyHq",
              "type": "address"
            },
            {
              "name": "_tempGov",
              "type": "address"
            },
            {
              "name": "_minConfigTimeLock",
              "type": "uint256"
            },
            {
              "name": "_maxConfigTimeLock",
              "type": "uint256"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/modules/Addys.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\ninterface UndyHq:\n    def isValidAddr(_addr: address) -> bool: view\n    def getAddr(_regId: uint256) -> address: view\n    def undyToken() -> address: view\n\ninterface Switchboard:\n    def isSwitchboardAddr(_addr: address) -> bool: view\n\ninterface LegoBook:\n    def isLegoAddr(_addr: address) -> bool: view\n\nstruct Addys:\n    hq: address\n    undyToken: address\n    ledger: address\n    missionControl: address\n    legoBook: address\n    switchboard: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    walletBackpack: address\n    billing: address\n    vaultRegistry: address\n\n# hq\nUNDY_HQ_FOR_ADDYS: immutable(address)\n\n# core addys\nLEDGER_ID: constant(uint256) = 1\nMISSION_CONTROL_ID: constant(uint256) = 2\nLEGO_BOOK_ID: constant(uint256) = 3\nSWITCHBOARD_ID: constant(uint256) = 4\nHATCHERY_ID: constant(uint256) = 5\nLOOT_DISTRIBUTOR_ID: constant(uint256) = 6\nAPPRAISER_ID: constant(uint256) = 7\nWALLET_BACKPACK_ID: constant(uint256) = 8\nBILLING_ID: constant(uint256) = 9\nVAULT_REGISTRY_ID: constant(uint256) = 10\n\n\n@deploy\ndef __init__(_undyHq: address):\n    assert _undyHq != empty(address) # dev: invalid undy hq\n    UNDY_HQ_FOR_ADDYS = _undyHq\n\n\n########\n# Core #\n########\n\n\n@view\n@external\ndef getAddys() -> Addys:\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _getAddys(_addys: Addys = empty(Addys)) -> Addys:\n    if _addys.hq != empty(address):\n        return _addys\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _generateAddys() -> Addys:\n    hq: address = UNDY_HQ_FOR_ADDYS\n    return Addys(\n        hq = hq,\n        undyToken = staticcall UndyHq(hq).undyToken(),\n        ledger = staticcall UndyHq(hq).getAddr(LEDGER_ID),\n        missionControl = staticcall UndyHq(hq).getAddr(MISSION_CONTROL_ID),\n        legoBook = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID),\n        switchboard = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID),\n        hatchery = staticcall UndyHq(hq).getAddr(HATCHERY_ID),\n        lootDistributor = staticcall UndyHq(hq).getAddr(LOOT_DISTRIBUTOR_ID),\n        appraiser = staticcall UndyHq(hq).getAddr(APPRAISER_ID),\n        walletBackpack = staticcall UndyHq(hq).getAddr(WALLET_BACKPACK_ID),\n        billing = staticcall UndyHq(hq).getAddr(BILLING_ID),\n        vaultRegistry = staticcall UndyHq(hq).getAddr(VAULT_REGISTRY_ID),\n    )\n\n\n##########\n# Tokens #\n##########\n\n\n@view\n@internal\ndef _getUndyToken() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).undyToken()\n\n\n###########\n# Helpers #\n###########\n\n\n# undy hq\n\n\n@view\n@external\ndef getUndyHq() -> address:\n    return self._getUndyHq()\n\n\n@view\n@internal\ndef _getUndyHq() -> address:\n    return UNDY_HQ_FOR_ADDYS\n\n\n# utils\n\n\n@view\n@internal\ndef _isValidUndyAddr(_addr: address, _hq: address = empty(address)) -> bool:\n    hq: address = _hq\n    if _hq == empty(address):\n        hq = UNDY_HQ_FOR_ADDYS\n    \n    # core departments\n    if staticcall UndyHq(hq).isValidAddr(_addr):\n        return True\n\n    # lego book\n    legoBook: address = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID)\n    if legoBook != empty(address) and staticcall LegoBook(legoBook).isLegoAddr(_addr):\n        return True\n\n    # switchboard config\n    switchboard: address = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID)\n    if switchboard != empty(address) and staticcall Switchboard(switchboard).isSwitchboardAddr(_addr):\n        return True\n\n    return False\n\n\n@view\n@internal\ndef _isSwitchboardAddr(_addr: address) -> bool:\n    switchboard: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n    if switchboard == empty(address):\n        return False\n    return staticcall Switchboard(switchboard).isSwitchboardAddr(_addr)\n\n\n@view\n@internal\ndef _isLegoBookAddr(_addr: address) -> bool:\n    legoBook: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n    if legoBook == empty(address):\n        return False\n    return staticcall LegoBook(legoBook).isLegoAddr(_addr)\n\n\n###############\n# Departments #\n###############\n\n\n# ledger\n\n\n@view\n@internal\ndef _getLedgerId() -> uint256:\n    return LEDGER_ID\n\n\n@view\n@internal\ndef _getLedgerAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEDGER_ID)\n\n\n# mission control\n\n\n@view\n@internal\ndef _getMissionControlId() -> uint256:\n    return MISSION_CONTROL_ID\n\n\n@view\n@internal\ndef _getMissionControlAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(MISSION_CONTROL_ID)\n\n\n# lego book\n\n\n@view\n@internal\ndef _getLegoBookId() -> uint256:\n    return LEGO_BOOK_ID\n\n\n@view\n@internal\ndef _getLegoBookAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n\n\n# switchboard\n\n\n@view\n@internal\ndef _getSwitchboardId() -> uint256:\n    return SWITCHBOARD_ID\n\n\n@view\n@internal\ndef _getSwitchboardAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n\n\n# hatchery\n\n\n@view\n@internal\ndef _getHatcheryId() -> uint256:\n    return HATCHERY_ID\n\n\n@view\n@internal\ndef _getHatcheryAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(HATCHERY_ID)\n\n\n# loot distributor\n\n\n@view\n@internal\ndef _getLootDistributorId() -> uint256:\n    return LOOT_DISTRIBUTOR_ID\n\n\n@view\n@internal\ndef _getLootDistributorAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LOOT_DISTRIBUTOR_ID)\n\n\n# appraiser\n\n\n@view\n@internal\ndef _getAppraiserId() -> uint256:\n    return APPRAISER_ID\n\n\n@view\n@internal\ndef _getAppraiserAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(APPRAISER_ID)\n\n\n# wallet backpack\n\n\n@view\n@internal\ndef _getWalletBackpackId() -> uint256:\n    return WALLET_BACKPACK_ID\n\n\n@view\n@internal\ndef _getWalletBackpackAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(WALLET_BACKPACK_ID)\n\n\n# billing\n\n\n@view\n@internal\ndef _getBillingId() -> uint256:\n    return BILLING_ID\n\n\n@view\n@internal\ndef _getBillingAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(BILLING_ID)\n\n\n# vault registry\n\n\n@view\n@internal\ndef _getVaultRegistryId() -> uint256:\n    return VAULT_REGISTRY_ID\n\n\n@view\n@internal\ndef _getVaultRegistryAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(VAULT_REGISTRY_ID)",
            "sha256sum": "4df6b72db9bb417d1af81660175be1450cfb7b3575f3d17a5b8a130bff87b781"
          },
          "contracts/modules/LocalGov.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\ninterface UndyHq:\n    def minGovChangeTimeLock() -> uint256: view\n    def maxGovChangeTimeLock() -> uint256: view\n    def governance() -> address: view\n\nstruct PendingGovernance:\n    newGov: address\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeStarted:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    confirmBlock: uint256\n\nevent GovChangeConfirmed:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeCancelled:\n    cancelledGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovRelinquished:\n    prevGov: indexed(address)\n\nevent GovChangeTimeLockModified:\n    prevTimeLock: uint256\n    newTimeLock: uint256\n\nevent UndyHqSetupFinished:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    timeLock: uint256\n\n# governance\ngovernance: public(address)\npendingGov: public(PendingGovernance)\nnumGovChanges: public(uint256)\n\n# time lock\ngovChangeTimeLock: public(uint256)\n\n# config\nUNDY_HQ_FOR_GOV: immutable(address)\nMIN_GOV_TIME_LOCK: immutable(uint256)\nMAX_GOV_TIME_LOCK: immutable(uint256)\n\n\n@deploy\ndef __init__(\n    _undyHq: address,\n    _initialGov: address,\n    _minTimeLock: uint256,\n    _maxTimeLock: uint256,\n    _initialTimeLock: uint256,\n):\n    UNDY_HQ_FOR_GOV = _undyHq\n    self.governance = _initialGov\n\n    # undy hq\n    if _undyHq == empty(address):\n        assert _initialGov != empty(address) # dev: undy hq must have gov\n\n    # local gov (department, other smart contracts)\n    else:\n        hqGov: address = staticcall UndyHq(_undyHq).governance()\n        assert hqGov != empty(address) # dev: undy hq must have gov\n        assert _initialGov != hqGov # dev: undy hq cannot set same gov\n\n    # time locks\n    minTimeLock: uint256 = _minTimeLock\n    maxTimeLock: uint256 = _maxTimeLock\n    if minTimeLock == 0 or maxTimeLock == 0:\n        assert _undyHq != empty(address) # dev: need undy hq if no time locks\n        minTimeLock = staticcall UndyHq(_undyHq).minGovChangeTimeLock()\n        maxTimeLock = staticcall UndyHq(_undyHq).maxGovChangeTimeLock()\n\n    # set min and max time locks\n    assert minTimeLock < maxTimeLock # dev: invalid time lock\n    assert minTimeLock != 0 and maxTimeLock != max_value(uint256) # dev: invalid time lock\n    MIN_GOV_TIME_LOCK = minTimeLock\n    MAX_GOV_TIME_LOCK = maxTimeLock\n\n    # this contract is top level governance from Undy HQ -- not setting initial time lock during setup\n    if _undyHq == empty(address):\n        return\n\n    # set initial time lock (for local gov)\n    initialTimeLock: uint256 = max(minTimeLock, _initialTimeLock)\n    assert self._setGovTimeLock(initialTimeLock) # dev: invalid time lock\n\n\n@view\n@external\ndef getUndyHqFromGov() -> address:\n    return self._getUndyHqFromGov()\n\n\n@view\n@internal\ndef _getUndyHqFromGov() -> address:\n    return UNDY_HQ_FOR_GOV\n\n\n##############\n# Gov Access #\n##############\n\n\n@view\n@external\ndef canGovern(_addr: address) -> bool:\n    return self._canGovern(_addr)\n\n\n@view\n@internal\ndef _canGovern(_addr: address) -> bool:\n    if _addr == empty(address):\n        return False\n    return _addr in self._getGovernors()\n\n\n@view\n@external\ndef getGovernors() -> DynArray[address, 2]:\n    return self._getGovernors()\n\n\n@view\n@internal\ndef _getGovernors() -> DynArray[address, 2]:\n    governors: DynArray[address, 2] = []\n\n    # local governance\n    localGov: address = self.governance\n    if localGov != empty(address):\n        governors.append(localGov)\n\n    # undy hq governance\n    undyHq: address = UNDY_HQ_FOR_GOV\n    if undyHq == empty(address):\n        return governors\n\n    hqGov: address = staticcall UndyHq(undyHq).governance()\n    if hqGov != empty(address):\n        governors.append(hqGov)\n\n    return governors\n\n\n######################\n# Governance Changes #\n######################\n\n\n@view\n@external\ndef hasPendingGovChange() -> bool:\n    return self.pendingGov.confirmBlock != 0\n\n\n@view\n@internal\ndef _isUndyHq() -> bool:\n    return UNDY_HQ_FOR_GOV == empty(address)\n\n\n# start gov change\n\n\n@external\ndef startGovernanceChange(_newGov: address):\n    governors: DynArray[address, 2] = self._getGovernors()\n    assert msg.sender in governors # dev: no perms\n\n    # validation\n    if _newGov != empty(address):\n        assert _newGov not in governors # dev: invalid _newGov\n        assert _newGov.is_contract # dev: _newGov must be a contract\n    else:\n        assert not self._isUndyHq() # dev: undy hq cannot set 0x0\n\n    confirmBlock: uint256 = block.number + self.govChangeTimeLock\n    self.pendingGov = PendingGovernance(\n        newGov= _newGov,\n        initiatedBlock= block.number,\n        confirmBlock= confirmBlock,\n    )\n    log GovChangeStarted(prevGov=self.governance, newGov=_newGov, confirmBlock=confirmBlock)\n\n\n# confirm gov change\n\n\n@external\ndef confirmGovernanceChange():\n    data: PendingGovernance = self.pendingGov\n    assert data.confirmBlock != 0 and block.number >= data.confirmBlock # dev: time lock not reached\n\n    # check permissions\n    if data.newGov != empty(address):\n        assert msg.sender == data.newGov # dev: only new gov can confirm\n    else:\n        assert self._canGovern(msg.sender) # dev: no perms\n        assert not self._isUndyHq() # dev: undy hq cannot set 0x0\n\n    # set new governance\n    prevGov: address = self.governance\n    self.governance = data.newGov\n    self.numGovChanges += 1\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeConfirmed(prevGov=prevGov, newGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n# cancel gov change\n\n\n@external\ndef cancelGovernanceChange():\n    assert self._canGovern(msg.sender) # dev: no perms\n    data: PendingGovernance = self.pendingGov\n    assert data.confirmBlock != 0 # dev: no pending change\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeCancelled(cancelledGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n# relinquish gov (only for local gov)\n\n\n@external\ndef relinquishGov():\n    assert msg.sender == self.governance # dev: no perms\n    assert not self._isUndyHq() # dev: undy hq cannot relinquish gov\n\n    self.governance = empty(address)\n    self.numGovChanges += 1\n    log GovRelinquished(prevGov=msg.sender)\n\n\n####################\n# Time Lock Config #\n####################\n\n\n# set time lock\n\n\n@external\ndef setGovTimeLock(_numBlocks: uint256) -> bool:\n    assert self._canGovern(msg.sender) # dev: no perms\n    return self._setGovTimeLock(_numBlocks)\n\n\n@internal\ndef _setGovTimeLock(_numBlocks: uint256) -> bool:\n    prevTimeLock: uint256 = self.govChangeTimeLock\n    assert self._isValidGovTimeLock(_numBlocks, prevTimeLock) # dev: invalid time lock\n    self.govChangeTimeLock = _numBlocks\n    log GovChangeTimeLockModified(prevTimeLock=prevTimeLock, newTimeLock=_numBlocks)\n    return True\n\n\n# validation\n\n\n@view\n@external\ndef isValidGovTimeLock(_newTimeLock: uint256) -> bool:\n    return self._isValidGovTimeLock(_newTimeLock, self.govChangeTimeLock)\n\n\n@view\n@internal\ndef _isValidGovTimeLock(_newTimeLock: uint256, _prevTimeLock: uint256) -> bool:\n    if _newTimeLock == _prevTimeLock:\n        return False # no change\n    if self.pendingGov.confirmBlock != 0:\n        return False # cannot change while pending gov change\n    return _newTimeLock >= MIN_GOV_TIME_LOCK and _newTimeLock <= MAX_GOV_TIME_LOCK\n\n\n# utils\n\n\n@view\n@external\ndef minGovChangeTimeLock() -> uint256:\n    return MIN_GOV_TIME_LOCK\n\n\n@view\n@external\ndef maxGovChangeTimeLock() -> uint256:\n    return MAX_GOV_TIME_LOCK\n\n\n#################\n# Undy Hq Setup #\n#################\n\n\n@external\ndef finishUndyHqSetup(_newGov: address, _timeLock: uint256 = 0) -> bool:\n    assert self._isUndyHq() # dev: only undy hq\n    assert msg.sender == self.governance # dev: no perms\n    assert self.numGovChanges == 0 # dev: already changed gov\n\n    # validation\n    assert _newGov != empty(address) and _newGov.is_contract # dev: invalid _newGov\n    prevGov: address = self.governance\n\n    # set new gov\n    self.governance = _newGov\n    self.numGovChanges += 1\n\n    # set time lock\n    timeLock: uint256 = _timeLock\n    if timeLock == 0:\n        timeLock = MIN_GOV_TIME_LOCK\n    assert self._setGovTimeLock(timeLock) # dev: invalid time lock\n\n    log UndyHqSetupFinished(prevGov=prevGov, newGov=_newGov, timeLock=timeLock)\n    return True",
            "sha256sum": "c41aa3e0d0d96b512171813377ea277e2c7da690c3cd9b4662733b3f11f705b0"
          },
          "contracts/modules/TimeLock.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nuses: gov\nimport contracts.modules.LocalGov as gov\n\nstruct PendingAction:\n    initiatedBlock: uint256\n    confirmBlock: uint256\n    expiration: uint256\n\nevent ActionTimeLockSet:\n    newTimeLock: uint256\n    prevTimeLock: uint256\n\nevent ExpirationSet:\n    expiration: uint256\n\n# core data\npendingActions: public(HashMap[uint256, PendingAction])\nactionId: public(uint256)\n\n# config\nactionTimeLock: public(uint256)\nexpiration: public(uint256)\n\nMIN_ACTION_TIMELOCK: immutable(uint256)\nMAX_ACTION_TIMELOCK: immutable(uint256)\n\n\n@deploy\ndef __init__(\n    _minActionTimeLock: uint256,\n    _maxActionTimeLock: uint256,\n    _initialTimeLock: uint256,\n    _expiration: uint256,\n):\n    # start at 1 index\n    self.actionId = 1\n\n    # set time lock boundaries\n    assert _minActionTimeLock < _maxActionTimeLock # dev: invalid time lock boundaries\n    assert _minActionTimeLock != 0 and _maxActionTimeLock != max_value(uint256) # dev: invalid time lock boundaries\n    MIN_ACTION_TIMELOCK = _minActionTimeLock\n    MAX_ACTION_TIMELOCK = _maxActionTimeLock\n\n    # set expiration time\n    self._setExpiration(_expiration, _initialTimeLock)\n\n    # set initial time lock\n    if _initialTimeLock != 0:\n        assert self._setActionTimeLock(_initialTimeLock, 0) # dev: failed to set initial time lock\n\n\n########\n# Core #\n########\n\n\n# initiate\n\n\n@internal\ndef _initiateAction() -> uint256:\n    actionId: uint256 = self.actionId\n    confirmBlock: uint256 = block.number + self.actionTimeLock\n    self.pendingActions[actionId] = PendingAction(\n        initiatedBlock= block.number,\n        confirmBlock= confirmBlock,\n        expiration= confirmBlock + self.expiration,\n    )\n    self.actionId += 1\n    return actionId\n\n\n# confirm\n\n\n@internal\ndef _confirmAction(_actionId: uint256) -> bool:\n    if not self._canConfirmAction(_actionId):\n        return False\n    self.pendingActions[_actionId] = empty(PendingAction)\n    return True\n\n\n# cancel\n\n\n@internal\ndef _cancelAction(_actionId: uint256) -> bool:\n    data: PendingAction = self.pendingActions[_actionId]\n    if data.confirmBlock == 0:\n        return False\n    self.pendingActions[_actionId] = empty(PendingAction)\n    return True\n\n\n#########\n# Utils #\n#########\n\n\n# can confirm\n\n\n@view\n@external\ndef canConfirmAction(_actionId: uint256) -> bool:\n    return self._canConfirmAction(_actionId)\n\n\n@view\n@internal\ndef _canConfirmAction(_actionId: uint256) -> bool:\n    data: PendingAction = self.pendingActions[_actionId]\n    if data.confirmBlock == 0 or block.number < data.confirmBlock:\n        return False\n    if block.number >= data.expiration:\n        return False\n    return True\n\n\n# is expired\n\n\n@view\n@external\ndef isExpired(_actionId: uint256) -> bool:\n    return self._isExpired(_actionId)\n\n\n@view\n@internal\ndef _isExpired(_actionId: uint256) -> bool:\n    data: PendingAction = self.pendingActions[_actionId]\n    if data.confirmBlock == 0:\n        return False\n    return block.number >= data.expiration\n\n\n# pending action\n\n\n@view\n@external\ndef hasPendingAction(_actionId: uint256) -> bool:\n    return self._hasPendingAction(_actionId)\n\n\n@view\n@internal\ndef _hasPendingAction(_actionId: uint256) -> bool:\n    return self.pendingActions[_actionId].confirmBlock != 0\n\n\n# confirmation block\n\n\n@view\n@external\ndef getActionConfirmationBlock(_actionId: uint256) -> uint256:\n    return self._getActionConfirmationBlock(_actionId)\n\n\n@view\n@internal\ndef _getActionConfirmationBlock(_actionId: uint256) -> uint256:\n    return self.pendingActions[_actionId].confirmBlock\n\n\n######################\n# Config - Time Lock #\n######################\n\n\n@external\ndef setActionTimeLock(_newTimeLock: uint256) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return self._setActionTimeLock(_newTimeLock, self.actionTimeLock)\n\n\n@internal\ndef _setActionTimeLock(_newTimeLock: uint256, _prevTimeLock: uint256) -> bool:\n    assert self._isValidActionTimeLock(_newTimeLock, _prevTimeLock) # dev: invalid time lock\n    self.actionTimeLock = _newTimeLock\n    log ActionTimeLockSet(newTimeLock=_newTimeLock, prevTimeLock=_prevTimeLock)\n    return True\n\n\n# validation\n\n\n@view\n@external\ndef isValidActionTimeLock(_newTimeLock: uint256) -> bool:\n    return self._isValidActionTimeLock(_newTimeLock, self.actionTimeLock)\n\n\n@view\n@internal\ndef _isValidActionTimeLock(_newTimeLock: uint256, _prevTimeLock: uint256) -> bool:\n    if _newTimeLock == _prevTimeLock:\n        return False # no change\n    return _newTimeLock >= MIN_ACTION_TIMELOCK and _newTimeLock <= MAX_ACTION_TIMELOCK\n\n\n# utils\n\n\n@view\n@external\ndef minActionTimeLock() -> uint256:\n    return MIN_ACTION_TIMELOCK\n\n\n@view\n@external\ndef maxActionTimeLock() -> uint256:\n    return MAX_ACTION_TIMELOCK\n\n\n#######################\n# Config - Expiration #\n#######################\n\n\n@external\ndef setExpiration(_expiration: uint256) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return self._setExpiration(_expiration, self.actionTimeLock)\n\n\n@internal\ndef _setExpiration(_expiration: uint256, _timeLock: uint256) -> bool:\n    assert self._isValidExpiration(_expiration, _timeLock) # dev: invalid expiration\n    self.expiration = _expiration\n    log ExpirationSet(expiration=_expiration)\n    return True\n\n\n# validation\n\n\n@view\n@internal\ndef _isValidExpiration(_expiration: uint256, _timeLock: uint256) -> bool:\n    if _expiration == 0 or _expiration == max_value(uint256):\n        return False\n    if _expiration < _timeLock:\n        return False\n    return True\n\n\n################\n# Finish Setup #\n################\n\n\n@external\ndef setActionTimeLockAfterSetup(_newTimeLock: uint256 = 0) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    prevTimeLock: uint256 = self.actionTimeLock\n    assert prevTimeLock == 0 # dev: already set\n\n    timeLock: uint256 = _newTimeLock\n    if timeLock == 0:\n        timeLock = MIN_ACTION_TIMELOCK\n    return self._setActionTimeLock(timeLock, prevTimeLock)",
            "sha256sum": "80ec25619b21a5ac9791a94ca96d5ee38a887cb59d0e9368e23ea4a2de75da8e"
          },
          "interfaces/ConfigStructs.vyi": {
            "content": "# @version 0.4.3\n\nstruct UserWalletConfig:\n    walletTemplate: address\n    configTemplate: address\n    numUserWalletsAllowed: uint256\n    enforceCreatorWhitelist: bool\n    minKeyActionTimeLock: uint256\n    maxKeyActionTimeLock: uint256\n    depositRewardsAsset: address\n    lootClaimCoolOffPeriod: uint256\n    txFees: TxFees\n    ambassadorRevShare: AmbassadorRevShare\n    yieldConfig: YieldConfig\n\nstruct AssetConfig:\n    hasConfig: bool\n    txFees: TxFees\n    ambassadorRevShare: AmbassadorRevShare\n    yieldConfig: YieldConfig\n\nstruct TxFees:\n    swapFee: uint256\n    stableSwapFee: uint256\n    rewardsFee: uint256\n\nstruct AmbassadorRevShare:\n    swapRatio: uint256\n    rewardsRatio: uint256\n    yieldRatio: uint256\n\nstruct YieldConfig:\n    maxYieldIncrease: uint256\n    performanceFee: uint256\n    ambassadorBonusRatio: uint256\n    bonusRatio: uint256\n    bonusAsset: address\n\nstruct AgentConfig:\n    startingAgent: address\n    startingAgentActivationLength: uint256\n\nstruct ManagerConfig:\n    managerPeriod: uint256\n    managerActivationLength: uint256\n    mustHaveUsdValueOnSwaps: bool\n    maxNumSwapsPerPeriod: uint256\n    maxSlippageOnSwaps: uint256\n    onlyApprovedYieldOpps: bool\n\nstruct PayeeConfig:\n    payeePeriod: uint256\n    payeeActivationLength: uint256\n\nstruct ChequeConfig:\n    maxNumActiveCheques: uint256\n    instantUsdThreshold: uint256\n    periodLength: uint256\n    expensiveDelayBlocks: uint256\n    defaultExpiryBlocks: uint256\n\nstruct RipeRewardsConfig:\n    stakeRatio: uint256\n    lockDuration: uint256",
            "sha256sum": "4a631b60c85398adcd4e8174532e69540dd8df9afff85b0876f3feeae196af74"
          },
          "contracts/config/SwitchboardAlpha.vy": {
            "content": "#        ______   __     __   __   ______  ______   __  __   ______   ______   ______   ______   _____    \n#       /\\  ___\\ /\\ \\  _ \\ \\ /\\ \\ /\\__  _\\/\\  ___\\ /\\ \\_\\ \\ /\\  == \\ /\\  __ \\ /\\  __ \\ /\\  == \\ /\\  __-.  \n#       \\ \\___  \\\\ \\ \\/ \".\\ \\\\ \\ \\\\/_/\\ \\/\\ \\ \\____\\ \\  __ \\\\ \\  __< \\ \\ \\/\\ \\\\ \\  __ \\\\ \\  __< \\ \\ \\/\\ \\ \n#        \\/\\_____\\\\ \\__/\".~\\_\\\\ \\_\\  \\ \\_\\ \\ \\_____\\\\ \\_\\ \\_\\\\ \\_____\\\\ \\_____\\\\ \\_\\ \\_\\\\ \\_\\ \\_\\\\ \\____- \n#         \\/_____/ \\/_/   \\/_/ \\/_/   \\/_/  \\/_____/ \\/_/\\/_/ \\/_____/ \\/_____/ \\/_/\\/_/ \\/_/ /_/ \\/____/ \n#                                                  \u250f\u2513\u2513  \u2513   \n#                                                  \u2523\u252b\u2503\u250f\u2513\u2523\u2513\u250f\u2513\n#                                                  \u251b\u2517\u2517\u2523\u251b\u251b\u2517\u2517\u253b\n#                                                     \u251b     \n#\n#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nexports: addys.__interface__\nexports: gov.__interface__\nexports: timeLock.__interface__\n\ninitializes: addys\ninitializes: gov\ninitializes: timeLock[gov := gov]\n\nimport contracts.modules.Addys as addys\nimport contracts.modules.LocalGov as gov\nimport contracts.modules.TimeLock as timeLock\n\nimport interfaces.ConfigStructs as cs\n\ninterface MissionControl:\n    def setCanPerformSecurityAction(_signer: address, _canPerform: bool): nonpayable\n    def setCreatorWhitelist(_creator: address, _isWhitelisted: bool): nonpayable\n    def setAssetConfig(_asset: address, _config: cs.AssetConfig): nonpayable\n    def setIsStablecoin(_asset: address, _isStablecoin: bool): nonpayable\n    def setLockedSigner(_signer: address, _isLocked: bool): nonpayable\n    def setUserWalletConfig(_config: cs.UserWalletConfig): nonpayable\n    def canPerformSecurityAction(_signer: address) -> bool: view\n    def setManagerConfig(_config: cs.ManagerConfig): nonpayable\n    def assetConfig(_asset: address) -> cs.AssetConfig: view\n    def setPayeeConfig(_config: cs.PayeeConfig): nonpayable\n    def setAgentConfig(_config: cs.AgentConfig): nonpayable\n    def userWalletConfig() -> cs.UserWalletConfig: view\n    def agentConfig() -> cs.AgentConfig: view\n    def setRipeRewardsConfig(_config: cs.RipeRewardsConfig): nonpayable\n\ninterface AgentWrapper:\n    def removeSender(_sender: address): nonpayable\n    def addSender(_sender: address): nonpayable\n\nflag ActionType:\n    USER_WALLET_TEMPLATES\n    WALLET_CREATION_LIMITS\n    KEY_ACTION_TIMELOCK_BOUNDS\n    TX_FEES\n    AMBASSADOR_REV_SHARE\n    DEFAULT_YIELD_PARAMS\n    LOOT_PARAMS\n    STARTER_AGENT_PARAMS\n    MANAGER_CONFIG\n    PAYEE_CONFIG\n    CAN_PERFORM_SECURITY_ACTION\n    ASSET_CONFIG\n    ASSET_TX_FEES\n    ASSET_AMBASSADOR_REV_SHARE\n    ASSET_YIELD_CONFIG\n    IS_STABLECOIN\n    AGENT_WRAPPER_SENDER\n    RIPE_REWARDS_CONFIG\n\nstruct IsAddrAllowed:\n    addr: address\n    isAllowed: bool\n\nstruct PendingAssetConfig:\n    asset: address\n    config: cs.AssetConfig\n\nstruct PendingAssetTxFees:\n    asset: address\n    txFees: cs.TxFees\n\nstruct PendingAssetAmbassadorRevShare:\n    asset: address\n    ambassadorRevShare: cs.AmbassadorRevShare\n\nstruct PendingAssetYieldConfig:\n    asset: address\n    yieldConfig: cs.YieldConfig\n\nstruct PendingAgentWrapperSender:\n    agentWrapper: address\n    agentSender: address\n\nevent PendingUserWalletTemplatesChange:\n    walletTemplate: address\n    configTemplate: address\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent UserWalletTemplatesSet:\n    walletTemplate: address\n    configTemplate: address\n\nevent PendingWalletCreationLimitsChange:\n    numUserWalletsAllowed: uint256\n    enforceCreatorWhitelist: bool\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent WalletCreationLimitsSet:\n    numUserWalletsAllowed: uint256\n    enforceCreatorWhitelist: bool\n\nevent PendingKeyActionTimelockBoundsChange:\n    minKeyActionTimeLock: uint256\n    maxKeyActionTimeLock: uint256\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent KeyActionTimelockBoundsSet:\n    minKeyActionTimeLock: uint256\n    maxKeyActionTimeLock: uint256\n\nevent PendingTxFeesChange:\n    swapFee: uint256\n    stableSwapFee: uint256\n    rewardsFee: uint256\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent TxFeesSet:\n    swapFee: uint256\n    stableSwapFee: uint256\n    rewardsFee: uint256\n\nevent PendingAmbassadorRevShareChange:\n    swapRatio: uint256\n    rewardsRatio: uint256\n    yieldRatio: uint256\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent AmbassadorRevShareSet:\n    swapRatio: uint256\n    rewardsRatio: uint256\n    yieldRatio: uint256\n\nevent PendingDefaultYieldParamsChange:\n    defaultYieldMaxIncrease: uint256\n    defaultYieldPerformanceFee: uint256\n    defaultYieldAmbassadorBonusRatio: uint256\n    defaultYieldBonusRatio: uint256\n    defaultYieldBonusAsset: address\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent DefaultYieldParamsSet:\n    defaultYieldMaxIncrease: uint256\n    defaultYieldPerformanceFee: uint256\n    defaultYieldAmbassadorBonusRatio: uint256\n    defaultYieldBonusRatio: uint256\n    defaultYieldBonusAsset: address\n\nevent PendingLootParamsChange:\n    depositRewardsAsset: address\n    lootClaimCoolOffPeriod: uint256\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent LootParamsSet:\n    depositRewardsAsset: address\n    lootClaimCoolOffPeriod: uint256\n\nevent PendingAssetConfigChange:\n    asset: address\n    txFeesSwapFee: uint256\n    txFeesStableSwapFee: uint256\n    txFeesRewardsFee: uint256\n    ambassadorRevShareSwapRatio: uint256\n    ambassadorRevShareRewardsRatio: uint256\n    ambassadorRevShareYieldRatio: uint256\n    maxYieldIncrease: uint256\n    performanceFee: uint256\n    ambassadorBonusRatio: uint256\n    bonusRatio: uint256\n    bonusAsset: address\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent PendingIsStablecoinChange:\n    asset: address\n    isStablecoin: bool\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent IsStablecoinSet:\n    asset: address\n    isStablecoin: bool\n\nevent AssetConfigSet:\n    asset: address\n    txFeesSwapFee: uint256\n    txFeesStableSwapFee: uint256\n    txFeesRewardsFee: uint256\n    ambassadorRevShareSwapRatio: uint256\n    ambassadorRevShareRewardsRatio: uint256\n    ambassadorRevShareYieldRatio: uint256\n    maxYieldIncrease: uint256\n    performanceFee: uint256\n    ambassadorBonusRatio: uint256\n    bonusRatio: uint256\n    bonusAsset: address\n\nevent PendingAssetTxFeesChange:\n    asset: address\n    swapFee: uint256\n    stableSwapFee: uint256\n    rewardsFee: uint256\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent AssetTxFeesSet:\n    asset: address\n    swapFee: uint256\n    stableSwapFee: uint256\n    rewardsFee: uint256\n\nevent PendingAssetAmbassadorRevShareChange:\n    asset: address\n    swapRatio: uint256\n    rewardsRatio: uint256\n    yieldRatio: uint256\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent AssetAmbassadorRevShareSet:\n    asset: address\n    swapRatio: uint256\n    rewardsRatio: uint256\n    yieldRatio: uint256\n\nevent PendingAssetYieldConfigChange:\n    asset: address\n    maxYieldIncrease: uint256\n    performanceFee: uint256\n    ambassadorBonusRatio: uint256\n    bonusRatio: uint256\n    bonusAsset: address\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent AssetYieldConfigSet:\n    asset: address\n    maxYieldIncrease: uint256\n    performanceFee: uint256\n    ambassadorBonusRatio: uint256\n    bonusRatio: uint256\n    bonusAsset: address\n\nevent PendingStarterAgentParamsChange:\n    startingAgent: address\n    startingAgentActivationLength: uint256\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent StarterAgentParamsSet:\n    startingAgent: address\n    startingAgentActivationLength: uint256\n\nevent PendingManagerConfigChange:\n    managerPeriod: uint256\n    managerActivationLength: uint256\n    mustHaveUsdValueOnSwaps: bool\n    maxNumSwapsPerPeriod: uint256\n    maxSlippageOnSwaps: uint256\n    onlyApprovedYieldOpps: bool\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent PendingPayeeConfigChange:\n    payeePeriod: uint256\n    payeeActivationLength: uint256\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent PendingCanPerformSecurityAction:\n    signer: address\n    canPerform: bool\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent CreatorWhitelistSet:\n    creator: address\n    isWhitelisted: bool\n    caller: address\n\nevent ManagerConfigSet:\n    managerPeriod: uint256\n    managerActivationLength: uint256\n\nevent PayeeConfigSet:\n    payeePeriod: uint256\n    payeeActivationLength: uint256\n\nevent CanPerformSecurityAction:\n    signer: address\n    canPerform: bool\n\nevent LockedSignerSet:\n    signer: address\n    isLocked: bool\n    caller: address\n\nevent PendingRipeRewardsConfigChange:\n    ripeStakeRatio: uint256\n    ripeLockDuration: uint256\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent RipeRewardsConfigSet:\n    ripeStakeRatio: uint256\n    ripeLockDuration: uint256\n\nevent PendingAgentWrapperSenderAdd:\n    agentWrapper: indexed(address)\n    agentSender: indexed(address)\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent AgentWrapperSenderAdded:\n    agentWrapper: indexed(address)\n    agentSender: indexed(address)\n\nevent AgentWrapperSenderRemoved:\n    agentWrapper: indexed(address)\n    agentSender: indexed(address)\n\n# pending config changes\nactionType: public(HashMap[uint256, ActionType]) # aid -> type\npendingUserWalletConfig: public(HashMap[uint256, cs.UserWalletConfig]) # aid -> config\npendingAssetConfig: public(HashMap[uint256, PendingAssetConfig]) # aid -> config\npendingAssetTxFees: public(HashMap[uint256, PendingAssetTxFees]) # aid -> tx fees\npendingAssetAmbassadorRevShare: public(HashMap[uint256, PendingAssetAmbassadorRevShare]) # aid -> ambassador rev share\npendingAssetYieldConfig: public(HashMap[uint256, PendingAssetYieldConfig]) # aid -> yield config\npendingAgentConfig: public(HashMap[uint256, cs.AgentConfig]) # aid -> config\npendingManagerConfig: public(HashMap[uint256, cs.ManagerConfig]) # aid -> config\npendingPayeeConfig: public(HashMap[uint256, cs.PayeeConfig]) # aid -> config\npendingAddrToBool: public(HashMap[uint256, IsAddrAllowed])\npendingAgentWrapperSender: public(HashMap[uint256, PendingAgentWrapperSender])\npendingRipeRewardsConfig: public(HashMap[uint256, cs.RipeRewardsConfig])\npendingMissionControl: public(HashMap[uint256, address]) # aid -> target mission control\n\nHUNDRED_PERCENT: constant(uint256) = 100_00 # 100%\n\n\n@deploy\ndef __init__(\n    _undyHq: address,\n    _tempGov: address,\n    _minConfigTimeLock: uint256,\n    _maxConfigTimeLock: uint256,\n):\n    addys.__init__(_undyHq)\n    gov.__init__(_undyHq, _tempGov, 0, 0, 0)\n    timeLock.__init__(_minConfigTimeLock, _maxConfigTimeLock, 0, _maxConfigTimeLock)\n\n\n# access control\n\n\n@view\n@internal\ndef _hasPermsToEnable(_caller: address, _shouldEnable: bool) -> bool:\n    if gov._canGovern(_caller):\n        return True\n    if not _shouldEnable:\n        return staticcall MissionControl(addys._getMissionControlAddr()).canPerformSecurityAction(_caller)\n    return False\n\n\n@view\n@internal\ndef _resolveMissionControl(_missionControl: address) -> address:\n    mc: address = addys._getMissionControlAddr()\n    if _missionControl == empty(address):\n        return mc\n    assert _missionControl != mc # dev: use empty for current mission control\n    return _missionControl\n\n\n######################\n# User Wallet Config #\n######################\n\n\n# user wallet templates\n\n\n@external\ndef setUserWalletTemplates(_walletTemplate: address, _configTemplate: address, _missionControl: address = empty(address)) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    mc: address = self._resolveMissionControl(_missionControl)\n    assert self._areValidUserWalletTemplates(_walletTemplate, _configTemplate) # dev: invalid user wallet templates\n    return self._setPendingUserWalletConfig(ActionType.USER_WALLET_TEMPLATES, mc, _walletTemplate, _configTemplate)\n\n\n@view\n@internal\ndef _areValidUserWalletTemplates(_walletTemplate: address, _configTemplate: address) -> bool:\n    if empty(address) in [_walletTemplate, _configTemplate]:\n        return False\n    if not _walletTemplate.is_contract or not _configTemplate.is_contract:\n        return False\n    return True\n\n\n# wallet creation limits\n\n\n@external\ndef setWalletCreationLimits(_numUserWalletsAllowed: uint256, _enforceCreatorWhitelist: bool, _missionControl: address = empty(address)) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    mc: address = self._resolveMissionControl(_missionControl)\n    assert self._isValidNumUserWalletsAllowed(_numUserWalletsAllowed) # dev: invalid num user wallets allowed\n    return self._setPendingUserWalletConfig(\n        ActionType.WALLET_CREATION_LIMITS,\n        mc,\n        empty(address),\n        empty(address),\n        _numUserWalletsAllowed,\n        _enforceCreatorWhitelist\n    )\n\n\n@view\n@internal\ndef _isValidNumUserWalletsAllowed(_numUserWalletsAllowed: uint256) -> bool:\n    if _numUserWalletsAllowed == 0:\n        return False\n    if _numUserWalletsAllowed == max_value(uint256):\n        return False\n    return True\n\n\n# key action timelock bounds\n\n\n@external\ndef setKeyActionTimelockBounds(_minKeyActionTimeLock: uint256, _maxKeyActionTimeLock: uint256, _missionControl: address = empty(address)) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    mc: address = self._resolveMissionControl(_missionControl)\n    assert self._areValidKeyActionTimelockBounds(_minKeyActionTimeLock, _maxKeyActionTimeLock) # dev: invalid key action timelock bounds\n    return self._setPendingUserWalletConfig(\n        ActionType.KEY_ACTION_TIMELOCK_BOUNDS,\n        mc,\n        empty(address),\n        empty(address),\n        0,\n        False,\n        _minKeyActionTimeLock,\n        _maxKeyActionTimeLock\n    )\n\n\n@view\n@internal\ndef _areValidKeyActionTimelockBounds(_minKeyActionTimeLock: uint256, _maxKeyActionTimeLock: uint256) -> bool:\n    if 0 in [_minKeyActionTimeLock, _maxKeyActionTimeLock]:\n        return False\n    if max_value(uint256) in [_minKeyActionTimeLock, _maxKeyActionTimeLock]:\n        return False\n    if _minKeyActionTimeLock >= _maxKeyActionTimeLock:\n        return False\n    return True\n\n\n# tx fees\n\n\n@external\ndef setTxFees(_swapFee: uint256, _stableSwapFee: uint256, _rewardsFee: uint256, _missionControl: address = empty(address)) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    mc: address = self._resolveMissionControl(_missionControl)\n    assert self._areValidTxFees(_swapFee, _stableSwapFee, _rewardsFee) # dev: invalid tx fees\n    return self._setPendingUserWalletConfig(\n        ActionType.TX_FEES,\n        mc,\n        empty(address),\n        empty(address),\n        0,\n        False,\n        0,\n        0,\n        empty(address),\n        0,\n        _swapFee,\n        _stableSwapFee,\n        _rewardsFee\n    )\n\n\n@view\n@internal\ndef _areValidTxFees(_swapFee: uint256, _stableSwapFee: uint256, _rewardsFee: uint256) -> bool:\n    if _swapFee > 5_00: # 5% max\n        return False\n    if _stableSwapFee > 2_00: # 2% max\n        return False\n    if _rewardsFee > 25_00: # 25% max\n        return False\n    return True\n\n\n# ambassador rev share\n\n\n@external\ndef setAmbassadorRevShare(_swapRatio: uint256, _rewardsRatio: uint256, _yieldRatio: uint256, _missionControl: address = empty(address)) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    mc: address = self._resolveMissionControl(_missionControl)\n    assert self._areValidAmbassadorRevShareRatios(_swapRatio, _rewardsRatio, _yieldRatio) # dev: invalid ambassador rev share ratios\n    return self._setPendingUserWalletConfig(\n        ActionType.AMBASSADOR_REV_SHARE,\n        mc,\n        empty(address),\n        empty(address),\n        0,\n        False,\n        0,\n        0,\n        empty(address),\n        0,\n        0,\n        0,\n        0,\n        _swapRatio,\n        _rewardsRatio,\n        _yieldRatio\n    )\n\n\n@view\n@internal\ndef _areValidAmbassadorRevShareRatios(_swapRatio: uint256, _rewardsRatio: uint256, _yieldRatio: uint256) -> bool:\n    if _swapRatio > HUNDRED_PERCENT:\n        return False\n    if _rewardsRatio > HUNDRED_PERCENT:\n        return False\n    if _yieldRatio > HUNDRED_PERCENT:\n        return False\n    return True\n\n\n# default yield params\n\n\n@external\ndef setDefaultYieldParams(\n    _defaultYieldMaxIncrease: uint256,\n    _defaultYieldPerformanceFee: uint256,\n    _defaultYieldAmbassadorBonusRatio: uint256,\n    _defaultYieldBonusRatio: uint256,\n    _defaultYieldBonusAsset: address,\n    _missionControl: address = empty(address)\n) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    mc: address = self._resolveMissionControl(_missionControl)\n    assert self._areValidYieldParams(\n        _defaultYieldMaxIncrease,\n        _defaultYieldPerformanceFee,\n        _defaultYieldAmbassadorBonusRatio,\n        _defaultYieldBonusRatio\n    ) # dev: invalid default yield params\n\n    return self._setPendingUserWalletConfig(\n        ActionType.DEFAULT_YIELD_PARAMS,\n        mc,\n        empty(address),\n        empty(address),\n        0,\n        False,\n        0,\n        0,\n        empty(address),\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        _defaultYieldMaxIncrease,\n        _defaultYieldPerformanceFee,\n        _defaultYieldAmbassadorBonusRatio,\n        _defaultYieldBonusRatio,\n        _defaultYieldBonusAsset\n    )\n\n\n@view\n@internal\ndef _areValidYieldParams(\n    _maxIncrease: uint256,\n    _performanceFee: uint256,\n    _ambassadorBonusRatio: uint256,\n    _bonusRatio: uint256\n) -> bool:\n    if _maxIncrease > 10_00: # 10% max\n        return False\n    if _performanceFee > 25_00: # 25% max\n        return False\n    if _ambassadorBonusRatio > HUNDRED_PERCENT:\n        return False\n    if _bonusRatio > HUNDRED_PERCENT:\n        return False\n    return True\n\n\n# loot params\n\n\n@external\ndef setLootParams(_depositRewardsAsset: address, _lootClaimCoolOffPeriod: uint256, _missionControl: address = empty(address)) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    mc: address = self._resolveMissionControl(_missionControl)\n    assert self._areValidLootParams(_lootClaimCoolOffPeriod) # dev: invalid loot params\n    return self._setPendingUserWalletConfig(\n        ActionType.LOOT_PARAMS,\n        mc,\n        empty(address),\n        empty(address),\n        0,\n        False,\n        0,\n        0,\n        _depositRewardsAsset,\n        _lootClaimCoolOffPeriod,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        empty(address)\n    )\n\n\n@view\n@internal\ndef _areValidLootParams(_lootClaimCoolOffPeriod: uint256) -> bool:\n    if _lootClaimCoolOffPeriod == 0:\n        return False\n    if _lootClaimCoolOffPeriod == max_value(uint256):\n        return False\n    return True\n\n\n################\n# Asset Config #\n################\n\n\n@external\ndef setAssetConfig(\n    _asset: address,\n    _txFeesSwapFee: uint256,\n    _txFeesStableSwapFee: uint256,\n    _txFeesRewardsFee: uint256,\n    _ambassadorRevShareSwapRatio: uint256,\n    _ambassadorRevShareRewardsRatio: uint256,\n    _ambassadorRevShareYieldRatio: uint256,\n    _maxYieldIncrease: uint256,\n    _performanceFee: uint256,\n    _ambassadorBonusRatio: uint256,\n    _bonusRatio: uint256,\n    _bonusAsset: address,\n    _missionControl: address = empty(address)\n) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    mc: address = self._resolveMissionControl(_missionControl)\n    assert self._isValidAssetConfig(\n        _asset,\n        _txFeesSwapFee,\n        _txFeesStableSwapFee,\n        _txFeesRewardsFee,\n        _ambassadorRevShareSwapRatio,\n        _ambassadorRevShareRewardsRatio,\n        _ambassadorRevShareYieldRatio,\n        _maxYieldIncrease,\n        _performanceFee,\n        _ambassadorBonusRatio,\n        _bonusRatio,\n        _bonusAsset\n    ) # dev: invalid asset config\n\n    yieldConfig: cs.YieldConfig = cs.YieldConfig(\n        maxYieldIncrease=_maxYieldIncrease,\n        performanceFee=_performanceFee,\n        ambassadorBonusRatio=_ambassadorBonusRatio,\n        bonusRatio=_bonusRatio,\n        bonusAsset=_bonusAsset\n    )\n\n    aid: uint256 = timeLock._initiateAction()\n    self.actionType[aid] = ActionType.ASSET_CONFIG\n    self.pendingMissionControl[aid] = mc\n    self.pendingAssetConfig[aid] = PendingAssetConfig(\n        asset=_asset,\n        config=cs.AssetConfig(\n            hasConfig=True,\n            txFees=cs.TxFees(\n                swapFee=_txFeesSwapFee,\n                stableSwapFee=_txFeesStableSwapFee,\n                rewardsFee=_txFeesRewardsFee,\n            ),\n            ambassadorRevShare=cs.AmbassadorRevShare(\n                swapRatio=_ambassadorRevShareSwapRatio,\n                rewardsRatio=_ambassadorRevShareRewardsRatio,\n                yieldRatio=_ambassadorRevShareYieldRatio,\n            ),\n            yieldConfig=yieldConfig,\n        )\n    )\n    confirmationBlock: uint256 = timeLock._getActionConfirmationBlock(aid)\n    log PendingAssetConfigChange(\n        asset=_asset,\n        txFeesSwapFee=_txFeesSwapFee,\n        txFeesStableSwapFee=_txFeesStableSwapFee,\n        txFeesRewardsFee=_txFeesRewardsFee,\n        ambassadorRevShareSwapRatio=_ambassadorRevShareSwapRatio,\n        ambassadorRevShareRewardsRatio=_ambassadorRevShareRewardsRatio,\n        ambassadorRevShareYieldRatio=_ambassadorRevShareYieldRatio,\n        maxYieldIncrease=_maxYieldIncrease,\n        performanceFee=_performanceFee,\n        ambassadorBonusRatio=_ambassadorBonusRatio,\n        bonusRatio=_bonusRatio,\n        bonusAsset=_bonusAsset,\n        confirmationBlock=confirmationBlock,\n        actionId=aid,\n    )\n    return aid\n\n\n@view\n@internal\ndef _isValidAssetConfig(\n    _asset: address,\n    _txFeesSwapFee: uint256,\n    _txFeesStableSwapFee: uint256,\n    _txFeesRewardsFee: uint256,\n    _ambassadorRevShareSwapRatio: uint256,\n    _ambassadorRevShareRewardsRatio: uint256,\n    _ambassadorRevShareYieldRatio: uint256,\n    _maxYieldIncrease: uint256,\n    _performanceFee: uint256,\n    _ambassadorBonusRatio: uint256,\n    _bonusRatio: uint256,\n    _bonusAsset: address\n) -> bool:\n    if _asset == empty(address):\n        return False\n\n    if not self._areValidTxFees(_txFeesSwapFee, _txFeesStableSwapFee, _txFeesRewardsFee):\n        return False\n\n    if not self._areValidAmbassadorRevShareRatios(_ambassadorRevShareSwapRatio, _ambassadorRevShareRewardsRatio, _ambassadorRevShareYieldRatio):\n        return False\n\n    if not self._areValidYieldParams(_maxYieldIncrease, _performanceFee, _ambassadorBonusRatio, _bonusRatio):\n        return False\n\n    return True\n\n\n# granular asset config setters\n\n\n@external\ndef setAssetTxFees(\n    _asset: address,\n    _swapFee: uint256,\n    _stableSwapFee: uint256,\n    _rewardsFee: uint256,\n    _missionControl: address = empty(address)\n) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert _asset != empty(address) # dev: invalid asset\n\n    # Ensure full asset config has been set first\n    mc: address = self._resolveMissionControl(_missionControl)\n    existingConfig: cs.AssetConfig = staticcall MissionControl(mc).assetConfig(_asset)\n    assert existingConfig.hasConfig # dev: must set full asset config first\n\n    assert self._areValidTxFees(_swapFee, _stableSwapFee, _rewardsFee) # dev: invalid tx fees\n\n    aid: uint256 = timeLock._initiateAction()\n    self.actionType[aid] = ActionType.ASSET_TX_FEES\n    self.pendingMissionControl[aid] = mc\n    self.pendingAssetTxFees[aid] = PendingAssetTxFees(\n        asset=_asset,\n        txFees=cs.TxFees(\n            swapFee=_swapFee,\n            stableSwapFee=_stableSwapFee,\n            rewardsFee=_rewardsFee\n        )\n    )\n    confirmationBlock: uint256 = timeLock._getActionConfirmationBlock(aid)\n    log PendingAssetTxFeesChange(\n        asset=_asset,\n        swapFee=_swapFee,\n        stableSwapFee=_stableSwapFee,\n        rewardsFee=_rewardsFee,\n        confirmationBlock=confirmationBlock,\n        actionId=aid\n    )\n    return aid\n\n\n@external\ndef setAssetAmbassadorRevShare(\n    _asset: address,\n    _swapRatio: uint256,\n    _rewardsRatio: uint256,\n    _yieldRatio: uint256,\n    _missionControl: address = empty(address)\n) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert _asset != empty(address) # dev: invalid asset\n\n    # Ensure full asset config has been set first\n    mc: address = self._resolveMissionControl(_missionControl)\n    existingConfig: cs.AssetConfig = staticcall MissionControl(mc).assetConfig(_asset)\n    assert existingConfig.hasConfig # dev: must set full asset config first\n\n    assert self._areValidAmbassadorRevShareRatios(_swapRatio, _rewardsRatio, _yieldRatio) # dev: invalid ratios\n\n    aid: uint256 = timeLock._initiateAction()\n    self.actionType[aid] = ActionType.ASSET_AMBASSADOR_REV_SHARE\n    self.pendingMissionControl[aid] = mc\n    self.pendingAssetAmbassadorRevShare[aid] = PendingAssetAmbassadorRevShare(\n        asset=_asset,\n        ambassadorRevShare=cs.AmbassadorRevShare(\n            swapRatio=_swapRatio,\n            rewardsRatio=_rewardsRatio,\n            yieldRatio=_yieldRatio\n        )\n    )\n    confirmationBlock: uint256 = timeLock._getActionConfirmationBlock(aid)\n    log PendingAssetAmbassadorRevShareChange(\n        asset=_asset,\n        swapRatio=_swapRatio,\n        rewardsRatio=_rewardsRatio,\n        yieldRatio=_yieldRatio,\n        confirmationBlock=confirmationBlock,\n        actionId=aid\n    )\n    return aid\n\n\n@external\ndef setAssetYieldConfig(\n    _asset: address,\n    _maxYieldIncrease: uint256,\n    _performanceFee: uint256,\n    _ambassadorBonusRatio: uint256,\n    _bonusRatio: uint256,\n    _bonusAsset: address,\n    _missionControl: address = empty(address)\n) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert _asset != empty(address) # dev: invalid asset\n\n    # Ensure full asset config has been set first\n    mc: address = self._resolveMissionControl(_missionControl)\n    existingConfig: cs.AssetConfig = staticcall MissionControl(mc).assetConfig(_asset)\n    assert existingConfig.hasConfig # dev: must set full asset config first\n\n    assert self._areValidYieldParams(_maxYieldIncrease, _performanceFee, _ambassadorBonusRatio, _bonusRatio) # dev: invalid yield params\n\n    aid: uint256 = timeLock._initiateAction()\n    self.actionType[aid] = ActionType.ASSET_YIELD_CONFIG\n    self.pendingMissionControl[aid] = mc\n    self.pendingAssetYieldConfig[aid] = PendingAssetYieldConfig(\n        asset=_asset,\n        yieldConfig=cs.YieldConfig(\n            maxYieldIncrease=_maxYieldIncrease,\n            performanceFee=_performanceFee,\n            ambassadorBonusRatio=_ambassadorBonusRatio,\n            bonusRatio=_bonusRatio,\n            bonusAsset=_bonusAsset\n        )\n    )\n    confirmationBlock: uint256 = timeLock._getActionConfirmationBlock(aid)\n    log PendingAssetYieldConfigChange(\n        asset=_asset,\n        maxYieldIncrease=_maxYieldIncrease,\n        performanceFee=_performanceFee,\n        ambassadorBonusRatio=_ambassadorBonusRatio,\n        bonusRatio=_bonusRatio,\n        bonusAsset=_bonusAsset,\n        confirmationBlock=confirmationBlock,\n        actionId=aid\n    )\n    return aid\n\n\n# is stablecoin\n\n\n@external\ndef setIsStablecoin(_asset: address, _isStablecoin: bool, _missionControl: address = empty(address)) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    mc: address = self._resolveMissionControl(_missionControl)\n    aid: uint256 = timeLock._initiateAction()\n    self.actionType[aid] = ActionType.IS_STABLECOIN\n    self.pendingMissionControl[aid] = mc\n    self.pendingAddrToBool[aid] = IsAddrAllowed(addr=_asset, isAllowed=_isStablecoin)\n    confirmationBlock: uint256 = timeLock._getActionConfirmationBlock(aid)\n    log PendingIsStablecoinChange(asset=_asset, isStablecoin=_isStablecoin, confirmationBlock=confirmationBlock, actionId=aid)\n    return aid\n\n\n################\n# Agent Config #\n################\n\n\n# starter agent params\n\n\n@external\ndef setStarterAgentParams(_startingAgent: address, _startingAgentActivationLength: uint256, _missionControl: address = empty(address)) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    mc: address = self._resolveMissionControl(_missionControl)\n    assert self._areValidStarterAgentParams(_startingAgent, _startingAgentActivationLength) # dev: invalid starter agent params\n    return self._setPendingAgentConfig(\n        mc,\n        _startingAgent,\n        _startingAgentActivationLength\n    )\n\n\n@view\n@internal\ndef _areValidStarterAgentParams(_startingAgent: address, _startingAgentActivationLength: uint256) -> bool:\n\n    # If starting agent is set, activation length must be non-zero\n    if _startingAgent != empty(address) and _startingAgentActivationLength == 0:\n        return False\n\n    # If starting agent is zero address, activation length must be zero\n    if _startingAgent == empty(address) and _startingAgentActivationLength != 0:\n        return False\n\n    # Activation length cannot be max value\n    if _startingAgentActivationLength == max_value(uint256):\n        return False\n\n    return True\n\n\n# agent wrapper sender\n\n\n@external\ndef setAgentWrapperSender(_agentWrapper: address, _agentSender: address, _shouldAdd: bool) -> uint256:\n    assert self._hasPermsToEnable(msg.sender, _shouldAdd) # dev: no perms\n    assert _agentWrapper != empty(address) # dev: invalid agent wrapper\n    assert _agentSender != empty(address) # dev: invalid agent sender\n\n    # when removing, execute immediately\n    if not _shouldAdd:\n        extcall AgentWrapper(_agentWrapper).removeSender(_agentSender)\n        log AgentWrapperSenderRemoved(agentWrapper=_agentWrapper, agentSender=_agentSender)\n        return 0\n\n    # when adding, use timelock\n    aid: uint256 = timeLock._initiateAction()\n    self.actionType[aid] = ActionType.AGENT_WRAPPER_SENDER\n    self.pendingAgentWrapperSender[aid] = PendingAgentWrapperSender(\n        agentWrapper=_agentWrapper,\n        agentSender=_agentSender\n    )\n    confirmationBlock: uint256 = timeLock._getActionConfirmationBlock(aid)\n    log PendingAgentWrapperSenderAdd(\n        agentWrapper=_agentWrapper,\n        agentSender=_agentSender,\n        confirmationBlock=confirmationBlock,\n        actionId=aid\n    )\n    return aid\n\n\n##################\n# Manager Config #\n##################\n\n\n@external\ndef setManagerConfig(\n    _managerPeriod: uint256,\n    _managerActivationLength: uint256,\n    _mustHaveUsdValueOnSwaps: bool,\n    _maxNumSwapsPerPeriod: uint256,\n    _maxSlippageOnSwaps: uint256,\n    _onlyApprovedYieldOpps: bool,\n    _missionControl: address = empty(address)\n) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    mc: address = self._resolveMissionControl(_missionControl)\n    assert 0 not in [_managerPeriod, _managerActivationLength] # dev: invalid manager config\n    assert max_value(uint256) not in [_managerPeriod, _managerActivationLength] # dev: invalid manager config\n\n    aid: uint256 = timeLock._initiateAction()\n    self.actionType[aid] = ActionType.MANAGER_CONFIG\n    self.pendingMissionControl[aid] = mc\n    self.pendingManagerConfig[aid] = cs.ManagerConfig(\n        managerPeriod=_managerPeriod,\n        managerActivationLength=_managerActivationLength,\n        mustHaveUsdValueOnSwaps=_mustHaveUsdValueOnSwaps,\n        maxNumSwapsPerPeriod=_maxNumSwapsPerPeriod,\n        maxSlippageOnSwaps=_maxSlippageOnSwaps,\n        onlyApprovedYieldOpps=_onlyApprovedYieldOpps,\n    )\n    confirmationBlock: uint256 = timeLock._getActionConfirmationBlock(aid)\n    log PendingManagerConfigChange(\n        managerPeriod=_managerPeriod,\n        managerActivationLength=_managerActivationLength,\n        mustHaveUsdValueOnSwaps=_mustHaveUsdValueOnSwaps,\n        maxNumSwapsPerPeriod=_maxNumSwapsPerPeriod,\n        maxSlippageOnSwaps=_maxSlippageOnSwaps,\n        onlyApprovedYieldOpps=_onlyApprovedYieldOpps,\n        confirmationBlock=confirmationBlock,\n        actionId=aid,\n    )\n    return aid\n\n\n################\n# Payee Config #\n################\n\n\n@external\ndef setPayeeConfig(_payeePeriod: uint256, _payeeActivationLength: uint256, _missionControl: address = empty(address)) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    mc: address = self._resolveMissionControl(_missionControl)\n    assert 0 not in [_payeePeriod, _payeeActivationLength] # dev: invalid payee config\n    assert max_value(uint256) not in [_payeePeriod, _payeeActivationLength] # dev: invalid payee config\n\n    aid: uint256 = timeLock._initiateAction()\n    self.actionType[aid] = ActionType.PAYEE_CONFIG\n    self.pendingMissionControl[aid] = mc\n    self.pendingPayeeConfig[aid] = cs.PayeeConfig(\n        payeePeriod=_payeePeriod,\n        payeeActivationLength=_payeeActivationLength\n    )\n    confirmationBlock: uint256 = timeLock._getActionConfirmationBlock(aid)\n    log PendingPayeeConfigChange(\n        payeePeriod=_payeePeriod,\n        payeeActivationLength=_payeeActivationLength,\n        confirmationBlock=confirmationBlock,\n        actionId=aid,\n    )\n    return aid\n\n\n#########\n# Other #\n#########\n\n\n# can perform security action\n\n\n@external\ndef setCanPerformSecurityAction(_signer: address, _canPerform: bool, _missionControl: address = empty(address)) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    mc: address = self._resolveMissionControl(_missionControl)\n\n    # when removing, allow to do immediately\n    if not _canPerform:\n        extcall MissionControl(mc).setCanPerformSecurityAction(_signer, _canPerform)\n        log CanPerformSecurityAction(signer=_signer, canPerform=_canPerform)\n        return 0\n\n    aid: uint256 = timeLock._initiateAction()\n    self.actionType[aid] = ActionType.CAN_PERFORM_SECURITY_ACTION\n    self.pendingMissionControl[aid] = mc\n    self.pendingAddrToBool[aid] = IsAddrAllowed(addr=_signer, isAllowed=_canPerform)\n    confirmationBlock: uint256 = timeLock._getActionConfirmationBlock(aid)\n    log PendingCanPerformSecurityAction(signer=_signer, canPerform=_canPerform, confirmationBlock=confirmationBlock, actionId=aid)\n    return aid\n\n\n# set creator whitelist\n\n\n@external\ndef setCreatorWhitelist(_creator: address, _isWhitelisted: bool, _missionControl: address = empty(address)):\n    assert self._hasPermsToEnable(msg.sender, _isWhitelisted) # dev: no perms\n\n    assert _creator != empty(address) # dev: invalid creator\n    mc: address = self._resolveMissionControl(_missionControl)\n    extcall MissionControl(mc).setCreatorWhitelist(_creator, _isWhitelisted)\n\n    log CreatorWhitelistSet(creator=_creator, isWhitelisted=_isWhitelisted, caller=msg.sender)\n\n\n# locked signer\n\n\n@external\ndef setLockedSigner(_signer: address, _isLocked: bool, _missionControl: address = empty(address)):\n    assert self._hasPermsToEnable(msg.sender, _isLocked) # dev: no perms\n\n    assert _signer != empty(address) # dev: invalid creator\n    mc: address = self._resolveMissionControl(_missionControl)\n    extcall MissionControl(mc).setLockedSigner(_signer, _isLocked)\n\n    log LockedSignerSet(signer=_signer, isLocked=_isLocked, caller=msg.sender)\n\n\n# ripe rewards config\n\n\n@external\ndef setRipeRewardsConfig(_ripeStakeRatio: uint256, _ripeLockDuration: uint256, _missionControl: address = empty(address)) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert self._isValidRipeRewardsConfig(_ripeStakeRatio, _ripeLockDuration) # dev: invalid ripe rewards config\n\n    aid: uint256 = timeLock._initiateAction()\n    self.actionType[aid] = ActionType.RIPE_REWARDS_CONFIG\n    self.pendingMissionControl[aid] = self._resolveMissionControl(_missionControl)\n    self.pendingRipeRewardsConfig[aid] = cs.RipeRewardsConfig(\n        stakeRatio=_ripeStakeRatio,\n        lockDuration=_ripeLockDuration,\n    )\n\n    confirmationBlock: uint256 = timeLock._getActionConfirmationBlock(aid)\n    log PendingRipeRewardsConfigChange(\n        ripeStakeRatio=_ripeStakeRatio,\n        ripeLockDuration=_ripeLockDuration,\n        confirmationBlock=confirmationBlock,\n        actionId=aid,\n    )\n    return aid\n\n\n@view\n@internal\ndef _isValidRipeRewardsConfig(_ripeStakeRatio: uint256, _ripeLockDuration: uint256) -> bool:\n    if _ripeStakeRatio > HUNDRED_PERCENT:\n        return False\n    return _ripeLockDuration != 0\n\n\n###############\n# Set Pending #\n###############\n\n\n@internal\ndef _setPendingUserWalletConfig(\n    _actionType: ActionType,\n    _missionControl: address,\n    _walletTemplate: address = empty(address),\n    _configTemplate: address = empty(address),\n    _numUserWalletsAllowed: uint256 = 0,\n    _enforceCreatorWhitelist: bool = False,\n    _minKeyActionTimeLock: uint256 = 0,\n    _maxKeyActionTimeLock: uint256 = 0,\n    _depositRewardsAsset: address = empty(address),\n    _lootClaimCoolOffPeriod: uint256 = 0,\n    _txFeesSwapFee: uint256 = 0,\n    _txFeesStableSwapFee: uint256 = 0,\n    _txFeesRewardsFee: uint256 = 0,\n    _ambassadorRevShareSwapRatio: uint256 = 0,\n    _ambassadorRevShareRewardsRatio: uint256 = 0,\n    _ambassadorRevShareYieldRatio: uint256 = 0,\n    _yieldMaxIncrease: uint256 = 0,\n    _yieldPerformanceFee: uint256 = 0,\n    _yieldAmbassadorBonusRatio: uint256 = 0,\n    _yieldBonusRatio: uint256 = 0,\n    _yieldBonusAsset: address = empty(address),\n) -> uint256:\n    aid: uint256 = timeLock._initiateAction()\n\n    self.actionType[aid] = _actionType\n    self.pendingMissionControl[aid] = _missionControl\n    self.pendingUserWalletConfig[aid] = cs.UserWalletConfig(\n        walletTemplate=_walletTemplate,\n        configTemplate=_configTemplate,\n        numUserWalletsAllowed=_numUserWalletsAllowed,\n        enforceCreatorWhitelist=_enforceCreatorWhitelist,\n        minKeyActionTimeLock=_minKeyActionTimeLock,\n        maxKeyActionTimeLock=_maxKeyActionTimeLock,\n        depositRewardsAsset=_depositRewardsAsset,\n        lootClaimCoolOffPeriod=_lootClaimCoolOffPeriod,\n        txFees=cs.TxFees(\n            swapFee=_txFeesSwapFee,\n            stableSwapFee=_txFeesStableSwapFee,\n            rewardsFee=_txFeesRewardsFee,\n        ),\n        ambassadorRevShare=cs.AmbassadorRevShare(\n            swapRatio=_ambassadorRevShareSwapRatio,\n            rewardsRatio=_ambassadorRevShareRewardsRatio,\n            yieldRatio=_ambassadorRevShareYieldRatio,\n        ),\n        yieldConfig=cs.YieldConfig(\n            maxYieldIncrease=_yieldMaxIncrease,\n            performanceFee=_yieldPerformanceFee,\n            ambassadorBonusRatio=_yieldAmbassadorBonusRatio,\n            bonusRatio=_yieldBonusRatio,\n            bonusAsset=_yieldBonusAsset,\n        ),\n    )\n\n    confirmationBlock: uint256 = timeLock._getActionConfirmationBlock(aid)\n    if _actionType == ActionType.USER_WALLET_TEMPLATES:\n        log PendingUserWalletTemplatesChange(\n            walletTemplate=_walletTemplate,\n            configTemplate=_configTemplate,\n            confirmationBlock=confirmationBlock,\n            actionId=aid,\n        )\n    elif _actionType == ActionType.WALLET_CREATION_LIMITS:\n        log PendingWalletCreationLimitsChange(\n            numUserWalletsAllowed=_numUserWalletsAllowed,\n            enforceCreatorWhitelist=_enforceCreatorWhitelist,\n            confirmationBlock=confirmationBlock,\n            actionId=aid,\n        )\n    elif _actionType == ActionType.KEY_ACTION_TIMELOCK_BOUNDS:\n        log PendingKeyActionTimelockBoundsChange(\n            minKeyActionTimeLock=_minKeyActionTimeLock,\n            maxKeyActionTimeLock=_maxKeyActionTimeLock,\n            confirmationBlock=confirmationBlock,\n            actionId=aid,\n        )\n    elif _actionType == ActionType.TX_FEES:\n        log PendingTxFeesChange(\n            swapFee=_txFeesSwapFee,\n            stableSwapFee=_txFeesStableSwapFee,\n            rewardsFee=_txFeesRewardsFee,\n            confirmationBlock=confirmationBlock,\n            actionId=aid,\n        )\n    elif _actionType == ActionType.AMBASSADOR_REV_SHARE:\n        log PendingAmbassadorRevShareChange(\n            swapRatio=_ambassadorRevShareSwapRatio,\n            rewardsRatio=_ambassadorRevShareRewardsRatio,\n            yieldRatio=_ambassadorRevShareYieldRatio,\n            confirmationBlock=confirmationBlock,\n            actionId=aid,\n        )\n    elif _actionType == ActionType.DEFAULT_YIELD_PARAMS:\n        log PendingDefaultYieldParamsChange(\n            defaultYieldMaxIncrease=_yieldMaxIncrease,\n            defaultYieldPerformanceFee=_yieldPerformanceFee,\n            defaultYieldAmbassadorBonusRatio=_yieldAmbassadorBonusRatio,\n            defaultYieldBonusRatio=_yieldBonusRatio,\n            defaultYieldBonusAsset=_yieldBonusAsset,\n            confirmationBlock=confirmationBlock,\n            actionId=aid,\n        )\n    elif _actionType == ActionType.LOOT_PARAMS:\n        log PendingLootParamsChange(\n            depositRewardsAsset=_depositRewardsAsset,\n            lootClaimCoolOffPeriod=_lootClaimCoolOffPeriod,\n            confirmationBlock=confirmationBlock,\n            actionId=aid,\n        )\n    return aid\n\n\n@internal\ndef _setPendingAgentConfig(\n    _missionControl: address,\n    _startingAgent: address,\n    _startingAgentActivationLength: uint256,\n) -> uint256:\n    aid: uint256 = timeLock._initiateAction()\n\n    self.actionType[aid] = ActionType.STARTER_AGENT_PARAMS\n    self.pendingMissionControl[aid] = _missionControl\n    self.pendingAgentConfig[aid] = cs.AgentConfig(\n        startingAgent=_startingAgent,\n        startingAgentActivationLength=_startingAgentActivationLength,\n    )\n\n    confirmationBlock: uint256 = timeLock._getActionConfirmationBlock(aid)\n    log PendingStarterAgentParamsChange(\n        startingAgent=_startingAgent,\n        startingAgentActivationLength=_startingAgentActivationLength,\n        confirmationBlock=confirmationBlock,\n        actionId=aid,\n    )\n    return aid\n\n\n#############\n# Execution #\n#############\n\n\n@external\ndef executePendingAction(_aid: uint256) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    # check time lock\n    if not timeLock._confirmAction(_aid):\n        if timeLock._isExpired(_aid):\n            self._cancelPendingAction(_aid)\n        return False\n\n    actionType: ActionType = self.actionType[_aid]\n    mc: address = self.pendingMissionControl[_aid]\n    if mc == empty(address):\n        mc = addys._getMissionControlAddr()\n\n    if actionType == ActionType.USER_WALLET_TEMPLATES:\n        config: cs.UserWalletConfig = staticcall MissionControl(mc).userWalletConfig()\n        p: cs.UserWalletConfig = self.pendingUserWalletConfig[_aid]\n        config.walletTemplate = p.walletTemplate\n        config.configTemplate = p.configTemplate\n        extcall MissionControl(mc).setUserWalletConfig(config)\n        log UserWalletTemplatesSet(walletTemplate=p.walletTemplate, configTemplate=p.configTemplate)\n\n    elif actionType == ActionType.WALLET_CREATION_LIMITS:\n        config: cs.UserWalletConfig = staticcall MissionControl(mc).userWalletConfig()\n        p: cs.UserWalletConfig = self.pendingUserWalletConfig[_aid]\n        config.numUserWalletsAllowed = p.numUserWalletsAllowed\n        config.enforceCreatorWhitelist = p.enforceCreatorWhitelist\n        extcall MissionControl(mc).setUserWalletConfig(config)\n        log WalletCreationLimitsSet(numUserWalletsAllowed=p.numUserWalletsAllowed, enforceCreatorWhitelist=p.enforceCreatorWhitelist)\n\n    elif actionType == ActionType.KEY_ACTION_TIMELOCK_BOUNDS:\n        config: cs.UserWalletConfig = staticcall MissionControl(mc).userWalletConfig()\n        p: cs.UserWalletConfig = self.pendingUserWalletConfig[_aid]\n        config.minKeyActionTimeLock = p.minKeyActionTimeLock\n        config.maxKeyActionTimeLock = p.maxKeyActionTimeLock\n        extcall MissionControl(mc).setUserWalletConfig(config)\n        log KeyActionTimelockBoundsSet(minKeyActionTimeLock=p.minKeyActionTimeLock, maxKeyActionTimeLock=p.maxKeyActionTimeLock)\n\n    elif actionType == ActionType.TX_FEES:\n        config: cs.UserWalletConfig = staticcall MissionControl(mc).userWalletConfig()\n        p: cs.UserWalletConfig = self.pendingUserWalletConfig[_aid]\n        config.txFees = p.txFees\n        extcall MissionControl(mc).setUserWalletConfig(config)\n        log TxFeesSet(swapFee=p.txFees.swapFee, stableSwapFee=p.txFees.stableSwapFee, rewardsFee=p.txFees.rewardsFee)\n\n    elif actionType == ActionType.AMBASSADOR_REV_SHARE:\n        config: cs.UserWalletConfig = staticcall MissionControl(mc).userWalletConfig()\n        p: cs.UserWalletConfig = self.pendingUserWalletConfig[_aid]\n        config.ambassadorRevShare = p.ambassadorRevShare\n        extcall MissionControl(mc).setUserWalletConfig(config)\n        log AmbassadorRevShareSet(swapRatio=p.ambassadorRevShare.swapRatio, rewardsRatio=p.ambassadorRevShare.rewardsRatio, yieldRatio=p.ambassadorRevShare.yieldRatio)\n\n    elif actionType == ActionType.DEFAULT_YIELD_PARAMS:\n        config: cs.UserWalletConfig = staticcall MissionControl(mc).userWalletConfig()\n        p: cs.UserWalletConfig = self.pendingUserWalletConfig[_aid]\n        config.yieldConfig = p.yieldConfig\n        extcall MissionControl(mc).setUserWalletConfig(config)\n        log DefaultYieldParamsSet(\n            defaultYieldMaxIncrease=p.yieldConfig.maxYieldIncrease,\n            defaultYieldPerformanceFee=p.yieldConfig.performanceFee,\n            defaultYieldAmbassadorBonusRatio=p.yieldConfig.ambassadorBonusRatio,\n            defaultYieldBonusRatio=p.yieldConfig.bonusRatio,\n            defaultYieldBonusAsset=p.yieldConfig.bonusAsset\n        )\n\n    elif actionType == ActionType.LOOT_PARAMS:\n        config: cs.UserWalletConfig = staticcall MissionControl(mc).userWalletConfig()\n        p: cs.UserWalletConfig = self.pendingUserWalletConfig[_aid]\n        config.depositRewardsAsset = p.depositRewardsAsset\n        config.lootClaimCoolOffPeriod = p.lootClaimCoolOffPeriod\n        extcall MissionControl(mc).setUserWalletConfig(config)\n        log LootParamsSet(depositRewardsAsset=p.depositRewardsAsset, lootClaimCoolOffPeriod=p.lootClaimCoolOffPeriod)\n\n    elif actionType == ActionType.ASSET_CONFIG:\n        p: PendingAssetConfig = self.pendingAssetConfig[_aid]\n        extcall MissionControl(mc).setAssetConfig(p.asset, p.config)\n        log AssetConfigSet(\n            asset=p.asset,\n            txFeesSwapFee=p.config.txFees.swapFee,\n            txFeesStableSwapFee=p.config.txFees.stableSwapFee,\n            txFeesRewardsFee=p.config.txFees.rewardsFee,\n            ambassadorRevShareSwapRatio=p.config.ambassadorRevShare.swapRatio,\n            ambassadorRevShareRewardsRatio=p.config.ambassadorRevShare.rewardsRatio,\n            ambassadorRevShareYieldRatio=p.config.ambassadorRevShare.yieldRatio,\n            maxYieldIncrease=p.config.yieldConfig.maxYieldIncrease,\n            performanceFee=p.config.yieldConfig.performanceFee,\n            ambassadorBonusRatio=p.config.yieldConfig.ambassadorBonusRatio,\n            bonusRatio=p.config.yieldConfig.bonusRatio,\n            bonusAsset=p.config.yieldConfig.bonusAsset,\n        )\n\n    elif actionType == ActionType.ASSET_TX_FEES:\n        p: PendingAssetTxFees = self.pendingAssetTxFees[_aid]\n        config: cs.AssetConfig = staticcall MissionControl(mc).assetConfig(p.asset)\n        config.txFees = p.txFees\n        extcall MissionControl(mc).setAssetConfig(p.asset, config)\n        log AssetTxFeesSet(\n            asset=p.asset,\n            swapFee=p.txFees.swapFee,\n            stableSwapFee=p.txFees.stableSwapFee,\n            rewardsFee=p.txFees.rewardsFee\n        )\n\n    elif actionType == ActionType.ASSET_AMBASSADOR_REV_SHARE:\n        p: PendingAssetAmbassadorRevShare = self.pendingAssetAmbassadorRevShare[_aid]\n        config: cs.AssetConfig = staticcall MissionControl(mc).assetConfig(p.asset)\n        config.ambassadorRevShare = p.ambassadorRevShare\n        extcall MissionControl(mc).setAssetConfig(p.asset, config)\n        log AssetAmbassadorRevShareSet(\n            asset=p.asset,\n            swapRatio=p.ambassadorRevShare.swapRatio,\n            rewardsRatio=p.ambassadorRevShare.rewardsRatio,\n            yieldRatio=p.ambassadorRevShare.yieldRatio\n        )\n\n    elif actionType == ActionType.ASSET_YIELD_CONFIG:\n        p: PendingAssetYieldConfig = self.pendingAssetYieldConfig[_aid]\n        config: cs.AssetConfig = staticcall MissionControl(mc).assetConfig(p.asset)\n        config.yieldConfig = p.yieldConfig\n        extcall MissionControl(mc).setAssetConfig(p.asset, config)\n        log AssetYieldConfigSet(\n            asset=p.asset,\n            maxYieldIncrease=p.yieldConfig.maxYieldIncrease,\n            performanceFee=p.yieldConfig.performanceFee,\n            ambassadorBonusRatio=p.yieldConfig.ambassadorBonusRatio,\n            bonusRatio=p.yieldConfig.bonusRatio,\n            bonusAsset=p.yieldConfig.bonusAsset\n        )\n\n    elif actionType == ActionType.IS_STABLECOIN:\n        p: IsAddrAllowed = self.pendingAddrToBool[_aid]\n        extcall MissionControl(mc).setIsStablecoin(p.addr, p.isAllowed)\n        log IsStablecoinSet(asset=p.addr, isStablecoin=p.isAllowed)\n\n    elif actionType == ActionType.STARTER_AGENT_PARAMS:\n        p: cs.AgentConfig = self.pendingAgentConfig[_aid]\n        extcall MissionControl(mc).setAgentConfig(p)\n        log StarterAgentParamsSet(startingAgent=p.startingAgent, startingAgentActivationLength=p.startingAgentActivationLength)\n\n    elif actionType == ActionType.MANAGER_CONFIG:\n        p: cs.ManagerConfig = self.pendingManagerConfig[_aid]\n        extcall MissionControl(mc).setManagerConfig(p)\n        log ManagerConfigSet(managerPeriod=p.managerPeriod, managerActivationLength=p.managerActivationLength)\n\n    elif actionType == ActionType.PAYEE_CONFIG:\n        p: cs.PayeeConfig = self.pendingPayeeConfig[_aid]\n        extcall MissionControl(mc).setPayeeConfig(p)\n        log PayeeConfigSet(payeePeriod=p.payeePeriod, payeeActivationLength=p.payeeActivationLength)\n\n    elif actionType == ActionType.CAN_PERFORM_SECURITY_ACTION:\n        data: IsAddrAllowed = self.pendingAddrToBool[_aid]\n        extcall MissionControl(mc).setCanPerformSecurityAction(data.addr, data.isAllowed)\n        log CanPerformSecurityAction(signer=data.addr, canPerform=data.isAllowed)\n\n    elif actionType == ActionType.AGENT_WRAPPER_SENDER:\n        p: PendingAgentWrapperSender = self.pendingAgentWrapperSender[_aid]\n        extcall AgentWrapper(p.agentWrapper).addSender(p.agentSender)\n        log AgentWrapperSenderAdded(agentWrapper=p.agentWrapper, agentSender=p.agentSender)\n\n    elif actionType == ActionType.RIPE_REWARDS_CONFIG:\n        p: cs.RipeRewardsConfig = self.pendingRipeRewardsConfig[_aid]\n        extcall MissionControl(mc).setRipeRewardsConfig(p)\n        log RipeRewardsConfigSet(ripeStakeRatio=p.stakeRatio, ripeLockDuration=p.lockDuration)\n\n    self.actionType[_aid] = empty(ActionType)\n    self.pendingMissionControl[_aid] = empty(address)\n    return True\n\n\n# cancel action\n\n\n@external\ndef cancelPendingAction(_aid: uint256) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    self._cancelPendingAction(_aid)\n    return True\n\n\n@internal\ndef _cancelPendingAction(_aid: uint256):\n    assert timeLock._cancelAction(_aid) # dev: cannot cancel action\n    self.actionType[_aid] = empty(ActionType)\n    self.pendingMissionControl[_aid] = empty(address)\n",
            "sha256sum": "27197294d435dc160becfa45f217b7a7b04453b8355bd7ecc20287f67eafe2ed"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/config/SwitchboardAlpha.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.3+commit.bff19ea2",
        "integrity": "30881d4349d8596d83ff6fc63c12e276cc882594133a101f2331d6b1392c7a25"
      },
      "args": "00000000000000000000000044cf3c4f000dfd76a35d03298049d37be688d6f900000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000e10000000000000000000000000000000000000000000000000000000000013c680",
      "file": "contracts/config/SwitchboardAlpha.vy"
    },
    "UndyVirtual": {
      "address": "0x26E36D3069c73d892feA8EF8140aDCDC4F7bf585",
      "abi": [
        {
          "name": "Deposit",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "owner",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assets",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "shares",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "Withdraw",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "receiver",
              "type": "address",
              "indexed": true
            },
            {
              "name": "owner",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assets",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "shares",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LeftoversSwept",
          "inputs": [
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "Transfer",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "Approval",
          "inputs": [
            {
              "name": "owner",
              "type": "address",
              "indexed": true
            },
            {
              "name": "spender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "BlacklistModified",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "isBlacklisted",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "TokenPauseModified",
          "inputs": [
            {
              "name": "isPaused",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "EarnVaultDeposit",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountDeposited",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "assetAmountAdjusted",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultTokenReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultTokenExpected",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "legoId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "signer",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "EarnVaultWithdrawal",
          "inputs": [
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultTokenBurned",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "underlyingAsset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "underlyingAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "legoId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "signer",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "EarnVaultSwap",
          "inputs": [
            {
              "name": "tokenIn",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenInAmount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "tokenOut",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenOutAmount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "swapFee",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "legoId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "signer",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "EarnVaultRewardsClaim",
          "inputs": [
            {
              "name": "rewardToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "rewardAmount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "legoId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "signer",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PerformanceFeesClaimed",
          "inputs": [
            {
              "name": "pendingFees",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "name",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "string"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "symbol",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "string"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "decimals",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint8"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "transfer",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "transferFrom",
          "inputs": [
            {
              "name": "_sender",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "approve",
          "inputs": [
            {
              "name": "_spender",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "increaseAllowance",
          "inputs": [
            {
              "name": "_spender",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "decreaseAllowance",
          "inputs": [
            {
              "name": "_spender",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "burn",
          "inputs": [
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "DOMAIN_SEPARATOR",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bytes32"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "permit",
          "inputs": [
            {
              "name": "_owner",
              "type": "address"
            },
            {
              "name": "_spender",
              "type": "address"
            },
            {
              "name": "_value",
              "type": "uint256"
            },
            {
              "name": "_deadline",
              "type": "uint256"
            },
            {
              "name": "_signature",
              "type": "bytes"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setBlacklist",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            },
            {
              "name": "_shouldBlacklist",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "burnBlacklistTokens",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "burnBlacklistTokens",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pause",
          "inputs": [
            {
              "name": "_shouldPause",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "undyHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "blacklisted",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isPaused",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "balanceOf",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "allowance",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalSupply",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "TOKEN_NAME",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "string"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "TOKEN_SYMBOL",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "string"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "TOKEN_DECIMALS",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint8"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "VERSION",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "string"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "nonces",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositForYield",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositForYield",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositForYield",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositForYield",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawFromYield",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawFromYield",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawFromYield",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawFromYield",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_isSpecialTx",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_instructions",
              "type": "tuple[]",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "minAmountOut",
                  "type": "uint256"
                },
                {
                  "name": "tokenPath",
                  "type": "address[]"
                },
                {
                  "name": "poolPath",
                  "type": "address[]"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimIncentives",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimIncentives",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimIncentives",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimIncentives",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_proofs",
              "type": "bytes32[]"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimPerformanceFees",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getClaimablePerformanceFees",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "updateYieldPosition",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addManager",
          "inputs": [
            {
              "name": "_manager",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeManager",
          "inputs": [
            {
              "name": "_manager",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "lastUnderlyingBal",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingYieldRealized",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "vaultToLegoId",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assets",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "managers",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfManager",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numManagers",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "asset",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getTotalAssets",
          "inputs": [
            {
              "name": "_shouldGetMax",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "maxDeposit",
          "inputs": [
            {
              "name": "_receiver",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "previewDeposit",
          "inputs": [
            {
              "name": "_assets",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "deposit",
          "inputs": [
            {
              "name": "_assets",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "deposit",
          "inputs": [
            {
              "name": "_assets",
              "type": "uint256"
            },
            {
              "name": "_receiver",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositWithMinAmountOut",
          "inputs": [
            {
              "name": "_assets",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositWithMinAmountOut",
          "inputs": [
            {
              "name": "_assets",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_receiver",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "maxMint",
          "inputs": [
            {
              "name": "_receiver",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "previewMint",
          "inputs": [
            {
              "name": "_shares",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mint",
          "inputs": [
            {
              "name": "_shares",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mint",
          "inputs": [
            {
              "name": "_shares",
              "type": "uint256"
            },
            {
              "name": "_receiver",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "maxWithdraw",
          "inputs": [
            {
              "name": "_owner",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "previewWithdraw",
          "inputs": [
            {
              "name": "_assets",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdraw",
          "inputs": [
            {
              "name": "_assets",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdraw",
          "inputs": [
            {
              "name": "_assets",
              "type": "uint256"
            },
            {
              "name": "_receiver",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdraw",
          "inputs": [
            {
              "name": "_assets",
              "type": "uint256"
            },
            {
              "name": "_receiver",
              "type": "address"
            },
            {
              "name": "_owner",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "maxRedeem",
          "inputs": [
            {
              "name": "_owner",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "previewRedeem",
          "inputs": [
            {
              "name": "_shares",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "redeem",
          "inputs": [
            {
              "name": "_shares",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "redeem",
          "inputs": [
            {
              "name": "_shares",
              "type": "uint256"
            },
            {
              "name": "_receiver",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "redeem",
          "inputs": [
            {
              "name": "_shares",
              "type": "uint256"
            },
            {
              "name": "_receiver",
              "type": "address"
            },
            {
              "name": "_owner",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "redeemWithMinAmountOut",
          "inputs": [
            {
              "name": "_shares",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "redeemWithMinAmountOut",
          "inputs": [
            {
              "name": "_shares",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_receiver",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "redeemWithMinAmountOut",
          "inputs": [
            {
              "name": "_shares",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_receiver",
              "type": "address"
            },
            {
              "name": "_owner",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "convertToShares",
          "inputs": [
            {
              "name": "_assets",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "convertToSharesSafe",
          "inputs": [
            {
              "name": "_assets",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "convertToAssets",
          "inputs": [
            {
              "name": "_shares",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "convertToAssetsSafe",
          "inputs": [
            {
              "name": "_shares",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "sweepLeftovers",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_tokenName",
              "type": "string"
            },
            {
              "name": "_tokenSymbol",
              "type": "string"
            },
            {
              "name": "_undyHq",
              "type": "address"
            },
            {
              "name": "_minHqTimeLock",
              "type": "uint256"
            },
            {
              "name": "_maxHqTimeLock",
              "type": "uint256"
            },
            {
              "name": "_startingAgent",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/vaults/modules/VaultErc20Token.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nimplements: IERC20\nfrom ethereum.ercs import IERC20\n\ninterface UndyHq:\n    def canSetTokenBlacklist(_addr: address) -> bool: view\n    def canMintUndy(_addr: address) -> bool: view\n    def hasPendingGovChange() -> bool: view\n    def governance() -> address: view\n\ninterface ERC1271:\n    def isValidSignature(_hash: bytes32, _signature: Bytes[65]) -> bytes4: view\n\n# erc20\n\nevent Transfer:\n    sender: indexed(address)\n    recipient: indexed(address)\n    amount: uint256\n\nevent Approval:\n    owner: indexed(address)\n    spender: indexed(address)\n    amount: uint256\n\n# undy \n\nevent BlacklistModified:\n    addr: indexed(address)\n    isBlacklisted: bool\n\nevent TokenPauseModified:\n    isPaused: bool\n\n# undy hq\nundyHq: public(address)\n\n# config\nblacklisted: public(HashMap[address, bool])\nisPaused: public(bool)\n\n# erc20\nbalanceOf: public(HashMap[address, uint256])\nallowance: public(HashMap[address, HashMap[address, uint256]])\ntotalSupply: public(uint256)\n\n# token info\nTOKEN_NAME: public(immutable(String[64]))\nTOKEN_SYMBOL: public(immutable(String[32]))\nTOKEN_DECIMALS: public(immutable(uint8))\nVERSION: public(constant(String[8])) = \"v1.0.0\"\n\n# eip-712\nnonces: public(HashMap[address, uint256])\nEIP712_TYPEHASH: constant(bytes32) = keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\")\nEIP2612_TYPEHASH: constant(bytes32) = keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\")\nECRECOVER_PRECOMPILE: constant(address) = 0x0000000000000000000000000000000000000001\nERC1271_MAGIC_VAL: constant(bytes4) = 0x1626ba7e\n\nCACHED_DOMAIN_SEPARATOR: immutable(bytes32)\nNAME_HASH: immutable(bytes32)\nVERSION_HASH: constant(bytes32) = keccak256(VERSION)\nCACHED_CHAIN_ID: immutable(uint256)\n\n\n@deploy\ndef __init__(\n    _tokenName: String[64],\n    _tokenSymbol: String[32],\n    _tokenDecimals: uint8,\n    _undyHq: address,\n):\n    # token info\n    TOKEN_NAME = _tokenName\n    TOKEN_SYMBOL = _tokenSymbol\n    TOKEN_DECIMALS = _tokenDecimals\n\n    # set undy hq\n    assert _undyHq != empty(address) # dev: invalid undy hq\n    self.undyHq = _undyHq\n\n    # domain separator\n    NAME_HASH = keccak256(_tokenName)\n    CACHED_CHAIN_ID = chain.id\n    CACHED_DOMAIN_SEPARATOR = keccak256(\n        abi_encode(\n            EIP712_TYPEHASH,\n            NAME_HASH,\n            VERSION_HASH,\n            CACHED_CHAIN_ID,\n            self,\n        )\n    )\n\n\n##############\n# Token Info #\n##############\n\n\n@view\n@external\ndef name() -> String[64]:\n    return TOKEN_NAME\n\n\n@view\n@external\ndef symbol() -> String[32]:\n    return TOKEN_SYMBOL\n\n\n@view\n@external\ndef decimals() -> uint8:\n    return TOKEN_DECIMALS\n\n\n#############\n# Transfers #\n#############\n\n\n@external\ndef transfer(_recipient: address, _amount: uint256) -> bool:\n    self._transfer(msg.sender, _recipient, _amount)\n    return True\n\n\n@external\ndef transferFrom(_sender: address, _recipient: address, _amount: uint256) -> bool:\n    assert not self.blacklisted[msg.sender] # dev: spender blacklisted\n    self._spendAllowance(_sender, msg.sender, _amount)\n    self._transfer(_sender, _recipient, _amount)\n    return True\n\n\n@internal\ndef _transfer(_sender: address, _recipient: address, _amount: uint256):\n    assert not self.isPaused # dev: token paused\n    assert _amount != 0 # dev: cannot transfer 0 amount\n    assert _recipient not in [self, empty(address)] # dev: invalid recipient\n\n    assert not self.blacklisted[_sender] # dev: sender blacklisted\n    assert not self.blacklisted[_recipient] # dev: recipient blacklisted\n\n    senderBalance: uint256 = self.balanceOf[_sender]\n    assert senderBalance >= _amount # dev: insufficient funds\n    self.balanceOf[_sender] = senderBalance - _amount\n    self.balanceOf[_recipient] += _amount\n\n    log Transfer(sender=_sender, recipient=_recipient, amount=_amount)\n\n\n#############\n# Allowance #\n#############\n\n\n# approvals\n\n\n@external\ndef approve(_spender: address, _amount: uint256) -> bool:\n    self._validateNewApprovals(msg.sender, _spender)\n    self._approve(msg.sender, _spender, _amount)\n    return True\n\n\n@internal\ndef _approve(_owner: address, _spender: address, _amount: uint256):\n    self.allowance[_owner][_spender] = _amount\n    log Approval(owner=_owner, spender=_spender, amount=_amount)\n\n\n@internal\ndef _spendAllowance(_owner: address, _spender: address, _amount: uint256):\n    currentAllowance: uint256 = self.allowance[_owner][_spender]\n    if currentAllowance != max_value(uint256):\n        assert currentAllowance >= _amount # dev: insufficient allowance\n        self._approve(_owner, _spender, currentAllowance - _amount)\n\n\n# increase / decrease allowance\n\n\n@external\ndef increaseAllowance(_spender: address, _amount: uint256) -> bool:\n    self._validateNewApprovals(msg.sender, _spender)\n    currentAllowance: uint256 = self.allowance[msg.sender][_spender]\n    maxIncrease: uint256 = max_value(uint256) - currentAllowance\n    newAllowance: uint256 = currentAllowance + min(_amount, maxIncrease)\n    if newAllowance != currentAllowance:\n        self._approve(msg.sender, _spender, newAllowance)\n    return True\n\n\n@external\ndef decreaseAllowance(_spender: address, _amount: uint256) -> bool:\n    self._validateNewApprovals(msg.sender, _spender)\n    currentAllowance: uint256 = self.allowance[msg.sender][_spender]\n    newAllowance: uint256 = currentAllowance - min(_amount, currentAllowance)\n    if newAllowance != currentAllowance:\n        self._approve(msg.sender, _spender, newAllowance)\n    return True\n\n\n# validation\n\n\n@view\n@internal\ndef _validateNewApprovals(_owner: address, _spender: address):\n    assert not self.isPaused # dev: token paused\n    assert not self.blacklisted[_owner] # dev: owner blacklisted\n    assert not self.blacklisted[_spender] # dev: spender blacklisted\n    assert _spender != empty(address) # dev: invalid spender\n\n\n#####################\n# Minting / Burning #\n#####################\n\n\n# mint tokens\n\n\n@internal\ndef _mint(_recipient: address, _amount: uint256) -> bool:\n    assert _recipient not in [self, empty(address)] # dev: invalid recipient\n    assert not self.blacklisted[_recipient] # dev: blacklisted\n    assert not self.isPaused # dev: token paused\n\n    self.balanceOf[_recipient] += _amount\n    self.totalSupply += _amount\n    log Transfer(sender=empty(address), recipient=_recipient, amount=_amount)\n    return True\n\n\n# burn tokens\n\n\n@external\ndef burn(_amount: uint256) -> bool:\n    assert not self.isPaused # dev: token paused\n    self._burn(msg.sender, _amount)\n    return True\n\n\n@internal\ndef _burn(_owner: address, _amount: uint256):\n    self.balanceOf[_owner] -= _amount\n    self.totalSupply -= _amount\n    log Transfer(sender=_owner, recipient=empty(address), amount=_amount)\n\n\n###########\n# EIP 712 #\n###########\n\n\n@view\n@external\ndef DOMAIN_SEPARATOR() -> bytes32:\n    return self._domainSeparator()\n\n\n@view\n@internal\ndef _domainSeparator() -> bytes32:\n    if chain.id != CACHED_CHAIN_ID:\n        return keccak256(\n            abi_encode(\n                EIP712_TYPEHASH,\n                NAME_HASH,\n                VERSION_HASH,\n                chain.id,\n                self,\n            )\n        )\n    return CACHED_DOMAIN_SEPARATOR\n\n\n@external\ndef permit(\n    _owner: address,\n    _spender: address,\n    _value: uint256,\n    _deadline: uint256,\n    _signature: Bytes[65],\n) -> bool:\n    self._validateNewApprovals(_owner, _spender)\n    assert _owner != empty(address) and block.timestamp <= _deadline # dev: permit expired\n\n    nonce: uint256 = self.nonces[_owner]\n    digest: bytes32 = keccak256(\n        concat(\n            b\"\\x19\\x01\",\n            self._domainSeparator(),\n            keccak256(abi_encode(EIP2612_TYPEHASH, _owner, _spender, _value, nonce, _deadline)),\n        )\n    )\n\n    if _owner.is_contract:\n        assert staticcall ERC1271(_owner).isValidSignature(digest, _signature) == ERC1271_MAGIC_VAL # dev: invalid signature\n\n    else:\n        r: bytes32 = convert(slice(_signature, 0, 32), bytes32)\n        s: bytes32 = convert(slice(_signature, 32, 32), bytes32)\n        v: uint8 = convert(slice(_signature, 64, 1), uint8)\n\n        # validate v parameter (27 or 28)\n        if v < 27:\n            v = v + 27\n        assert v == 27 or v == 28 # dev: invalid v parameter\n\n        # prevent signature malleability by ensuring s is in lower half of curve order\n        s_uint: uint256 = convert(s, uint256)\n        assert s_uint != 0 # dev: invalid s value (zero)\n        assert s_uint <= convert(0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, uint256) # dev: invalid s value\n\n        response: Bytes[32] = raw_call(\n            ECRECOVER_PRECOMPILE,\n            abi_encode(digest, v, r, s),\n            max_outsize = 32,\n            is_static_call = True # a view function\n        )\n        assert len(response) == 32  # dev: invalid ecrecover response length\n        assert abi_decode(response, address) == _owner  # dev: invalid signature\n\n    self.nonces[_owner] = nonce + 1\n    self._approve(_owner, _spender, _value)\n    return True\n\n\n#############\n# Blacklist #\n#############\n\n\n@external\ndef setBlacklist(_addr: address, _shouldBlacklist: bool) -> bool:\n    assert staticcall UndyHq(self.undyHq).canSetTokenBlacklist(msg.sender) # dev: no perms\n\n    assert _addr not in [self, empty(address)] # dev: invalid blacklist recipient\n    self.blacklisted[_addr] = _shouldBlacklist\n    log BlacklistModified(addr=_addr, isBlacklisted=_shouldBlacklist)\n    return True\n\n\n@external\ndef burnBlacklistTokens(_addr: address, _amount: uint256 = max_value(uint256)) -> bool:\n    assert msg.sender == staticcall UndyHq(self.undyHq).governance() # dev: no perms\n    assert self.blacklisted[_addr] # dev: not blacklisted\n\n    amount: uint256 = min(_amount, self.balanceOf[_addr])\n    assert amount != 0 # dev: cannot burn 0 tokens\n    self._burn(_addr, amount)\n    return True\n\n\n#########\n# Pause #\n#########\n\n\n@external\ndef pause(_shouldPause: bool):\n    assert msg.sender == staticcall UndyHq(self.undyHq).governance() # dev: no perms\n    assert _shouldPause != self.isPaused # dev: no change\n    self.isPaused = _shouldPause\n    log TokenPauseModified(isPaused=_shouldPause)\n",
            "sha256sum": "c01f0100f9d040bbd95c91f201e0623bd0331c6982e5ef73e832a37bb27eee08"
          },
          "interfaces/Wallet.vyi": {
            "content": "# @version 0.4.3\n\nstruct SwapInstruction:\n    legoId: uint256\n    amountIn: uint256\n    minAmountOut: uint256\n    tokenPath: DynArray[address, MAX_TOKEN_PATH]\n    poolPath: DynArray[address, MAX_TOKEN_PATH - 1]\n\nMAX_SWAP_INSTRUCTIONS: constant(uint256) = 5\nMAX_TOKEN_PATH: constant(uint256) = 5\nMAX_PROOFS: constant(uint256) = 25\n\n\n@view\n@external\ndef onERC721Received(_operator: address, _owner: address, _tokenId: uint256, _data: Bytes[1024]) -> bytes4:\n    ...\n\n\n@pure\n@external\ndef apiVersion() -> String[28]:\n    ...\n\n\n##################\n# Transfer Funds #\n##################\n\n\n@external\ndef transferFunds(\n    _recipient: address,\n    _asset: address = empty(address),\n    _amount: uint256 = max_value(uint256),\n    _isCheque: bool = False,\n    _isSpecialTx: bool = False,\n) -> (uint256, uint256):\n    ...\n\n\n#########\n# Yield #\n#########\n\n\n# deposit\n\n\n@external\ndef depositForYield(\n    _legoId: uint256,\n    _asset: address,\n    _vaultAddr: address = empty(address),\n    _amount: uint256 = max_value(uint256),\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, address, uint256, uint256):\n    ...\n\n\n# withdraw\n\n\n@external\ndef withdrawFromYield(\n    _legoId: uint256,\n    _vaultToken: address,\n    _amount: uint256 = max_value(uint256),\n    _extraData: bytes32 = empty(bytes32),\n    _isSpecialTx: bool = False,\n) -> (uint256, address, uint256, uint256):\n    ...\n\n\n# rebalance position\n\n\n@external\ndef rebalanceYieldPosition(\n    _fromLegoId: uint256,\n    _fromVaultToken: address,\n    _toLegoId: uint256,\n    _toVaultAddr: address = empty(address),\n    _fromVaultAmount: uint256 = max_value(uint256),\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, address, uint256, uint256):\n    ...\n\n\n###################\n# Swap / Exchange #\n###################\n\n\n@external\ndef swapTokens(_instructions: DynArray[SwapInstruction, MAX_SWAP_INSTRUCTIONS]) -> (address, uint256, address, uint256, uint256):\n    ...\n\n\n# mint / redeem\n\n\n@external\ndef mintOrRedeemAsset(\n    _legoId: uint256,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256 = max_value(uint256),\n    _minAmountOut: uint256 = 0,\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, uint256, bool, uint256):\n    ...\n\n\n@external\ndef confirmMintOrRedeemAsset(\n    _legoId: uint256,\n    _tokenIn: address,\n    _tokenOut: address,\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, uint256):\n    ...\n\n\n###################\n# Debt Management #\n###################\n\n\n# add collateral\n\n\n@external\ndef addCollateral(\n    _legoId: uint256,\n    _asset: address,\n    _amount: uint256 = max_value(uint256),\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, uint256):\n    ...\n\n\n# remove collateral\n\n\n@external\ndef removeCollateral(\n    _legoId: uint256,\n    _asset: address,\n    _amount: uint256 = max_value(uint256),\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, uint256):\n    ...\n\n\n# borrow\n\n\n@external\ndef borrow(\n    _legoId: uint256,\n    _borrowAsset: address,\n    _amount: uint256 = max_value(uint256),\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, uint256):\n    ...\n\n\n# repay debt\n\n\n@external\ndef repayDebt(\n    _legoId: uint256,\n    _paymentAsset: address,\n    _paymentAmount: uint256 = max_value(uint256),\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, uint256):\n    ...\n\n\n#################\n# Claim Rewards #\n#################\n\n\n@external\ndef claimIncentives(\n    _legoId: uint256,\n    _rewardToken: address = empty(address),\n    _rewardAmount: uint256 = max_value(uint256),\n    _proofs: DynArray[bytes32, MAX_PROOFS] = [],\n) -> (uint256, uint256):\n    ...\n\n\n################\n# Wrapped ETH #\n################\n\n\n# eth -> weth\n\n\n@payable\n@external\ndef convertEthToWeth(_amount: uint256 = max_value(uint256)) -> (uint256, uint256):\n    ...\n\n\n# weth -> eth\n\n\n@external\ndef convertWethToEth(_amount: uint256 = max_value(uint256)) -> (uint256, uint256):\n    ...\n\n\n#################\n# Add Liquidity #\n#################\n\n\n# add / remove liquidity (simple)\n\n\n@external\ndef addLiquidity(\n    _legoId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _amountA: uint256 = max_value(uint256),\n    _amountB: uint256 = max_value(uint256),\n    _minAmountA: uint256 = 0,\n    _minAmountB: uint256 = 0,\n    _minLpAmount: uint256 = 0,\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, uint256, uint256, uint256):\n    ...\n\n\n@external\ndef removeLiquidity(\n    _legoId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpToken: address,\n    _lpAmount: uint256 = max_value(uint256),\n    _minAmountA: uint256 = 0,\n    _minAmountB: uint256 = 0,\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, uint256, uint256, uint256):\n    ...\n\n\n# add / remove liquidity (concentrated)\n\n\n@external\ndef addLiquidityConcentrated(\n    _legoId: uint256,\n    _nftAddr: address,\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _amountA: uint256 = max_value(uint256),\n    _amountB: uint256 = max_value(uint256),\n    _tickLower: int24 = min_value(int24),\n    _tickUpper: int24 = max_value(int24),\n    _minAmountA: uint256 = 0,\n    _minAmountB: uint256 = 0,\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, uint256, uint256, uint256, uint256):\n    ...\n\n\n@external\ndef removeLiquidityConcentrated(\n    _legoId: uint256,\n    _nftAddr: address,\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _liqToRemove: uint256 = max_value(uint256),\n    _minAmountA: uint256 = 0,\n    _minAmountB: uint256 = 0,\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, uint256, uint256, uint256):\n    ...\n\n\n#############\n# Utilities #\n#############\n\n\n# recover nft\n\n\n@external\ndef recoverNft(_collection: address, _nftTokenId: uint256, _recipient: address):\n    ...\n",
            "sha256sum": "5fd15f8da6c599f20c3c5a765632b224190eede7c05057d45df54563b94cd15c"
          },
          "interfaces/WalletStructs.vyi": {
            "content": "# @version 0.4.3\n\nflag ActionType:\n    TRANSFER\n    EARN_DEPOSIT\n    EARN_WITHDRAW\n    EARN_REBALANCE\n    SWAP\n    MINT_REDEEM\n    CONFIRM_MINT_REDEEM\n    ADD_COLLATERAL\n    REMOVE_COLLATERAL\n    BORROW\n    REPAY_DEBT\n    REWARDS\n    ETH_TO_WETH\n    WETH_TO_ETH\n    ADD_LIQ\n    REMOVE_LIQ\n    ADD_LIQ_CONC\n    REMOVE_LIQ_CONC\n    PAY_CHEQUE\n\nstruct WalletAssetData:\n    assetBalance: uint256\n    usdValue: uint256\n    isYieldAsset: bool\n    lastPricePerShare: uint256\n\nstruct ActionData:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    billing: address\n    vaultRegistry: address\n    wallet: address\n    walletConfig: address\n    walletOwner: address\n    inEjectMode: bool\n    isFrozen: bool\n    lastTotalUsdValue: uint256\n    signer: address\n    isManager: bool\n    legoId: uint256\n    legoAddr: address\n    eth: address\n    weth: address\n\nstruct MiniAddys:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    appraiser: address",
            "sha256sum": "466493c129135c95470aaf70eeddc936632f7b0f813396e5a7ddc03bea9da518"
          },
          "interfaces/LegoPartner.vyi": {
            "content": "# @version 0.4.3\n\nfrom interfaces import WalletStructs as ws\n\nMAX_TOKEN_PATH: constant(uint256) = 5\nMAX_RECOVER_ASSETS: constant(uint256) = 20\nMAX_PROOFS: constant(uint256) = 25\n\n@external\ndef addLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _tickLower: int24, _tickUpper: int24, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef addLiquidity(_pool: address, _tokenA: address, _tokenB: address, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _minLpAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (address, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef removeLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _liqToRemove: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef removeLiquidity(_pool: address, _tokenA: address, _tokenB: address, _lpToken: address, _lpAmount: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef mintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _tokenInAmount: uint256, _minAmountOut: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef swapTokens(_amountIn: uint256, _minAmountOut: uint256, _tokenPath: DynArray[address, MAX_TOKEN_PATH], _poolPath: DynArray[address, MAX_TOKEN_PATH - 1], _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256):\n    ...\n\n@external\ndef depositForYield(_asset: address, _amount: uint256, _vaultAddr: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef withdrawFromYield(_vaultToken: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef confirmMintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef borrow(_borrowAsset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef repayDebt(_paymentAsset: address, _paymentAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef claimIncentives(_user: address, _rewardToken: address, _rewardAmount: uint256, _proofs: DynArray[bytes32, MAX_PROOFS], _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef removeCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef addCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@view\n@external\ndef getAccessForLego(_user: address, _action: ws.ActionType) -> (address, String[64], uint256):\n    ...\n\n@view\n@external\ndef hasCapability(_action: ws.ActionType) -> bool:\n    ...\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    ...\n\n@view\n@external\ndef isYieldLego() -> bool:\n    ...\n\n@view\n@external\ndef isDexLego() -> bool:\n    ...\n\n\n# common\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "f2afb7bd72d4301aea77bbe4177b7ae954ba6f6b76af363965993eb92ad0b715"
          },
          "contracts/vaults/modules/EarnVaultWallet.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nfrom interfaces import Wallet as wi\nfrom interfaces import LegoPartner as Lego\nfrom interfaces import WalletStructs as ws\n\nfrom ethereum.ercs import IERC20\n\ninterface VaultRegistry:\n    def getVaultActionDataWithFrozenStatus(_legoId: uint256, _signer: address, _vaultAddr: address) -> (VaultActionData, bool): view\n    def getVaultActionDataBundle(_legoId: uint256, _signer: address) -> VaultActionData: view\n    def checkVaultApprovals(_vaultAddr: address, _vaultToken: address) -> bool: view\n    def getLegoDataFromVaultToken(_vaultToken: address) -> (uint256, address): view\n    def redemptionConfig(_vaultAddr: address) -> (uint256, uint256): view\n    def getPerformanceFee(_vaultAddr: address) -> uint256: view\n\ninterface YieldLego:\n    def getUnderlyingBalances(_vaultToken: address, _vaultTokenBalance: uint256) -> (uint256, uint256): view\n    def getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256: view\n    def getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256: view\n    def getWithdrawalFees(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256: view\n\ninterface Switchboard:\n    def isSwitchboardAddr(_addr: address) -> bool: view\n\ninterface MissionControl:\n    def isLockedSigner(_signer: address) -> bool: view\n\ninterface Registry:\n    def getAddr(_regId: uint256) -> address: view\n\ninterface UndyHq:\n    def governance() -> address: view\n\nstruct VaultActionData:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    appraiser: address\n    vaultRegistry: address\n    vaultAsset: address\n    signer: address\n    legoId: uint256\n    legoAddr: address\n\nevent EarnVaultDeposit:\n    asset: indexed(address)\n    assetAmountDeposited: uint256\n    assetAmountAdjusted: uint256\n    vaultToken: indexed(address)\n    vaultTokenReceived: uint256\n    vaultTokenExpected: uint256\n    usdValue: uint256\n    legoId: uint256\n    signer: indexed(address)\n\nevent EarnVaultWithdrawal:\n    vaultToken: indexed(address)\n    vaultTokenBurned: uint256\n    underlyingAsset: indexed(address)\n    underlyingAmountReceived: uint256\n    usdValue: uint256\n    legoId: uint256\n    signer: indexed(address)\n\nevent EarnVaultSwap:\n    tokenIn: indexed(address)\n    tokenInAmount: uint256\n    tokenOut: indexed(address)\n    tokenOutAmount: uint256\n    usdValue: uint256\n    swapFee: uint256\n    legoId: uint256\n    signer: indexed(address)\n\nevent EarnVaultRewardsClaim:\n    rewardToken: indexed(address)\n    rewardAmount: uint256\n    usdValue: uint256\n    legoId: uint256\n    signer: indexed(address)\n\nevent PerformanceFeesClaimed:\n    pendingFees: uint256\n\n# yield tracking\nlastUnderlyingBal: public(uint256)\npendingYieldRealized: public(uint256)\n\n# asset data\nvaultToLegoId: public(HashMap[address, uint256]) # vault addr -> lego id\nassets: public(HashMap[uint256, address]) # index -> asset\nindexOfAsset: public(HashMap[address, uint256]) # asset -> index\nnumAssets: public(uint256) # num assets\n\n# managers\nmanagers: public(HashMap[uint256, address]) # index -> manager\nindexOfManager: public(HashMap[address, uint256]) # manager -> index\nnumManagers: public(uint256) # num managers\n\n# transient data\nnumDeregVaultTokens: transient(uint256) # num vault tokens\nderegVaultTokens: transient(HashMap[uint256, address]) # index -> vault token\nderegVaultTokenToId: transient(HashMap[address, uint256]) # vault token -> index\nnumFeeVaultTokens: transient(uint256) # num vault tokens\nfeeVaultTokens: transient(HashMap[uint256, address]) # index -> vault token\nfeeVaultTokenToId: transient(HashMap[address, uint256]) # vault token -> index\n\n# constants\nHUNDRED_PERCENT: constant(uint256) = 100_00 # 100.00%\nMAX_SWAP_INSTRUCTIONS: constant(uint256) = 5\nMAX_TOKEN_PATH: constant(uint256) = 5\nMAX_LEGOS: constant(uint256) = 10\nMAX_PROOFS: constant(uint256) = 25\n\n# registry ids\nLEGO_BOOK_ID: constant(uint256) = 3\nSWITCHBOARD_ID: constant(uint256) = 4\nVAULT_REGISTRY_ID: constant(uint256) = 10\n\nUNDY_HQ: immutable(address)\nVAULT_ASSET: immutable(address)\n\n\n@deploy\ndef __init__(\n    _undyHq: address,\n    _vaultAsset: address,\n    _startingAgent: address,\n):\n    # not using 0 index\n    self.numManagers = 1\n    self.numAssets = 1\n\n    assert empty(address) not in [_undyHq, _vaultAsset] # dev: inv addr\n    UNDY_HQ = _undyHq\n    VAULT_ASSET = _vaultAsset\n\n    # initial agent\n    if _startingAgent != empty(address):\n        self._registerManager(_startingAgent)\n\n\n#########\n# Yield #\n#########\n\n\n# deposit\n\n\n@external\ndef depositForYield(\n    _legoId: uint256,\n    _asset: address,\n    _vaultAddr: address = empty(address),\n    _amount: uint256 = max_value(uint256),\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, address, uint256, uint256):\n    ad: VaultActionData = self._canManagerPerformAction(msg.sender, [_legoId])\n    assetAmount: uint256 = 0\n    na: uint256 = 0\n    vaultToken: address = empty(address)\n    vaultTokenAmountReceived: uint256 = 0\n    txUsdValue: uint256 = 0\n    assetAmount, na, vaultToken, vaultTokenAmountReceived, txUsdValue = self._depositForYield(_asset, _vaultAddr, _amount, _extraData, self._getUnderlyingAndUpdatePendingYield(), True, ad)\n    return assetAmount, vaultToken, vaultTokenAmountReceived, txUsdValue\n\n\n@internal\ndef _onReceiveVaultFunds(\n    _vaultAddr: address,\n    _depositor: address,\n    _vaultRegistry: address,\n) -> uint256:\n    legoId: uint256 = self.vaultToLegoId[_vaultAddr]\n    ad: VaultActionData = staticcall VaultRegistry(_vaultRegistry).getVaultActionDataBundle(legoId, _depositor)\n    if ad.legoId == 0 or ad.legoAddr == empty(address):\n        return 0\n    ad.vaultAsset = VAULT_ASSET\n    return self._depositForYield(ad.vaultAsset, _vaultAddr, max_value(uint256), empty(bytes32), 0, False, ad)[1]\n\n\n@internal\ndef _depositForYield(\n    _asset: address,\n    _vaultAddr: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _currentUnderlying: uint256,\n    _shouldSaveUnderlying: bool,\n    _ad: VaultActionData,\n) -> (uint256, uint256, address, uint256, uint256):\n    amount: uint256 = self._getAmountAndApprove(_asset, _amount, _ad.legoAddr) # doing approval here\n    currentUnderlying: uint256 = _currentUnderlying\n\n    # no re-depositing / re-staking\n    assert self.vaultToLegoId[_asset] == 0 # dev: cannot re-deposit vault tokens\n\n    # expected vault token amount\n    expectedVaultTokenAmount: uint256 = staticcall YieldLego(_ad.legoAddr).getVaultTokenAmount(_asset, amount, _vaultAddr)\n\n    # deposit for yield\n    assetAmount: uint256 = 0\n    vaultToken: address = empty(address)\n    vaultTokenAmountReceived: uint256 = 0\n    txUsdValue: uint256 = 0\n    assetAmount, vaultToken, vaultTokenAmountReceived, txUsdValue = extcall Lego(_ad.legoAddr).depositForYield(_asset, amount, _vaultAddr, _extraData, self, self._packMiniAddys(_ad.ledger, _ad.missionControl, _ad.legoBook, _ad.appraiser))\n    assert _vaultAddr == vaultToken # dev: vault token mismatch\n    assert extcall IERC20(_asset).approve(_ad.legoAddr, 0, default_return_value = True) # dev: appr\n\n    # this accounts for withdrawal fees -- therefore using this when tracking `lastUnderlyingBal`\n    assetAmountAdjusted: uint256 = staticcall YieldLego(_ad.legoAddr).getUnderlyingAmount(_vaultAddr, vaultTokenAmountReceived)\n\n    # update yield position\n    if _asset == _ad.vaultAsset:\n        assert staticcall VaultRegistry(_ad.vaultRegistry).checkVaultApprovals(self, vaultToken) # dev: lego or vault token not approved\n        self._updateYieldPosition(vaultToken, _ad.legoId)\n        currentUnderlying += min(assetAmountAdjusted, assetAmount)\n\n    # save underlying balance\n    if _shouldSaveUnderlying:\n        self.lastUnderlyingBal = currentUnderlying\n\n    log EarnVaultDeposit(\n        asset = _asset,\n        assetAmountDeposited = assetAmount,\n        assetAmountAdjusted = assetAmountAdjusted,\n        vaultToken = vaultToken,\n        vaultTokenReceived = vaultTokenAmountReceived,\n        vaultTokenExpected = expectedVaultTokenAmount,\n        usdValue = txUsdValue,\n        legoId = _ad.legoId,\n        signer = _ad.signer,\n    )\n    return assetAmount, assetAmountAdjusted, vaultToken, vaultTokenAmountReceived, txUsdValue\n\n\n# withdraw\n\n\n@external\ndef withdrawFromYield(\n    _legoId: uint256,\n    _vaultToken: address,\n    _amount: uint256 = max_value(uint256),\n    _extraData: bytes32 = empty(bytes32),\n    _isSpecialTx: bool = False,\n) -> (uint256, address, uint256, uint256):\n    ad: VaultActionData = self._canManagerPerformAction(msg.sender, [_legoId])\n    return self._withdrawFromYield(_vaultToken, _amount, _extraData, self._getUnderlyingAndUpdatePendingYield(), True, ad)\n\n\n@internal\ndef _withdrawFromYield(\n    _vaultToken: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _currentUnderlying: uint256,\n    _shouldSaveUnderlying: bool,\n    _ad: VaultActionData,\n) -> (uint256, address, uint256, uint256):\n    assert _vaultToken != empty(address) # dev: invalid vault token\n    vaultTokenAmount: uint256 = self._getAmountAndApprove(_vaultToken, _amount, empty(address)) # not approving here\n    currentUnderlying: uint256 = _currentUnderlying\n\n    # some vault tokens require max value approval (comp v3)\n    assert extcall IERC20(_vaultToken).approve(_ad.legoAddr, max_value(uint256), default_return_value = True) # dev: appr\n\n    # withdraw from yield\n    vaultTokenAmountBurned: uint256 = 0\n    underlyingAsset: address = empty(address)\n    underlyingAmount: uint256 = 0\n    txUsdValue: uint256 = 0\n    vaultTokenAmountBurned, underlyingAsset, underlyingAmount, txUsdValue = extcall Lego(_ad.legoAddr).withdrawFromYield(_vaultToken, vaultTokenAmount, _extraData, self, self._packMiniAddys(_ad.ledger, _ad.missionControl, _ad.legoBook, _ad.appraiser))\n    assert extcall IERC20(_vaultToken).approve(_ad.legoAddr, 0, default_return_value = True) # dev: appr\n\n    # update yield position\n    if underlyingAsset == _ad.vaultAsset:\n        self._updateYieldPosition(_vaultToken, _ad.legoId)\n        currentUnderlying -= min(currentUnderlying, underlyingAmount)\n\n    if _shouldSaveUnderlying:\n        self.lastUnderlyingBal = currentUnderlying\n\n    log EarnVaultWithdrawal(\n        vaultToken = _vaultToken,\n        vaultTokenBurned = vaultTokenAmountBurned,\n        underlyingAsset = underlyingAsset,\n        underlyingAmountReceived = underlyingAmount,\n        usdValue = txUsdValue,\n        legoId = _ad.legoId,\n        signer = _ad.signer\n    )\n    return vaultTokenAmountBurned, underlyingAsset, underlyingAmount, txUsdValue\n\n\n###################\n# Swap / Exchange #\n###################\n\n\n@external\ndef swapTokens(_instructions: DynArray[wi.SwapInstruction, MAX_SWAP_INSTRUCTIONS]) -> (address, uint256, address, uint256, uint256):\n    tokenIn: address = empty(address)\n    tokenOut: address = empty(address)\n    legoIds: DynArray[uint256, MAX_LEGOS] = []\n    tokenIn, tokenOut, legoIds = self._validateAndGetSwapInfo(_instructions)\n    ad: VaultActionData = self._canManagerPerformAction(msg.sender, legoIds)\n\n    # important checks!\n    assert tokenIn != ad.vaultAsset # dev: cannot swap out of vault asset\n    assert self.vaultToLegoId[tokenIn] == 0 # dev: cannot swap out of vault token\n    assert tokenOut == ad.vaultAsset # dev: must swap into vault asset\n\n    origAmountIn: uint256 = self._getAmountAndApprove(tokenIn, _instructions[0].amountIn, empty(address)) # not approving here\n    amountIn: uint256 = origAmountIn\n    lastTokenOut: address = empty(address)\n    lastTokenOutAmount: uint256 = 0\n    maxTxUsdValue: uint256 = 0\n\n    # perform swaps\n    for i: wi.SwapInstruction in _instructions:\n        if lastTokenOut != empty(address):\n            newTokenIn: address = i.tokenPath[0]\n            assert lastTokenOut == newTokenIn # dev: path\n            amountIn = min(lastTokenOutAmount, staticcall IERC20(newTokenIn).balanceOf(self))\n        \n        thisTxUsdValue: uint256 = 0\n        lastTokenOut, lastTokenOutAmount, thisTxUsdValue = self._performSwapInstruction(amountIn, i, ad)\n        maxTxUsdValue = max(maxTxUsdValue, thisTxUsdValue)\n\n    assert lastTokenOutAmount != 0 # dev: no output amount\n    assert lastTokenOut == tokenOut # dev: must swap into token out\n\n    # handle swap fees\n    swapFee: uint256 = self._paySwapFees(lastTokenOut, lastTokenOutAmount, ad.vaultRegistry)\n    if swapFee != 0:\n        maxTxUsdValue = maxTxUsdValue * (lastTokenOutAmount - swapFee) // lastTokenOutAmount\n        lastTokenOutAmount -= swapFee\n\n    log EarnVaultSwap(\n        tokenIn = tokenIn,\n        tokenInAmount = origAmountIn,\n        tokenOut = lastTokenOut,\n        tokenOutAmount = lastTokenOutAmount,\n        usdValue = maxTxUsdValue,\n        swapFee = swapFee,\n        legoId = ad.legoId,\n        signer = ad.signer\n    )\n    return tokenIn, origAmountIn, lastTokenOut, lastTokenOutAmount, maxTxUsdValue\n\n\n@internal\ndef _performSwapInstruction(\n    _amountIn: uint256,\n    _i: wi.SwapInstruction,\n    _ad: VaultActionData,\n) -> (address, uint256, uint256):\n    legoAddr: address = staticcall Registry(_ad.legoBook).getAddr(_i.legoId)\n    assert legoAddr != empty(address) # dev: lego\n\n    # tokens\n    tokenIn: address = _i.tokenPath[0]\n    tokenOut: address = _i.tokenPath[len(_i.tokenPath) - 1]\n    tokenInAmount: uint256 = 0\n    tokenOutAmount: uint256 = 0\n    txUsdValue: uint256 = 0\n\n    assert extcall IERC20(tokenIn).approve(legoAddr, _amountIn, default_return_value = True) # dev: appr\n    tokenInAmount, tokenOutAmount, txUsdValue = extcall Lego(legoAddr).swapTokens(_amountIn, _i.minAmountOut, _i.tokenPath, _i.poolPath, self, self._packMiniAddys(_ad.ledger, _ad.missionControl, _ad.legoBook, _ad.appraiser))\n    assert extcall IERC20(tokenIn).approve(legoAddr, 0, default_return_value = True) # dev: appr\n    return tokenOut, tokenOutAmount, txUsdValue\n\n\n@internal\ndef _validateAndGetSwapInfo(_instructions: DynArray[wi.SwapInstruction, MAX_SWAP_INSTRUCTIONS]) -> (address, address, DynArray[uint256, MAX_LEGOS]):\n    numSwapInstructions: uint256 = len(_instructions)\n    assert numSwapInstructions != 0 # dev: swaps\n\n    # lego ids, make sure token paths are valid\n    legoIds: DynArray[uint256, MAX_LEGOS] = []\n    for i: wi.SwapInstruction in _instructions:\n        assert len(i.tokenPath) >= 2 # dev: path\n        if i.legoId not in legoIds:\n            legoIds.append(i.legoId)\n\n    # finalize tokens\n    firstRoutePath: DynArray[address, MAX_TOKEN_PATH] = _instructions[0].tokenPath\n    tokenIn: address = firstRoutePath[0]\n    tokenOut: address = empty(address)\n\n    if numSwapInstructions == 1:\n        tokenOut = firstRoutePath[len(firstRoutePath) - 1]\n    else:\n        lastRoutePath: DynArray[address, MAX_TOKEN_PATH] = _instructions[numSwapInstructions - 1].tokenPath\n        tokenOut = lastRoutePath[len(lastRoutePath) - 1]\n\n    assert empty(address) not in [tokenIn, tokenOut] # dev: path\n    return tokenIn, tokenOut, legoIds\n\n\n# pay swap fees\n\n\n@internal\ndef _paySwapFees(\n    _tokenOut: address,\n    _tokenOutAmount: uint256,\n    _vaultRegistry: address,\n) -> uint256:\n    if _tokenOut == empty(address) or _tokenOutAmount == 0:\n        return 0\n\n    swapFee: uint256 = min(_tokenOutAmount * self._getPerformanceFeeRatio(_vaultRegistry) // HUNDRED_PERCENT, staticcall IERC20(_tokenOut).balanceOf(self))\n    if swapFee == 0:\n        return 0\n\n    governance: address = self._getGovernanceAddr()\n    if governance == empty(address):\n        return 0\n\n    assert extcall IERC20(_tokenOut).transfer(governance, swapFee, default_return_value = True) # dev: xfer\n    return swapFee\n\n\n####################\n# Claim Incentives #\n####################\n\n\n@external\ndef claimIncentives(\n    _legoId: uint256,\n    _rewardToken: address = empty(address),\n    _rewardAmount: uint256 = max_value(uint256),\n    _proofs: DynArray[bytes32, MAX_PROOFS] = [],\n) -> (uint256, uint256):\n    ad: VaultActionData = self._canManagerPerformAction(msg.sender, [_legoId])\n\n    # make sure can access\n    self._setLegoAccessForAction(ad.legoAddr, ws.ActionType.REWARDS)\n\n    # claim rewards\n    rewardAmount: uint256 = 0\n    txUsdValue: uint256 = 0\n    rewardAmount, txUsdValue = extcall Lego(ad.legoAddr).claimIncentives(self, _rewardToken, _rewardAmount, _proofs, self._packMiniAddys(ad.ledger, ad.missionControl, ad.legoBook, ad.appraiser))\n\n    log EarnVaultRewardsClaim(\n        rewardToken = _rewardToken,\n        rewardAmount = rewardAmount,\n        usdValue = txUsdValue,\n        legoId = ad.legoId,\n        signer = ad.signer,\n    )\n    return rewardAmount, txUsdValue\n\n\n#############################\n# Overall Yield Calculation #\n#############################\n\n\n# calculate yield realized\n\n\n@view\n@internal\ndef _calcNewYieldAndGetUnderlying(_currentUnderlying: uint256 = 0) -> (uint256, uint256):\n    currentUnderlying: uint256 = _currentUnderlying\n    if currentUnderlying == 0:\n        currentUnderlying = self._getUnderlyingYieldBalances()[0]\n\n    newYield: uint256 = 0\n    lastUnderlyingBal: uint256 = self.lastUnderlyingBal\n    if lastUnderlyingBal != 0 and currentUnderlying > lastUnderlyingBal:\n        newYield = currentUnderlying - lastUnderlyingBal\n\n    return currentUnderlying, newYield\n\n\n# update pending yield realized\n\n\n@internal\ndef _getUnderlyingAndUpdatePendingYield() -> uint256:\n    currentUnderlying: uint256 = 0\n    newYield: uint256 = 0\n    currentUnderlying, newYield = self._calcNewYieldAndGetUnderlying()\n    self.pendingYieldRealized += newYield\n    return currentUnderlying\n\n\n# claim performance fees\n\n\n@external\ndef claimPerformanceFees() -> uint256:\n    governance: address = self._getGovernanceAddr()\n    assert self._isSwitchboardAddr(msg.sender) or governance == msg.sender # dev: no perms\n\n    vaultRegistry: address = self._getVaultRegistry()\n    currentUnderlying: uint256 = self._getUnderlyingAndUpdatePendingYield()\n    pendingFees: uint256 = self.pendingYieldRealized * self._getPerformanceFeeRatio(vaultRegistry) // HUNDRED_PERCENT\n\n    # make withdrawals from yield positions\n    availAmount: uint256 = 0\n    actuallyWithdrawn: uint256 = 0\n    availAmount, actuallyWithdrawn = self._prepareRedemption(VAULT_ASSET, pendingFees, empty(address), governance, vaultRegistry)\n    assert availAmount >= pendingFees # dev: insufficient funds\n\n    # transfer pending fees to governance\n    assert extcall IERC20(VAULT_ASSET).transfer(governance, pendingFees, default_return_value=True) # dev: withdrawal failed\n\n    # update data\n    self.pendingYieldRealized = 0\n    self.lastUnderlyingBal = currentUnderlying - min(currentUnderlying, actuallyWithdrawn)\n\n    log PerformanceFeesClaimed(pendingFees=pendingFees)\n    return pendingFees\n\n\n# claimable performance fees\n\n\n@view\n@external\ndef getClaimablePerformanceFees() -> uint256:\n    newYield: uint256 = self._calcNewYieldAndGetUnderlying()[1]\n    return (self.pendingYieldRealized + newYield) * self._getPerformanceFeeRatio(self._getVaultRegistry()) // HUNDRED_PERCENT\n\n\n# get performance fee %\n\n\n@view\n@internal\ndef _getPerformanceFeeRatio(_vaultRegistry: address) -> uint256:\n    return staticcall VaultRegistry(_vaultRegistry).getPerformanceFee(self)\n\n\n#####################\n# Underlying Assets #\n#####################\n\n\n@view\n@internal\ndef _getUnderlyingYieldBalances() -> (uint256, uint256, address):\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return 0, 0, empty(address)\n\n    maxTotalAssets: uint256 = 0\n    safeTotalAssets: uint256 = 0\n\n    maxBalance: uint256 = 0\n    maxBalVaultToken: address = empty(address)\n\n    # iterate over each asset\n    legoBook: address = staticcall Registry(UNDY_HQ).getAddr(LEGO_BOOK_ID)\n    for i: uint256 in range(1, numAssets, bound=max_value(uint256)):\n\n        # get asset addr\n        vaultToken: address = self.assets[i]\n        if vaultToken == empty(address):\n            continue\n\n        vaultTokenBalance: uint256 = staticcall IERC20(vaultToken).balanceOf(self)\n        if vaultTokenBalance == 0:\n            continue\n\n        legoId: uint256 = self.vaultToLegoId[vaultToken]\n        if legoId == 0:\n            continue\n\n        legoAddr: address = staticcall Registry(legoBook).getAddr(legoId)\n        if legoAddr == empty(address):\n            continue\n\n        # get balance data\n        trueUnderlying: uint256 = 0\n        safeUnderlying: uint256 = 0\n        trueUnderlying, safeUnderlying = staticcall YieldLego(legoAddr).getUnderlyingBalances(vaultToken, vaultTokenBalance)\n\n        # add totals\n        maxTotalAssets += trueUnderlying\n        safeTotalAssets += safeUnderlying\n\n        # save max balance / token\n        if trueUnderlying > maxBalance:\n            maxBalance = trueUnderlying\n            maxBalVaultToken = vaultToken\n\n    return maxTotalAssets, safeTotalAssets, maxBalVaultToken\n\n\n###################\n# Redemption Prep #\n###################\n\n\n@internal\ndef _prepareRedemption(\n    _asset: address,\n    _amount: uint256,\n    _maxBalVaultToken: address,\n    _sender: address,\n    _vaultRegistry: address,\n) -> (uint256, uint256):\n    availAmount: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    actuallyWithdrawn: uint256 = 0\n\n    # enough balance, no need to withdraw\n    if availAmount >= _amount:\n        return availAmount, actuallyWithdrawn\n\n    # get redemption config (buffer and min withdraw amount)\n    redemptionBuffer: uint256 = 0\n    minWithdrawAmount: uint256 = 0\n    redemptionBuffer, minWithdrawAmount = staticcall VaultRegistry(_vaultRegistry).redemptionConfig(self)\n\n    # buffer to make sure we pull out enough for redemption\n    bufferMultiplier: uint256 = HUNDRED_PERCENT + redemptionBuffer\n    targetWithdrawAmount: uint256 = _amount * bufferMultiplier // HUNDRED_PERCENT\n\n    ad: VaultActionData = staticcall VaultRegistry(_vaultRegistry).getVaultActionDataBundle(0, _sender)\n    ad.vaultAsset = _asset\n\n    # first withdraw from biggest yield position\n    if _maxBalVaultToken != empty(address):\n        availAmount, actuallyWithdrawn = self._withdrawDuringRedemption(_maxBalVaultToken, targetWithdrawAmount, availAmount, actuallyWithdrawn, minWithdrawAmount, True, ad)\n\n    # next, iterate thru each yield position (order it is saved)\n    if availAmount < _amount:\n        numAssets: uint256 = self.numAssets\n        if numAssets != 0:\n            for i: uint256 in range(1, numAssets, bound=max_value(uint256)):\n                if availAmount >= _amount:\n                    break\n\n                vaultToken: address = self.assets[i]\n                if _maxBalVaultToken != empty(address) and vaultToken == _maxBalVaultToken:\n                    continue\n\n                # withdraw from yield opportunity\n                availAmount, actuallyWithdrawn = self._withdrawDuringRedemption(vaultToken, targetWithdrawAmount, availAmount, actuallyWithdrawn, minWithdrawAmount, True, ad)\n\n    # lastly, iterate thru all tokens that have withdrawal fees\n    if availAmount < _amount:\n        numFeeVaultTokens: uint256 = self.numFeeVaultTokens\n        if numFeeVaultTokens != 0:\n            for i: uint256 in range(1, numFeeVaultTokens, bound=max_value(uint256)):\n                if availAmount >= _amount:\n                    break\n                vaultToken: address = self.feeVaultTokens[i]\n                availAmount, actuallyWithdrawn = self._withdrawDuringRedemption(vaultToken, targetWithdrawAmount, availAmount, actuallyWithdrawn, minWithdrawAmount, False, ad)\n\n    # deregister vault positions\n    numDeregVaultTokens: uint256 = self.numDeregVaultTokens\n    if numDeregVaultTokens != 0:\n        for i: uint256 in range(1, numDeregVaultTokens, bound=max_value(uint256)):\n            vaultToken: address = self.deregVaultTokens[i]\n            self._deregisterYieldPosition(vaultToken)\n\n    return availAmount, actuallyWithdrawn\n\n\n# withdraw from yield position\n\n\n@internal\ndef _withdrawDuringRedemption(\n    _vaultToken: address,\n    _targetWithdrawAmount: uint256,\n    _availAmount: uint256,\n    _actuallyWithdrawn: uint256,\n    _minWithdrawAmount: uint256,\n    _shouldCheckFees: bool,\n    _ad: VaultActionData,\n) -> (uint256, uint256):\n    availAmount: uint256 = _availAmount\n    actuallyWithdrawn: uint256 = _actuallyWithdrawn\n\n    # no token\n    if _vaultToken == empty(address):\n        return availAmount, actuallyWithdrawn\n\n    # no balance, deregister asset\n    vaultTokenBalance: uint256 = staticcall IERC20(_vaultToken).balanceOf(self)\n    if vaultTokenBalance == 0:\n        self._saveVaultTokenForDeregistration(_vaultToken) # save for deregistration\n        return availAmount, actuallyWithdrawn\n\n    # no lego id, skip\n    legoId: uint256 = self.vaultToLegoId[_vaultToken]\n    if legoId == 0:\n        return availAmount, actuallyWithdrawn\n\n    ad: VaultActionData = _ad\n    ad.legoId = legoId\n    ad.legoAddr = staticcall Registry(ad.legoBook).getAddr(legoId)\n\n    # skip if amount still needed is below minimum (dust protection)\n    amountStillNeeded: uint256 = _targetWithdrawAmount - _availAmount\n    if _minWithdrawAmount != 0 and amountStillNeeded < _minWithdrawAmount:\n        return availAmount, actuallyWithdrawn\n\n    # skip if vault tokens needed rounds to 0 (dust)\n    vaultTokensNeeded: uint256 = staticcall YieldLego(ad.legoAddr).getVaultTokenAmount(ad.vaultAsset, amountStillNeeded, _vaultToken)\n    if vaultTokensNeeded == 0:\n        return availAmount, actuallyWithdrawn\n\n    # save for last if it has withdrawal fees\n    if _shouldCheckFees:\n        withdrawalFees: uint256 = staticcall YieldLego(ad.legoAddr).getWithdrawalFees(_vaultToken, vaultTokensNeeded)\n        if withdrawalFees != 0:\n            self._saveFeeVaultToken(_vaultToken) # save this for the end\n            return availAmount, actuallyWithdrawn\n\n    # withdraw from yield opportunity\n    na: uint256 = 0\n    na2: address = empty(address)\n    underlyingAmount: uint256 = 0\n    na3: uint256 = 0\n    na, na2, underlyingAmount, na3 = self._withdrawFromYield(_vaultToken, vaultTokensNeeded, empty(bytes32), 0, False, ad)\n\n    # add to deregister list\n    if vaultTokensNeeded >= vaultTokenBalance and staticcall IERC20(_vaultToken).balanceOf(self) == 0:\n        self._saveVaultTokenForDeregistration(_vaultToken) # save for deregistration\n\n    availAmount += underlyingAmount\n    actuallyWithdrawn += underlyingAmount\n    return availAmount, actuallyWithdrawn\n\n\n# save vault token for later\n\n\n@internal\ndef _saveFeeVaultToken(_vaultToken: address):\n    if self.feeVaultTokenToId[_vaultToken] != 0:\n        return\n    nextId: uint256 = self.numFeeVaultTokens\n    if nextId == 0:\n        nextId = 1\n    self.feeVaultTokens[nextId] = _vaultToken\n    self.feeVaultTokenToId[_vaultToken] = nextId\n    self.numFeeVaultTokens = nextId + 1\n\n\n# save vault token for deregistration\n\n\n@internal\ndef _saveVaultTokenForDeregistration(_vaultToken: address):\n    if self.deregVaultTokenToId[_vaultToken] != 0:\n        return\n    nextId: uint256 = self.numDeregVaultTokens\n    if nextId == 0:\n        nextId = 1\n    self.deregVaultTokens[nextId] = _vaultToken\n    self.deregVaultTokenToId[_vaultToken] = nextId\n    self.numDeregVaultTokens = nextId + 1\n\n\n###################\n# Yield Positions #\n###################\n\n\n# update yield position\n\n\n@external\ndef updateYieldPosition(_vaultToken: address):\n    assert self._isSwitchboardAddr(msg.sender) # dev: no perms\n    vaultRegistry: address = self._getVaultRegistry()\n    legoId: uint256 = 0\n    na: address = empty(address)\n    legoId, na = staticcall VaultRegistry(vaultRegistry).getLegoDataFromVaultToken(_vaultToken)\n    if legoId != 0:\n        self._updateYieldPosition(_vaultToken, legoId)\n\n\n@internal\ndef _updateYieldPosition(_vaultToken: address, _legoId: uint256):\n    if _vaultToken == empty(address):\n        return\n\n    # no balance, deregister asset\n    currentBalance: uint256 = staticcall IERC20(_vaultToken).balanceOf(self)\n    if currentBalance == 0:\n        self._deregisterYieldPosition(_vaultToken)\n        return\n\n    # first time, need to save lego mapping\n    legoId: uint256 = self.vaultToLegoId[_vaultToken]\n    if legoId == 0 and _legoId != 0:\n        self.vaultToLegoId[_vaultToken] = _legoId\n\n    # register asset (if necessary)\n    if self.indexOfAsset[_vaultToken] == 0:\n        self._registerYieldPosition(_vaultToken)\n\n\n# register yield position\n\n\n@internal\ndef _registerYieldPosition(_vaultToken: address):\n    aid: uint256 = self.numAssets\n    self.assets[aid] = _vaultToken\n    self.indexOfAsset[_vaultToken] = aid\n    self.numAssets = aid + 1\n\n\n# deregister yield position\n\n\n@internal\ndef _deregisterYieldPosition(_vaultToken: address) -> bool:\n    if _vaultToken == empty(address):\n        return False\n\n    numAssets: uint256 = self.numAssets\n    if numAssets == 1:\n        return False\n\n    targetIndex: uint256 = self.indexOfAsset[_vaultToken]\n    if targetIndex == 0:\n        return False\n\n    # update data\n    lastIndex: uint256 = numAssets - 1\n    self.numAssets = lastIndex\n    self.indexOfAsset[_vaultToken] = 0\n\n    # get last item, replace the removed item\n    if targetIndex != lastIndex:\n        lastItem: address = self.assets[lastIndex]\n        self.assets[targetIndex] = lastItem\n        self.indexOfAsset[lastItem] = targetIndex\n\n    return True\n\n\n####################\n# Manager Settings #\n####################\n\n\n# can manage\n\n\n@internal\ndef _canManagerPerformAction(_signer: address, _legoIds: DynArray[uint256, MAX_LEGOS]) -> VaultActionData:\n    vaultRegistry: address = self._getVaultRegistry()\n    if msg.sender != vaultRegistry:\n        assert self.indexOfManager[_signer] != 0 # dev: not manager\n\n    # main data for this transaction - get action data and frozen status in single call\n    legoId: uint256 = 0\n    if len(_legoIds) != 0:\n        legoId = _legoIds[0]\n\n    ad: VaultActionData = empty(VaultActionData)\n    isVaultOpsFrozen: bool = False\n    ad, isVaultOpsFrozen = staticcall VaultRegistry(vaultRegistry).getVaultActionDataWithFrozenStatus(legoId, _signer, self)\n    ad.vaultAsset = VAULT_ASSET\n\n    # cannot perform any actions if vault is frozen\n    assert not isVaultOpsFrozen # dev: frozen vault\n\n    # make sure manager is not locked\n    assert not staticcall MissionControl(ad.missionControl).isLockedSigner(_signer) # dev: manager is locked\n\n    return ad\n\n\n# add manager\n\n\n@external\ndef addManager(_manager: address):\n    assert self._isSwitchboardAddr(msg.sender) # dev: no perms\n    self._registerManager(_manager)\n\n\n# register manager\n\n\n@internal\ndef _registerManager(_manager: address):\n    if self.indexOfManager[_manager] != 0:\n        return\n    mid: uint256 = self.numManagers\n    self.managers[mid] = _manager\n    self.indexOfManager[_manager] = mid\n    self.numManagers = mid + 1\n\n\n# remove manager\n\n\n@external\ndef removeManager(_manager: address):\n    assert self._isSwitchboardAddr(msg.sender) # dev: no perms\n\n    numManagers: uint256 = self.numManagers\n    if numManagers == 1:\n        return\n\n    targetIndex: uint256 = self.indexOfManager[_manager]\n    if targetIndex == 0:\n        return\n\n    # update data\n    lastIndex: uint256 = numManagers - 1\n    self.numManagers = lastIndex\n    self.indexOfManager[_manager] = 0\n\n    # get last item, replace the removed item\n    if targetIndex != lastIndex:\n        lastItem: address = self.managers[lastIndex]\n        self.managers[targetIndex] = lastItem\n        self.indexOfManager[lastItem] = targetIndex\n\n    # clear the last position to prevent stale data\n    self.managers[lastIndex] = empty(address)\n\n\n#############\n# Utilities #\n#############\n\n\n# get vault registry\n\n\n@view\n@internal\ndef _getVaultRegistry() -> address:\n    return staticcall Registry(UNDY_HQ).getAddr(VAULT_REGISTRY_ID)\n\n\n# is signer switchboard\n\n\n@view\n@internal\ndef _isSwitchboardAddr(_signer: address) -> bool:\n    switchboard: address = staticcall Registry(UNDY_HQ).getAddr(SWITCHBOARD_ID)\n    if switchboard == empty(address):\n        return False\n    return staticcall Switchboard(switchboard).isSwitchboardAddr(_signer)\n\n\n# governance\n\n\n@view\n@internal\ndef _getGovernanceAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ).governance()\n\n\n# approve\n\n\n@internal\ndef _getAmountAndApprove(_token: address, _amount: uint256, _legoAddr: address) -> uint256:\n    amount: uint256 = min(_amount, staticcall IERC20(_token).balanceOf(self))\n    assert amount != 0 # dev: no balance for _token\n    if _legoAddr != empty(address):\n        assert extcall IERC20(_token).approve(_legoAddr, amount, default_return_value = True) # dev: appr\n    return amount\n\n\n# lego access\n\n\n@internal\ndef _setLegoAccessForAction(_legoAddr: address, _action: ws.ActionType) -> bool:\n    if _legoAddr == empty(address):\n        return False\n\n    targetAddr: address = empty(address)\n    accessAbi: String[64] = empty(String[64])\n    numInputs: uint256 = 0\n    targetAddr, accessAbi, numInputs = staticcall Lego(_legoAddr).getAccessForLego(self, _action)\n\n    # nothing to do here\n    if targetAddr == empty(address):\n        return False\n\n    method_abi: bytes4 = convert(slice(keccak256(accessAbi), 0, 4), bytes4)\n    success: bool = False\n    response: Bytes[32] = b\"\"\n\n    # assumes input is: lego addr (operator)\n    if numInputs == 1:\n        success, response = raw_call(\n            targetAddr,\n            concat(\n                method_abi,\n                convert(_legoAddr, bytes32),\n            ),\n            revert_on_failure = False,\n            max_outsize = 32,\n        )\n    \n    # assumes input (and order) is: user (self), lego addr (operator)\n    elif numInputs == 2:\n        success, response = raw_call(\n            targetAddr,\n            concat(\n                method_abi,\n                convert(self, bytes32),\n                convert(_legoAddr, bytes32),\n            ),\n            revert_on_failure = False,\n            max_outsize = 32,\n        )\n\n    # assumes input (and order) is: user (self), lego addr (operator), allowed bool\n    elif numInputs == 3:\n        success, response = raw_call(\n            targetAddr,\n            concat(\n                method_abi,\n                convert(self, bytes32),\n                convert(_legoAddr, bytes32),\n                convert(True, bytes32),\n            ),\n            revert_on_failure = False,\n            max_outsize = 32,\n        )\n\n    assert success # dev: failed to set operator\n    return True\n\n\n# mini addys\n\n\n@view\n@internal\ndef _packMiniAddys(\n    _ledger: address,\n    _missionControl: address,\n    _legoBook: address,\n    _appraiser: address,\n) -> ws.MiniAddys:\n    return ws.MiniAddys(\n        ledger = _ledger,\n        missionControl = _missionControl,\n        legoBook = _legoBook,\n        appraiser = _appraiser,\n    )\n\n",
            "sha256sum": "858c93485063f9ce96949b98f229bf2f56945599ecf43c5effb06974314182d5"
          },
          "contracts/vaults/EarnVault.vy": {
            "content": "#    ________   __  __   _________  ______   ______   ________  __       ______   _________  \n#   /_______/\\ /_/\\/_/\\ /________/\\/_____/\\ /_____/\\ /_______/\\/_/\\     /_____/\\ /________/\\ \n#   \\::: _  \\ \\\\:\\ \\:\\ \\\\__.::.__\\/\\:::_ \\ \\\\:::_ \\ \\\\__.::._\\/\\:\\ \\    \\:::_ \\ \\\\__.::.__\\/ \n#    \\::(_)  \\ \\\\:\\ \\:\\ \\  \\::\\ \\   \\:\\ \\ \\ \\\\:(_) \\ \\  \\::\\ \\  \\:\\ \\    \\:\\ \\ \\ \\  \\::\\ \\   \n#     \\:: __  \\ \\\\:\\ \\:\\ \\  \\::\\ \\   \\:\\ \\ \\ \\\\: ___\\/  _\\::\\ \\__\\:\\ \\____\\:\\ \\ \\ \\  \\::\\ \\  \n#      \\:.\\ \\  \\ \\\\:\\_\\:\\ \\  \\::\\ \\   \\:\\_\\ \\ \\\\ \\ \\   /__\\::\\__/\\\\:\\/___/\\\\:\\_\\ \\ \\  \\::\\ \\ \n#       \\__\\/\\__\\/ \\_____\\/   \\__\\/    \\_____\\/ \\_\\/   \\________\\/ \\_____\\/ \\_____\\/   \\__\\/ \n#                                                                       \n#     \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n#     \u2551  ** Earn Autopilot Vaults **                                         \u2551\n#     \u2551  Managed by AI agents, enforced by onchain rules. Erc4626 compliant. \u2551\n#     \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n#\n#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nimplements: IERC4626\nimplements: IERC20\n\nexports: token.__interface__\ninitializes: token\nfrom contracts.vaults.modules import VaultErc20Token as token\n\nexports: vaultWallet.__interface__\ninitializes: vaultWallet\nfrom contracts.vaults.modules import EarnVaultWallet as vaultWallet\n\nfrom ethereum.ercs import IERC4626\nfrom ethereum.ercs import IERC20\nfrom ethereum.ercs import IERC20Detailed\n\ninterface VaultRegistry:\n    def getDepositConfig(_vaultAddr: address, _user: address = empty(address)) -> (bool, uint256, bool, address): view\n    def canWithdraw(_vaultAddr: address) -> bool: view\n\nevent Deposit:\n    sender: indexed(address)\n    owner: indexed(address)\n    assets: uint256\n    shares: uint256\n\nevent Withdraw:\n    sender: indexed(address)\n    receiver: indexed(address)\n    owner: indexed(address)\n    assets: uint256\n    shares: uint256\n\nevent LeftoversSwept:\n    amount: uint256\n    recipient: indexed(address)\n\nHUNDRED_PERCENT: constant(uint256) = 100_00 # 100.00%\n\n\n@deploy\ndef __init__(\n    _asset: address,\n    _tokenName: String[64],\n    _tokenSymbol: String[32],\n    _undyHq: address,\n    _minHqTimeLock: uint256,\n    _maxHqTimeLock: uint256,\n    _startingAgent: address,\n):\n    token.__init__(_tokenName, _tokenSymbol, staticcall IERC20Detailed(_asset).decimals(), _undyHq)\n    vaultWallet.__init__(_undyHq, _asset, _startingAgent)\n\n\n@view\n@external\ndef asset() -> address:\n    return vaultWallet.VAULT_ASSET\n\n\n@view\n@external\ndef totalAssets() -> uint256:\n    return self._getTotalAssets(True)\n\n\n################\n# Total Assets #\n################\n\n\n@view\n@external\ndef getTotalAssets(_shouldGetMax: bool) -> uint256:\n    return self._getTotalAssets(_shouldGetMax)\n\n\n@view\n@internal\ndef _getTotalAssets(_shouldGetMax: bool, _vaultRegistry: address = empty(address)) -> uint256:\n    vaultRegistry: address = _vaultRegistry\n    if vaultRegistry == empty(address):\n        vaultRegistry = vaultWallet._getVaultRegistry()\n    return self._getUnderlyingData(_shouldGetMax, vaultRegistry)[0]\n\n\n@view\n@internal\ndef _getUnderlyingData(_shouldGetMax: bool, _vaultRegistry: address) -> (uint256, uint256, uint256, address):\n    totalAssets: uint256 = staticcall IERC20(vaultWallet.VAULT_ASSET).balanceOf(self)\n\n    # all underlying assets\n    maxTotalAssets: uint256 = 0\n    safeTotalAssets: uint256 = 0\n    maxBalVaultToken: address = empty(address)\n    maxTotalAssets, safeTotalAssets, maxBalVaultToken = vaultWallet._getUnderlyingYieldBalances()\n\n    # new yield\n    currentBalance: uint256 = 0\n    newYield: uint256 = 0\n    currentBalance, newYield = vaultWallet._calcNewYieldAndGetUnderlying(maxTotalAssets)\n\n    # pending fees\n    pendingYieldRealized: uint256 = vaultWallet.pendingYieldRealized + newYield\n    pendingFees: uint256 = pendingYieldRealized * vaultWallet._getPerformanceFeeRatio(_vaultRegistry) // HUNDRED_PERCENT\n\n    # add total assets\n    if _shouldGetMax:\n        totalAssets += maxTotalAssets\n    else:\n        totalAssets += safeTotalAssets\n    totalAssets -= min(pendingFees, totalAssets)\n\n    return totalAssets, currentBalance, pendingYieldRealized, maxBalVaultToken\n\n\n############\n# Deposits #\n############\n\n\n@view\n@external\ndef maxDeposit(_receiver: address) -> uint256:\n    vaultRegistry: address = vaultWallet._getVaultRegistry()\n\n    # deposit config\n    canDeposit: bool = False\n    maxDepositAmount: uint256 = 0\n    na1: bool = False\n    na2: address = empty(address)\n    canDeposit, maxDepositAmount, na1, na2 = staticcall VaultRegistry(vaultRegistry).getDepositConfig(self, _receiver)\n\n    if not canDeposit:\n        return 0\n\n    if maxDepositAmount == 0:\n        return max_value(uint256)\n\n    totalAssets: uint256 = self._getTotalAssets(True, vaultRegistry)\n    if totalAssets >= maxDepositAmount:\n        return 0\n\n    return maxDepositAmount - totalAssets\n\n\n@view\n@external\ndef previewDeposit(_assets: uint256) -> uint256:\n    return self._amountToShares(_assets, token.totalSupply, self._getTotalAssets(True), False)\n\n\n@nonreentrant\n@external\ndef deposit(_assets: uint256, _receiver: address = msg.sender) -> uint256:\n    return self._deposit(_assets, msg.sender, _receiver, 0)\n\n\n@nonreentrant\n@external\ndef depositWithMinAmountOut(_assets: uint256, _minAmountOut: uint256, _receiver: address = msg.sender) -> uint256:\n    return self._deposit(_assets, msg.sender, _receiver, _minAmountOut)\n\n\n@internal\ndef _deposit(_assets: uint256, _sender: address, _receiver: address, _minAmountOut: uint256) -> uint256:\n    vaultRegistry: address = vaultWallet._getVaultRegistry()\n    asset: address = vaultWallet.VAULT_ASSET\n\n    amount: uint256 = _assets\n    if amount == max_value(uint256):\n        amount = staticcall IERC20(asset).balanceOf(_sender)\n\n    # underlying data\n    totalAssets: uint256 = 0\n    currentBalance: uint256 = 0\n    pendingYieldRealized: uint256 = 0\n    maxBalVaultToken: address = empty(address)\n    totalAssets, currentBalance, pendingYieldRealized, maxBalVaultToken = self._getUnderlyingData(True, vaultRegistry)\n\n    shares: uint256 = self._amountToShares(amount, token.totalSupply, totalAssets, False)\n    if _minAmountOut != 0:\n        assert shares >= _minAmountOut # dev: insufficient shares\n\n    self._depositIntoVault(asset, amount, shares, _sender, _receiver, totalAssets, currentBalance, pendingYieldRealized, maxBalVaultToken, vaultRegistry)\n    return shares\n\n\n# mint\n\n\n@view\n@external\ndef maxMint(_receiver: address) -> uint256:\n    vaultRegistry: address = vaultWallet._getVaultRegistry()\n\n    # deposit config\n    canDeposit: bool = False\n    maxDepositAmount: uint256 = 0\n    na1: bool = False\n    na2: address = empty(address)\n    canDeposit, maxDepositAmount, na1, na2 = staticcall VaultRegistry(vaultRegistry).getDepositConfig(self, _receiver)\n\n    if not canDeposit:\n        return 0\n\n    if maxDepositAmount == 0:\n        return max_value(uint256)\n\n    totalAssets: uint256 = self._getTotalAssets(True, vaultRegistry)\n    if totalAssets >= maxDepositAmount:\n        return 0\n\n    maxDepositAmt: uint256 = maxDepositAmount - totalAssets\n    return self._amountToShares(maxDepositAmt, token.totalSupply, totalAssets, False)\n\n\n@view\n@external\ndef previewMint(_shares: uint256) -> uint256:\n    return self._sharesToAmount(_shares, token.totalSupply, self._getTotalAssets(True), True)\n\n\n@nonreentrant\n@external\ndef mint(_shares: uint256, _receiver: address = msg.sender) -> uint256:\n    vaultRegistry: address = vaultWallet._getVaultRegistry()\n\n    # underlying data\n    totalAssets: uint256 = 0\n    currentBalance: uint256 = 0\n    pendingYieldRealized: uint256 = 0\n    maxBalVaultToken: address = empty(address)\n    totalAssets, currentBalance, pendingYieldRealized, maxBalVaultToken = self._getUnderlyingData(True, vaultRegistry)\n\n    amount: uint256 = self._sharesToAmount(_shares, token.totalSupply, totalAssets, True)\n    self._depositIntoVault(vaultWallet.VAULT_ASSET, amount, _shares, msg.sender, _receiver, totalAssets, currentBalance, pendingYieldRealized, maxBalVaultToken, vaultRegistry)\n    return amount\n\n\n# shared deposit logic\n\n\n@internal\ndef _depositIntoVault(\n    _asset: address,\n    _amount: uint256,\n    _shares: uint256,\n    _sender: address,\n    _recipient: address,\n    _totalAssets: uint256,\n    _currentBalance: uint256,\n    _pendingYieldRealized: uint256,\n    _maxBalVaultToken: address,\n    _vaultRegistry: address,\n):\n    # get all deposit config\n    canDeposit: bool = False\n    maxDepositAmount: uint256 = 0\n    shouldAutoDeposit: bool = False\n    defaultTargetVaultToken: address = empty(address)\n    canDeposit, maxDepositAmount, shouldAutoDeposit, defaultTargetVaultToken = staticcall VaultRegistry(_vaultRegistry).getDepositConfig(self, _recipient)\n\n    if not canDeposit:\n        assert _sender == vaultWallet._getGovernanceAddr() # dev: cannot deposit\n\n    assert _amount != 0 # dev: cannot deposit 0 amount\n    assert _shares != 0 # dev: cannot receive 0 shares\n    assert _recipient != empty(address) # dev: invalid recipient\n    if maxDepositAmount != 0:\n        assert _totalAssets + _amount <= maxDepositAmount # dev: exceeds max deposit\n\n    # transfer assets to vault\n    assert extcall IERC20(_asset).transferFrom(msg.sender, self, _amount, default_return_value=True) # dev: deposit failed\n\n    # put the deposit to work -- start earning\n    amountDeposited: uint256 = 0\n    if shouldAutoDeposit:\n        targetVaultToken: address = defaultTargetVaultToken\n        if targetVaultToken == empty(address):\n            targetVaultToken = _maxBalVaultToken\n        amountDeposited = vaultWallet._onReceiveVaultFunds(targetVaultToken, _recipient, _vaultRegistry)\n\n    # save data\n    vaultWallet.lastUnderlyingBal = _currentBalance + amountDeposited\n    vaultWallet.pendingYieldRealized = _pendingYieldRealized\n\n    token._mint(_recipient, _shares)\n    log Deposit(sender=msg.sender, owner=_recipient, assets=_amount, shares=_shares)\n\n\n###############\n# Withdrawals #\n###############\n\n\n@view\n@external\ndef maxWithdraw(_owner: address) -> uint256:\n    ownerShares: uint256 = token.balanceOf[_owner]\n    if ownerShares == 0:\n        return 0\n    availableAssets: uint256 = self._getTotalAssets(False)\n    ownerAssets: uint256 = self._sharesToAmount(ownerShares, token.totalSupply, availableAssets, False)\n    return min(ownerAssets, availableAssets)\n\n\n@view\n@external\ndef previewWithdraw(_assets: uint256) -> uint256:\n    return self._amountToShares(_assets, token.totalSupply, self._getTotalAssets(False), True)\n\n\n@nonreentrant\n@external\ndef withdraw(_assets: uint256, _receiver: address = msg.sender, _owner: address = msg.sender) -> uint256:\n    vaultRegistry: address = vaultWallet._getVaultRegistry()\n\n    # underlying data\n    totalAssets: uint256 = 0\n    currentBalance: uint256 = 0\n    pendingYieldRealized: uint256 = 0\n    maxBalVaultToken: address = empty(address)\n    totalAssets, currentBalance, pendingYieldRealized, maxBalVaultToken = self._getUnderlyingData(False, vaultRegistry)\n\n    shares: uint256 = self._amountToShares(_assets, token.totalSupply, totalAssets, True)\n    self._redeemFromVault(vaultWallet.VAULT_ASSET, _assets, 0, shares, msg.sender, _receiver, _owner, currentBalance, pendingYieldRealized, maxBalVaultToken, vaultRegistry)\n    return shares\n\n\n# redeem\n\n\n@view\n@external\ndef maxRedeem(_owner: address) -> uint256:\n    return token.balanceOf[_owner]\n\n\n@view\n@external\ndef previewRedeem(_shares: uint256) -> uint256:\n    return self._sharesToAmount(_shares, token.totalSupply, self._getTotalAssets(False), False)\n\n\n@nonreentrant\n@external\ndef redeem(_shares: uint256, _receiver: address = msg.sender, _owner: address = msg.sender) -> uint256:\n    return self._redeem(_shares, msg.sender, _receiver, _owner, 0)\n\n\n@nonreentrant\n@external\ndef redeemWithMinAmountOut(_shares: uint256, _minAmountOut: uint256, _receiver: address = msg.sender, _owner: address = msg.sender) -> uint256:\n    return self._redeem(_shares, msg.sender, _receiver, _owner, _minAmountOut)\n\n\n@internal\ndef _redeem(_shares: uint256, _sender: address, _receiver: address, _owner: address, _minAmountOut: uint256) -> uint256:\n    vaultRegistry: address = vaultWallet._getVaultRegistry()\n\n    shares: uint256 = _shares\n    if shares == max_value(uint256):\n        shares = token.balanceOf[_owner]\n\n    # underlying data\n    totalAssets: uint256 = 0\n    currentBalance: uint256 = 0\n    pendingYieldRealized: uint256 = 0\n    maxBalVaultToken: address = empty(address)\n    totalAssets, currentBalance, pendingYieldRealized, maxBalVaultToken = self._getUnderlyingData(False, vaultRegistry)\n\n    amount: uint256 = self._sharesToAmount(shares, token.totalSupply, totalAssets, False)\n    return self._redeemFromVault(vaultWallet.VAULT_ASSET, amount, _minAmountOut, shares, _sender, _receiver, _owner, currentBalance, pendingYieldRealized, maxBalVaultToken, vaultRegistry)\n\n\n# shared redeem logic\n\n\n@internal\ndef _redeemFromVault(\n    _asset: address,\n    _amount: uint256,\n    _minAmountOut: uint256,\n    _shares: uint256,\n    _sender: address,\n    _recipient: address,\n    _owner: address,\n    _currentBalance: uint256,\n    _pendingYieldRealized: uint256,\n    _maxBalVaultToken: address,\n    _vaultRegistry: address,\n) -> uint256:\n    if not staticcall VaultRegistry(_vaultRegistry).canWithdraw(self):\n        assert _sender == vaultWallet._getGovernanceAddr() # dev: cannot withdraw\n\n    assert _amount != 0 # dev: cannot withdraw 0 amount\n    assert _shares != 0 # dev: cannot redeem 0 shares\n    assert _recipient != empty(address) # dev: invalid recipient\n\n    assert token.balanceOf[_owner] >= _shares # dev: insufficient shares\n\n    if _sender != _owner:\n        token._spendAllowance(_owner, _sender, _shares)\n\n    # withdraw from yield opportunity\n    availAmount: uint256 = 0\n    actuallyWithdrawn: uint256 = 0\n    availAmount, actuallyWithdrawn = vaultWallet._prepareRedemption(_asset, _amount, _maxBalVaultToken, _sender, _vaultRegistry)\n    actualAmount: uint256 = min(availAmount, _amount)\n\n    # check amount out\n    if _minAmountOut != 0:\n        assert actualAmount >= _minAmountOut # dev: insufficient amount out\n    else:\n        assert self._isRedemptionCloseEnough(_amount, actualAmount) # dev: insufficient funds\n\n    # burn shares\n    token._burn(_owner, _shares)\n\n    # save vault yield data\n    vaultWallet.lastUnderlyingBal = _currentBalance - min(_currentBalance, actuallyWithdrawn)\n    vaultWallet.pendingYieldRealized = _pendingYieldRealized\n\n    # transfer assets to recipient\n    assert extcall IERC20(_asset).transfer(_recipient, actualAmount, default_return_value=True) # dev: withdrawal failed\n\n    log Withdraw(sender=_sender, receiver=_recipient, owner=_owner, assets=actualAmount, shares=_shares)\n    return actualAmount\n\n\n@pure\n@internal\ndef _isRedemptionCloseEnough(_requestedAmount: uint256, _actualAmount: uint256) -> bool:\n    # extra check to make sure what was sent was actually close-ish to what was requested\n    buffer: uint256 = _requestedAmount * 10 // HUNDRED_PERCENT # 0.1%\n    lowerBound: uint256 = _requestedAmount - buffer\n    return _actualAmount >= lowerBound\n\n\n##########\n# Shares #\n##########\n\n\n@view\n@external\ndef convertToShares(_assets: uint256) -> uint256:\n    return self._amountToShares(_assets, token.totalSupply, self._getTotalAssets(True), False)\n\n\n@view\n@external\ndef convertToSharesSafe(_assets: uint256) -> uint256:\n    return self._amountToShares(_assets, token.totalSupply, self._getTotalAssets(False), False)\n\n\n@view\n@external\ndef convertToAssets(_shares: uint256) -> uint256:\n    return self._sharesToAmount(_shares, token.totalSupply, self._getTotalAssets(True), False)\n\n\n@view\n@external\ndef convertToAssetsSafe(_shares: uint256) -> uint256:\n    return self._sharesToAmount(_shares, token.totalSupply, self._getTotalAssets(False), False)\n\n\n# amount -> shares\n\n\n@view\n@internal\ndef _amountToShares(\n    _amount: uint256,\n    _totalShares: uint256,\n    _totalBalance: uint256,\n    _shouldRoundUp: bool,\n) -> uint256:\n    if _amount == max_value(uint256) or _amount == 0:\n        return _amount\n\n    # first deposit, price per share = 1\n    if _totalShares == 0:\n        return _amount\n\n    # no underlying balance, price per share = 0\n    if _totalBalance == 0:\n        return 0\n\n    # calc shares\n    numerator: uint256 = _amount * _totalShares\n    shares: uint256 = numerator // _totalBalance\n\n    # rounding\n    if _shouldRoundUp and (numerator % _totalBalance != 0):\n        shares += 1\n\n    return shares\n\n\n# shares -> amount\n\n\n@view\n@internal\ndef _sharesToAmount(\n    _shares: uint256,\n    _totalShares: uint256,\n    _totalBalance: uint256,\n    _shouldRoundUp: bool,\n) -> uint256:\n    if _shares == max_value(uint256) or _shares == 0:\n        return _shares\n\n    # first deposit, price per share = 1\n    if _totalShares == 0:\n        return _shares\n\n    # calc amount\n    numerator: uint256 = _shares * _totalBalance\n    amount: uint256 = numerator // _totalShares\n\n    # rounding\n    if _shouldRoundUp and (numerator % _totalShares != 0):\n        amount += 1\n\n    return amount\n\n\n###################\n# Sweep Leftovers #\n###################\n\n\n@external\ndef sweepLeftovers() -> uint256:\n    governance: address = vaultWallet._getGovernanceAddr()\n    assert vaultWallet._isSwitchboardAddr(msg.sender) or governance == msg.sender # dev: no perms\n    assert token.totalSupply == 0 # dev: shares outstanding\n\n    vaultAsset: address = vaultWallet.VAULT_ASSET\n    balance: uint256 = staticcall IERC20(vaultAsset).balanceOf(self)\n    assert balance != 0 # dev: no balance\n\n    assert extcall IERC20(vaultAsset).transfer(governance, balance, default_return_value=True) # dev: transfer failed\n    log LeftoversSwept(amount=balance, recipient=governance)\n    return balance",
            "sha256sum": "cb75bb865f4249183299e0bdebea28ac60571a587d0d55a251b55f12c32f131c"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/vaults/EarnVault.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.3+commit.bff19ea2",
        "integrity": "9812de03d8c6316da14cd804ef506a741441b8f548a8b56593f5295a4873aaa6"
      },
      "args": "0000000000000000000000000b3e328455c4059eeb9e3f84b5543f74e24e7e1b00000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000012000000000000000000000000044cf3c4f000dfd76a35d03298049d37be688d6f90000000000000000000000000000000000000000000000000000000000000e10000000000000000000000000000000000000000000000000000000000013c6800000000000000000000000008d6dd438b9748dca269033a01b1581ee8ef21e3b000000000000000000000000000000000000000000000000000000000000001c556e64657273636f726520426c75652043686970205669727475616c00000000000000000000000000000000000000000000000000000000000000000000000b756e64795669727475616c000000000000000000000000000000000000000000",
      "file": "contracts/vaults/EarnVault.vy"
    },
    "ExtraFi": {
      "address": "0x92D446F251D214c982c4371513355739634D4465",
      "abi": [
        {
          "name": "ExtraFiDeposit",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountDeposited",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultTokenAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "ExtraFiWithdrawal",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultTokenAmountBurned",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetOpportunityAdded",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultAddr",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LegoPauseModified",
          "inputs": [
            {
              "name": "isPaused",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LegoFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "balance",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "SnapShotPriceConfigSet",
          "inputs": [
            {
              "name": "minSnapshotDelay",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "maxNumSnapshots",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "maxUpsideDeviation",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "staleTime",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetOpportunityRemoved",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultAddr",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PricePerShareSnapShotAdded",
          "inputs": [
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "totalSupply",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "pricePerShare",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "lastAveragePricePerShare",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddys",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "undyToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "hatchery",
                  "type": "address"
                },
                {
                  "name": "lootDistributor",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                },
                {
                  "name": "walletBackpack",
                  "type": "address"
                },
                {
                  "name": "billing",
                  "type": "address"
                },
                {
                  "name": "vaultRegistry",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUndyHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isLegoAsset",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssetOpportunities",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isAssetOpportunity",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getNumLegoAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pause",
          "inputs": [
            {
              "name": "_shouldPause",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFundsMany",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_assets",
              "type": "address[]"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getWeightedPricePerShare",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLatestSnapshot",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_pricePerShare",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "totalSupply",
                  "type": "uint256"
                },
                {
                  "name": "pricePerShare",
                  "type": "uint256"
                },
                {
                  "name": "lastUpdate",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setSnapShotPriceConfig",
          "inputs": [
            {
              "name": "_config",
              "type": "tuple",
              "components": [
                {
                  "name": "minSnapshotDelay",
                  "type": "uint256"
                },
                {
                  "name": "maxNumSnapshots",
                  "type": "uint256"
                },
                {
                  "name": "maxUpsideDeviation",
                  "type": "uint256"
                },
                {
                  "name": "staleTime",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidPriceConfig",
          "inputs": [
            {
              "name": "_config",
              "type": "tuple",
              "components": [
                {
                  "name": "minSnapshotDelay",
                  "type": "uint256"
                },
                {
                  "name": "maxNumSnapshots",
                  "type": "uint256"
                },
                {
                  "name": "maxUpsideDeviation",
                  "type": "uint256"
                },
                {
                  "name": "staleTime",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "vaultToAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "underlyingAsset",
                  "type": "address"
                },
                {
                  "name": "decimals",
                  "type": "uint256"
                },
                {
                  "name": "lastAveragePricePerShare",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assetOpportunities",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAssetOpportunity",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssetOpportunities",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assets",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "snapShotData",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "lastSnapShot",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "totalSupply",
                      "type": "uint256"
                    },
                    {
                      "name": "pricePerShare",
                      "type": "uint256"
                    },
                    {
                      "name": "lastUpdate",
                      "type": "uint256"
                    }
                  ]
                },
                {
                  "name": "nextIndex",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "snapShots",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "totalSupply",
                  "type": "uint256"
                },
                {
                  "name": "pricePerShare",
                  "type": "uint256"
                },
                {
                  "name": "lastUpdate",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "snapShotPriceConfig",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "minSnapshotDelay",
                  "type": "uint256"
                },
                {
                  "name": "maxNumSnapshots",
                  "type": "uint256"
                },
                {
                  "name": "maxUpsideDeviation",
                  "type": "uint256"
                },
                {
                  "name": "staleTime",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isPaused",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasCapability",
          "inputs": [
            {
              "name": "_action",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRegistries",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isYieldLego",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isDexLego",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAsset",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingBalances",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenBalance",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAmount",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAmountSafe",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenBalance",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingData",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingData",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            },
            {
              "name": "_appraiser",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValueOfVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValueOfVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            },
            {
              "name": "_appraiser",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isRebasing",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPricePerShare",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPricePerShare",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_decimals",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getVaultTokenAmount",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_assetAmount",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalAssets",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalBorrows",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAvailLiquidity",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUtilizationRatio",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isEligibleForYieldBonus",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getWithdrawalFees",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canRegisterVaultToken",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "registerVaultTokenLocally",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_reserveId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "underlyingAsset",
                  "type": "address"
                },
                {
                  "name": "decimals",
                  "type": "uint256"
                },
                {
                  "name": "lastAveragePricePerShare",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "deregisterVaultTokenLocally",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "registerVaultTokensGlobally",
          "inputs": [
            {
              "name": "_vaultTokens",
              "type": "address[]"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addPriceSnapshot",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositForYield",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositForYield",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawFromYield",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawFromYield",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAccessForLego",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_action",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "string"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimIncentives",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_proofs",
              "type": "bytes32[]"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimIncentives",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_proofs",
              "type": "bytes32[]"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasClaimableRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_tokenPath",
              "type": "address[]"
            },
            {
              "name": "_poolPath",
              "type": "address[]"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_tokenPath",
              "type": "address[]"
            },
            {
              "name": "_poolPath",
              "type": "address[]"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_tokenInAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_tokenInAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmMintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmMintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_borrowAsset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_borrowAsset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_paymentAsset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_paymentAsset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "vaultTokenToReserveId",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "EXTRAFI_POOL",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "RIPE_REGISTRY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_undyHq",
              "type": "address"
            },
            {
              "name": "_extraFiPool",
              "type": "address"
            },
            {
              "name": "_ripeRegistry",
              "type": "address"
            },
            {
              "name": "_reserveIds",
              "type": "uint256[]"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "interfaces/WalletStructs.vyi": {
            "content": "# @version 0.4.3\n\nflag ActionType:\n    TRANSFER\n    EARN_DEPOSIT\n    EARN_WITHDRAW\n    EARN_REBALANCE\n    SWAP\n    MINT_REDEEM\n    CONFIRM_MINT_REDEEM\n    ADD_COLLATERAL\n    REMOVE_COLLATERAL\n    BORROW\n    REPAY_DEBT\n    REWARDS\n    ETH_TO_WETH\n    WETH_TO_ETH\n    ADD_LIQ\n    REMOVE_LIQ\n    ADD_LIQ_CONC\n    REMOVE_LIQ_CONC\n    PAY_CHEQUE\n\nstruct WalletAssetData:\n    assetBalance: uint256\n    usdValue: uint256\n    isYieldAsset: bool\n    lastPricePerShare: uint256\n\nstruct ActionData:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    billing: address\n    vaultRegistry: address\n    wallet: address\n    walletConfig: address\n    walletOwner: address\n    inEjectMode: bool\n    isFrozen: bool\n    lastTotalUsdValue: uint256\n    signer: address\n    isManager: bool\n    legoId: uint256\n    legoAddr: address\n    eth: address\n    weth: address\n\nstruct MiniAddys:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    appraiser: address",
            "sha256sum": "466493c129135c95470aaf70eeddc936632f7b0f813396e5a7ddc03bea9da518"
          },
          "interfaces/LegoPartner.vyi": {
            "content": "# @version 0.4.3\n\nfrom interfaces import WalletStructs as ws\n\nMAX_TOKEN_PATH: constant(uint256) = 5\nMAX_RECOVER_ASSETS: constant(uint256) = 20\nMAX_PROOFS: constant(uint256) = 25\n\n@external\ndef addLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _tickLower: int24, _tickUpper: int24, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef addLiquidity(_pool: address, _tokenA: address, _tokenB: address, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _minLpAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (address, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef removeLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _liqToRemove: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef removeLiquidity(_pool: address, _tokenA: address, _tokenB: address, _lpToken: address, _lpAmount: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef mintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _tokenInAmount: uint256, _minAmountOut: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef swapTokens(_amountIn: uint256, _minAmountOut: uint256, _tokenPath: DynArray[address, MAX_TOKEN_PATH], _poolPath: DynArray[address, MAX_TOKEN_PATH - 1], _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256):\n    ...\n\n@external\ndef depositForYield(_asset: address, _amount: uint256, _vaultAddr: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef withdrawFromYield(_vaultToken: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef confirmMintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef borrow(_borrowAsset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef repayDebt(_paymentAsset: address, _paymentAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef claimIncentives(_user: address, _rewardToken: address, _rewardAmount: uint256, _proofs: DynArray[bytes32, MAX_PROOFS], _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef removeCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef addCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@view\n@external\ndef getAccessForLego(_user: address, _action: ws.ActionType) -> (address, String[64], uint256):\n    ...\n\n@view\n@external\ndef hasCapability(_action: ws.ActionType) -> bool:\n    ...\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    ...\n\n@view\n@external\ndef isYieldLego() -> bool:\n    ...\n\n@view\n@external\ndef isDexLego() -> bool:\n    ...\n\n\n# common\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "f2afb7bd72d4301aea77bbe4177b7ae954ba6f6b76af363965993eb92ad0b715"
          },
          "interfaces/LegoStructs.vyi": {
            "content": "# @version 0.4.3\n\nstruct VaultTokenInfo:\n    underlyingAsset: address\n    decimals: uint256\n    lastAveragePricePerShare: uint256\n\nstruct SnapShotPriceConfig:\n    minSnapshotDelay: uint256\n    maxNumSnapshots: uint256\n    maxUpsideDeviation: uint256\n    staleTime: uint256\n\nstruct SingleSnapShot:\n    totalSupply: uint256\n    pricePerShare: uint256\n    lastUpdate: uint256\n\nstruct SnapShotData:\n    lastSnapShot: SingleSnapShot\n    nextIndex: uint256\n",
            "sha256sum": "8ae48be17d812d57fbd671bbf0593e8abf175ad0924e47c5997823cac19ec806"
          },
          "interfaces/YieldLego.vyi": {
            "content": "# @version 0.4.3\n\nfrom interfaces import LegoStructs as ls\n\n\n###################\n# Underlying Data #\n###################\n\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    ...\n\n\n@view\n@external\ndef getUnderlyingBalances(_vaultToken: address, _vaultTokenBalance: uint256) -> (uint256, uint256):\n    ...\n\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    ...\n\n\n@view\n@external\ndef getUnderlyingAmountSafe(_vaultToken: address, _vaultTokenBalance: uint256) -> uint256:\n    ...\n\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> (address, uint256, uint256):\n    ...\n\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> uint256:\n    ...\n\n\n###############\n# Other Utils #\n###############\n\n\n@view\n@external\ndef isRebasing() -> bool:\n    ...\n\n\n@view\n@external\ndef getPricePerShare(_vaultToken: address, _decimals: uint256 = 0) -> uint256:\n    ...\n\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef canRegisterVaultToken(_asset: address, _vaultToken: address) -> bool:\n    ...\n\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef getUtilizationRatio(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef getAvailLiquidity(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef isEligibleForYieldBonus(_asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef getWithdrawalFees(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    ...\n\n\n###################\n# Yield Lego Data #\n###################\n\n\n@view\n@external\ndef isLegoAsset(_asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, 40]:\n    ...\n\n\n@view\n@external\ndef getAssets() -> DynArray[address, 20]:\n    ...\n\n\n@view\n@external\ndef isAssetOpportunity(_asset: address, _vaultAddr: address) -> bool:\n    ...\n\n\n@view\n@external\ndef getNumLegoAssets() -> uint256:\n    ...\n\n\n@view\n@external\ndef assets(_index: uint256) -> address:\n    ...\n\n\n@view\n@external\ndef indexOfAsset(_asset: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef numAssets() -> uint256:\n    ...\n\n\n@view\n@external\ndef assetOpportunities(_asset: address, _index: uint256) -> address:\n    ...\n\n\n@view\n@external\ndef indexOfAssetOpportunity(_asset: address, _vaultAddr: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef numAssetOpportunities(_asset: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef vaultToAsset(_vaultAddr: address) -> ls.VaultTokenInfo:\n    ...\n\n\n# price snapshots\n\n\n@external\ndef addPriceSnapshot(_vaultToken: address) -> bool:\n    ...\n\n\n@view\n@external\ndef snapShotPriceConfig() -> ls.SnapShotPriceConfig:\n    ...\n\n\n@view\n@external\ndef snapShotData(_vaultToken: address) -> ls.SnapShotData:\n    ...\n\n\n@view\n@external\ndef snapShots(_vaultToken: address, _index: uint256) -> ls.SingleSnapShot:\n    ...\n\n\n@view\n@external\ndef getWeightedPricePerShare(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef getLatestSnapshot(_vaultToken: address, _pricePerShare: uint256) -> ls.SingleSnapShot:\n    ...\n\n\n@external\ndef setSnapShotPriceConfig(_config: ls.SnapShotPriceConfig):\n    ...\n",
            "sha256sum": "db91c139f6018f5218b389d08c8703bc16fb994aa948805dbfea27e072f382ec"
          },
          "contracts/modules/Addys.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\ninterface UndyHq:\n    def isValidAddr(_addr: address) -> bool: view\n    def getAddr(_regId: uint256) -> address: view\n    def undyToken() -> address: view\n\ninterface Switchboard:\n    def isSwitchboardAddr(_addr: address) -> bool: view\n\ninterface LegoBook:\n    def isLegoAddr(_addr: address) -> bool: view\n\nstruct Addys:\n    hq: address\n    undyToken: address\n    ledger: address\n    missionControl: address\n    legoBook: address\n    switchboard: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    walletBackpack: address\n    billing: address\n    vaultRegistry: address\n\n# hq\nUNDY_HQ_FOR_ADDYS: immutable(address)\n\n# core addys\nLEDGER_ID: constant(uint256) = 1\nMISSION_CONTROL_ID: constant(uint256) = 2\nLEGO_BOOK_ID: constant(uint256) = 3\nSWITCHBOARD_ID: constant(uint256) = 4\nHATCHERY_ID: constant(uint256) = 5\nLOOT_DISTRIBUTOR_ID: constant(uint256) = 6\nAPPRAISER_ID: constant(uint256) = 7\nWALLET_BACKPACK_ID: constant(uint256) = 8\nBILLING_ID: constant(uint256) = 9\nVAULT_REGISTRY_ID: constant(uint256) = 10\n\n\n@deploy\ndef __init__(_undyHq: address):\n    assert _undyHq != empty(address) # dev: invalid undy hq\n    UNDY_HQ_FOR_ADDYS = _undyHq\n\n\n########\n# Core #\n########\n\n\n@view\n@external\ndef getAddys() -> Addys:\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _getAddys(_addys: Addys = empty(Addys)) -> Addys:\n    if _addys.hq != empty(address):\n        return _addys\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _generateAddys() -> Addys:\n    hq: address = UNDY_HQ_FOR_ADDYS\n    return Addys(\n        hq = hq,\n        undyToken = staticcall UndyHq(hq).undyToken(),\n        ledger = staticcall UndyHq(hq).getAddr(LEDGER_ID),\n        missionControl = staticcall UndyHq(hq).getAddr(MISSION_CONTROL_ID),\n        legoBook = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID),\n        switchboard = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID),\n        hatchery = staticcall UndyHq(hq).getAddr(HATCHERY_ID),\n        lootDistributor = staticcall UndyHq(hq).getAddr(LOOT_DISTRIBUTOR_ID),\n        appraiser = staticcall UndyHq(hq).getAddr(APPRAISER_ID),\n        walletBackpack = staticcall UndyHq(hq).getAddr(WALLET_BACKPACK_ID),\n        billing = staticcall UndyHq(hq).getAddr(BILLING_ID),\n        vaultRegistry = staticcall UndyHq(hq).getAddr(VAULT_REGISTRY_ID),\n    )\n\n\n##########\n# Tokens #\n##########\n\n\n@view\n@internal\ndef _getUndyToken() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).undyToken()\n\n\n###########\n# Helpers #\n###########\n\n\n# undy hq\n\n\n@view\n@external\ndef getUndyHq() -> address:\n    return self._getUndyHq()\n\n\n@view\n@internal\ndef _getUndyHq() -> address:\n    return UNDY_HQ_FOR_ADDYS\n\n\n# utils\n\n\n@view\n@internal\ndef _isValidUndyAddr(_addr: address, _hq: address = empty(address)) -> bool:\n    hq: address = _hq\n    if _hq == empty(address):\n        hq = UNDY_HQ_FOR_ADDYS\n    \n    # core departments\n    if staticcall UndyHq(hq).isValidAddr(_addr):\n        return True\n\n    # lego book\n    legoBook: address = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID)\n    if legoBook != empty(address) and staticcall LegoBook(legoBook).isLegoAddr(_addr):\n        return True\n\n    # switchboard config\n    switchboard: address = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID)\n    if switchboard != empty(address) and staticcall Switchboard(switchboard).isSwitchboardAddr(_addr):\n        return True\n\n    return False\n\n\n@view\n@internal\ndef _isSwitchboardAddr(_addr: address) -> bool:\n    switchboard: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n    if switchboard == empty(address):\n        return False\n    return staticcall Switchboard(switchboard).isSwitchboardAddr(_addr)\n\n\n@view\n@internal\ndef _isLegoBookAddr(_addr: address) -> bool:\n    legoBook: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n    if legoBook == empty(address):\n        return False\n    return staticcall LegoBook(legoBook).isLegoAddr(_addr)\n\n\n###############\n# Departments #\n###############\n\n\n# ledger\n\n\n@view\n@internal\ndef _getLedgerId() -> uint256:\n    return LEDGER_ID\n\n\n@view\n@internal\ndef _getLedgerAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEDGER_ID)\n\n\n# mission control\n\n\n@view\n@internal\ndef _getMissionControlId() -> uint256:\n    return MISSION_CONTROL_ID\n\n\n@view\n@internal\ndef _getMissionControlAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(MISSION_CONTROL_ID)\n\n\n# lego book\n\n\n@view\n@internal\ndef _getLegoBookId() -> uint256:\n    return LEGO_BOOK_ID\n\n\n@view\n@internal\ndef _getLegoBookAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n\n\n# switchboard\n\n\n@view\n@internal\ndef _getSwitchboardId() -> uint256:\n    return SWITCHBOARD_ID\n\n\n@view\n@internal\ndef _getSwitchboardAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n\n\n# hatchery\n\n\n@view\n@internal\ndef _getHatcheryId() -> uint256:\n    return HATCHERY_ID\n\n\n@view\n@internal\ndef _getHatcheryAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(HATCHERY_ID)\n\n\n# loot distributor\n\n\n@view\n@internal\ndef _getLootDistributorId() -> uint256:\n    return LOOT_DISTRIBUTOR_ID\n\n\n@view\n@internal\ndef _getLootDistributorAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LOOT_DISTRIBUTOR_ID)\n\n\n# appraiser\n\n\n@view\n@internal\ndef _getAppraiserId() -> uint256:\n    return APPRAISER_ID\n\n\n@view\n@internal\ndef _getAppraiserAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(APPRAISER_ID)\n\n\n# wallet backpack\n\n\n@view\n@internal\ndef _getWalletBackpackId() -> uint256:\n    return WALLET_BACKPACK_ID\n\n\n@view\n@internal\ndef _getWalletBackpackAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(WALLET_BACKPACK_ID)\n\n\n# billing\n\n\n@view\n@internal\ndef _getBillingId() -> uint256:\n    return BILLING_ID\n\n\n@view\n@internal\ndef _getBillingAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(BILLING_ID)\n\n\n# vault registry\n\n\n@view\n@internal\ndef _getVaultRegistryId() -> uint256:\n    return VAULT_REGISTRY_ID\n\n\n@view\n@internal\ndef _getVaultRegistryAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(VAULT_REGISTRY_ID)",
            "sha256sum": "4df6b72db9bb417d1af81660175be1450cfb7b3575f3d17a5b8a130bff87b781"
          },
          "contracts/modules/YieldLegoData.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nuses: addys\n\nimport contracts.modules.Addys as addys\n\nfrom interfaces import WalletStructs as ws\nfrom interfaces import LegoStructs as ls\nfrom ethereum.ercs import IERC20\nfrom ethereum.ercs import IERC20Detailed\n\nevent AssetOpportunityAdded:\n    asset: indexed(address)\n    vaultAddr: indexed(address)\n\nevent AssetOpportunityRemoved:\n    asset: indexed(address)\n    vaultAddr: indexed(address)\n\nevent LegoPauseModified:\n    isPaused: bool\n\nevent LegoFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    balance: uint256\n\nevent PricePerShareSnapShotAdded:\n    vaultToken: indexed(address)\n    totalSupply: uint256\n    pricePerShare: uint256\n    lastAveragePricePerShare: uint256\n\nevent SnapShotPriceConfigSet:\n    minSnapshotDelay: uint256\n    maxNumSnapshots: uint256\n    maxUpsideDeviation: uint256\n    staleTime: uint256\n\n# core\nvaultToAsset: public(HashMap[address, ls.VaultTokenInfo]) # vault addr -> data\n\n# asset opportunities\nassetOpportunities: public(HashMap[address, HashMap[uint256, address]]) # asset -> index -> vault addr\nindexOfAssetOpportunity: public(HashMap[address, HashMap[address, uint256]]) # asset -> vault addr -> index\nnumAssetOpportunities: public(HashMap[address, uint256]) # asset -> number of opportunities\n\n# lego assets (iterable)\nassets: public(HashMap[uint256, address]) # index -> asset\nindexOfAsset: public(HashMap[address, uint256]) # asset -> index\nnumAssets: public(uint256) # num assets\n\n# price snapshots\nsnapShotData: public(HashMap[address, ls.SnapShotData]) # vault token -> data\nsnapShots: public(HashMap[address, HashMap[uint256, ls.SingleSnapShot]]) # vault token -> index -> snapshot\nsnapShotPriceConfig: public(ls.SnapShotPriceConfig) # config\n\nisPaused: public(bool)\n\nMAX_VAULTS: constant(uint256) = 40\nMAX_ASSETS: constant(uint256) = 20\nMAX_RECOVER_ASSETS: constant(uint256) = 20\nONE_DAY_SECONDS: constant(uint256) = 60 * 60 * 24\nONE_WEEK_SECONDS: constant(uint256) = ONE_DAY_SECONDS * 7\nHUNDRED_PERCENT: constant(uint256) = 100_00\n\n\n@deploy\ndef __init__(_shouldPause: bool):\n    self.isPaused = _shouldPause\n    self.numAssets = 1 # not using 0 index\n\n    # default snapshot price config\n    self.snapShotPriceConfig = ls.SnapShotPriceConfig(\n        minSnapshotDelay = 60 * 10, # 10 minutes\n        maxNumSnapshots = 20,\n        maxUpsideDeviation = 10_00, # 10%\n        staleTime = ONE_DAY_SECONDS, # 1 day\n    )\n\n\n#########\n# Views #\n#########\n\n\n# is lego asset\n\n\n@view\n@external\ndef isLegoAsset(_asset: address) -> bool:\n    return self._isLegoAsset(_asset)\n\n\n@view\n@internal\ndef _isLegoAsset(_asset: address) -> bool:\n    return self.indexOfAsset[_asset] != 0\n\n\n# vault opportunities\n\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, MAX_VAULTS]:\n    numOpportunities: uint256 = self.numAssetOpportunities[_asset]\n    if numOpportunities == 0:\n        return []\n    opportunities: DynArray[address, MAX_VAULTS] = []\n    for i: uint256 in range(1, numOpportunities, bound=MAX_VAULTS):\n        opportunities.append(self.assetOpportunities[_asset][i])\n    return opportunities\n\n\n# all assets registered\n\n\n@view\n@external\ndef getAssets() -> DynArray[address, MAX_ASSETS]:\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return []\n    assets: DynArray[address, MAX_ASSETS] = []\n    for i: uint256 in range(1, numAssets, bound=MAX_ASSETS):\n        assets.append(self.assets[i])\n    return assets\n\n\n################\n# Registration #\n################\n\n\n@view\n@external\ndef isAssetOpportunity(_asset: address, _vaultAddr: address) -> bool:\n    return self._isAssetOpportunity(_asset, _vaultAddr)\n\n\n@view\n@internal\ndef _isAssetOpportunity(_asset: address, _vaultAddr: address) -> bool:\n    return self.indexOfAssetOpportunity[_asset][_vaultAddr] != 0\n\n\n# add asset opportunity\n\n\n@internal\ndef _addAssetOpportunity(_asset: address, _vaultAddr: address) -> ls.VaultTokenInfo:\n    if self.indexOfAssetOpportunity[_asset][_vaultAddr] != 0:\n        return self.vaultToAsset[_vaultAddr]\n\n    if empty(address) in [_asset, _vaultAddr]:\n        return empty(ls.VaultTokenInfo)\n\n    # add asset opportunity\n    aid: uint256 = self.numAssetOpportunities[_asset]\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.assetOpportunities[_asset][aid] = _vaultAddr\n    self.indexOfAssetOpportunity[_asset][_vaultAddr] = aid\n    self.numAssetOpportunities[_asset] = aid + 1\n\n    # add mapping\n    vaultInfo: ls.VaultTokenInfo = ls.VaultTokenInfo(\n        underlyingAsset = _asset,\n        decimals = convert(staticcall IERC20Detailed(_vaultAddr).decimals(), uint256),\n        lastAveragePricePerShare = 0,\n    )\n    self.vaultToAsset[_vaultAddr] = vaultInfo\n\n    # add asset\n    self._addAsset(_asset)\n\n    log AssetOpportunityAdded(asset=_asset, vaultAddr=_vaultAddr)\n    return vaultInfo\n\n\n# remove asset opportunity\n\n\n@internal\ndef _removeAssetOpportunity(_asset: address, _vaultAddr: address):\n    numOpportunities: uint256 = self.numAssetOpportunities[_asset]\n    if numOpportunities == 0:\n        return\n\n    targetIndex: uint256 = self.indexOfAssetOpportunity[_asset][_vaultAddr]\n    if targetIndex == 0:\n        return\n\n    # update data\n    lastIndex: uint256 = numOpportunities - 1\n    self.numAssetOpportunities[_asset] = lastIndex\n    self.indexOfAssetOpportunity[_asset][_vaultAddr] = 0\n\n    self.vaultToAsset[_vaultAddr] = empty(ls.VaultTokenInfo)\n\n    # clear all snapshot data for the vault token to prevent contamination on re-add\n    self.snapShotData[_vaultAddr] = empty(ls.SnapShotData)\n\n    # clear all historical snapshots\n    config: ls.SnapShotPriceConfig = self.snapShotPriceConfig\n    for i: uint256 in range(config.maxNumSnapshots, bound=max_value(uint256)):\n        if i >= config.maxNumSnapshots:\n            break\n        self.snapShots[_vaultAddr][i] = empty(ls.SingleSnapShot)\n\n    # shift to replace the removed one\n    if targetIndex != lastIndex:\n        lastVaultAddr: address = self.assetOpportunities[_asset][lastIndex]\n        self.assetOpportunities[_asset][targetIndex] = lastVaultAddr\n        self.indexOfAssetOpportunity[_asset][lastVaultAddr] = targetIndex\n\n    # remove asset\n    if lastIndex <= 1:\n        self._removeAsset(_asset)\n\n    log AssetOpportunityRemoved(asset=_asset, vaultAddr=_vaultAddr)\n\n\n# add asset\n\n\n@internal\ndef _addAsset(_asset: address):\n    if self.indexOfAsset[_asset] != 0:\n        return\n\n    aid: uint256 = self.numAssets\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.assets[aid] = _asset\n    self.indexOfAsset[_asset] = aid\n    self.numAssets = aid + 1\n\n\n# remove asset\n\n\n@internal\ndef _removeAsset(_asset: address):\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return\n\n    targetIndex: uint256 = self.indexOfAsset[_asset]\n    if targetIndex == 0:\n        return\n\n    # update data\n    lastIndex: uint256 = numAssets - 1\n    self.numAssets = lastIndex\n    self.indexOfAsset[_asset] = 0\n\n    # shift to replace the removed one\n    if targetIndex != lastIndex:\n        lastAsset: address = self.assets[lastIndex]\n        self.assets[targetIndex] = lastAsset\n        self.indexOfAsset[lastAsset] = targetIndex\n\n\n# num lego assets (true number, use `numAssets` for iteration)\n\n\n@view\n@external\ndef getNumLegoAssets() -> uint256:\n    return self._getNumLegoAssets()\n\n\n@view\n@internal\ndef _getNumLegoAssets() -> uint256:\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return 0\n    return numAssets - 1\n\n\n###########\n# General #\n###########\n\n\n# fill mini addys\n\n\n@view\n@internal\ndef _getMiniAddys(_miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> ws.MiniAddys:\n    if _miniAddys.ledger != empty(address):\n        return _miniAddys\n    return ws.MiniAddys(\n        ledger = addys._getLedgerAddr(),\n        missionControl = addys._getMissionControlAddr(),\n        legoBook = addys._getLegoBookAddr(),\n        appraiser = addys._getAppraiserAddr(),\n    )\n\n\n# activate\n\n\n@external\ndef pause(_shouldPause: bool):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert _shouldPause != self.isPaused # dev: no change\n    self.isPaused = _shouldPause\n    log LegoPauseModified(isPaused=_shouldPause)\n\n\n# recover funds\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    self._recoverFunds(_recipient, _asset)\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, MAX_RECOVER_ASSETS]):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    for a: address in _assets:\n        self._recoverFunds(_recipient, a)\n\n\n@internal\ndef _recoverFunds(_recipient: address, _asset: address):\n    assert empty(address) not in [_recipient, _asset] # dev: invalid recipient or asset\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    assert balance != 0 # dev: nothing to recover\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log LegoFundsRecovered(asset=_asset, recipient=_recipient, balance=balance)\n\n\n###################\n# Price Snapshots #\n###################\n\n\n# add price snapshot\n\n\n@internal\ndef _addPriceSnapshot(_vaultToken: address, _pricePerShare: uint256, _vaultTokenDecimals: uint256) -> bool:\n    config: ls.SnapShotPriceConfig = self.snapShotPriceConfig\n    if config.maxNumSnapshots == 0:\n        return False\n\n    data: ls.SnapShotData = self.snapShotData[_vaultToken]\n\n    # already have snapshot for this time\n    if data.lastSnapShot.lastUpdate == block.timestamp:\n        return False\n\n    # check if snapshot is too recent\n    if data.lastSnapShot.lastUpdate + config.minSnapshotDelay > block.timestamp:\n        return False\n\n    # create and store new snapshot\n    newSnapshot: ls.SingleSnapShot = self._getLatestSnapshot(_vaultToken, _pricePerShare, _vaultTokenDecimals, data.lastSnapShot, config)\n    data.lastSnapShot = newSnapshot\n    self.snapShots[_vaultToken][data.nextIndex] = newSnapshot\n\n    # update index\n    data.nextIndex += 1\n    if data.nextIndex >= config.maxNumSnapshots:\n        data.nextIndex = 0\n\n    # save snap shot data\n    self.snapShotData[_vaultToken] = data\n\n    # update cached weighted average price per share\n    lastAveragePricePerShare: uint256 = self._getWeightedPricePerShare(_vaultToken, _pricePerShare)\n    self.vaultToAsset[_vaultToken].lastAveragePricePerShare = lastAveragePricePerShare\n\n    log PricePerShareSnapShotAdded(\n        vaultToken = _vaultToken,\n        totalSupply = newSnapshot.totalSupply,\n        pricePerShare = newSnapshot.pricePerShare,\n        lastAveragePricePerShare = lastAveragePricePerShare,\n    )\n    return True\n\n\n# weighted price per share\n\n\n@view\n@external\ndef getWeightedPricePerShare(_vaultToken: address) -> uint256:\n    data: ls.SnapShotData = self.snapShotData[_vaultToken]\n    return self._getWeightedPricePerShare(_vaultToken, data.lastSnapShot.pricePerShare)\n\n\n@view\n@internal\ndef _getWeightedPricePerShare(_vaultToken: address, _lastPricePerShare: uint256) -> uint256:\n    config: ls.SnapShotPriceConfig = self.snapShotPriceConfig\n    if config.maxNumSnapshots == 0:\n        return 0\n\n    # calculate weighted average price using all valid snapshots\n    numerator: uint256 = 0\n    denominator: uint256 = 0\n    for i: uint256 in range(config.maxNumSnapshots, bound=max_value(uint256)):\n\n        snapShot: ls.SingleSnapShot = self.snapShots[_vaultToken][i]\n        if snapShot.pricePerShare == 0 or snapShot.totalSupply == 0 or snapShot.lastUpdate == 0:\n            continue\n\n        # too stale, skip\n        if config.staleTime != 0 and block.timestamp > snapShot.lastUpdate + config.staleTime:\n            continue\n\n        numerator += (snapShot.totalSupply * snapShot.pricePerShare)\n        denominator += snapShot.totalSupply\n\n    # weighted price per share\n    weightedPricePerShare: uint256 = 0\n    if numerator != 0:\n        weightedPricePerShare = numerator // denominator\n    else:\n        weightedPricePerShare = _lastPricePerShare\n\n    return weightedPricePerShare\n\n\n# latest snapshot\n\n\n@view\n@external\ndef getLatestSnapshot(_vaultToken: address, _pricePerShare: uint256) -> ls.SingleSnapShot:\n    data: ls.SnapShotData = self.snapShotData[_vaultToken]\n    config: ls.SnapShotPriceConfig = self.snapShotPriceConfig\n    vaultTokenDecimals: uint256 = self.vaultToAsset[_vaultToken].decimals\n    return self._getLatestSnapshot(_vaultToken, _pricePerShare, vaultTokenDecimals, data.lastSnapShot, config)\n\n\n@view\n@internal\ndef _getLatestSnapshot(\n    _vaultToken: address,\n    _pricePerShare: uint256,\n    _vaultTokenDecimals: uint256,\n    _lastSnapShot: ls.SingleSnapShot,\n    _config: ls.SnapShotPriceConfig,\n) -> ls.SingleSnapShot:\n\n    # total supply (adjusted)\n    totalSupply: uint256 = staticcall IERC20(_vaultToken).totalSupply() // (10 ** _vaultTokenDecimals)\n    if totalSupply == 0:\n        totalSupply = 1\n\n    # throttle upside (extra safety check)\n    pricePerShare: uint256 = self._throttleUpside(_pricePerShare, _lastSnapShot.pricePerShare, _config.maxUpsideDeviation)\n\n    return ls.SingleSnapShot(\n        totalSupply = totalSupply,\n        pricePerShare = pricePerShare,\n        lastUpdate = block.timestamp,\n    )\n\n\n@view\n@internal\ndef _throttleUpside(_newValue: uint256, _prevValue: uint256, _maxUpside: uint256) -> uint256:\n    if _maxUpside == 0 or _prevValue == 0 or _newValue == 0:\n        return _newValue\n    maxPricePerShare: uint256 = _prevValue + (_prevValue * _maxUpside // HUNDRED_PERCENT)\n    return min(_newValue, maxPricePerShare)\n\n\n# snapshot price config\n\n\n@external\ndef setSnapShotPriceConfig(_config: ls.SnapShotPriceConfig):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert self._isValidPriceConfig(_config) # dev: invalid config\n    self.snapShotPriceConfig = _config\n    log SnapShotPriceConfigSet(\n        minSnapshotDelay=_config.minSnapshotDelay,\n        maxNumSnapshots=_config.maxNumSnapshots,\n        maxUpsideDeviation=_config.maxUpsideDeviation,\n        staleTime=_config.staleTime\n    )\n\n\n@view\n@external\ndef isValidPriceConfig(_config: ls.SnapShotPriceConfig) -> bool:\n    return self._isValidPriceConfig(_config)\n\n\n@view\n@internal\ndef _isValidPriceConfig(_config: ls.SnapShotPriceConfig) -> bool:\n    if _config.minSnapshotDelay > ONE_WEEK_SECONDS:\n        return False\n    if _config.maxNumSnapshots == 0 or _config.maxNumSnapshots > 25:\n        return False\n    if _config.maxUpsideDeviation > HUNDRED_PERCENT:\n        return False\n    return _config.staleTime < ONE_WEEK_SECONDS",
            "sha256sum": "50440c96dc8a7af22e7ad927bb6d3e308f137d5d3632e633e084b05510c94c28"
          },
          "contracts/legos/yield/ExtraFi.vy": {
            "content": "#     __   __ ___ _______ ___     ______       ___     _______ _______ _______ \n#    |  | |  |   |       |   |   |      |     |   |   |       |       |       |\n#    |  |_|  |   |    ___|   |   |  _    |    |   |   |    ___|    ___|   _   |\n#    |       |   |   |___|   |   | | |   |    |   |   |   |___|   | __|  | |  |\n#    |_     _|   |    ___|   |___| |_|   |    |   |___|    ___|   ||  |  |_|  |\n#      |   | |   |   |___|       |       |    |       |   |___|   |_| |       |\n#      |___| |___|_______|_______|______|     |_______|_______|_______|_______|\n#                                                                       \n#     \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n#     \u2551  ** ExtraFi Lego **                     \u2551\n#     \u2551  Integration with ExtraFi Protocol.     \u2551\n#     \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n#\n#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nimplements: Lego\nimplements: YieldLego\n\nexports: addys.__interface__\nexports: yld.__interface__\n\ninitializes: addys\ninitializes: yld[addys := addys]\n\nfrom interfaces import LegoPartner as Lego\nfrom interfaces import YieldLego as YieldLego\nfrom interfaces import WalletStructs as ws\nfrom interfaces import LegoStructs as ls\n\nimport contracts.modules.Addys as addys\nimport contracts.modules.YieldLegoData as yld\n\nfrom ethereum.ercs import IERC20\nfrom ethereum.ercs import IERC20Detailed\n\ninterface ExtraFiPool:\n    def redeem(_reserveId: uint256, _eTokenAmount: uint256, _recipient: address, _receiveNativeETH: bool) -> uint256: nonpayable\n    def deposit(_reserveId: uint256, _amount: uint256, _onBehalfOf: address, _referralCode: uint16) -> uint256: payable\n    def getUnderlyingTokenAddress(_reserveId: uint256) -> address: view\n    def totalLiquidityOfReserve(_reserveId: uint256) -> uint256: view\n    def totalBorrowsOfReserve(_reserveId: uint256) -> uint256: view\n    def exchangeRateOfReserve(_reserveId: uint256) -> uint256: view\n    def getETokenAddress(_reserveId: uint256) -> address: view\n\ninterface Ledger:\n    def setVaultToken(_vaultToken: address, _legoId: uint256, _underlyingAsset: address, _decimals: uint256, _isRebasing: bool): nonpayable\n    def isRegisteredVaultToken(_vaultToken: address) -> bool: view\n    def isUserWallet(_user: address) -> bool: view\n\ninterface Registry:\n    def getRegId(_addr: address) -> uint256: view\n    def isValidAddr(_addr: address) -> bool: view\n\ninterface Appraiser:\n    def getUnderlyingUsdValue(_asset: address, _amount: uint256) -> uint256: view\n\ninterface VaultRegistry:\n    def isEarnVault(_vaultAddr: address) -> bool: view\n\nevent ExtraFiDeposit:\n    sender: indexed(address)\n    asset: indexed(address)\n    vaultToken: indexed(address)\n    assetAmountDeposited: uint256\n    usdValue: uint256\n    vaultTokenAmountReceived: uint256\n    recipient: address\n\nevent ExtraFiWithdrawal:\n    sender: indexed(address)\n    asset: indexed(address)\n    vaultToken: indexed(address)\n    assetAmountReceived: uint256\n    usdValue: uint256\n    vaultTokenAmountBurned: uint256\n    recipient: address\n\nvaultTokenToReserveId: public(HashMap[address, uint256]) # vault token -> reserve id\n\nEXTRAFI_POOL: public(immutable(address))\nRIPE_REGISTRY: public(immutable(address))\n\nMAX_TOKEN_PATH: constant(uint256) = 5\nMAX_PROOFS: constant(uint256) = 25\nHUNDRED_PERCENT: constant(uint256) = 100_00\n\n\n@deploy\ndef __init__(_undyHq: address, _extraFiPool: address, _ripeRegistry: address, _reserveIds: DynArray[uint256, 10]):\n    addys.__init__(_undyHq)\n    yld.__init__(False)\n\n    assert _extraFiPool != empty(address) # dev: invalid addr\n    EXTRAFI_POOL = _extraFiPool\n\n    assert _ripeRegistry != empty(address) # dev: invalid addrs\n    RIPE_REGISTRY = _ripeRegistry\n\n    # register vault tokens for provided reserve ids\n    for rid: uint256 in _reserveIds:\n        asset: address = staticcall ExtraFiPool(_extraFiPool).getUnderlyingTokenAddress(rid)\n        vaultAddr: address = staticcall ExtraFiPool(_extraFiPool).getETokenAddress(rid)\n        assert empty(address) not in [asset, vaultAddr] # dev: invalid reserve id\n        self._registerVaultTokenLocally(asset, vaultAddr, rid)\n\n\n@view\n@external\ndef hasCapability(_action: ws.ActionType) -> bool:\n    return _action in (\n        ws.ActionType.EARN_DEPOSIT | \n        ws.ActionType.EARN_WITHDRAW\n    )\n\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    return [EXTRAFI_POOL]\n\n\n@view\n@external\ndef isYieldLego() -> bool:\n    return True\n\n\n@view\n@external\ndef isDexLego() -> bool:\n    return False\n\n\n###################\n# Underlying Data #\n###################\n\n\n# underlying asset\n\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    return self._getUnderlyingAsset(_vaultToken)\n\n\n@view\n@internal\ndef _getUnderlyingAsset(_vaultToken: address) -> address:\n    return yld.vaultToAsset[_vaultToken].underlyingAsset\n\n\n# underlying balances (both true and safe)\n\n\n@view\n@external\ndef getUnderlyingBalances(_vaultToken: address, _vaultTokenBalance: uint256) -> (uint256, uint256):\n    if _vaultTokenBalance == 0:\n        return 0, 0\n\n    trueUnderlying: uint256 = self._getUnderlyingAmount(_vaultToken, _vaultTokenBalance)\n    safeUnderlying: uint256 = self._getUnderlyingAmountSafe(_vaultToken, _vaultTokenBalance)\n    if safeUnderlying == 0:\n        safeUnderlying = trueUnderlying\n\n    return trueUnderlying, min(trueUnderlying, safeUnderlying)\n\n\n# underlying amount (true)\n\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    return self._getUnderlyingAmount(_vaultToken, _vaultTokenAmount)\n\n\n@view\n@internal\ndef _getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    reserveId: uint256 = self.vaultTokenToReserveId[_vaultToken]\n    if reserveId == 0:\n        return 0\n    return _vaultTokenAmount * staticcall ExtraFiPool(EXTRAFI_POOL).exchangeRateOfReserve(reserveId) // (10 ** 18)\n\n\n# underlying amount (safe)\n\n\n@view\n@external\ndef getUnderlyingAmountSafe(_vaultToken: address, _vaultTokenBalance: uint256) -> uint256:\n    return self._getUnderlyingAmountSafe(_vaultToken, _vaultTokenBalance)\n\n\n@view\n@internal\ndef _getUnderlyingAmountSafe(_vaultToken: address, _vaultTokenBalance: uint256) -> uint256:\n    vaultInfo: ls.VaultTokenInfo = yld.vaultToAsset[_vaultToken]\n    if vaultInfo.decimals == 0:\n        return 0 # not registered\n\n    # safe underlying amount (using cached weighted average from snapshots)\n    return _vaultTokenBalance * vaultInfo.lastAveragePricePerShare // (10 ** vaultInfo.decimals)\n\n\n# underlying data (combined)\n\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> (address, uint256, uint256):\n    return self._getUnderlyingData(_vaultToken, _vaultTokenAmount, _appraiser)\n\n\n@view\n@internal\ndef _getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address) -> (address, uint256, uint256):\n    asset: address = self._getUnderlyingAsset(_vaultToken)\n    if asset == empty(address):\n        return empty(address), 0, 0 # invalid vault token\n    underlyingAmount: uint256 = self._getUnderlyingAmount(_vaultToken, _vaultTokenAmount)\n    usdValue: uint256 = self._getUsdValue(asset, underlyingAmount, _appraiser)\n    return asset, underlyingAmount, usdValue\n\n\n# usd value\n\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> uint256:\n    return self._getUsdValueOfVaultToken(_vaultToken, _vaultTokenAmount, _appraiser)\n\n\n@view\n@internal\ndef _getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address) -> uint256:\n    return self._getUnderlyingData(_vaultToken, _vaultTokenAmount, _appraiser)[2]\n\n\n@view\n@internal\ndef _getUsdValue(_asset: address, _amount: uint256, _appraiser: address) -> uint256:\n    appraiser: address = _appraiser\n    if _appraiser == empty(address):\n        appraiser = addys._getAppraiserAddr()\n    return staticcall Appraiser(appraiser).getUnderlyingUsdValue(_asset, _amount)\n\n\n###############\n# Other Utils #\n###############\n\n\n# basics\n\n\n@view\n@external\ndef isRebasing() -> bool:\n    return self._isRebasing()\n\n\n@view\n@internal\ndef _isRebasing() -> bool:\n    return False\n\n\n# price per share\n\n\n@view\n@external\ndef getPricePerShare(_vaultToken: address, _decimals: uint256 = 0) -> uint256:\n    decimals: uint256 = _decimals\n    if decimals == 0:\n        decimals = yld.vaultToAsset[_vaultToken].decimals\n    if decimals == 0:\n        decimals = convert(staticcall IERC20Detailed(_vaultToken).decimals(), uint256)\n    return self._getPricePerShare(_vaultToken, decimals)\n\n\n@view\n@internal\ndef _getPricePerShare(_vaultToken: address, _decimals: uint256) -> uint256:\n    reserveId: uint256 = self.vaultTokenToReserveId[_vaultToken]\n    if reserveId == 0:\n        return 0\n    return staticcall ExtraFiPool(EXTRAFI_POOL).exchangeRateOfReserve(reserveId) * (10 ** _decimals) // (10 ** 18)\n\n\n# vault token amount\n\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    reserveId: uint256 = self.vaultTokenToReserveId[_vaultToken]\n    if reserveId == 0:\n        return 0\n    return _assetAmount * (10 ** 18) // staticcall ExtraFiPool(EXTRAFI_POOL).exchangeRateOfReserve(reserveId)\n\n\n# total assets\n\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    return self._totalAssets(_vaultToken)\n\n\n@view\n@internal\ndef _totalAssets(_vaultToken: address) -> uint256:\n    reserveId: uint256 = self.vaultTokenToReserveId[_vaultToken]\n    if reserveId == 0:\n        return 0\n    return staticcall ExtraFiPool(EXTRAFI_POOL).totalLiquidityOfReserve(reserveId)\n\n\n# total borrows\n\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    return self._totalBorrows(_vaultToken)\n\n\n@view\n@internal\ndef _totalBorrows(_vaultToken: address) -> uint256:\n    reserveId: uint256 = self.vaultTokenToReserveId[_vaultToken]\n    if reserveId == 0:\n        return 0\n    return staticcall ExtraFiPool(EXTRAFI_POOL).totalBorrowsOfReserve(reserveId)\n\n\n# avail liquidity\n\n\n@view\n@external\ndef getAvailLiquidity(_vaultToken: address) -> uint256:\n    totalAssets: uint256 = self._totalAssets(_vaultToken)\n    totalBorrows: uint256 = self._totalBorrows(_vaultToken)\n    if totalAssets <= totalBorrows:\n        return 0\n    return totalAssets - totalBorrows\n\n\n# utilization\n\n\n@view\n@external\ndef getUtilizationRatio(_vaultToken: address) -> uint256:\n    totalAssets: uint256 = self._totalAssets(_vaultToken)\n    if totalAssets == 0:\n        return 0\n    totalBorrows: uint256 = self._totalBorrows(_vaultToken)\n    return totalBorrows * HUNDRED_PERCENT // totalAssets\n\n\n# extras\n\n\n@view\n@external\ndef isEligibleForYieldBonus(_asset: address) -> bool:\n    return False\n\n\n@view\n@external\ndef getWithdrawalFees(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    return 0\n\n\n################\n# Registration #\n################\n\n\n# can vault be registered\n\n\n@view\n@external\ndef canRegisterVaultToken(_asset: address, _vaultToken: address) -> bool:\n    # no `_reserveId` param can be passed here, so not implemented\n    return False\n\n\n@view\n@internal\ndef _canRegisterVaultToken(_asset: address, _vaultToken: address, _reserveId: uint256) -> bool:\n    if empty(address) in [_asset, _vaultToken]:\n        return False\n    if _reserveId == 0:\n        return False\n    extraFiPool: address = EXTRAFI_POOL\n    if staticcall ExtraFiPool(extraFiPool).getUnderlyingTokenAddress(_reserveId) != _asset:\n        return False\n    return staticcall ExtraFiPool(extraFiPool).getETokenAddress(_reserveId) == _vaultToken\n\n\n# register vault token locally\n\n\n@external\ndef registerVaultTokenLocally(_asset: address, _vaultAddr: address, _reserveId: uint256) -> ls.VaultTokenInfo:\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert self._canRegisterVaultToken(_asset, _vaultAddr, _reserveId) # dev: cannot register vault token\n    assert not yld._isAssetOpportunity(_asset, _vaultAddr) # dev: already registered\n    vaultInfo: ls.VaultTokenInfo = self._registerVaultTokenLocally(_asset, _vaultAddr, _reserveId)\n    self._registerVaultTokenGlobally(_asset, _vaultAddr, vaultInfo.decimals, addys._getLedgerAddr(), addys._getLegoBookAddr())\n    return vaultInfo\n\n\n@internal\ndef _registerVaultTokenLocally(_asset: address, _vaultAddr: address, _reserveId: uint256) -> ls.VaultTokenInfo:\n    assert extcall IERC20(_asset).approve(EXTRAFI_POOL, max_value(uint256), default_return_value=True) # dev: max approval failed\n    assert extcall IERC20(_vaultAddr).approve(EXTRAFI_POOL, max_value(uint256), default_return_value=True) # dev: max approval failed\n    self.vaultTokenToReserveId[_vaultAddr] = _reserveId\n    vaultInfo: ls.VaultTokenInfo = yld._addAssetOpportunity(_asset, _vaultAddr)\n    assert vaultInfo.decimals != 0 # dev: invalid vault token\n    return vaultInfo\n\n\n# remove vault token locally\n\n\n@external\ndef deregisterVaultTokenLocally(_asset: address, _vaultAddr: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert yld._isAssetOpportunity(_asset, _vaultAddr) # dev: already registered\n    self._deregisterVaultTokenLocally(_asset, _vaultAddr)\n\n\n@internal\ndef _deregisterVaultTokenLocally(_asset: address, _vaultAddr: address):\n    assert extcall IERC20(_asset).approve(EXTRAFI_POOL, 0, default_return_value=True) # dev: max approval failed\n    assert extcall IERC20(_vaultAddr).approve(EXTRAFI_POOL, 0, default_return_value=True) # dev: max approval failed\n    yld._removeAssetOpportunity(_asset, _vaultAddr)\n    self.vaultTokenToReserveId[_vaultAddr] = 0\n\n\n# ledger registration\n\n\n@external\ndef registerVaultTokensGlobally(_vaultTokens: DynArray[address, 10]):\n    ledger: address = addys._getLedgerAddr()\n    legoBook: address = addys._getLegoBookAddr()\n    for vt: address in _vaultTokens:\n        vaultInfo: ls.VaultTokenInfo = yld.vaultToAsset[vt]\n        if vaultInfo.decimals != 0 and empty(address) not in [vt, vaultInfo.underlyingAsset]:\n            self._registerVaultTokenGlobally(vaultInfo.underlyingAsset, vt, vaultInfo.decimals, ledger, legoBook)\n\n\n@internal\ndef _registerVaultTokenGlobally(_underlyingAsset: address, _vaultToken: address, _decimals: uint256, _ledger: address, _legoBook: address):\n    if not staticcall Ledger(_ledger).isRegisteredVaultToken(_vaultToken):\n        legoId: uint256 = staticcall Registry(_legoBook).getRegId(self)\n        extcall Ledger(_ledger).setVaultToken(_vaultToken, legoId, _underlyingAsset, _decimals, self._isRebasing())\n\n\n#################\n# Yield Actions #\n#################\n\n\n# access control\n\n\n@view\n@internal\ndef _isAllowedToPerformAction(_caller: address) -> bool:\n    # NOTE: important to not trust `_miniAddys` here, that's why getting ledger and vault registry from addys\n    if staticcall VaultRegistry(addys._getVaultRegistryAddr()).isEarnVault(_caller):\n        return True\n    if staticcall Ledger(addys._getLedgerAddr()).isUserWallet(_caller):\n        return True\n    return staticcall Registry(RIPE_REGISTRY).isValidAddr(_caller) # Ripe Endaoment is allowed\n\n\n# add price snapshot\n\n\n@external\ndef addPriceSnapshot(_vaultToken: address) -> bool:\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    vaultInfo: ls.VaultTokenInfo = yld.vaultToAsset[_vaultToken]\n    assert vaultInfo.decimals != 0 # dev: not registered\n    pricePerShare: uint256 = self._getPricePerShare(_vaultToken, vaultInfo.decimals)\n    return yld._addPriceSnapshot(_vaultToken, pricePerShare, vaultInfo.decimals)\n\n\n# deposit\n\n\n@external\ndef depositForYield(\n    _asset: address,\n    _amount: uint256,\n    _vaultAddr: address,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, address, uint256, uint256):\n    assert self._isAllowedToPerformAction(msg.sender) # dev: no perms\n    assert not yld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = yld._getMiniAddys(_miniAddys)\n    vaultInfo: ls.VaultTokenInfo = yld.vaultToAsset[_vaultAddr]\n\n    # verify asset and vault token are registered\n    assert _asset != empty(address) # dev: invalid asset\n    assert vaultInfo.underlyingAsset == _asset # dev: asset mismatch\n    reserveId: uint256 = self.vaultTokenToReserveId[_vaultAddr]\n    assert reserveId != 0 # dev: invalid vault token\n\n    # pre balances\n    preLegoBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n\n    # transfer deposit asset to this contract\n    depositAmount: uint256 = min(_amount, staticcall IERC20(_asset).balanceOf(msg.sender))\n    assert depositAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_asset).transferFrom(msg.sender, self, depositAmount, default_return_value=True) # dev: transfer failed\n\n    # deposit assets into lego partner\n    vaultTokenAmountReceived: uint256 = extcall ExtraFiPool(EXTRAFI_POOL).deposit(reserveId, depositAmount, _recipient, 0)\n    assert vaultTokenAmountReceived != 0 # dev: no vault tokens received\n\n    # refund if full deposit didn't get through\n    currentLegoBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    refundAssetAmount: uint256 = 0\n    if currentLegoBalance > preLegoBalance:\n        refundAssetAmount = currentLegoBalance - preLegoBalance\n        assert extcall IERC20(_asset).transfer(msg.sender, refundAssetAmount, default_return_value=True) # dev: transfer failed\n        depositAmount -= refundAssetAmount\n\n    usdValue: uint256 = staticcall Appraiser(miniAddys.appraiser).getUnderlyingUsdValue(_asset, depositAmount)\n    log ExtraFiDeposit(\n        sender = msg.sender,\n        asset = _asset,\n        vaultToken = _vaultAddr,\n        assetAmountDeposited = depositAmount,\n        usdValue = usdValue,\n        vaultTokenAmountReceived = vaultTokenAmountReceived,\n        recipient = _recipient,\n    )\n\n    # add price snapshot\n    pricePerShare: uint256 = self._getPricePerShare(_vaultAddr, vaultInfo.decimals)\n    yld._addPriceSnapshot(_vaultAddr, pricePerShare, vaultInfo.decimals)\n\n    return depositAmount, _vaultAddr, vaultTokenAmountReceived, usdValue\n\n\n# withdraw\n\n\n@external\ndef withdrawFromYield(\n    _vaultToken: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, address, uint256, uint256):\n    assert self._isAllowedToPerformAction(msg.sender) # dev: no perms\n    assert not yld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = yld._getMiniAddys(_miniAddys)\n    vaultInfo: ls.VaultTokenInfo = yld.vaultToAsset[_vaultToken]\n\n    # verify asset and vault token are registered\n    assert vaultInfo.underlyingAsset != empty(address) # dev: invalid asset\n    reserveId: uint256 = self.vaultTokenToReserveId[_vaultToken]\n    assert reserveId != 0 # dev: invalid vault token\n\n    # pre balances\n    preLegoVaultBalance: uint256 = staticcall IERC20(_vaultToken).balanceOf(self)\n\n    # transfer vaults tokens to this contract\n    vaultTokenAmount: uint256 = min(_amount, staticcall IERC20(_vaultToken).balanceOf(msg.sender))\n    assert vaultTokenAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_vaultToken).transferFrom(msg.sender, self, vaultTokenAmount, default_return_value=True) # dev: transfer failed\n\n    # withdraw assets from lego partner\n    assetAmountReceived: uint256 = extcall ExtraFiPool(EXTRAFI_POOL).redeem(reserveId, vaultTokenAmount, _recipient, False)\n    assert assetAmountReceived != 0 # dev: no asset amount received\n\n    # refund if full withdrawal didn't happen\n    currentLegoVaultBalance: uint256 = staticcall IERC20(_vaultToken).balanceOf(self)\n    refundVaultTokenAmount: uint256 = 0\n    if currentLegoVaultBalance > preLegoVaultBalance:\n        refundVaultTokenAmount = currentLegoVaultBalance - preLegoVaultBalance\n        assert extcall IERC20(_vaultToken).transfer(msg.sender, refundVaultTokenAmount, default_return_value=True) # dev: transfer failed\n        vaultTokenAmount -= refundVaultTokenAmount\n\n    usdValue: uint256 = staticcall Appraiser(miniAddys.appraiser).getUnderlyingUsdValue(vaultInfo.underlyingAsset, assetAmountReceived)\n    log ExtraFiWithdrawal(\n        sender = msg.sender,\n        asset = vaultInfo.underlyingAsset,\n        vaultToken = _vaultToken,\n        assetAmountReceived = assetAmountReceived,\n        usdValue = usdValue,\n        vaultTokenAmountBurned = vaultTokenAmount,\n        recipient = _recipient,\n    )\n\n    # add price snapshot\n    pricePerShare: uint256 = self._getPricePerShare(_vaultToken, vaultInfo.decimals)\n    yld._addPriceSnapshot(_vaultToken, pricePerShare, vaultInfo.decimals)\n\n    return vaultTokenAmount, vaultInfo.underlyingAsset, assetAmountReceived, usdValue\n\n\n#########\n# Other #\n#########\n\n\n@view\n@external\ndef getAccessForLego(_user: address, _action: ws.ActionType) -> (address, String[64], uint256):\n    return empty(address), empty(String[64]), 0\n\n\n@external\ndef claimRewards(\n    _user: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _extraData: bytes32,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    # backwards compatibility\n    return 0, 0\n\n\n@external\ndef claimIncentives(\n    _user: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _proofs: DynArray[bytes32, MAX_PROOFS],\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@view\n@external\ndef hasClaimableRewards(_user: address) -> bool:\n    return False\n\n\n@external\ndef swapTokens(\n    _amountIn: uint256,\n    _minAmountOut: uint256,\n    _tokenPath: DynArray[address, MAX_TOKEN_PATH],\n    _poolPath: DynArray[address, MAX_TOKEN_PATH - 1],\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256):\n    return 0, 0, 0\n\n\n@external\ndef mintOrRedeemAsset(\n    _tokenIn: address,\n    _tokenOut: address,\n    _tokenInAmount: uint256,\n    _minAmountOut: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, bool, uint256):\n    return 0, 0, False, 0\n\n\n@external\ndef confirmMintOrRedeemAsset(\n    _tokenIn: address,\n    _tokenOut: address,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef addCollateral(\n    _asset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef removeCollateral(\n    _asset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef borrow(\n    _borrowAsset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef repayDebt(\n    _paymentAsset: address,\n    _paymentAmount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef addLiquidity(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _amountA: uint256,\n    _amountB: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _minLpAmount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (address, uint256, uint256, uint256, uint256):\n    return empty(address), 0, 0, 0, 0\n\n\n@external\ndef removeLiquidity(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpToken: address,\n    _lpAmount: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, uint256):\n    return 0, 0, 0, 0\n\n\n@external\ndef addLiquidityConcentrated(\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _tickLower: int24,\n    _tickUpper: int24,\n    _amountA: uint256,\n    _amountB: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, uint256, uint256):\n    return 0, 0, 0, 0, 0\n\n\n@external\ndef removeLiquidityConcentrated(\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _liqToRemove: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, bool, uint256):\n    return 0, 0, 0, False, 0",
            "sha256sum": "a885bd9c483cfdc1e5086753ecb8aca36550803b7d3e63b9757d4111e14d62de"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/legos/yield/ExtraFi.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.3+commit.bff19ea2",
        "integrity": "977be895c2c943372c806bdba6f3594a7130b5c9200813a97e0466df752907b9"
      },
      "args": "00000000000000000000000044cf3c4f000dfd76a35d03298049d37be688d6f9000000000000000000000000bb505c54d71e9e599cb8435b4f0ceec05fc71cbd0000000000000000000000006162df1b329e157479f8f1407e888260e0ec3d2b0000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000500000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000019000000000000000000000000000000000000000000000000000000000000004c0000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000000002c",
      "file": "contracts/legos/yield/ExtraFi.vy"
    }
  }
}