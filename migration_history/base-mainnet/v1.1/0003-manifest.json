{
  "contracts": {
    "LegoBook": {
      "address": "0xc0E0bc04A7EF550053792c30782E38E34d3Dd70D",
      "abi": [
        {
          "name": "LegoToolsSet",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeTimeLockModified",
          "inputs": [
            {
              "name": "prevTimeLock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "newTimeLock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "RegistryTimeLockModified",
          "inputs": [
            {
              "name": "newTimeLock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "prevTimeLock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeStarted",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeConfirmed",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeCancelled",
          "inputs": [
            {
              "name": "cancelledGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovRelinquished",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UndyHqSetupFinished",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "timeLock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "DepartmentPauseModified",
          "inputs": [
            {
              "name": "isPaused",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "DepartmentFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "balance",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "NewAddressPending",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "NewAddressConfirmed",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "regId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "NewAddressCancelled",
          "inputs": [
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddressUpdatePending",
          "inputs": [
            {
              "name": "regId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "newAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "prevAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "version",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddressUpdateConfirmed",
          "inputs": [
            {
              "name": "regId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "newAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "prevAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "version",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddressUpdateCancelled",
          "inputs": [
            {
              "name": "regId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "newAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "prevAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddressDisablePending",
          "inputs": [
            {
              "name": "regId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "version",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddressDisableConfirmed",
          "inputs": [
            {
              "name": "regId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "version",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddressDisableCancelled",
          "inputs": [
            {
              "name": "regId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUndyHqFromGov",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canGovern",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getGovernors",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPendingGovChange",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "startGovernanceChange",
          "inputs": [
            {
              "name": "_newGov",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "relinquishGov",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setGovTimeLock",
          "inputs": [
            {
              "name": "_numBlocks",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidGovTimeLock",
          "inputs": [
            {
              "name": "_newTimeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "minGovChangeTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "maxGovChangeTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "finishUndyHqSetup",
          "inputs": [
            {
              "name": "_newGov",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "finishUndyHqSetup",
          "inputs": [
            {
              "name": "_newGov",
              "type": "address"
            },
            {
              "name": "_timeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "governance",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingGov",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "newGov",
                  "type": "address"
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numGovChanges",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "govChangeTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRegistryDescription",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "string"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidNewAddress",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidAddressUpdate",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            },
            {
              "name": "_newAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidAddressDisable",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setRegistryTimeLock",
          "inputs": [
            {
              "name": "_numBlocks",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidRegistryTimeLock",
          "inputs": [
            {
              "name": "_numBlocks",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setRegistryTimeLockAfterSetup",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setRegistryTimeLockAfterSetup",
          "inputs": [
            {
              "name": "_numBlocks",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "minRegistryTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "maxRegistryTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidAddr",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidRegId",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRegId",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddr",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddrInfo",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "addr",
                  "type": "address"
                },
                {
                  "name": "version",
                  "type": "uint256"
                },
                {
                  "name": "lastModified",
                  "type": "uint256"
                },
                {
                  "name": "description",
                  "type": "string"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddrDescription",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "string"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getNumAddrs",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLastAddr",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLastRegId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "registryChangeTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "addrInfo",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "addr",
                  "type": "address"
                },
                {
                  "name": "version",
                  "type": "uint256"
                },
                {
                  "name": "lastModified",
                  "type": "uint256"
                },
                {
                  "name": "description",
                  "type": "string"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "addrToRegId",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAddrs",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingNewAddr",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "description",
                  "type": "string"
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingAddrUpdate",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "newAddr",
                  "type": "address"
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingAddrDisable",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddys",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "undyToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "hatchery",
                  "type": "address"
                },
                {
                  "name": "lootDistributor",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                },
                {
                  "name": "walletBackpack",
                  "type": "address"
                },
                {
                  "name": "billing",
                  "type": "address"
                },
                {
                  "name": "vaultRegistry",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUndyHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canMintUndy",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pause",
          "inputs": [
            {
              "name": "_shouldPause",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFundsMany",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_assets",
              "type": "address[]"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isPaused",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isLegoAddr",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "startAddNewAddressToRegistry",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            },
            {
              "name": "_description",
              "type": "string"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmNewAddressToRegistry",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelNewAddressToRegistry",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "startAddressUpdateToRegistry",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            },
            {
              "name": "_newAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmAddressUpdateToRegistry",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelAddressUpdateToRegistry",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "startAddressDisableInRegistry",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmAddressDisableInRegistry",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelAddressDisableInRegistry",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setLegoTools",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidLegoTools",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "legoTools",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_undyHq",
              "type": "address"
            },
            {
              "name": "_initialGov",
              "type": "address"
            },
            {
              "name": "_minRegistryTimeLock",
              "type": "uint256"
            },
            {
              "name": "_maxRegistryTimeLock",
              "type": "uint256"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/modules/LocalGov.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\ninterface UndyHq:\n    def minGovChangeTimeLock() -> uint256: view\n    def maxGovChangeTimeLock() -> uint256: view\n    def governance() -> address: view\n\nstruct PendingGovernance:\n    newGov: address\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeStarted:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    confirmBlock: uint256\n\nevent GovChangeConfirmed:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeCancelled:\n    cancelledGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovRelinquished:\n    prevGov: indexed(address)\n\nevent GovChangeTimeLockModified:\n    prevTimeLock: uint256\n    newTimeLock: uint256\n\nevent UndyHqSetupFinished:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    timeLock: uint256\n\n# governance\ngovernance: public(address)\npendingGov: public(PendingGovernance)\nnumGovChanges: public(uint256)\n\n# time lock\ngovChangeTimeLock: public(uint256)\n\n# config\nUNDY_HQ_FOR_GOV: immutable(address)\nMIN_GOV_TIME_LOCK: immutable(uint256)\nMAX_GOV_TIME_LOCK: immutable(uint256)\n\n\n@deploy\ndef __init__(\n    _undyHq: address,\n    _initialGov: address,\n    _minTimeLock: uint256,\n    _maxTimeLock: uint256,\n    _initialTimeLock: uint256,\n):\n    UNDY_HQ_FOR_GOV = _undyHq\n    self.governance = _initialGov\n\n    # undy hq\n    if _undyHq == empty(address):\n        assert _initialGov != empty(address) # dev: undy hq must have gov\n\n    # local gov (department, other smart contracts)\n    else:\n        hqGov: address = staticcall UndyHq(_undyHq).governance()\n        assert hqGov != empty(address) # dev: undy hq must have gov\n        assert _initialGov != hqGov # dev: undy hq cannot set same gov\n\n    # time locks\n    minTimeLock: uint256 = _minTimeLock\n    maxTimeLock: uint256 = _maxTimeLock\n    if minTimeLock == 0 or maxTimeLock == 0:\n        assert _undyHq != empty(address) # dev: need undy hq if no time locks\n        minTimeLock = staticcall UndyHq(_undyHq).minGovChangeTimeLock()\n        maxTimeLock = staticcall UndyHq(_undyHq).maxGovChangeTimeLock()\n\n    # set min and max time locks\n    assert minTimeLock < maxTimeLock # dev: invalid time lock\n    assert minTimeLock != 0 and maxTimeLock != max_value(uint256) # dev: invalid time lock\n    MIN_GOV_TIME_LOCK = minTimeLock\n    MAX_GOV_TIME_LOCK = maxTimeLock\n\n    # this contract is top level governance from Undy HQ -- not setting initial time lock during setup\n    if _undyHq == empty(address):\n        return\n\n    # set initial time lock (for local gov)\n    initialTimeLock: uint256 = max(minTimeLock, _initialTimeLock)\n    assert self._setGovTimeLock(initialTimeLock) # dev: invalid time lock\n\n\n@view\n@external\ndef getUndyHqFromGov() -> address:\n    return self._getUndyHqFromGov()\n\n\n@view\n@internal\ndef _getUndyHqFromGov() -> address:\n    return UNDY_HQ_FOR_GOV\n\n\n##############\n# Gov Access #\n##############\n\n\n@view\n@external\ndef canGovern(_addr: address) -> bool:\n    return self._canGovern(_addr)\n\n\n@view\n@internal\ndef _canGovern(_addr: address) -> bool:\n    if _addr == empty(address):\n        return False\n    return _addr in self._getGovernors()\n\n\n@view\n@external\ndef getGovernors() -> DynArray[address, 2]:\n    return self._getGovernors()\n\n\n@view\n@internal\ndef _getGovernors() -> DynArray[address, 2]:\n    governors: DynArray[address, 2] = []\n\n    # local governance\n    localGov: address = self.governance\n    if localGov != empty(address):\n        governors.append(localGov)\n\n    # undy hq governance\n    undyHq: address = UNDY_HQ_FOR_GOV\n    if undyHq == empty(address):\n        return governors\n\n    hqGov: address = staticcall UndyHq(undyHq).governance()\n    if hqGov != empty(address):\n        governors.append(hqGov)\n\n    return governors\n\n\n######################\n# Governance Changes #\n######################\n\n\n@view\n@external\ndef hasPendingGovChange() -> bool:\n    return self.pendingGov.confirmBlock != 0\n\n\n@view\n@internal\ndef _isUndyHq() -> bool:\n    return UNDY_HQ_FOR_GOV == empty(address)\n\n\n# start gov change\n\n\n@external\ndef startGovernanceChange(_newGov: address):\n    governors: DynArray[address, 2] = self._getGovernors()\n    assert msg.sender in governors # dev: no perms\n\n    # validation\n    if _newGov != empty(address):\n        assert _newGov not in governors # dev: invalid _newGov\n        assert _newGov.is_contract # dev: _newGov must be a contract\n    else:\n        assert not self._isUndyHq() # dev: undy hq cannot set 0x0\n\n    confirmBlock: uint256 = block.number + self.govChangeTimeLock\n    self.pendingGov = PendingGovernance(\n        newGov= _newGov,\n        initiatedBlock= block.number,\n        confirmBlock= confirmBlock,\n    )\n    log GovChangeStarted(prevGov=self.governance, newGov=_newGov, confirmBlock=confirmBlock)\n\n\n# confirm gov change\n\n\n@external\ndef confirmGovernanceChange():\n    data: PendingGovernance = self.pendingGov\n    assert data.confirmBlock != 0 and block.number >= data.confirmBlock # dev: time lock not reached\n\n    # check permissions\n    if data.newGov != empty(address):\n        assert msg.sender == data.newGov # dev: only new gov can confirm\n    else:\n        assert self._canGovern(msg.sender) # dev: no perms\n        assert not self._isUndyHq() # dev: undy hq cannot set 0x0\n\n    # set new governance\n    prevGov: address = self.governance\n    self.governance = data.newGov\n    self.numGovChanges += 1\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeConfirmed(prevGov=prevGov, newGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n# cancel gov change\n\n\n@external\ndef cancelGovernanceChange():\n    assert self._canGovern(msg.sender) # dev: no perms\n    data: PendingGovernance = self.pendingGov\n    assert data.confirmBlock != 0 # dev: no pending change\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeCancelled(cancelledGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n# relinquish gov (only for local gov)\n\n\n@external\ndef relinquishGov():\n    assert msg.sender == self.governance # dev: no perms\n    assert not self._isUndyHq() # dev: undy hq cannot relinquish gov\n\n    self.governance = empty(address)\n    self.numGovChanges += 1\n    log GovRelinquished(prevGov=msg.sender)\n\n\n####################\n# Time Lock Config #\n####################\n\n\n# set time lock\n\n\n@external\ndef setGovTimeLock(_numBlocks: uint256) -> bool:\n    assert self._canGovern(msg.sender) # dev: no perms\n    return self._setGovTimeLock(_numBlocks)\n\n\n@internal\ndef _setGovTimeLock(_numBlocks: uint256) -> bool:\n    prevTimeLock: uint256 = self.govChangeTimeLock\n    assert self._isValidGovTimeLock(_numBlocks, prevTimeLock) # dev: invalid time lock\n    self.govChangeTimeLock = _numBlocks\n    log GovChangeTimeLockModified(prevTimeLock=prevTimeLock, newTimeLock=_numBlocks)\n    return True\n\n\n# validation\n\n\n@view\n@external\ndef isValidGovTimeLock(_newTimeLock: uint256) -> bool:\n    return self._isValidGovTimeLock(_newTimeLock, self.govChangeTimeLock)\n\n\n@view\n@internal\ndef _isValidGovTimeLock(_newTimeLock: uint256, _prevTimeLock: uint256) -> bool:\n    if _newTimeLock == _prevTimeLock:\n        return False # no change\n    if self.pendingGov.confirmBlock != 0:\n        return False # cannot change while pending gov change\n    return _newTimeLock >= MIN_GOV_TIME_LOCK and _newTimeLock <= MAX_GOV_TIME_LOCK\n\n\n# utils\n\n\n@view\n@external\ndef minGovChangeTimeLock() -> uint256:\n    return MIN_GOV_TIME_LOCK\n\n\n@view\n@external\ndef maxGovChangeTimeLock() -> uint256:\n    return MAX_GOV_TIME_LOCK\n\n\n#################\n# Undy Hq Setup #\n#################\n\n\n@external\ndef finishUndyHqSetup(_newGov: address, _timeLock: uint256 = 0) -> bool:\n    assert self._isUndyHq() # dev: only undy hq\n    assert msg.sender == self.governance # dev: no perms\n    assert self.numGovChanges == 0 # dev: already changed gov\n\n    # validation\n    assert _newGov != empty(address) and _newGov.is_contract # dev: invalid _newGov\n    prevGov: address = self.governance\n\n    # set new gov\n    self.governance = _newGov\n    self.numGovChanges += 1\n\n    # set time lock\n    timeLock: uint256 = _timeLock\n    if timeLock == 0:\n        timeLock = MIN_GOV_TIME_LOCK\n    assert self._setGovTimeLock(timeLock) # dev: invalid time lock\n\n    log UndyHqSetupFinished(prevGov=prevGov, newGov=_newGov, timeLock=timeLock)\n    return True",
            "sha256sum": "c41aa3e0d0d96b512171813377ea277e2c7da690c3cd9b4662733b3f11f705b0"
          },
          "contracts/modules/AddressRegistry.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nuses: gov\nimport contracts.modules.LocalGov as gov\n\nstruct AddressInfo:\n    addr: address\n    version: uint256\n    lastModified: uint256\n    description: String[64]\n\nstruct PendingNewAddress:\n    description: String[64]\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nstruct PendingAddressUpdate:\n    newAddr: address\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nstruct PendingAddressDisable:\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent NewAddressPending:\n    addr: indexed(address)\n    description: String[64]\n    confirmBlock: uint256\n    registry: String[28]\n\nevent NewAddressConfirmed:\n    addr: indexed(address)\n    regId: uint256\n    description: String[64]\n    registry: String[28]\n\nevent NewAddressCancelled:\n    description: String[64]\n    addr: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n    registry: String[28]\n\nevent AddressUpdatePending:\n    regId: uint256\n    description: String[64]\n    newAddr: indexed(address)\n    prevAddr: indexed(address)\n    version: uint256\n    confirmBlock: uint256\n    registry: String[28]\n\nevent AddressUpdateConfirmed:\n    regId: uint256\n    description: String[64]\n    newAddr: indexed(address)\n    prevAddr: indexed(address)\n    version: uint256\n    registry: String[28]\n\nevent AddressUpdateCancelled:\n    regId: uint256\n    description: String[64]\n    newAddr: indexed(address)\n    prevAddr: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n    registry: String[28]\n\nevent AddressDisablePending:\n    regId: uint256\n    description: String[64]\n    addr: indexed(address)\n    version: uint256\n    confirmBlock: uint256\n    registry: String[28]\n\nevent AddressDisableConfirmed:\n    regId: uint256\n    description: String[64]\n    addr: indexed(address)\n    version: uint256\n    registry: String[28]\n\nevent AddressDisableCancelled:\n    regId: uint256\n    description: String[64]\n    addr: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n    registry: String[28]\n\nevent RegistryTimeLockModified:\n    newTimeLock: uint256\n    prevTimeLock: uint256\n    registry: String[28]\n\n# time lock\nregistryChangeTimeLock: public(uint256)\n\n# core data (address registry)\naddrInfo: public(HashMap[uint256, AddressInfo]) # regId -> address info\naddrToRegId: public(HashMap[address, uint256]) # addr -> regId\nnumAddrs: public(uint256) # number of addrs in registry\n\n# pending changes\npendingNewAddr: public(HashMap[address, PendingNewAddress]) # addr -> pending new addr\npendingAddrUpdate: public(HashMap[uint256, PendingAddressUpdate]) # regId -> pending addr update\npendingAddrDisable: public(HashMap[uint256, PendingAddressDisable]) # regId -> pending addr disable\n\nREGISTRY_STR: immutable(String[28])\nMIN_REG_TIME_LOCK: immutable(uint256)\nMAX_REG_TIME_LOCK: immutable(uint256)\n\n\n@deploy\ndef __init__(\n    _minTimeLock: uint256,\n    _maxTimeLock: uint256,\n    _initialTimeLock: uint256,\n    _registryStr: String[28],\n):\n    REGISTRY_STR = _registryStr\n\n    assert _minTimeLock < _maxTimeLock # dev: invalid time lock\n    assert _minTimeLock != 0 and _maxTimeLock != max_value(uint256) # dev: invalid time lock\n    MIN_REG_TIME_LOCK = _minTimeLock\n    MAX_REG_TIME_LOCK = _maxTimeLock\n\n    # set initial time lock -- this may be zero during inital setup of registry\n    if _initialTimeLock != 0:\n        assert self._setRegistryTimeLock(_initialTimeLock) # dev: invalid time lock\n\n    # start at 1 index\n    self.numAddrs = 1\n\n\n@view\n@external\ndef getRegistryDescription() -> String[28]:\n    return REGISTRY_STR\n\n\n###############\n# New Address #\n###############\n\n\n# register new address\n\n\n@internal\ndef _startAddNewAddressToRegistry(_addr: address, _description: String[64]) -> bool:\n    assert self._isValidNewAddress(_addr) # dev: invalid addy\n\n    confirmBlock: uint256 = block.number + self.registryChangeTimeLock\n    self.pendingNewAddr[_addr] = PendingNewAddress(\n        description=_description,\n        initiatedBlock=block.number,\n        confirmBlock=confirmBlock,\n    )\n\n    log NewAddressPending(addr=_addr, description=_description, confirmBlock=confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n# confirm new address\n\n\n@internal\ndef _confirmNewAddressToRegistry(_addr: address) -> uint256:\n    data: PendingNewAddress = self.pendingNewAddr[_addr]\n    assert data.confirmBlock != 0 and block.number >= data.confirmBlock # dev: time lock not reached\n\n    if not self._isValidNewAddress(_addr):\n        self.pendingNewAddr[_addr] = empty(PendingNewAddress) # clear pending\n        return 0\n\n    # register new addy\n    regId: uint256 = self.numAddrs\n    self.addrToRegId[_addr] = regId\n    self.numAddrs = regId + 1\n    self.addrInfo[regId] = AddressInfo(\n        addr=_addr,\n        version=1,\n        lastModified=block.timestamp,\n        description=data.description,\n    )\n\n    # clear pending\n    self.pendingNewAddr[_addr] = empty(PendingNewAddress)\n\n    log NewAddressConfirmed(addr=_addr, regId=regId, description=data.description, registry=REGISTRY_STR)\n    return regId\n\n\n# cancel new address\n\n\n@internal\ndef _cancelNewAddressToRegistry(_addr: address) -> bool:\n    data: PendingNewAddress = self.pendingNewAddr[_addr]\n    assert data.confirmBlock != 0 # dev: no pending\n\n    self.pendingNewAddr[_addr] = empty(PendingNewAddress)\n    log NewAddressCancelled(description=data.description, addr=_addr, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n# validation\n\n\n@view\n@external\ndef isValidNewAddress(_addr: address) -> bool:\n    return self._isValidNewAddress(_addr)\n\n\n@view\n@internal\ndef _isValidNewAddress(_addr: address) -> bool:\n    if _addr == empty(address) or not _addr.is_contract:\n        return False\n    return self.addrToRegId[_addr] == 0\n\n\n###################\n# Address Updates #\n###################\n\n\n# update address\n\n\n@internal\ndef _startAddressUpdateToRegistry(_regId: uint256, _newAddr: address) -> bool:\n    data: AddressInfo = self.addrInfo[_regId]\n    assert self._isValidAddressUpdate(_regId, _newAddr, data.addr) # dev: invalid update\n\n    # set pending\n    confirmBlock: uint256 = block.number + self.registryChangeTimeLock\n    self.pendingAddrUpdate[_regId] = PendingAddressUpdate(\n        newAddr=_newAddr,\n        initiatedBlock=block.number,\n        confirmBlock=confirmBlock,\n    )\n\n    log AddressUpdatePending(regId=_regId, description=data.description, newAddr=_newAddr, prevAddr=data.addr, version=data.version, confirmBlock=confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n# confirm update address\n\n\n@internal\ndef _confirmAddressUpdateToRegistry(_regId: uint256) -> bool:\n    newData: PendingAddressUpdate = self.pendingAddrUpdate[_regId]\n    assert newData.confirmBlock != 0 and block.number >= newData.confirmBlock # dev: time lock not reached\n\n    data: AddressInfo = self.addrInfo[_regId]\n    prevAddr: address = data.addr # needed for later\n    if not self._isValidAddressUpdate(_regId, newData.newAddr, prevAddr):\n        self.pendingAddrUpdate[_regId] = empty(PendingAddressUpdate) # clear pending\n        return False\n\n    # update addy data\n    data.addr = newData.newAddr\n    data.lastModified = block.timestamp\n    data.version += 1\n    self.addrInfo[_regId] = data\n    self.addrToRegId[newData.newAddr] = _regId\n\n    # handle previous addr\n    if prevAddr != empty(address):\n        self.addrToRegId[prevAddr] = 0\n\n    # clear pending\n    self.pendingAddrUpdate[_regId] = empty(PendingAddressUpdate)\n\n    log AddressUpdateConfirmed(regId=_regId, description=data.description, newAddr=newData.newAddr, prevAddr=prevAddr, version=data.version, registry=REGISTRY_STR)\n    return True\n\n\n# cancel update address\n\n\n@internal\ndef _cancelAddressUpdateToRegistry(_regId: uint256) -> bool:\n    data: PendingAddressUpdate = self.pendingAddrUpdate[_regId]\n    assert data.confirmBlock != 0 # dev: no pending\n\n    self.pendingAddrUpdate[_regId] = empty(PendingAddressUpdate)\n    prevData: AddressInfo = self.addrInfo[_regId]\n    log AddressUpdateCancelled(regId=_regId, description=prevData.description, newAddr=data.newAddr, prevAddr=prevData.addr, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n# validation\n\n\n@view\n@external\ndef isValidAddressUpdate(_regId: uint256, _newAddr: address) -> bool:\n    return self._isValidAddressUpdate(_regId, _newAddr, self.addrInfo[_regId].addr)\n\n\n@view\n@internal\ndef _isValidAddressUpdate(_regId: uint256, _newAddr: address, _prevAddr: address) -> bool:\n    if not self._isValidRegId(_regId):\n        return False\n    if not self._isValidNewAddress(_newAddr):\n        return False\n    return _newAddr != _prevAddr\n\n\n###################\n# Disable Address #\n###################\n\n\n# start disable address\n\n\n@internal\ndef _startAddressDisableInRegistry(_regId: uint256) -> bool:\n    data: AddressInfo = self.addrInfo[_regId]\n    assert self._isValidAddressDisable(_regId, data.addr) # dev: invalid disable\n\n    # set pending\n    confirmBlock: uint256 = block.number + self.registryChangeTimeLock\n    self.pendingAddrDisable[_regId] = PendingAddressDisable(\n        initiatedBlock=block.number,\n        confirmBlock=confirmBlock,\n    )\n\n    log AddressDisablePending(regId=_regId, description=data.description, addr=data.addr, version=data.version, confirmBlock=confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n# confirm disable address\n\n\n@internal\ndef _confirmAddressDisableInRegistry(_regId: uint256) -> bool:\n    newData: PendingAddressDisable = self.pendingAddrDisable[_regId]\n    assert newData.confirmBlock != 0 and block.number >= newData.confirmBlock # dev: time lock not reached\n\n    data: AddressInfo = self.addrInfo[_regId]\n    prevAddr: address = data.addr # needed for later\n    if not self._isValidAddressDisable(_regId, prevAddr):\n        self.pendingAddrDisable[_regId] = empty(PendingAddressDisable) # clear pending\n        return False\n\n    # disable addy\n    data.addr = empty(address)\n    data.lastModified = block.timestamp\n    data.version += 1\n    self.addrInfo[_regId] = data\n    self.addrToRegId[prevAddr] = 0\n\n    # clear pending\n    self.pendingAddrDisable[_regId] = empty(PendingAddressDisable)\n\n    log AddressDisableConfirmed(regId=_regId, description=data.description, addr=prevAddr, version=data.version, registry=REGISTRY_STR)\n    return True\n\n\n# cancel disable address\n\n\n@internal\ndef _cancelAddressDisableInRegistry(_regId: uint256) -> bool:\n    data: PendingAddressDisable = self.pendingAddrDisable[_regId]\n    assert data.confirmBlock != 0 # dev: no pending\n\n    self.pendingAddrDisable[_regId] = empty(PendingAddressDisable)\n    prevData: AddressInfo = self.addrInfo[_regId]\n    log AddressDisableCancelled(regId=_regId, description=prevData.description, addr=prevData.addr, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n# validation\n\n\n@view\n@external\ndef isValidAddressDisable(_regId: uint256) -> bool:\n    return self._isValidAddressDisable(_regId, self.addrInfo[_regId].addr)\n\n\n@view\n@internal\ndef _isValidAddressDisable(_regId: uint256, _prevAddr: address) -> bool:\n    if not self._isValidRegId(_regId):\n        return False\n    return _prevAddr != empty(address)\n\n\n####################\n# Time Lock Config #\n####################\n\n\n@external\ndef setRegistryTimeLock(_numBlocks: uint256) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return self._setRegistryTimeLock(_numBlocks)\n\n\n@internal\ndef _setRegistryTimeLock(_numBlocks: uint256) -> bool:\n    prevTimeLock: uint256 = self.registryChangeTimeLock\n    assert self._isValidRegistryTimeLock(_numBlocks, prevTimeLock) # dev: invalid time lock\n    self.registryChangeTimeLock = _numBlocks\n    log RegistryTimeLockModified(newTimeLock=_numBlocks, prevTimeLock=prevTimeLock, registry=REGISTRY_STR)\n    return True\n\n\n# validation\n\n\n@view\n@external\ndef isValidRegistryTimeLock(_numBlocks: uint256) -> bool:\n    return self._isValidRegistryTimeLock(_numBlocks, self.registryChangeTimeLock)\n\n\n@view\n@internal\ndef _isValidRegistryTimeLock(_newTimeLock: uint256, _prevTimeLock: uint256) -> bool:\n    if _newTimeLock == _prevTimeLock:\n        return False\n    return _newTimeLock >= MIN_REG_TIME_LOCK and _newTimeLock <= MAX_REG_TIME_LOCK\n\n\n# finish setup\n\n\n@external\ndef setRegistryTimeLockAfterSetup(_numBlocks: uint256 = 0) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert self.registryChangeTimeLock == 0 # dev: already set\n\n    timeLock: uint256 = _numBlocks\n    if timeLock == 0:\n        timeLock = MIN_REG_TIME_LOCK\n    return self._setRegistryTimeLock(timeLock)\n\n\n# utils\n\n\n@view\n@external\ndef minRegistryTimeLock() -> uint256:\n    return MIN_REG_TIME_LOCK\n\n\n@view\n@external\ndef maxRegistryTimeLock() -> uint256:\n    return MAX_REG_TIME_LOCK\n\n\n#################\n# Views / Utils #\n#################\n\n\n# is valid addr\n\n\n@view\n@external\ndef isValidAddr(_addr: address) -> bool:\n    return self._isValidAddr(_addr)\n\n\n@view\n@internal\ndef _isValidAddr(_addr: address) -> bool:\n    return self.addrToRegId[_addr] != 0\n\n\n# is valid addr id\n\n\n@view\n@external\ndef isValidRegId(_regId: uint256) -> bool:\n    return self._isValidRegId(_regId)\n\n\n@view\n@internal\ndef _isValidRegId(_regId: uint256) -> bool:\n    return _regId != 0 and _regId < self.numAddrs\n\n\n# get reg id\n\n\n@view\n@external\ndef getRegId(_addr: address) -> uint256:\n    return self._getRegId(_addr)\n\n\n@view\n@internal\ndef _getRegId(_addr: address) -> uint256:\n    return self.addrToRegId[_addr]\n\n\n# get addr\n\n\n@view\n@external\ndef getAddr(_regId: uint256) -> address:\n    return self._getAddr(_regId)\n\n\n@view\n@internal\ndef _getAddr(_regId: uint256) -> address:\n    return self.addrInfo[_regId].addr\n\n\n# get addr info\n\n\n@view\n@external\ndef getAddrInfo(_regId: uint256) -> AddressInfo:\n    return self._getAddrInfo(_regId)\n\n\n@view\n@internal\ndef _getAddrInfo(_regId: uint256) -> AddressInfo:\n    return self.addrInfo[_regId]\n\n\n# get addr description\n\n\n@view\n@external\ndef getAddrDescription(_regId: uint256) -> String[64]:\n    return self._getAddrDescription(_regId)\n\n\n@view\n@internal\ndef _getAddrDescription(_regId: uint256) -> String[64]:\n    return self.addrInfo[_regId].description\n\n\n# get num addrs\n\n\n@view\n@external\ndef getNumAddrs() -> uint256:\n    return self._getNumAddrs()\n\n\n@view\n@internal\ndef _getNumAddrs() -> uint256:\n    return self.numAddrs - 1\n\n\n# get last addr\n\n\n@view\n@external\ndef getLastAddr() -> address:\n    return self._getLastAddr()\n\n\n@view\n@internal\ndef _getLastAddr() -> address:\n    lastRegId: uint256 = self.numAddrs - 1\n    return self.addrInfo[lastRegId].addr\n\n\n# get last reg id\n\n\n@view\n@external\ndef getLastRegId() -> uint256:\n    return self._getLastRegId()\n\n\n@view\n@internal\ndef _getLastRegId() -> uint256:\n    return self.numAddrs - 1\n",
            "sha256sum": "b88f6fc85ae3cd815c5a476c620b2fb5494b4dec5f1ce738878eded11c46396b"
          },
          "contracts/modules/Addys.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\ninterface UndyHq:\n    def isValidAddr(_addr: address) -> bool: view\n    def getAddr(_regId: uint256) -> address: view\n    def undyToken() -> address: view\n\ninterface Switchboard:\n    def isSwitchboardAddr(_addr: address) -> bool: view\n\ninterface LegoBook:\n    def isLegoAddr(_addr: address) -> bool: view\n\nstruct Addys:\n    hq: address\n    undyToken: address\n    ledger: address\n    missionControl: address\n    legoBook: address\n    switchboard: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    walletBackpack: address\n    billing: address\n    vaultRegistry: address\n\n# hq\nUNDY_HQ_FOR_ADDYS: immutable(address)\n\n# core addys\nLEDGER_ID: constant(uint256) = 1\nMISSION_CONTROL_ID: constant(uint256) = 2\nLEGO_BOOK_ID: constant(uint256) = 3\nSWITCHBOARD_ID: constant(uint256) = 4\nHATCHERY_ID: constant(uint256) = 5\nLOOT_DISTRIBUTOR_ID: constant(uint256) = 6\nAPPRAISER_ID: constant(uint256) = 7\nWALLET_BACKPACK_ID: constant(uint256) = 8\nBILLING_ID: constant(uint256) = 9\nVAULT_REGISTRY_ID: constant(uint256) = 10\n\n\n@deploy\ndef __init__(_undyHq: address):\n    assert _undyHq != empty(address) # dev: invalid undy hq\n    UNDY_HQ_FOR_ADDYS = _undyHq\n\n\n########\n# Core #\n########\n\n\n@view\n@external\ndef getAddys() -> Addys:\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _getAddys(_addys: Addys = empty(Addys)) -> Addys:\n    if _addys.hq != empty(address):\n        return _addys\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _generateAddys() -> Addys:\n    hq: address = UNDY_HQ_FOR_ADDYS\n    return Addys(\n        hq = hq,\n        undyToken = staticcall UndyHq(hq).undyToken(),\n        ledger = staticcall UndyHq(hq).getAddr(LEDGER_ID),\n        missionControl = staticcall UndyHq(hq).getAddr(MISSION_CONTROL_ID),\n        legoBook = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID),\n        switchboard = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID),\n        hatchery = staticcall UndyHq(hq).getAddr(HATCHERY_ID),\n        lootDistributor = staticcall UndyHq(hq).getAddr(LOOT_DISTRIBUTOR_ID),\n        appraiser = staticcall UndyHq(hq).getAddr(APPRAISER_ID),\n        walletBackpack = staticcall UndyHq(hq).getAddr(WALLET_BACKPACK_ID),\n        billing = staticcall UndyHq(hq).getAddr(BILLING_ID),\n        vaultRegistry = staticcall UndyHq(hq).getAddr(VAULT_REGISTRY_ID),\n    )\n\n\n##########\n# Tokens #\n##########\n\n\n@view\n@internal\ndef _getUndyToken() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).undyToken()\n\n\n###########\n# Helpers #\n###########\n\n\n# undy hq\n\n\n@view\n@external\ndef getUndyHq() -> address:\n    return self._getUndyHq()\n\n\n@view\n@internal\ndef _getUndyHq() -> address:\n    return UNDY_HQ_FOR_ADDYS\n\n\n# utils\n\n\n@view\n@internal\ndef _isValidUndyAddr(_addr: address, _hq: address = empty(address)) -> bool:\n    hq: address = _hq\n    if _hq == empty(address):\n        hq = UNDY_HQ_FOR_ADDYS\n    \n    # core departments\n    if staticcall UndyHq(hq).isValidAddr(_addr):\n        return True\n\n    # lego book\n    legoBook: address = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID)\n    if legoBook != empty(address) and staticcall LegoBook(legoBook).isLegoAddr(_addr):\n        return True\n\n    # switchboard config\n    switchboard: address = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID)\n    if switchboard != empty(address) and staticcall Switchboard(switchboard).isSwitchboardAddr(_addr):\n        return True\n\n    return False\n\n\n@view\n@internal\ndef _isSwitchboardAddr(_addr: address) -> bool:\n    switchboard: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n    if switchboard == empty(address):\n        return False\n    return staticcall Switchboard(switchboard).isSwitchboardAddr(_addr)\n\n\n@view\n@internal\ndef _isLegoBookAddr(_addr: address) -> bool:\n    legoBook: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n    if legoBook == empty(address):\n        return False\n    return staticcall LegoBook(legoBook).isLegoAddr(_addr)\n\n\n###############\n# Departments #\n###############\n\n\n# ledger\n\n\n@view\n@internal\ndef _getLedgerId() -> uint256:\n    return LEDGER_ID\n\n\n@view\n@internal\ndef _getLedgerAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEDGER_ID)\n\n\n# mission control\n\n\n@view\n@internal\ndef _getMissionControlId() -> uint256:\n    return MISSION_CONTROL_ID\n\n\n@view\n@internal\ndef _getMissionControlAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(MISSION_CONTROL_ID)\n\n\n# lego book\n\n\n@view\n@internal\ndef _getLegoBookId() -> uint256:\n    return LEGO_BOOK_ID\n\n\n@view\n@internal\ndef _getLegoBookAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n\n\n# switchboard\n\n\n@view\n@internal\ndef _getSwitchboardId() -> uint256:\n    return SWITCHBOARD_ID\n\n\n@view\n@internal\ndef _getSwitchboardAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n\n\n# hatchery\n\n\n@view\n@internal\ndef _getHatcheryId() -> uint256:\n    return HATCHERY_ID\n\n\n@view\n@internal\ndef _getHatcheryAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(HATCHERY_ID)\n\n\n# loot distributor\n\n\n@view\n@internal\ndef _getLootDistributorId() -> uint256:\n    return LOOT_DISTRIBUTOR_ID\n\n\n@view\n@internal\ndef _getLootDistributorAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LOOT_DISTRIBUTOR_ID)\n\n\n# appraiser\n\n\n@view\n@internal\ndef _getAppraiserId() -> uint256:\n    return APPRAISER_ID\n\n\n@view\n@internal\ndef _getAppraiserAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(APPRAISER_ID)\n\n\n# wallet backpack\n\n\n@view\n@internal\ndef _getWalletBackpackId() -> uint256:\n    return WALLET_BACKPACK_ID\n\n\n@view\n@internal\ndef _getWalletBackpackAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(WALLET_BACKPACK_ID)\n\n\n# billing\n\n\n@view\n@internal\ndef _getBillingId() -> uint256:\n    return BILLING_ID\n\n\n@view\n@internal\ndef _getBillingAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(BILLING_ID)\n\n\n# vault registry\n\n\n@view\n@internal\ndef _getVaultRegistryId() -> uint256:\n    return VAULT_REGISTRY_ID\n\n\n@view\n@internal\ndef _getVaultRegistryAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(VAULT_REGISTRY_ID)",
            "sha256sum": "4df6b72db9bb417d1af81660175be1450cfb7b3575f3d17a5b8a130bff87b781"
          },
          "interfaces/Department.vyi": {
            "content": "# @version 0.4.3\n\n\n###########\n# Minting #\n###########\n\n\n@view\n@external\ndef canMintUndy() -> bool:\n    # used in UndyHq.vy\n    ...\n\n\n########\n# Undy #\n########\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "53e48da591c4ee36045a8950c9d3a01458456b471b797df536e9a9f54404e721"
          },
          "contracts/modules/DeptBasics.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nuses: addys\nimplements: dept\n\nimport contracts.modules.Addys as addys\nimport interfaces.Department as dept\nfrom ethereum.ercs import IERC20\n\nevent DepartmentPauseModified:\n    isPaused: bool\n\nevent DepartmentFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    balance: uint256\n\nisPaused: public(bool)\n\nCAN_MINT_UNDY: immutable(bool)\nMAX_RECOVER_ASSETS: constant(uint256) = 20\n\n\n@deploy\ndef __init__(_shouldPause: bool, _canMintUndy: bool):\n    self.isPaused = _shouldPause\n    CAN_MINT_UNDY = _canMintUndy\n\n\n###########\n# Minting #\n###########\n\n\n@view\n@external\ndef canMintUndy() -> bool:\n    return CAN_MINT_UNDY\n\n\n########\n# Undy #\n########\n\n\n# activate\n\n\n@external\ndef pause(_shouldPause: bool):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert _shouldPause != self.isPaused # dev: no change\n    self.isPaused = _shouldPause\n    log DepartmentPauseModified(isPaused=_shouldPause)\n\n\n# recover funds\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    self._recoverFunds(_recipient, _asset)\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, MAX_RECOVER_ASSETS]):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    for a: address in _assets:\n        self._recoverFunds(_recipient, a)\n\n\n@internal\ndef _recoverFunds(_recipient: address, _asset: address):\n    assert empty(address) not in [_recipient, _asset] # dev: invalid recipient or asset\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    assert balance != 0 # dev: nothing to recover\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log DepartmentFundsRecovered(asset=_asset, recipient=_recipient, balance=balance)\n",
            "sha256sum": "976a50a3807bcf71f3f1c57de5cd7a59fe4e8f27b4d4560e774073962f44d1ac"
          },
          "interfaces/WalletStructs.vyi": {
            "content": "# @version 0.4.3\n\nflag ActionType:\n    TRANSFER\n    EARN_DEPOSIT\n    EARN_WITHDRAW\n    EARN_REBALANCE\n    SWAP\n    MINT_REDEEM\n    CONFIRM_MINT_REDEEM\n    ADD_COLLATERAL\n    REMOVE_COLLATERAL\n    BORROW\n    REPAY_DEBT\n    REWARDS\n    ETH_TO_WETH\n    WETH_TO_ETH\n    ADD_LIQ\n    REMOVE_LIQ\n    ADD_LIQ_CONC\n    REMOVE_LIQ_CONC\n    PAY_CHEQUE\n\nstruct WalletAssetData:\n    assetBalance: uint256\n    usdValue: uint256\n    isYieldAsset: bool\n    lastPricePerShare: uint256\n\nstruct ActionData:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    billing: address\n    vaultRegistry: address\n    wallet: address\n    walletConfig: address\n    walletOwner: address\n    inEjectMode: bool\n    isFrozen: bool\n    lastTotalUsdValue: uint256\n    signer: address\n    isManager: bool\n    legoId: uint256\n    legoAddr: address\n    eth: address\n    weth: address\n\nstruct MiniAddys:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    appraiser: address",
            "sha256sum": "466493c129135c95470aaf70eeddc936632f7b0f813396e5a7ddc03bea9da518"
          },
          "interfaces/LegoPartner.vyi": {
            "content": "# @version 0.4.3\n\nfrom interfaces import WalletStructs as ws\n\nMAX_TOKEN_PATH: constant(uint256) = 5\nMAX_RECOVER_ASSETS: constant(uint256) = 20\nMAX_PROOFS: constant(uint256) = 25\n\n@external\ndef addLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _tickLower: int24, _tickUpper: int24, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef addLiquidity(_pool: address, _tokenA: address, _tokenB: address, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _minLpAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (address, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef removeLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _liqToRemove: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef removeLiquidity(_pool: address, _tokenA: address, _tokenB: address, _lpToken: address, _lpAmount: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef mintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _tokenInAmount: uint256, _minAmountOut: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef swapTokens(_amountIn: uint256, _minAmountOut: uint256, _tokenPath: DynArray[address, MAX_TOKEN_PATH], _poolPath: DynArray[address, MAX_TOKEN_PATH - 1], _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256):\n    ...\n\n@external\ndef depositForYield(_asset: address, _amount: uint256, _vaultAddr: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef withdrawFromYield(_vaultToken: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef confirmMintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef borrow(_borrowAsset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef repayDebt(_paymentAsset: address, _paymentAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef claimIncentives(_user: address, _rewardToken: address, _rewardAmount: uint256, _proofs: DynArray[bytes32, MAX_PROOFS], _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef removeCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef addCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@view\n@external\ndef getAccessForLego(_user: address, _action: ws.ActionType) -> (address, String[64], uint256):\n    ...\n\n@view\n@external\ndef hasCapability(_action: ws.ActionType) -> bool:\n    ...\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    ...\n\n@view\n@external\ndef isYieldLego() -> bool:\n    ...\n\n@view\n@external\ndef isDexLego() -> bool:\n    ...\n\n\n# common\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "f2afb7bd72d4301aea77bbe4177b7ae954ba6f6b76af363965993eb92ad0b715"
          },
          "contracts/registries/LegoBook.vy": {
            "content": "#          ___       ___           ___           ___                ___           ___           ___           ___     \n#         /\\__\\     /\\  \\         /\\  \\         /\\  \\              /\\  \\         /\\  \\         /\\  \\         /\\__\\    \n#        /:/  /    /::\\  \\       /::\\  \\       /::\\  \\            /::\\  \\       /::\\  \\       /::\\  \\       /:/  /    \n#       /:/  /    /:/\\:\\  \\     /:/\\:\\  \\     /:/\\:\\  \\          /:/\\:\\  \\     /:/\\:\\  \\     /:/\\:\\  \\     /:/__/     \n#      /:/  /    /::\\~\\:\\  \\   /:/  \\:\\  \\   /:/  \\:\\  \\        /::\\~\\:\\__\\   /:/  \\:\\  \\   /:/  \\:\\  \\   /::\\__\\____ \n#     /:/__/    /:/\\:\\ \\:\\__\\ /:/__/_\\:\\__\\ /:/__/ \\:\\__\\      /:/\\:\\ \\:|__| /:/__/ \\:\\__\\ /:/__/ \\:\\__\\ /:/\\:::::\\__\\\n#     \\:\\  \\    \\:\\~\\:\\ \\/__/ \\:\\  /\\ \\/__/ \\:\\  \\ /:/  /      \\:\\~\\:\\/:/  / \\:\\  \\ /:/  / \\:\\  \\ /:/  / \\/_|:|~~|~   \n#      \\:\\  \\    \\:\\ \\:\\__\\    \\:\\ \\:\\__\\    \\:\\  /:/  /        \\:\\ \\::/  /   \\:\\  /:/  /   \\:\\  /:/  /     |:|  |    \n#       \\:\\  \\    \\:\\ \\/__/     \\:\\/:/  /     \\:\\/:/  /          \\:\\/:/  /     \\:\\/:/  /     \\:\\/:/  /      |:|  |    \n#        \\:\\__\\    \\:\\__\\        \\::/  /       \\::/  /            \\::/__/       \\::/  /       \\::/  /       |:|  |    \n#         \\/__/     \\/__/         \\/__/         \\/__/              ~~            \\/__/         \\/__/         \\|__|    \n#\n#     \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n#     \u2551  ** Lego Book **                                                               \u2551\n#     \u2551  Address registry for Legos (DeFi integrations -- yield protocols, DEXs, etc). \u2551\n#     \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n#\n#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nimplements: Department\n\nexports: gov.__interface__\nexports: registry.__interface__\nexports: addys.__interface__\nexports: deptBasics.__interface__\n\ninitializes: gov\ninitializes: registry[gov := gov]\ninitializes: addys\ninitializes: deptBasics[addys := addys]\n\nimport contracts.modules.LocalGov as gov\nimport contracts.modules.AddressRegistry as registry\nimport contracts.modules.Addys as addys\nimport contracts.modules.DeptBasics as deptBasics\n\nfrom interfaces import LegoPartner as Lego\nfrom interfaces import Department\n\nevent LegoToolsSet:\n    addr: indexed(address)\n\nlegoTools: public(address)\n\n\n@deploy\ndef __init__(\n    _undyHq: address,\n    _initialGov: address,\n    _minRegistryTimeLock: uint256,\n    _maxRegistryTimeLock: uint256,\n):\n    gov.__init__(_undyHq, _initialGov, 0, 0, 0)\n    registry.__init__(_minRegistryTimeLock, _maxRegistryTimeLock, 0, \"LegoBook.vy\")\n    addys.__init__(_undyHq)\n    deptBasics.__init__(False, False)\n\n\n@view\n@external\ndef isLegoAddr(_addr: address) -> bool:\n    return registry._isValidAddr(_addr)\n\n\n############\n# Registry #\n############\n\n\n# new address\n\n\n@external\ndef startAddNewAddressToRegistry(_addr: address, _description: String[64]) -> bool:\n    assert self._canPerformAction(msg.sender) # dev: no perms\n    return registry._startAddNewAddressToRegistry(_addr, _description)\n\n\n@external\ndef confirmNewAddressToRegistry(_addr: address) -> uint256:\n    assert self._canPerformAction(msg.sender) # dev: no perms\n    return registry._confirmNewAddressToRegistry(_addr)\n\n\n@external\ndef cancelNewAddressToRegistry(_addr: address) -> bool:\n    assert self._canPerformAction(msg.sender) # dev: no perms\n    return registry._cancelNewAddressToRegistry(_addr)\n\n\n# address update\n\n\n@external\ndef startAddressUpdateToRegistry(_regId: uint256, _newAddr: address) -> bool:\n    assert self._canPerformAction(msg.sender) # dev: no perms\n    return registry._startAddressUpdateToRegistry(_regId, _newAddr)\n\n\n@external\ndef confirmAddressUpdateToRegistry(_regId: uint256) -> bool:\n    assert self._canPerformAction(msg.sender) # dev: no perms\n    return registry._confirmAddressUpdateToRegistry(_regId)\n\n\n@external\ndef cancelAddressUpdateToRegistry(_regId: uint256) -> bool:\n    assert self._canPerformAction(msg.sender) # dev: no perms\n    return registry._cancelAddressUpdateToRegistry(_regId)\n\n\n# address disable\n\n\n@external\ndef startAddressDisableInRegistry(_regId: uint256) -> bool:\n    assert self._canPerformAction(msg.sender) # dev: no perms\n    return registry._startAddressDisableInRegistry(_regId)\n\n\n@external\ndef confirmAddressDisableInRegistry(_regId: uint256) -> bool:\n    assert self._canPerformAction(msg.sender) # dev: no perms\n    return registry._confirmAddressDisableInRegistry(_regId)\n\n\n@external\ndef cancelAddressDisableInRegistry(_regId: uint256) -> bool:\n    assert self._canPerformAction(msg.sender) # dev: no perms\n    return registry._cancelAddressDisableInRegistry(_regId)\n\n\n##############\n# Lego Tools #\n##############\n\n\n@external\ndef setLegoTools(_addr: address) -> bool:\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    if not self._isValidLegoTools(_addr):\n        return False\n    self.legoTools = _addr\n    log LegoToolsSet(addr = _addr)\n    return True\n\n\n@view\n@external \ndef isValidLegoTools(_addr: address) -> bool:\n    return self._isValidLegoTools(_addr)\n\n\n@view\n@internal \ndef _isValidLegoTools(_addr: address) -> bool:\n    if not _addr.is_contract or _addr == empty(address):\n        return False\n    return _addr != self.legoTools\n\n\n#############\n# Utilities #\n#############\n\n\n@view\n@internal\ndef _canPerformAction(_caller: address) -> bool:\n    return gov._canGovern(_caller) and not deptBasics.isPaused",
            "sha256sum": "df672ba936fd221a5ad1de20d19aa251e5d9b6e70bd871e30e16d971e0559332"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/registries/LegoBook.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.3+commit.bff19ea2",
        "integrity": "dbfcaaa644504cfb165f4fbabe9bd5e5620974b39da419239c8d338d7f3a0562"
      },
      "args": "00000000000000000000000044cf3c4f000dfd76a35d03298049d37be688d6f90000000000000000000000003ed8174065c00fe511a91850cf8f45d161e8ee150000000000000000000000000000000000000000000000000000000000000e10000000000000000000000000000000000000000000000000000000000013c680",
      "file": "contracts/registries/LegoBook.vy"
    },
    "RipeLego": {
      "address": "0xD10829C06F95D40004aFc4379579Bc05Aa3982e5",
      "abi": [
        {
          "name": "RipeCollateralDeposit",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountDeposited",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultIdOrLock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "RipeCollateralWithdrawal",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "RipeBorrow",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountBorrowed",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "RipeRepay",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountRepaid",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "RipeClaimRewards",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "ripeClaimed",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "RipeSavingsGreenDeposit",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountDeposited",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultTokenAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "RipeSavingsGreenWithdrawal",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultTokenAmountBurned",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "RipeEndaomentPsmSwap",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenIn",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenOut",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amountIn",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "amountOut",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "numTokens",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LegoPauseModified",
          "inputs": [
            {
              "name": "isPaused",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LegoFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "balance",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "SnapShotPriceConfigSet",
          "inputs": [
            {
              "name": "minSnapshotDelay",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "maxNumSnapshots",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "maxUpsideDeviation",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "staleTime",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetOpportunityAdded",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultAddr",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetOpportunityRemoved",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultAddr",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PricePerShareSnapShotAdded",
          "inputs": [
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "totalSupply",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "pricePerShare",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "lastAveragePricePerShare",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddys",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "undyToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "hatchery",
                  "type": "address"
                },
                {
                  "name": "lootDistributor",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                },
                {
                  "name": "walletBackpack",
                  "type": "address"
                },
                {
                  "name": "billing",
                  "type": "address"
                },
                {
                  "name": "vaultRegistry",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUndyHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isLegoAsset",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssetOpportunities",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isAssetOpportunity",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getNumLegoAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pause",
          "inputs": [
            {
              "name": "_shouldPause",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFundsMany",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_assets",
              "type": "address[]"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getWeightedPricePerShare",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLatestSnapshot",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_pricePerShare",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "totalSupply",
                  "type": "uint256"
                },
                {
                  "name": "pricePerShare",
                  "type": "uint256"
                },
                {
                  "name": "lastUpdate",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setSnapShotPriceConfig",
          "inputs": [
            {
              "name": "_config",
              "type": "tuple",
              "components": [
                {
                  "name": "minSnapshotDelay",
                  "type": "uint256"
                },
                {
                  "name": "maxNumSnapshots",
                  "type": "uint256"
                },
                {
                  "name": "maxUpsideDeviation",
                  "type": "uint256"
                },
                {
                  "name": "staleTime",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidPriceConfig",
          "inputs": [
            {
              "name": "_config",
              "type": "tuple",
              "components": [
                {
                  "name": "minSnapshotDelay",
                  "type": "uint256"
                },
                {
                  "name": "maxNumSnapshots",
                  "type": "uint256"
                },
                {
                  "name": "maxUpsideDeviation",
                  "type": "uint256"
                },
                {
                  "name": "staleTime",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "vaultToAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "underlyingAsset",
                  "type": "address"
                },
                {
                  "name": "decimals",
                  "type": "uint256"
                },
                {
                  "name": "lastAveragePricePerShare",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assetOpportunities",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAssetOpportunity",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssetOpportunities",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assets",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "snapShotData",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "lastSnapShot",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "totalSupply",
                      "type": "uint256"
                    },
                    {
                      "name": "pricePerShare",
                      "type": "uint256"
                    },
                    {
                      "name": "lastUpdate",
                      "type": "uint256"
                    }
                  ]
                },
                {
                  "name": "nextIndex",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "snapShots",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "totalSupply",
                  "type": "uint256"
                },
                {
                  "name": "pricePerShare",
                  "type": "uint256"
                },
                {
                  "name": "lastUpdate",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "snapShotPriceConfig",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "minSnapshotDelay",
                  "type": "uint256"
                },
                {
                  "name": "maxNumSnapshots",
                  "type": "uint256"
                },
                {
                  "name": "maxUpsideDeviation",
                  "type": "uint256"
                },
                {
                  "name": "staleTime",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isPaused",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasCapability",
          "inputs": [
            {
              "name": "_action",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRegistries",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isYieldLego",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isDexLego",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAsset",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingBalances",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenBalance",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAmount",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAmountSafe",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenBalance",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingData",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingData",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            },
            {
              "name": "_appraiser",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValueOfVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValueOfVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            },
            {
              "name": "_appraiser",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isRebasing",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPricePerShare",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPricePerShare",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_decimals",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getVaultTokenAmount",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_assetAmount",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalAssets",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalBorrows",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAvailLiquidity",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUtilizationRatio",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isEligibleForYieldBonus",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getWithdrawalFees",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canRegisterVaultToken",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "registerVaultTokenLocally",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "underlyingAsset",
                  "type": "address"
                },
                {
                  "name": "decimals",
                  "type": "uint256"
                },
                {
                  "name": "lastAveragePricePerShare",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "deregisterVaultTokenLocally",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addPriceSnapshot",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositForYield",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositForYield",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawFromYield",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawFromYield",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_tokenPath",
              "type": "address[]"
            },
            {
              "name": "_poolPath",
              "type": "address[]"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_tokenPath",
              "type": "address[]"
            },
            {
              "name": "_poolPath",
              "type": "address[]"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_borrowAsset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_borrowAsset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_paymentAsset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_paymentAsset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "deleverageWithSpecificAssets",
          "inputs": [
            {
              "name": "_assets",
              "type": "tuple[]",
              "components": [
                {
                  "name": "vaultId",
                  "type": "uint256"
                },
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "targetRepayAmount",
                  "type": "uint256"
                }
              ]
            },
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimIncentives",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_proofs",
              "type": "bytes32[]"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimIncentives",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_proofs",
              "type": "bytes32[]"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasClaimableRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAccessForLego",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_action",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "string"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_tokenInAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_tokenInAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmMintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmMintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "RIPE_REGISTRY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "RIPE_GREEN_TOKEN",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "RIPE_SAVINGS_GREEN",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "RIPE_TOKEN",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "USDC",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_undyHq",
              "type": "address"
            },
            {
              "name": "_ripeRegistry",
              "type": "address"
            },
            {
              "name": "_usdc",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "interfaces/WalletStructs.vyi": {
            "content": "# @version 0.4.3\n\nflag ActionType:\n    TRANSFER\n    EARN_DEPOSIT\n    EARN_WITHDRAW\n    EARN_REBALANCE\n    SWAP\n    MINT_REDEEM\n    CONFIRM_MINT_REDEEM\n    ADD_COLLATERAL\n    REMOVE_COLLATERAL\n    BORROW\n    REPAY_DEBT\n    REWARDS\n    ETH_TO_WETH\n    WETH_TO_ETH\n    ADD_LIQ\n    REMOVE_LIQ\n    ADD_LIQ_CONC\n    REMOVE_LIQ_CONC\n    PAY_CHEQUE\n\nstruct WalletAssetData:\n    assetBalance: uint256\n    usdValue: uint256\n    isYieldAsset: bool\n    lastPricePerShare: uint256\n\nstruct ActionData:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    billing: address\n    vaultRegistry: address\n    wallet: address\n    walletConfig: address\n    walletOwner: address\n    inEjectMode: bool\n    isFrozen: bool\n    lastTotalUsdValue: uint256\n    signer: address\n    isManager: bool\n    legoId: uint256\n    legoAddr: address\n    eth: address\n    weth: address\n\nstruct MiniAddys:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    appraiser: address",
            "sha256sum": "466493c129135c95470aaf70eeddc936632f7b0f813396e5a7ddc03bea9da518"
          },
          "interfaces/LegoPartner.vyi": {
            "content": "# @version 0.4.3\n\nfrom interfaces import WalletStructs as ws\n\nMAX_TOKEN_PATH: constant(uint256) = 5\nMAX_RECOVER_ASSETS: constant(uint256) = 20\nMAX_PROOFS: constant(uint256) = 25\n\n@external\ndef addLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _tickLower: int24, _tickUpper: int24, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef addLiquidity(_pool: address, _tokenA: address, _tokenB: address, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _minLpAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (address, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef removeLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _liqToRemove: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef removeLiquidity(_pool: address, _tokenA: address, _tokenB: address, _lpToken: address, _lpAmount: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef mintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _tokenInAmount: uint256, _minAmountOut: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef swapTokens(_amountIn: uint256, _minAmountOut: uint256, _tokenPath: DynArray[address, MAX_TOKEN_PATH], _poolPath: DynArray[address, MAX_TOKEN_PATH - 1], _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256):\n    ...\n\n@external\ndef depositForYield(_asset: address, _amount: uint256, _vaultAddr: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef withdrawFromYield(_vaultToken: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef confirmMintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef borrow(_borrowAsset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef repayDebt(_paymentAsset: address, _paymentAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef claimIncentives(_user: address, _rewardToken: address, _rewardAmount: uint256, _proofs: DynArray[bytes32, MAX_PROOFS], _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef removeCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef addCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@view\n@external\ndef getAccessForLego(_user: address, _action: ws.ActionType) -> (address, String[64], uint256):\n    ...\n\n@view\n@external\ndef hasCapability(_action: ws.ActionType) -> bool:\n    ...\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    ...\n\n@view\n@external\ndef isYieldLego() -> bool:\n    ...\n\n@view\n@external\ndef isDexLego() -> bool:\n    ...\n\n\n# common\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "f2afb7bd72d4301aea77bbe4177b7ae954ba6f6b76af363965993eb92ad0b715"
          },
          "interfaces/LegoStructs.vyi": {
            "content": "# @version 0.4.3\n\nstruct VaultTokenInfo:\n    underlyingAsset: address\n    decimals: uint256\n    lastAveragePricePerShare: uint256\n\nstruct SnapShotPriceConfig:\n    minSnapshotDelay: uint256\n    maxNumSnapshots: uint256\n    maxUpsideDeviation: uint256\n    staleTime: uint256\n\nstruct SingleSnapShot:\n    totalSupply: uint256\n    pricePerShare: uint256\n    lastUpdate: uint256\n\nstruct SnapShotData:\n    lastSnapShot: SingleSnapShot\n    nextIndex: uint256\n",
            "sha256sum": "8ae48be17d812d57fbd671bbf0593e8abf175ad0924e47c5997823cac19ec806"
          },
          "interfaces/YieldLego.vyi": {
            "content": "# @version 0.4.3\n\nfrom interfaces import LegoStructs as ls\n\n\n###################\n# Underlying Data #\n###################\n\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    ...\n\n\n@view\n@external\ndef getUnderlyingBalances(_vaultToken: address, _vaultTokenBalance: uint256) -> (uint256, uint256):\n    ...\n\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    ...\n\n\n@view\n@external\ndef getUnderlyingAmountSafe(_vaultToken: address, _vaultTokenBalance: uint256) -> uint256:\n    ...\n\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> (address, uint256, uint256):\n    ...\n\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> uint256:\n    ...\n\n\n###############\n# Other Utils #\n###############\n\n\n@view\n@external\ndef isRebasing() -> bool:\n    ...\n\n\n@view\n@external\ndef getPricePerShare(_vaultToken: address, _decimals: uint256 = 0) -> uint256:\n    ...\n\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef canRegisterVaultToken(_asset: address, _vaultToken: address) -> bool:\n    ...\n\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef getUtilizationRatio(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef getAvailLiquidity(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef isEligibleForYieldBonus(_asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef getWithdrawalFees(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    ...\n\n\n###################\n# Yield Lego Data #\n###################\n\n\n@view\n@external\ndef isLegoAsset(_asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, 40]:\n    ...\n\n\n@view\n@external\ndef getAssets() -> DynArray[address, 20]:\n    ...\n\n\n@view\n@external\ndef isAssetOpportunity(_asset: address, _vaultAddr: address) -> bool:\n    ...\n\n\n@view\n@external\ndef getNumLegoAssets() -> uint256:\n    ...\n\n\n@view\n@external\ndef assets(_index: uint256) -> address:\n    ...\n\n\n@view\n@external\ndef indexOfAsset(_asset: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef numAssets() -> uint256:\n    ...\n\n\n@view\n@external\ndef assetOpportunities(_asset: address, _index: uint256) -> address:\n    ...\n\n\n@view\n@external\ndef indexOfAssetOpportunity(_asset: address, _vaultAddr: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef numAssetOpportunities(_asset: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef vaultToAsset(_vaultAddr: address) -> ls.VaultTokenInfo:\n    ...\n\n\n# price snapshots\n\n\n@external\ndef addPriceSnapshot(_vaultToken: address) -> bool:\n    ...\n\n\n@view\n@external\ndef snapShotPriceConfig() -> ls.SnapShotPriceConfig:\n    ...\n\n\n@view\n@external\ndef snapShotData(_vaultToken: address) -> ls.SnapShotData:\n    ...\n\n\n@view\n@external\ndef snapShots(_vaultToken: address, _index: uint256) -> ls.SingleSnapShot:\n    ...\n\n\n@view\n@external\ndef getWeightedPricePerShare(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef getLatestSnapshot(_vaultToken: address, _pricePerShare: uint256) -> ls.SingleSnapShot:\n    ...\n\n\n@external\ndef setSnapShotPriceConfig(_config: ls.SnapShotPriceConfig):\n    ...\n",
            "sha256sum": "db91c139f6018f5218b389d08c8703bc16fb994aa948805dbfea27e072f382ec"
          },
          "contracts/modules/Addys.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\ninterface UndyHq:\n    def isValidAddr(_addr: address) -> bool: view\n    def getAddr(_regId: uint256) -> address: view\n    def undyToken() -> address: view\n\ninterface Switchboard:\n    def isSwitchboardAddr(_addr: address) -> bool: view\n\ninterface LegoBook:\n    def isLegoAddr(_addr: address) -> bool: view\n\nstruct Addys:\n    hq: address\n    undyToken: address\n    ledger: address\n    missionControl: address\n    legoBook: address\n    switchboard: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    walletBackpack: address\n    billing: address\n    vaultRegistry: address\n\n# hq\nUNDY_HQ_FOR_ADDYS: immutable(address)\n\n# core addys\nLEDGER_ID: constant(uint256) = 1\nMISSION_CONTROL_ID: constant(uint256) = 2\nLEGO_BOOK_ID: constant(uint256) = 3\nSWITCHBOARD_ID: constant(uint256) = 4\nHATCHERY_ID: constant(uint256) = 5\nLOOT_DISTRIBUTOR_ID: constant(uint256) = 6\nAPPRAISER_ID: constant(uint256) = 7\nWALLET_BACKPACK_ID: constant(uint256) = 8\nBILLING_ID: constant(uint256) = 9\nVAULT_REGISTRY_ID: constant(uint256) = 10\n\n\n@deploy\ndef __init__(_undyHq: address):\n    assert _undyHq != empty(address) # dev: invalid undy hq\n    UNDY_HQ_FOR_ADDYS = _undyHq\n\n\n########\n# Core #\n########\n\n\n@view\n@external\ndef getAddys() -> Addys:\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _getAddys(_addys: Addys = empty(Addys)) -> Addys:\n    if _addys.hq != empty(address):\n        return _addys\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _generateAddys() -> Addys:\n    hq: address = UNDY_HQ_FOR_ADDYS\n    return Addys(\n        hq = hq,\n        undyToken = staticcall UndyHq(hq).undyToken(),\n        ledger = staticcall UndyHq(hq).getAddr(LEDGER_ID),\n        missionControl = staticcall UndyHq(hq).getAddr(MISSION_CONTROL_ID),\n        legoBook = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID),\n        switchboard = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID),\n        hatchery = staticcall UndyHq(hq).getAddr(HATCHERY_ID),\n        lootDistributor = staticcall UndyHq(hq).getAddr(LOOT_DISTRIBUTOR_ID),\n        appraiser = staticcall UndyHq(hq).getAddr(APPRAISER_ID),\n        walletBackpack = staticcall UndyHq(hq).getAddr(WALLET_BACKPACK_ID),\n        billing = staticcall UndyHq(hq).getAddr(BILLING_ID),\n        vaultRegistry = staticcall UndyHq(hq).getAddr(VAULT_REGISTRY_ID),\n    )\n\n\n##########\n# Tokens #\n##########\n\n\n@view\n@internal\ndef _getUndyToken() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).undyToken()\n\n\n###########\n# Helpers #\n###########\n\n\n# undy hq\n\n\n@view\n@external\ndef getUndyHq() -> address:\n    return self._getUndyHq()\n\n\n@view\n@internal\ndef _getUndyHq() -> address:\n    return UNDY_HQ_FOR_ADDYS\n\n\n# utils\n\n\n@view\n@internal\ndef _isValidUndyAddr(_addr: address, _hq: address = empty(address)) -> bool:\n    hq: address = _hq\n    if _hq == empty(address):\n        hq = UNDY_HQ_FOR_ADDYS\n    \n    # core departments\n    if staticcall UndyHq(hq).isValidAddr(_addr):\n        return True\n\n    # lego book\n    legoBook: address = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID)\n    if legoBook != empty(address) and staticcall LegoBook(legoBook).isLegoAddr(_addr):\n        return True\n\n    # switchboard config\n    switchboard: address = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID)\n    if switchboard != empty(address) and staticcall Switchboard(switchboard).isSwitchboardAddr(_addr):\n        return True\n\n    return False\n\n\n@view\n@internal\ndef _isSwitchboardAddr(_addr: address) -> bool:\n    switchboard: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n    if switchboard == empty(address):\n        return False\n    return staticcall Switchboard(switchboard).isSwitchboardAddr(_addr)\n\n\n@view\n@internal\ndef _isLegoBookAddr(_addr: address) -> bool:\n    legoBook: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n    if legoBook == empty(address):\n        return False\n    return staticcall LegoBook(legoBook).isLegoAddr(_addr)\n\n\n###############\n# Departments #\n###############\n\n\n# ledger\n\n\n@view\n@internal\ndef _getLedgerId() -> uint256:\n    return LEDGER_ID\n\n\n@view\n@internal\ndef _getLedgerAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEDGER_ID)\n\n\n# mission control\n\n\n@view\n@internal\ndef _getMissionControlId() -> uint256:\n    return MISSION_CONTROL_ID\n\n\n@view\n@internal\ndef _getMissionControlAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(MISSION_CONTROL_ID)\n\n\n# lego book\n\n\n@view\n@internal\ndef _getLegoBookId() -> uint256:\n    return LEGO_BOOK_ID\n\n\n@view\n@internal\ndef _getLegoBookAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n\n\n# switchboard\n\n\n@view\n@internal\ndef _getSwitchboardId() -> uint256:\n    return SWITCHBOARD_ID\n\n\n@view\n@internal\ndef _getSwitchboardAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n\n\n# hatchery\n\n\n@view\n@internal\ndef _getHatcheryId() -> uint256:\n    return HATCHERY_ID\n\n\n@view\n@internal\ndef _getHatcheryAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(HATCHERY_ID)\n\n\n# loot distributor\n\n\n@view\n@internal\ndef _getLootDistributorId() -> uint256:\n    return LOOT_DISTRIBUTOR_ID\n\n\n@view\n@internal\ndef _getLootDistributorAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LOOT_DISTRIBUTOR_ID)\n\n\n# appraiser\n\n\n@view\n@internal\ndef _getAppraiserId() -> uint256:\n    return APPRAISER_ID\n\n\n@view\n@internal\ndef _getAppraiserAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(APPRAISER_ID)\n\n\n# wallet backpack\n\n\n@view\n@internal\ndef _getWalletBackpackId() -> uint256:\n    return WALLET_BACKPACK_ID\n\n\n@view\n@internal\ndef _getWalletBackpackAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(WALLET_BACKPACK_ID)\n\n\n# billing\n\n\n@view\n@internal\ndef _getBillingId() -> uint256:\n    return BILLING_ID\n\n\n@view\n@internal\ndef _getBillingAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(BILLING_ID)\n\n\n# vault registry\n\n\n@view\n@internal\ndef _getVaultRegistryId() -> uint256:\n    return VAULT_REGISTRY_ID\n\n\n@view\n@internal\ndef _getVaultRegistryAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(VAULT_REGISTRY_ID)",
            "sha256sum": "4df6b72db9bb417d1af81660175be1450cfb7b3575f3d17a5b8a130bff87b781"
          },
          "contracts/modules/YieldLegoData.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nuses: addys\n\nimport contracts.modules.Addys as addys\n\nfrom interfaces import WalletStructs as ws\nfrom interfaces import LegoStructs as ls\nfrom ethereum.ercs import IERC20\nfrom ethereum.ercs import IERC20Detailed\n\nevent AssetOpportunityAdded:\n    asset: indexed(address)\n    vaultAddr: indexed(address)\n\nevent AssetOpportunityRemoved:\n    asset: indexed(address)\n    vaultAddr: indexed(address)\n\nevent LegoPauseModified:\n    isPaused: bool\n\nevent LegoFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    balance: uint256\n\nevent PricePerShareSnapShotAdded:\n    vaultToken: indexed(address)\n    totalSupply: uint256\n    pricePerShare: uint256\n    lastAveragePricePerShare: uint256\n\nevent SnapShotPriceConfigSet:\n    minSnapshotDelay: uint256\n    maxNumSnapshots: uint256\n    maxUpsideDeviation: uint256\n    staleTime: uint256\n\n# core\nvaultToAsset: public(HashMap[address, ls.VaultTokenInfo]) # vault addr -> data\n\n# asset opportunities\nassetOpportunities: public(HashMap[address, HashMap[uint256, address]]) # asset -> index -> vault addr\nindexOfAssetOpportunity: public(HashMap[address, HashMap[address, uint256]]) # asset -> vault addr -> index\nnumAssetOpportunities: public(HashMap[address, uint256]) # asset -> number of opportunities\n\n# lego assets (iterable)\nassets: public(HashMap[uint256, address]) # index -> asset\nindexOfAsset: public(HashMap[address, uint256]) # asset -> index\nnumAssets: public(uint256) # num assets\n\n# price snapshots\nsnapShotData: public(HashMap[address, ls.SnapShotData]) # vault token -> data\nsnapShots: public(HashMap[address, HashMap[uint256, ls.SingleSnapShot]]) # vault token -> index -> snapshot\nsnapShotPriceConfig: public(ls.SnapShotPriceConfig) # config\n\nisPaused: public(bool)\n\nMAX_VAULTS: constant(uint256) = 40\nMAX_ASSETS: constant(uint256) = 20\nMAX_RECOVER_ASSETS: constant(uint256) = 20\nONE_DAY_SECONDS: constant(uint256) = 60 * 60 * 24\nONE_WEEK_SECONDS: constant(uint256) = ONE_DAY_SECONDS * 7\nHUNDRED_PERCENT: constant(uint256) = 100_00\n\n\n@deploy\ndef __init__(_shouldPause: bool):\n    self.isPaused = _shouldPause\n    self.numAssets = 1 # not using 0 index\n\n    # default snapshot price config\n    self.snapShotPriceConfig = ls.SnapShotPriceConfig(\n        minSnapshotDelay = 60 * 10, # 10 minutes\n        maxNumSnapshots = 20,\n        maxUpsideDeviation = 10_00, # 10%\n        staleTime = ONE_DAY_SECONDS, # 1 day\n    )\n\n\n#########\n# Views #\n#########\n\n\n# is lego asset\n\n\n@view\n@external\ndef isLegoAsset(_asset: address) -> bool:\n    return self._isLegoAsset(_asset)\n\n\n@view\n@internal\ndef _isLegoAsset(_asset: address) -> bool:\n    return self.indexOfAsset[_asset] != 0\n\n\n# vault opportunities\n\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, MAX_VAULTS]:\n    numOpportunities: uint256 = self.numAssetOpportunities[_asset]\n    if numOpportunities == 0:\n        return []\n    opportunities: DynArray[address, MAX_VAULTS] = []\n    for i: uint256 in range(1, numOpportunities, bound=MAX_VAULTS):\n        opportunities.append(self.assetOpportunities[_asset][i])\n    return opportunities\n\n\n# all assets registered\n\n\n@view\n@external\ndef getAssets() -> DynArray[address, MAX_ASSETS]:\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return []\n    assets: DynArray[address, MAX_ASSETS] = []\n    for i: uint256 in range(1, numAssets, bound=MAX_ASSETS):\n        assets.append(self.assets[i])\n    return assets\n\n\n################\n# Registration #\n################\n\n\n@view\n@external\ndef isAssetOpportunity(_asset: address, _vaultAddr: address) -> bool:\n    return self._isAssetOpportunity(_asset, _vaultAddr)\n\n\n@view\n@internal\ndef _isAssetOpportunity(_asset: address, _vaultAddr: address) -> bool:\n    return self.indexOfAssetOpportunity[_asset][_vaultAddr] != 0\n\n\n# add asset opportunity\n\n\n@internal\ndef _addAssetOpportunity(_asset: address, _vaultAddr: address) -> ls.VaultTokenInfo:\n    if self.indexOfAssetOpportunity[_asset][_vaultAddr] != 0:\n        return self.vaultToAsset[_vaultAddr]\n\n    if empty(address) in [_asset, _vaultAddr]:\n        return empty(ls.VaultTokenInfo)\n\n    # add asset opportunity\n    aid: uint256 = self.numAssetOpportunities[_asset]\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.assetOpportunities[_asset][aid] = _vaultAddr\n    self.indexOfAssetOpportunity[_asset][_vaultAddr] = aid\n    self.numAssetOpportunities[_asset] = aid + 1\n\n    # add mapping\n    vaultInfo: ls.VaultTokenInfo = ls.VaultTokenInfo(\n        underlyingAsset = _asset,\n        decimals = convert(staticcall IERC20Detailed(_vaultAddr).decimals(), uint256),\n        lastAveragePricePerShare = 0,\n    )\n    self.vaultToAsset[_vaultAddr] = vaultInfo\n\n    # add asset\n    self._addAsset(_asset)\n\n    log AssetOpportunityAdded(asset=_asset, vaultAddr=_vaultAddr)\n    return vaultInfo\n\n\n# remove asset opportunity\n\n\n@internal\ndef _removeAssetOpportunity(_asset: address, _vaultAddr: address):\n    numOpportunities: uint256 = self.numAssetOpportunities[_asset]\n    if numOpportunities == 0:\n        return\n\n    targetIndex: uint256 = self.indexOfAssetOpportunity[_asset][_vaultAddr]\n    if targetIndex == 0:\n        return\n\n    # update data\n    lastIndex: uint256 = numOpportunities - 1\n    self.numAssetOpportunities[_asset] = lastIndex\n    self.indexOfAssetOpportunity[_asset][_vaultAddr] = 0\n\n    self.vaultToAsset[_vaultAddr] = empty(ls.VaultTokenInfo)\n\n    # clear all snapshot data for the vault token to prevent contamination on re-add\n    self.snapShotData[_vaultAddr] = empty(ls.SnapShotData)\n\n    # clear all historical snapshots\n    config: ls.SnapShotPriceConfig = self.snapShotPriceConfig\n    for i: uint256 in range(config.maxNumSnapshots, bound=max_value(uint256)):\n        if i >= config.maxNumSnapshots:\n            break\n        self.snapShots[_vaultAddr][i] = empty(ls.SingleSnapShot)\n\n    # shift to replace the removed one\n    if targetIndex != lastIndex:\n        lastVaultAddr: address = self.assetOpportunities[_asset][lastIndex]\n        self.assetOpportunities[_asset][targetIndex] = lastVaultAddr\n        self.indexOfAssetOpportunity[_asset][lastVaultAddr] = targetIndex\n\n    # remove asset\n    if lastIndex <= 1:\n        self._removeAsset(_asset)\n\n    log AssetOpportunityRemoved(asset=_asset, vaultAddr=_vaultAddr)\n\n\n# add asset\n\n\n@internal\ndef _addAsset(_asset: address):\n    if self.indexOfAsset[_asset] != 0:\n        return\n\n    aid: uint256 = self.numAssets\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.assets[aid] = _asset\n    self.indexOfAsset[_asset] = aid\n    self.numAssets = aid + 1\n\n\n# remove asset\n\n\n@internal\ndef _removeAsset(_asset: address):\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return\n\n    targetIndex: uint256 = self.indexOfAsset[_asset]\n    if targetIndex == 0:\n        return\n\n    # update data\n    lastIndex: uint256 = numAssets - 1\n    self.numAssets = lastIndex\n    self.indexOfAsset[_asset] = 0\n\n    # shift to replace the removed one\n    if targetIndex != lastIndex:\n        lastAsset: address = self.assets[lastIndex]\n        self.assets[targetIndex] = lastAsset\n        self.indexOfAsset[lastAsset] = targetIndex\n\n\n# num lego assets (true number, use `numAssets` for iteration)\n\n\n@view\n@external\ndef getNumLegoAssets() -> uint256:\n    return self._getNumLegoAssets()\n\n\n@view\n@internal\ndef _getNumLegoAssets() -> uint256:\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return 0\n    return numAssets - 1\n\n\n###########\n# General #\n###########\n\n\n# fill mini addys\n\n\n@view\n@internal\ndef _getMiniAddys(_miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> ws.MiniAddys:\n    if _miniAddys.ledger != empty(address):\n        return _miniAddys\n    return ws.MiniAddys(\n        ledger = addys._getLedgerAddr(),\n        missionControl = addys._getMissionControlAddr(),\n        legoBook = addys._getLegoBookAddr(),\n        appraiser = addys._getAppraiserAddr(),\n    )\n\n\n# activate\n\n\n@external\ndef pause(_shouldPause: bool):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert _shouldPause != self.isPaused # dev: no change\n    self.isPaused = _shouldPause\n    log LegoPauseModified(isPaused=_shouldPause)\n\n\n# recover funds\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    self._recoverFunds(_recipient, _asset)\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, MAX_RECOVER_ASSETS]):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    for a: address in _assets:\n        self._recoverFunds(_recipient, a)\n\n\n@internal\ndef _recoverFunds(_recipient: address, _asset: address):\n    assert empty(address) not in [_recipient, _asset] # dev: invalid recipient or asset\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    assert balance != 0 # dev: nothing to recover\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log LegoFundsRecovered(asset=_asset, recipient=_recipient, balance=balance)\n\n\n###################\n# Price Snapshots #\n###################\n\n\n# add price snapshot\n\n\n@internal\ndef _addPriceSnapshot(_vaultToken: address, _pricePerShare: uint256, _vaultTokenDecimals: uint256) -> bool:\n    config: ls.SnapShotPriceConfig = self.snapShotPriceConfig\n    if config.maxNumSnapshots == 0:\n        return False\n\n    data: ls.SnapShotData = self.snapShotData[_vaultToken]\n\n    # already have snapshot for this time\n    if data.lastSnapShot.lastUpdate == block.timestamp:\n        return False\n\n    # check if snapshot is too recent\n    if data.lastSnapShot.lastUpdate + config.minSnapshotDelay > block.timestamp:\n        return False\n\n    # create and store new snapshot\n    newSnapshot: ls.SingleSnapShot = self._getLatestSnapshot(_vaultToken, _pricePerShare, _vaultTokenDecimals, data.lastSnapShot, config)\n    data.lastSnapShot = newSnapshot\n    self.snapShots[_vaultToken][data.nextIndex] = newSnapshot\n\n    # update index\n    data.nextIndex += 1\n    if data.nextIndex >= config.maxNumSnapshots:\n        data.nextIndex = 0\n\n    # save snap shot data\n    self.snapShotData[_vaultToken] = data\n\n    # update cached weighted average price per share\n    lastAveragePricePerShare: uint256 = self._getWeightedPricePerShare(_vaultToken, _pricePerShare)\n    self.vaultToAsset[_vaultToken].lastAveragePricePerShare = lastAveragePricePerShare\n\n    log PricePerShareSnapShotAdded(\n        vaultToken = _vaultToken,\n        totalSupply = newSnapshot.totalSupply,\n        pricePerShare = newSnapshot.pricePerShare,\n        lastAveragePricePerShare = lastAveragePricePerShare,\n    )\n    return True\n\n\n# weighted price per share\n\n\n@view\n@external\ndef getWeightedPricePerShare(_vaultToken: address) -> uint256:\n    data: ls.SnapShotData = self.snapShotData[_vaultToken]\n    return self._getWeightedPricePerShare(_vaultToken, data.lastSnapShot.pricePerShare)\n\n\n@view\n@internal\ndef _getWeightedPricePerShare(_vaultToken: address, _lastPricePerShare: uint256) -> uint256:\n    config: ls.SnapShotPriceConfig = self.snapShotPriceConfig\n    if config.maxNumSnapshots == 0:\n        return 0\n\n    # calculate weighted average price using all valid snapshots\n    numerator: uint256 = 0\n    denominator: uint256 = 0\n    for i: uint256 in range(config.maxNumSnapshots, bound=max_value(uint256)):\n\n        snapShot: ls.SingleSnapShot = self.snapShots[_vaultToken][i]\n        if snapShot.pricePerShare == 0 or snapShot.totalSupply == 0 or snapShot.lastUpdate == 0:\n            continue\n\n        # too stale, skip\n        if config.staleTime != 0 and block.timestamp > snapShot.lastUpdate + config.staleTime:\n            continue\n\n        numerator += (snapShot.totalSupply * snapShot.pricePerShare)\n        denominator += snapShot.totalSupply\n\n    # weighted price per share\n    weightedPricePerShare: uint256 = 0\n    if numerator != 0:\n        weightedPricePerShare = numerator // denominator\n    else:\n        weightedPricePerShare = _lastPricePerShare\n\n    return weightedPricePerShare\n\n\n# latest snapshot\n\n\n@view\n@external\ndef getLatestSnapshot(_vaultToken: address, _pricePerShare: uint256) -> ls.SingleSnapShot:\n    data: ls.SnapShotData = self.snapShotData[_vaultToken]\n    config: ls.SnapShotPriceConfig = self.snapShotPriceConfig\n    vaultTokenDecimals: uint256 = self.vaultToAsset[_vaultToken].decimals\n    return self._getLatestSnapshot(_vaultToken, _pricePerShare, vaultTokenDecimals, data.lastSnapShot, config)\n\n\n@view\n@internal\ndef _getLatestSnapshot(\n    _vaultToken: address,\n    _pricePerShare: uint256,\n    _vaultTokenDecimals: uint256,\n    _lastSnapShot: ls.SingleSnapShot,\n    _config: ls.SnapShotPriceConfig,\n) -> ls.SingleSnapShot:\n\n    # total supply (adjusted)\n    totalSupply: uint256 = staticcall IERC20(_vaultToken).totalSupply() // (10 ** _vaultTokenDecimals)\n    if totalSupply == 0:\n        totalSupply = 1\n\n    # throttle upside (extra safety check)\n    pricePerShare: uint256 = self._throttleUpside(_pricePerShare, _lastSnapShot.pricePerShare, _config.maxUpsideDeviation)\n\n    return ls.SingleSnapShot(\n        totalSupply = totalSupply,\n        pricePerShare = pricePerShare,\n        lastUpdate = block.timestamp,\n    )\n\n\n@view\n@internal\ndef _throttleUpside(_newValue: uint256, _prevValue: uint256, _maxUpside: uint256) -> uint256:\n    if _maxUpside == 0 or _prevValue == 0 or _newValue == 0:\n        return _newValue\n    maxPricePerShare: uint256 = _prevValue + (_prevValue * _maxUpside // HUNDRED_PERCENT)\n    return min(_newValue, maxPricePerShare)\n\n\n# snapshot price config\n\n\n@external\ndef setSnapShotPriceConfig(_config: ls.SnapShotPriceConfig):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert self._isValidPriceConfig(_config) # dev: invalid config\n    self.snapShotPriceConfig = _config\n    log SnapShotPriceConfigSet(\n        minSnapshotDelay=_config.minSnapshotDelay,\n        maxNumSnapshots=_config.maxNumSnapshots,\n        maxUpsideDeviation=_config.maxUpsideDeviation,\n        staleTime=_config.staleTime\n    )\n\n\n@view\n@external\ndef isValidPriceConfig(_config: ls.SnapShotPriceConfig) -> bool:\n    return self._isValidPriceConfig(_config)\n\n\n@view\n@internal\ndef _isValidPriceConfig(_config: ls.SnapShotPriceConfig) -> bool:\n    if _config.minSnapshotDelay > ONE_WEEK_SECONDS:\n        return False\n    if _config.maxNumSnapshots == 0 or _config.maxNumSnapshots > 25:\n        return False\n    if _config.maxUpsideDeviation > HUNDRED_PERCENT:\n        return False\n    return _config.staleTime < ONE_WEEK_SECONDS",
            "sha256sum": "50440c96dc8a7af22e7ad927bb6d3e308f137d5d3632e633e084b05510c94c28"
          },
          "contracts/legos/RipeLego.vy": {
            "content": "#         _____   ____     _____       ______          ____            ______        _____           _____    \n#     ___|\\    \\ |    |___|\\    \\  ___|\\     \\        |    |       ___|\\     \\   ___|\\    \\     ____|\\    \\   \n#    |    |\\    \\|    |    |\\    \\|     \\     \\       |    |      |     \\     \\ /    /\\    \\   /     /\\    \\  \n#    |    | |    |    |    | |    |     ,_____/|      |    |      |     ,_____/|    |  |____| /     /  \\    \\ \n#    |    |/____/|    |    |/____/|     \\--'\\_|/      |    |  ____|     \\--'\\_|/    |    ____|     |    |    |\n#    |    |\\    \\|    |    ||    ||     /___/|        |    | |    |     /___/| |    |   |    |     |    |    |\n#    |    | |    |    |    ||____|/     \\____|\\       |    | |    |     \\____|\\|    |   |_,  |\\     \\  /    /|\n#    |____| |____|____|____|      |____ '     /|      |____|/____/|____ '     /|\\ ___\\___/  /| \\_____\\/____/ |\n#    |    | |    |    |    |      |    /_____/ |      |    |     ||    /_____/ | |   /____ / |\\ |    ||    | /\n#    |____| |____|____|____|      |____|     | /      |____|_____|/____|     | /\\|___|    | /  \\|____||____|/ \n#      \\(     )/   \\(   \\(          \\( |_____|/         \\(    )/    \\( |_____|/   \\( |____|/      \\(    )/    \n#       '     '     '    '           '    )/             '    '      '    )/       '   )/          '    '     \n#                                         '                               '            '                      \n#     \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n#     \u2551  ** Ripe Lego **                        \u2551\n#     \u2551  Integration with Ripe Protocol.        \u2551\n#     \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n#\n#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nimplements: Lego\nimplements: YieldLego\n\nexports: addys.__interface__\nexports: yld.__interface__\n\ninitializes: addys\ninitializes: yld[addys := addys]\n\nfrom interfaces import LegoPartner as Lego\nfrom interfaces import YieldLego as YieldLego\nfrom interfaces import WalletStructs as ws\nfrom interfaces import LegoStructs as ls\n\nimport contracts.modules.Addys as addys\nimport contracts.modules.YieldLegoData as yld\n\nfrom ethereum.ercs import IERC20\nfrom ethereum.ercs import IERC4626\nfrom ethereum.ercs import IERC20Detailed\n\ninterface RipeTeller:\n    def repay(_paymentAmount: uint256 = max_value(uint256), _user: address = msg.sender, _isPaymentSavingsGreen: bool = False, _shouldRefundSavingsGreen: bool = True) -> bool: nonpayable\n    def withdraw(_asset: address, _amount: uint256 = max_value(uint256), _user: address = msg.sender, _vaultAddr: address = empty(address), _vaultId: uint256 = 0) -> uint256: nonpayable\n    def deposit(_asset: address, _amount: uint256 = max_value(uint256), _user: address = msg.sender, _vaultAddr: address = empty(address), _vaultId: uint256 = 0) -> uint256: nonpayable\n    def borrow(_greenAmount: uint256 = max_value(uint256), _user: address = msg.sender, _wantsSavingsGreen: bool = True, _shouldEnterStabPool: bool = False) -> uint256: nonpayable\n    def deleverageWithSpecificAssets(_assets: DynArray[DeleverageAsset, MAX_DELEVERAGE_ASSETS], _user: address = msg.sender) -> uint256: nonpayable\n    def depositIntoGovVault(_asset: address, _amount: uint256, _lockDuration: uint256, _user: address = msg.sender) -> uint256: nonpayable\n    def claimLoot(_user: address = msg.sender, _shouldStake: bool = True) -> uint256: nonpayable\n\ninterface Ledger:\n    def setVaultToken(_vaultToken: address, _legoId: uint256, _underlyingAsset: address, _decimals: uint256, _isRebasing: bool): nonpayable\n    def isRegisteredVaultToken(_vaultToken: address) -> bool: view\n    def isUserWallet(_user: address) -> bool: view\n\ninterface Registry:\n    def getRegId(_addr: address) -> uint256: view\n    def getAddr(_regId: uint256) -> address: view\n    def isValidAddr(_addr: address) -> bool: view\n\ninterface RipeRegistry:\n    def savingsGreen() -> address: view\n    def greenToken() -> address: view\n    def ripeToken() -> address: view\n\ninterface Appraiser:\n    def getUsdValue(_asset: address, _amount: uint256, _missionControl: address = empty(address), _legoBook: address = empty(address), _ledger: address = empty(address)) -> uint256: view\n    def getUnderlyingUsdValue(_asset: address, _amount: uint256) -> uint256: view\n\ninterface EndaomentPsm:\n    def redeemGreen(_paymentAmount: uint256 = max_value(uint256), _recipient: address = msg.sender, _isPaymentSavingsGreen: bool = False) -> uint256: nonpayable\n    def mintGreen(_usdcAmount: uint256 = max_value(uint256), _recipient: address = msg.sender, _wantsSavingsGreen: bool = False) -> uint256: nonpayable\n\ninterface RipeMissionControl:\n    def doesUndyLegoHaveAccess(_wallet: address, _legoAddr: address) -> bool: view\n\ninterface VaultRegistry:\n    def isEarnVault(_vaultAddr: address) -> bool: view\n\ninterface UserWalletConfig:\n    def isAgentSender(_addr: address) -> bool: view\n\ninterface UserWallet:\n    def walletConfig() -> address: view\n\nstruct DeleverageAsset:\n    vaultId: uint256\n    asset: address\n    targetRepayAmount: uint256\n\nevent RipeCollateralDeposit:\n    sender: indexed(address)\n    asset: indexed(address)\n    assetAmountDeposited: uint256\n    vaultIdOrLock: uint256\n    usdValue: uint256\n    recipient: address\n\nevent RipeCollateralWithdrawal:\n    sender: indexed(address)\n    asset: indexed(address)\n    assetAmountReceived: uint256\n    vaultId: uint256\n    usdValue: uint256\n    recipient: address\n\nevent RipeBorrow:\n    sender: indexed(address)\n    asset: indexed(address)\n    assetAmountBorrowed: uint256\n    usdValue: uint256\n    recipient: address\n\nevent RipeRepay:\n    sender: indexed(address)\n    asset: indexed(address)\n    assetAmountRepaid: uint256\n    usdValue: uint256\n    recipient: address\n\nevent RipeClaimRewards:\n    sender: indexed(address)\n    asset: indexed(address)\n    ripeClaimed: uint256\n    usdValue: uint256\n    recipient: address\n\nevent RipeSavingsGreenDeposit:\n    sender: indexed(address)\n    asset: indexed(address)\n    vaultToken: indexed(address)\n    assetAmountDeposited: uint256\n    usdValue: uint256\n    vaultTokenAmountReceived: uint256\n    recipient: address\n\nevent RipeSavingsGreenWithdrawal:\n    sender: indexed(address)\n    asset: indexed(address)\n    vaultToken: indexed(address)\n    assetAmountReceived: uint256\n    usdValue: uint256\n    vaultTokenAmountBurned: uint256\n    recipient: address\n\nevent RipeEndaomentPsmSwap:\n    sender: indexed(address)\n    tokenIn: indexed(address)\n    tokenOut: indexed(address)\n    amountIn: uint256\n    amountOut: uint256\n    usdValue: uint256\n    numTokens: uint256\n    recipient: address\n\n# ripe addrs\nRIPE_REGISTRY: public(immutable(address))\nRIPE_GREEN_TOKEN: public(immutable(address))\nRIPE_SAVINGS_GREEN: public(immutable(address))\nRIPE_TOKEN: public(immutable(address))\nUSDC: public(immutable(address))\n\nRIPE_MISSION_CONTROL_ID: constant(uint256) = 5\nRIPE_TELLER_ID: constant(uint256) = 17\nRIPE_ENDAOMENT_PSM_ID: constant(uint256) = 22\n\nLEGO_ACCESS_ABI: constant(String[64]) = \"setUndyLegoAccess(address)\"\nMAX_TOKEN_PATH: constant(uint256) = 5\nMAX_PROOFS: constant(uint256) = 25\nMAX_DELEVERAGE_ASSETS: constant(uint256) = 25\n\n\n@deploy\ndef __init__(_undyHq: address, _ripeRegistry: address, _usdc: address):\n    addys.__init__(_undyHq)\n    yld.__init__(False)\n\n    assert _ripeRegistry != empty(address) # dev: invalid ripe registry\n    RIPE_REGISTRY = _ripeRegistry\n    RIPE_GREEN_TOKEN = staticcall RipeRegistry(RIPE_REGISTRY).greenToken()\n    RIPE_SAVINGS_GREEN = staticcall RipeRegistry(RIPE_REGISTRY).savingsGreen()\n    RIPE_TOKEN = staticcall RipeRegistry(RIPE_REGISTRY).ripeToken()\n\n    assert _usdc != empty(address) # dev: invalid usdc\n    USDC = _usdc\n\n\n@view\n@external\ndef hasCapability(_action: ws.ActionType) -> bool:\n    return _action in (\n        ws.ActionType.EARN_DEPOSIT | \n        ws.ActionType.EARN_WITHDRAW |\n        ws.ActionType.ADD_COLLATERAL |\n        ws.ActionType.REMOVE_COLLATERAL |\n        ws.ActionType.BORROW |\n        ws.ActionType.REPAY_DEBT |\n        ws.ActionType.REWARDS\n    )\n\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    return [RIPE_REGISTRY]\n\n\n@view\n@external\ndef isYieldLego() -> bool:\n    return True # savings green\n\n\n@view\n@external\ndef isDexLego() -> bool:\n    return False\n\n\n###################\n# Underlying Data #\n###################\n\n\n# underlying asset\n\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    return self._getUnderlyingAsset(_vaultToken)\n\n\n@view\n@internal\ndef _getUnderlyingAsset(_vaultToken: address) -> address:\n    asset: address = yld.vaultToAsset[_vaultToken].underlyingAsset\n    if asset != empty(address):\n        return asset\n    return RIPE_GREEN_TOKEN\n\n\n# underlying balances (both true and safe)\n\n\n@view\n@external\ndef getUnderlyingBalances(_vaultToken: address, _vaultTokenBalance: uint256) -> (uint256, uint256):\n    if _vaultTokenBalance == 0:\n        return 0, 0\n\n    trueUnderlying: uint256 = self._getUnderlyingAmount(_vaultToken, _vaultTokenBalance)\n    safeUnderlying: uint256 = self._getUnderlyingAmountSafe(_vaultToken, _vaultTokenBalance)\n    if safeUnderlying == 0:\n        safeUnderlying = trueUnderlying\n\n    return trueUnderlying, min(trueUnderlying, safeUnderlying)\n\n\n# underlying amount (true)\n\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    return self._getUnderlyingAmount(_vaultToken, _vaultTokenAmount)\n\n\n@view\n@internal\ndef _getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    return staticcall IERC4626(_vaultToken).convertToAssets(_vaultTokenAmount)\n\n\n# underlying amount (safe)\n\n\n@view\n@external\ndef getUnderlyingAmountSafe(_vaultToken: address, _vaultTokenBalance: uint256) -> uint256:\n    return self._getUnderlyingAmountSafe(_vaultToken, _vaultTokenBalance)\n\n\n@view\n@internal\ndef _getUnderlyingAmountSafe(_vaultToken: address, _vaultTokenBalance: uint256) -> uint256:\n    vaultInfo: ls.VaultTokenInfo = yld.vaultToAsset[_vaultToken]\n    if vaultInfo.decimals == 0:\n        return 0 # not registered\n\n    # safe underlying amount (using cached weighted average from snapshots)\n    return _vaultTokenBalance * vaultInfo.lastAveragePricePerShare // (10 ** vaultInfo.decimals)\n\n\n# underlying data (combined)\n\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> (address, uint256, uint256):\n    return self._getUnderlyingData(_vaultToken, _vaultTokenAmount, _appraiser)\n\n\n@view\n@internal\ndef _getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address) -> (address, uint256, uint256):\n    asset: address = self._getUnderlyingAsset(_vaultToken)\n    if asset == empty(address):\n        return empty(address), 0, 0 # invalid vault token\n    underlyingAmount: uint256 = self._getUnderlyingAmount(_vaultToken, _vaultTokenAmount)\n    usdValue: uint256 = self._getUsdValueViaAppraiser(asset, underlyingAmount, _appraiser)\n    return asset, underlyingAmount, usdValue\n\n\n# usd value\n\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> uint256:\n    return self._getUsdValueOfVaultToken(_vaultToken, _vaultTokenAmount, _appraiser)\n\n\n@view\n@internal\ndef _getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address) -> uint256:\n    return self._getUnderlyingData(_vaultToken, _vaultTokenAmount, _appraiser)[2]\n\n\n@view\n@internal\ndef _getUsdValueViaAppraiser(_asset: address, _amount: uint256, _appraiser: address) -> uint256:\n    appraiser: address = _appraiser\n    if _appraiser == empty(address):\n        appraiser = addys._getAppraiserAddr()\n    return staticcall Appraiser(appraiser).getUnderlyingUsdValue(_asset, _amount)\n\n\n###############\n# Other Utils #\n###############\n\n\n# basics\n\n\n@view\n@external\ndef isRebasing() -> bool:\n    return self._isRebasing()\n\n\n@view\n@internal\ndef _isRebasing() -> bool:\n    return False\n\n\n# price per share\n\n\n@view\n@external\ndef getPricePerShare(_vaultToken: address, _decimals: uint256 = 0) -> uint256:\n    decimals: uint256 = _decimals\n    if decimals == 0:\n        decimals = yld.vaultToAsset[_vaultToken].decimals\n    if decimals == 0:\n        decimals = convert(staticcall IERC20Detailed(_vaultToken).decimals(), uint256)\n    return self._getPricePerShare(_vaultToken, decimals)\n\n\n@view\n@internal\ndef _getPricePerShare(_vaultToken: address, _decimals: uint256) -> uint256:\n    return staticcall IERC4626(_vaultToken).convertToAssets(10 ** _decimals)\n\n\n# vault token amount\n\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    return staticcall IERC4626(_vaultToken).convertToShares(_assetAmount)\n\n\n# total assets\n\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    return staticcall IERC4626(_vaultToken).totalAssets()\n\n\n# total borrows\n\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    # no borrowing related to _vaultToken\n    return 0\n\n\n# avail liquidity\n\n\n@view\n@external\ndef getAvailLiquidity(_vaultToken: address) -> uint256:\n    return staticcall IERC4626(_vaultToken).totalAssets()\n\n\n# utilization\n\n\n@view\n@external\ndef getUtilizationRatio(_vaultToken: address) -> uint256:\n    # no borrowing related to _vaultToken\n    return 0\n\n\n# extras\n\n\n@view\n@external\ndef isEligibleForYieldBonus(_asset: address) -> bool:\n    return False\n\n\n@view\n@external\ndef getWithdrawalFees(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    return 0\n\n\n################\n# Registration #\n################\n\n\n# can vault be registered\n\n\n@view\n@external\ndef canRegisterVaultToken(_asset: address, _vaultToken: address) -> bool:\n    return self._canRegisterVaultToken(_asset, _vaultToken)\n\n\n@view\n@internal\ndef _canRegisterVaultToken(_asset: address, _vaultToken: address) -> bool:\n    if empty(address) in [_asset, _vaultToken]:\n        return False\n    return _asset == RIPE_GREEN_TOKEN and _vaultToken == RIPE_SAVINGS_GREEN\n\n\n# register vault token locally\n\n\n@external\ndef registerVaultTokenLocally(_asset: address, _vaultAddr: address) -> ls.VaultTokenInfo:\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert self._canRegisterVaultToken(_asset, _vaultAddr) # dev: cannot register vault token\n    assert not yld._isAssetOpportunity(_asset, _vaultAddr) # dev: already registered\n    vaultInfo: ls.VaultTokenInfo = self._registerVaultTokenLocally(_asset, _vaultAddr)\n    self._registerVaultTokenGlobally(_asset, _vaultAddr, vaultInfo.decimals, addys._getLedgerAddr(), addys._getLegoBookAddr())\n    return vaultInfo\n\n\n@internal\ndef _registerVaultTokenLocally(_asset: address, _vaultAddr: address) -> ls.VaultTokenInfo:\n    assert extcall IERC20(_asset).approve(_vaultAddr, max_value(uint256), default_return_value=True) # dev: max approval failed\n    vaultInfo: ls.VaultTokenInfo = yld._addAssetOpportunity(_asset, _vaultAddr)\n    assert vaultInfo.decimals != 0 # dev: invalid vault token\n    return vaultInfo\n\n\n# remove vault token locally\n\n\n@external\ndef deregisterVaultTokenLocally(_asset: address, _vaultAddr: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert yld._isAssetOpportunity(_asset, _vaultAddr) # dev: already registered\n    self._deregisterVaultTokenLocally(_asset, _vaultAddr)\n\n\n@internal\ndef _deregisterVaultTokenLocally(_asset: address, _vaultAddr: address):\n    assert extcall IERC20(_asset).approve(_vaultAddr, 0, default_return_value=True) # dev: max approval failed\n    yld._removeAssetOpportunity(_asset, _vaultAddr)\n\n\n# ledger registration\n\n\n@internal\ndef _registerVaultTokenGlobally(_underlyingAsset: address, _vaultToken: address, _decimals: uint256, _ledger: address, _legoBook: address):\n    if not staticcall Ledger(_ledger).isRegisteredVaultToken(_vaultToken):\n        legoId: uint256 = staticcall Registry(_legoBook).getRegId(self)\n        extcall Ledger(_ledger).setVaultToken(_vaultToken, legoId, _underlyingAsset, _decimals, self._isRebasing())\n\n\n#################\n# Yield Actions #\n#################\n\n\n# add price snapshot\n\n\n@external\ndef addPriceSnapshot(_vaultToken: address) -> bool:\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    vaultInfo: ls.VaultTokenInfo = yld.vaultToAsset[_vaultToken]\n    assert vaultInfo.decimals != 0 # dev: not registered\n    pricePerShare: uint256 = self._getPricePerShare(_vaultToken, vaultInfo.decimals)\n    return yld._addPriceSnapshot(_vaultToken, pricePerShare, vaultInfo.decimals)\n\n\n# deposit\n\n\n@external\ndef depositForYield(\n    _asset: address,\n    _amount: uint256,\n    _vaultAddr: address,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, address, uint256, uint256):\n    assert self._isAllowedToPerformAction(msg.sender) # dev: no perms\n    assert not yld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = yld._getMiniAddys(_miniAddys)\n    vaultInfo: ls.VaultTokenInfo = self._getVaultInfoOnDeposit(_asset, _vaultAddr, miniAddys.ledger, miniAddys.legoBook)\n\n    # pre balances\n    preLegoBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n\n    # transfer deposit asset to this contract\n    depositAmount: uint256 = min(_amount, staticcall IERC20(_asset).balanceOf(msg.sender))\n    assert depositAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_asset).transferFrom(msg.sender, self, depositAmount, default_return_value=True) # dev: transfer failed\n\n    # deposit assets into lego partner\n    vaultTokenAmountReceived: uint256 = extcall IERC4626(_vaultAddr).deposit(depositAmount, _recipient)\n    assert vaultTokenAmountReceived != 0 # dev: no vault tokens received\n\n    # refund if full deposit didn't get through\n    currentLegoBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    refundAssetAmount: uint256 = 0\n    if currentLegoBalance > preLegoBalance:\n        refundAssetAmount = currentLegoBalance - preLegoBalance\n        assert extcall IERC20(_asset).transfer(msg.sender, refundAssetAmount, default_return_value=True) # dev: transfer failed\n        depositAmount -= refundAssetAmount\n\n    usdValue: uint256 = staticcall Appraiser(miniAddys.appraiser).getUnderlyingUsdValue(_asset, depositAmount)\n    log RipeSavingsGreenDeposit(\n        sender = msg.sender,\n        asset = _asset,\n        vaultToken = _vaultAddr,\n        assetAmountDeposited = depositAmount,\n        usdValue = usdValue,\n        vaultTokenAmountReceived = vaultTokenAmountReceived,\n        recipient = _recipient,\n    )\n\n    # add price snapshot\n    pricePerShare: uint256 = self._getPricePerShare(_vaultAddr, vaultInfo.decimals)\n    yld._addPriceSnapshot(_vaultAddr, pricePerShare, vaultInfo.decimals)\n\n    return depositAmount, _vaultAddr, vaultTokenAmountReceived, usdValue\n\n\n# vault info on deposit\n\n\n@internal\ndef _getVaultInfoOnDeposit(_asset: address, _vaultAddr: address, _ledger: address, _legoBook: address) -> ls.VaultTokenInfo:\n    vaultInfo: ls.VaultTokenInfo = yld.vaultToAsset[_vaultAddr]\n    if vaultInfo.decimals == 0:\n        assert self._canRegisterVaultToken(_asset, _vaultAddr) # dev: cannot register vault token\n        vaultInfo = self._registerVaultTokenLocally(_asset, _vaultAddr)\n        self._registerVaultTokenGlobally(_asset, _vaultAddr, vaultInfo.decimals, _ledger, _legoBook)\n    else:\n        assert vaultInfo.underlyingAsset == _asset # dev: asset mismatch\n    return vaultInfo\n\n\n# withdraw\n\n\n@external\ndef withdrawFromYield(\n    _vaultToken: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, address, uint256, uint256):\n    assert self._isAllowedToPerformAction(msg.sender) # dev: no perms\n    assert not yld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = yld._getMiniAddys(_miniAddys)\n    vaultInfo: ls.VaultTokenInfo = self._getVaultInfoOnWithdrawal(_vaultToken, miniAddys.ledger, miniAddys.legoBook)\n\n    # pre balances\n    preLegoVaultBalance: uint256 = staticcall IERC20(_vaultToken).balanceOf(self)\n\n    # transfer vaults tokens to this contract\n    vaultTokenAmount: uint256 = min(_amount, staticcall IERC20(_vaultToken).balanceOf(msg.sender))\n    assert vaultTokenAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_vaultToken).transferFrom(msg.sender, self, vaultTokenAmount, default_return_value=True) # dev: transfer failed\n\n    # withdraw assets from lego partner\n    assetAmountReceived: uint256 = extcall IERC4626(_vaultToken).redeem(vaultTokenAmount, _recipient, self)\n    assert assetAmountReceived != 0 # dev: no asset amount received\n\n    # refund if full withdrawal didn't happen\n    currentLegoVaultBalance: uint256 = staticcall IERC20(_vaultToken).balanceOf(self)\n    refundVaultTokenAmount: uint256 = 0\n    if currentLegoVaultBalance > preLegoVaultBalance:\n        refundVaultTokenAmount = currentLegoVaultBalance - preLegoVaultBalance\n        assert extcall IERC20(_vaultToken).transfer(msg.sender, refundVaultTokenAmount, default_return_value=True) # dev: transfer failed\n        vaultTokenAmount -= refundVaultTokenAmount\n\n    usdValue: uint256 = staticcall Appraiser(miniAddys.appraiser).getUnderlyingUsdValue(vaultInfo.underlyingAsset, assetAmountReceived)\n    log RipeSavingsGreenWithdrawal(\n        sender = msg.sender,\n        asset = vaultInfo.underlyingAsset,\n        vaultToken = _vaultToken,\n        assetAmountReceived = assetAmountReceived,\n        usdValue = usdValue,\n        vaultTokenAmountBurned = vaultTokenAmount,\n        recipient = _recipient,\n    )\n\n    # add price snapshot\n    pricePerShare: uint256 = self._getPricePerShare(_vaultToken, vaultInfo.decimals)\n    yld._addPriceSnapshot(_vaultToken, pricePerShare, vaultInfo.decimals)\n\n    return vaultTokenAmount, vaultInfo.underlyingAsset, assetAmountReceived, usdValue\n\n\n# vault info on withdrawal\n\n\n@internal\ndef _getVaultInfoOnWithdrawal(_vaultAddr: address, _ledger: address, _legoBook: address) -> ls.VaultTokenInfo:\n    vaultInfo: ls.VaultTokenInfo = yld.vaultToAsset[_vaultAddr]\n    if vaultInfo.decimals == 0:\n        asset: address = staticcall IERC4626(_vaultAddr).asset()\n        assert self._canRegisterVaultToken(asset, _vaultAddr) # dev: cannot register vault token\n        vaultInfo = self._registerVaultTokenLocally(asset, _vaultAddr)\n        self._registerVaultTokenGlobally(asset, _vaultAddr, vaultInfo.decimals, _ledger, _legoBook)\n    return vaultInfo\n\n\n#################\n# Swaps via PSM #\n#################\n\n\n@external\ndef swapTokens(\n    _amountIn: uint256,\n    _minAmountOut: uint256,\n    _tokenPath: DynArray[address, MAX_TOKEN_PATH],\n    _poolPath: DynArray[address, MAX_TOKEN_PATH - 1],\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256):\n    assert not yld.isPaused # dev: paused\n    assert self._isAllowedToPerformAction(msg.sender) # dev: no perms\n    miniAddys: ws.MiniAddys = yld._getMiniAddys(_miniAddys)\n\n    assert len(_tokenPath) == 2 # dev: invalid token path\n    tokenIn: address = _tokenPath[0]\n    tokenOut: address = _tokenPath[1]\n    assert tokenIn != tokenOut # dev: same token\n\n    # must be GREEN and USDC\n    savingsGreen: address = RIPE_SAVINGS_GREEN\n    green: address = RIPE_GREEN_TOKEN\n    usdc: address = USDC\n    assert tokenIn in [green, savingsGreen, usdc] # dev: invalid tokens\n    assert tokenOut in [green, savingsGreen, usdc] # dev: invalid tokens\n\n    # prevent GREEN <-> SAVINGS_GREEN swaps (use depositForYield/withdrawFromYield instead)\n    bothAreGreenVariants: bool = (tokenIn in [green, savingsGreen]) and (tokenOut in [green, savingsGreen])\n    assert not bothAreGreenVariants # dev: cannot swap into or out of savings green\n\n    # pre balances\n    preLegoBalance: uint256 = staticcall IERC20(tokenIn).balanceOf(self)\n\n    # transfer swap asset to this contract\n    amountIn: uint256 = min(_amountIn, staticcall IERC20(tokenIn).balanceOf(msg.sender))\n    assert amountIn != 0 # dev: nothing to transfer\n    assert extcall IERC20(tokenIn).transferFrom(msg.sender, self, amountIn, default_return_value=True) # dev: transfer failed\n\n    # swap via endaoment psm\n    endaomentPsm: address = staticcall Registry(RIPE_REGISTRY).getAddr(RIPE_ENDAOMENT_PSM_ID)\n    assert extcall IERC20(tokenIn).approve(endaomentPsm, amountIn, default_return_value=True) # dev: approval failed\n\n    # swap GREEN -> USDC\n    amountOut: uint256 = 0\n    if tokenIn in [green, savingsGreen]:\n        amountOut = extcall EndaomentPsm(endaomentPsm).redeemGreen(amountIn, _recipient, tokenIn == savingsGreen)\n\n    # swap USDC -> GREEN\n    elif tokenIn == usdc:\n        amountOut = extcall EndaomentPsm(endaomentPsm).mintGreen(amountIn, _recipient, tokenOut == savingsGreen)\n\n    # reset approvals\n    assert extcall IERC20(tokenIn).approve(endaomentPsm, 0, default_return_value=True) # dev: approval failed\n\n    # refund if full swap didn't get through\n    currentLegoBalance: uint256 = staticcall IERC20(tokenIn).balanceOf(self)\n    refundAssetAmount: uint256 = 0\n    if currentLegoBalance > preLegoBalance:\n        refundAssetAmount = currentLegoBalance - preLegoBalance\n        assert extcall IERC20(tokenIn).transfer(msg.sender, refundAssetAmount, default_return_value=True) # dev: transfer failed\n        amountIn -= refundAssetAmount\n\n    # adjust min amount out\n    minAmountOut: uint256 = _minAmountOut\n    if amountIn < _amountIn and _amountIn != max_value(uint256):\n        minAmountOut = _minAmountOut * amountIn // _amountIn\n    assert amountOut >= minAmountOut # dev: min amount out not met\n\n    # get usd values\n    usdValue: uint256 = staticcall Appraiser(miniAddys.appraiser).getUsdValue(tokenIn, amountIn, miniAddys.missionControl, miniAddys.legoBook, miniAddys.ledger)\n    if usdValue == 0:\n        usdValue = staticcall Appraiser(miniAddys.appraiser).getUsdValue(tokenOut, amountOut, miniAddys.missionControl, miniAddys.legoBook, miniAddys.ledger)\n\n    log RipeEndaomentPsmSwap(\n        sender = msg.sender,\n        tokenIn = tokenIn,\n        tokenOut = tokenOut,\n        amountIn = amountIn,\n        amountOut = amountOut,\n        usdValue = usdValue,\n        numTokens = 2,\n        recipient = _recipient,\n    )\n    return amountIn, amountOut, usdValue\n\n\n###################\n# Debt Management #\n###################\n\n\n# add collateral on Ripe\n\n\n@external\ndef addCollateral(\n    _asset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    assert self._isAllowedToPerformAction(msg.sender) # dev: no perms\n    assert not yld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = yld._getMiniAddys(_miniAddys)\n\n    assert msg.sender == _recipient # dev: recipient must be caller\n\n    # pre balances\n    preLegoBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n\n    # transfer deposit asset to this contract\n    depositAmount: uint256 = min(_amount, staticcall IERC20(_asset).balanceOf(msg.sender))\n    assert depositAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_asset).transferFrom(msg.sender, self, depositAmount, default_return_value=True) # dev: transfer failed\n\n    vaultIdOrLock: uint256 = 0\n    if _extraData != empty(bytes32):\n        vaultIdOrLock = convert(_extraData, uint256)\n\n    # deposit into Ripe Protocol\n    teller: address = self._getRipeTellerAndApprove(_asset)\n    if _asset == RIPE_TOKEN:\n        depositAmount = extcall RipeTeller(teller).depositIntoGovVault(_asset, depositAmount, vaultIdOrLock, _recipient)\n    else:\n        depositAmount = extcall RipeTeller(teller).deposit(_asset, depositAmount, _recipient, empty(address), vaultIdOrLock)\n    self._resetTellerApproval(_asset, teller)\n\n    # refund if full deposit didn't get through\n    currentLegoBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    refundAssetAmount: uint256 = 0\n    if currentLegoBalance > preLegoBalance:\n        refundAssetAmount = currentLegoBalance - preLegoBalance\n        assert extcall IERC20(_asset).transfer(msg.sender, refundAssetAmount, default_return_value=True) # dev: transfer failed\n\n    usdValue: uint256 = staticcall Appraiser(miniAddys.appraiser).getUsdValue(_asset, depositAmount, miniAddys.missionControl, miniAddys.legoBook, miniAddys.ledger)\n    log RipeCollateralDeposit(\n        sender = msg.sender,\n        asset = _asset,\n        assetAmountDeposited = depositAmount,\n        vaultIdOrLock = vaultIdOrLock,\n        usdValue = usdValue,\n        recipient = _recipient,\n    )\n    return depositAmount, usdValue\n\n\n# remove collateral on ripe\n\n\n@external\ndef removeCollateral(\n    _asset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    assert self._isAllowedToPerformAction(msg.sender) # dev: no perms\n    assert not yld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = yld._getMiniAddys(_miniAddys)\n\n    assert msg.sender == _recipient # dev: recipient must be caller\n\n    vaultId: uint256 = 0\n    if _extraData != empty(bytes32):\n        vaultId = convert(_extraData, uint256)\n\n    # withdraw from Ripe Protocol\n    ripeHq: address = RIPE_REGISTRY\n    teller: address = staticcall Registry(ripeHq).getAddr(RIPE_TELLER_ID)\n    amountRemoved: uint256 = extcall RipeTeller(teller).withdraw(_asset, _amount, _recipient, empty(address), vaultId)\n    assert amountRemoved != 0 # dev: no asset amount received\n\n    usdValue: uint256 = staticcall Appraiser(miniAddys.appraiser).getUsdValue(_asset, amountRemoved, miniAddys.missionControl, miniAddys.legoBook, miniAddys.ledger)\n    log RipeCollateralWithdrawal(\n        sender = msg.sender,\n        asset = _asset,\n        assetAmountReceived = amountRemoved,\n        vaultId = vaultId,\n        usdValue = usdValue,\n        recipient = _recipient,\n    )\n    return amountRemoved, usdValue\n\n\n# borrow\n\n\n@external\ndef borrow(\n    _borrowAsset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    assert self._isAllowedToPerformAction(msg.sender) # dev: no perms\n    assert not yld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = yld._getMiniAddys(_miniAddys)\n\n    assert msg.sender == _recipient # dev: recipient must be caller\n\n    savingsGreen: address = RIPE_SAVINGS_GREEN\n    assert _borrowAsset in [RIPE_GREEN_TOKEN, savingsGreen] # dev: invalid borrow asset\n    wantsSavingsGreen: bool = _borrowAsset == savingsGreen\n\n    # Extract shouldEnterStabPool from extraData (1 bit in lowest position)\n    shouldEnterStabPool: bool = convert(convert(_extraData, uint256) & 1, bool)\n\n    # borrow from Ripe\n    teller: address = staticcall Registry(RIPE_REGISTRY).getAddr(RIPE_TELLER_ID)\n    borrowAmount: uint256 = extcall RipeTeller(teller).borrow(_amount, _recipient, wantsSavingsGreen, shouldEnterStabPool)\n    assert borrowAmount != 0 # dev: no borrow amount received\n\n    usdValue: uint256 = staticcall Appraiser(miniAddys.appraiser).getUnderlyingUsdValue(_borrowAsset, borrowAmount)\n    log RipeBorrow(\n        sender = msg.sender,\n        asset = _borrowAsset,\n        assetAmountBorrowed = borrowAmount,\n        usdValue = usdValue,\n        recipient = _recipient,\n    )\n    return borrowAmount, usdValue\n\n\n# repay debt\n\n\n@external\ndef repayDebt(\n    _paymentAsset: address,\n    _paymentAmount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    assert self._isAllowedToPerformAction(msg.sender) # dev: no perms\n    assert not yld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = yld._getMiniAddys(_miniAddys)\n\n    assert msg.sender == _recipient # dev: recipient must be caller\n\n    savingsGreen: address = RIPE_SAVINGS_GREEN\n    assert _paymentAsset in [RIPE_GREEN_TOKEN, savingsGreen] # dev: invalid payment asset\n    isPaymentSavingsGreen: bool = _paymentAsset == savingsGreen\n\n    # pre balances\n    preLegoBalance: uint256 = staticcall IERC20(_paymentAsset).balanceOf(self)\n\n    # transfer deposit asset to this contract\n    paymentAmount: uint256 = min(_paymentAmount, staticcall IERC20(_paymentAsset).balanceOf(msg.sender))\n    assert paymentAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_paymentAsset).transferFrom(msg.sender, self, paymentAmount, default_return_value=True) # dev: transfer failed\n\n    # deposit into Ripe Protocol\n    teller: address = self._getRipeTellerAndApprove(_paymentAsset)\n    extcall RipeTeller(teller).repay(paymentAmount, _recipient, isPaymentSavingsGreen, True)\n    self._resetTellerApproval(_paymentAsset, teller)\n\n    # refund if full deposit didn't get through\n    currentLegoBalance: uint256 = staticcall IERC20(_paymentAsset).balanceOf(self)\n    refundAssetAmount: uint256 = 0\n    if currentLegoBalance > preLegoBalance:\n        refundAssetAmount = currentLegoBalance - preLegoBalance\n        assert extcall IERC20(_paymentAsset).transfer(msg.sender, refundAssetAmount, default_return_value=True) # dev: transfer failed\n\n    usdValue: uint256 = staticcall Appraiser(miniAddys.appraiser).getUsdValue(_paymentAsset, paymentAmount, miniAddys.missionControl, miniAddys.legoBook, miniAddys.ledger)\n    log RipeRepay(\n        sender = msg.sender,\n        asset = _paymentAsset,\n        assetAmountRepaid = paymentAmount,\n        usdValue = usdValue,\n        recipient = _recipient,\n    )\n    return paymentAmount, usdValue\n\n\n# deleverage\n\n\n@external\ndef deleverageWithSpecificAssets(_assets: DynArray[DeleverageAsset, MAX_DELEVERAGE_ASSETS], _user: address) -> uint256:\n    walletConfig: address = staticcall UserWallet(_user).walletConfig()\n    assert staticcall UserWalletConfig(walletConfig).isAgentSender(msg.sender) # dev: no perms\n\n    teller: address = staticcall Registry(RIPE_REGISTRY).getAddr(RIPE_TELLER_ID)\n    return extcall RipeTeller(teller).deleverageWithSpecificAssets(_assets, _user)\n\n\n# shared utils\n\n\n@internal\ndef _getRipeTellerAndApprove(_asset: address) -> address:\n    teller: address = staticcall Registry(RIPE_REGISTRY).getAddr(RIPE_TELLER_ID)\n    # some vault tokens require max value approval (comp v3)\n    assert extcall IERC20(_asset).approve(teller, max_value(uint256), default_return_value = True) # dev: appr\n    return teller\n\n\n@internal\ndef _resetTellerApproval(_asset: address, _teller: address):\n    if _teller != empty(address):\n        assert extcall IERC20(_asset).approve(_teller, 0, default_return_value = True) # dev: approval failed\n\n\n@view\n@internal\ndef _isUserWalletOrEarnVault(_user: address) -> bool:\n    return staticcall Ledger(addys._getLedgerAddr()).isUserWallet(_user) or staticcall VaultRegistry(addys._getVaultRegistryAddr()).isEarnVault(_user)\n\n\n#################\n# Claim Rewards #\n#################\n\n\n@external\ndef claimIncentives(\n    _user: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _proofs: DynArray[bytes32, MAX_PROOFS],\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    assert self._isAllowedToPerformAction(msg.sender) # dev: no perms\n    return self._claimRewards(_user, _rewardToken, _rewardAmount, _miniAddys)\n\n\n@external\ndef claimRewards(\n    _user: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _extraData: bytes32,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    assert self._isAllowedToPerformAction(msg.sender) # dev: no perms\n    return self._claimRewards(_user, _rewardToken, _rewardAmount, _miniAddys)\n\n\n@internal\ndef _claimRewards(\n    _user: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _miniAddys: ws.MiniAddys,\n) -> (uint256, uint256):\n    miniAddys: ws.MiniAddys = yld._getMiniAddys(_miniAddys)\n    assert not yld.isPaused # dev: paused\n    assert _rewardToken == RIPE_TOKEN # dev: invalid reward token\n\n    teller: address = staticcall Registry(RIPE_REGISTRY).getAddr(RIPE_TELLER_ID)\n    totalRipe: uint256 = extcall RipeTeller(teller).claimLoot(_user, True)\n    assert totalRipe != 0 # dev: no ripe tokens received\n\n    usdValue: uint256 = staticcall Appraiser(miniAddys.appraiser).getUnderlyingUsdValue(_rewardToken, totalRipe)\n    log RipeClaimRewards(\n        sender = msg.sender,\n        asset = _rewardToken,\n        ripeClaimed = totalRipe,\n        usdValue = usdValue,\n        recipient = _user,\n    )\n    return 0, usdValue\n\n\n# has claimable rewards\n\n\n@view\n@external\ndef hasClaimableRewards(_user: address) -> bool:\n    # TODO: implement\n    return False\n\n\n##################\n# Access Control #\n##################\n\n\n@view\n@internal\ndef _isAllowedToPerformAction(_caller: address) -> bool:\n    # NOTE: important to not trust `_miniAddys` here, that's why getting ledger and vault registry from addys\n    if staticcall VaultRegistry(addys._getVaultRegistryAddr()).isEarnVault(_caller):\n        return True\n    if staticcall Ledger(addys._getLedgerAddr()).isUserWallet(_caller):\n        return True\n    return staticcall Registry(RIPE_REGISTRY).isValidAddr(_caller) # Ripe Endaoment is allowed\n\n\n@view\n@external\ndef getAccessForLego(_user: address, _action: ws.ActionType) -> (address, String[64], uint256):\n    ripeHq: address = RIPE_REGISTRY\n\n    mc: address = staticcall Registry(ripeHq).getAddr(RIPE_MISSION_CONTROL_ID)\n    if staticcall RipeMissionControl(mc).doesUndyLegoHaveAccess(_user, self):\n        return empty(address), empty(String[64]), 0\n\n    else:\n        teller: address = staticcall Registry(ripeHq).getAddr(RIPE_TELLER_ID)\n        return teller, LEGO_ACCESS_ABI, 1\n\n\n#########\n# Other #\n#########\n\n\n@external\ndef mintOrRedeemAsset(\n    _tokenIn: address,\n    _tokenOut: address,\n    _tokenInAmount: uint256,\n    _minAmountOut: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, bool, uint256):\n    return 0, 0, False, 0\n\n\n@external\ndef confirmMintOrRedeemAsset(\n    _tokenIn: address,\n    _tokenOut: address,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef addLiquidity(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _amountA: uint256,\n    _amountB: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _minLpAmount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (address, uint256, uint256, uint256, uint256):\n    return empty(address), 0, 0, 0, 0\n\n\n@external\ndef removeLiquidity(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpToken: address,\n    _lpAmount: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, uint256):\n    return 0, 0, 0, 0\n\n\n@external\ndef addLiquidityConcentrated(\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _tickLower: int24,\n    _tickUpper: int24,\n    _amountA: uint256,\n    _amountB: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, uint256, uint256):\n    return 0, 0, 0, 0, 0\n\n\n@external\ndef removeLiquidityConcentrated(\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _liqToRemove: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, bool, uint256):\n    return 0, 0, 0, False, 0\n",
            "sha256sum": "54462c31816f794c488102c608a4b9c5c5dad71c9611fe388ec2673f84e09fdc"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/legos/RipeLego.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.3+commit.bff19ea2",
        "integrity": "4dbed52ac583d099f2cbefadf66b24e8babfbf0aabefe10e2a6939ad8e573564"
      },
      "args": "00000000000000000000000044cf3c4f000dfd76a35d03298049d37be688d6f90000000000000000000000006162df1b329e157479f8f1407e888260e0ec3d2b000000000000000000000000833589fcd6edb6e08f4c7c32d4f71b54bda02913",
      "file": "contracts/legos/RipeLego.vy"
    },
    "AaveV3": {
      "address": "0x2E5CcDbd412588ceE58516Fa732658CEF7944233",
      "abi": [
        {
          "name": "AaveV3Deposit",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountDeposited",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultTokenAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AaveV3Withdrawal",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultTokenAmountBurned",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LegoPauseModified",
          "inputs": [
            {
              "name": "isPaused",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LegoFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "balance",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "SnapShotPriceConfigSet",
          "inputs": [
            {
              "name": "minSnapshotDelay",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "maxNumSnapshots",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "maxUpsideDeviation",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "staleTime",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetOpportunityAdded",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultAddr",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetOpportunityRemoved",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultAddr",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddys",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "undyToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "hatchery",
                  "type": "address"
                },
                {
                  "name": "lootDistributor",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                },
                {
                  "name": "walletBackpack",
                  "type": "address"
                },
                {
                  "name": "billing",
                  "type": "address"
                },
                {
                  "name": "vaultRegistry",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUndyHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isLegoAsset",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssetOpportunities",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isAssetOpportunity",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getNumLegoAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pause",
          "inputs": [
            {
              "name": "_shouldPause",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFundsMany",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_assets",
              "type": "address[]"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getWeightedPricePerShare",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLatestSnapshot",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_pricePerShare",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "totalSupply",
                  "type": "uint256"
                },
                {
                  "name": "pricePerShare",
                  "type": "uint256"
                },
                {
                  "name": "lastUpdate",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setSnapShotPriceConfig",
          "inputs": [
            {
              "name": "_config",
              "type": "tuple",
              "components": [
                {
                  "name": "minSnapshotDelay",
                  "type": "uint256"
                },
                {
                  "name": "maxNumSnapshots",
                  "type": "uint256"
                },
                {
                  "name": "maxUpsideDeviation",
                  "type": "uint256"
                },
                {
                  "name": "staleTime",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidPriceConfig",
          "inputs": [
            {
              "name": "_config",
              "type": "tuple",
              "components": [
                {
                  "name": "minSnapshotDelay",
                  "type": "uint256"
                },
                {
                  "name": "maxNumSnapshots",
                  "type": "uint256"
                },
                {
                  "name": "maxUpsideDeviation",
                  "type": "uint256"
                },
                {
                  "name": "staleTime",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "vaultToAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "underlyingAsset",
                  "type": "address"
                },
                {
                  "name": "decimals",
                  "type": "uint256"
                },
                {
                  "name": "lastAveragePricePerShare",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assetOpportunities",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAssetOpportunity",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssetOpportunities",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assets",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "snapShotData",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "lastSnapShot",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "totalSupply",
                      "type": "uint256"
                    },
                    {
                      "name": "pricePerShare",
                      "type": "uint256"
                    },
                    {
                      "name": "lastUpdate",
                      "type": "uint256"
                    }
                  ]
                },
                {
                  "name": "nextIndex",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "snapShots",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "totalSupply",
                  "type": "uint256"
                },
                {
                  "name": "pricePerShare",
                  "type": "uint256"
                },
                {
                  "name": "lastUpdate",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "snapShotPriceConfig",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "minSnapshotDelay",
                  "type": "uint256"
                },
                {
                  "name": "maxNumSnapshots",
                  "type": "uint256"
                },
                {
                  "name": "maxUpsideDeviation",
                  "type": "uint256"
                },
                {
                  "name": "staleTime",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isPaused",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasCapability",
          "inputs": [
            {
              "name": "_action",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRegistries",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isYieldLego",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isDexLego",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAsset",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingBalances",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenBalance",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAmount",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAmountSafe",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenBalance",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingData",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingData",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            },
            {
              "name": "_appraiser",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValueOfVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValueOfVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            },
            {
              "name": "_appraiser",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isRebasing",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPricePerShare",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPricePerShare",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_decimals",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getVaultTokenAmount",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_assetAmount",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalAssets",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalBorrows",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAvailLiquidity",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUtilizationRatio",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isEligibleForYieldBonus",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getWithdrawalFees",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canRegisterVaultToken",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "registerVaultTokenLocally",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "underlyingAsset",
                  "type": "address"
                },
                {
                  "name": "decimals",
                  "type": "uint256"
                },
                {
                  "name": "lastAveragePricePerShare",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "deregisterVaultTokenLocally",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositForYield",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositForYield",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawFromYield",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawFromYield",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addPriceSnapshot",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAccessForLego",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_action",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "string"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimIncentives",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_proofs",
              "type": "bytes32[]"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimIncentives",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_proofs",
              "type": "bytes32[]"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasClaimableRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_tokenPath",
              "type": "address[]"
            },
            {
              "name": "_poolPath",
              "type": "address[]"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_tokenPath",
              "type": "address[]"
            },
            {
              "name": "_poolPath",
              "type": "address[]"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_tokenInAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_tokenInAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmMintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmMintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_borrowAsset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_borrowAsset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_paymentAsset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_paymentAsset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "AAVE_V3_POOL",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "AAVE_V3_ADDRESS_PROVIDER",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "RIPE_REGISTRY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_undyHq",
              "type": "address"
            },
            {
              "name": "_aaveV3",
              "type": "address"
            },
            {
              "name": "_addressProvider",
              "type": "address"
            },
            {
              "name": "_ripeRegistry",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "interfaces/WalletStructs.vyi": {
            "content": "# @version 0.4.3\n\nflag ActionType:\n    TRANSFER\n    EARN_DEPOSIT\n    EARN_WITHDRAW\n    EARN_REBALANCE\n    SWAP\n    MINT_REDEEM\n    CONFIRM_MINT_REDEEM\n    ADD_COLLATERAL\n    REMOVE_COLLATERAL\n    BORROW\n    REPAY_DEBT\n    REWARDS\n    ETH_TO_WETH\n    WETH_TO_ETH\n    ADD_LIQ\n    REMOVE_LIQ\n    ADD_LIQ_CONC\n    REMOVE_LIQ_CONC\n    PAY_CHEQUE\n\nstruct WalletAssetData:\n    assetBalance: uint256\n    usdValue: uint256\n    isYieldAsset: bool\n    lastPricePerShare: uint256\n\nstruct ActionData:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    billing: address\n    vaultRegistry: address\n    wallet: address\n    walletConfig: address\n    walletOwner: address\n    inEjectMode: bool\n    isFrozen: bool\n    lastTotalUsdValue: uint256\n    signer: address\n    isManager: bool\n    legoId: uint256\n    legoAddr: address\n    eth: address\n    weth: address\n\nstruct MiniAddys:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    appraiser: address",
            "sha256sum": "466493c129135c95470aaf70eeddc936632f7b0f813396e5a7ddc03bea9da518"
          },
          "interfaces/LegoPartner.vyi": {
            "content": "# @version 0.4.3\n\nfrom interfaces import WalletStructs as ws\n\nMAX_TOKEN_PATH: constant(uint256) = 5\nMAX_RECOVER_ASSETS: constant(uint256) = 20\nMAX_PROOFS: constant(uint256) = 25\n\n@external\ndef addLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _tickLower: int24, _tickUpper: int24, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef addLiquidity(_pool: address, _tokenA: address, _tokenB: address, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _minLpAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (address, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef removeLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _liqToRemove: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef removeLiquidity(_pool: address, _tokenA: address, _tokenB: address, _lpToken: address, _lpAmount: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef mintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _tokenInAmount: uint256, _minAmountOut: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef swapTokens(_amountIn: uint256, _minAmountOut: uint256, _tokenPath: DynArray[address, MAX_TOKEN_PATH], _poolPath: DynArray[address, MAX_TOKEN_PATH - 1], _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256):\n    ...\n\n@external\ndef depositForYield(_asset: address, _amount: uint256, _vaultAddr: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef withdrawFromYield(_vaultToken: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef confirmMintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef borrow(_borrowAsset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef repayDebt(_paymentAsset: address, _paymentAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef claimIncentives(_user: address, _rewardToken: address, _rewardAmount: uint256, _proofs: DynArray[bytes32, MAX_PROOFS], _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef removeCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef addCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@view\n@external\ndef getAccessForLego(_user: address, _action: ws.ActionType) -> (address, String[64], uint256):\n    ...\n\n@view\n@external\ndef hasCapability(_action: ws.ActionType) -> bool:\n    ...\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    ...\n\n@view\n@external\ndef isYieldLego() -> bool:\n    ...\n\n@view\n@external\ndef isDexLego() -> bool:\n    ...\n\n\n# common\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "f2afb7bd72d4301aea77bbe4177b7ae954ba6f6b76af363965993eb92ad0b715"
          },
          "interfaces/LegoStructs.vyi": {
            "content": "# @version 0.4.3\n\nstruct VaultTokenInfo:\n    underlyingAsset: address\n    decimals: uint256\n    lastAveragePricePerShare: uint256\n\nstruct SnapShotPriceConfig:\n    minSnapshotDelay: uint256\n    maxNumSnapshots: uint256\n    maxUpsideDeviation: uint256\n    staleTime: uint256\n\nstruct SingleSnapShot:\n    totalSupply: uint256\n    pricePerShare: uint256\n    lastUpdate: uint256\n\nstruct SnapShotData:\n    lastSnapShot: SingleSnapShot\n    nextIndex: uint256\n",
            "sha256sum": "8ae48be17d812d57fbd671bbf0593e8abf175ad0924e47c5997823cac19ec806"
          },
          "interfaces/YieldLego.vyi": {
            "content": "# @version 0.4.3\n\nfrom interfaces import LegoStructs as ls\n\n\n###################\n# Underlying Data #\n###################\n\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    ...\n\n\n@view\n@external\ndef getUnderlyingBalances(_vaultToken: address, _vaultTokenBalance: uint256) -> (uint256, uint256):\n    ...\n\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    ...\n\n\n@view\n@external\ndef getUnderlyingAmountSafe(_vaultToken: address, _vaultTokenBalance: uint256) -> uint256:\n    ...\n\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> (address, uint256, uint256):\n    ...\n\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> uint256:\n    ...\n\n\n###############\n# Other Utils #\n###############\n\n\n@view\n@external\ndef isRebasing() -> bool:\n    ...\n\n\n@view\n@external\ndef getPricePerShare(_vaultToken: address, _decimals: uint256 = 0) -> uint256:\n    ...\n\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef canRegisterVaultToken(_asset: address, _vaultToken: address) -> bool:\n    ...\n\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef getUtilizationRatio(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef getAvailLiquidity(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef isEligibleForYieldBonus(_asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef getWithdrawalFees(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    ...\n\n\n###################\n# Yield Lego Data #\n###################\n\n\n@view\n@external\ndef isLegoAsset(_asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, 40]:\n    ...\n\n\n@view\n@external\ndef getAssets() -> DynArray[address, 20]:\n    ...\n\n\n@view\n@external\ndef isAssetOpportunity(_asset: address, _vaultAddr: address) -> bool:\n    ...\n\n\n@view\n@external\ndef getNumLegoAssets() -> uint256:\n    ...\n\n\n@view\n@external\ndef assets(_index: uint256) -> address:\n    ...\n\n\n@view\n@external\ndef indexOfAsset(_asset: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef numAssets() -> uint256:\n    ...\n\n\n@view\n@external\ndef assetOpportunities(_asset: address, _index: uint256) -> address:\n    ...\n\n\n@view\n@external\ndef indexOfAssetOpportunity(_asset: address, _vaultAddr: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef numAssetOpportunities(_asset: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef vaultToAsset(_vaultAddr: address) -> ls.VaultTokenInfo:\n    ...\n\n\n# price snapshots\n\n\n@external\ndef addPriceSnapshot(_vaultToken: address) -> bool:\n    ...\n\n\n@view\n@external\ndef snapShotPriceConfig() -> ls.SnapShotPriceConfig:\n    ...\n\n\n@view\n@external\ndef snapShotData(_vaultToken: address) -> ls.SnapShotData:\n    ...\n\n\n@view\n@external\ndef snapShots(_vaultToken: address, _index: uint256) -> ls.SingleSnapShot:\n    ...\n\n\n@view\n@external\ndef getWeightedPricePerShare(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef getLatestSnapshot(_vaultToken: address, _pricePerShare: uint256) -> ls.SingleSnapShot:\n    ...\n\n\n@external\ndef setSnapShotPriceConfig(_config: ls.SnapShotPriceConfig):\n    ...\n",
            "sha256sum": "db91c139f6018f5218b389d08c8703bc16fb994aa948805dbfea27e072f382ec"
          },
          "contracts/modules/Addys.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\ninterface UndyHq:\n    def isValidAddr(_addr: address) -> bool: view\n    def getAddr(_regId: uint256) -> address: view\n    def undyToken() -> address: view\n\ninterface Switchboard:\n    def isSwitchboardAddr(_addr: address) -> bool: view\n\ninterface LegoBook:\n    def isLegoAddr(_addr: address) -> bool: view\n\nstruct Addys:\n    hq: address\n    undyToken: address\n    ledger: address\n    missionControl: address\n    legoBook: address\n    switchboard: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    walletBackpack: address\n    billing: address\n    vaultRegistry: address\n\n# hq\nUNDY_HQ_FOR_ADDYS: immutable(address)\n\n# core addys\nLEDGER_ID: constant(uint256) = 1\nMISSION_CONTROL_ID: constant(uint256) = 2\nLEGO_BOOK_ID: constant(uint256) = 3\nSWITCHBOARD_ID: constant(uint256) = 4\nHATCHERY_ID: constant(uint256) = 5\nLOOT_DISTRIBUTOR_ID: constant(uint256) = 6\nAPPRAISER_ID: constant(uint256) = 7\nWALLET_BACKPACK_ID: constant(uint256) = 8\nBILLING_ID: constant(uint256) = 9\nVAULT_REGISTRY_ID: constant(uint256) = 10\n\n\n@deploy\ndef __init__(_undyHq: address):\n    assert _undyHq != empty(address) # dev: invalid undy hq\n    UNDY_HQ_FOR_ADDYS = _undyHq\n\n\n########\n# Core #\n########\n\n\n@view\n@external\ndef getAddys() -> Addys:\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _getAddys(_addys: Addys = empty(Addys)) -> Addys:\n    if _addys.hq != empty(address):\n        return _addys\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _generateAddys() -> Addys:\n    hq: address = UNDY_HQ_FOR_ADDYS\n    return Addys(\n        hq = hq,\n        undyToken = staticcall UndyHq(hq).undyToken(),\n        ledger = staticcall UndyHq(hq).getAddr(LEDGER_ID),\n        missionControl = staticcall UndyHq(hq).getAddr(MISSION_CONTROL_ID),\n        legoBook = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID),\n        switchboard = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID),\n        hatchery = staticcall UndyHq(hq).getAddr(HATCHERY_ID),\n        lootDistributor = staticcall UndyHq(hq).getAddr(LOOT_DISTRIBUTOR_ID),\n        appraiser = staticcall UndyHq(hq).getAddr(APPRAISER_ID),\n        walletBackpack = staticcall UndyHq(hq).getAddr(WALLET_BACKPACK_ID),\n        billing = staticcall UndyHq(hq).getAddr(BILLING_ID),\n        vaultRegistry = staticcall UndyHq(hq).getAddr(VAULT_REGISTRY_ID),\n    )\n\n\n##########\n# Tokens #\n##########\n\n\n@view\n@internal\ndef _getUndyToken() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).undyToken()\n\n\n###########\n# Helpers #\n###########\n\n\n# undy hq\n\n\n@view\n@external\ndef getUndyHq() -> address:\n    return self._getUndyHq()\n\n\n@view\n@internal\ndef _getUndyHq() -> address:\n    return UNDY_HQ_FOR_ADDYS\n\n\n# utils\n\n\n@view\n@internal\ndef _isValidUndyAddr(_addr: address, _hq: address = empty(address)) -> bool:\n    hq: address = _hq\n    if _hq == empty(address):\n        hq = UNDY_HQ_FOR_ADDYS\n    \n    # core departments\n    if staticcall UndyHq(hq).isValidAddr(_addr):\n        return True\n\n    # lego book\n    legoBook: address = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID)\n    if legoBook != empty(address) and staticcall LegoBook(legoBook).isLegoAddr(_addr):\n        return True\n\n    # switchboard config\n    switchboard: address = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID)\n    if switchboard != empty(address) and staticcall Switchboard(switchboard).isSwitchboardAddr(_addr):\n        return True\n\n    return False\n\n\n@view\n@internal\ndef _isSwitchboardAddr(_addr: address) -> bool:\n    switchboard: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n    if switchboard == empty(address):\n        return False\n    return staticcall Switchboard(switchboard).isSwitchboardAddr(_addr)\n\n\n@view\n@internal\ndef _isLegoBookAddr(_addr: address) -> bool:\n    legoBook: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n    if legoBook == empty(address):\n        return False\n    return staticcall LegoBook(legoBook).isLegoAddr(_addr)\n\n\n###############\n# Departments #\n###############\n\n\n# ledger\n\n\n@view\n@internal\ndef _getLedgerId() -> uint256:\n    return LEDGER_ID\n\n\n@view\n@internal\ndef _getLedgerAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEDGER_ID)\n\n\n# mission control\n\n\n@view\n@internal\ndef _getMissionControlId() -> uint256:\n    return MISSION_CONTROL_ID\n\n\n@view\n@internal\ndef _getMissionControlAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(MISSION_CONTROL_ID)\n\n\n# lego book\n\n\n@view\n@internal\ndef _getLegoBookId() -> uint256:\n    return LEGO_BOOK_ID\n\n\n@view\n@internal\ndef _getLegoBookAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n\n\n# switchboard\n\n\n@view\n@internal\ndef _getSwitchboardId() -> uint256:\n    return SWITCHBOARD_ID\n\n\n@view\n@internal\ndef _getSwitchboardAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n\n\n# hatchery\n\n\n@view\n@internal\ndef _getHatcheryId() -> uint256:\n    return HATCHERY_ID\n\n\n@view\n@internal\ndef _getHatcheryAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(HATCHERY_ID)\n\n\n# loot distributor\n\n\n@view\n@internal\ndef _getLootDistributorId() -> uint256:\n    return LOOT_DISTRIBUTOR_ID\n\n\n@view\n@internal\ndef _getLootDistributorAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LOOT_DISTRIBUTOR_ID)\n\n\n# appraiser\n\n\n@view\n@internal\ndef _getAppraiserId() -> uint256:\n    return APPRAISER_ID\n\n\n@view\n@internal\ndef _getAppraiserAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(APPRAISER_ID)\n\n\n# wallet backpack\n\n\n@view\n@internal\ndef _getWalletBackpackId() -> uint256:\n    return WALLET_BACKPACK_ID\n\n\n@view\n@internal\ndef _getWalletBackpackAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(WALLET_BACKPACK_ID)\n\n\n# billing\n\n\n@view\n@internal\ndef _getBillingId() -> uint256:\n    return BILLING_ID\n\n\n@view\n@internal\ndef _getBillingAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(BILLING_ID)\n\n\n# vault registry\n\n\n@view\n@internal\ndef _getVaultRegistryId() -> uint256:\n    return VAULT_REGISTRY_ID\n\n\n@view\n@internal\ndef _getVaultRegistryAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(VAULT_REGISTRY_ID)",
            "sha256sum": "4df6b72db9bb417d1af81660175be1450cfb7b3575f3d17a5b8a130bff87b781"
          },
          "contracts/modules/YieldLegoData.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nuses: addys\n\nimport contracts.modules.Addys as addys\n\nfrom interfaces import WalletStructs as ws\nfrom interfaces import LegoStructs as ls\nfrom ethereum.ercs import IERC20\nfrom ethereum.ercs import IERC20Detailed\n\nevent AssetOpportunityAdded:\n    asset: indexed(address)\n    vaultAddr: indexed(address)\n\nevent AssetOpportunityRemoved:\n    asset: indexed(address)\n    vaultAddr: indexed(address)\n\nevent LegoPauseModified:\n    isPaused: bool\n\nevent LegoFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    balance: uint256\n\nevent PricePerShareSnapShotAdded:\n    vaultToken: indexed(address)\n    totalSupply: uint256\n    pricePerShare: uint256\n    lastAveragePricePerShare: uint256\n\nevent SnapShotPriceConfigSet:\n    minSnapshotDelay: uint256\n    maxNumSnapshots: uint256\n    maxUpsideDeviation: uint256\n    staleTime: uint256\n\n# core\nvaultToAsset: public(HashMap[address, ls.VaultTokenInfo]) # vault addr -> data\n\n# asset opportunities\nassetOpportunities: public(HashMap[address, HashMap[uint256, address]]) # asset -> index -> vault addr\nindexOfAssetOpportunity: public(HashMap[address, HashMap[address, uint256]]) # asset -> vault addr -> index\nnumAssetOpportunities: public(HashMap[address, uint256]) # asset -> number of opportunities\n\n# lego assets (iterable)\nassets: public(HashMap[uint256, address]) # index -> asset\nindexOfAsset: public(HashMap[address, uint256]) # asset -> index\nnumAssets: public(uint256) # num assets\n\n# price snapshots\nsnapShotData: public(HashMap[address, ls.SnapShotData]) # vault token -> data\nsnapShots: public(HashMap[address, HashMap[uint256, ls.SingleSnapShot]]) # vault token -> index -> snapshot\nsnapShotPriceConfig: public(ls.SnapShotPriceConfig) # config\n\nisPaused: public(bool)\n\nMAX_VAULTS: constant(uint256) = 40\nMAX_ASSETS: constant(uint256) = 20\nMAX_RECOVER_ASSETS: constant(uint256) = 20\nONE_DAY_SECONDS: constant(uint256) = 60 * 60 * 24\nONE_WEEK_SECONDS: constant(uint256) = ONE_DAY_SECONDS * 7\nHUNDRED_PERCENT: constant(uint256) = 100_00\n\n\n@deploy\ndef __init__(_shouldPause: bool):\n    self.isPaused = _shouldPause\n    self.numAssets = 1 # not using 0 index\n\n    # default snapshot price config\n    self.snapShotPriceConfig = ls.SnapShotPriceConfig(\n        minSnapshotDelay = 60 * 10, # 10 minutes\n        maxNumSnapshots = 20,\n        maxUpsideDeviation = 10_00, # 10%\n        staleTime = ONE_DAY_SECONDS, # 1 day\n    )\n\n\n#########\n# Views #\n#########\n\n\n# is lego asset\n\n\n@view\n@external\ndef isLegoAsset(_asset: address) -> bool:\n    return self._isLegoAsset(_asset)\n\n\n@view\n@internal\ndef _isLegoAsset(_asset: address) -> bool:\n    return self.indexOfAsset[_asset] != 0\n\n\n# vault opportunities\n\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, MAX_VAULTS]:\n    numOpportunities: uint256 = self.numAssetOpportunities[_asset]\n    if numOpportunities == 0:\n        return []\n    opportunities: DynArray[address, MAX_VAULTS] = []\n    for i: uint256 in range(1, numOpportunities, bound=MAX_VAULTS):\n        opportunities.append(self.assetOpportunities[_asset][i])\n    return opportunities\n\n\n# all assets registered\n\n\n@view\n@external\ndef getAssets() -> DynArray[address, MAX_ASSETS]:\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return []\n    assets: DynArray[address, MAX_ASSETS] = []\n    for i: uint256 in range(1, numAssets, bound=MAX_ASSETS):\n        assets.append(self.assets[i])\n    return assets\n\n\n################\n# Registration #\n################\n\n\n@view\n@external\ndef isAssetOpportunity(_asset: address, _vaultAddr: address) -> bool:\n    return self._isAssetOpportunity(_asset, _vaultAddr)\n\n\n@view\n@internal\ndef _isAssetOpportunity(_asset: address, _vaultAddr: address) -> bool:\n    return self.indexOfAssetOpportunity[_asset][_vaultAddr] != 0\n\n\n# add asset opportunity\n\n\n@internal\ndef _addAssetOpportunity(_asset: address, _vaultAddr: address) -> ls.VaultTokenInfo:\n    if self.indexOfAssetOpportunity[_asset][_vaultAddr] != 0:\n        return self.vaultToAsset[_vaultAddr]\n\n    if empty(address) in [_asset, _vaultAddr]:\n        return empty(ls.VaultTokenInfo)\n\n    # add asset opportunity\n    aid: uint256 = self.numAssetOpportunities[_asset]\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.assetOpportunities[_asset][aid] = _vaultAddr\n    self.indexOfAssetOpportunity[_asset][_vaultAddr] = aid\n    self.numAssetOpportunities[_asset] = aid + 1\n\n    # add mapping\n    vaultInfo: ls.VaultTokenInfo = ls.VaultTokenInfo(\n        underlyingAsset = _asset,\n        decimals = convert(staticcall IERC20Detailed(_vaultAddr).decimals(), uint256),\n        lastAveragePricePerShare = 0,\n    )\n    self.vaultToAsset[_vaultAddr] = vaultInfo\n\n    # add asset\n    self._addAsset(_asset)\n\n    log AssetOpportunityAdded(asset=_asset, vaultAddr=_vaultAddr)\n    return vaultInfo\n\n\n# remove asset opportunity\n\n\n@internal\ndef _removeAssetOpportunity(_asset: address, _vaultAddr: address):\n    numOpportunities: uint256 = self.numAssetOpportunities[_asset]\n    if numOpportunities == 0:\n        return\n\n    targetIndex: uint256 = self.indexOfAssetOpportunity[_asset][_vaultAddr]\n    if targetIndex == 0:\n        return\n\n    # update data\n    lastIndex: uint256 = numOpportunities - 1\n    self.numAssetOpportunities[_asset] = lastIndex\n    self.indexOfAssetOpportunity[_asset][_vaultAddr] = 0\n\n    self.vaultToAsset[_vaultAddr] = empty(ls.VaultTokenInfo)\n\n    # clear all snapshot data for the vault token to prevent contamination on re-add\n    self.snapShotData[_vaultAddr] = empty(ls.SnapShotData)\n\n    # clear all historical snapshots\n    config: ls.SnapShotPriceConfig = self.snapShotPriceConfig\n    for i: uint256 in range(config.maxNumSnapshots, bound=max_value(uint256)):\n        if i >= config.maxNumSnapshots:\n            break\n        self.snapShots[_vaultAddr][i] = empty(ls.SingleSnapShot)\n\n    # shift to replace the removed one\n    if targetIndex != lastIndex:\n        lastVaultAddr: address = self.assetOpportunities[_asset][lastIndex]\n        self.assetOpportunities[_asset][targetIndex] = lastVaultAddr\n        self.indexOfAssetOpportunity[_asset][lastVaultAddr] = targetIndex\n\n    # remove asset\n    if lastIndex <= 1:\n        self._removeAsset(_asset)\n\n    log AssetOpportunityRemoved(asset=_asset, vaultAddr=_vaultAddr)\n\n\n# add asset\n\n\n@internal\ndef _addAsset(_asset: address):\n    if self.indexOfAsset[_asset] != 0:\n        return\n\n    aid: uint256 = self.numAssets\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.assets[aid] = _asset\n    self.indexOfAsset[_asset] = aid\n    self.numAssets = aid + 1\n\n\n# remove asset\n\n\n@internal\ndef _removeAsset(_asset: address):\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return\n\n    targetIndex: uint256 = self.indexOfAsset[_asset]\n    if targetIndex == 0:\n        return\n\n    # update data\n    lastIndex: uint256 = numAssets - 1\n    self.numAssets = lastIndex\n    self.indexOfAsset[_asset] = 0\n\n    # shift to replace the removed one\n    if targetIndex != lastIndex:\n        lastAsset: address = self.assets[lastIndex]\n        self.assets[targetIndex] = lastAsset\n        self.indexOfAsset[lastAsset] = targetIndex\n\n\n# num lego assets (true number, use `numAssets` for iteration)\n\n\n@view\n@external\ndef getNumLegoAssets() -> uint256:\n    return self._getNumLegoAssets()\n\n\n@view\n@internal\ndef _getNumLegoAssets() -> uint256:\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return 0\n    return numAssets - 1\n\n\n###########\n# General #\n###########\n\n\n# fill mini addys\n\n\n@view\n@internal\ndef _getMiniAddys(_miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> ws.MiniAddys:\n    if _miniAddys.ledger != empty(address):\n        return _miniAddys\n    return ws.MiniAddys(\n        ledger = addys._getLedgerAddr(),\n        missionControl = addys._getMissionControlAddr(),\n        legoBook = addys._getLegoBookAddr(),\n        appraiser = addys._getAppraiserAddr(),\n    )\n\n\n# activate\n\n\n@external\ndef pause(_shouldPause: bool):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert _shouldPause != self.isPaused # dev: no change\n    self.isPaused = _shouldPause\n    log LegoPauseModified(isPaused=_shouldPause)\n\n\n# recover funds\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    self._recoverFunds(_recipient, _asset)\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, MAX_RECOVER_ASSETS]):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    for a: address in _assets:\n        self._recoverFunds(_recipient, a)\n\n\n@internal\ndef _recoverFunds(_recipient: address, _asset: address):\n    assert empty(address) not in [_recipient, _asset] # dev: invalid recipient or asset\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    assert balance != 0 # dev: nothing to recover\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log LegoFundsRecovered(asset=_asset, recipient=_recipient, balance=balance)\n\n\n###################\n# Price Snapshots #\n###################\n\n\n# add price snapshot\n\n\n@internal\ndef _addPriceSnapshot(_vaultToken: address, _pricePerShare: uint256, _vaultTokenDecimals: uint256) -> bool:\n    config: ls.SnapShotPriceConfig = self.snapShotPriceConfig\n    if config.maxNumSnapshots == 0:\n        return False\n\n    data: ls.SnapShotData = self.snapShotData[_vaultToken]\n\n    # already have snapshot for this time\n    if data.lastSnapShot.lastUpdate == block.timestamp:\n        return False\n\n    # check if snapshot is too recent\n    if data.lastSnapShot.lastUpdate + config.minSnapshotDelay > block.timestamp:\n        return False\n\n    # create and store new snapshot\n    newSnapshot: ls.SingleSnapShot = self._getLatestSnapshot(_vaultToken, _pricePerShare, _vaultTokenDecimals, data.lastSnapShot, config)\n    data.lastSnapShot = newSnapshot\n    self.snapShots[_vaultToken][data.nextIndex] = newSnapshot\n\n    # update index\n    data.nextIndex += 1\n    if data.nextIndex >= config.maxNumSnapshots:\n        data.nextIndex = 0\n\n    # save snap shot data\n    self.snapShotData[_vaultToken] = data\n\n    # update cached weighted average price per share\n    lastAveragePricePerShare: uint256 = self._getWeightedPricePerShare(_vaultToken, _pricePerShare)\n    self.vaultToAsset[_vaultToken].lastAveragePricePerShare = lastAveragePricePerShare\n\n    log PricePerShareSnapShotAdded(\n        vaultToken = _vaultToken,\n        totalSupply = newSnapshot.totalSupply,\n        pricePerShare = newSnapshot.pricePerShare,\n        lastAveragePricePerShare = lastAveragePricePerShare,\n    )\n    return True\n\n\n# weighted price per share\n\n\n@view\n@external\ndef getWeightedPricePerShare(_vaultToken: address) -> uint256:\n    data: ls.SnapShotData = self.snapShotData[_vaultToken]\n    return self._getWeightedPricePerShare(_vaultToken, data.lastSnapShot.pricePerShare)\n\n\n@view\n@internal\ndef _getWeightedPricePerShare(_vaultToken: address, _lastPricePerShare: uint256) -> uint256:\n    config: ls.SnapShotPriceConfig = self.snapShotPriceConfig\n    if config.maxNumSnapshots == 0:\n        return 0\n\n    # calculate weighted average price using all valid snapshots\n    numerator: uint256 = 0\n    denominator: uint256 = 0\n    for i: uint256 in range(config.maxNumSnapshots, bound=max_value(uint256)):\n\n        snapShot: ls.SingleSnapShot = self.snapShots[_vaultToken][i]\n        if snapShot.pricePerShare == 0 or snapShot.totalSupply == 0 or snapShot.lastUpdate == 0:\n            continue\n\n        # too stale, skip\n        if config.staleTime != 0 and block.timestamp > snapShot.lastUpdate + config.staleTime:\n            continue\n\n        numerator += (snapShot.totalSupply * snapShot.pricePerShare)\n        denominator += snapShot.totalSupply\n\n    # weighted price per share\n    weightedPricePerShare: uint256 = 0\n    if numerator != 0:\n        weightedPricePerShare = numerator // denominator\n    else:\n        weightedPricePerShare = _lastPricePerShare\n\n    return weightedPricePerShare\n\n\n# latest snapshot\n\n\n@view\n@external\ndef getLatestSnapshot(_vaultToken: address, _pricePerShare: uint256) -> ls.SingleSnapShot:\n    data: ls.SnapShotData = self.snapShotData[_vaultToken]\n    config: ls.SnapShotPriceConfig = self.snapShotPriceConfig\n    vaultTokenDecimals: uint256 = self.vaultToAsset[_vaultToken].decimals\n    return self._getLatestSnapshot(_vaultToken, _pricePerShare, vaultTokenDecimals, data.lastSnapShot, config)\n\n\n@view\n@internal\ndef _getLatestSnapshot(\n    _vaultToken: address,\n    _pricePerShare: uint256,\n    _vaultTokenDecimals: uint256,\n    _lastSnapShot: ls.SingleSnapShot,\n    _config: ls.SnapShotPriceConfig,\n) -> ls.SingleSnapShot:\n\n    # total supply (adjusted)\n    totalSupply: uint256 = staticcall IERC20(_vaultToken).totalSupply() // (10 ** _vaultTokenDecimals)\n    if totalSupply == 0:\n        totalSupply = 1\n\n    # throttle upside (extra safety check)\n    pricePerShare: uint256 = self._throttleUpside(_pricePerShare, _lastSnapShot.pricePerShare, _config.maxUpsideDeviation)\n\n    return ls.SingleSnapShot(\n        totalSupply = totalSupply,\n        pricePerShare = pricePerShare,\n        lastUpdate = block.timestamp,\n    )\n\n\n@view\n@internal\ndef _throttleUpside(_newValue: uint256, _prevValue: uint256, _maxUpside: uint256) -> uint256:\n    if _maxUpside == 0 or _prevValue == 0 or _newValue == 0:\n        return _newValue\n    maxPricePerShare: uint256 = _prevValue + (_prevValue * _maxUpside // HUNDRED_PERCENT)\n    return min(_newValue, maxPricePerShare)\n\n\n# snapshot price config\n\n\n@external\ndef setSnapShotPriceConfig(_config: ls.SnapShotPriceConfig):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert self._isValidPriceConfig(_config) # dev: invalid config\n    self.snapShotPriceConfig = _config\n    log SnapShotPriceConfigSet(\n        minSnapshotDelay=_config.minSnapshotDelay,\n        maxNumSnapshots=_config.maxNumSnapshots,\n        maxUpsideDeviation=_config.maxUpsideDeviation,\n        staleTime=_config.staleTime\n    )\n\n\n@view\n@external\ndef isValidPriceConfig(_config: ls.SnapShotPriceConfig) -> bool:\n    return self._isValidPriceConfig(_config)\n\n\n@view\n@internal\ndef _isValidPriceConfig(_config: ls.SnapShotPriceConfig) -> bool:\n    if _config.minSnapshotDelay > ONE_WEEK_SECONDS:\n        return False\n    if _config.maxNumSnapshots == 0 or _config.maxNumSnapshots > 25:\n        return False\n    if _config.maxUpsideDeviation > HUNDRED_PERCENT:\n        return False\n    return _config.staleTime < ONE_WEEK_SECONDS",
            "sha256sum": "50440c96dc8a7af22e7ad927bb6d3e308f137d5d3632e633e084b05510c94c28"
          },
          "contracts/legos/yield/AaveV3.vy": {
            "content": "#     __   __ ___ _______ ___     ______       ___     _______ _______ _______ \n#    |  | |  |   |       |   |   |      |     |   |   |       |       |       |\n#    |  |_|  |   |    ___|   |   |  _    |    |   |   |    ___|    ___|   _   |\n#    |       |   |   |___|   |   | | |   |    |   |   |   |___|   | __|  | |  |\n#    |_     _|   |    ___|   |___| |_|   |    |   |___|    ___|   ||  |  |_|  |\n#      |   | |   |   |___|       |       |    |       |   |___|   |_| |       |\n#      |___| |___|_______|_______|______|     |_______|_______|_______|_______|\n#                                                                       \n#     \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n#     \u2551  ** Aave V3 Lego **                    \u2551\n#     \u2551  Integration with Aave Protocol (v3)   \u2551\n#     \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n#\n#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nimplements: Lego\nimplements: YieldLego\n\nexports: addys.__interface__\nexports: yld.__interface__\n\ninitializes: addys\ninitializes: yld[addys := addys]\n\nfrom interfaces import LegoPartner as Lego\nfrom interfaces import YieldLego as YieldLego\nfrom interfaces import WalletStructs as ws\nfrom interfaces import LegoStructs as ls\n\nimport contracts.modules.Addys as addys\nimport contracts.modules.YieldLegoData as yld\n\nfrom ethereum.ercs import IERC20\nfrom ethereum.ercs import IERC20Detailed\n\ninterface Ledger:\n    def setVaultToken(_vaultToken: address, _legoId: uint256, _underlyingAsset: address, _decimals: uint256, _isRebasing: bool): nonpayable\n    def isRegisteredVaultToken(_vaultToken: address) -> bool: view\n    def isUserWallet(_user: address) -> bool: view\n\ninterface AaveV3Pool:\n    def supply(_asset: address, _amount: uint256, _onBehalfOf: address, _referralCode: uint16): nonpayable\n    def withdraw(_asset: address, _amount: uint256, _to: address): nonpayable\n\ninterface AaveProtocolDataProvider:\n    def getReserveTokensAddresses(_asset: address) -> (address, address, address): view\n    def getTotalDebt(_asset: address) -> uint256: view\n\ninterface Registry:\n    def getRegId(_addr: address) -> uint256: view\n    def isValidAddr(_addr: address) -> bool: view\n\ninterface AToken:\n    def UNDERLYING_ASSET_ADDRESS() -> address: view\n    def totalSupply() -> uint256: view\n\ninterface Appraiser:\n    def getUnderlyingUsdValue(_asset: address, _amount: uint256) -> uint256: view\n\ninterface VaultRegistry:\n    def isEarnVault(_vaultAddr: address) -> bool: view\n\ninterface AaveV3AddressProvider:\n    def getPoolDataProvider() -> address: view\n\nevent AaveV3Deposit:\n    sender: indexed(address)\n    asset: indexed(address)\n    vaultToken: indexed(address)\n    assetAmountDeposited: uint256\n    usdValue: uint256\n    vaultTokenAmountReceived: uint256\n    recipient: address\n\nevent AaveV3Withdrawal:\n    sender: indexed(address)\n    asset: indexed(address)\n    vaultToken: indexed(address)\n    assetAmountReceived: uint256\n    usdValue: uint256\n    vaultTokenAmountBurned: uint256\n    recipient: address\n\n# aave v3\nAAVE_V3_POOL: public(immutable(address))\nAAVE_V3_ADDRESS_PROVIDER: public(immutable(address))\nRIPE_REGISTRY: public(immutable(address))\n\nMAX_TOKEN_PATH: constant(uint256) = 5\nMAX_PROOFS: constant(uint256) = 25\nHUNDRED_PERCENT: constant(uint256) = 100_00\n\n\n@deploy\ndef __init__(\n    _undyHq: address,\n    _aaveV3: address,\n    _addressProvider: address,\n    _ripeRegistry: address,\n):\n    addys.__init__(_undyHq)\n    yld.__init__(False)\n\n    assert empty(address) not in [_aaveV3, _addressProvider, _ripeRegistry] # dev: invalid addrs\n    AAVE_V3_POOL = _aaveV3\n    AAVE_V3_ADDRESS_PROVIDER = _addressProvider\n    RIPE_REGISTRY = _ripeRegistry\n\n\n@view\n@external\ndef hasCapability(_action: ws.ActionType) -> bool:\n    return _action in (\n        ws.ActionType.EARN_DEPOSIT | \n        ws.ActionType.EARN_WITHDRAW\n    )\n\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    return [AAVE_V3_POOL, AAVE_V3_ADDRESS_PROVIDER]\n\n\n@view\n@external\ndef isYieldLego() -> bool:\n    return True\n\n\n@view\n@external\ndef isDexLego() -> bool:\n    return False\n\n\n# helper\n\n\n@view\n@internal\ndef _getPoolDataProvider() -> address:\n    return staticcall AaveV3AddressProvider(AAVE_V3_ADDRESS_PROVIDER).getPoolDataProvider()\n\n\n###################\n# Underlying Data #\n###################\n\n\n# underlying asset\n\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    return self._getUnderlyingAsset(_vaultToken)\n\n\n@view\n@internal\ndef _getUnderlyingAsset(_vaultToken: address) -> address:\n    asset: address = yld.vaultToAsset[_vaultToken].underlyingAsset\n    if asset != empty(address):\n        return asset\n    return staticcall AToken(_vaultToken).UNDERLYING_ASSET_ADDRESS()\n\n\n# underlying balances (both true and safe)\n\n\n@view\n@external\ndef getUnderlyingBalances(_vaultToken: address, _vaultTokenBalance: uint256) -> (uint256, uint256):\n    return _vaultTokenBalance, _vaultTokenBalance\n\n\n# underlying amount (true)\n\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    return self._getUnderlyingAmount(_vaultToken, _vaultTokenAmount)\n\n\n@view\n@internal\ndef _getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    # treated as 1:1\n    return _vaultTokenAmount\n\n\n# underlying amount (safe)\n\n\n@view\n@external\ndef getUnderlyingAmountSafe(_vaultToken: address, _vaultTokenBalance: uint256) -> uint256:\n    # treated as 1:1\n    return _vaultTokenBalance\n\n\n# underlying data (combined)\n\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> (address, uint256, uint256):\n    return self._getUnderlyingData(_vaultToken, _vaultTokenAmount, _appraiser)\n\n\n@view\n@internal\ndef _getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address) -> (address, uint256, uint256):\n    asset: address = self._getUnderlyingAsset(_vaultToken)\n    if asset == empty(address):\n        return empty(address), 0, 0 # invalid vault token\n    underlyingAmount: uint256 = self._getUnderlyingAmount(_vaultToken, _vaultTokenAmount)\n    usdValue: uint256 = self._getUsdValue(asset, underlyingAmount, _appraiser)\n    return asset, underlyingAmount, usdValue\n\n\n# usd value\n\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> uint256:\n    return self._getUsdValueOfVaultToken(_vaultToken, _vaultTokenAmount, _appraiser)\n\n\n@view\n@internal\ndef _getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address) -> uint256:\n    return self._getUnderlyingData(_vaultToken, _vaultTokenAmount, _appraiser)[2]\n\n\n@view\n@internal\ndef _getUsdValue(_asset: address, _amount: uint256, _appraiser: address) -> uint256:\n    appraiser: address = _appraiser\n    if _appraiser == empty(address):\n        appraiser = addys._getAppraiserAddr()\n    return staticcall Appraiser(appraiser).getUnderlyingUsdValue(_asset, _amount)\n\n\n###############\n# Other Utils #\n###############\n\n\n# basics\n\n\n@view\n@external\ndef isRebasing() -> bool:\n    return self._isRebasing()\n\n\n@view\n@internal\ndef _isRebasing() -> bool:\n    return True\n\n\n# price per share\n\n\n@view\n@external\ndef getPricePerShare(_vaultToken: address, _decimals: uint256 = 0) -> uint256:\n    decimals: uint256 = _decimals\n    if decimals == 0:\n        decimals = yld.vaultToAsset[_vaultToken].decimals\n    if decimals == 0:\n        decimals = convert(staticcall IERC20Detailed(_vaultToken).decimals(), uint256)\n    return self._getPricePerShare(_vaultToken, decimals)\n\n\n@view\n@internal\ndef _getPricePerShare(_vaultToken: address, _decimals: uint256) -> uint256:\n    return 10 ** _decimals # treated as 1:1\n\n\n# vault token amount\n\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    return _assetAmount # treated as 1:1\n\n\n# total assets\n\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    return self._totalAssets(_vaultToken)\n\n\n@view\n@internal\ndef _totalAssets(_vaultToken: address) -> uint256:\n    return staticcall AToken(_vaultToken).totalSupply()\n\n\n# total borrows\n\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    asset: address = self._getUnderlyingAsset(_vaultToken)\n    if asset == empty(address):\n        return 0 # not registered\n    return self._totalBorrows(asset)\n\n\n@view\n@internal\ndef _totalBorrows(_asset: address) -> uint256:\n    return staticcall AaveProtocolDataProvider(self._getPoolDataProvider()).getTotalDebt(_asset)\n\n\n# avail liquidity\n\n\n@view\n@external\ndef getAvailLiquidity(_vaultToken: address) -> uint256:\n    asset: address = self._getUnderlyingAsset(_vaultToken)\n    if asset == empty(address):\n        return 0\n    totalAssets: uint256 = self._totalAssets(_vaultToken)\n    totalBorrows: uint256 = self._totalBorrows(asset)\n    if totalAssets <= totalBorrows:\n        return 0\n    return totalAssets - totalBorrows\n\n\n# utilization\n\n\n@view\n@external\ndef getUtilizationRatio(_vaultToken: address) -> uint256:\n    asset: address = self._getUnderlyingAsset(_vaultToken)\n    if asset == empty(address):\n        return 0\n    totalAssets: uint256 = self._totalAssets(_vaultToken)\n    if totalAssets == 0:\n        return 0\n    totalBorrows: uint256 = self._totalBorrows(asset)\n    return totalBorrows * HUNDRED_PERCENT // totalAssets\n\n\n# extras\n\n\n@view\n@external\ndef isEligibleForYieldBonus(_asset: address) -> bool:\n    return False\n\n\n@view\n@external\ndef getWithdrawalFees(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    return 0\n\n\n################\n# Registration #\n################\n\n\n# can vault be registered\n\n\n@view\n@external\ndef canRegisterVaultToken(_asset: address, _vaultToken: address) -> bool:\n    return self._canRegisterVaultToken(_asset, _vaultToken)\n\n\n@view\n@internal\ndef _canRegisterVaultToken(_asset: address, _vaultToken: address) -> bool:\n    if empty(address) in [_asset, _vaultToken]:\n        return False\n    if staticcall AToken(_vaultToken).UNDERLYING_ASSET_ADDRESS() != _asset:\n        return False\n    vaultToken: address = (staticcall AaveProtocolDataProvider(self._getPoolDataProvider()).getReserveTokensAddresses(_asset))[0]\n    return vaultToken == _vaultToken\n\n\n# register vault token locally\n\n\n@external\ndef registerVaultTokenLocally(_asset: address, _vaultAddr: address) -> ls.VaultTokenInfo:\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert self._canRegisterVaultToken(_asset, _vaultAddr) # dev: cannot register vault token\n    assert not yld._isAssetOpportunity(_asset, _vaultAddr) # dev: already registered\n    vaultInfo: ls.VaultTokenInfo = self._registerVaultTokenLocally(_asset, _vaultAddr)\n    self._registerVaultTokenGlobally(_asset, _vaultAddr, vaultInfo.decimals, addys._getLedgerAddr(), addys._getLegoBookAddr())\n    return vaultInfo\n\n\n@internal\ndef _registerVaultTokenLocally(_asset: address, _vaultAddr: address) -> ls.VaultTokenInfo:\n    assert extcall IERC20(_asset).approve(AAVE_V3_POOL, max_value(uint256), default_return_value=True) # dev: max approval failed\n    vaultInfo: ls.VaultTokenInfo = yld._addAssetOpportunity(_asset, _vaultAddr)\n    assert vaultInfo.decimals != 0 # dev: invalid vault token\n    return vaultInfo\n\n\n# remove vault token locally\n\n\n@external\ndef deregisterVaultTokenLocally(_asset: address, _vaultAddr: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert yld._isAssetOpportunity(_asset, _vaultAddr) # dev: already registered\n    self._deregisterVaultTokenLocally(_asset, _vaultAddr)\n\n\n@internal\ndef _deregisterVaultTokenLocally(_asset: address, _vaultAddr: address):\n    assert extcall IERC20(_asset).approve(AAVE_V3_POOL, 0, default_return_value=True) # dev: max approval failed\n    yld._removeAssetOpportunity(_asset, _vaultAddr)\n\n\n# ledger registration\n\n\n@internal\ndef _registerVaultTokenGlobally(_underlyingAsset: address, _vaultToken: address, _decimals: uint256, _ledger: address, _legoBook: address):\n    if not staticcall Ledger(_ledger).isRegisteredVaultToken(_vaultToken):\n        legoId: uint256 = staticcall Registry(_legoBook).getRegId(self)\n        extcall Ledger(_ledger).setVaultToken(_vaultToken, legoId, _underlyingAsset, _decimals, self._isRebasing())\n\n\n#################\n# Yield Actions #\n#################\n\n\n# access control\n\n\n@view\n@internal\ndef _isAllowedToPerformAction(_caller: address) -> bool:\n    # NOTE: important to not trust `_miniAddys` here, that's why getting ledger and vault registry from addys\n    if staticcall VaultRegistry(addys._getVaultRegistryAddr()).isEarnVault(_caller):\n        return True\n    if staticcall Ledger(addys._getLedgerAddr()).isUserWallet(_caller):\n        return True\n    return staticcall Registry(RIPE_REGISTRY).isValidAddr(_caller) # Ripe Endaoment is allowed\n\n\n# deposit\n\n\n@external\ndef depositForYield(\n    _asset: address,\n    _amount: uint256,\n    _vaultAddr: address,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, address, uint256, uint256):\n    assert self._isAllowedToPerformAction(msg.sender) # dev: no perms\n    assert not yld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = yld._getMiniAddys(_miniAddys)\n    vaultInfo: ls.VaultTokenInfo = self._getVaultInfoOnDeposit(_asset, _vaultAddr, miniAddys.ledger, miniAddys.legoBook)\n\n    # pre balances\n    preRecipientVaultBalance: uint256 = staticcall IERC20(_vaultAddr).balanceOf(_recipient)\n    preLegoBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n\n    # transfer deposit asset to this contract\n    depositAmount: uint256 = min(_amount, staticcall IERC20(_asset).balanceOf(msg.sender))\n    assert depositAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_asset).transferFrom(msg.sender, self, depositAmount, default_return_value=True) # dev: transfer failed\n\n    # deposit assets into lego partner\n    extcall AaveV3Pool(AAVE_V3_POOL).supply(_asset, depositAmount, _recipient, 0)\n\n    # validate vault token transfer\n    vaultTokenAmountReceived: uint256 = staticcall IERC20(_vaultAddr).balanceOf(_recipient) - preRecipientVaultBalance\n    assert vaultTokenAmountReceived != 0 # dev: no vault tokens received\n\n    # refund if full deposit didn't get through\n    currentLegoBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    refundAssetAmount: uint256 = 0\n    if currentLegoBalance > preLegoBalance:\n        refundAssetAmount = currentLegoBalance - preLegoBalance\n        assert extcall IERC20(_asset).transfer(msg.sender, refundAssetAmount, default_return_value=True) # dev: transfer failed\n        depositAmount -= refundAssetAmount\n\n    usdValue: uint256 = staticcall Appraiser(miniAddys.appraiser).getUnderlyingUsdValue(_asset, depositAmount)\n    log AaveV3Deposit(\n        sender = msg.sender,\n        asset = _asset,\n        vaultToken = _vaultAddr,\n        assetAmountDeposited = depositAmount,\n        usdValue = usdValue,\n        vaultTokenAmountReceived = vaultTokenAmountReceived,\n        recipient = _recipient,\n    )\n    return depositAmount, _vaultAddr, vaultTokenAmountReceived, usdValue\n\n\n# vault info on deposit\n\n\n@internal\ndef _getVaultInfoOnDeposit(_asset: address, _vaultAddr: address, _ledger: address, _legoBook: address) -> ls.VaultTokenInfo:\n    vaultInfo: ls.VaultTokenInfo = yld.vaultToAsset[_vaultAddr]\n    if vaultInfo.decimals == 0:\n        assert self._canRegisterVaultToken(_asset, _vaultAddr) # dev: cannot register vault token\n        vaultInfo = self._registerVaultTokenLocally(_asset, _vaultAddr)\n        self._registerVaultTokenGlobally(_asset, _vaultAddr, vaultInfo.decimals, _ledger, _legoBook)\n    else:\n        assert vaultInfo.underlyingAsset == _asset # dev: asset mismatch\n    return vaultInfo\n\n\n# withdraw\n\n\n@external\ndef withdrawFromYield(\n    _vaultToken: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, address, uint256, uint256):\n    assert self._isAllowedToPerformAction(msg.sender) # dev: no perms\n    assert not yld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = yld._getMiniAddys(_miniAddys)\n    vaultInfo: ls.VaultTokenInfo = self._getVaultInfoOnWithdrawal(_vaultToken, miniAddys.ledger, miniAddys.legoBook)\n\n    # pre balances\n    preRecipientAssetBalance: uint256 = staticcall IERC20(vaultInfo.underlyingAsset).balanceOf(_recipient)\n    preLegoVaultBalance: uint256 = staticcall IERC20(_vaultToken).balanceOf(self)\n\n    # transfer vaults tokens to this contract\n    vaultTokenAmount: uint256 = min(_amount, staticcall IERC20(_vaultToken).balanceOf(msg.sender))\n    assert vaultTokenAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_vaultToken).transferFrom(msg.sender, self, vaultTokenAmount, default_return_value=True) # dev: transfer failed\n\n    # withdraw assets from lego partner\n    extcall AaveV3Pool(AAVE_V3_POOL).withdraw(vaultInfo.underlyingAsset, max_value(uint256), _recipient)\n\n    # validate asset transfer\n    assetAmountReceived: uint256 = staticcall IERC20(vaultInfo.underlyingAsset).balanceOf(_recipient) - preRecipientAssetBalance\n    assert assetAmountReceived != 0 # dev: no asset amount received\n\n    # refund if full withdrawal didn't happen\n    currentLegoVaultBalance: uint256 = staticcall IERC20(_vaultToken).balanceOf(self)\n    refundVaultTokenAmount: uint256 = 0\n    if currentLegoVaultBalance > preLegoVaultBalance:\n        refundVaultTokenAmount = currentLegoVaultBalance - preLegoVaultBalance\n        assert extcall IERC20(_vaultToken).transfer(msg.sender, refundVaultTokenAmount, default_return_value=True) # dev: transfer failed\n        vaultTokenAmount -= refundVaultTokenAmount\n\n    usdValue: uint256 = staticcall Appraiser(miniAddys.appraiser).getUnderlyingUsdValue(vaultInfo.underlyingAsset, assetAmountReceived)\n    log AaveV3Withdrawal(\n        sender = msg.sender,\n        asset = vaultInfo.underlyingAsset,\n        vaultToken = _vaultToken,\n        assetAmountReceived = assetAmountReceived,\n        usdValue = usdValue,\n        vaultTokenAmountBurned = vaultTokenAmount,\n        recipient = _recipient,\n    )\n    return vaultTokenAmount, vaultInfo.underlyingAsset, assetAmountReceived, usdValue\n\n\n# vault info on withdrawal\n\n\n@internal\ndef _getVaultInfoOnWithdrawal(_vaultAddr: address, _ledger: address, _legoBook: address) -> ls.VaultTokenInfo:\n    vaultInfo: ls.VaultTokenInfo = yld.vaultToAsset[_vaultAddr]\n    if vaultInfo.decimals == 0:\n        asset: address = staticcall AToken(_vaultAddr).UNDERLYING_ASSET_ADDRESS()\n        assert self._canRegisterVaultToken(asset, _vaultAddr) # dev: cannot register vault token\n        vaultInfo = self._registerVaultTokenLocally(asset, _vaultAddr)\n        self._registerVaultTokenGlobally(asset, _vaultAddr, vaultInfo.decimals, _ledger, _legoBook)\n    return vaultInfo\n\n\n#########\n# Other #\n#########\n\n\n@external\ndef addPriceSnapshot(_vaultToken: address) -> bool:\n    # no need for snapshots\n    return False\n\n\n@view\n@external\ndef getAccessForLego(_user: address, _action: ws.ActionType) -> (address, String[64], uint256):\n    return empty(address), empty(String[64]), 0\n\n\n@external\ndef claimRewards(\n    _user: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _extraData: bytes32,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    # backwards compatibility\n    return 0, 0\n\n\n@external\ndef claimIncentives(\n    _user: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _proofs: DynArray[bytes32, MAX_PROOFS],\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@view\n@external\ndef hasClaimableRewards(_user: address) -> bool:\n    return False\n\n\n@external\ndef swapTokens(\n    _amountIn: uint256,\n    _minAmountOut: uint256,\n    _tokenPath: DynArray[address, MAX_TOKEN_PATH],\n    _poolPath: DynArray[address, MAX_TOKEN_PATH - 1],\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256):\n    return 0, 0, 0\n\n\n@external\ndef mintOrRedeemAsset(\n    _tokenIn: address,\n    _tokenOut: address,\n    _tokenInAmount: uint256,\n    _minAmountOut: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, bool, uint256):\n    return 0, 0, False, 0\n\n\n@external\ndef confirmMintOrRedeemAsset(\n    _tokenIn: address,\n    _tokenOut: address,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef addCollateral(\n    _asset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef removeCollateral(\n    _asset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef borrow(\n    _borrowAsset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef repayDebt(\n    _paymentAsset: address,\n    _paymentAmount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef addLiquidity(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _amountA: uint256,\n    _amountB: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _minLpAmount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (address, uint256, uint256, uint256, uint256):\n    return empty(address), 0, 0, 0, 0\n\n\n@external\ndef removeLiquidity(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpToken: address,\n    _lpAmount: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, uint256):\n    return 0, 0, 0, 0\n\n\n@external\ndef addLiquidityConcentrated(\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _tickLower: int24,\n    _tickUpper: int24,\n    _amountA: uint256,\n    _amountB: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, uint256, uint256):\n    return 0, 0, 0, 0, 0\n\n\n@external\ndef removeLiquidityConcentrated(\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _liqToRemove: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, bool, uint256):\n    return 0, 0, 0, False, 0",
            "sha256sum": "377ac9b0b796d5e509012df436ddaf2cbed7c7c74b23d5570053132a5740c7b4"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/legos/yield/AaveV3.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.3+commit.bff19ea2",
        "integrity": "fc132749e418d5db774a8aba2a03bff56f683ef6615ffe9988a62dcc1aea8e8b"
      },
      "args": "00000000000000000000000044cf3c4f000dfd76a35d03298049d37be688d6f9000000000000000000000000a238dd80c259a72e81d7e4664a9801593f98d1c5000000000000000000000000e20fcbdbffc4dd138ce8b2e6fbb6cb49777ad64d0000000000000000000000006162df1b329e157479f8f1407e888260e0ec3d2b",
      "file": "contracts/legos/yield/AaveV3.vy"
    },
    "CompoundV3": {
      "address": "0x0757B84433Fc529cC4A4a9829b08AB4B68e9c49C",
      "abi": [
        {
          "name": "CompoundV3Deposit",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountDeposited",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultTokenAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "CompoundV3Withdrawal",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultTokenAmountBurned",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "CompoundV3RewardsAddrSet",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LegoPauseModified",
          "inputs": [
            {
              "name": "isPaused",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LegoFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "balance",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "SnapShotPriceConfigSet",
          "inputs": [
            {
              "name": "minSnapshotDelay",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "maxNumSnapshots",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "maxUpsideDeviation",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "staleTime",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetOpportunityAdded",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultAddr",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetOpportunityRemoved",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultAddr",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddys",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "undyToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "hatchery",
                  "type": "address"
                },
                {
                  "name": "lootDistributor",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                },
                {
                  "name": "walletBackpack",
                  "type": "address"
                },
                {
                  "name": "billing",
                  "type": "address"
                },
                {
                  "name": "vaultRegistry",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUndyHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isLegoAsset",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssetOpportunities",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isAssetOpportunity",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getNumLegoAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pause",
          "inputs": [
            {
              "name": "_shouldPause",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFundsMany",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_assets",
              "type": "address[]"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getWeightedPricePerShare",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLatestSnapshot",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_pricePerShare",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "totalSupply",
                  "type": "uint256"
                },
                {
                  "name": "pricePerShare",
                  "type": "uint256"
                },
                {
                  "name": "lastUpdate",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setSnapShotPriceConfig",
          "inputs": [
            {
              "name": "_config",
              "type": "tuple",
              "components": [
                {
                  "name": "minSnapshotDelay",
                  "type": "uint256"
                },
                {
                  "name": "maxNumSnapshots",
                  "type": "uint256"
                },
                {
                  "name": "maxUpsideDeviation",
                  "type": "uint256"
                },
                {
                  "name": "staleTime",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidPriceConfig",
          "inputs": [
            {
              "name": "_config",
              "type": "tuple",
              "components": [
                {
                  "name": "minSnapshotDelay",
                  "type": "uint256"
                },
                {
                  "name": "maxNumSnapshots",
                  "type": "uint256"
                },
                {
                  "name": "maxUpsideDeviation",
                  "type": "uint256"
                },
                {
                  "name": "staleTime",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "vaultToAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "underlyingAsset",
                  "type": "address"
                },
                {
                  "name": "decimals",
                  "type": "uint256"
                },
                {
                  "name": "lastAveragePricePerShare",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assetOpportunities",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAssetOpportunity",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssetOpportunities",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assets",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "snapShotData",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "lastSnapShot",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "totalSupply",
                      "type": "uint256"
                    },
                    {
                      "name": "pricePerShare",
                      "type": "uint256"
                    },
                    {
                      "name": "lastUpdate",
                      "type": "uint256"
                    }
                  ]
                },
                {
                  "name": "nextIndex",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "snapShots",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "totalSupply",
                  "type": "uint256"
                },
                {
                  "name": "pricePerShare",
                  "type": "uint256"
                },
                {
                  "name": "lastUpdate",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "snapShotPriceConfig",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "minSnapshotDelay",
                  "type": "uint256"
                },
                {
                  "name": "maxNumSnapshots",
                  "type": "uint256"
                },
                {
                  "name": "maxUpsideDeviation",
                  "type": "uint256"
                },
                {
                  "name": "staleTime",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isPaused",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasCapability",
          "inputs": [
            {
              "name": "_action",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRegistries",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isYieldLego",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isDexLego",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAsset",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingBalances",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenBalance",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAmount",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAmountSafe",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenBalance",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingData",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingData",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            },
            {
              "name": "_appraiser",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValueOfVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValueOfVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            },
            {
              "name": "_appraiser",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isRebasing",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPricePerShare",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPricePerShare",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_decimals",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getVaultTokenAmount",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_assetAmount",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalAssets",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalBorrows",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAvailLiquidity",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUtilizationRatio",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isEligibleForYieldBonus",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getWithdrawalFees",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canRegisterVaultToken",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "registerVaultTokenLocally",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "underlyingAsset",
                  "type": "address"
                },
                {
                  "name": "decimals",
                  "type": "uint256"
                },
                {
                  "name": "lastAveragePricePerShare",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "deregisterVaultTokenLocally",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositForYield",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositForYield",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawFromYield",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawFromYield",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimIncentives",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_proofs",
              "type": "bytes32[]"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimIncentives",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_proofs",
              "type": "bytes32[]"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "hasClaimableRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setCompRewardsAddr",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addPriceSnapshot",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAccessForLego",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_action",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "string"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_tokenPath",
              "type": "address[]"
            },
            {
              "name": "_poolPath",
              "type": "address[]"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_tokenPath",
              "type": "address[]"
            },
            {
              "name": "_poolPath",
              "type": "address[]"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_tokenInAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_tokenInAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmMintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmMintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_borrowAsset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_borrowAsset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_paymentAsset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_paymentAsset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "compoundRewards",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "COMPOUND_V3_CONFIGURATOR",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "RIPE_REGISTRY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_undyHq",
              "type": "address"
            },
            {
              "name": "_configurator",
              "type": "address"
            },
            {
              "name": "_compRewards",
              "type": "address"
            },
            {
              "name": "_ripeRegistry",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "interfaces/WalletStructs.vyi": {
            "content": "# @version 0.4.3\n\nflag ActionType:\n    TRANSFER\n    EARN_DEPOSIT\n    EARN_WITHDRAW\n    EARN_REBALANCE\n    SWAP\n    MINT_REDEEM\n    CONFIRM_MINT_REDEEM\n    ADD_COLLATERAL\n    REMOVE_COLLATERAL\n    BORROW\n    REPAY_DEBT\n    REWARDS\n    ETH_TO_WETH\n    WETH_TO_ETH\n    ADD_LIQ\n    REMOVE_LIQ\n    ADD_LIQ_CONC\n    REMOVE_LIQ_CONC\n    PAY_CHEQUE\n\nstruct WalletAssetData:\n    assetBalance: uint256\n    usdValue: uint256\n    isYieldAsset: bool\n    lastPricePerShare: uint256\n\nstruct ActionData:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    billing: address\n    vaultRegistry: address\n    wallet: address\n    walletConfig: address\n    walletOwner: address\n    inEjectMode: bool\n    isFrozen: bool\n    lastTotalUsdValue: uint256\n    signer: address\n    isManager: bool\n    legoId: uint256\n    legoAddr: address\n    eth: address\n    weth: address\n\nstruct MiniAddys:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    appraiser: address",
            "sha256sum": "466493c129135c95470aaf70eeddc936632f7b0f813396e5a7ddc03bea9da518"
          },
          "interfaces/LegoPartner.vyi": {
            "content": "# @version 0.4.3\n\nfrom interfaces import WalletStructs as ws\n\nMAX_TOKEN_PATH: constant(uint256) = 5\nMAX_RECOVER_ASSETS: constant(uint256) = 20\nMAX_PROOFS: constant(uint256) = 25\n\n@external\ndef addLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _tickLower: int24, _tickUpper: int24, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef addLiquidity(_pool: address, _tokenA: address, _tokenB: address, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _minLpAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (address, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef removeLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _liqToRemove: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef removeLiquidity(_pool: address, _tokenA: address, _tokenB: address, _lpToken: address, _lpAmount: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef mintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _tokenInAmount: uint256, _minAmountOut: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef swapTokens(_amountIn: uint256, _minAmountOut: uint256, _tokenPath: DynArray[address, MAX_TOKEN_PATH], _poolPath: DynArray[address, MAX_TOKEN_PATH - 1], _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256):\n    ...\n\n@external\ndef depositForYield(_asset: address, _amount: uint256, _vaultAddr: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef withdrawFromYield(_vaultToken: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef confirmMintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef borrow(_borrowAsset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef repayDebt(_paymentAsset: address, _paymentAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef claimIncentives(_user: address, _rewardToken: address, _rewardAmount: uint256, _proofs: DynArray[bytes32, MAX_PROOFS], _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef removeCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef addCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@view\n@external\ndef getAccessForLego(_user: address, _action: ws.ActionType) -> (address, String[64], uint256):\n    ...\n\n@view\n@external\ndef hasCapability(_action: ws.ActionType) -> bool:\n    ...\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    ...\n\n@view\n@external\ndef isYieldLego() -> bool:\n    ...\n\n@view\n@external\ndef isDexLego() -> bool:\n    ...\n\n\n# common\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "f2afb7bd72d4301aea77bbe4177b7ae954ba6f6b76af363965993eb92ad0b715"
          },
          "interfaces/LegoStructs.vyi": {
            "content": "# @version 0.4.3\n\nstruct VaultTokenInfo:\n    underlyingAsset: address\n    decimals: uint256\n    lastAveragePricePerShare: uint256\n\nstruct SnapShotPriceConfig:\n    minSnapshotDelay: uint256\n    maxNumSnapshots: uint256\n    maxUpsideDeviation: uint256\n    staleTime: uint256\n\nstruct SingleSnapShot:\n    totalSupply: uint256\n    pricePerShare: uint256\n    lastUpdate: uint256\n\nstruct SnapShotData:\n    lastSnapShot: SingleSnapShot\n    nextIndex: uint256\n",
            "sha256sum": "8ae48be17d812d57fbd671bbf0593e8abf175ad0924e47c5997823cac19ec806"
          },
          "interfaces/YieldLego.vyi": {
            "content": "# @version 0.4.3\n\nfrom interfaces import LegoStructs as ls\n\n\n###################\n# Underlying Data #\n###################\n\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    ...\n\n\n@view\n@external\ndef getUnderlyingBalances(_vaultToken: address, _vaultTokenBalance: uint256) -> (uint256, uint256):\n    ...\n\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    ...\n\n\n@view\n@external\ndef getUnderlyingAmountSafe(_vaultToken: address, _vaultTokenBalance: uint256) -> uint256:\n    ...\n\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> (address, uint256, uint256):\n    ...\n\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> uint256:\n    ...\n\n\n###############\n# Other Utils #\n###############\n\n\n@view\n@external\ndef isRebasing() -> bool:\n    ...\n\n\n@view\n@external\ndef getPricePerShare(_vaultToken: address, _decimals: uint256 = 0) -> uint256:\n    ...\n\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef canRegisterVaultToken(_asset: address, _vaultToken: address) -> bool:\n    ...\n\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef getUtilizationRatio(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef getAvailLiquidity(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef isEligibleForYieldBonus(_asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef getWithdrawalFees(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    ...\n\n\n###################\n# Yield Lego Data #\n###################\n\n\n@view\n@external\ndef isLegoAsset(_asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, 40]:\n    ...\n\n\n@view\n@external\ndef getAssets() -> DynArray[address, 20]:\n    ...\n\n\n@view\n@external\ndef isAssetOpportunity(_asset: address, _vaultAddr: address) -> bool:\n    ...\n\n\n@view\n@external\ndef getNumLegoAssets() -> uint256:\n    ...\n\n\n@view\n@external\ndef assets(_index: uint256) -> address:\n    ...\n\n\n@view\n@external\ndef indexOfAsset(_asset: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef numAssets() -> uint256:\n    ...\n\n\n@view\n@external\ndef assetOpportunities(_asset: address, _index: uint256) -> address:\n    ...\n\n\n@view\n@external\ndef indexOfAssetOpportunity(_asset: address, _vaultAddr: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef numAssetOpportunities(_asset: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef vaultToAsset(_vaultAddr: address) -> ls.VaultTokenInfo:\n    ...\n\n\n# price snapshots\n\n\n@external\ndef addPriceSnapshot(_vaultToken: address) -> bool:\n    ...\n\n\n@view\n@external\ndef snapShotPriceConfig() -> ls.SnapShotPriceConfig:\n    ...\n\n\n@view\n@external\ndef snapShotData(_vaultToken: address) -> ls.SnapShotData:\n    ...\n\n\n@view\n@external\ndef snapShots(_vaultToken: address, _index: uint256) -> ls.SingleSnapShot:\n    ...\n\n\n@view\n@external\ndef getWeightedPricePerShare(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef getLatestSnapshot(_vaultToken: address, _pricePerShare: uint256) -> ls.SingleSnapShot:\n    ...\n\n\n@external\ndef setSnapShotPriceConfig(_config: ls.SnapShotPriceConfig):\n    ...\n",
            "sha256sum": "db91c139f6018f5218b389d08c8703bc16fb994aa948805dbfea27e072f382ec"
          },
          "contracts/modules/Addys.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\ninterface UndyHq:\n    def isValidAddr(_addr: address) -> bool: view\n    def getAddr(_regId: uint256) -> address: view\n    def undyToken() -> address: view\n\ninterface Switchboard:\n    def isSwitchboardAddr(_addr: address) -> bool: view\n\ninterface LegoBook:\n    def isLegoAddr(_addr: address) -> bool: view\n\nstruct Addys:\n    hq: address\n    undyToken: address\n    ledger: address\n    missionControl: address\n    legoBook: address\n    switchboard: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    walletBackpack: address\n    billing: address\n    vaultRegistry: address\n\n# hq\nUNDY_HQ_FOR_ADDYS: immutable(address)\n\n# core addys\nLEDGER_ID: constant(uint256) = 1\nMISSION_CONTROL_ID: constant(uint256) = 2\nLEGO_BOOK_ID: constant(uint256) = 3\nSWITCHBOARD_ID: constant(uint256) = 4\nHATCHERY_ID: constant(uint256) = 5\nLOOT_DISTRIBUTOR_ID: constant(uint256) = 6\nAPPRAISER_ID: constant(uint256) = 7\nWALLET_BACKPACK_ID: constant(uint256) = 8\nBILLING_ID: constant(uint256) = 9\nVAULT_REGISTRY_ID: constant(uint256) = 10\n\n\n@deploy\ndef __init__(_undyHq: address):\n    assert _undyHq != empty(address) # dev: invalid undy hq\n    UNDY_HQ_FOR_ADDYS = _undyHq\n\n\n########\n# Core #\n########\n\n\n@view\n@external\ndef getAddys() -> Addys:\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _getAddys(_addys: Addys = empty(Addys)) -> Addys:\n    if _addys.hq != empty(address):\n        return _addys\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _generateAddys() -> Addys:\n    hq: address = UNDY_HQ_FOR_ADDYS\n    return Addys(\n        hq = hq,\n        undyToken = staticcall UndyHq(hq).undyToken(),\n        ledger = staticcall UndyHq(hq).getAddr(LEDGER_ID),\n        missionControl = staticcall UndyHq(hq).getAddr(MISSION_CONTROL_ID),\n        legoBook = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID),\n        switchboard = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID),\n        hatchery = staticcall UndyHq(hq).getAddr(HATCHERY_ID),\n        lootDistributor = staticcall UndyHq(hq).getAddr(LOOT_DISTRIBUTOR_ID),\n        appraiser = staticcall UndyHq(hq).getAddr(APPRAISER_ID),\n        walletBackpack = staticcall UndyHq(hq).getAddr(WALLET_BACKPACK_ID),\n        billing = staticcall UndyHq(hq).getAddr(BILLING_ID),\n        vaultRegistry = staticcall UndyHq(hq).getAddr(VAULT_REGISTRY_ID),\n    )\n\n\n##########\n# Tokens #\n##########\n\n\n@view\n@internal\ndef _getUndyToken() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).undyToken()\n\n\n###########\n# Helpers #\n###########\n\n\n# undy hq\n\n\n@view\n@external\ndef getUndyHq() -> address:\n    return self._getUndyHq()\n\n\n@view\n@internal\ndef _getUndyHq() -> address:\n    return UNDY_HQ_FOR_ADDYS\n\n\n# utils\n\n\n@view\n@internal\ndef _isValidUndyAddr(_addr: address, _hq: address = empty(address)) -> bool:\n    hq: address = _hq\n    if _hq == empty(address):\n        hq = UNDY_HQ_FOR_ADDYS\n    \n    # core departments\n    if staticcall UndyHq(hq).isValidAddr(_addr):\n        return True\n\n    # lego book\n    legoBook: address = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID)\n    if legoBook != empty(address) and staticcall LegoBook(legoBook).isLegoAddr(_addr):\n        return True\n\n    # switchboard config\n    switchboard: address = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID)\n    if switchboard != empty(address) and staticcall Switchboard(switchboard).isSwitchboardAddr(_addr):\n        return True\n\n    return False\n\n\n@view\n@internal\ndef _isSwitchboardAddr(_addr: address) -> bool:\n    switchboard: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n    if switchboard == empty(address):\n        return False\n    return staticcall Switchboard(switchboard).isSwitchboardAddr(_addr)\n\n\n@view\n@internal\ndef _isLegoBookAddr(_addr: address) -> bool:\n    legoBook: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n    if legoBook == empty(address):\n        return False\n    return staticcall LegoBook(legoBook).isLegoAddr(_addr)\n\n\n###############\n# Departments #\n###############\n\n\n# ledger\n\n\n@view\n@internal\ndef _getLedgerId() -> uint256:\n    return LEDGER_ID\n\n\n@view\n@internal\ndef _getLedgerAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEDGER_ID)\n\n\n# mission control\n\n\n@view\n@internal\ndef _getMissionControlId() -> uint256:\n    return MISSION_CONTROL_ID\n\n\n@view\n@internal\ndef _getMissionControlAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(MISSION_CONTROL_ID)\n\n\n# lego book\n\n\n@view\n@internal\ndef _getLegoBookId() -> uint256:\n    return LEGO_BOOK_ID\n\n\n@view\n@internal\ndef _getLegoBookAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n\n\n# switchboard\n\n\n@view\n@internal\ndef _getSwitchboardId() -> uint256:\n    return SWITCHBOARD_ID\n\n\n@view\n@internal\ndef _getSwitchboardAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n\n\n# hatchery\n\n\n@view\n@internal\ndef _getHatcheryId() -> uint256:\n    return HATCHERY_ID\n\n\n@view\n@internal\ndef _getHatcheryAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(HATCHERY_ID)\n\n\n# loot distributor\n\n\n@view\n@internal\ndef _getLootDistributorId() -> uint256:\n    return LOOT_DISTRIBUTOR_ID\n\n\n@view\n@internal\ndef _getLootDistributorAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LOOT_DISTRIBUTOR_ID)\n\n\n# appraiser\n\n\n@view\n@internal\ndef _getAppraiserId() -> uint256:\n    return APPRAISER_ID\n\n\n@view\n@internal\ndef _getAppraiserAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(APPRAISER_ID)\n\n\n# wallet backpack\n\n\n@view\n@internal\ndef _getWalletBackpackId() -> uint256:\n    return WALLET_BACKPACK_ID\n\n\n@view\n@internal\ndef _getWalletBackpackAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(WALLET_BACKPACK_ID)\n\n\n# billing\n\n\n@view\n@internal\ndef _getBillingId() -> uint256:\n    return BILLING_ID\n\n\n@view\n@internal\ndef _getBillingAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(BILLING_ID)\n\n\n# vault registry\n\n\n@view\n@internal\ndef _getVaultRegistryId() -> uint256:\n    return VAULT_REGISTRY_ID\n\n\n@view\n@internal\ndef _getVaultRegistryAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(VAULT_REGISTRY_ID)",
            "sha256sum": "4df6b72db9bb417d1af81660175be1450cfb7b3575f3d17a5b8a130bff87b781"
          },
          "contracts/modules/YieldLegoData.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nuses: addys\n\nimport contracts.modules.Addys as addys\n\nfrom interfaces import WalletStructs as ws\nfrom interfaces import LegoStructs as ls\nfrom ethereum.ercs import IERC20\nfrom ethereum.ercs import IERC20Detailed\n\nevent AssetOpportunityAdded:\n    asset: indexed(address)\n    vaultAddr: indexed(address)\n\nevent AssetOpportunityRemoved:\n    asset: indexed(address)\n    vaultAddr: indexed(address)\n\nevent LegoPauseModified:\n    isPaused: bool\n\nevent LegoFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    balance: uint256\n\nevent PricePerShareSnapShotAdded:\n    vaultToken: indexed(address)\n    totalSupply: uint256\n    pricePerShare: uint256\n    lastAveragePricePerShare: uint256\n\nevent SnapShotPriceConfigSet:\n    minSnapshotDelay: uint256\n    maxNumSnapshots: uint256\n    maxUpsideDeviation: uint256\n    staleTime: uint256\n\n# core\nvaultToAsset: public(HashMap[address, ls.VaultTokenInfo]) # vault addr -> data\n\n# asset opportunities\nassetOpportunities: public(HashMap[address, HashMap[uint256, address]]) # asset -> index -> vault addr\nindexOfAssetOpportunity: public(HashMap[address, HashMap[address, uint256]]) # asset -> vault addr -> index\nnumAssetOpportunities: public(HashMap[address, uint256]) # asset -> number of opportunities\n\n# lego assets (iterable)\nassets: public(HashMap[uint256, address]) # index -> asset\nindexOfAsset: public(HashMap[address, uint256]) # asset -> index\nnumAssets: public(uint256) # num assets\n\n# price snapshots\nsnapShotData: public(HashMap[address, ls.SnapShotData]) # vault token -> data\nsnapShots: public(HashMap[address, HashMap[uint256, ls.SingleSnapShot]]) # vault token -> index -> snapshot\nsnapShotPriceConfig: public(ls.SnapShotPriceConfig) # config\n\nisPaused: public(bool)\n\nMAX_VAULTS: constant(uint256) = 40\nMAX_ASSETS: constant(uint256) = 20\nMAX_RECOVER_ASSETS: constant(uint256) = 20\nONE_DAY_SECONDS: constant(uint256) = 60 * 60 * 24\nONE_WEEK_SECONDS: constant(uint256) = ONE_DAY_SECONDS * 7\nHUNDRED_PERCENT: constant(uint256) = 100_00\n\n\n@deploy\ndef __init__(_shouldPause: bool):\n    self.isPaused = _shouldPause\n    self.numAssets = 1 # not using 0 index\n\n    # default snapshot price config\n    self.snapShotPriceConfig = ls.SnapShotPriceConfig(\n        minSnapshotDelay = 60 * 10, # 10 minutes\n        maxNumSnapshots = 20,\n        maxUpsideDeviation = 10_00, # 10%\n        staleTime = ONE_DAY_SECONDS, # 1 day\n    )\n\n\n#########\n# Views #\n#########\n\n\n# is lego asset\n\n\n@view\n@external\ndef isLegoAsset(_asset: address) -> bool:\n    return self._isLegoAsset(_asset)\n\n\n@view\n@internal\ndef _isLegoAsset(_asset: address) -> bool:\n    return self.indexOfAsset[_asset] != 0\n\n\n# vault opportunities\n\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, MAX_VAULTS]:\n    numOpportunities: uint256 = self.numAssetOpportunities[_asset]\n    if numOpportunities == 0:\n        return []\n    opportunities: DynArray[address, MAX_VAULTS] = []\n    for i: uint256 in range(1, numOpportunities, bound=MAX_VAULTS):\n        opportunities.append(self.assetOpportunities[_asset][i])\n    return opportunities\n\n\n# all assets registered\n\n\n@view\n@external\ndef getAssets() -> DynArray[address, MAX_ASSETS]:\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return []\n    assets: DynArray[address, MAX_ASSETS] = []\n    for i: uint256 in range(1, numAssets, bound=MAX_ASSETS):\n        assets.append(self.assets[i])\n    return assets\n\n\n################\n# Registration #\n################\n\n\n@view\n@external\ndef isAssetOpportunity(_asset: address, _vaultAddr: address) -> bool:\n    return self._isAssetOpportunity(_asset, _vaultAddr)\n\n\n@view\n@internal\ndef _isAssetOpportunity(_asset: address, _vaultAddr: address) -> bool:\n    return self.indexOfAssetOpportunity[_asset][_vaultAddr] != 0\n\n\n# add asset opportunity\n\n\n@internal\ndef _addAssetOpportunity(_asset: address, _vaultAddr: address) -> ls.VaultTokenInfo:\n    if self.indexOfAssetOpportunity[_asset][_vaultAddr] != 0:\n        return self.vaultToAsset[_vaultAddr]\n\n    if empty(address) in [_asset, _vaultAddr]:\n        return empty(ls.VaultTokenInfo)\n\n    # add asset opportunity\n    aid: uint256 = self.numAssetOpportunities[_asset]\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.assetOpportunities[_asset][aid] = _vaultAddr\n    self.indexOfAssetOpportunity[_asset][_vaultAddr] = aid\n    self.numAssetOpportunities[_asset] = aid + 1\n\n    # add mapping\n    vaultInfo: ls.VaultTokenInfo = ls.VaultTokenInfo(\n        underlyingAsset = _asset,\n        decimals = convert(staticcall IERC20Detailed(_vaultAddr).decimals(), uint256),\n        lastAveragePricePerShare = 0,\n    )\n    self.vaultToAsset[_vaultAddr] = vaultInfo\n\n    # add asset\n    self._addAsset(_asset)\n\n    log AssetOpportunityAdded(asset=_asset, vaultAddr=_vaultAddr)\n    return vaultInfo\n\n\n# remove asset opportunity\n\n\n@internal\ndef _removeAssetOpportunity(_asset: address, _vaultAddr: address):\n    numOpportunities: uint256 = self.numAssetOpportunities[_asset]\n    if numOpportunities == 0:\n        return\n\n    targetIndex: uint256 = self.indexOfAssetOpportunity[_asset][_vaultAddr]\n    if targetIndex == 0:\n        return\n\n    # update data\n    lastIndex: uint256 = numOpportunities - 1\n    self.numAssetOpportunities[_asset] = lastIndex\n    self.indexOfAssetOpportunity[_asset][_vaultAddr] = 0\n\n    self.vaultToAsset[_vaultAddr] = empty(ls.VaultTokenInfo)\n\n    # clear all snapshot data for the vault token to prevent contamination on re-add\n    self.snapShotData[_vaultAddr] = empty(ls.SnapShotData)\n\n    # clear all historical snapshots\n    config: ls.SnapShotPriceConfig = self.snapShotPriceConfig\n    for i: uint256 in range(config.maxNumSnapshots, bound=max_value(uint256)):\n        if i >= config.maxNumSnapshots:\n            break\n        self.snapShots[_vaultAddr][i] = empty(ls.SingleSnapShot)\n\n    # shift to replace the removed one\n    if targetIndex != lastIndex:\n        lastVaultAddr: address = self.assetOpportunities[_asset][lastIndex]\n        self.assetOpportunities[_asset][targetIndex] = lastVaultAddr\n        self.indexOfAssetOpportunity[_asset][lastVaultAddr] = targetIndex\n\n    # remove asset\n    if lastIndex <= 1:\n        self._removeAsset(_asset)\n\n    log AssetOpportunityRemoved(asset=_asset, vaultAddr=_vaultAddr)\n\n\n# add asset\n\n\n@internal\ndef _addAsset(_asset: address):\n    if self.indexOfAsset[_asset] != 0:\n        return\n\n    aid: uint256 = self.numAssets\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.assets[aid] = _asset\n    self.indexOfAsset[_asset] = aid\n    self.numAssets = aid + 1\n\n\n# remove asset\n\n\n@internal\ndef _removeAsset(_asset: address):\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return\n\n    targetIndex: uint256 = self.indexOfAsset[_asset]\n    if targetIndex == 0:\n        return\n\n    # update data\n    lastIndex: uint256 = numAssets - 1\n    self.numAssets = lastIndex\n    self.indexOfAsset[_asset] = 0\n\n    # shift to replace the removed one\n    if targetIndex != lastIndex:\n        lastAsset: address = self.assets[lastIndex]\n        self.assets[targetIndex] = lastAsset\n        self.indexOfAsset[lastAsset] = targetIndex\n\n\n# num lego assets (true number, use `numAssets` for iteration)\n\n\n@view\n@external\ndef getNumLegoAssets() -> uint256:\n    return self._getNumLegoAssets()\n\n\n@view\n@internal\ndef _getNumLegoAssets() -> uint256:\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return 0\n    return numAssets - 1\n\n\n###########\n# General #\n###########\n\n\n# fill mini addys\n\n\n@view\n@internal\ndef _getMiniAddys(_miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> ws.MiniAddys:\n    if _miniAddys.ledger != empty(address):\n        return _miniAddys\n    return ws.MiniAddys(\n        ledger = addys._getLedgerAddr(),\n        missionControl = addys._getMissionControlAddr(),\n        legoBook = addys._getLegoBookAddr(),\n        appraiser = addys._getAppraiserAddr(),\n    )\n\n\n# activate\n\n\n@external\ndef pause(_shouldPause: bool):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert _shouldPause != self.isPaused # dev: no change\n    self.isPaused = _shouldPause\n    log LegoPauseModified(isPaused=_shouldPause)\n\n\n# recover funds\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    self._recoverFunds(_recipient, _asset)\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, MAX_RECOVER_ASSETS]):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    for a: address in _assets:\n        self._recoverFunds(_recipient, a)\n\n\n@internal\ndef _recoverFunds(_recipient: address, _asset: address):\n    assert empty(address) not in [_recipient, _asset] # dev: invalid recipient or asset\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    assert balance != 0 # dev: nothing to recover\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log LegoFundsRecovered(asset=_asset, recipient=_recipient, balance=balance)\n\n\n###################\n# Price Snapshots #\n###################\n\n\n# add price snapshot\n\n\n@internal\ndef _addPriceSnapshot(_vaultToken: address, _pricePerShare: uint256, _vaultTokenDecimals: uint256) -> bool:\n    config: ls.SnapShotPriceConfig = self.snapShotPriceConfig\n    if config.maxNumSnapshots == 0:\n        return False\n\n    data: ls.SnapShotData = self.snapShotData[_vaultToken]\n\n    # already have snapshot for this time\n    if data.lastSnapShot.lastUpdate == block.timestamp:\n        return False\n\n    # check if snapshot is too recent\n    if data.lastSnapShot.lastUpdate + config.minSnapshotDelay > block.timestamp:\n        return False\n\n    # create and store new snapshot\n    newSnapshot: ls.SingleSnapShot = self._getLatestSnapshot(_vaultToken, _pricePerShare, _vaultTokenDecimals, data.lastSnapShot, config)\n    data.lastSnapShot = newSnapshot\n    self.snapShots[_vaultToken][data.nextIndex] = newSnapshot\n\n    # update index\n    data.nextIndex += 1\n    if data.nextIndex >= config.maxNumSnapshots:\n        data.nextIndex = 0\n\n    # save snap shot data\n    self.snapShotData[_vaultToken] = data\n\n    # update cached weighted average price per share\n    lastAveragePricePerShare: uint256 = self._getWeightedPricePerShare(_vaultToken, _pricePerShare)\n    self.vaultToAsset[_vaultToken].lastAveragePricePerShare = lastAveragePricePerShare\n\n    log PricePerShareSnapShotAdded(\n        vaultToken = _vaultToken,\n        totalSupply = newSnapshot.totalSupply,\n        pricePerShare = newSnapshot.pricePerShare,\n        lastAveragePricePerShare = lastAveragePricePerShare,\n    )\n    return True\n\n\n# weighted price per share\n\n\n@view\n@external\ndef getWeightedPricePerShare(_vaultToken: address) -> uint256:\n    data: ls.SnapShotData = self.snapShotData[_vaultToken]\n    return self._getWeightedPricePerShare(_vaultToken, data.lastSnapShot.pricePerShare)\n\n\n@view\n@internal\ndef _getWeightedPricePerShare(_vaultToken: address, _lastPricePerShare: uint256) -> uint256:\n    config: ls.SnapShotPriceConfig = self.snapShotPriceConfig\n    if config.maxNumSnapshots == 0:\n        return 0\n\n    # calculate weighted average price using all valid snapshots\n    numerator: uint256 = 0\n    denominator: uint256 = 0\n    for i: uint256 in range(config.maxNumSnapshots, bound=max_value(uint256)):\n\n        snapShot: ls.SingleSnapShot = self.snapShots[_vaultToken][i]\n        if snapShot.pricePerShare == 0 or snapShot.totalSupply == 0 or snapShot.lastUpdate == 0:\n            continue\n\n        # too stale, skip\n        if config.staleTime != 0 and block.timestamp > snapShot.lastUpdate + config.staleTime:\n            continue\n\n        numerator += (snapShot.totalSupply * snapShot.pricePerShare)\n        denominator += snapShot.totalSupply\n\n    # weighted price per share\n    weightedPricePerShare: uint256 = 0\n    if numerator != 0:\n        weightedPricePerShare = numerator // denominator\n    else:\n        weightedPricePerShare = _lastPricePerShare\n\n    return weightedPricePerShare\n\n\n# latest snapshot\n\n\n@view\n@external\ndef getLatestSnapshot(_vaultToken: address, _pricePerShare: uint256) -> ls.SingleSnapShot:\n    data: ls.SnapShotData = self.snapShotData[_vaultToken]\n    config: ls.SnapShotPriceConfig = self.snapShotPriceConfig\n    vaultTokenDecimals: uint256 = self.vaultToAsset[_vaultToken].decimals\n    return self._getLatestSnapshot(_vaultToken, _pricePerShare, vaultTokenDecimals, data.lastSnapShot, config)\n\n\n@view\n@internal\ndef _getLatestSnapshot(\n    _vaultToken: address,\n    _pricePerShare: uint256,\n    _vaultTokenDecimals: uint256,\n    _lastSnapShot: ls.SingleSnapShot,\n    _config: ls.SnapShotPriceConfig,\n) -> ls.SingleSnapShot:\n\n    # total supply (adjusted)\n    totalSupply: uint256 = staticcall IERC20(_vaultToken).totalSupply() // (10 ** _vaultTokenDecimals)\n    if totalSupply == 0:\n        totalSupply = 1\n\n    # throttle upside (extra safety check)\n    pricePerShare: uint256 = self._throttleUpside(_pricePerShare, _lastSnapShot.pricePerShare, _config.maxUpsideDeviation)\n\n    return ls.SingleSnapShot(\n        totalSupply = totalSupply,\n        pricePerShare = pricePerShare,\n        lastUpdate = block.timestamp,\n    )\n\n\n@view\n@internal\ndef _throttleUpside(_newValue: uint256, _prevValue: uint256, _maxUpside: uint256) -> uint256:\n    if _maxUpside == 0 or _prevValue == 0 or _newValue == 0:\n        return _newValue\n    maxPricePerShare: uint256 = _prevValue + (_prevValue * _maxUpside // HUNDRED_PERCENT)\n    return min(_newValue, maxPricePerShare)\n\n\n# snapshot price config\n\n\n@external\ndef setSnapShotPriceConfig(_config: ls.SnapShotPriceConfig):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert self._isValidPriceConfig(_config) # dev: invalid config\n    self.snapShotPriceConfig = _config\n    log SnapShotPriceConfigSet(\n        minSnapshotDelay=_config.minSnapshotDelay,\n        maxNumSnapshots=_config.maxNumSnapshots,\n        maxUpsideDeviation=_config.maxUpsideDeviation,\n        staleTime=_config.staleTime\n    )\n\n\n@view\n@external\ndef isValidPriceConfig(_config: ls.SnapShotPriceConfig) -> bool:\n    return self._isValidPriceConfig(_config)\n\n\n@view\n@internal\ndef _isValidPriceConfig(_config: ls.SnapShotPriceConfig) -> bool:\n    if _config.minSnapshotDelay > ONE_WEEK_SECONDS:\n        return False\n    if _config.maxNumSnapshots == 0 or _config.maxNumSnapshots > 25:\n        return False\n    if _config.maxUpsideDeviation > HUNDRED_PERCENT:\n        return False\n    return _config.staleTime < ONE_WEEK_SECONDS",
            "sha256sum": "50440c96dc8a7af22e7ad927bb6d3e308f137d5d3632e633e084b05510c94c28"
          },
          "contracts/legos/yield/CompoundV3.vy": {
            "content": "#     __   __ ___ _______ ___     ______       ___     _______ _______ _______ \n#    |  | |  |   |       |   |   |      |     |   |   |       |       |       |\n#    |  |_|  |   |    ___|   |   |  _    |    |   |   |    ___|    ___|   _   |\n#    |       |   |   |___|   |   | | |   |    |   |   |   |___|   | __|  | |  |\n#    |_     _|   |    ___|   |___| |_|   |    |   |___|    ___|   ||  |  |_|  |\n#      |   | |   |   |___|       |       |    |       |   |___|   |_| |       |\n#      |___| |___|_______|_______|______|     |_______|_______|_______|_______|\n#                                                                       \n#     \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n#     \u2551  ** Compound V3 Lego **                   \u2551\n#     \u2551  Integration with Compound Protocol (v3)  \u2551\n#     \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n#\n#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nimplements: Lego\nimplements: YieldLego\n\nexports: addys.__interface__\nexports: yld.__interface__\n\ninitializes: addys\ninitializes: yld[addys := addys]\n\nfrom interfaces import LegoPartner as Lego\nfrom interfaces import YieldLego as YieldLego\nfrom interfaces import WalletStructs as ws\nfrom interfaces import LegoStructs as ls\n\nimport contracts.modules.Addys as addys\nimport contracts.modules.YieldLegoData as yld\n\nfrom ethereum.ercs import IERC20\nfrom ethereum.ercs import IERC20Detailed\n\ninterface CompoundV3:\n    def withdrawTo(_recipient: address, _asset: address, _amount: uint256): nonpayable\n    def supplyTo(_recipient: address, _asset: address, _amount: uint256): nonpayable\n    def totalSupply() -> uint256: view\n    def totalBorrow() -> uint256: view\n    def baseToken() -> address: view\n\ninterface Ledger:\n    def setVaultToken(_vaultToken: address, _legoId: uint256, _underlyingAsset: address, _decimals: uint256, _isRebasing: bool): nonpayable\n    def isRegisteredVaultToken(_vaultToken: address) -> bool: view\n    def isUserWallet(_user: address) -> bool: view\n\ninterface CompoundV3Rewards:\n    def getRewardOwed(_comet: address, _user: address) -> RewardOwed: nonpayable\n    def claim(_comet: address, _user: address, _shouldAccrue: bool): nonpayable\n\ninterface Registry:\n    def getRegId(_addr: address) -> uint256: view\n    def isValidAddr(_addr: address) -> bool: view\n\ninterface Appraiser:\n    def getUnderlyingUsdValue(_asset: address, _amount: uint256) -> uint256: view\n\ninterface VaultRegistry:\n    def isEarnVault(_vaultAddr: address) -> bool: view\n\ninterface CompoundV3Configurator:\n    def factory(_cometAsset: address) -> address: view\n\nstruct RewardOwed:\n    token: address\n    owed: uint256\n\nevent CompoundV3Deposit:\n    sender: indexed(address)\n    asset: indexed(address)\n    vaultToken: indexed(address)\n    assetAmountDeposited: uint256\n    usdValue: uint256\n    vaultTokenAmountReceived: uint256\n    recipient: address\n\nevent CompoundV3Withdrawal:\n    sender: indexed(address)\n    asset: indexed(address)\n    vaultToken: indexed(address)\n    assetAmountReceived: uint256\n    usdValue: uint256\n    vaultTokenAmountBurned: uint256\n    recipient: address\n\nevent CompoundV3RewardsAddrSet:\n    addr: address\n\n# rewards contract\ncompoundRewards: public(address)\n\n# compound v3\nCOMPOUND_V3_CONFIGURATOR: public(immutable(address))\nRIPE_REGISTRY: public(immutable(address))\n\nMAX_TOKEN_PATH: constant(uint256) = 5\nMAX_PROOFS: constant(uint256) = 25\nHUNDRED_PERCENT: constant(uint256) = 100_00\n\n\n@deploy\ndef __init__(\n    _undyHq: address,\n    _configurator: address,\n    _compRewards: address,\n    _ripeRegistry: address,\n):\n    addys.__init__(_undyHq)\n    yld.__init__(False)\n\n    assert _configurator != empty(address) # dev: invalid configurator\n    COMPOUND_V3_CONFIGURATOR = _configurator\n    self.compoundRewards = _compRewards\n\n    assert _ripeRegistry != empty(address) # dev: invalid addrs\n    RIPE_REGISTRY = _ripeRegistry\n\n\n@view\n@external\ndef hasCapability(_action: ws.ActionType) -> bool:\n    return _action in (\n        ws.ActionType.EARN_DEPOSIT | \n        ws.ActionType.EARN_WITHDRAW |\n        ws.ActionType.REWARDS\n    )\n\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    return [COMPOUND_V3_CONFIGURATOR]\n\n\n@view\n@external\ndef isYieldLego() -> bool:\n    return True\n\n\n@view\n@external\ndef isDexLego() -> bool:\n    return False\n\n\n###################\n# Underlying Data #\n###################\n\n\n# underlying asset\n\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    return self._getUnderlyingAsset(_vaultToken)\n\n\n@view\n@internal\ndef _getUnderlyingAsset(_vaultToken: address) -> address:\n    asset: address = yld.vaultToAsset[_vaultToken].underlyingAsset\n    if asset != empty(address):\n        return asset\n    return staticcall CompoundV3(_vaultToken).baseToken()\n\n\n# underlying balances (both true and safe)\n\n\n@view\n@external\ndef getUnderlyingBalances(_vaultToken: address, _vaultTokenBalance: uint256) -> (uint256, uint256):\n    return _vaultTokenBalance, _vaultTokenBalance\n\n\n# underlying amount (true)\n\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    return self._getUnderlyingAmount(_vaultToken, _vaultTokenAmount)\n\n\n@view\n@internal\ndef _getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    # treated as 1:1\n    return _vaultTokenAmount\n\n\n# underlying amount (safe)\n\n\n@view\n@external\ndef getUnderlyingAmountSafe(_vaultToken: address, _vaultTokenBalance: uint256) -> uint256:\n    # treated as 1:1\n    return _vaultTokenBalance\n\n\n# underlying data (combined)\n\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> (address, uint256, uint256):\n    return self._getUnderlyingData(_vaultToken, _vaultTokenAmount, _appraiser)\n\n\n@view\n@internal\ndef _getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address) -> (address, uint256, uint256):\n    asset: address = self._getUnderlyingAsset(_vaultToken)\n    if asset == empty(address):\n        return empty(address), 0, 0 # invalid vault token\n    underlyingAmount: uint256 = self._getUnderlyingAmount(_vaultToken, _vaultTokenAmount)\n    usdValue: uint256 = self._getUsdValue(asset, underlyingAmount, _appraiser)\n    return asset, underlyingAmount, usdValue\n\n\n# usd value\n\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> uint256:\n    return self._getUsdValueOfVaultToken(_vaultToken, _vaultTokenAmount, _appraiser)\n\n\n@view\n@internal\ndef _getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address) -> uint256:\n    return self._getUnderlyingData(_vaultToken, _vaultTokenAmount, _appraiser)[2]\n\n\n@view\n@internal\ndef _getUsdValue(_asset: address, _amount: uint256, _appraiser: address) -> uint256:\n    appraiser: address = _appraiser\n    if _appraiser == empty(address):\n        appraiser = addys._getAppraiserAddr()\n    return staticcall Appraiser(appraiser).getUnderlyingUsdValue(_asset, _amount)\n\n\n###############\n# Other Utils #\n###############\n\n\n# basics\n\n\n@view\n@external\ndef isRebasing() -> bool:\n    return self._isRebasing()\n\n\n@view\n@internal\ndef _isRebasing() -> bool:\n    return True\n\n\n# price per share\n\n\n@view\n@external\ndef getPricePerShare(_vaultToken: address, _decimals: uint256 = 0) -> uint256:\n    decimals: uint256 = _decimals\n    if decimals == 0:\n        decimals = yld.vaultToAsset[_vaultToken].decimals\n    if decimals == 0:\n        decimals = convert(staticcall IERC20Detailed(_vaultToken).decimals(), uint256)\n    return self._getPricePerShare(_vaultToken, decimals)\n\n\n@view\n@internal\ndef _getPricePerShare(_vaultToken: address, _decimals: uint256) -> uint256:\n    return 10 ** _decimals # treated as 1:1\n\n\n# vault token amount\n\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    return _assetAmount # treated as 1:1\n\n\n# total assets\n\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    return self._totalAssets(_vaultToken)\n\n\n@view\n@internal\ndef _totalAssets(_vaultToken: address) -> uint256:\n    return staticcall CompoundV3(_vaultToken).totalSupply()\n\n\n# total borrows\n\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    return self._totalBorrows(_vaultToken)\n\n\n@view\n@internal\ndef _totalBorrows(_vaultToken: address) -> uint256:\n    return staticcall CompoundV3(_vaultToken).totalBorrow()\n\n\n# avail liquidity\n\n\n@view\n@external\ndef getAvailLiquidity(_vaultToken: address) -> uint256:\n    totalAssets: uint256 = self._totalAssets(_vaultToken)\n    totalBorrows: uint256 = self._totalBorrows(_vaultToken)\n    if totalAssets <= totalBorrows:\n        return 0\n    return totalAssets - totalBorrows\n\n\n# utilization\n\n\n@view\n@external\ndef getUtilizationRatio(_vaultToken: address) -> uint256:\n    totalAssets: uint256 = self._totalAssets(_vaultToken)\n    if totalAssets == 0:\n        return 0\n    totalBorrows: uint256 = self._totalBorrows(_vaultToken)\n    return totalBorrows * HUNDRED_PERCENT // totalAssets\n\n\n# extras\n\n\n@view\n@external\ndef isEligibleForYieldBonus(_asset: address) -> bool:\n    return False\n\n\n@view\n@external\ndef getWithdrawalFees(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    return 0\n\n\n################\n# Registration #\n################\n\n\n# can vault be registered\n\n\n@view\n@external\ndef canRegisterVaultToken(_asset: address, _vaultToken: address) -> bool:\n    return self._canRegisterVaultToken(_asset, _vaultToken)\n\n\n@view\n@internal\ndef _canRegisterVaultToken(_asset: address, _vaultToken: address) -> bool:\n    if empty(address) in [_asset, _vaultToken]:\n        return False\n    if staticcall CompoundV3(_vaultToken).baseToken() != _asset:\n        return False\n    return staticcall CompoundV3Configurator(COMPOUND_V3_CONFIGURATOR).factory(_vaultToken) != empty(address)\n\n\n# register vault token locally\n\n\n@external\ndef registerVaultTokenLocally(_asset: address, _vaultAddr: address) -> ls.VaultTokenInfo:\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert self._canRegisterVaultToken(_asset, _vaultAddr) # dev: cannot register vault token\n    assert not yld._isAssetOpportunity(_asset, _vaultAddr) # dev: already registered\n    vaultInfo: ls.VaultTokenInfo = self._registerVaultTokenLocally(_asset, _vaultAddr)\n    self._registerVaultTokenGlobally(_asset, _vaultAddr, vaultInfo.decimals, addys._getLedgerAddr(), addys._getLegoBookAddr())\n    return vaultInfo\n\n\n@internal\ndef _registerVaultTokenLocally(_asset: address, _vaultAddr: address) -> ls.VaultTokenInfo:\n    assert extcall IERC20(_asset).approve(_vaultAddr, max_value(uint256), default_return_value=True) # dev: max approval failed\n    vaultInfo: ls.VaultTokenInfo = yld._addAssetOpportunity(_asset, _vaultAddr)\n    assert vaultInfo.decimals != 0 # dev: invalid vault token\n    return vaultInfo\n\n\n# remove vault token locally\n\n\n@external\ndef deregisterVaultTokenLocally(_asset: address, _vaultAddr: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert yld._isAssetOpportunity(_asset, _vaultAddr) # dev: already registered\n    self._deregisterVaultTokenLocally(_asset, _vaultAddr)\n\n\n@internal\ndef _deregisterVaultTokenLocally(_asset: address, _vaultAddr: address):\n    assert extcall IERC20(_asset).approve(_vaultAddr, 0, default_return_value=True) # dev: max approval failed\n    yld._removeAssetOpportunity(_asset, _vaultAddr)\n\n\n# ledger registration\n\n\n@internal\ndef _registerVaultTokenGlobally(_underlyingAsset: address, _vaultToken: address, _decimals: uint256, _ledger: address, _legoBook: address):\n    if not staticcall Ledger(_ledger).isRegisteredVaultToken(_vaultToken):\n        legoId: uint256 = staticcall Registry(_legoBook).getRegId(self)\n        extcall Ledger(_ledger).setVaultToken(_vaultToken, legoId, _underlyingAsset, _decimals, self._isRebasing())\n\n\n#################\n# Yield Actions #\n#################\n\n\n# access control\n\n\n@view\n@internal\ndef _isAllowedToPerformAction(_caller: address) -> bool:\n    # NOTE: important to not trust `_miniAddys` here, that's why getting ledger and vault registry from addys\n    if staticcall VaultRegistry(addys._getVaultRegistryAddr()).isEarnVault(_caller):\n        return True\n    if staticcall Ledger(addys._getLedgerAddr()).isUserWallet(_caller):\n        return True\n    return staticcall Registry(RIPE_REGISTRY).isValidAddr(_caller) # Ripe Endaoment is allowed\n\n\n# deposit\n\n\n@external\ndef depositForYield(\n    _asset: address,\n    _amount: uint256,\n    _vaultAddr: address,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, address, uint256, uint256):\n    assert self._isAllowedToPerformAction(msg.sender) # dev: no perms\n    assert not yld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = yld._getMiniAddys(_miniAddys)\n    vaultInfo: ls.VaultTokenInfo = self._getVaultInfoOnDeposit(_asset, _vaultAddr, miniAddys.ledger, miniAddys.legoBook)\n\n    # pre balances\n    preRecipientVaultBalance: uint256 = staticcall IERC20(_vaultAddr).balanceOf(_recipient)\n    preLegoBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n\n    # transfer deposit asset to this contract\n    depositAmount: uint256 = min(_amount, staticcall IERC20(_asset).balanceOf(msg.sender))\n    assert depositAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_asset).transferFrom(msg.sender, self, depositAmount, default_return_value=True) # dev: transfer failed\n\n    # deposit assets into lego partner\n    extcall CompoundV3(_vaultAddr).supplyTo(_recipient, _asset, depositAmount) # dev: could not deposit into compound v3\n\n    # validate vault token transfer\n    vaultTokenAmountReceived: uint256 = staticcall IERC20(_vaultAddr).balanceOf(_recipient) - preRecipientVaultBalance\n    assert vaultTokenAmountReceived != 0 # dev: no vault tokens received\n\n    # refund if full deposit didn't get through\n    currentLegoBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    refundAssetAmount: uint256 = 0\n    if currentLegoBalance > preLegoBalance:\n        refundAssetAmount = currentLegoBalance - preLegoBalance\n        assert extcall IERC20(_asset).transfer(msg.sender, refundAssetAmount, default_return_value=True) # dev: transfer failed\n        depositAmount -= refundAssetAmount\n\n    usdValue: uint256 = staticcall Appraiser(miniAddys.appraiser).getUnderlyingUsdValue(_asset, depositAmount)\n    log CompoundV3Deposit(\n        sender = msg.sender,\n        asset = _asset,\n        vaultToken = _vaultAddr,\n        assetAmountDeposited = depositAmount,\n        usdValue = usdValue,\n        vaultTokenAmountReceived = vaultTokenAmountReceived,\n        recipient = _recipient,\n    )\n    return depositAmount, _vaultAddr, vaultTokenAmountReceived, usdValue\n\n\n# vault info on deposit\n\n\n@internal\ndef _getVaultInfoOnDeposit(_asset: address, _vaultAddr: address, _ledger: address, _legoBook: address) -> ls.VaultTokenInfo:\n    vaultInfo: ls.VaultTokenInfo = yld.vaultToAsset[_vaultAddr]\n    if vaultInfo.decimals == 0:\n        assert self._canRegisterVaultToken(_asset, _vaultAddr) # dev: cannot register vault token\n        vaultInfo = self._registerVaultTokenLocally(_asset, _vaultAddr)\n        self._registerVaultTokenGlobally(_asset, _vaultAddr, vaultInfo.decimals, _ledger, _legoBook)\n    else:\n        assert vaultInfo.underlyingAsset == _asset # dev: asset mismatch\n    return vaultInfo\n\n\n# withdraw\n\n\n@external\ndef withdrawFromYield(\n    _vaultToken: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, address, uint256, uint256):\n    assert self._isAllowedToPerformAction(msg.sender) # dev: no perms\n    assert not yld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = yld._getMiniAddys(_miniAddys)\n    vaultInfo: ls.VaultTokenInfo = self._getVaultInfoOnWithdrawal(_vaultToken, miniAddys.ledger, miniAddys.legoBook)\n\n    # pre balances\n    preRecipientAssetBalance: uint256 = staticcall IERC20(vaultInfo.underlyingAsset).balanceOf(_recipient)\n    preLegoVaultBalance: uint256 = staticcall IERC20(_vaultToken).balanceOf(self)\n\n    # transfer vaults tokens to this contract\n    vaultTokenAmount: uint256 = min(_amount, staticcall IERC20(_vaultToken).balanceOf(msg.sender))\n    assert vaultTokenAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_vaultToken).transferFrom(msg.sender, self, vaultTokenAmount, default_return_value=True) # dev: transfer failed\n\n    # withdraw assets from lego partner\n    extcall CompoundV3(_vaultToken).withdrawTo(_recipient, vaultInfo.underlyingAsset, max_value(uint256)) # dev: could not withdraw from compound v3\n\n    # validate asset transfer\n    assetAmountReceived: uint256 = staticcall IERC20(vaultInfo.underlyingAsset).balanceOf(_recipient) - preRecipientAssetBalance\n    assert assetAmountReceived != 0 # dev: no asset amount received\n\n    # refund if full withdrawal didn't happen\n    currentLegoVaultBalance: uint256 = staticcall IERC20(_vaultToken).balanceOf(self)\n    refundVaultTokenAmount: uint256 = 0\n    if currentLegoVaultBalance > preLegoVaultBalance:\n        refundVaultTokenAmount = currentLegoVaultBalance - preLegoVaultBalance\n        assert extcall IERC20(_vaultToken).transfer(msg.sender, refundVaultTokenAmount, default_return_value=True) # dev: transfer failed\n        vaultTokenAmount -= refundVaultTokenAmount\n\n    usdValue: uint256 = staticcall Appraiser(miniAddys.appraiser).getUnderlyingUsdValue(vaultInfo.underlyingAsset, assetAmountReceived)\n    log CompoundV3Withdrawal(\n        sender = msg.sender,\n        asset = vaultInfo.underlyingAsset,\n        vaultToken = _vaultToken,\n        assetAmountReceived = assetAmountReceived,\n        usdValue = usdValue,\n        vaultTokenAmountBurned = vaultTokenAmount,\n        recipient = _recipient,\n    )\n    return vaultTokenAmount, vaultInfo.underlyingAsset, assetAmountReceived, usdValue\n\n\n# vault info on withdrawal\n\n\n@internal\ndef _getVaultInfoOnWithdrawal(_vaultAddr: address, _ledger: address, _legoBook: address) -> ls.VaultTokenInfo:\n    vaultInfo: ls.VaultTokenInfo = yld.vaultToAsset[_vaultAddr]\n    if vaultInfo.decimals == 0:\n        asset: address = staticcall CompoundV3(_vaultAddr).baseToken()\n        assert self._canRegisterVaultToken(asset, _vaultAddr) # dev: cannot register vault token\n        vaultInfo = self._registerVaultTokenLocally(asset, _vaultAddr)\n        self._registerVaultTokenGlobally(asset, _vaultAddr, vaultInfo.decimals, _ledger, _legoBook)\n    return vaultInfo\n\n\n#################\n# Claim Rewards #\n#################\n\n\n@external\ndef claimIncentives(\n    _user: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _proofs: DynArray[bytes32, MAX_PROOFS],\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    assert self._isAllowedToPerformAction(msg.sender) # dev: no perms\n    return self._claimIncentives(_user, _rewardToken, _rewardAmount, _proofs, _miniAddys)\n\n\n@external\ndef claimRewards(\n    _user: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _extraData: bytes32,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    assert self._isAllowedToPerformAction(msg.sender) # dev: no perms\n    return self._claimIncentives(_user, _rewardToken, _rewardAmount, [_extraData], _miniAddys)\n\n\n@internal\ndef _claimIncentives(\n    _user: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _proofs: DynArray[bytes32, MAX_PROOFS],\n    _miniAddys: ws.MiniAddys,\n) -> (uint256, uint256):\n    assert not yld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = yld._getMiniAddys(_miniAddys)\n    preBalance: uint256 = staticcall IERC20(_rewardToken).balanceOf(_user)\n\n    market: address = empty(address)\n    if len(_proofs) != 0:\n        data: bytes32 = _proofs[0]\n        market = convert(data, address)\n\n    compRewards: address = self.compoundRewards\n    assert compRewards != empty(address) # dev: no comp rewards addr set\n    if market != empty(address):\n        extcall CompoundV3Rewards(compRewards).claim(market, _user, True)\n    else:\n        self._hasClaimableOrShouldClaim(_user, True, compRewards)\n\n    rewardAmount: uint256 = staticcall IERC20(_rewardToken).balanceOf(_user) - preBalance\n    assert rewardAmount != 0 # dev: no rewards received\n    usdValue: uint256 = staticcall Appraiser(miniAddys.appraiser).getUnderlyingUsdValue(_rewardToken, rewardAmount)\n    return rewardAmount, usdValue\n\n\n# sadly, this is not a view function because of `getRewardOwed()`\n@external\ndef hasClaimableRewards(_user: address) -> bool:\n    return self._hasClaimableOrShouldClaim(_user, False, self.compoundRewards)\n\n\n@internal\ndef _hasClaimableOrShouldClaim(_user: address, _shouldClaim: bool, _compRewardsAddr: address) -> bool:\n    numAssets: uint256 = yld.numAssets\n    if numAssets == 0:\n        return False\n\n    for i: uint256 in range(1, numAssets, bound=max_value(uint256)):\n        asset: address = yld.assets[i]\n        comet: address = yld.assetOpportunities[asset][1] # only a single \"vault token\" (comet) per asset\n\n        rewardOwed: RewardOwed = extcall CompoundV3Rewards(_compRewardsAddr).getRewardOwed(comet, _user)\n        if rewardOwed.owed != 0:\n            if _shouldClaim:\n                extcall CompoundV3Rewards(_compRewardsAddr).claim(comet, _user, True)\n            else:\n                return True\n\n    return False\n\n\n# set rewards addr\n\n\n@external\ndef setCompRewardsAddr(_addr: address) -> bool:\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert _addr != empty(address) # dev: invalid addr\n    self.compoundRewards = _addr\n    log CompoundV3RewardsAddrSet(addr=_addr)\n    return True\n\n\n#########\n# Other #\n#########\n\n\n@external\ndef addPriceSnapshot(_vaultToken: address) -> bool:\n    # no need for snapshots\n    return False\n\n\n@view\n@external\ndef getAccessForLego(_user: address, _action: ws.ActionType) -> (address, String[64], uint256):\n    return empty(address), empty(String[64]), 0\n\n\n@external\ndef swapTokens(\n    _amountIn: uint256,\n    _minAmountOut: uint256,\n    _tokenPath: DynArray[address, MAX_TOKEN_PATH],\n    _poolPath: DynArray[address, MAX_TOKEN_PATH - 1],\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256):\n    return 0, 0, 0\n\n\n@external\ndef mintOrRedeemAsset(\n    _tokenIn: address,\n    _tokenOut: address,\n    _tokenInAmount: uint256,\n    _minAmountOut: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, bool, uint256):\n    return 0, 0, False, 0\n\n\n@external\ndef confirmMintOrRedeemAsset(\n    _tokenIn: address,\n    _tokenOut: address,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef addCollateral(\n    _asset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef removeCollateral(\n    _asset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef borrow(\n    _borrowAsset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef repayDebt(\n    _paymentAsset: address,\n    _paymentAmount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef addLiquidity(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _amountA: uint256,\n    _amountB: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _minLpAmount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (address, uint256, uint256, uint256, uint256):\n    return empty(address), 0, 0, 0, 0\n\n\n@external\ndef removeLiquidity(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpToken: address,\n    _lpAmount: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, uint256):\n    return 0, 0, 0, 0\n\n\n@external\ndef addLiquidityConcentrated(\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _tickLower: int24,\n    _tickUpper: int24,\n    _amountA: uint256,\n    _amountB: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, uint256, uint256):\n    return 0, 0, 0, 0, 0\n\n\n@external\ndef removeLiquidityConcentrated(\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _liqToRemove: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, bool, uint256):\n    return 0, 0, 0, False, 0",
            "sha256sum": "abf98fa0e8302d251e63ab35c9ffe7b12901d4ef9acc4ddc764d1cca602a0fd0"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/legos/yield/CompoundV3.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.3+commit.bff19ea2",
        "integrity": "11cfeddb1cc129741b2c29497bc9bb321d2f340960848ab93376b45e9d2f3aba"
      },
      "args": "00000000000000000000000044cf3c4f000dfd76a35d03298049d37be688d6f900000000000000000000000045939657d1ca34a8fa39a924b71d28fe8431e581000000000000000000000000123964802e6ababbe1bc9547d72ef1b69b00a6b10000000000000000000000006162df1b329e157479f8f1407e888260e0ec3d2b",
      "file": "contracts/legos/yield/CompoundV3.vy"
    },
    "Euler": {
      "address": "0xB854c1f42f9ccedB43Ef646c94c2512ecbB05BA1",
      "abi": [
        {
          "name": "EulerDeposit",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountDeposited",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultTokenAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "EulerWithdrawal",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultTokenAmountBurned",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "EulerRewardsAddrSet",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LegoPauseModified",
          "inputs": [
            {
              "name": "isPaused",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LegoFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "balance",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "SnapShotPriceConfigSet",
          "inputs": [
            {
              "name": "minSnapshotDelay",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "maxNumSnapshots",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "maxUpsideDeviation",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "staleTime",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetOpportunityAdded",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultAddr",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetOpportunityRemoved",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultAddr",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PricePerShareSnapShotAdded",
          "inputs": [
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "totalSupply",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "pricePerShare",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "lastAveragePricePerShare",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddys",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "undyToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "hatchery",
                  "type": "address"
                },
                {
                  "name": "lootDistributor",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                },
                {
                  "name": "walletBackpack",
                  "type": "address"
                },
                {
                  "name": "billing",
                  "type": "address"
                },
                {
                  "name": "vaultRegistry",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUndyHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isLegoAsset",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssetOpportunities",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isAssetOpportunity",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getNumLegoAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pause",
          "inputs": [
            {
              "name": "_shouldPause",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFundsMany",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_assets",
              "type": "address[]"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getWeightedPricePerShare",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLatestSnapshot",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_pricePerShare",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "totalSupply",
                  "type": "uint256"
                },
                {
                  "name": "pricePerShare",
                  "type": "uint256"
                },
                {
                  "name": "lastUpdate",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setSnapShotPriceConfig",
          "inputs": [
            {
              "name": "_config",
              "type": "tuple",
              "components": [
                {
                  "name": "minSnapshotDelay",
                  "type": "uint256"
                },
                {
                  "name": "maxNumSnapshots",
                  "type": "uint256"
                },
                {
                  "name": "maxUpsideDeviation",
                  "type": "uint256"
                },
                {
                  "name": "staleTime",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidPriceConfig",
          "inputs": [
            {
              "name": "_config",
              "type": "tuple",
              "components": [
                {
                  "name": "minSnapshotDelay",
                  "type": "uint256"
                },
                {
                  "name": "maxNumSnapshots",
                  "type": "uint256"
                },
                {
                  "name": "maxUpsideDeviation",
                  "type": "uint256"
                },
                {
                  "name": "staleTime",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "vaultToAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "underlyingAsset",
                  "type": "address"
                },
                {
                  "name": "decimals",
                  "type": "uint256"
                },
                {
                  "name": "lastAveragePricePerShare",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assetOpportunities",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAssetOpportunity",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssetOpportunities",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assets",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "snapShotData",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "lastSnapShot",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "totalSupply",
                      "type": "uint256"
                    },
                    {
                      "name": "pricePerShare",
                      "type": "uint256"
                    },
                    {
                      "name": "lastUpdate",
                      "type": "uint256"
                    }
                  ]
                },
                {
                  "name": "nextIndex",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "snapShots",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "totalSupply",
                  "type": "uint256"
                },
                {
                  "name": "pricePerShare",
                  "type": "uint256"
                },
                {
                  "name": "lastUpdate",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "snapShotPriceConfig",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "minSnapshotDelay",
                  "type": "uint256"
                },
                {
                  "name": "maxNumSnapshots",
                  "type": "uint256"
                },
                {
                  "name": "maxUpsideDeviation",
                  "type": "uint256"
                },
                {
                  "name": "staleTime",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isPaused",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasCapability",
          "inputs": [
            {
              "name": "_action",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRegistries",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isYieldLego",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isDexLego",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAsset",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingBalances",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenBalance",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAmount",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAmountSafe",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenBalance",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingData",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingData",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            },
            {
              "name": "_appraiser",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValueOfVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValueOfVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            },
            {
              "name": "_appraiser",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isRebasing",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPricePerShare",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPricePerShare",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_decimals",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getVaultTokenAmount",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_assetAmount",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalAssets",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalBorrows",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAvailLiquidity",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUtilizationRatio",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isEligibleForYieldBonus",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getWithdrawalFees",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canRegisterVaultToken",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "registerVaultTokenLocally",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "underlyingAsset",
                  "type": "address"
                },
                {
                  "name": "decimals",
                  "type": "uint256"
                },
                {
                  "name": "lastAveragePricePerShare",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "deregisterVaultTokenLocally",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addPriceSnapshot",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositForYield",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositForYield",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawFromYield",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawFromYield",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimIncentives",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_proofs",
              "type": "bytes32[]"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimIncentives",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_proofs",
              "type": "bytes32[]"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasClaimableRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setEulerRewardsAddr",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAccessForLego",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_action",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "string"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_tokenPath",
              "type": "address[]"
            },
            {
              "name": "_poolPath",
              "type": "address[]"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_tokenPath",
              "type": "address[]"
            },
            {
              "name": "_poolPath",
              "type": "address[]"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_tokenInAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_tokenInAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmMintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmMintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_borrowAsset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_borrowAsset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_paymentAsset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_paymentAsset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "eulerRewards",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "EULER_EVAULT_FACTORY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "EULER_EARN_FACTORY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "RIPE_REGISTRY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_undyHq",
              "type": "address"
            },
            {
              "name": "_evaultFactory",
              "type": "address"
            },
            {
              "name": "_earnFactory",
              "type": "address"
            },
            {
              "name": "_eulerRewardsAddr",
              "type": "address"
            },
            {
              "name": "_ripeRegistry",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "interfaces/WalletStructs.vyi": {
            "content": "# @version 0.4.3\n\nflag ActionType:\n    TRANSFER\n    EARN_DEPOSIT\n    EARN_WITHDRAW\n    EARN_REBALANCE\n    SWAP\n    MINT_REDEEM\n    CONFIRM_MINT_REDEEM\n    ADD_COLLATERAL\n    REMOVE_COLLATERAL\n    BORROW\n    REPAY_DEBT\n    REWARDS\n    ETH_TO_WETH\n    WETH_TO_ETH\n    ADD_LIQ\n    REMOVE_LIQ\n    ADD_LIQ_CONC\n    REMOVE_LIQ_CONC\n    PAY_CHEQUE\n\nstruct WalletAssetData:\n    assetBalance: uint256\n    usdValue: uint256\n    isYieldAsset: bool\n    lastPricePerShare: uint256\n\nstruct ActionData:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    billing: address\n    vaultRegistry: address\n    wallet: address\n    walletConfig: address\n    walletOwner: address\n    inEjectMode: bool\n    isFrozen: bool\n    lastTotalUsdValue: uint256\n    signer: address\n    isManager: bool\n    legoId: uint256\n    legoAddr: address\n    eth: address\n    weth: address\n\nstruct MiniAddys:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    appraiser: address",
            "sha256sum": "466493c129135c95470aaf70eeddc936632f7b0f813396e5a7ddc03bea9da518"
          },
          "interfaces/LegoPartner.vyi": {
            "content": "# @version 0.4.3\n\nfrom interfaces import WalletStructs as ws\n\nMAX_TOKEN_PATH: constant(uint256) = 5\nMAX_RECOVER_ASSETS: constant(uint256) = 20\nMAX_PROOFS: constant(uint256) = 25\n\n@external\ndef addLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _tickLower: int24, _tickUpper: int24, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef addLiquidity(_pool: address, _tokenA: address, _tokenB: address, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _minLpAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (address, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef removeLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _liqToRemove: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef removeLiquidity(_pool: address, _tokenA: address, _tokenB: address, _lpToken: address, _lpAmount: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef mintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _tokenInAmount: uint256, _minAmountOut: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef swapTokens(_amountIn: uint256, _minAmountOut: uint256, _tokenPath: DynArray[address, MAX_TOKEN_PATH], _poolPath: DynArray[address, MAX_TOKEN_PATH - 1], _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256):\n    ...\n\n@external\ndef depositForYield(_asset: address, _amount: uint256, _vaultAddr: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef withdrawFromYield(_vaultToken: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef confirmMintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef borrow(_borrowAsset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef repayDebt(_paymentAsset: address, _paymentAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef claimIncentives(_user: address, _rewardToken: address, _rewardAmount: uint256, _proofs: DynArray[bytes32, MAX_PROOFS], _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef removeCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef addCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@view\n@external\ndef getAccessForLego(_user: address, _action: ws.ActionType) -> (address, String[64], uint256):\n    ...\n\n@view\n@external\ndef hasCapability(_action: ws.ActionType) -> bool:\n    ...\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    ...\n\n@view\n@external\ndef isYieldLego() -> bool:\n    ...\n\n@view\n@external\ndef isDexLego() -> bool:\n    ...\n\n\n# common\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "f2afb7bd72d4301aea77bbe4177b7ae954ba6f6b76af363965993eb92ad0b715"
          },
          "interfaces/LegoStructs.vyi": {
            "content": "# @version 0.4.3\n\nstruct VaultTokenInfo:\n    underlyingAsset: address\n    decimals: uint256\n    lastAveragePricePerShare: uint256\n\nstruct SnapShotPriceConfig:\n    minSnapshotDelay: uint256\n    maxNumSnapshots: uint256\n    maxUpsideDeviation: uint256\n    staleTime: uint256\n\nstruct SingleSnapShot:\n    totalSupply: uint256\n    pricePerShare: uint256\n    lastUpdate: uint256\n\nstruct SnapShotData:\n    lastSnapShot: SingleSnapShot\n    nextIndex: uint256\n",
            "sha256sum": "8ae48be17d812d57fbd671bbf0593e8abf175ad0924e47c5997823cac19ec806"
          },
          "interfaces/YieldLego.vyi": {
            "content": "# @version 0.4.3\n\nfrom interfaces import LegoStructs as ls\n\n\n###################\n# Underlying Data #\n###################\n\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    ...\n\n\n@view\n@external\ndef getUnderlyingBalances(_vaultToken: address, _vaultTokenBalance: uint256) -> (uint256, uint256):\n    ...\n\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    ...\n\n\n@view\n@external\ndef getUnderlyingAmountSafe(_vaultToken: address, _vaultTokenBalance: uint256) -> uint256:\n    ...\n\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> (address, uint256, uint256):\n    ...\n\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> uint256:\n    ...\n\n\n###############\n# Other Utils #\n###############\n\n\n@view\n@external\ndef isRebasing() -> bool:\n    ...\n\n\n@view\n@external\ndef getPricePerShare(_vaultToken: address, _decimals: uint256 = 0) -> uint256:\n    ...\n\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef canRegisterVaultToken(_asset: address, _vaultToken: address) -> bool:\n    ...\n\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef getUtilizationRatio(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef getAvailLiquidity(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef isEligibleForYieldBonus(_asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef getWithdrawalFees(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    ...\n\n\n###################\n# Yield Lego Data #\n###################\n\n\n@view\n@external\ndef isLegoAsset(_asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, 40]:\n    ...\n\n\n@view\n@external\ndef getAssets() -> DynArray[address, 20]:\n    ...\n\n\n@view\n@external\ndef isAssetOpportunity(_asset: address, _vaultAddr: address) -> bool:\n    ...\n\n\n@view\n@external\ndef getNumLegoAssets() -> uint256:\n    ...\n\n\n@view\n@external\ndef assets(_index: uint256) -> address:\n    ...\n\n\n@view\n@external\ndef indexOfAsset(_asset: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef numAssets() -> uint256:\n    ...\n\n\n@view\n@external\ndef assetOpportunities(_asset: address, _index: uint256) -> address:\n    ...\n\n\n@view\n@external\ndef indexOfAssetOpportunity(_asset: address, _vaultAddr: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef numAssetOpportunities(_asset: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef vaultToAsset(_vaultAddr: address) -> ls.VaultTokenInfo:\n    ...\n\n\n# price snapshots\n\n\n@external\ndef addPriceSnapshot(_vaultToken: address) -> bool:\n    ...\n\n\n@view\n@external\ndef snapShotPriceConfig() -> ls.SnapShotPriceConfig:\n    ...\n\n\n@view\n@external\ndef snapShotData(_vaultToken: address) -> ls.SnapShotData:\n    ...\n\n\n@view\n@external\ndef snapShots(_vaultToken: address, _index: uint256) -> ls.SingleSnapShot:\n    ...\n\n\n@view\n@external\ndef getWeightedPricePerShare(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef getLatestSnapshot(_vaultToken: address, _pricePerShare: uint256) -> ls.SingleSnapShot:\n    ...\n\n\n@external\ndef setSnapShotPriceConfig(_config: ls.SnapShotPriceConfig):\n    ...\n",
            "sha256sum": "db91c139f6018f5218b389d08c8703bc16fb994aa948805dbfea27e072f382ec"
          },
          "contracts/modules/Addys.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\ninterface UndyHq:\n    def isValidAddr(_addr: address) -> bool: view\n    def getAddr(_regId: uint256) -> address: view\n    def undyToken() -> address: view\n\ninterface Switchboard:\n    def isSwitchboardAddr(_addr: address) -> bool: view\n\ninterface LegoBook:\n    def isLegoAddr(_addr: address) -> bool: view\n\nstruct Addys:\n    hq: address\n    undyToken: address\n    ledger: address\n    missionControl: address\n    legoBook: address\n    switchboard: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    walletBackpack: address\n    billing: address\n    vaultRegistry: address\n\n# hq\nUNDY_HQ_FOR_ADDYS: immutable(address)\n\n# core addys\nLEDGER_ID: constant(uint256) = 1\nMISSION_CONTROL_ID: constant(uint256) = 2\nLEGO_BOOK_ID: constant(uint256) = 3\nSWITCHBOARD_ID: constant(uint256) = 4\nHATCHERY_ID: constant(uint256) = 5\nLOOT_DISTRIBUTOR_ID: constant(uint256) = 6\nAPPRAISER_ID: constant(uint256) = 7\nWALLET_BACKPACK_ID: constant(uint256) = 8\nBILLING_ID: constant(uint256) = 9\nVAULT_REGISTRY_ID: constant(uint256) = 10\n\n\n@deploy\ndef __init__(_undyHq: address):\n    assert _undyHq != empty(address) # dev: invalid undy hq\n    UNDY_HQ_FOR_ADDYS = _undyHq\n\n\n########\n# Core #\n########\n\n\n@view\n@external\ndef getAddys() -> Addys:\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _getAddys(_addys: Addys = empty(Addys)) -> Addys:\n    if _addys.hq != empty(address):\n        return _addys\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _generateAddys() -> Addys:\n    hq: address = UNDY_HQ_FOR_ADDYS\n    return Addys(\n        hq = hq,\n        undyToken = staticcall UndyHq(hq).undyToken(),\n        ledger = staticcall UndyHq(hq).getAddr(LEDGER_ID),\n        missionControl = staticcall UndyHq(hq).getAddr(MISSION_CONTROL_ID),\n        legoBook = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID),\n        switchboard = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID),\n        hatchery = staticcall UndyHq(hq).getAddr(HATCHERY_ID),\n        lootDistributor = staticcall UndyHq(hq).getAddr(LOOT_DISTRIBUTOR_ID),\n        appraiser = staticcall UndyHq(hq).getAddr(APPRAISER_ID),\n        walletBackpack = staticcall UndyHq(hq).getAddr(WALLET_BACKPACK_ID),\n        billing = staticcall UndyHq(hq).getAddr(BILLING_ID),\n        vaultRegistry = staticcall UndyHq(hq).getAddr(VAULT_REGISTRY_ID),\n    )\n\n\n##########\n# Tokens #\n##########\n\n\n@view\n@internal\ndef _getUndyToken() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).undyToken()\n\n\n###########\n# Helpers #\n###########\n\n\n# undy hq\n\n\n@view\n@external\ndef getUndyHq() -> address:\n    return self._getUndyHq()\n\n\n@view\n@internal\ndef _getUndyHq() -> address:\n    return UNDY_HQ_FOR_ADDYS\n\n\n# utils\n\n\n@view\n@internal\ndef _isValidUndyAddr(_addr: address, _hq: address = empty(address)) -> bool:\n    hq: address = _hq\n    if _hq == empty(address):\n        hq = UNDY_HQ_FOR_ADDYS\n    \n    # core departments\n    if staticcall UndyHq(hq).isValidAddr(_addr):\n        return True\n\n    # lego book\n    legoBook: address = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID)\n    if legoBook != empty(address) and staticcall LegoBook(legoBook).isLegoAddr(_addr):\n        return True\n\n    # switchboard config\n    switchboard: address = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID)\n    if switchboard != empty(address) and staticcall Switchboard(switchboard).isSwitchboardAddr(_addr):\n        return True\n\n    return False\n\n\n@view\n@internal\ndef _isSwitchboardAddr(_addr: address) -> bool:\n    switchboard: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n    if switchboard == empty(address):\n        return False\n    return staticcall Switchboard(switchboard).isSwitchboardAddr(_addr)\n\n\n@view\n@internal\ndef _isLegoBookAddr(_addr: address) -> bool:\n    legoBook: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n    if legoBook == empty(address):\n        return False\n    return staticcall LegoBook(legoBook).isLegoAddr(_addr)\n\n\n###############\n# Departments #\n###############\n\n\n# ledger\n\n\n@view\n@internal\ndef _getLedgerId() -> uint256:\n    return LEDGER_ID\n\n\n@view\n@internal\ndef _getLedgerAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEDGER_ID)\n\n\n# mission control\n\n\n@view\n@internal\ndef _getMissionControlId() -> uint256:\n    return MISSION_CONTROL_ID\n\n\n@view\n@internal\ndef _getMissionControlAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(MISSION_CONTROL_ID)\n\n\n# lego book\n\n\n@view\n@internal\ndef _getLegoBookId() -> uint256:\n    return LEGO_BOOK_ID\n\n\n@view\n@internal\ndef _getLegoBookAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n\n\n# switchboard\n\n\n@view\n@internal\ndef _getSwitchboardId() -> uint256:\n    return SWITCHBOARD_ID\n\n\n@view\n@internal\ndef _getSwitchboardAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n\n\n# hatchery\n\n\n@view\n@internal\ndef _getHatcheryId() -> uint256:\n    return HATCHERY_ID\n\n\n@view\n@internal\ndef _getHatcheryAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(HATCHERY_ID)\n\n\n# loot distributor\n\n\n@view\n@internal\ndef _getLootDistributorId() -> uint256:\n    return LOOT_DISTRIBUTOR_ID\n\n\n@view\n@internal\ndef _getLootDistributorAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LOOT_DISTRIBUTOR_ID)\n\n\n# appraiser\n\n\n@view\n@internal\ndef _getAppraiserId() -> uint256:\n    return APPRAISER_ID\n\n\n@view\n@internal\ndef _getAppraiserAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(APPRAISER_ID)\n\n\n# wallet backpack\n\n\n@view\n@internal\ndef _getWalletBackpackId() -> uint256:\n    return WALLET_BACKPACK_ID\n\n\n@view\n@internal\ndef _getWalletBackpackAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(WALLET_BACKPACK_ID)\n\n\n# billing\n\n\n@view\n@internal\ndef _getBillingId() -> uint256:\n    return BILLING_ID\n\n\n@view\n@internal\ndef _getBillingAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(BILLING_ID)\n\n\n# vault registry\n\n\n@view\n@internal\ndef _getVaultRegistryId() -> uint256:\n    return VAULT_REGISTRY_ID\n\n\n@view\n@internal\ndef _getVaultRegistryAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(VAULT_REGISTRY_ID)",
            "sha256sum": "4df6b72db9bb417d1af81660175be1450cfb7b3575f3d17a5b8a130bff87b781"
          },
          "contracts/modules/YieldLegoData.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nuses: addys\n\nimport contracts.modules.Addys as addys\n\nfrom interfaces import WalletStructs as ws\nfrom interfaces import LegoStructs as ls\nfrom ethereum.ercs import IERC20\nfrom ethereum.ercs import IERC20Detailed\n\nevent AssetOpportunityAdded:\n    asset: indexed(address)\n    vaultAddr: indexed(address)\n\nevent AssetOpportunityRemoved:\n    asset: indexed(address)\n    vaultAddr: indexed(address)\n\nevent LegoPauseModified:\n    isPaused: bool\n\nevent LegoFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    balance: uint256\n\nevent PricePerShareSnapShotAdded:\n    vaultToken: indexed(address)\n    totalSupply: uint256\n    pricePerShare: uint256\n    lastAveragePricePerShare: uint256\n\nevent SnapShotPriceConfigSet:\n    minSnapshotDelay: uint256\n    maxNumSnapshots: uint256\n    maxUpsideDeviation: uint256\n    staleTime: uint256\n\n# core\nvaultToAsset: public(HashMap[address, ls.VaultTokenInfo]) # vault addr -> data\n\n# asset opportunities\nassetOpportunities: public(HashMap[address, HashMap[uint256, address]]) # asset -> index -> vault addr\nindexOfAssetOpportunity: public(HashMap[address, HashMap[address, uint256]]) # asset -> vault addr -> index\nnumAssetOpportunities: public(HashMap[address, uint256]) # asset -> number of opportunities\n\n# lego assets (iterable)\nassets: public(HashMap[uint256, address]) # index -> asset\nindexOfAsset: public(HashMap[address, uint256]) # asset -> index\nnumAssets: public(uint256) # num assets\n\n# price snapshots\nsnapShotData: public(HashMap[address, ls.SnapShotData]) # vault token -> data\nsnapShots: public(HashMap[address, HashMap[uint256, ls.SingleSnapShot]]) # vault token -> index -> snapshot\nsnapShotPriceConfig: public(ls.SnapShotPriceConfig) # config\n\nisPaused: public(bool)\n\nMAX_VAULTS: constant(uint256) = 40\nMAX_ASSETS: constant(uint256) = 20\nMAX_RECOVER_ASSETS: constant(uint256) = 20\nONE_DAY_SECONDS: constant(uint256) = 60 * 60 * 24\nONE_WEEK_SECONDS: constant(uint256) = ONE_DAY_SECONDS * 7\nHUNDRED_PERCENT: constant(uint256) = 100_00\n\n\n@deploy\ndef __init__(_shouldPause: bool):\n    self.isPaused = _shouldPause\n    self.numAssets = 1 # not using 0 index\n\n    # default snapshot price config\n    self.snapShotPriceConfig = ls.SnapShotPriceConfig(\n        minSnapshotDelay = 60 * 10, # 10 minutes\n        maxNumSnapshots = 20,\n        maxUpsideDeviation = 10_00, # 10%\n        staleTime = ONE_DAY_SECONDS, # 1 day\n    )\n\n\n#########\n# Views #\n#########\n\n\n# is lego asset\n\n\n@view\n@external\ndef isLegoAsset(_asset: address) -> bool:\n    return self._isLegoAsset(_asset)\n\n\n@view\n@internal\ndef _isLegoAsset(_asset: address) -> bool:\n    return self.indexOfAsset[_asset] != 0\n\n\n# vault opportunities\n\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, MAX_VAULTS]:\n    numOpportunities: uint256 = self.numAssetOpportunities[_asset]\n    if numOpportunities == 0:\n        return []\n    opportunities: DynArray[address, MAX_VAULTS] = []\n    for i: uint256 in range(1, numOpportunities, bound=MAX_VAULTS):\n        opportunities.append(self.assetOpportunities[_asset][i])\n    return opportunities\n\n\n# all assets registered\n\n\n@view\n@external\ndef getAssets() -> DynArray[address, MAX_ASSETS]:\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return []\n    assets: DynArray[address, MAX_ASSETS] = []\n    for i: uint256 in range(1, numAssets, bound=MAX_ASSETS):\n        assets.append(self.assets[i])\n    return assets\n\n\n################\n# Registration #\n################\n\n\n@view\n@external\ndef isAssetOpportunity(_asset: address, _vaultAddr: address) -> bool:\n    return self._isAssetOpportunity(_asset, _vaultAddr)\n\n\n@view\n@internal\ndef _isAssetOpportunity(_asset: address, _vaultAddr: address) -> bool:\n    return self.indexOfAssetOpportunity[_asset][_vaultAddr] != 0\n\n\n# add asset opportunity\n\n\n@internal\ndef _addAssetOpportunity(_asset: address, _vaultAddr: address) -> ls.VaultTokenInfo:\n    if self.indexOfAssetOpportunity[_asset][_vaultAddr] != 0:\n        return self.vaultToAsset[_vaultAddr]\n\n    if empty(address) in [_asset, _vaultAddr]:\n        return empty(ls.VaultTokenInfo)\n\n    # add asset opportunity\n    aid: uint256 = self.numAssetOpportunities[_asset]\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.assetOpportunities[_asset][aid] = _vaultAddr\n    self.indexOfAssetOpportunity[_asset][_vaultAddr] = aid\n    self.numAssetOpportunities[_asset] = aid + 1\n\n    # add mapping\n    vaultInfo: ls.VaultTokenInfo = ls.VaultTokenInfo(\n        underlyingAsset = _asset,\n        decimals = convert(staticcall IERC20Detailed(_vaultAddr).decimals(), uint256),\n        lastAveragePricePerShare = 0,\n    )\n    self.vaultToAsset[_vaultAddr] = vaultInfo\n\n    # add asset\n    self._addAsset(_asset)\n\n    log AssetOpportunityAdded(asset=_asset, vaultAddr=_vaultAddr)\n    return vaultInfo\n\n\n# remove asset opportunity\n\n\n@internal\ndef _removeAssetOpportunity(_asset: address, _vaultAddr: address):\n    numOpportunities: uint256 = self.numAssetOpportunities[_asset]\n    if numOpportunities == 0:\n        return\n\n    targetIndex: uint256 = self.indexOfAssetOpportunity[_asset][_vaultAddr]\n    if targetIndex == 0:\n        return\n\n    # update data\n    lastIndex: uint256 = numOpportunities - 1\n    self.numAssetOpportunities[_asset] = lastIndex\n    self.indexOfAssetOpportunity[_asset][_vaultAddr] = 0\n\n    self.vaultToAsset[_vaultAddr] = empty(ls.VaultTokenInfo)\n\n    # clear all snapshot data for the vault token to prevent contamination on re-add\n    self.snapShotData[_vaultAddr] = empty(ls.SnapShotData)\n\n    # clear all historical snapshots\n    config: ls.SnapShotPriceConfig = self.snapShotPriceConfig\n    for i: uint256 in range(config.maxNumSnapshots, bound=max_value(uint256)):\n        if i >= config.maxNumSnapshots:\n            break\n        self.snapShots[_vaultAddr][i] = empty(ls.SingleSnapShot)\n\n    # shift to replace the removed one\n    if targetIndex != lastIndex:\n        lastVaultAddr: address = self.assetOpportunities[_asset][lastIndex]\n        self.assetOpportunities[_asset][targetIndex] = lastVaultAddr\n        self.indexOfAssetOpportunity[_asset][lastVaultAddr] = targetIndex\n\n    # remove asset\n    if lastIndex <= 1:\n        self._removeAsset(_asset)\n\n    log AssetOpportunityRemoved(asset=_asset, vaultAddr=_vaultAddr)\n\n\n# add asset\n\n\n@internal\ndef _addAsset(_asset: address):\n    if self.indexOfAsset[_asset] != 0:\n        return\n\n    aid: uint256 = self.numAssets\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.assets[aid] = _asset\n    self.indexOfAsset[_asset] = aid\n    self.numAssets = aid + 1\n\n\n# remove asset\n\n\n@internal\ndef _removeAsset(_asset: address):\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return\n\n    targetIndex: uint256 = self.indexOfAsset[_asset]\n    if targetIndex == 0:\n        return\n\n    # update data\n    lastIndex: uint256 = numAssets - 1\n    self.numAssets = lastIndex\n    self.indexOfAsset[_asset] = 0\n\n    # shift to replace the removed one\n    if targetIndex != lastIndex:\n        lastAsset: address = self.assets[lastIndex]\n        self.assets[targetIndex] = lastAsset\n        self.indexOfAsset[lastAsset] = targetIndex\n\n\n# num lego assets (true number, use `numAssets` for iteration)\n\n\n@view\n@external\ndef getNumLegoAssets() -> uint256:\n    return self._getNumLegoAssets()\n\n\n@view\n@internal\ndef _getNumLegoAssets() -> uint256:\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return 0\n    return numAssets - 1\n\n\n###########\n# General #\n###########\n\n\n# fill mini addys\n\n\n@view\n@internal\ndef _getMiniAddys(_miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> ws.MiniAddys:\n    if _miniAddys.ledger != empty(address):\n        return _miniAddys\n    return ws.MiniAddys(\n        ledger = addys._getLedgerAddr(),\n        missionControl = addys._getMissionControlAddr(),\n        legoBook = addys._getLegoBookAddr(),\n        appraiser = addys._getAppraiserAddr(),\n    )\n\n\n# activate\n\n\n@external\ndef pause(_shouldPause: bool):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert _shouldPause != self.isPaused # dev: no change\n    self.isPaused = _shouldPause\n    log LegoPauseModified(isPaused=_shouldPause)\n\n\n# recover funds\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    self._recoverFunds(_recipient, _asset)\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, MAX_RECOVER_ASSETS]):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    for a: address in _assets:\n        self._recoverFunds(_recipient, a)\n\n\n@internal\ndef _recoverFunds(_recipient: address, _asset: address):\n    assert empty(address) not in [_recipient, _asset] # dev: invalid recipient or asset\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    assert balance != 0 # dev: nothing to recover\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log LegoFundsRecovered(asset=_asset, recipient=_recipient, balance=balance)\n\n\n###################\n# Price Snapshots #\n###################\n\n\n# add price snapshot\n\n\n@internal\ndef _addPriceSnapshot(_vaultToken: address, _pricePerShare: uint256, _vaultTokenDecimals: uint256) -> bool:\n    config: ls.SnapShotPriceConfig = self.snapShotPriceConfig\n    if config.maxNumSnapshots == 0:\n        return False\n\n    data: ls.SnapShotData = self.snapShotData[_vaultToken]\n\n    # already have snapshot for this time\n    if data.lastSnapShot.lastUpdate == block.timestamp:\n        return False\n\n    # check if snapshot is too recent\n    if data.lastSnapShot.lastUpdate + config.minSnapshotDelay > block.timestamp:\n        return False\n\n    # create and store new snapshot\n    newSnapshot: ls.SingleSnapShot = self._getLatestSnapshot(_vaultToken, _pricePerShare, _vaultTokenDecimals, data.lastSnapShot, config)\n    data.lastSnapShot = newSnapshot\n    self.snapShots[_vaultToken][data.nextIndex] = newSnapshot\n\n    # update index\n    data.nextIndex += 1\n    if data.nextIndex >= config.maxNumSnapshots:\n        data.nextIndex = 0\n\n    # save snap shot data\n    self.snapShotData[_vaultToken] = data\n\n    # update cached weighted average price per share\n    lastAveragePricePerShare: uint256 = self._getWeightedPricePerShare(_vaultToken, _pricePerShare)\n    self.vaultToAsset[_vaultToken].lastAveragePricePerShare = lastAveragePricePerShare\n\n    log PricePerShareSnapShotAdded(\n        vaultToken = _vaultToken,\n        totalSupply = newSnapshot.totalSupply,\n        pricePerShare = newSnapshot.pricePerShare,\n        lastAveragePricePerShare = lastAveragePricePerShare,\n    )\n    return True\n\n\n# weighted price per share\n\n\n@view\n@external\ndef getWeightedPricePerShare(_vaultToken: address) -> uint256:\n    data: ls.SnapShotData = self.snapShotData[_vaultToken]\n    return self._getWeightedPricePerShare(_vaultToken, data.lastSnapShot.pricePerShare)\n\n\n@view\n@internal\ndef _getWeightedPricePerShare(_vaultToken: address, _lastPricePerShare: uint256) -> uint256:\n    config: ls.SnapShotPriceConfig = self.snapShotPriceConfig\n    if config.maxNumSnapshots == 0:\n        return 0\n\n    # calculate weighted average price using all valid snapshots\n    numerator: uint256 = 0\n    denominator: uint256 = 0\n    for i: uint256 in range(config.maxNumSnapshots, bound=max_value(uint256)):\n\n        snapShot: ls.SingleSnapShot = self.snapShots[_vaultToken][i]\n        if snapShot.pricePerShare == 0 or snapShot.totalSupply == 0 or snapShot.lastUpdate == 0:\n            continue\n\n        # too stale, skip\n        if config.staleTime != 0 and block.timestamp > snapShot.lastUpdate + config.staleTime:\n            continue\n\n        numerator += (snapShot.totalSupply * snapShot.pricePerShare)\n        denominator += snapShot.totalSupply\n\n    # weighted price per share\n    weightedPricePerShare: uint256 = 0\n    if numerator != 0:\n        weightedPricePerShare = numerator // denominator\n    else:\n        weightedPricePerShare = _lastPricePerShare\n\n    return weightedPricePerShare\n\n\n# latest snapshot\n\n\n@view\n@external\ndef getLatestSnapshot(_vaultToken: address, _pricePerShare: uint256) -> ls.SingleSnapShot:\n    data: ls.SnapShotData = self.snapShotData[_vaultToken]\n    config: ls.SnapShotPriceConfig = self.snapShotPriceConfig\n    vaultTokenDecimals: uint256 = self.vaultToAsset[_vaultToken].decimals\n    return self._getLatestSnapshot(_vaultToken, _pricePerShare, vaultTokenDecimals, data.lastSnapShot, config)\n\n\n@view\n@internal\ndef _getLatestSnapshot(\n    _vaultToken: address,\n    _pricePerShare: uint256,\n    _vaultTokenDecimals: uint256,\n    _lastSnapShot: ls.SingleSnapShot,\n    _config: ls.SnapShotPriceConfig,\n) -> ls.SingleSnapShot:\n\n    # total supply (adjusted)\n    totalSupply: uint256 = staticcall IERC20(_vaultToken).totalSupply() // (10 ** _vaultTokenDecimals)\n    if totalSupply == 0:\n        totalSupply = 1\n\n    # throttle upside (extra safety check)\n    pricePerShare: uint256 = self._throttleUpside(_pricePerShare, _lastSnapShot.pricePerShare, _config.maxUpsideDeviation)\n\n    return ls.SingleSnapShot(\n        totalSupply = totalSupply,\n        pricePerShare = pricePerShare,\n        lastUpdate = block.timestamp,\n    )\n\n\n@view\n@internal\ndef _throttleUpside(_newValue: uint256, _prevValue: uint256, _maxUpside: uint256) -> uint256:\n    if _maxUpside == 0 or _prevValue == 0 or _newValue == 0:\n        return _newValue\n    maxPricePerShare: uint256 = _prevValue + (_prevValue * _maxUpside // HUNDRED_PERCENT)\n    return min(_newValue, maxPricePerShare)\n\n\n# snapshot price config\n\n\n@external\ndef setSnapShotPriceConfig(_config: ls.SnapShotPriceConfig):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert self._isValidPriceConfig(_config) # dev: invalid config\n    self.snapShotPriceConfig = _config\n    log SnapShotPriceConfigSet(\n        minSnapshotDelay=_config.minSnapshotDelay,\n        maxNumSnapshots=_config.maxNumSnapshots,\n        maxUpsideDeviation=_config.maxUpsideDeviation,\n        staleTime=_config.staleTime\n    )\n\n\n@view\n@external\ndef isValidPriceConfig(_config: ls.SnapShotPriceConfig) -> bool:\n    return self._isValidPriceConfig(_config)\n\n\n@view\n@internal\ndef _isValidPriceConfig(_config: ls.SnapShotPriceConfig) -> bool:\n    if _config.minSnapshotDelay > ONE_WEEK_SECONDS:\n        return False\n    if _config.maxNumSnapshots == 0 or _config.maxNumSnapshots > 25:\n        return False\n    if _config.maxUpsideDeviation > HUNDRED_PERCENT:\n        return False\n    return _config.staleTime < ONE_WEEK_SECONDS",
            "sha256sum": "50440c96dc8a7af22e7ad927bb6d3e308f137d5d3632e633e084b05510c94c28"
          },
          "contracts/legos/yield/Euler.vy": {
            "content": "#     __   __ ___ _______ ___     ______       ___     _______ _______ _______ \n#    |  | |  |   |       |   |   |      |     |   |   |       |       |       |\n#    |  |_|  |   |    ___|   |   |  _    |    |   |   |    ___|    ___|   _   |\n#    |       |   |   |___|   |   | | |   |    |   |   |   |___|   | __|  | |  |\n#    |_     _|   |    ___|   |___| |_|   |    |   |___|    ___|   ||  |  |_|  |\n#      |   | |   |   |___|       |       |    |       |   |___|   |_| |       |\n#      |___| |___|_______|_______|______|     |_______|_______|_______|_______|\n#                                                                       \n#     \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n#     \u2551  ** Euler Lego **                       \u2551\n#     \u2551  Integration with Euler Protocol.       \u2551\n#     \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n#\n#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nimplements: Lego\nimplements: YieldLego\n\nexports: addys.__interface__\nexports: yld.__interface__\n\ninitializes: addys\ninitializes: yld[addys := addys]\n\nfrom interfaces import LegoPartner as Lego\nfrom interfaces import YieldLego as YieldLego\nfrom interfaces import WalletStructs as ws\nfrom interfaces import LegoStructs as ls\n\nimport contracts.modules.Addys as addys\nimport contracts.modules.YieldLegoData as yld\n\nfrom ethereum.ercs import IERC20\nfrom ethereum.ercs import IERC4626\nfrom ethereum.ercs import IERC20Detailed\n\ninterface Ledger:\n    def setVaultToken(_vaultToken: address, _legoId: uint256, _underlyingAsset: address, _decimals: uint256, _isRebasing: bool): nonpayable\n    def isRegisteredVaultToken(_vaultToken: address) -> bool: view\n    def isUserWallet(_user: address) -> bool: view\n\ninterface EulerRewardsDistributor:\n    def claim(_users: DynArray[address, 10], _rewardTokens: DynArray[address, 10], _claimAmounts: DynArray[uint256, 10], _proofs: DynArray[DynArray[bytes32, MAX_PROOFS], 10]): nonpayable\n    def operators(_user: address, _operator: address) -> bool: view\n\ninterface Registry:\n    def getRegId(_addr: address) -> uint256: view\n    def isValidAddr(_addr: address) -> bool: view\n\ninterface Appraiser:\n    def getUnderlyingUsdValue(_asset: address, _amount: uint256) -> uint256: view\n\ninterface EulerEarnFactory:\n    def isValidDeployment(_vault: address) -> bool: view\n\ninterface VaultRegistry:\n    def isEarnVault(_vaultAddr: address) -> bool: view\n\ninterface EulerEvaultFactory:\n    def isProxy(_vault: address) -> bool: view\n\ninterface EulerVault:\n    def totalBorrows() -> uint256: view\n\nevent EulerDeposit:\n    sender: indexed(address)\n    asset: indexed(address)\n    vaultToken: indexed(address)\n    assetAmountDeposited: uint256\n    usdValue: uint256\n    vaultTokenAmountReceived: uint256\n    recipient: address\n\nevent EulerWithdrawal:\n    sender: indexed(address)\n    asset: indexed(address)\n    vaultToken: indexed(address)\n    assetAmountReceived: uint256\n    usdValue: uint256\n    vaultTokenAmountBurned: uint256\n    recipient: address\n\nevent EulerRewardsAddrSet:\n    addr: address\n\n# rewards contract\neulerRewards: public(address)\n\n# euler\nEULER_EVAULT_FACTORY: public(immutable(address))\nEULER_EARN_FACTORY: public(immutable(address))\nRIPE_REGISTRY: public(immutable(address))\n\nMAX_TOKEN_PATH: constant(uint256) = 5\nMAX_PROOFS: constant(uint256) = 25\nHUNDRED_PERCENT: constant(uint256) = 100_00\nLEGO_ACCESS_ABI: constant(String[64]) = \"toggleOperator(address,address)\"\n\n\n@deploy\ndef __init__(\n    _undyHq: address,\n    _evaultFactory: address,\n    _earnFactory: address,\n    _eulerRewardsAddr: address,\n    _ripeRegistry: address,\n):\n    addys.__init__(_undyHq)\n    yld.__init__(False)\n\n    assert empty(address) not in [_evaultFactory, _earnFactory, _ripeRegistry] # dev: invalid addrs\n    EULER_EVAULT_FACTORY = _evaultFactory\n    EULER_EARN_FACTORY = _earnFactory\n    self.eulerRewards = _eulerRewardsAddr\n\n    RIPE_REGISTRY = _ripeRegistry\n\n\n@view\n@external\ndef hasCapability(_action: ws.ActionType) -> bool:\n    return _action in (\n        ws.ActionType.EARN_DEPOSIT | \n        ws.ActionType.EARN_WITHDRAW |\n        ws.ActionType.REWARDS\n    )\n\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    return [EULER_EVAULT_FACTORY, EULER_EARN_FACTORY]\n\n\n@view\n@external\ndef isYieldLego() -> bool:\n    return True\n\n\n@view\n@external\ndef isDexLego() -> bool:\n    return False\n\n\n###################\n# Underlying Data #\n###################\n\n\n# underlying asset\n\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    return self._getUnderlyingAsset(_vaultToken)\n\n\n@view\n@internal\ndef _getUnderlyingAsset(_vaultToken: address) -> address:\n    asset: address = yld.vaultToAsset[_vaultToken].underlyingAsset\n    if asset != empty(address):\n        return asset\n    return staticcall IERC4626(_vaultToken).asset()\n\n\n# underlying balances (both true and safe)\n\n\n@view\n@external\ndef getUnderlyingBalances(_vaultToken: address, _vaultTokenBalance: uint256) -> (uint256, uint256):\n    if _vaultTokenBalance == 0:\n        return 0, 0\n\n    trueUnderlying: uint256 = self._getUnderlyingAmount(_vaultToken, _vaultTokenBalance)\n    safeUnderlying: uint256 = self._getUnderlyingAmountSafe(_vaultToken, _vaultTokenBalance)\n    if safeUnderlying == 0:\n        safeUnderlying = trueUnderlying\n\n    return trueUnderlying, min(trueUnderlying, safeUnderlying)\n\n\n# underlying amount (true)\n\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    return self._getUnderlyingAmount(_vaultToken, _vaultTokenAmount)\n\n\n@view\n@internal\ndef _getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    return staticcall IERC4626(_vaultToken).previewRedeem(_vaultTokenAmount)\n\n\n# underlying amount (safe)\n\n\n@view\n@external\ndef getUnderlyingAmountSafe(_vaultToken: address, _vaultTokenBalance: uint256) -> uint256:\n    return self._getUnderlyingAmountSafe(_vaultToken, _vaultTokenBalance)\n\n\n@view\n@internal\ndef _getUnderlyingAmountSafe(_vaultToken: address, _vaultTokenBalance: uint256) -> uint256:\n    vaultInfo: ls.VaultTokenInfo = yld.vaultToAsset[_vaultToken]\n    if vaultInfo.decimals == 0:\n        return 0 # not registered\n\n    # safe underlying amount (using cached weighted average from snapshots)\n    return _vaultTokenBalance * vaultInfo.lastAveragePricePerShare // (10 ** vaultInfo.decimals)\n\n\n# underlying data (combined)\n\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> (address, uint256, uint256):\n    return self._getUnderlyingData(_vaultToken, _vaultTokenAmount, _appraiser)\n\n\n@view\n@internal\ndef _getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address) -> (address, uint256, uint256):\n    asset: address = self._getUnderlyingAsset(_vaultToken)\n    if asset == empty(address):\n        return empty(address), 0, 0 # invalid vault token\n    underlyingAmount: uint256 = self._getUnderlyingAmount(_vaultToken, _vaultTokenAmount)\n    usdValue: uint256 = self._getUsdValue(asset, underlyingAmount, _appraiser)\n    return asset, underlyingAmount, usdValue\n\n\n# usd value\n\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> uint256:\n    return self._getUsdValueOfVaultToken(_vaultToken, _vaultTokenAmount, _appraiser)\n\n\n@view\n@internal\ndef _getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address) -> uint256:\n    return self._getUnderlyingData(_vaultToken, _vaultTokenAmount, _appraiser)[2]\n\n\n@view\n@internal\ndef _getUsdValue(_asset: address, _amount: uint256, _appraiser: address) -> uint256:\n    appraiser: address = _appraiser\n    if _appraiser == empty(address):\n        appraiser = addys._getAppraiserAddr()\n    return staticcall Appraiser(appraiser).getUnderlyingUsdValue(_asset, _amount)\n\n\n###############\n# Other Utils #\n###############\n\n\n# basics\n\n\n@view\n@external\ndef isRebasing() -> bool:\n    return self._isRebasing()\n\n\n@view\n@internal\ndef _isRebasing() -> bool:\n    return False\n\n\n# price per share\n\n\n@view\n@external\ndef getPricePerShare(_vaultToken: address, _decimals: uint256 = 0) -> uint256:\n    decimals: uint256 = _decimals\n    if decimals == 0:\n        decimals = yld.vaultToAsset[_vaultToken].decimals\n    if decimals == 0:\n        decimals = convert(staticcall IERC20Detailed(_vaultToken).decimals(), uint256)\n    return self._getPricePerShare(_vaultToken, decimals)\n\n\n@view\n@internal\ndef _getPricePerShare(_vaultToken: address, _decimals: uint256) -> uint256:\n    return staticcall IERC4626(_vaultToken).previewRedeem(10 ** _decimals)\n\n\n# vault token amount\n\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    return staticcall IERC4626(_vaultToken).convertToShares(_assetAmount)\n\n\n# total assets\n\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    return self._totalAssets(_vaultToken)\n\n\n@view\n@internal\ndef _totalAssets(_vaultToken: address) -> uint256:\n    return staticcall IERC4626(_vaultToken).totalAssets()\n\n\n# total borrows\n\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    return self._totalBorrows(_vaultToken)\n\n\n@view\n@internal\ndef _totalBorrows(_vaultToken: address) -> uint256:\n    return staticcall EulerVault(_vaultToken).totalBorrows()\n\n\n# avail liquidity\n\n\n@view\n@external\ndef getAvailLiquidity(_vaultToken: address) -> uint256:\n    totalAssets: uint256 = self._totalAssets(_vaultToken)\n    totalBorrows: uint256 = self._totalBorrows(_vaultToken)\n    if totalAssets <= totalBorrows:\n        return 0\n    return totalAssets - totalBorrows\n\n\n# utilization\n\n\n@view\n@external\ndef getUtilizationRatio(_vaultToken: address) -> uint256:\n    totalAssets: uint256 = self._totalAssets(_vaultToken)\n    if totalAssets == 0:\n        return 0\n    totalBorrows: uint256 = self._totalBorrows(_vaultToken)\n    return totalBorrows * HUNDRED_PERCENT // totalAssets\n\n\n# extras\n\n\n@view\n@external\ndef isEligibleForYieldBonus(_asset: address) -> bool:\n    return False\n\n\n@view\n@external\ndef getWithdrawalFees(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    return 0\n\n\n################\n# Registration #\n################\n\n\n# can vault be registered\n\n\n@view\n@external\ndef canRegisterVaultToken(_asset: address, _vaultToken: address) -> bool:\n    return self._canRegisterVaultToken(_asset, _vaultToken)\n\n\n@view\n@internal\ndef _canRegisterVaultToken(_asset: address, _vaultToken: address) -> bool:\n    if empty(address) in [_asset, _vaultToken]:\n        return False\n    if staticcall IERC4626(_vaultToken).asset() != _asset:\n        return False\n    return staticcall EulerEvaultFactory(EULER_EVAULT_FACTORY).isProxy(_vaultToken) or staticcall EulerEarnFactory(EULER_EARN_FACTORY).isValidDeployment(_vaultToken)\n\n\n# register vault token locally\n\n\n@external\ndef registerVaultTokenLocally(_asset: address, _vaultAddr: address) -> ls.VaultTokenInfo:\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert self._canRegisterVaultToken(_asset, _vaultAddr) # dev: cannot register vault token\n    assert not yld._isAssetOpportunity(_asset, _vaultAddr) # dev: already registered\n    vaultInfo: ls.VaultTokenInfo = self._registerVaultTokenLocally(_asset, _vaultAddr)\n    self._registerVaultTokenGlobally(_asset, _vaultAddr, vaultInfo.decimals, addys._getLedgerAddr(), addys._getLegoBookAddr())\n    return vaultInfo\n\n\n@internal\ndef _registerVaultTokenLocally(_asset: address, _vaultAddr: address) -> ls.VaultTokenInfo:\n    assert extcall IERC20(_asset).approve(_vaultAddr, max_value(uint256), default_return_value=True) # dev: max approval failed\n    vaultInfo: ls.VaultTokenInfo = yld._addAssetOpportunity(_asset, _vaultAddr)\n    assert vaultInfo.decimals != 0 # dev: invalid vault token\n    return vaultInfo\n\n\n# remove vault token locally\n\n\n@external\ndef deregisterVaultTokenLocally(_asset: address, _vaultAddr: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert yld._isAssetOpportunity(_asset, _vaultAddr) # dev: already registered\n    self._deregisterVaultTokenLocally(_asset, _vaultAddr)\n\n\n@internal\ndef _deregisterVaultTokenLocally(_asset: address, _vaultAddr: address):\n    assert extcall IERC20(_asset).approve(_vaultAddr, 0, default_return_value=True) # dev: max approval failed\n    yld._removeAssetOpportunity(_asset, _vaultAddr)\n\n\n# ledger registration\n\n\n@internal\ndef _registerVaultTokenGlobally(_underlyingAsset: address, _vaultToken: address, _decimals: uint256, _ledger: address, _legoBook: address):\n    if not staticcall Ledger(_ledger).isRegisteredVaultToken(_vaultToken):\n        legoId: uint256 = staticcall Registry(_legoBook).getRegId(self)\n        extcall Ledger(_ledger).setVaultToken(_vaultToken, legoId, _underlyingAsset, _decimals, self._isRebasing())\n\n\n#################\n# Yield Actions #\n#################\n\n\n# access control\n\n\n@view\n@internal\ndef _isAllowedToPerformAction(_caller: address) -> bool:\n    # NOTE: important to not trust `_miniAddys` here, that's why getting ledger and vault registry from addys\n    if staticcall VaultRegistry(addys._getVaultRegistryAddr()).isEarnVault(_caller):\n        return True\n    if staticcall Ledger(addys._getLedgerAddr()).isUserWallet(_caller):\n        return True\n    return staticcall Registry(RIPE_REGISTRY).isValidAddr(_caller) # Ripe Endaoment is allowed\n\n\n# add price snapshot\n\n\n@external\ndef addPriceSnapshot(_vaultToken: address) -> bool:\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    vaultInfo: ls.VaultTokenInfo = yld.vaultToAsset[_vaultToken]\n    assert vaultInfo.decimals != 0 # dev: not registered\n    pricePerShare: uint256 = self._getPricePerShare(_vaultToken, vaultInfo.decimals)\n    return yld._addPriceSnapshot(_vaultToken, pricePerShare, vaultInfo.decimals)\n\n\n# deposit\n\n\n@external\ndef depositForYield(\n    _asset: address,\n    _amount: uint256,\n    _vaultAddr: address,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, address, uint256, uint256):\n    assert self._isAllowedToPerformAction(msg.sender) # dev: no perms\n    assert not yld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = yld._getMiniAddys(_miniAddys)\n    vaultInfo: ls.VaultTokenInfo = self._getVaultInfoOnDeposit(_asset, _vaultAddr, miniAddys.ledger, miniAddys.legoBook)\n\n    # pre balances\n    preLegoBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n\n    # transfer deposit asset to this contract\n    depositAmount: uint256 = min(_amount, staticcall IERC20(_asset).balanceOf(msg.sender))\n    assert depositAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_asset).transferFrom(msg.sender, self, depositAmount, default_return_value=True) # dev: transfer failed\n\n    # deposit assets into lego partner\n    vaultTokenAmountReceived: uint256 = extcall IERC4626(_vaultAddr).deposit(depositAmount, _recipient)\n    assert vaultTokenAmountReceived != 0 # dev: no vault tokens received\n\n    # refund if full deposit didn't get through\n    currentLegoBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    refundAssetAmount: uint256 = 0\n    if currentLegoBalance > preLegoBalance:\n        refundAssetAmount = currentLegoBalance - preLegoBalance\n        assert extcall IERC20(_asset).transfer(msg.sender, refundAssetAmount, default_return_value=True) # dev: transfer failed\n        depositAmount -= refundAssetAmount\n\n    usdValue: uint256 = staticcall Appraiser(miniAddys.appraiser).getUnderlyingUsdValue(_asset, depositAmount)\n    log EulerDeposit(\n        sender = msg.sender,\n        asset = _asset,\n        vaultToken = _vaultAddr,\n        assetAmountDeposited = depositAmount,\n        usdValue = usdValue,\n        vaultTokenAmountReceived = vaultTokenAmountReceived,\n        recipient = _recipient,\n    )\n\n    # add price snapshot\n    pricePerShare: uint256 = self._getPricePerShare(_vaultAddr, vaultInfo.decimals)\n    yld._addPriceSnapshot(_vaultAddr, pricePerShare, vaultInfo.decimals)\n\n    return depositAmount, _vaultAddr, vaultTokenAmountReceived, usdValue\n\n\n# vault info on deposit\n\n\n@internal\ndef _getVaultInfoOnDeposit(_asset: address, _vaultAddr: address, _ledger: address, _legoBook: address) -> ls.VaultTokenInfo:\n    vaultInfo: ls.VaultTokenInfo = yld.vaultToAsset[_vaultAddr]\n    if vaultInfo.decimals == 0:\n        assert self._canRegisterVaultToken(_asset, _vaultAddr) # dev: cannot register vault token\n        vaultInfo = self._registerVaultTokenLocally(_asset, _vaultAddr)\n        self._registerVaultTokenGlobally(_asset, _vaultAddr, vaultInfo.decimals, _ledger, _legoBook)\n    else:\n        assert vaultInfo.underlyingAsset == _asset # dev: asset mismatch\n    return vaultInfo\n\n\n# withdraw\n\n\n@external\ndef withdrawFromYield(\n    _vaultToken: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, address, uint256, uint256):\n    assert self._isAllowedToPerformAction(msg.sender) # dev: no perms\n    assert not yld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = yld._getMiniAddys(_miniAddys)\n    vaultInfo: ls.VaultTokenInfo = self._getVaultInfoOnWithdrawal(_vaultToken, miniAddys.ledger, miniAddys.legoBook)\n\n    # pre balances\n    preLegoVaultBalance: uint256 = staticcall IERC20(_vaultToken).balanceOf(self)\n\n    # transfer vaults tokens to this contract\n    vaultTokenAmount: uint256 = min(_amount, staticcall IERC20(_vaultToken).balanceOf(msg.sender))\n    assert vaultTokenAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_vaultToken).transferFrom(msg.sender, self, vaultTokenAmount, default_return_value=True) # dev: transfer failed\n\n    # withdraw assets from lego partner\n    assetAmountReceived: uint256 = extcall IERC4626(_vaultToken).redeem(vaultTokenAmount, _recipient, self)\n    assert assetAmountReceived != 0 # dev: no asset amount received\n\n    # refund if full withdrawal didn't happen\n    currentLegoVaultBalance: uint256 = staticcall IERC20(_vaultToken).balanceOf(self)\n    refundVaultTokenAmount: uint256 = 0\n    if currentLegoVaultBalance > preLegoVaultBalance:\n        refundVaultTokenAmount = currentLegoVaultBalance - preLegoVaultBalance\n        assert extcall IERC20(_vaultToken).transfer(msg.sender, refundVaultTokenAmount, default_return_value=True) # dev: transfer failed\n        vaultTokenAmount -= refundVaultTokenAmount\n\n    usdValue: uint256 = staticcall Appraiser(miniAddys.appraiser).getUnderlyingUsdValue(vaultInfo.underlyingAsset, assetAmountReceived)\n    log EulerWithdrawal(\n        sender = msg.sender,\n        asset = vaultInfo.underlyingAsset,\n        vaultToken = _vaultToken,\n        assetAmountReceived = assetAmountReceived,\n        usdValue = usdValue,\n        vaultTokenAmountBurned = vaultTokenAmount,\n        recipient = _recipient,\n    )\n\n    # add price snapshot\n    pricePerShare: uint256 = self._getPricePerShare(_vaultToken, vaultInfo.decimals)\n    yld._addPriceSnapshot(_vaultToken, pricePerShare, vaultInfo.decimals)\n\n    return vaultTokenAmount, vaultInfo.underlyingAsset, assetAmountReceived, usdValue\n\n\n# vault info on withdrawal\n\n\n@internal\ndef _getVaultInfoOnWithdrawal(_vaultAddr: address, _ledger: address, _legoBook: address) -> ls.VaultTokenInfo:\n    vaultInfo: ls.VaultTokenInfo = yld.vaultToAsset[_vaultAddr]\n    if vaultInfo.decimals == 0:\n        asset: address = staticcall IERC4626(_vaultAddr).asset()\n        assert self._canRegisterVaultToken(asset, _vaultAddr) # dev: cannot register vault token\n        vaultInfo = self._registerVaultTokenLocally(asset, _vaultAddr)\n        self._registerVaultTokenGlobally(asset, _vaultAddr, vaultInfo.decimals, _ledger, _legoBook)\n    return vaultInfo\n\n\n#################\n# Claim Rewards #\n#################\n\n\n@external\ndef claimIncentives(\n    _user: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _proofs: DynArray[bytes32, MAX_PROOFS],\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    assert self._isAllowedToPerformAction(msg.sender) # dev: no perms\n    assert not yld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = yld._getMiniAddys(_miniAddys)\n    preBalance: uint256 = staticcall IERC20(_rewardToken).balanceOf(_user)\n\n    eulerRewards: address = self.eulerRewards\n    assert eulerRewards != empty(address) # dev: no eulerRewards rewards addr set\n    extcall EulerRewardsDistributor(eulerRewards).claim([_user], [_rewardToken], [_rewardAmount], [_proofs])\n    rewardAmount: uint256 = staticcall IERC20(_rewardToken).balanceOf(_user) - preBalance\n    assert rewardAmount != 0 # dev: no rewards received\n\n    usdValue: uint256 = staticcall Appraiser(miniAddys.appraiser).getUnderlyingUsdValue(_rewardToken, rewardAmount)\n    return rewardAmount, usdValue\n\n\n@external\ndef claimRewards(\n    _user: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _extraData: bytes32,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    # backwards compatibility\n    return 0, 0\n\n\n@view\n@external\ndef hasClaimableRewards(_user: address) -> bool:\n    # as far as we can tell, this must be done offchain\n    return False\n\n\n# set rewards addr\n\n\n@external\ndef setEulerRewardsAddr(_addr: address) -> bool:\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert _addr != empty(address) # dev: invalid addr\n    self.eulerRewards = _addr\n    log EulerRewardsAddrSet(addr=_addr)\n    return True\n\n\n# access control\n\n\n@view\n@external\ndef getAccessForLego(_user: address, _action: ws.ActionType) -> (address, String[64], uint256):\n    if _action != ws.ActionType.REWARDS:\n        return empty(address), empty(String[64]), 0\n\n    eulerRewards: address = self.eulerRewards\n    if staticcall EulerRewardsDistributor(eulerRewards).operators(_user, self):\n        return empty(address), empty(String[64]), 0\n    else:\n        return eulerRewards, LEGO_ACCESS_ABI, 2\n\n\n#########\n# Other #\n#########\n\n\n@external\ndef swapTokens(\n    _amountIn: uint256,\n    _minAmountOut: uint256,\n    _tokenPath: DynArray[address, MAX_TOKEN_PATH],\n    _poolPath: DynArray[address, MAX_TOKEN_PATH - 1],\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256):\n    return 0, 0, 0\n\n\n@external\ndef mintOrRedeemAsset(\n    _tokenIn: address,\n    _tokenOut: address,\n    _tokenInAmount: uint256,\n    _minAmountOut: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, bool, uint256):\n    return 0, 0, False, 0\n\n\n@external\ndef confirmMintOrRedeemAsset(\n    _tokenIn: address,\n    _tokenOut: address,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef addCollateral(\n    _asset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef removeCollateral(\n    _asset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef borrow(\n    _borrowAsset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef repayDebt(\n    _paymentAsset: address,\n    _paymentAmount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef addLiquidity(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _amountA: uint256,\n    _amountB: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _minLpAmount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (address, uint256, uint256, uint256, uint256):\n    return empty(address), 0, 0, 0, 0\n\n\n@external\ndef removeLiquidity(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpToken: address,\n    _lpAmount: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, uint256):\n    return 0, 0, 0, 0\n\n\n@external\ndef addLiquidityConcentrated(\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _tickLower: int24,\n    _tickUpper: int24,\n    _amountA: uint256,\n    _amountB: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, uint256, uint256):\n    return 0, 0, 0, 0, 0\n\n\n@external\ndef removeLiquidityConcentrated(\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _liqToRemove: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, bool, uint256):\n    return 0, 0, 0, False, 0",
            "sha256sum": "cb58f748c1a16740f00409bbf5cb51017933e518340c39c1e2928834ae2a34cf"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/legos/yield/Euler.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.3+commit.bff19ea2",
        "integrity": "fd14a57c9584ce3ff583af891c26a9aa54f610854e06b73ad567abf2271dd608"
      },
      "args": "00000000000000000000000044cf3c4f000dfd76a35d03298049d37be688d6f90000000000000000000000007f321498a801a191a93c840750ed637149ddf8d000000000000000000000000072bbdb652f2aec9056115644efccdd1986f51f150000000000000000000000003ef3d8ba38ebe18db133cec108f4d14ce00dd9ae0000000000000000000000006162df1b329e157479f8f1407e888260e0ec3d2b",
      "file": "contracts/legos/yield/Euler.vy"
    },
    "Fluid": {
      "address": "0x064e88f9CD0eF0525f7A125D4396eE93468C7cdD",
      "abi": [
        {
          "name": "FluidDeposit",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountDeposited",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultTokenAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "FluidWithdrawal",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultTokenAmountBurned",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LegoPauseModified",
          "inputs": [
            {
              "name": "isPaused",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LegoFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "balance",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "SnapShotPriceConfigSet",
          "inputs": [
            {
              "name": "minSnapshotDelay",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "maxNumSnapshots",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "maxUpsideDeviation",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "staleTime",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetOpportunityAdded",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultAddr",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetOpportunityRemoved",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultAddr",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PricePerShareSnapShotAdded",
          "inputs": [
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "totalSupply",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "pricePerShare",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "lastAveragePricePerShare",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddys",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "undyToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "hatchery",
                  "type": "address"
                },
                {
                  "name": "lootDistributor",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                },
                {
                  "name": "walletBackpack",
                  "type": "address"
                },
                {
                  "name": "billing",
                  "type": "address"
                },
                {
                  "name": "vaultRegistry",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUndyHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isLegoAsset",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssetOpportunities",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isAssetOpportunity",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getNumLegoAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pause",
          "inputs": [
            {
              "name": "_shouldPause",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFundsMany",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_assets",
              "type": "address[]"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getWeightedPricePerShare",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLatestSnapshot",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_pricePerShare",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "totalSupply",
                  "type": "uint256"
                },
                {
                  "name": "pricePerShare",
                  "type": "uint256"
                },
                {
                  "name": "lastUpdate",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setSnapShotPriceConfig",
          "inputs": [
            {
              "name": "_config",
              "type": "tuple",
              "components": [
                {
                  "name": "minSnapshotDelay",
                  "type": "uint256"
                },
                {
                  "name": "maxNumSnapshots",
                  "type": "uint256"
                },
                {
                  "name": "maxUpsideDeviation",
                  "type": "uint256"
                },
                {
                  "name": "staleTime",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidPriceConfig",
          "inputs": [
            {
              "name": "_config",
              "type": "tuple",
              "components": [
                {
                  "name": "minSnapshotDelay",
                  "type": "uint256"
                },
                {
                  "name": "maxNumSnapshots",
                  "type": "uint256"
                },
                {
                  "name": "maxUpsideDeviation",
                  "type": "uint256"
                },
                {
                  "name": "staleTime",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "vaultToAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "underlyingAsset",
                  "type": "address"
                },
                {
                  "name": "decimals",
                  "type": "uint256"
                },
                {
                  "name": "lastAveragePricePerShare",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assetOpportunities",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAssetOpportunity",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssetOpportunities",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assets",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "snapShotData",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "lastSnapShot",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "totalSupply",
                      "type": "uint256"
                    },
                    {
                      "name": "pricePerShare",
                      "type": "uint256"
                    },
                    {
                      "name": "lastUpdate",
                      "type": "uint256"
                    }
                  ]
                },
                {
                  "name": "nextIndex",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "snapShots",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "totalSupply",
                  "type": "uint256"
                },
                {
                  "name": "pricePerShare",
                  "type": "uint256"
                },
                {
                  "name": "lastUpdate",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "snapShotPriceConfig",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "minSnapshotDelay",
                  "type": "uint256"
                },
                {
                  "name": "maxNumSnapshots",
                  "type": "uint256"
                },
                {
                  "name": "maxUpsideDeviation",
                  "type": "uint256"
                },
                {
                  "name": "staleTime",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isPaused",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasCapability",
          "inputs": [
            {
              "name": "_action",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRegistries",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isYieldLego",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isDexLego",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAsset",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingBalances",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenBalance",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAmount",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAmountSafe",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenBalance",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingData",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingData",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            },
            {
              "name": "_appraiser",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValueOfVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValueOfVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            },
            {
              "name": "_appraiser",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isRebasing",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPricePerShare",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPricePerShare",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_decimals",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getVaultTokenAmount",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_assetAmount",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalAssets",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalBorrows",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAvailLiquidity",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUtilizationRatio",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isEligibleForYieldBonus",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getWithdrawalFees",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canRegisterVaultToken",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "registerVaultTokenLocally",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "underlyingAsset",
                  "type": "address"
                },
                {
                  "name": "decimals",
                  "type": "uint256"
                },
                {
                  "name": "lastAveragePricePerShare",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "deregisterVaultTokenLocally",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addPriceSnapshot",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositForYield",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositForYield",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawFromYield",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawFromYield",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAccessForLego",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_action",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "string"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimIncentives",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_proofs",
              "type": "bytes32[]"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimIncentives",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_proofs",
              "type": "bytes32[]"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasClaimableRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_tokenPath",
              "type": "address[]"
            },
            {
              "name": "_poolPath",
              "type": "address[]"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_tokenPath",
              "type": "address[]"
            },
            {
              "name": "_poolPath",
              "type": "address[]"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_tokenInAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_tokenInAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmMintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmMintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_borrowAsset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_borrowAsset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_paymentAsset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_paymentAsset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "FLUID_RESOLVER",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "RIPE_REGISTRY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "WETH",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "NATIVE_ETH",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_undyHq",
              "type": "address"
            },
            {
              "name": "_fluidResolver",
              "type": "address"
            },
            {
              "name": "_ripeRegistry",
              "type": "address"
            },
            {
              "name": "_weth",
              "type": "address"
            },
            {
              "name": "_eth",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "interfaces/WalletStructs.vyi": {
            "content": "# @version 0.4.3\n\nflag ActionType:\n    TRANSFER\n    EARN_DEPOSIT\n    EARN_WITHDRAW\n    EARN_REBALANCE\n    SWAP\n    MINT_REDEEM\n    CONFIRM_MINT_REDEEM\n    ADD_COLLATERAL\n    REMOVE_COLLATERAL\n    BORROW\n    REPAY_DEBT\n    REWARDS\n    ETH_TO_WETH\n    WETH_TO_ETH\n    ADD_LIQ\n    REMOVE_LIQ\n    ADD_LIQ_CONC\n    REMOVE_LIQ_CONC\n    PAY_CHEQUE\n\nstruct WalletAssetData:\n    assetBalance: uint256\n    usdValue: uint256\n    isYieldAsset: bool\n    lastPricePerShare: uint256\n\nstruct ActionData:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    billing: address\n    vaultRegistry: address\n    wallet: address\n    walletConfig: address\n    walletOwner: address\n    inEjectMode: bool\n    isFrozen: bool\n    lastTotalUsdValue: uint256\n    signer: address\n    isManager: bool\n    legoId: uint256\n    legoAddr: address\n    eth: address\n    weth: address\n\nstruct MiniAddys:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    appraiser: address",
            "sha256sum": "466493c129135c95470aaf70eeddc936632f7b0f813396e5a7ddc03bea9da518"
          },
          "interfaces/LegoPartner.vyi": {
            "content": "# @version 0.4.3\n\nfrom interfaces import WalletStructs as ws\n\nMAX_TOKEN_PATH: constant(uint256) = 5\nMAX_RECOVER_ASSETS: constant(uint256) = 20\nMAX_PROOFS: constant(uint256) = 25\n\n@external\ndef addLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _tickLower: int24, _tickUpper: int24, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef addLiquidity(_pool: address, _tokenA: address, _tokenB: address, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _minLpAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (address, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef removeLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _liqToRemove: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef removeLiquidity(_pool: address, _tokenA: address, _tokenB: address, _lpToken: address, _lpAmount: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef mintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _tokenInAmount: uint256, _minAmountOut: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef swapTokens(_amountIn: uint256, _minAmountOut: uint256, _tokenPath: DynArray[address, MAX_TOKEN_PATH], _poolPath: DynArray[address, MAX_TOKEN_PATH - 1], _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256):\n    ...\n\n@external\ndef depositForYield(_asset: address, _amount: uint256, _vaultAddr: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef withdrawFromYield(_vaultToken: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef confirmMintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef borrow(_borrowAsset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef repayDebt(_paymentAsset: address, _paymentAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef claimIncentives(_user: address, _rewardToken: address, _rewardAmount: uint256, _proofs: DynArray[bytes32, MAX_PROOFS], _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef removeCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef addCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@view\n@external\ndef getAccessForLego(_user: address, _action: ws.ActionType) -> (address, String[64], uint256):\n    ...\n\n@view\n@external\ndef hasCapability(_action: ws.ActionType) -> bool:\n    ...\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    ...\n\n@view\n@external\ndef isYieldLego() -> bool:\n    ...\n\n@view\n@external\ndef isDexLego() -> bool:\n    ...\n\n\n# common\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "f2afb7bd72d4301aea77bbe4177b7ae954ba6f6b76af363965993eb92ad0b715"
          },
          "interfaces/LegoStructs.vyi": {
            "content": "# @version 0.4.3\n\nstruct VaultTokenInfo:\n    underlyingAsset: address\n    decimals: uint256\n    lastAveragePricePerShare: uint256\n\nstruct SnapShotPriceConfig:\n    minSnapshotDelay: uint256\n    maxNumSnapshots: uint256\n    maxUpsideDeviation: uint256\n    staleTime: uint256\n\nstruct SingleSnapShot:\n    totalSupply: uint256\n    pricePerShare: uint256\n    lastUpdate: uint256\n\nstruct SnapShotData:\n    lastSnapShot: SingleSnapShot\n    nextIndex: uint256\n",
            "sha256sum": "8ae48be17d812d57fbd671bbf0593e8abf175ad0924e47c5997823cac19ec806"
          },
          "interfaces/YieldLego.vyi": {
            "content": "# @version 0.4.3\n\nfrom interfaces import LegoStructs as ls\n\n\n###################\n# Underlying Data #\n###################\n\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    ...\n\n\n@view\n@external\ndef getUnderlyingBalances(_vaultToken: address, _vaultTokenBalance: uint256) -> (uint256, uint256):\n    ...\n\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    ...\n\n\n@view\n@external\ndef getUnderlyingAmountSafe(_vaultToken: address, _vaultTokenBalance: uint256) -> uint256:\n    ...\n\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> (address, uint256, uint256):\n    ...\n\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> uint256:\n    ...\n\n\n###############\n# Other Utils #\n###############\n\n\n@view\n@external\ndef isRebasing() -> bool:\n    ...\n\n\n@view\n@external\ndef getPricePerShare(_vaultToken: address, _decimals: uint256 = 0) -> uint256:\n    ...\n\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef canRegisterVaultToken(_asset: address, _vaultToken: address) -> bool:\n    ...\n\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef getUtilizationRatio(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef getAvailLiquidity(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef isEligibleForYieldBonus(_asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef getWithdrawalFees(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    ...\n\n\n###################\n# Yield Lego Data #\n###################\n\n\n@view\n@external\ndef isLegoAsset(_asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, 40]:\n    ...\n\n\n@view\n@external\ndef getAssets() -> DynArray[address, 20]:\n    ...\n\n\n@view\n@external\ndef isAssetOpportunity(_asset: address, _vaultAddr: address) -> bool:\n    ...\n\n\n@view\n@external\ndef getNumLegoAssets() -> uint256:\n    ...\n\n\n@view\n@external\ndef assets(_index: uint256) -> address:\n    ...\n\n\n@view\n@external\ndef indexOfAsset(_asset: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef numAssets() -> uint256:\n    ...\n\n\n@view\n@external\ndef assetOpportunities(_asset: address, _index: uint256) -> address:\n    ...\n\n\n@view\n@external\ndef indexOfAssetOpportunity(_asset: address, _vaultAddr: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef numAssetOpportunities(_asset: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef vaultToAsset(_vaultAddr: address) -> ls.VaultTokenInfo:\n    ...\n\n\n# price snapshots\n\n\n@external\ndef addPriceSnapshot(_vaultToken: address) -> bool:\n    ...\n\n\n@view\n@external\ndef snapShotPriceConfig() -> ls.SnapShotPriceConfig:\n    ...\n\n\n@view\n@external\ndef snapShotData(_vaultToken: address) -> ls.SnapShotData:\n    ...\n\n\n@view\n@external\ndef snapShots(_vaultToken: address, _index: uint256) -> ls.SingleSnapShot:\n    ...\n\n\n@view\n@external\ndef getWeightedPricePerShare(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef getLatestSnapshot(_vaultToken: address, _pricePerShare: uint256) -> ls.SingleSnapShot:\n    ...\n\n\n@external\ndef setSnapShotPriceConfig(_config: ls.SnapShotPriceConfig):\n    ...\n",
            "sha256sum": "db91c139f6018f5218b389d08c8703bc16fb994aa948805dbfea27e072f382ec"
          },
          "contracts/modules/Addys.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\ninterface UndyHq:\n    def isValidAddr(_addr: address) -> bool: view\n    def getAddr(_regId: uint256) -> address: view\n    def undyToken() -> address: view\n\ninterface Switchboard:\n    def isSwitchboardAddr(_addr: address) -> bool: view\n\ninterface LegoBook:\n    def isLegoAddr(_addr: address) -> bool: view\n\nstruct Addys:\n    hq: address\n    undyToken: address\n    ledger: address\n    missionControl: address\n    legoBook: address\n    switchboard: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    walletBackpack: address\n    billing: address\n    vaultRegistry: address\n\n# hq\nUNDY_HQ_FOR_ADDYS: immutable(address)\n\n# core addys\nLEDGER_ID: constant(uint256) = 1\nMISSION_CONTROL_ID: constant(uint256) = 2\nLEGO_BOOK_ID: constant(uint256) = 3\nSWITCHBOARD_ID: constant(uint256) = 4\nHATCHERY_ID: constant(uint256) = 5\nLOOT_DISTRIBUTOR_ID: constant(uint256) = 6\nAPPRAISER_ID: constant(uint256) = 7\nWALLET_BACKPACK_ID: constant(uint256) = 8\nBILLING_ID: constant(uint256) = 9\nVAULT_REGISTRY_ID: constant(uint256) = 10\n\n\n@deploy\ndef __init__(_undyHq: address):\n    assert _undyHq != empty(address) # dev: invalid undy hq\n    UNDY_HQ_FOR_ADDYS = _undyHq\n\n\n########\n# Core #\n########\n\n\n@view\n@external\ndef getAddys() -> Addys:\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _getAddys(_addys: Addys = empty(Addys)) -> Addys:\n    if _addys.hq != empty(address):\n        return _addys\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _generateAddys() -> Addys:\n    hq: address = UNDY_HQ_FOR_ADDYS\n    return Addys(\n        hq = hq,\n        undyToken = staticcall UndyHq(hq).undyToken(),\n        ledger = staticcall UndyHq(hq).getAddr(LEDGER_ID),\n        missionControl = staticcall UndyHq(hq).getAddr(MISSION_CONTROL_ID),\n        legoBook = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID),\n        switchboard = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID),\n        hatchery = staticcall UndyHq(hq).getAddr(HATCHERY_ID),\n        lootDistributor = staticcall UndyHq(hq).getAddr(LOOT_DISTRIBUTOR_ID),\n        appraiser = staticcall UndyHq(hq).getAddr(APPRAISER_ID),\n        walletBackpack = staticcall UndyHq(hq).getAddr(WALLET_BACKPACK_ID),\n        billing = staticcall UndyHq(hq).getAddr(BILLING_ID),\n        vaultRegistry = staticcall UndyHq(hq).getAddr(VAULT_REGISTRY_ID),\n    )\n\n\n##########\n# Tokens #\n##########\n\n\n@view\n@internal\ndef _getUndyToken() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).undyToken()\n\n\n###########\n# Helpers #\n###########\n\n\n# undy hq\n\n\n@view\n@external\ndef getUndyHq() -> address:\n    return self._getUndyHq()\n\n\n@view\n@internal\ndef _getUndyHq() -> address:\n    return UNDY_HQ_FOR_ADDYS\n\n\n# utils\n\n\n@view\n@internal\ndef _isValidUndyAddr(_addr: address, _hq: address = empty(address)) -> bool:\n    hq: address = _hq\n    if _hq == empty(address):\n        hq = UNDY_HQ_FOR_ADDYS\n    \n    # core departments\n    if staticcall UndyHq(hq).isValidAddr(_addr):\n        return True\n\n    # lego book\n    legoBook: address = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID)\n    if legoBook != empty(address) and staticcall LegoBook(legoBook).isLegoAddr(_addr):\n        return True\n\n    # switchboard config\n    switchboard: address = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID)\n    if switchboard != empty(address) and staticcall Switchboard(switchboard).isSwitchboardAddr(_addr):\n        return True\n\n    return False\n\n\n@view\n@internal\ndef _isSwitchboardAddr(_addr: address) -> bool:\n    switchboard: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n    if switchboard == empty(address):\n        return False\n    return staticcall Switchboard(switchboard).isSwitchboardAddr(_addr)\n\n\n@view\n@internal\ndef _isLegoBookAddr(_addr: address) -> bool:\n    legoBook: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n    if legoBook == empty(address):\n        return False\n    return staticcall LegoBook(legoBook).isLegoAddr(_addr)\n\n\n###############\n# Departments #\n###############\n\n\n# ledger\n\n\n@view\n@internal\ndef _getLedgerId() -> uint256:\n    return LEDGER_ID\n\n\n@view\n@internal\ndef _getLedgerAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEDGER_ID)\n\n\n# mission control\n\n\n@view\n@internal\ndef _getMissionControlId() -> uint256:\n    return MISSION_CONTROL_ID\n\n\n@view\n@internal\ndef _getMissionControlAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(MISSION_CONTROL_ID)\n\n\n# lego book\n\n\n@view\n@internal\ndef _getLegoBookId() -> uint256:\n    return LEGO_BOOK_ID\n\n\n@view\n@internal\ndef _getLegoBookAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n\n\n# switchboard\n\n\n@view\n@internal\ndef _getSwitchboardId() -> uint256:\n    return SWITCHBOARD_ID\n\n\n@view\n@internal\ndef _getSwitchboardAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n\n\n# hatchery\n\n\n@view\n@internal\ndef _getHatcheryId() -> uint256:\n    return HATCHERY_ID\n\n\n@view\n@internal\ndef _getHatcheryAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(HATCHERY_ID)\n\n\n# loot distributor\n\n\n@view\n@internal\ndef _getLootDistributorId() -> uint256:\n    return LOOT_DISTRIBUTOR_ID\n\n\n@view\n@internal\ndef _getLootDistributorAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LOOT_DISTRIBUTOR_ID)\n\n\n# appraiser\n\n\n@view\n@internal\ndef _getAppraiserId() -> uint256:\n    return APPRAISER_ID\n\n\n@view\n@internal\ndef _getAppraiserAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(APPRAISER_ID)\n\n\n# wallet backpack\n\n\n@view\n@internal\ndef _getWalletBackpackId() -> uint256:\n    return WALLET_BACKPACK_ID\n\n\n@view\n@internal\ndef _getWalletBackpackAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(WALLET_BACKPACK_ID)\n\n\n# billing\n\n\n@view\n@internal\ndef _getBillingId() -> uint256:\n    return BILLING_ID\n\n\n@view\n@internal\ndef _getBillingAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(BILLING_ID)\n\n\n# vault registry\n\n\n@view\n@internal\ndef _getVaultRegistryId() -> uint256:\n    return VAULT_REGISTRY_ID\n\n\n@view\n@internal\ndef _getVaultRegistryAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(VAULT_REGISTRY_ID)",
            "sha256sum": "4df6b72db9bb417d1af81660175be1450cfb7b3575f3d17a5b8a130bff87b781"
          },
          "contracts/modules/YieldLegoData.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nuses: addys\n\nimport contracts.modules.Addys as addys\n\nfrom interfaces import WalletStructs as ws\nfrom interfaces import LegoStructs as ls\nfrom ethereum.ercs import IERC20\nfrom ethereum.ercs import IERC20Detailed\n\nevent AssetOpportunityAdded:\n    asset: indexed(address)\n    vaultAddr: indexed(address)\n\nevent AssetOpportunityRemoved:\n    asset: indexed(address)\n    vaultAddr: indexed(address)\n\nevent LegoPauseModified:\n    isPaused: bool\n\nevent LegoFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    balance: uint256\n\nevent PricePerShareSnapShotAdded:\n    vaultToken: indexed(address)\n    totalSupply: uint256\n    pricePerShare: uint256\n    lastAveragePricePerShare: uint256\n\nevent SnapShotPriceConfigSet:\n    minSnapshotDelay: uint256\n    maxNumSnapshots: uint256\n    maxUpsideDeviation: uint256\n    staleTime: uint256\n\n# core\nvaultToAsset: public(HashMap[address, ls.VaultTokenInfo]) # vault addr -> data\n\n# asset opportunities\nassetOpportunities: public(HashMap[address, HashMap[uint256, address]]) # asset -> index -> vault addr\nindexOfAssetOpportunity: public(HashMap[address, HashMap[address, uint256]]) # asset -> vault addr -> index\nnumAssetOpportunities: public(HashMap[address, uint256]) # asset -> number of opportunities\n\n# lego assets (iterable)\nassets: public(HashMap[uint256, address]) # index -> asset\nindexOfAsset: public(HashMap[address, uint256]) # asset -> index\nnumAssets: public(uint256) # num assets\n\n# price snapshots\nsnapShotData: public(HashMap[address, ls.SnapShotData]) # vault token -> data\nsnapShots: public(HashMap[address, HashMap[uint256, ls.SingleSnapShot]]) # vault token -> index -> snapshot\nsnapShotPriceConfig: public(ls.SnapShotPriceConfig) # config\n\nisPaused: public(bool)\n\nMAX_VAULTS: constant(uint256) = 40\nMAX_ASSETS: constant(uint256) = 20\nMAX_RECOVER_ASSETS: constant(uint256) = 20\nONE_DAY_SECONDS: constant(uint256) = 60 * 60 * 24\nONE_WEEK_SECONDS: constant(uint256) = ONE_DAY_SECONDS * 7\nHUNDRED_PERCENT: constant(uint256) = 100_00\n\n\n@deploy\ndef __init__(_shouldPause: bool):\n    self.isPaused = _shouldPause\n    self.numAssets = 1 # not using 0 index\n\n    # default snapshot price config\n    self.snapShotPriceConfig = ls.SnapShotPriceConfig(\n        minSnapshotDelay = 60 * 10, # 10 minutes\n        maxNumSnapshots = 20,\n        maxUpsideDeviation = 10_00, # 10%\n        staleTime = ONE_DAY_SECONDS, # 1 day\n    )\n\n\n#########\n# Views #\n#########\n\n\n# is lego asset\n\n\n@view\n@external\ndef isLegoAsset(_asset: address) -> bool:\n    return self._isLegoAsset(_asset)\n\n\n@view\n@internal\ndef _isLegoAsset(_asset: address) -> bool:\n    return self.indexOfAsset[_asset] != 0\n\n\n# vault opportunities\n\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, MAX_VAULTS]:\n    numOpportunities: uint256 = self.numAssetOpportunities[_asset]\n    if numOpportunities == 0:\n        return []\n    opportunities: DynArray[address, MAX_VAULTS] = []\n    for i: uint256 in range(1, numOpportunities, bound=MAX_VAULTS):\n        opportunities.append(self.assetOpportunities[_asset][i])\n    return opportunities\n\n\n# all assets registered\n\n\n@view\n@external\ndef getAssets() -> DynArray[address, MAX_ASSETS]:\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return []\n    assets: DynArray[address, MAX_ASSETS] = []\n    for i: uint256 in range(1, numAssets, bound=MAX_ASSETS):\n        assets.append(self.assets[i])\n    return assets\n\n\n################\n# Registration #\n################\n\n\n@view\n@external\ndef isAssetOpportunity(_asset: address, _vaultAddr: address) -> bool:\n    return self._isAssetOpportunity(_asset, _vaultAddr)\n\n\n@view\n@internal\ndef _isAssetOpportunity(_asset: address, _vaultAddr: address) -> bool:\n    return self.indexOfAssetOpportunity[_asset][_vaultAddr] != 0\n\n\n# add asset opportunity\n\n\n@internal\ndef _addAssetOpportunity(_asset: address, _vaultAddr: address) -> ls.VaultTokenInfo:\n    if self.indexOfAssetOpportunity[_asset][_vaultAddr] != 0:\n        return self.vaultToAsset[_vaultAddr]\n\n    if empty(address) in [_asset, _vaultAddr]:\n        return empty(ls.VaultTokenInfo)\n\n    # add asset opportunity\n    aid: uint256 = self.numAssetOpportunities[_asset]\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.assetOpportunities[_asset][aid] = _vaultAddr\n    self.indexOfAssetOpportunity[_asset][_vaultAddr] = aid\n    self.numAssetOpportunities[_asset] = aid + 1\n\n    # add mapping\n    vaultInfo: ls.VaultTokenInfo = ls.VaultTokenInfo(\n        underlyingAsset = _asset,\n        decimals = convert(staticcall IERC20Detailed(_vaultAddr).decimals(), uint256),\n        lastAveragePricePerShare = 0,\n    )\n    self.vaultToAsset[_vaultAddr] = vaultInfo\n\n    # add asset\n    self._addAsset(_asset)\n\n    log AssetOpportunityAdded(asset=_asset, vaultAddr=_vaultAddr)\n    return vaultInfo\n\n\n# remove asset opportunity\n\n\n@internal\ndef _removeAssetOpportunity(_asset: address, _vaultAddr: address):\n    numOpportunities: uint256 = self.numAssetOpportunities[_asset]\n    if numOpportunities == 0:\n        return\n\n    targetIndex: uint256 = self.indexOfAssetOpportunity[_asset][_vaultAddr]\n    if targetIndex == 0:\n        return\n\n    # update data\n    lastIndex: uint256 = numOpportunities - 1\n    self.numAssetOpportunities[_asset] = lastIndex\n    self.indexOfAssetOpportunity[_asset][_vaultAddr] = 0\n\n    self.vaultToAsset[_vaultAddr] = empty(ls.VaultTokenInfo)\n\n    # clear all snapshot data for the vault token to prevent contamination on re-add\n    self.snapShotData[_vaultAddr] = empty(ls.SnapShotData)\n\n    # clear all historical snapshots\n    config: ls.SnapShotPriceConfig = self.snapShotPriceConfig\n    for i: uint256 in range(config.maxNumSnapshots, bound=max_value(uint256)):\n        if i >= config.maxNumSnapshots:\n            break\n        self.snapShots[_vaultAddr][i] = empty(ls.SingleSnapShot)\n\n    # shift to replace the removed one\n    if targetIndex != lastIndex:\n        lastVaultAddr: address = self.assetOpportunities[_asset][lastIndex]\n        self.assetOpportunities[_asset][targetIndex] = lastVaultAddr\n        self.indexOfAssetOpportunity[_asset][lastVaultAddr] = targetIndex\n\n    # remove asset\n    if lastIndex <= 1:\n        self._removeAsset(_asset)\n\n    log AssetOpportunityRemoved(asset=_asset, vaultAddr=_vaultAddr)\n\n\n# add asset\n\n\n@internal\ndef _addAsset(_asset: address):\n    if self.indexOfAsset[_asset] != 0:\n        return\n\n    aid: uint256 = self.numAssets\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.assets[aid] = _asset\n    self.indexOfAsset[_asset] = aid\n    self.numAssets = aid + 1\n\n\n# remove asset\n\n\n@internal\ndef _removeAsset(_asset: address):\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return\n\n    targetIndex: uint256 = self.indexOfAsset[_asset]\n    if targetIndex == 0:\n        return\n\n    # update data\n    lastIndex: uint256 = numAssets - 1\n    self.numAssets = lastIndex\n    self.indexOfAsset[_asset] = 0\n\n    # shift to replace the removed one\n    if targetIndex != lastIndex:\n        lastAsset: address = self.assets[lastIndex]\n        self.assets[targetIndex] = lastAsset\n        self.indexOfAsset[lastAsset] = targetIndex\n\n\n# num lego assets (true number, use `numAssets` for iteration)\n\n\n@view\n@external\ndef getNumLegoAssets() -> uint256:\n    return self._getNumLegoAssets()\n\n\n@view\n@internal\ndef _getNumLegoAssets() -> uint256:\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return 0\n    return numAssets - 1\n\n\n###########\n# General #\n###########\n\n\n# fill mini addys\n\n\n@view\n@internal\ndef _getMiniAddys(_miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> ws.MiniAddys:\n    if _miniAddys.ledger != empty(address):\n        return _miniAddys\n    return ws.MiniAddys(\n        ledger = addys._getLedgerAddr(),\n        missionControl = addys._getMissionControlAddr(),\n        legoBook = addys._getLegoBookAddr(),\n        appraiser = addys._getAppraiserAddr(),\n    )\n\n\n# activate\n\n\n@external\ndef pause(_shouldPause: bool):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert _shouldPause != self.isPaused # dev: no change\n    self.isPaused = _shouldPause\n    log LegoPauseModified(isPaused=_shouldPause)\n\n\n# recover funds\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    self._recoverFunds(_recipient, _asset)\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, MAX_RECOVER_ASSETS]):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    for a: address in _assets:\n        self._recoverFunds(_recipient, a)\n\n\n@internal\ndef _recoverFunds(_recipient: address, _asset: address):\n    assert empty(address) not in [_recipient, _asset] # dev: invalid recipient or asset\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    assert balance != 0 # dev: nothing to recover\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log LegoFundsRecovered(asset=_asset, recipient=_recipient, balance=balance)\n\n\n###################\n# Price Snapshots #\n###################\n\n\n# add price snapshot\n\n\n@internal\ndef _addPriceSnapshot(_vaultToken: address, _pricePerShare: uint256, _vaultTokenDecimals: uint256) -> bool:\n    config: ls.SnapShotPriceConfig = self.snapShotPriceConfig\n    if config.maxNumSnapshots == 0:\n        return False\n\n    data: ls.SnapShotData = self.snapShotData[_vaultToken]\n\n    # already have snapshot for this time\n    if data.lastSnapShot.lastUpdate == block.timestamp:\n        return False\n\n    # check if snapshot is too recent\n    if data.lastSnapShot.lastUpdate + config.minSnapshotDelay > block.timestamp:\n        return False\n\n    # create and store new snapshot\n    newSnapshot: ls.SingleSnapShot = self._getLatestSnapshot(_vaultToken, _pricePerShare, _vaultTokenDecimals, data.lastSnapShot, config)\n    data.lastSnapShot = newSnapshot\n    self.snapShots[_vaultToken][data.nextIndex] = newSnapshot\n\n    # update index\n    data.nextIndex += 1\n    if data.nextIndex >= config.maxNumSnapshots:\n        data.nextIndex = 0\n\n    # save snap shot data\n    self.snapShotData[_vaultToken] = data\n\n    # update cached weighted average price per share\n    lastAveragePricePerShare: uint256 = self._getWeightedPricePerShare(_vaultToken, _pricePerShare)\n    self.vaultToAsset[_vaultToken].lastAveragePricePerShare = lastAveragePricePerShare\n\n    log PricePerShareSnapShotAdded(\n        vaultToken = _vaultToken,\n        totalSupply = newSnapshot.totalSupply,\n        pricePerShare = newSnapshot.pricePerShare,\n        lastAveragePricePerShare = lastAveragePricePerShare,\n    )\n    return True\n\n\n# weighted price per share\n\n\n@view\n@external\ndef getWeightedPricePerShare(_vaultToken: address) -> uint256:\n    data: ls.SnapShotData = self.snapShotData[_vaultToken]\n    return self._getWeightedPricePerShare(_vaultToken, data.lastSnapShot.pricePerShare)\n\n\n@view\n@internal\ndef _getWeightedPricePerShare(_vaultToken: address, _lastPricePerShare: uint256) -> uint256:\n    config: ls.SnapShotPriceConfig = self.snapShotPriceConfig\n    if config.maxNumSnapshots == 0:\n        return 0\n\n    # calculate weighted average price using all valid snapshots\n    numerator: uint256 = 0\n    denominator: uint256 = 0\n    for i: uint256 in range(config.maxNumSnapshots, bound=max_value(uint256)):\n\n        snapShot: ls.SingleSnapShot = self.snapShots[_vaultToken][i]\n        if snapShot.pricePerShare == 0 or snapShot.totalSupply == 0 or snapShot.lastUpdate == 0:\n            continue\n\n        # too stale, skip\n        if config.staleTime != 0 and block.timestamp > snapShot.lastUpdate + config.staleTime:\n            continue\n\n        numerator += (snapShot.totalSupply * snapShot.pricePerShare)\n        denominator += snapShot.totalSupply\n\n    # weighted price per share\n    weightedPricePerShare: uint256 = 0\n    if numerator != 0:\n        weightedPricePerShare = numerator // denominator\n    else:\n        weightedPricePerShare = _lastPricePerShare\n\n    return weightedPricePerShare\n\n\n# latest snapshot\n\n\n@view\n@external\ndef getLatestSnapshot(_vaultToken: address, _pricePerShare: uint256) -> ls.SingleSnapShot:\n    data: ls.SnapShotData = self.snapShotData[_vaultToken]\n    config: ls.SnapShotPriceConfig = self.snapShotPriceConfig\n    vaultTokenDecimals: uint256 = self.vaultToAsset[_vaultToken].decimals\n    return self._getLatestSnapshot(_vaultToken, _pricePerShare, vaultTokenDecimals, data.lastSnapShot, config)\n\n\n@view\n@internal\ndef _getLatestSnapshot(\n    _vaultToken: address,\n    _pricePerShare: uint256,\n    _vaultTokenDecimals: uint256,\n    _lastSnapShot: ls.SingleSnapShot,\n    _config: ls.SnapShotPriceConfig,\n) -> ls.SingleSnapShot:\n\n    # total supply (adjusted)\n    totalSupply: uint256 = staticcall IERC20(_vaultToken).totalSupply() // (10 ** _vaultTokenDecimals)\n    if totalSupply == 0:\n        totalSupply = 1\n\n    # throttle upside (extra safety check)\n    pricePerShare: uint256 = self._throttleUpside(_pricePerShare, _lastSnapShot.pricePerShare, _config.maxUpsideDeviation)\n\n    return ls.SingleSnapShot(\n        totalSupply = totalSupply,\n        pricePerShare = pricePerShare,\n        lastUpdate = block.timestamp,\n    )\n\n\n@view\n@internal\ndef _throttleUpside(_newValue: uint256, _prevValue: uint256, _maxUpside: uint256) -> uint256:\n    if _maxUpside == 0 or _prevValue == 0 or _newValue == 0:\n        return _newValue\n    maxPricePerShare: uint256 = _prevValue + (_prevValue * _maxUpside // HUNDRED_PERCENT)\n    return min(_newValue, maxPricePerShare)\n\n\n# snapshot price config\n\n\n@external\ndef setSnapShotPriceConfig(_config: ls.SnapShotPriceConfig):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert self._isValidPriceConfig(_config) # dev: invalid config\n    self.snapShotPriceConfig = _config\n    log SnapShotPriceConfigSet(\n        minSnapshotDelay=_config.minSnapshotDelay,\n        maxNumSnapshots=_config.maxNumSnapshots,\n        maxUpsideDeviation=_config.maxUpsideDeviation,\n        staleTime=_config.staleTime\n    )\n\n\n@view\n@external\ndef isValidPriceConfig(_config: ls.SnapShotPriceConfig) -> bool:\n    return self._isValidPriceConfig(_config)\n\n\n@view\n@internal\ndef _isValidPriceConfig(_config: ls.SnapShotPriceConfig) -> bool:\n    if _config.minSnapshotDelay > ONE_WEEK_SECONDS:\n        return False\n    if _config.maxNumSnapshots == 0 or _config.maxNumSnapshots > 25:\n        return False\n    if _config.maxUpsideDeviation > HUNDRED_PERCENT:\n        return False\n    return _config.staleTime < ONE_WEEK_SECONDS",
            "sha256sum": "50440c96dc8a7af22e7ad927bb6d3e308f137d5d3632e633e084b05510c94c28"
          },
          "contracts/legos/yield/Fluid.vy": {
            "content": "#     __   __ ___ _______ ___     ______       ___     _______ _______ _______ \n#    |  | |  |   |       |   |   |      |     |   |   |       |       |       |\n#    |  |_|  |   |    ___|   |   |  _    |    |   |   |    ___|    ___|   _   |\n#    |       |   |   |___|   |   | | |   |    |   |   |   |___|   | __|  | |  |\n#    |_     _|   |    ___|   |___| |_|   |    |   |___|    ___|   ||  |  |_|  |\n#      |   | |   |   |___|       |       |    |       |   |___|   |_| |       |\n#      |___| |___|_______|_______|______|     |_______|_______|_______|_______|\n#                                                                       \n#     \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n#     \u2551  ** Fluid Lego **                       \u2551\n#     \u2551  Integration with Fluid Protocol.       \u2551\n#     \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n#\n#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nimplements: Lego\nimplements: YieldLego\n\nexports: addys.__interface__\nexports: yld.__interface__\n\ninitializes: addys\ninitializes: yld[addys := addys]\n\nfrom interfaces import LegoPartner as Lego\nfrom interfaces import YieldLego as YieldLego\nfrom interfaces import WalletStructs as ws\nfrom interfaces import LegoStructs as ls\n\nimport contracts.modules.Addys as addys\nimport contracts.modules.YieldLegoData as yld\n\nfrom ethereum.ercs import IERC20\nfrom ethereum.ercs import IERC4626\nfrom ethereum.ercs import IERC20Detailed\n\ninterface Ledger:\n    def setVaultToken(_vaultToken: address, _legoId: uint256, _underlyingAsset: address, _decimals: uint256, _isRebasing: bool): nonpayable\n    def isRegisteredVaultToken(_vaultToken: address) -> bool: view\n    def isUserWallet(_user: address) -> bool: view\n\ninterface FluidLendingResolver:\n    def getAllFTokens() -> DynArray[address, MAX_FTOKENS]: view\n    def LIQUIDITY_RESOLVER() -> address: view\n\ninterface Registry:\n    def getRegId(_addr: address) -> uint256: view\n    def isValidAddr(_addr: address) -> bool: view\n\ninterface Appraiser:\n    def getUnderlyingUsdValue(_asset: address, _amount: uint256) -> uint256: view\n\ninterface FluidLiquidityResolver:\n    def getOverallTokenData(_token: address) -> OverallTokenData: view\n\ninterface VaultRegistry:\n    def isEarnVault(_vaultAddr: address) -> bool: view\n\nstruct OverallTokenData:\n    borrowRate: uint256\n    supplyRate: uint256\n    fee: uint256\n    lastStoredUtilization: uint256\n    storageUpdateThreshold: uint256\n    lastUpdateTimestamp: uint256\n    supplyExchangePrice: uint256\n    borrowExchangePrice: uint256\n    supplyRawInterest: uint256\n    supplyInterestFree: uint256\n    borrowRawInterest: uint256\n    borrowInterestFree: uint256\n    totalSupply: uint256\n    totalBorrow: uint256\n    revenue: uint256\n    maxUtilization: uint256\n    rateData: RateData\n\nstruct RateData:\n    version: uint256\n    rateDataV1: RateDataV1\n    rateDataV2: RateDataV2\n\nstruct RateDataV1:\n    rateAtUtilizationZero: uint256\n    kink: uint256\n    rateAtUtilizationKink: uint256\n    rateAtUtilizationMax: uint256\n\nstruct RateDataV2:\n    rateAtUtilizationZero: uint256\n    kink1: uint256\n    rateAtUtilizationKink1: uint256\n    kink2: uint256\n    rateAtUtilizationKink2: uint256\n    rateAtUtilizationMax: uint256\n\nevent FluidDeposit:\n    sender: indexed(address)\n    asset: indexed(address)\n    vaultToken: indexed(address)\n    assetAmountDeposited: uint256\n    usdValue: uint256\n    vaultTokenAmountReceived: uint256\n    recipient: address\n\nevent FluidWithdrawal:\n    sender: indexed(address)\n    asset: indexed(address)\n    vaultToken: indexed(address)\n    assetAmountReceived: uint256\n    usdValue: uint256\n    vaultTokenAmountBurned: uint256\n    recipient: address\n\n# fluid\nFLUID_RESOLVER: public(immutable(address))\nRIPE_REGISTRY: public(immutable(address))\nWETH: public(immutable(address))\nNATIVE_ETH: public(immutable(address))\n\nMAX_FTOKENS: constant(uint256) = 50\nMAX_TOKEN_PATH: constant(uint256) = 5\nMAX_PROOFS: constant(uint256) = 25\nHUNDRED_PERCENT: constant(uint256) = 100_00\n\n\n@deploy\ndef __init__(\n    _undyHq: address,\n    _fluidResolver: address,\n    _ripeRegistry: address,\n    _weth: address,\n    _eth: address,\n):\n    addys.__init__(_undyHq)\n    yld.__init__(False)\n\n    assert empty(address) not in [_fluidResolver, _ripeRegistry, _weth, _eth] # dev: invalid addrs\n    FLUID_RESOLVER = _fluidResolver\n    RIPE_REGISTRY = _ripeRegistry\n    WETH = _weth\n    NATIVE_ETH = _eth\n\n\n@view\n@external\ndef hasCapability(_action: ws.ActionType) -> bool:\n    return _action in (\n        ws.ActionType.EARN_DEPOSIT | \n        ws.ActionType.EARN_WITHDRAW\n    )\n\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    return [FLUID_RESOLVER]\n\n\n@view\n@external\ndef isYieldLego() -> bool:\n    return True\n\n\n@view\n@external\ndef isDexLego() -> bool:\n    return False\n\n\n###################\n# Underlying Data #\n###################\n\n\n# underlying asset\n\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    return self._getUnderlyingAsset(_vaultToken)\n\n\n@view\n@internal\ndef _getUnderlyingAsset(_vaultToken: address) -> address:\n    asset: address = yld.vaultToAsset[_vaultToken].underlyingAsset\n    if asset != empty(address):\n        return asset\n    return staticcall IERC4626(_vaultToken).asset()\n\n\n# underlying balances (both true and safe)\n\n\n@view\n@external\ndef getUnderlyingBalances(_vaultToken: address, _vaultTokenBalance: uint256) -> (uint256, uint256):\n    if _vaultTokenBalance == 0:\n        return 0, 0\n\n    trueUnderlying: uint256 = self._getUnderlyingAmount(_vaultToken, _vaultTokenBalance)\n    safeUnderlying: uint256 = self._getUnderlyingAmountSafe(_vaultToken, _vaultTokenBalance)\n    if safeUnderlying == 0:\n        safeUnderlying = trueUnderlying\n\n    return trueUnderlying, min(trueUnderlying, safeUnderlying)\n\n\n# underlying amount (true)\n\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    return self._getUnderlyingAmount(_vaultToken, _vaultTokenAmount)\n\n\n@view\n@internal\ndef _getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    return staticcall IERC4626(_vaultToken).previewRedeem(_vaultTokenAmount)\n\n\n# underlying amount (safe)\n\n\n@view\n@external\ndef getUnderlyingAmountSafe(_vaultToken: address, _vaultTokenBalance: uint256) -> uint256:\n    return self._getUnderlyingAmountSafe(_vaultToken, _vaultTokenBalance)\n\n\n@view\n@internal\ndef _getUnderlyingAmountSafe(_vaultToken: address, _vaultTokenBalance: uint256) -> uint256:\n    vaultInfo: ls.VaultTokenInfo = yld.vaultToAsset[_vaultToken]\n    if vaultInfo.decimals == 0:\n        return 0 # not registered\n\n    # safe underlying amount (using cached weighted average from snapshots)\n    return _vaultTokenBalance * vaultInfo.lastAveragePricePerShare // (10 ** vaultInfo.decimals)\n\n\n# underlying data (combined)\n\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> (address, uint256, uint256):\n    return self._getUnderlyingData(_vaultToken, _vaultTokenAmount, _appraiser)\n\n\n@view\n@internal\ndef _getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address) -> (address, uint256, uint256):\n    asset: address = self._getUnderlyingAsset(_vaultToken)\n    if asset == empty(address):\n        return empty(address), 0, 0 # invalid vault token\n    underlyingAmount: uint256 = self._getUnderlyingAmount(_vaultToken, _vaultTokenAmount)\n    usdValue: uint256 = self._getUsdValue(asset, underlyingAmount, _appraiser)\n    return asset, underlyingAmount, usdValue\n\n\n# usd value\n\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> uint256:\n    return self._getUsdValueOfVaultToken(_vaultToken, _vaultTokenAmount, _appraiser)\n\n\n@view\n@internal\ndef _getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address) -> uint256:\n    return self._getUnderlyingData(_vaultToken, _vaultTokenAmount, _appraiser)[2]\n\n\n@view\n@internal\ndef _getUsdValue(_asset: address, _amount: uint256, _appraiser: address) -> uint256:\n    appraiser: address = _appraiser\n    if _appraiser == empty(address):\n        appraiser = addys._getAppraiserAddr()\n    return staticcall Appraiser(appraiser).getUnderlyingUsdValue(_asset, _amount)\n\n\n###############\n# Other Utils #\n###############\n\n\n# basics\n\n\n@view\n@external\ndef isRebasing() -> bool:\n    return self._isRebasing()\n\n\n@view\n@internal\ndef _isRebasing() -> bool:\n    return False\n\n\n# price per share\n\n\n@view\n@external\ndef getPricePerShare(_vaultToken: address, _decimals: uint256 = 0) -> uint256:\n    decimals: uint256 = _decimals\n    if decimals == 0:\n        decimals = yld.vaultToAsset[_vaultToken].decimals\n    if decimals == 0:\n        decimals = convert(staticcall IERC20Detailed(_vaultToken).decimals(), uint256)\n    return self._getPricePerShare(_vaultToken, decimals)\n\n\n@view\n@internal\ndef _getPricePerShare(_vaultToken: address, _decimals: uint256) -> uint256:\n    return staticcall IERC4626(_vaultToken).previewRedeem(10 ** _decimals)\n\n\n# vault token amount\n\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    return staticcall IERC4626(_vaultToken).convertToShares(_assetAmount)\n\n\n# total assets\n\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    return self._totalAssets(_vaultToken)\n\n\n@view\n@internal\ndef _totalAssets(_vaultToken: address) -> uint256:\n    return staticcall IERC4626(_vaultToken).totalAssets()\n\n\n# total borrows\n\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    return self._totalBorrows(_vaultToken)\n\n\n@view\n@internal\ndef _totalBorrows(_vaultToken: address) -> uint256:\n    # calculate vault's proportional share of protocol borrows\n    vaultAssets: uint256 = self._totalAssets(_vaultToken)\n    if vaultAssets == 0:\n        return 0\n    tokenData: OverallTokenData = self._getOverallTokenData(_vaultToken)\n    if tokenData.totalSupply == 0:\n        return 0\n    return vaultAssets * tokenData.totalBorrow // tokenData.totalSupply\n\n\n@view\n@internal\ndef _getOverallTokenData(_vaultToken: address) -> OverallTokenData:\n    asset: address = self._getUnderlyingAsset(_vaultToken)\n    if asset == WETH:\n        asset = NATIVE_ETH # Fluid uses native ETH address for WETH data\n    liquidityResolver: address = staticcall FluidLendingResolver(FLUID_RESOLVER).LIQUIDITY_RESOLVER()\n    return staticcall FluidLiquidityResolver(liquidityResolver).getOverallTokenData(asset)\n\n\n# avail liquidity\n\n\n@view\n@external\ndef getAvailLiquidity(_vaultToken: address) -> uint256:\n    # vault's available = vaultAssets - vaultShareOfBorrows\n    vaultAssets: uint256 = self._totalAssets(_vaultToken)\n    vaultBorrows: uint256 = self._totalBorrows(_vaultToken)\n    if vaultAssets <= vaultBorrows:\n        return 0\n    return vaultAssets - vaultBorrows\n\n\n# utilization\n\n\n@view\n@external\ndef getUtilizationRatio(_vaultToken: address) -> uint256:\n    # utilization ratio is the same at vault and protocol level\n    tokenData: OverallTokenData = self._getOverallTokenData(_vaultToken)\n    if tokenData.totalSupply == 0:\n        return 0\n    return tokenData.totalBorrow * HUNDRED_PERCENT // tokenData.totalSupply\n\n\n# extras\n\n\n@view\n@external\ndef isEligibleForYieldBonus(_asset: address) -> bool:\n    return False\n\n\n@view\n@external\ndef getWithdrawalFees(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    return 0\n\n\n################\n# Registration #\n################\n\n\n# can vault be registered\n\n\n@view\n@external\ndef canRegisterVaultToken(_asset: address, _vaultToken: address) -> bool:\n    return self._canRegisterVaultToken(_asset, _vaultToken)\n\n\n@view\n@internal\ndef _canRegisterVaultToken(_asset: address, _vaultToken: address) -> bool:\n    if empty(address) in [_asset, _vaultToken]:\n        return False\n    if staticcall IERC4626(_vaultToken).asset() != _asset:\n        return False\n    fTokens: DynArray[address, MAX_FTOKENS] = staticcall FluidLendingResolver(FLUID_RESOLVER).getAllFTokens()\n    return _vaultToken in fTokens\n\n\n# register vault token locally\n\n\n@external\ndef registerVaultTokenLocally(_asset: address, _vaultAddr: address) -> ls.VaultTokenInfo:\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert self._canRegisterVaultToken(_asset, _vaultAddr) # dev: cannot register vault token\n    assert not yld._isAssetOpportunity(_asset, _vaultAddr) # dev: already registered\n    vaultInfo: ls.VaultTokenInfo = self._registerVaultTokenLocally(_asset, _vaultAddr)\n    self._registerVaultTokenGlobally(_asset, _vaultAddr, vaultInfo.decimals, addys._getLedgerAddr(), addys._getLegoBookAddr())\n    return vaultInfo\n\n\n@internal\ndef _registerVaultTokenLocally(_asset: address, _vaultAddr: address) -> ls.VaultTokenInfo:\n    assert extcall IERC20(_asset).approve(_vaultAddr, max_value(uint256), default_return_value=True) # dev: max approval failed\n    vaultInfo: ls.VaultTokenInfo = yld._addAssetOpportunity(_asset, _vaultAddr)\n    assert vaultInfo.decimals != 0 # dev: invalid vault token\n    return vaultInfo\n\n\n# remove vault token locally\n\n\n@external\ndef deregisterVaultTokenLocally(_asset: address, _vaultAddr: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert yld._isAssetOpportunity(_asset, _vaultAddr) # dev: already registered\n    self._deregisterVaultTokenLocally(_asset, _vaultAddr)\n\n\n@internal\ndef _deregisterVaultTokenLocally(_asset: address, _vaultAddr: address):\n    assert extcall IERC20(_asset).approve(_vaultAddr, 0, default_return_value=True) # dev: max approval failed\n    yld._removeAssetOpportunity(_asset, _vaultAddr)\n\n\n# ledger registration\n\n\n@internal\ndef _registerVaultTokenGlobally(_underlyingAsset: address, _vaultToken: address, _decimals: uint256, _ledger: address, _legoBook: address):\n    if not staticcall Ledger(_ledger).isRegisteredVaultToken(_vaultToken):\n        legoId: uint256 = staticcall Registry(_legoBook).getRegId(self)\n        extcall Ledger(_ledger).setVaultToken(_vaultToken, legoId, _underlyingAsset, _decimals, self._isRebasing())\n\n\n#################\n# Yield Actions #\n#################\n\n\n# access control\n\n\n@view\n@internal\ndef _isAllowedToPerformAction(_caller: address) -> bool:\n    # NOTE: important to not trust `_miniAddys` here, that's why getting ledger and vault registry from addys\n    if staticcall VaultRegistry(addys._getVaultRegistryAddr()).isEarnVault(_caller):\n        return True\n    if staticcall Ledger(addys._getLedgerAddr()).isUserWallet(_caller):\n        return True\n    return staticcall Registry(RIPE_REGISTRY).isValidAddr(_caller) # Ripe Endaoment is allowed\n\n\n# add price snapshot\n\n\n@external\ndef addPriceSnapshot(_vaultToken: address) -> bool:\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    vaultInfo: ls.VaultTokenInfo = yld.vaultToAsset[_vaultToken]\n    assert vaultInfo.decimals != 0 # dev: not registered\n    pricePerShare: uint256 = self._getPricePerShare(_vaultToken, vaultInfo.decimals)\n    return yld._addPriceSnapshot(_vaultToken, pricePerShare, vaultInfo.decimals)\n\n\n# deposit\n\n\n@external\ndef depositForYield(\n    _asset: address,\n    _amount: uint256,\n    _vaultAddr: address,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, address, uint256, uint256):\n    assert self._isAllowedToPerformAction(msg.sender) # dev: no perms\n    assert not yld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = yld._getMiniAddys(_miniAddys)\n    vaultInfo: ls.VaultTokenInfo = self._getVaultInfoOnDeposit(_asset, _vaultAddr, miniAddys.ledger, miniAddys.legoBook)\n\n    # pre balances\n    preLegoBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n\n    # transfer deposit asset to this contract\n    depositAmount: uint256 = min(_amount, staticcall IERC20(_asset).balanceOf(msg.sender))\n    assert depositAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_asset).transferFrom(msg.sender, self, depositAmount, default_return_value=True) # dev: transfer failed\n\n    # deposit assets into lego partner\n    vaultTokenAmountReceived: uint256 = extcall IERC4626(_vaultAddr).deposit(depositAmount, _recipient)\n    assert vaultTokenAmountReceived != 0 # dev: no vault tokens received\n\n    # refund if full deposit didn't get through\n    currentLegoBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    refundAssetAmount: uint256 = 0\n    if currentLegoBalance > preLegoBalance:\n        refundAssetAmount = currentLegoBalance - preLegoBalance\n        assert extcall IERC20(_asset).transfer(msg.sender, refundAssetAmount, default_return_value=True) # dev: transfer failed\n        depositAmount -= refundAssetAmount\n\n    usdValue: uint256 = staticcall Appraiser(miniAddys.appraiser).getUnderlyingUsdValue(_asset, depositAmount)\n    log FluidDeposit(\n        sender = msg.sender,\n        asset = _asset,\n        vaultToken = _vaultAddr,\n        assetAmountDeposited = depositAmount,\n        usdValue = usdValue,\n        vaultTokenAmountReceived = vaultTokenAmountReceived,\n        recipient = _recipient,\n    )\n\n    # add price snapshot\n    pricePerShare: uint256 = self._getPricePerShare(_vaultAddr, vaultInfo.decimals)\n    yld._addPriceSnapshot(_vaultAddr, pricePerShare, vaultInfo.decimals)\n\n    return depositAmount, _vaultAddr, vaultTokenAmountReceived, usdValue\n\n\n# vault info on deposit\n\n\n@internal\ndef _getVaultInfoOnDeposit(_asset: address, _vaultAddr: address, _ledger: address, _legoBook: address) -> ls.VaultTokenInfo:\n    vaultInfo: ls.VaultTokenInfo = yld.vaultToAsset[_vaultAddr]\n    if vaultInfo.decimals == 0:\n        assert self._canRegisterVaultToken(_asset, _vaultAddr) # dev: cannot register vault token\n        vaultInfo = self._registerVaultTokenLocally(_asset, _vaultAddr)\n        self._registerVaultTokenGlobally(_asset, _vaultAddr, vaultInfo.decimals, _ledger, _legoBook)\n    else:\n        assert vaultInfo.underlyingAsset == _asset # dev: asset mismatch\n    return vaultInfo\n\n\n# withdraw\n\n\n@external\ndef withdrawFromYield(\n    _vaultToken: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, address, uint256, uint256):\n    assert self._isAllowedToPerformAction(msg.sender) # dev: no perms\n    assert not yld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = yld._getMiniAddys(_miniAddys)\n    vaultInfo: ls.VaultTokenInfo = self._getVaultInfoOnWithdrawal(_vaultToken, miniAddys.ledger, miniAddys.legoBook)\n\n    # pre balances\n    preLegoVaultBalance: uint256 = staticcall IERC20(_vaultToken).balanceOf(self)\n\n    # transfer vaults tokens to this contract\n    vaultTokenAmount: uint256 = min(_amount, staticcall IERC20(_vaultToken).balanceOf(msg.sender))\n    assert vaultTokenAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_vaultToken).transferFrom(msg.sender, self, vaultTokenAmount, default_return_value=True) # dev: transfer failed\n\n    # withdraw assets from lego partner\n    assetAmountReceived: uint256 = extcall IERC4626(_vaultToken).redeem(vaultTokenAmount, _recipient, self)\n    assert assetAmountReceived != 0 # dev: no asset amount received\n\n    # refund if full withdrawal didn't happen\n    currentLegoVaultBalance: uint256 = staticcall IERC20(_vaultToken).balanceOf(self)\n    refundVaultTokenAmount: uint256 = 0\n    if currentLegoVaultBalance > preLegoVaultBalance:\n        refundVaultTokenAmount = currentLegoVaultBalance - preLegoVaultBalance\n        assert extcall IERC20(_vaultToken).transfer(msg.sender, refundVaultTokenAmount, default_return_value=True) # dev: transfer failed\n        vaultTokenAmount -= refundVaultTokenAmount\n\n    usdValue: uint256 = staticcall Appraiser(miniAddys.appraiser).getUnderlyingUsdValue(vaultInfo.underlyingAsset, assetAmountReceived)\n    log FluidWithdrawal(\n        sender = msg.sender,\n        asset = vaultInfo.underlyingAsset,\n        vaultToken = _vaultToken,\n        assetAmountReceived = assetAmountReceived,\n        usdValue = usdValue,\n        vaultTokenAmountBurned = vaultTokenAmount,\n        recipient = _recipient,\n    )\n\n    # add price snapshot\n    pricePerShare: uint256 = self._getPricePerShare(_vaultToken, vaultInfo.decimals)\n    yld._addPriceSnapshot(_vaultToken, pricePerShare, vaultInfo.decimals)\n\n    return vaultTokenAmount, vaultInfo.underlyingAsset, assetAmountReceived, usdValue\n\n\n# vault info on withdrawal\n\n\n@internal\ndef _getVaultInfoOnWithdrawal(_vaultAddr: address, _ledger: address, _legoBook: address) -> ls.VaultTokenInfo:\n    vaultInfo: ls.VaultTokenInfo = yld.vaultToAsset[_vaultAddr]\n    if vaultInfo.decimals == 0:\n        asset: address = staticcall IERC4626(_vaultAddr).asset()\n        assert self._canRegisterVaultToken(asset, _vaultAddr) # dev: cannot register vault token\n        vaultInfo = self._registerVaultTokenLocally(asset, _vaultAddr)\n        self._registerVaultTokenGlobally(asset, _vaultAddr, vaultInfo.decimals, _ledger, _legoBook)\n    return vaultInfo\n\n\n#########\n# Other #\n#########\n\n\n@view\n@external\ndef getAccessForLego(_user: address, _action: ws.ActionType) -> (address, String[64], uint256):\n    return empty(address), empty(String[64]), 0\n\n\n@external\ndef claimRewards(\n    _user: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _extraData: bytes32,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    # backwards compatibility\n    return 0, 0\n\n\n@external\ndef claimIncentives(\n    _user: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _proofs: DynArray[bytes32, MAX_PROOFS],\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@view\n@external\ndef hasClaimableRewards(_user: address) -> bool:\n    return False\n\n\n@external\ndef swapTokens(\n    _amountIn: uint256,\n    _minAmountOut: uint256,\n    _tokenPath: DynArray[address, MAX_TOKEN_PATH],\n    _poolPath: DynArray[address, MAX_TOKEN_PATH - 1],\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256):\n    return 0, 0, 0\n\n\n@external\ndef mintOrRedeemAsset(\n    _tokenIn: address,\n    _tokenOut: address,\n    _tokenInAmount: uint256,\n    _minAmountOut: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, bool, uint256):\n    return 0, 0, False, 0\n\n\n@external\ndef confirmMintOrRedeemAsset(\n    _tokenIn: address,\n    _tokenOut: address,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef addCollateral(\n    _asset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef removeCollateral(\n    _asset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef borrow(\n    _borrowAsset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef repayDebt(\n    _paymentAsset: address,\n    _paymentAmount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef addLiquidity(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _amountA: uint256,\n    _amountB: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _minLpAmount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (address, uint256, uint256, uint256, uint256):\n    return empty(address), 0, 0, 0, 0\n\n\n@external\ndef removeLiquidity(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpToken: address,\n    _lpAmount: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, uint256):\n    return 0, 0, 0, 0\n\n\n@external\ndef addLiquidityConcentrated(\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _tickLower: int24,\n    _tickUpper: int24,\n    _amountA: uint256,\n    _amountB: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, uint256, uint256):\n    return 0, 0, 0, 0, 0\n\n\n@external\ndef removeLiquidityConcentrated(\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _liqToRemove: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, bool, uint256):\n    return 0, 0, 0, False, 0",
            "sha256sum": "a891f59d43eb763cac852e8db81a5fc9fd3fe1e0fbdf24adc83c4f2f98943289"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/legos/yield/Fluid.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.3+commit.bff19ea2",
        "integrity": "00fc5c5c1a45a70c46598c7df6258668da8be08eb2501e99da88bb6c247e9b5e"
      },
      "args": "00000000000000000000000044cf3c4f000dfd76a35d03298049d37be688d6f90000000000000000000000003af6fbec4a2fe517f56e402c65e3f4c3e18c1d860000000000000000000000006162df1b329e157479f8f1407e888260e0ec3d2b0000000000000000000000004200000000000000000000000000000000000006000000000000000000000000eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee",
      "file": "contracts/legos/yield/Fluid.vy"
    },
    "Moonwell": {
      "address": "0x41e9951B2C85C295630C8a304A8410BB561ba87d",
      "abi": [
        {
          "name": "MoonwellDeposit",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountDeposited",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultTokenAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "MoonwellWithdrawal",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultTokenAmountBurned",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LegoPauseModified",
          "inputs": [
            {
              "name": "isPaused",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LegoFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "balance",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "SnapShotPriceConfigSet",
          "inputs": [
            {
              "name": "minSnapshotDelay",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "maxNumSnapshots",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "maxUpsideDeviation",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "staleTime",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetOpportunityAdded",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultAddr",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetOpportunityRemoved",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultAddr",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PricePerShareSnapShotAdded",
          "inputs": [
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "totalSupply",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "pricePerShare",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "lastAveragePricePerShare",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddys",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "undyToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "hatchery",
                  "type": "address"
                },
                {
                  "name": "lootDistributor",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                },
                {
                  "name": "walletBackpack",
                  "type": "address"
                },
                {
                  "name": "billing",
                  "type": "address"
                },
                {
                  "name": "vaultRegistry",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUndyHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isLegoAsset",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssetOpportunities",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isAssetOpportunity",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getNumLegoAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pause",
          "inputs": [
            {
              "name": "_shouldPause",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFundsMany",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_assets",
              "type": "address[]"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getWeightedPricePerShare",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLatestSnapshot",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_pricePerShare",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "totalSupply",
                  "type": "uint256"
                },
                {
                  "name": "pricePerShare",
                  "type": "uint256"
                },
                {
                  "name": "lastUpdate",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setSnapShotPriceConfig",
          "inputs": [
            {
              "name": "_config",
              "type": "tuple",
              "components": [
                {
                  "name": "minSnapshotDelay",
                  "type": "uint256"
                },
                {
                  "name": "maxNumSnapshots",
                  "type": "uint256"
                },
                {
                  "name": "maxUpsideDeviation",
                  "type": "uint256"
                },
                {
                  "name": "staleTime",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidPriceConfig",
          "inputs": [
            {
              "name": "_config",
              "type": "tuple",
              "components": [
                {
                  "name": "minSnapshotDelay",
                  "type": "uint256"
                },
                {
                  "name": "maxNumSnapshots",
                  "type": "uint256"
                },
                {
                  "name": "maxUpsideDeviation",
                  "type": "uint256"
                },
                {
                  "name": "staleTime",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "vaultToAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "underlyingAsset",
                  "type": "address"
                },
                {
                  "name": "decimals",
                  "type": "uint256"
                },
                {
                  "name": "lastAveragePricePerShare",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assetOpportunities",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAssetOpportunity",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssetOpportunities",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assets",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "snapShotData",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "lastSnapShot",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "totalSupply",
                      "type": "uint256"
                    },
                    {
                      "name": "pricePerShare",
                      "type": "uint256"
                    },
                    {
                      "name": "lastUpdate",
                      "type": "uint256"
                    }
                  ]
                },
                {
                  "name": "nextIndex",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "snapShots",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "totalSupply",
                  "type": "uint256"
                },
                {
                  "name": "pricePerShare",
                  "type": "uint256"
                },
                {
                  "name": "lastUpdate",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "snapShotPriceConfig",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "minSnapshotDelay",
                  "type": "uint256"
                },
                {
                  "name": "maxNumSnapshots",
                  "type": "uint256"
                },
                {
                  "name": "maxUpsideDeviation",
                  "type": "uint256"
                },
                {
                  "name": "staleTime",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isPaused",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "payable",
          "type": "fallback"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasCapability",
          "inputs": [
            {
              "name": "_action",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRegistries",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isYieldLego",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isDexLego",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAsset",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingBalances",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenBalance",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAmount",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAmountSafe",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenBalance",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingData",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingData",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            },
            {
              "name": "_appraiser",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValueOfVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValueOfVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            },
            {
              "name": "_appraiser",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isRebasing",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPricePerShare",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPricePerShare",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_decimals",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getVaultTokenAmount",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_assetAmount",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalAssets",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalBorrows",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAvailLiquidity",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUtilizationRatio",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isEligibleForYieldBonus",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getWithdrawalFees",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canRegisterVaultToken",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "registerVaultTokenLocally",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "underlyingAsset",
                  "type": "address"
                },
                {
                  "name": "decimals",
                  "type": "uint256"
                },
                {
                  "name": "lastAveragePricePerShare",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "deregisterVaultTokenLocally",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addPriceSnapshot",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositForYield",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositForYield",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawFromYield",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawFromYield",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimIncentives",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_proofs",
              "type": "bytes32[]"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimIncentives",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_proofs",
              "type": "bytes32[]"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasClaimableRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAccessForLego",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_action",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "string"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_tokenPath",
              "type": "address[]"
            },
            {
              "name": "_poolPath",
              "type": "address[]"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_tokenPath",
              "type": "address[]"
            },
            {
              "name": "_poolPath",
              "type": "address[]"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_tokenInAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_tokenInAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmMintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmMintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_borrowAsset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_borrowAsset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_paymentAsset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_paymentAsset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MOONWELL_COMPTROLLER",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "WETH",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "RIPE_REGISTRY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_undyHq",
              "type": "address"
            },
            {
              "name": "_moonwellComptroller",
              "type": "address"
            },
            {
              "name": "_weth",
              "type": "address"
            },
            {
              "name": "_ripeRegistry",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "interfaces/WalletStructs.vyi": {
            "content": "# @version 0.4.3\n\nflag ActionType:\n    TRANSFER\n    EARN_DEPOSIT\n    EARN_WITHDRAW\n    EARN_REBALANCE\n    SWAP\n    MINT_REDEEM\n    CONFIRM_MINT_REDEEM\n    ADD_COLLATERAL\n    REMOVE_COLLATERAL\n    BORROW\n    REPAY_DEBT\n    REWARDS\n    ETH_TO_WETH\n    WETH_TO_ETH\n    ADD_LIQ\n    REMOVE_LIQ\n    ADD_LIQ_CONC\n    REMOVE_LIQ_CONC\n    PAY_CHEQUE\n\nstruct WalletAssetData:\n    assetBalance: uint256\n    usdValue: uint256\n    isYieldAsset: bool\n    lastPricePerShare: uint256\n\nstruct ActionData:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    billing: address\n    vaultRegistry: address\n    wallet: address\n    walletConfig: address\n    walletOwner: address\n    inEjectMode: bool\n    isFrozen: bool\n    lastTotalUsdValue: uint256\n    signer: address\n    isManager: bool\n    legoId: uint256\n    legoAddr: address\n    eth: address\n    weth: address\n\nstruct MiniAddys:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    appraiser: address",
            "sha256sum": "466493c129135c95470aaf70eeddc936632f7b0f813396e5a7ddc03bea9da518"
          },
          "interfaces/LegoPartner.vyi": {
            "content": "# @version 0.4.3\n\nfrom interfaces import WalletStructs as ws\n\nMAX_TOKEN_PATH: constant(uint256) = 5\nMAX_RECOVER_ASSETS: constant(uint256) = 20\nMAX_PROOFS: constant(uint256) = 25\n\n@external\ndef addLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _tickLower: int24, _tickUpper: int24, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef addLiquidity(_pool: address, _tokenA: address, _tokenB: address, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _minLpAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (address, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef removeLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _liqToRemove: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef removeLiquidity(_pool: address, _tokenA: address, _tokenB: address, _lpToken: address, _lpAmount: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef mintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _tokenInAmount: uint256, _minAmountOut: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef swapTokens(_amountIn: uint256, _minAmountOut: uint256, _tokenPath: DynArray[address, MAX_TOKEN_PATH], _poolPath: DynArray[address, MAX_TOKEN_PATH - 1], _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256):\n    ...\n\n@external\ndef depositForYield(_asset: address, _amount: uint256, _vaultAddr: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef withdrawFromYield(_vaultToken: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef confirmMintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef borrow(_borrowAsset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef repayDebt(_paymentAsset: address, _paymentAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef claimIncentives(_user: address, _rewardToken: address, _rewardAmount: uint256, _proofs: DynArray[bytes32, MAX_PROOFS], _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef removeCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef addCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@view\n@external\ndef getAccessForLego(_user: address, _action: ws.ActionType) -> (address, String[64], uint256):\n    ...\n\n@view\n@external\ndef hasCapability(_action: ws.ActionType) -> bool:\n    ...\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    ...\n\n@view\n@external\ndef isYieldLego() -> bool:\n    ...\n\n@view\n@external\ndef isDexLego() -> bool:\n    ...\n\n\n# common\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "f2afb7bd72d4301aea77bbe4177b7ae954ba6f6b76af363965993eb92ad0b715"
          },
          "interfaces/LegoStructs.vyi": {
            "content": "# @version 0.4.3\n\nstruct VaultTokenInfo:\n    underlyingAsset: address\n    decimals: uint256\n    lastAveragePricePerShare: uint256\n\nstruct SnapShotPriceConfig:\n    minSnapshotDelay: uint256\n    maxNumSnapshots: uint256\n    maxUpsideDeviation: uint256\n    staleTime: uint256\n\nstruct SingleSnapShot:\n    totalSupply: uint256\n    pricePerShare: uint256\n    lastUpdate: uint256\n\nstruct SnapShotData:\n    lastSnapShot: SingleSnapShot\n    nextIndex: uint256\n",
            "sha256sum": "8ae48be17d812d57fbd671bbf0593e8abf175ad0924e47c5997823cac19ec806"
          },
          "interfaces/YieldLego.vyi": {
            "content": "# @version 0.4.3\n\nfrom interfaces import LegoStructs as ls\n\n\n###################\n# Underlying Data #\n###################\n\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    ...\n\n\n@view\n@external\ndef getUnderlyingBalances(_vaultToken: address, _vaultTokenBalance: uint256) -> (uint256, uint256):\n    ...\n\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    ...\n\n\n@view\n@external\ndef getUnderlyingAmountSafe(_vaultToken: address, _vaultTokenBalance: uint256) -> uint256:\n    ...\n\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> (address, uint256, uint256):\n    ...\n\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> uint256:\n    ...\n\n\n###############\n# Other Utils #\n###############\n\n\n@view\n@external\ndef isRebasing() -> bool:\n    ...\n\n\n@view\n@external\ndef getPricePerShare(_vaultToken: address, _decimals: uint256 = 0) -> uint256:\n    ...\n\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef canRegisterVaultToken(_asset: address, _vaultToken: address) -> bool:\n    ...\n\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef getUtilizationRatio(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef getAvailLiquidity(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef isEligibleForYieldBonus(_asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef getWithdrawalFees(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    ...\n\n\n###################\n# Yield Lego Data #\n###################\n\n\n@view\n@external\ndef isLegoAsset(_asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, 40]:\n    ...\n\n\n@view\n@external\ndef getAssets() -> DynArray[address, 20]:\n    ...\n\n\n@view\n@external\ndef isAssetOpportunity(_asset: address, _vaultAddr: address) -> bool:\n    ...\n\n\n@view\n@external\ndef getNumLegoAssets() -> uint256:\n    ...\n\n\n@view\n@external\ndef assets(_index: uint256) -> address:\n    ...\n\n\n@view\n@external\ndef indexOfAsset(_asset: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef numAssets() -> uint256:\n    ...\n\n\n@view\n@external\ndef assetOpportunities(_asset: address, _index: uint256) -> address:\n    ...\n\n\n@view\n@external\ndef indexOfAssetOpportunity(_asset: address, _vaultAddr: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef numAssetOpportunities(_asset: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef vaultToAsset(_vaultAddr: address) -> ls.VaultTokenInfo:\n    ...\n\n\n# price snapshots\n\n\n@external\ndef addPriceSnapshot(_vaultToken: address) -> bool:\n    ...\n\n\n@view\n@external\ndef snapShotPriceConfig() -> ls.SnapShotPriceConfig:\n    ...\n\n\n@view\n@external\ndef snapShotData(_vaultToken: address) -> ls.SnapShotData:\n    ...\n\n\n@view\n@external\ndef snapShots(_vaultToken: address, _index: uint256) -> ls.SingleSnapShot:\n    ...\n\n\n@view\n@external\ndef getWeightedPricePerShare(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef getLatestSnapshot(_vaultToken: address, _pricePerShare: uint256) -> ls.SingleSnapShot:\n    ...\n\n\n@external\ndef setSnapShotPriceConfig(_config: ls.SnapShotPriceConfig):\n    ...\n",
            "sha256sum": "db91c139f6018f5218b389d08c8703bc16fb994aa948805dbfea27e072f382ec"
          },
          "contracts/modules/Addys.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\ninterface UndyHq:\n    def isValidAddr(_addr: address) -> bool: view\n    def getAddr(_regId: uint256) -> address: view\n    def undyToken() -> address: view\n\ninterface Switchboard:\n    def isSwitchboardAddr(_addr: address) -> bool: view\n\ninterface LegoBook:\n    def isLegoAddr(_addr: address) -> bool: view\n\nstruct Addys:\n    hq: address\n    undyToken: address\n    ledger: address\n    missionControl: address\n    legoBook: address\n    switchboard: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    walletBackpack: address\n    billing: address\n    vaultRegistry: address\n\n# hq\nUNDY_HQ_FOR_ADDYS: immutable(address)\n\n# core addys\nLEDGER_ID: constant(uint256) = 1\nMISSION_CONTROL_ID: constant(uint256) = 2\nLEGO_BOOK_ID: constant(uint256) = 3\nSWITCHBOARD_ID: constant(uint256) = 4\nHATCHERY_ID: constant(uint256) = 5\nLOOT_DISTRIBUTOR_ID: constant(uint256) = 6\nAPPRAISER_ID: constant(uint256) = 7\nWALLET_BACKPACK_ID: constant(uint256) = 8\nBILLING_ID: constant(uint256) = 9\nVAULT_REGISTRY_ID: constant(uint256) = 10\n\n\n@deploy\ndef __init__(_undyHq: address):\n    assert _undyHq != empty(address) # dev: invalid undy hq\n    UNDY_HQ_FOR_ADDYS = _undyHq\n\n\n########\n# Core #\n########\n\n\n@view\n@external\ndef getAddys() -> Addys:\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _getAddys(_addys: Addys = empty(Addys)) -> Addys:\n    if _addys.hq != empty(address):\n        return _addys\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _generateAddys() -> Addys:\n    hq: address = UNDY_HQ_FOR_ADDYS\n    return Addys(\n        hq = hq,\n        undyToken = staticcall UndyHq(hq).undyToken(),\n        ledger = staticcall UndyHq(hq).getAddr(LEDGER_ID),\n        missionControl = staticcall UndyHq(hq).getAddr(MISSION_CONTROL_ID),\n        legoBook = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID),\n        switchboard = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID),\n        hatchery = staticcall UndyHq(hq).getAddr(HATCHERY_ID),\n        lootDistributor = staticcall UndyHq(hq).getAddr(LOOT_DISTRIBUTOR_ID),\n        appraiser = staticcall UndyHq(hq).getAddr(APPRAISER_ID),\n        walletBackpack = staticcall UndyHq(hq).getAddr(WALLET_BACKPACK_ID),\n        billing = staticcall UndyHq(hq).getAddr(BILLING_ID),\n        vaultRegistry = staticcall UndyHq(hq).getAddr(VAULT_REGISTRY_ID),\n    )\n\n\n##########\n# Tokens #\n##########\n\n\n@view\n@internal\ndef _getUndyToken() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).undyToken()\n\n\n###########\n# Helpers #\n###########\n\n\n# undy hq\n\n\n@view\n@external\ndef getUndyHq() -> address:\n    return self._getUndyHq()\n\n\n@view\n@internal\ndef _getUndyHq() -> address:\n    return UNDY_HQ_FOR_ADDYS\n\n\n# utils\n\n\n@view\n@internal\ndef _isValidUndyAddr(_addr: address, _hq: address = empty(address)) -> bool:\n    hq: address = _hq\n    if _hq == empty(address):\n        hq = UNDY_HQ_FOR_ADDYS\n    \n    # core departments\n    if staticcall UndyHq(hq).isValidAddr(_addr):\n        return True\n\n    # lego book\n    legoBook: address = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID)\n    if legoBook != empty(address) and staticcall LegoBook(legoBook).isLegoAddr(_addr):\n        return True\n\n    # switchboard config\n    switchboard: address = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID)\n    if switchboard != empty(address) and staticcall Switchboard(switchboard).isSwitchboardAddr(_addr):\n        return True\n\n    return False\n\n\n@view\n@internal\ndef _isSwitchboardAddr(_addr: address) -> bool:\n    switchboard: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n    if switchboard == empty(address):\n        return False\n    return staticcall Switchboard(switchboard).isSwitchboardAddr(_addr)\n\n\n@view\n@internal\ndef _isLegoBookAddr(_addr: address) -> bool:\n    legoBook: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n    if legoBook == empty(address):\n        return False\n    return staticcall LegoBook(legoBook).isLegoAddr(_addr)\n\n\n###############\n# Departments #\n###############\n\n\n# ledger\n\n\n@view\n@internal\ndef _getLedgerId() -> uint256:\n    return LEDGER_ID\n\n\n@view\n@internal\ndef _getLedgerAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEDGER_ID)\n\n\n# mission control\n\n\n@view\n@internal\ndef _getMissionControlId() -> uint256:\n    return MISSION_CONTROL_ID\n\n\n@view\n@internal\ndef _getMissionControlAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(MISSION_CONTROL_ID)\n\n\n# lego book\n\n\n@view\n@internal\ndef _getLegoBookId() -> uint256:\n    return LEGO_BOOK_ID\n\n\n@view\n@internal\ndef _getLegoBookAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n\n\n# switchboard\n\n\n@view\n@internal\ndef _getSwitchboardId() -> uint256:\n    return SWITCHBOARD_ID\n\n\n@view\n@internal\ndef _getSwitchboardAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n\n\n# hatchery\n\n\n@view\n@internal\ndef _getHatcheryId() -> uint256:\n    return HATCHERY_ID\n\n\n@view\n@internal\ndef _getHatcheryAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(HATCHERY_ID)\n\n\n# loot distributor\n\n\n@view\n@internal\ndef _getLootDistributorId() -> uint256:\n    return LOOT_DISTRIBUTOR_ID\n\n\n@view\n@internal\ndef _getLootDistributorAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LOOT_DISTRIBUTOR_ID)\n\n\n# appraiser\n\n\n@view\n@internal\ndef _getAppraiserId() -> uint256:\n    return APPRAISER_ID\n\n\n@view\n@internal\ndef _getAppraiserAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(APPRAISER_ID)\n\n\n# wallet backpack\n\n\n@view\n@internal\ndef _getWalletBackpackId() -> uint256:\n    return WALLET_BACKPACK_ID\n\n\n@view\n@internal\ndef _getWalletBackpackAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(WALLET_BACKPACK_ID)\n\n\n# billing\n\n\n@view\n@internal\ndef _getBillingId() -> uint256:\n    return BILLING_ID\n\n\n@view\n@internal\ndef _getBillingAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(BILLING_ID)\n\n\n# vault registry\n\n\n@view\n@internal\ndef _getVaultRegistryId() -> uint256:\n    return VAULT_REGISTRY_ID\n\n\n@view\n@internal\ndef _getVaultRegistryAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(VAULT_REGISTRY_ID)",
            "sha256sum": "4df6b72db9bb417d1af81660175be1450cfb7b3575f3d17a5b8a130bff87b781"
          },
          "contracts/modules/YieldLegoData.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nuses: addys\n\nimport contracts.modules.Addys as addys\n\nfrom interfaces import WalletStructs as ws\nfrom interfaces import LegoStructs as ls\nfrom ethereum.ercs import IERC20\nfrom ethereum.ercs import IERC20Detailed\n\nevent AssetOpportunityAdded:\n    asset: indexed(address)\n    vaultAddr: indexed(address)\n\nevent AssetOpportunityRemoved:\n    asset: indexed(address)\n    vaultAddr: indexed(address)\n\nevent LegoPauseModified:\n    isPaused: bool\n\nevent LegoFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    balance: uint256\n\nevent PricePerShareSnapShotAdded:\n    vaultToken: indexed(address)\n    totalSupply: uint256\n    pricePerShare: uint256\n    lastAveragePricePerShare: uint256\n\nevent SnapShotPriceConfigSet:\n    minSnapshotDelay: uint256\n    maxNumSnapshots: uint256\n    maxUpsideDeviation: uint256\n    staleTime: uint256\n\n# core\nvaultToAsset: public(HashMap[address, ls.VaultTokenInfo]) # vault addr -> data\n\n# asset opportunities\nassetOpportunities: public(HashMap[address, HashMap[uint256, address]]) # asset -> index -> vault addr\nindexOfAssetOpportunity: public(HashMap[address, HashMap[address, uint256]]) # asset -> vault addr -> index\nnumAssetOpportunities: public(HashMap[address, uint256]) # asset -> number of opportunities\n\n# lego assets (iterable)\nassets: public(HashMap[uint256, address]) # index -> asset\nindexOfAsset: public(HashMap[address, uint256]) # asset -> index\nnumAssets: public(uint256) # num assets\n\n# price snapshots\nsnapShotData: public(HashMap[address, ls.SnapShotData]) # vault token -> data\nsnapShots: public(HashMap[address, HashMap[uint256, ls.SingleSnapShot]]) # vault token -> index -> snapshot\nsnapShotPriceConfig: public(ls.SnapShotPriceConfig) # config\n\nisPaused: public(bool)\n\nMAX_VAULTS: constant(uint256) = 40\nMAX_ASSETS: constant(uint256) = 20\nMAX_RECOVER_ASSETS: constant(uint256) = 20\nONE_DAY_SECONDS: constant(uint256) = 60 * 60 * 24\nONE_WEEK_SECONDS: constant(uint256) = ONE_DAY_SECONDS * 7\nHUNDRED_PERCENT: constant(uint256) = 100_00\n\n\n@deploy\ndef __init__(_shouldPause: bool):\n    self.isPaused = _shouldPause\n    self.numAssets = 1 # not using 0 index\n\n    # default snapshot price config\n    self.snapShotPriceConfig = ls.SnapShotPriceConfig(\n        minSnapshotDelay = 60 * 10, # 10 minutes\n        maxNumSnapshots = 20,\n        maxUpsideDeviation = 10_00, # 10%\n        staleTime = ONE_DAY_SECONDS, # 1 day\n    )\n\n\n#########\n# Views #\n#########\n\n\n# is lego asset\n\n\n@view\n@external\ndef isLegoAsset(_asset: address) -> bool:\n    return self._isLegoAsset(_asset)\n\n\n@view\n@internal\ndef _isLegoAsset(_asset: address) -> bool:\n    return self.indexOfAsset[_asset] != 0\n\n\n# vault opportunities\n\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, MAX_VAULTS]:\n    numOpportunities: uint256 = self.numAssetOpportunities[_asset]\n    if numOpportunities == 0:\n        return []\n    opportunities: DynArray[address, MAX_VAULTS] = []\n    for i: uint256 in range(1, numOpportunities, bound=MAX_VAULTS):\n        opportunities.append(self.assetOpportunities[_asset][i])\n    return opportunities\n\n\n# all assets registered\n\n\n@view\n@external\ndef getAssets() -> DynArray[address, MAX_ASSETS]:\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return []\n    assets: DynArray[address, MAX_ASSETS] = []\n    for i: uint256 in range(1, numAssets, bound=MAX_ASSETS):\n        assets.append(self.assets[i])\n    return assets\n\n\n################\n# Registration #\n################\n\n\n@view\n@external\ndef isAssetOpportunity(_asset: address, _vaultAddr: address) -> bool:\n    return self._isAssetOpportunity(_asset, _vaultAddr)\n\n\n@view\n@internal\ndef _isAssetOpportunity(_asset: address, _vaultAddr: address) -> bool:\n    return self.indexOfAssetOpportunity[_asset][_vaultAddr] != 0\n\n\n# add asset opportunity\n\n\n@internal\ndef _addAssetOpportunity(_asset: address, _vaultAddr: address) -> ls.VaultTokenInfo:\n    if self.indexOfAssetOpportunity[_asset][_vaultAddr] != 0:\n        return self.vaultToAsset[_vaultAddr]\n\n    if empty(address) in [_asset, _vaultAddr]:\n        return empty(ls.VaultTokenInfo)\n\n    # add asset opportunity\n    aid: uint256 = self.numAssetOpportunities[_asset]\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.assetOpportunities[_asset][aid] = _vaultAddr\n    self.indexOfAssetOpportunity[_asset][_vaultAddr] = aid\n    self.numAssetOpportunities[_asset] = aid + 1\n\n    # add mapping\n    vaultInfo: ls.VaultTokenInfo = ls.VaultTokenInfo(\n        underlyingAsset = _asset,\n        decimals = convert(staticcall IERC20Detailed(_vaultAddr).decimals(), uint256),\n        lastAveragePricePerShare = 0,\n    )\n    self.vaultToAsset[_vaultAddr] = vaultInfo\n\n    # add asset\n    self._addAsset(_asset)\n\n    log AssetOpportunityAdded(asset=_asset, vaultAddr=_vaultAddr)\n    return vaultInfo\n\n\n# remove asset opportunity\n\n\n@internal\ndef _removeAssetOpportunity(_asset: address, _vaultAddr: address):\n    numOpportunities: uint256 = self.numAssetOpportunities[_asset]\n    if numOpportunities == 0:\n        return\n\n    targetIndex: uint256 = self.indexOfAssetOpportunity[_asset][_vaultAddr]\n    if targetIndex == 0:\n        return\n\n    # update data\n    lastIndex: uint256 = numOpportunities - 1\n    self.numAssetOpportunities[_asset] = lastIndex\n    self.indexOfAssetOpportunity[_asset][_vaultAddr] = 0\n\n    self.vaultToAsset[_vaultAddr] = empty(ls.VaultTokenInfo)\n\n    # clear all snapshot data for the vault token to prevent contamination on re-add\n    self.snapShotData[_vaultAddr] = empty(ls.SnapShotData)\n\n    # clear all historical snapshots\n    config: ls.SnapShotPriceConfig = self.snapShotPriceConfig\n    for i: uint256 in range(config.maxNumSnapshots, bound=max_value(uint256)):\n        if i >= config.maxNumSnapshots:\n            break\n        self.snapShots[_vaultAddr][i] = empty(ls.SingleSnapShot)\n\n    # shift to replace the removed one\n    if targetIndex != lastIndex:\n        lastVaultAddr: address = self.assetOpportunities[_asset][lastIndex]\n        self.assetOpportunities[_asset][targetIndex] = lastVaultAddr\n        self.indexOfAssetOpportunity[_asset][lastVaultAddr] = targetIndex\n\n    # remove asset\n    if lastIndex <= 1:\n        self._removeAsset(_asset)\n\n    log AssetOpportunityRemoved(asset=_asset, vaultAddr=_vaultAddr)\n\n\n# add asset\n\n\n@internal\ndef _addAsset(_asset: address):\n    if self.indexOfAsset[_asset] != 0:\n        return\n\n    aid: uint256 = self.numAssets\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.assets[aid] = _asset\n    self.indexOfAsset[_asset] = aid\n    self.numAssets = aid + 1\n\n\n# remove asset\n\n\n@internal\ndef _removeAsset(_asset: address):\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return\n\n    targetIndex: uint256 = self.indexOfAsset[_asset]\n    if targetIndex == 0:\n        return\n\n    # update data\n    lastIndex: uint256 = numAssets - 1\n    self.numAssets = lastIndex\n    self.indexOfAsset[_asset] = 0\n\n    # shift to replace the removed one\n    if targetIndex != lastIndex:\n        lastAsset: address = self.assets[lastIndex]\n        self.assets[targetIndex] = lastAsset\n        self.indexOfAsset[lastAsset] = targetIndex\n\n\n# num lego assets (true number, use `numAssets` for iteration)\n\n\n@view\n@external\ndef getNumLegoAssets() -> uint256:\n    return self._getNumLegoAssets()\n\n\n@view\n@internal\ndef _getNumLegoAssets() -> uint256:\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return 0\n    return numAssets - 1\n\n\n###########\n# General #\n###########\n\n\n# fill mini addys\n\n\n@view\n@internal\ndef _getMiniAddys(_miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> ws.MiniAddys:\n    if _miniAddys.ledger != empty(address):\n        return _miniAddys\n    return ws.MiniAddys(\n        ledger = addys._getLedgerAddr(),\n        missionControl = addys._getMissionControlAddr(),\n        legoBook = addys._getLegoBookAddr(),\n        appraiser = addys._getAppraiserAddr(),\n    )\n\n\n# activate\n\n\n@external\ndef pause(_shouldPause: bool):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert _shouldPause != self.isPaused # dev: no change\n    self.isPaused = _shouldPause\n    log LegoPauseModified(isPaused=_shouldPause)\n\n\n# recover funds\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    self._recoverFunds(_recipient, _asset)\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, MAX_RECOVER_ASSETS]):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    for a: address in _assets:\n        self._recoverFunds(_recipient, a)\n\n\n@internal\ndef _recoverFunds(_recipient: address, _asset: address):\n    assert empty(address) not in [_recipient, _asset] # dev: invalid recipient or asset\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    assert balance != 0 # dev: nothing to recover\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log LegoFundsRecovered(asset=_asset, recipient=_recipient, balance=balance)\n\n\n###################\n# Price Snapshots #\n###################\n\n\n# add price snapshot\n\n\n@internal\ndef _addPriceSnapshot(_vaultToken: address, _pricePerShare: uint256, _vaultTokenDecimals: uint256) -> bool:\n    config: ls.SnapShotPriceConfig = self.snapShotPriceConfig\n    if config.maxNumSnapshots == 0:\n        return False\n\n    data: ls.SnapShotData = self.snapShotData[_vaultToken]\n\n    # already have snapshot for this time\n    if data.lastSnapShot.lastUpdate == block.timestamp:\n        return False\n\n    # check if snapshot is too recent\n    if data.lastSnapShot.lastUpdate + config.minSnapshotDelay > block.timestamp:\n        return False\n\n    # create and store new snapshot\n    newSnapshot: ls.SingleSnapShot = self._getLatestSnapshot(_vaultToken, _pricePerShare, _vaultTokenDecimals, data.lastSnapShot, config)\n    data.lastSnapShot = newSnapshot\n    self.snapShots[_vaultToken][data.nextIndex] = newSnapshot\n\n    # update index\n    data.nextIndex += 1\n    if data.nextIndex >= config.maxNumSnapshots:\n        data.nextIndex = 0\n\n    # save snap shot data\n    self.snapShotData[_vaultToken] = data\n\n    # update cached weighted average price per share\n    lastAveragePricePerShare: uint256 = self._getWeightedPricePerShare(_vaultToken, _pricePerShare)\n    self.vaultToAsset[_vaultToken].lastAveragePricePerShare = lastAveragePricePerShare\n\n    log PricePerShareSnapShotAdded(\n        vaultToken = _vaultToken,\n        totalSupply = newSnapshot.totalSupply,\n        pricePerShare = newSnapshot.pricePerShare,\n        lastAveragePricePerShare = lastAveragePricePerShare,\n    )\n    return True\n\n\n# weighted price per share\n\n\n@view\n@external\ndef getWeightedPricePerShare(_vaultToken: address) -> uint256:\n    data: ls.SnapShotData = self.snapShotData[_vaultToken]\n    return self._getWeightedPricePerShare(_vaultToken, data.lastSnapShot.pricePerShare)\n\n\n@view\n@internal\ndef _getWeightedPricePerShare(_vaultToken: address, _lastPricePerShare: uint256) -> uint256:\n    config: ls.SnapShotPriceConfig = self.snapShotPriceConfig\n    if config.maxNumSnapshots == 0:\n        return 0\n\n    # calculate weighted average price using all valid snapshots\n    numerator: uint256 = 0\n    denominator: uint256 = 0\n    for i: uint256 in range(config.maxNumSnapshots, bound=max_value(uint256)):\n\n        snapShot: ls.SingleSnapShot = self.snapShots[_vaultToken][i]\n        if snapShot.pricePerShare == 0 or snapShot.totalSupply == 0 or snapShot.lastUpdate == 0:\n            continue\n\n        # too stale, skip\n        if config.staleTime != 0 and block.timestamp > snapShot.lastUpdate + config.staleTime:\n            continue\n\n        numerator += (snapShot.totalSupply * snapShot.pricePerShare)\n        denominator += snapShot.totalSupply\n\n    # weighted price per share\n    weightedPricePerShare: uint256 = 0\n    if numerator != 0:\n        weightedPricePerShare = numerator // denominator\n    else:\n        weightedPricePerShare = _lastPricePerShare\n\n    return weightedPricePerShare\n\n\n# latest snapshot\n\n\n@view\n@external\ndef getLatestSnapshot(_vaultToken: address, _pricePerShare: uint256) -> ls.SingleSnapShot:\n    data: ls.SnapShotData = self.snapShotData[_vaultToken]\n    config: ls.SnapShotPriceConfig = self.snapShotPriceConfig\n    vaultTokenDecimals: uint256 = self.vaultToAsset[_vaultToken].decimals\n    return self._getLatestSnapshot(_vaultToken, _pricePerShare, vaultTokenDecimals, data.lastSnapShot, config)\n\n\n@view\n@internal\ndef _getLatestSnapshot(\n    _vaultToken: address,\n    _pricePerShare: uint256,\n    _vaultTokenDecimals: uint256,\n    _lastSnapShot: ls.SingleSnapShot,\n    _config: ls.SnapShotPriceConfig,\n) -> ls.SingleSnapShot:\n\n    # total supply (adjusted)\n    totalSupply: uint256 = staticcall IERC20(_vaultToken).totalSupply() // (10 ** _vaultTokenDecimals)\n    if totalSupply == 0:\n        totalSupply = 1\n\n    # throttle upside (extra safety check)\n    pricePerShare: uint256 = self._throttleUpside(_pricePerShare, _lastSnapShot.pricePerShare, _config.maxUpsideDeviation)\n\n    return ls.SingleSnapShot(\n        totalSupply = totalSupply,\n        pricePerShare = pricePerShare,\n        lastUpdate = block.timestamp,\n    )\n\n\n@view\n@internal\ndef _throttleUpside(_newValue: uint256, _prevValue: uint256, _maxUpside: uint256) -> uint256:\n    if _maxUpside == 0 or _prevValue == 0 or _newValue == 0:\n        return _newValue\n    maxPricePerShare: uint256 = _prevValue + (_prevValue * _maxUpside // HUNDRED_PERCENT)\n    return min(_newValue, maxPricePerShare)\n\n\n# snapshot price config\n\n\n@external\ndef setSnapShotPriceConfig(_config: ls.SnapShotPriceConfig):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert self._isValidPriceConfig(_config) # dev: invalid config\n    self.snapShotPriceConfig = _config\n    log SnapShotPriceConfigSet(\n        minSnapshotDelay=_config.minSnapshotDelay,\n        maxNumSnapshots=_config.maxNumSnapshots,\n        maxUpsideDeviation=_config.maxUpsideDeviation,\n        staleTime=_config.staleTime\n    )\n\n\n@view\n@external\ndef isValidPriceConfig(_config: ls.SnapShotPriceConfig) -> bool:\n    return self._isValidPriceConfig(_config)\n\n\n@view\n@internal\ndef _isValidPriceConfig(_config: ls.SnapShotPriceConfig) -> bool:\n    if _config.minSnapshotDelay > ONE_WEEK_SECONDS:\n        return False\n    if _config.maxNumSnapshots == 0 or _config.maxNumSnapshots > 25:\n        return False\n    if _config.maxUpsideDeviation > HUNDRED_PERCENT:\n        return False\n    return _config.staleTime < ONE_WEEK_SECONDS",
            "sha256sum": "50440c96dc8a7af22e7ad927bb6d3e308f137d5d3632e633e084b05510c94c28"
          },
          "contracts/legos/yield/Moonwell.vy": {
            "content": "#     __   __ ___ _______ ___     ______       ___     _______ _______ _______ \n#    |  | |  |   |       |   |   |      |     |   |   |       |       |       |\n#    |  |_|  |   |    ___|   |   |  _    |    |   |   |    ___|    ___|   _   |\n#    |       |   |   |___|   |   | | |   |    |   |   |   |___|   | __|  | |  |\n#    |_     _|   |    ___|   |___| |_|   |    |   |___|    ___|   ||  |  |_|  |\n#      |   | |   |   |___|       |       |    |       |   |___|   |_| |       |\n#      |___| |___|_______|_______|______|     |_______|_______|_______|_______|\n#                                                                       \n#     \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n#     \u2551  ** Moonwell Lego **                    \u2551\n#     \u2551  Integration with Moonwell Protocol.    \u2551\n#     \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n#\n#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nimplements: Lego\nimplements: YieldLego\n\nexports: addys.__interface__\nexports: yld.__interface__\n\ninitializes: addys\ninitializes: yld[addys := addys]\n\nfrom interfaces import LegoPartner as Lego\nfrom interfaces import YieldLego as YieldLego\nfrom interfaces import WalletStructs as ws\nfrom interfaces import LegoStructs as ls\n\nimport contracts.modules.Addys as addys\nimport contracts.modules.YieldLegoData as yld\n\nfrom ethereum.ercs import IERC20\nfrom ethereum.ercs import IERC20Detailed\n\ninterface CompoundV2:\n    def redeem(_ctokenAmount: uint256) -> uint256: nonpayable\n    def mint(_amount: uint256) -> uint256: nonpayable\n    def exchangeRateStored() -> uint256: view\n    def totalBorrows() -> uint256: view\n    def totalSupply() -> uint256: view\n    def underlying() -> address: view\n    def getCash() -> uint256: view\n\ninterface Ledger:\n    def setVaultToken(_vaultToken: address, _legoId: uint256, _underlyingAsset: address, _decimals: uint256, _isRebasing: bool): nonpayable\n    def isRegisteredVaultToken(_vaultToken: address) -> bool: view\n    def isUserWallet(_user: address) -> bool: view\n\ninterface MoonwellComptroller:\n    def getAllMarkets() -> DynArray[address, MAX_MARKETS]: view\n    def claimReward(_holder: address): nonpayable\n    def rewardDistributor() -> address: view\n\ninterface Registry:\n    def getRegId(_addr: address) -> uint256: view\n    def isValidAddr(_addr: address) -> bool: view\n\ninterface MoonwellRewardDistributor:\n    def getOutstandingRewardsForUser(_user: address) -> DynArray[RewardWithMToken, MAX_MARKETS]: view\n\ninterface Appraiser:\n    def getUnderlyingUsdValue(_asset: address, _amount: uint256) -> uint256: view\n\ninterface VaultRegistry:\n    def isEarnVault(_vaultAddr: address) -> bool: view\n\ninterface WethContract:\n    def deposit(): payable\n\nstruct RewardWithMToken:\n    mToken: address\n    rewards: DynArray[RewardInfo, MAX_ASSETS]\n\nstruct RewardInfo:\n    emissionToken: address\n    totalAmount: uint256\n    supplySide: uint256\n    borrowSide: uint256\n\nevent MoonwellDeposit:\n    sender: indexed(address)\n    asset: indexed(address)\n    vaultToken: indexed(address)\n    assetAmountDeposited: uint256\n    usdValue: uint256\n    vaultTokenAmountReceived: uint256\n    recipient: address\n\nevent MoonwellWithdrawal:\n    sender: indexed(address)\n    asset: indexed(address)\n    vaultToken: indexed(address)\n    assetAmountReceived: uint256\n    usdValue: uint256\n    vaultTokenAmountBurned: uint256\n    recipient: address\n\n# moonwell\nMOONWELL_COMPTROLLER: public(immutable(address))\nWETH: public(immutable(address))\nRIPE_REGISTRY: public(immutable(address))\n\nMAX_MARKETS: constant(uint256) = 50\nMAX_ASSETS: constant(uint256) = 25\nMAX_TOKEN_PATH: constant(uint256) = 5\nMAX_PROOFS: constant(uint256) = 25\nHUNDRED_PERCENT: constant(uint256) = 100_00\n\n\n@deploy\ndef __init__(\n    _undyHq: address,\n    _moonwellComptroller: address,\n    _weth: address,\n    _ripeRegistry: address,\n):\n    addys.__init__(_undyHq)\n    yld.__init__(False)\n\n    assert empty(address) not in [_moonwellComptroller, _weth, _ripeRegistry] # dev: invalid addrs\n    MOONWELL_COMPTROLLER = _moonwellComptroller\n    WETH = _weth\n    RIPE_REGISTRY = _ripeRegistry\n\n\n@payable\n@external\ndef __default__():\n    pass\n\n\n@view\n@external\ndef hasCapability(_action: ws.ActionType) -> bool:\n    return _action in (\n        ws.ActionType.EARN_DEPOSIT | \n        ws.ActionType.EARN_WITHDRAW |\n        ws.ActionType.REWARDS\n    )\n\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    return [MOONWELL_COMPTROLLER]\n\n\n@view\n@external\ndef isYieldLego() -> bool:\n    return True\n\n\n@view\n@external\ndef isDexLego() -> bool:\n    return False\n\n\n###################\n# Underlying Data #\n###################\n\n\n# underlying asset\n\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    return self._getUnderlyingAsset(_vaultToken)\n\n\n@view\n@internal\ndef _getUnderlyingAsset(_vaultToken: address) -> address:\n    asset: address = yld.vaultToAsset[_vaultToken].underlyingAsset\n    if asset != empty(address):\n        return asset\n    return staticcall CompoundV2(_vaultToken).underlying()\n\n\n# underlying balances (both true and safe)\n\n\n@view\n@external\ndef getUnderlyingBalances(_vaultToken: address, _vaultTokenBalance: uint256) -> (uint256, uint256):\n    if _vaultTokenBalance == 0:\n        return 0, 0\n\n    trueUnderlying: uint256 = self._getUnderlyingAmount(_vaultToken, _vaultTokenBalance)\n    safeUnderlying: uint256 = self._getUnderlyingAmountSafe(_vaultToken, _vaultTokenBalance)\n    if safeUnderlying == 0:\n        safeUnderlying = trueUnderlying\n\n    return trueUnderlying, min(trueUnderlying, safeUnderlying)\n\n\n# underlying amount (true)\n\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    return self._getUnderlyingAmount(_vaultToken, _vaultTokenAmount)\n\n\n@view\n@internal\ndef _getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    return _vaultTokenAmount * staticcall CompoundV2(_vaultToken).exchangeRateStored() // (10 ** 18)\n\n\n# underlying amount (safe)\n\n\n@view\n@external\ndef getUnderlyingAmountSafe(_vaultToken: address, _vaultTokenBalance: uint256) -> uint256:\n    return self._getUnderlyingAmountSafe(_vaultToken, _vaultTokenBalance)\n\n\n@view\n@internal\ndef _getUnderlyingAmountSafe(_vaultToken: address, _vaultTokenBalance: uint256) -> uint256:\n    vaultInfo: ls.VaultTokenInfo = yld.vaultToAsset[_vaultToken]\n    if vaultInfo.decimals == 0:\n        return 0 # not registered\n\n    # safe underlying amount (using cached weighted average from snapshots)\n    return _vaultTokenBalance * vaultInfo.lastAveragePricePerShare // (10 ** vaultInfo.decimals)\n\n\n# underlying data (combined)\n\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> (address, uint256, uint256):\n    return self._getUnderlyingData(_vaultToken, _vaultTokenAmount, _appraiser)\n\n\n@view\n@internal\ndef _getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address) -> (address, uint256, uint256):\n    asset: address = self._getUnderlyingAsset(_vaultToken)\n    if asset == empty(address):\n        return empty(address), 0, 0 # invalid vault token\n    underlyingAmount: uint256 = self._getUnderlyingAmount(_vaultToken, _vaultTokenAmount)\n    usdValue: uint256 = self._getUsdValue(asset, underlyingAmount, _appraiser)\n    return asset, underlyingAmount, usdValue\n\n\n# usd value\n\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> uint256:\n    return self._getUsdValueOfVaultToken(_vaultToken, _vaultTokenAmount, _appraiser)\n\n\n@view\n@internal\ndef _getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address) -> uint256:\n    return self._getUnderlyingData(_vaultToken, _vaultTokenAmount, _appraiser)[2]\n\n\n@view\n@internal\ndef _getUsdValue(_asset: address, _amount: uint256, _appraiser: address) -> uint256:\n    appraiser: address = _appraiser\n    if _appraiser == empty(address):\n        appraiser = addys._getAppraiserAddr()\n    return staticcall Appraiser(appraiser).getUnderlyingUsdValue(_asset, _amount)\n\n\n###############\n# Other Utils #\n###############\n\n\n# basics\n\n\n@view\n@external\ndef isRebasing() -> bool:\n    return self._isRebasing()\n\n\n@view\n@internal\ndef _isRebasing() -> bool:\n    return False\n\n\n# price per share\n\n\n@view\n@external\ndef getPricePerShare(_vaultToken: address, _decimals: uint256 = 0) -> uint256:\n    decimals: uint256 = _decimals\n    if decimals == 0:\n        decimals = yld.vaultToAsset[_vaultToken].decimals\n    if decimals == 0:\n        decimals = convert(staticcall IERC20Detailed(_vaultToken).decimals(), uint256)\n    return self._getPricePerShare(_vaultToken, decimals)\n\n\n@view\n@internal\ndef _getPricePerShare(_vaultToken: address, _decimals: uint256) -> uint256:\n    return (10 ** _decimals) * staticcall CompoundV2(_vaultToken).exchangeRateStored() // (10 ** 18)\n\n\n# vault token amount\n\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    return _assetAmount * (10 ** 18) // staticcall CompoundV2(_vaultToken).exchangeRateStored()\n\n\n# total assets\n\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    return self._totalAssets(_vaultToken)\n\n\n@view\n@internal\ndef _totalAssets(_vaultToken: address) -> uint256:\n    return staticcall CompoundV2(_vaultToken).totalSupply() * staticcall CompoundV2(_vaultToken).exchangeRateStored() // (10 ** 18)\n\n\n# total borrows\n\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    return self._totalBorrows(_vaultToken)\n\n\n@view\n@internal\ndef _totalBorrows(_vaultToken: address) -> uint256:\n    return staticcall CompoundV2(_vaultToken).totalBorrows()\n\n\n# avail liquidity\n\n\n@view\n@external\ndef getAvailLiquidity(_vaultToken: address) -> uint256:\n    return staticcall CompoundV2(_vaultToken).getCash()\n\n\n# utilization\n\n\n@view\n@external\ndef getUtilizationRatio(_vaultToken: address) -> uint256:\n    totalAssets: uint256 = self._totalAssets(_vaultToken)\n    if totalAssets == 0:\n        return 0\n    totalBorrows: uint256 = self._totalBorrows(_vaultToken)\n    return totalBorrows * HUNDRED_PERCENT // totalAssets\n\n\n# extras\n\n\n@view\n@external\ndef isEligibleForYieldBonus(_asset: address) -> bool:\n    return False\n\n\n@view\n@external\ndef getWithdrawalFees(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    return 0\n\n\n################\n# Registration #\n################\n\n\n# can vault be registered\n\n\n@view\n@external\ndef canRegisterVaultToken(_asset: address, _vaultToken: address) -> bool:\n    return self._canRegisterVaultToken(_asset, _vaultToken)\n\n\n@view\n@internal\ndef _canRegisterVaultToken(_asset: address, _vaultToken: address) -> bool:\n    if empty(address) in [_asset, _vaultToken]:\n        return False\n    if staticcall CompoundV2(_vaultToken).underlying() != _asset:\n        return False\n    compMarkets: DynArray[address, MAX_MARKETS] = staticcall MoonwellComptroller(MOONWELL_COMPTROLLER).getAllMarkets()\n    return _vaultToken in compMarkets\n\n\n# register vault token locally\n\n\n@external\ndef registerVaultTokenLocally(_asset: address, _vaultAddr: address) -> ls.VaultTokenInfo:\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert self._canRegisterVaultToken(_asset, _vaultAddr) # dev: cannot register vault token\n    assert not yld._isAssetOpportunity(_asset, _vaultAddr) # dev: already registered\n    vaultInfo: ls.VaultTokenInfo = self._registerVaultTokenLocally(_asset, _vaultAddr)\n    self._registerVaultTokenGlobally(_asset, _vaultAddr, vaultInfo.decimals, addys._getLedgerAddr(), addys._getLegoBookAddr())\n    return vaultInfo\n\n\n@internal\ndef _registerVaultTokenLocally(_asset: address, _vaultAddr: address) -> ls.VaultTokenInfo:\n    assert extcall IERC20(_asset).approve(_vaultAddr, max_value(uint256), default_return_value=True) # dev: max approval failed\n    vaultInfo: ls.VaultTokenInfo = yld._addAssetOpportunity(_asset, _vaultAddr)\n    assert vaultInfo.decimals != 0 # dev: invalid vault token\n    return vaultInfo\n\n\n# remove vault token locally\n\n\n@external\ndef deregisterVaultTokenLocally(_asset: address, _vaultAddr: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert yld._isAssetOpportunity(_asset, _vaultAddr) # dev: already registered\n    self._deregisterVaultTokenLocally(_asset, _vaultAddr)\n\n\n@internal\ndef _deregisterVaultTokenLocally(_asset: address, _vaultAddr: address):\n    assert extcall IERC20(_asset).approve(_vaultAddr, 0, default_return_value=True) # dev: max approval failed\n    yld._removeAssetOpportunity(_asset, _vaultAddr)\n\n\n# ledger registration\n\n\n@internal\ndef _registerVaultTokenGlobally(_underlyingAsset: address, _vaultToken: address, _decimals: uint256, _ledger: address, _legoBook: address):\n    if not staticcall Ledger(_ledger).isRegisteredVaultToken(_vaultToken):\n        legoId: uint256 = staticcall Registry(_legoBook).getRegId(self)\n        extcall Ledger(_ledger).setVaultToken(_vaultToken, legoId, _underlyingAsset, _decimals, self._isRebasing())\n\n\n#################\n# Yield Actions #\n#################\n\n\n# access control\n\n\n@view\n@internal\ndef _isAllowedToPerformAction(_caller: address) -> bool:\n    # NOTE: important to not trust `_miniAddys` here, that's why getting ledger and vault registry from addys\n    if staticcall VaultRegistry(addys._getVaultRegistryAddr()).isEarnVault(_caller):\n        return True\n    if staticcall Ledger(addys._getLedgerAddr()).isUserWallet(_caller):\n        return True\n    return staticcall Registry(RIPE_REGISTRY).isValidAddr(_caller) # Ripe Endaoment is allowed\n\n\n# add price snapshot\n\n\n@external\ndef addPriceSnapshot(_vaultToken: address) -> bool:\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    vaultInfo: ls.VaultTokenInfo = yld.vaultToAsset[_vaultToken]\n    assert vaultInfo.decimals != 0 # dev: not registered\n    pricePerShare: uint256 = self._getPricePerShare(_vaultToken, vaultInfo.decimals)\n    return yld._addPriceSnapshot(_vaultToken, pricePerShare, vaultInfo.decimals)\n\n\n# deposit\n\n\n@external\ndef depositForYield(\n    _asset: address,\n    _amount: uint256,\n    _vaultAddr: address,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, address, uint256, uint256):\n    assert self._isAllowedToPerformAction(msg.sender) # dev: no perms\n    assert not yld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = yld._getMiniAddys(_miniAddys)\n    vaultInfo: ls.VaultTokenInfo = self._getVaultInfoOnDeposit(_asset, _vaultAddr, miniAddys.ledger, miniAddys.legoBook)\n\n    # pre balances\n    preLegoVaultBalance: uint256 = staticcall IERC20(_vaultAddr).balanceOf(self)\n    preLegoBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n\n    # transfer deposit asset to this contract\n    depositAmount: uint256 = min(_amount, staticcall IERC20(_asset).balanceOf(msg.sender))\n    assert depositAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_asset).transferFrom(msg.sender, self, depositAmount, default_return_value=True) # dev: transfer failed\n\n    # deposit assets into lego partner\n    assert extcall CompoundV2(_vaultAddr).mint(depositAmount) == 0 # dev: could not deposit into moonwell\n\n    # validate received vault tokens, transfer back to user\n    vaultTokenAmountReceived: uint256 = staticcall IERC20(_vaultAddr).balanceOf(self) - preLegoVaultBalance\n    assert vaultTokenAmountReceived != 0 # dev: no vault tokens received\n    assert extcall IERC20(_vaultAddr).transfer(_recipient, vaultTokenAmountReceived, default_return_value=True) # dev: transfer failed\n\n    # refund if full deposit didn't get through\n    currentLegoBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    refundAssetAmount: uint256 = 0\n    if currentLegoBalance > preLegoBalance:\n        refundAssetAmount = currentLegoBalance - preLegoBalance\n        assert extcall IERC20(_asset).transfer(msg.sender, refundAssetAmount, default_return_value=True) # dev: transfer failed\n        depositAmount -= refundAssetAmount\n\n    usdValue: uint256 = staticcall Appraiser(miniAddys.appraiser).getUnderlyingUsdValue(_asset, depositAmount)\n    log MoonwellDeposit(\n        sender = msg.sender,\n        asset = _asset,\n        vaultToken = _vaultAddr,\n        assetAmountDeposited = depositAmount,\n        usdValue = usdValue,\n        vaultTokenAmountReceived = vaultTokenAmountReceived,\n        recipient = _recipient,\n    )\n\n    # add price snapshot\n    pricePerShare: uint256 = self._getPricePerShare(_vaultAddr, vaultInfo.decimals)\n    yld._addPriceSnapshot(_vaultAddr, pricePerShare, vaultInfo.decimals)\n\n    return depositAmount, _vaultAddr, vaultTokenAmountReceived, usdValue\n\n\n# vault info on deposit\n\n\n@internal\ndef _getVaultInfoOnDeposit(_asset: address, _vaultAddr: address, _ledger: address, _legoBook: address) -> ls.VaultTokenInfo:\n    vaultInfo: ls.VaultTokenInfo = yld.vaultToAsset[_vaultAddr]\n    if vaultInfo.decimals == 0:\n        assert self._canRegisterVaultToken(_asset, _vaultAddr) # dev: cannot register vault token\n        vaultInfo = self._registerVaultTokenLocally(_asset, _vaultAddr)\n        self._registerVaultTokenGlobally(_asset, _vaultAddr, vaultInfo.decimals, _ledger, _legoBook)\n    else:\n        assert vaultInfo.underlyingAsset == _asset # dev: asset mismatch\n    return vaultInfo\n\n\n# withdraw\n\n\n@external\ndef withdrawFromYield(\n    _vaultToken: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, address, uint256, uint256):\n    assert self._isAllowedToPerformAction(msg.sender) # dev: no perms\n    assert not yld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = yld._getMiniAddys(_miniAddys)\n    vaultInfo: ls.VaultTokenInfo = self._getVaultInfoOnWithdrawal(_vaultToken, miniAddys.ledger, miniAddys.legoBook)\n\n    # pre balances\n    preLegoBalance: uint256 = staticcall IERC20(vaultInfo.underlyingAsset).balanceOf(self)\n    preLegoVaultBalance: uint256 = staticcall IERC20(_vaultToken).balanceOf(self)\n\n    # transfer vaults tokens to this contract\n    vaultTokenAmount: uint256 = min(_amount, staticcall IERC20(_vaultToken).balanceOf(msg.sender))\n    assert vaultTokenAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_vaultToken).transferFrom(msg.sender, self, vaultTokenAmount, default_return_value=True) # dev: transfer failed\n\n    # withdraw assets from lego partner\n    assert extcall CompoundV2(_vaultToken).redeem(max_value(uint256)) == 0 # dev: could not withdraw from moonwell\n\n    # when withdrawing weth, they give eth\n    if vaultInfo.underlyingAsset == WETH:\n        extcall WethContract(WETH).deposit(value=self.balance)\n\n    # validate received asset , transfer back to user\n    assetAmountReceived: uint256 = staticcall IERC20(vaultInfo.underlyingAsset).balanceOf(self) - preLegoBalance\n    assert assetAmountReceived != 0 # dev: no asset amount received\n    assert extcall IERC20(vaultInfo.underlyingAsset).transfer(_recipient, assetAmountReceived, default_return_value=True) # dev: transfer failed\n\n    # refund if full withdrawal didn't happen\n    currentLegoVaultBalance: uint256 = staticcall IERC20(_vaultToken).balanceOf(self)\n    refundVaultTokenAmount: uint256 = 0\n    if currentLegoVaultBalance > preLegoVaultBalance:\n        refundVaultTokenAmount = currentLegoVaultBalance - preLegoVaultBalance\n        assert extcall IERC20(_vaultToken).transfer(msg.sender, refundVaultTokenAmount, default_return_value=True) # dev: transfer failed\n        vaultTokenAmount -= refundVaultTokenAmount\n\n    usdValue: uint256 = staticcall Appraiser(miniAddys.appraiser).getUnderlyingUsdValue(vaultInfo.underlyingAsset, assetAmountReceived)\n    log MoonwellWithdrawal(\n        sender = msg.sender,\n        asset = vaultInfo.underlyingAsset,\n        vaultToken = _vaultToken,\n        assetAmountReceived = assetAmountReceived,\n        usdValue = usdValue,\n        vaultTokenAmountBurned = vaultTokenAmount,\n        recipient = _recipient,\n    )\n\n    # add price snapshot\n    pricePerShare: uint256 = self._getPricePerShare(_vaultToken, vaultInfo.decimals)\n    yld._addPriceSnapshot(_vaultToken, pricePerShare, vaultInfo.decimals)\n\n    return vaultTokenAmount, vaultInfo.underlyingAsset, assetAmountReceived, usdValue\n\n\n# vault info on withdrawal\n\n\n@internal\ndef _getVaultInfoOnWithdrawal(_vaultAddr: address, _ledger: address, _legoBook: address) -> ls.VaultTokenInfo:\n    vaultInfo: ls.VaultTokenInfo = yld.vaultToAsset[_vaultAddr]\n    if vaultInfo.decimals == 0:\n        asset: address = staticcall CompoundV2(_vaultAddr).underlying()\n        assert self._canRegisterVaultToken(asset, _vaultAddr) # dev: cannot register vault token\n        vaultInfo = self._registerVaultTokenLocally(asset, _vaultAddr)\n        self._registerVaultTokenGlobally(asset, _vaultAddr, vaultInfo.decimals, _ledger, _legoBook)\n    return vaultInfo\n\n\n#################\n# Claim Rewards #\n#################\n\n\n@external\ndef claimIncentives(\n    _user: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _proofs: DynArray[bytes32, MAX_PROOFS],\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    assert self._isAllowedToPerformAction(msg.sender) # dev: no perms\n    return self._claimIncentives(_user, _rewardToken, _rewardAmount, _miniAddys)\n\n\n@external\ndef claimRewards(\n    _user: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _extraData: bytes32,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    assert self._isAllowedToPerformAction(msg.sender) # dev: no perms\n    return self._claimIncentives(_user, _rewardToken, _rewardAmount, _miniAddys)\n\n\n@internal\ndef _claimIncentives(\n    _user: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    assert not yld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = yld._getMiniAddys(_miniAddys)\n    preBalance: uint256 = staticcall IERC20(_rewardToken).balanceOf(_user)\n\n    # claim rewards\n    extcall MoonwellComptroller(MOONWELL_COMPTROLLER).claimReward(_user)\n    rewardAmount: uint256 = staticcall IERC20(_rewardToken).balanceOf(_user) - preBalance\n    assert rewardAmount != 0 # dev: no rewards received\n\n    usdValue: uint256 = staticcall Appraiser(miniAddys.appraiser).getUnderlyingUsdValue(_rewardToken, rewardAmount)\n    return rewardAmount, usdValue\n\n\n# has claimable rewards\n\n\n@view\n@external\ndef hasClaimableRewards(_user: address) -> bool:\n    rewardDistributor: address = staticcall MoonwellComptroller(MOONWELL_COMPTROLLER).rewardDistributor()\n    rewardsWithMToken: DynArray[RewardWithMToken, MAX_MARKETS] = staticcall MoonwellRewardDistributor(rewardDistributor).getOutstandingRewardsForUser(_user)\n    for i: uint256 in range(len(rewardsWithMToken), bound=MAX_MARKETS):\n        rewardsInfo: DynArray[RewardInfo, MAX_ASSETS] = rewardsWithMToken[i].rewards\n        for j: uint256 in range(len(rewardsInfo), bound=MAX_ASSETS):\n            if rewardsInfo[j].totalAmount > 0:\n                return True\n    return False\n\n\n#########\n# Other #\n#########\n\n\n@view\n@external\ndef getAccessForLego(_user: address, _action: ws.ActionType) -> (address, String[64], uint256):\n    return empty(address), empty(String[64]), 0\n\n\n@external\ndef swapTokens(\n    _amountIn: uint256,\n    _minAmountOut: uint256,\n    _tokenPath: DynArray[address, MAX_TOKEN_PATH],\n    _poolPath: DynArray[address, MAX_TOKEN_PATH - 1],\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256):\n    return 0, 0, 0\n\n\n@external\ndef mintOrRedeemAsset(\n    _tokenIn: address,\n    _tokenOut: address,\n    _tokenInAmount: uint256,\n    _minAmountOut: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, bool, uint256):\n    return 0, 0, False, 0\n\n\n@external\ndef confirmMintOrRedeemAsset(\n    _tokenIn: address,\n    _tokenOut: address,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef addCollateral(\n    _asset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef removeCollateral(\n    _asset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef borrow(\n    _borrowAsset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef repayDebt(\n    _paymentAsset: address,\n    _paymentAmount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef addLiquidity(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _amountA: uint256,\n    _amountB: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _minLpAmount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (address, uint256, uint256, uint256, uint256):\n    return empty(address), 0, 0, 0, 0\n\n\n@external\ndef removeLiquidity(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpToken: address,\n    _lpAmount: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, uint256):\n    return 0, 0, 0, 0\n\n\n@external\ndef addLiquidityConcentrated(\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _tickLower: int24,\n    _tickUpper: int24,\n    _amountA: uint256,\n    _amountB: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, uint256, uint256):\n    return 0, 0, 0, 0, 0\n\n\n@external\ndef removeLiquidityConcentrated(\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _liqToRemove: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, bool, uint256):\n    return 0, 0, 0, False, 0",
            "sha256sum": "0657d3f99bcdd88806544c92d4b42dfa95fde1948cfe073f1394002c8529f6c8"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/legos/yield/Moonwell.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.3+commit.bff19ea2",
        "integrity": "0b4198563b17cb4527b853ac1fbfbf21667b38e4aacef2fd990412065a1a6b09"
      },
      "args": "00000000000000000000000044cf3c4f000dfd76a35d03298049d37be688d6f9000000000000000000000000fbb21d0380bee3312b33c4353c8936a0f13ef26c00000000000000000000000042000000000000000000000000000000000000060000000000000000000000006162df1b329e157479f8f1407e888260e0ec3d2b",
      "file": "contracts/legos/yield/Moonwell.vy"
    },
    "Morpho": {
      "address": "0x9a849C83B41c261974d438cc56ac48Fb5f568a52",
      "abi": [
        {
          "name": "MorphoDeposit",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountDeposited",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultTokenAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "MorphoWithdrawal",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultTokenAmountBurned",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "MorphoRewardsAddrSet",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LegoPauseModified",
          "inputs": [
            {
              "name": "isPaused",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LegoFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "balance",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "SnapShotPriceConfigSet",
          "inputs": [
            {
              "name": "minSnapshotDelay",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "maxNumSnapshots",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "maxUpsideDeviation",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "staleTime",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetOpportunityAdded",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultAddr",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetOpportunityRemoved",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultAddr",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PricePerShareSnapShotAdded",
          "inputs": [
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "totalSupply",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "pricePerShare",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "lastAveragePricePerShare",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddys",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "undyToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "hatchery",
                  "type": "address"
                },
                {
                  "name": "lootDistributor",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                },
                {
                  "name": "walletBackpack",
                  "type": "address"
                },
                {
                  "name": "billing",
                  "type": "address"
                },
                {
                  "name": "vaultRegistry",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUndyHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isLegoAsset",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssetOpportunities",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isAssetOpportunity",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getNumLegoAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pause",
          "inputs": [
            {
              "name": "_shouldPause",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFundsMany",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_assets",
              "type": "address[]"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getWeightedPricePerShare",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLatestSnapshot",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_pricePerShare",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "totalSupply",
                  "type": "uint256"
                },
                {
                  "name": "pricePerShare",
                  "type": "uint256"
                },
                {
                  "name": "lastUpdate",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setSnapShotPriceConfig",
          "inputs": [
            {
              "name": "_config",
              "type": "tuple",
              "components": [
                {
                  "name": "minSnapshotDelay",
                  "type": "uint256"
                },
                {
                  "name": "maxNumSnapshots",
                  "type": "uint256"
                },
                {
                  "name": "maxUpsideDeviation",
                  "type": "uint256"
                },
                {
                  "name": "staleTime",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidPriceConfig",
          "inputs": [
            {
              "name": "_config",
              "type": "tuple",
              "components": [
                {
                  "name": "minSnapshotDelay",
                  "type": "uint256"
                },
                {
                  "name": "maxNumSnapshots",
                  "type": "uint256"
                },
                {
                  "name": "maxUpsideDeviation",
                  "type": "uint256"
                },
                {
                  "name": "staleTime",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "vaultToAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "underlyingAsset",
                  "type": "address"
                },
                {
                  "name": "decimals",
                  "type": "uint256"
                },
                {
                  "name": "lastAveragePricePerShare",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assetOpportunities",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAssetOpportunity",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssetOpportunities",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assets",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "snapShotData",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "lastSnapShot",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "totalSupply",
                      "type": "uint256"
                    },
                    {
                      "name": "pricePerShare",
                      "type": "uint256"
                    },
                    {
                      "name": "lastUpdate",
                      "type": "uint256"
                    }
                  ]
                },
                {
                  "name": "nextIndex",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "snapShots",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "totalSupply",
                  "type": "uint256"
                },
                {
                  "name": "pricePerShare",
                  "type": "uint256"
                },
                {
                  "name": "lastUpdate",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "snapShotPriceConfig",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "minSnapshotDelay",
                  "type": "uint256"
                },
                {
                  "name": "maxNumSnapshots",
                  "type": "uint256"
                },
                {
                  "name": "maxUpsideDeviation",
                  "type": "uint256"
                },
                {
                  "name": "staleTime",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isPaused",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasCapability",
          "inputs": [
            {
              "name": "_action",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRegistries",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isYieldLego",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isDexLego",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAsset",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingBalances",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenBalance",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAmount",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAmountSafe",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenBalance",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingData",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingData",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            },
            {
              "name": "_appraiser",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValueOfVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValueOfVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            },
            {
              "name": "_appraiser",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isRebasing",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPricePerShare",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPricePerShare",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_decimals",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getVaultTokenAmount",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_assetAmount",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalAssets",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalBorrows",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAvailLiquidity",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUtilizationRatio",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isEligibleForYieldBonus",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getWithdrawalFees",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canRegisterVaultToken",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "registerVaultTokenLocally",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "underlyingAsset",
                  "type": "address"
                },
                {
                  "name": "decimals",
                  "type": "uint256"
                },
                {
                  "name": "lastAveragePricePerShare",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "deregisterVaultTokenLocally",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addPriceSnapshot",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositForYield",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositForYield",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawFromYield",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawFromYield",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimIncentives",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_proofs",
              "type": "bytes32[]"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimIncentives",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_proofs",
              "type": "bytes32[]"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasClaimableRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setMorphoRewardsAddr",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAccessForLego",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_action",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "string"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_tokenPath",
              "type": "address[]"
            },
            {
              "name": "_poolPath",
              "type": "address[]"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_tokenPath",
              "type": "address[]"
            },
            {
              "name": "_poolPath",
              "type": "address[]"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_tokenInAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_tokenInAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmMintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmMintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_borrowAsset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_borrowAsset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_paymentAsset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_paymentAsset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "morphoRewards",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MORPHO_FACTORY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MORPHO_FACTORY_LEGACY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "RIPE_REGISTRY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_undyHq",
              "type": "address"
            },
            {
              "name": "_morphoFactory",
              "type": "address"
            },
            {
              "name": "_morphoFactoryLegacy",
              "type": "address"
            },
            {
              "name": "_morphoRewardsAddr",
              "type": "address"
            },
            {
              "name": "_ripeRegistry",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "interfaces/WalletStructs.vyi": {
            "content": "# @version 0.4.3\n\nflag ActionType:\n    TRANSFER\n    EARN_DEPOSIT\n    EARN_WITHDRAW\n    EARN_REBALANCE\n    SWAP\n    MINT_REDEEM\n    CONFIRM_MINT_REDEEM\n    ADD_COLLATERAL\n    REMOVE_COLLATERAL\n    BORROW\n    REPAY_DEBT\n    REWARDS\n    ETH_TO_WETH\n    WETH_TO_ETH\n    ADD_LIQ\n    REMOVE_LIQ\n    ADD_LIQ_CONC\n    REMOVE_LIQ_CONC\n    PAY_CHEQUE\n\nstruct WalletAssetData:\n    assetBalance: uint256\n    usdValue: uint256\n    isYieldAsset: bool\n    lastPricePerShare: uint256\n\nstruct ActionData:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    billing: address\n    vaultRegistry: address\n    wallet: address\n    walletConfig: address\n    walletOwner: address\n    inEjectMode: bool\n    isFrozen: bool\n    lastTotalUsdValue: uint256\n    signer: address\n    isManager: bool\n    legoId: uint256\n    legoAddr: address\n    eth: address\n    weth: address\n\nstruct MiniAddys:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    appraiser: address",
            "sha256sum": "466493c129135c95470aaf70eeddc936632f7b0f813396e5a7ddc03bea9da518"
          },
          "interfaces/LegoPartner.vyi": {
            "content": "# @version 0.4.3\n\nfrom interfaces import WalletStructs as ws\n\nMAX_TOKEN_PATH: constant(uint256) = 5\nMAX_RECOVER_ASSETS: constant(uint256) = 20\nMAX_PROOFS: constant(uint256) = 25\n\n@external\ndef addLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _tickLower: int24, _tickUpper: int24, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef addLiquidity(_pool: address, _tokenA: address, _tokenB: address, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _minLpAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (address, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef removeLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _liqToRemove: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef removeLiquidity(_pool: address, _tokenA: address, _tokenB: address, _lpToken: address, _lpAmount: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef mintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _tokenInAmount: uint256, _minAmountOut: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef swapTokens(_amountIn: uint256, _minAmountOut: uint256, _tokenPath: DynArray[address, MAX_TOKEN_PATH], _poolPath: DynArray[address, MAX_TOKEN_PATH - 1], _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256):\n    ...\n\n@external\ndef depositForYield(_asset: address, _amount: uint256, _vaultAddr: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef withdrawFromYield(_vaultToken: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef confirmMintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef borrow(_borrowAsset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef repayDebt(_paymentAsset: address, _paymentAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef claimIncentives(_user: address, _rewardToken: address, _rewardAmount: uint256, _proofs: DynArray[bytes32, MAX_PROOFS], _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef removeCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef addCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@view\n@external\ndef getAccessForLego(_user: address, _action: ws.ActionType) -> (address, String[64], uint256):\n    ...\n\n@view\n@external\ndef hasCapability(_action: ws.ActionType) -> bool:\n    ...\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    ...\n\n@view\n@external\ndef isYieldLego() -> bool:\n    ...\n\n@view\n@external\ndef isDexLego() -> bool:\n    ...\n\n\n# common\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "f2afb7bd72d4301aea77bbe4177b7ae954ba6f6b76af363965993eb92ad0b715"
          },
          "interfaces/LegoStructs.vyi": {
            "content": "# @version 0.4.3\n\nstruct VaultTokenInfo:\n    underlyingAsset: address\n    decimals: uint256\n    lastAveragePricePerShare: uint256\n\nstruct SnapShotPriceConfig:\n    minSnapshotDelay: uint256\n    maxNumSnapshots: uint256\n    maxUpsideDeviation: uint256\n    staleTime: uint256\n\nstruct SingleSnapShot:\n    totalSupply: uint256\n    pricePerShare: uint256\n    lastUpdate: uint256\n\nstruct SnapShotData:\n    lastSnapShot: SingleSnapShot\n    nextIndex: uint256\n",
            "sha256sum": "8ae48be17d812d57fbd671bbf0593e8abf175ad0924e47c5997823cac19ec806"
          },
          "interfaces/YieldLego.vyi": {
            "content": "# @version 0.4.3\n\nfrom interfaces import LegoStructs as ls\n\n\n###################\n# Underlying Data #\n###################\n\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    ...\n\n\n@view\n@external\ndef getUnderlyingBalances(_vaultToken: address, _vaultTokenBalance: uint256) -> (uint256, uint256):\n    ...\n\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    ...\n\n\n@view\n@external\ndef getUnderlyingAmountSafe(_vaultToken: address, _vaultTokenBalance: uint256) -> uint256:\n    ...\n\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> (address, uint256, uint256):\n    ...\n\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> uint256:\n    ...\n\n\n###############\n# Other Utils #\n###############\n\n\n@view\n@external\ndef isRebasing() -> bool:\n    ...\n\n\n@view\n@external\ndef getPricePerShare(_vaultToken: address, _decimals: uint256 = 0) -> uint256:\n    ...\n\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef canRegisterVaultToken(_asset: address, _vaultToken: address) -> bool:\n    ...\n\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef getUtilizationRatio(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef getAvailLiquidity(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef isEligibleForYieldBonus(_asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef getWithdrawalFees(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    ...\n\n\n###################\n# Yield Lego Data #\n###################\n\n\n@view\n@external\ndef isLegoAsset(_asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, 40]:\n    ...\n\n\n@view\n@external\ndef getAssets() -> DynArray[address, 20]:\n    ...\n\n\n@view\n@external\ndef isAssetOpportunity(_asset: address, _vaultAddr: address) -> bool:\n    ...\n\n\n@view\n@external\ndef getNumLegoAssets() -> uint256:\n    ...\n\n\n@view\n@external\ndef assets(_index: uint256) -> address:\n    ...\n\n\n@view\n@external\ndef indexOfAsset(_asset: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef numAssets() -> uint256:\n    ...\n\n\n@view\n@external\ndef assetOpportunities(_asset: address, _index: uint256) -> address:\n    ...\n\n\n@view\n@external\ndef indexOfAssetOpportunity(_asset: address, _vaultAddr: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef numAssetOpportunities(_asset: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef vaultToAsset(_vaultAddr: address) -> ls.VaultTokenInfo:\n    ...\n\n\n# price snapshots\n\n\n@external\ndef addPriceSnapshot(_vaultToken: address) -> bool:\n    ...\n\n\n@view\n@external\ndef snapShotPriceConfig() -> ls.SnapShotPriceConfig:\n    ...\n\n\n@view\n@external\ndef snapShotData(_vaultToken: address) -> ls.SnapShotData:\n    ...\n\n\n@view\n@external\ndef snapShots(_vaultToken: address, _index: uint256) -> ls.SingleSnapShot:\n    ...\n\n\n@view\n@external\ndef getWeightedPricePerShare(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef getLatestSnapshot(_vaultToken: address, _pricePerShare: uint256) -> ls.SingleSnapShot:\n    ...\n\n\n@external\ndef setSnapShotPriceConfig(_config: ls.SnapShotPriceConfig):\n    ...\n",
            "sha256sum": "db91c139f6018f5218b389d08c8703bc16fb994aa948805dbfea27e072f382ec"
          },
          "contracts/modules/Addys.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\ninterface UndyHq:\n    def isValidAddr(_addr: address) -> bool: view\n    def getAddr(_regId: uint256) -> address: view\n    def undyToken() -> address: view\n\ninterface Switchboard:\n    def isSwitchboardAddr(_addr: address) -> bool: view\n\ninterface LegoBook:\n    def isLegoAddr(_addr: address) -> bool: view\n\nstruct Addys:\n    hq: address\n    undyToken: address\n    ledger: address\n    missionControl: address\n    legoBook: address\n    switchboard: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    walletBackpack: address\n    billing: address\n    vaultRegistry: address\n\n# hq\nUNDY_HQ_FOR_ADDYS: immutable(address)\n\n# core addys\nLEDGER_ID: constant(uint256) = 1\nMISSION_CONTROL_ID: constant(uint256) = 2\nLEGO_BOOK_ID: constant(uint256) = 3\nSWITCHBOARD_ID: constant(uint256) = 4\nHATCHERY_ID: constant(uint256) = 5\nLOOT_DISTRIBUTOR_ID: constant(uint256) = 6\nAPPRAISER_ID: constant(uint256) = 7\nWALLET_BACKPACK_ID: constant(uint256) = 8\nBILLING_ID: constant(uint256) = 9\nVAULT_REGISTRY_ID: constant(uint256) = 10\n\n\n@deploy\ndef __init__(_undyHq: address):\n    assert _undyHq != empty(address) # dev: invalid undy hq\n    UNDY_HQ_FOR_ADDYS = _undyHq\n\n\n########\n# Core #\n########\n\n\n@view\n@external\ndef getAddys() -> Addys:\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _getAddys(_addys: Addys = empty(Addys)) -> Addys:\n    if _addys.hq != empty(address):\n        return _addys\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _generateAddys() -> Addys:\n    hq: address = UNDY_HQ_FOR_ADDYS\n    return Addys(\n        hq = hq,\n        undyToken = staticcall UndyHq(hq).undyToken(),\n        ledger = staticcall UndyHq(hq).getAddr(LEDGER_ID),\n        missionControl = staticcall UndyHq(hq).getAddr(MISSION_CONTROL_ID),\n        legoBook = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID),\n        switchboard = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID),\n        hatchery = staticcall UndyHq(hq).getAddr(HATCHERY_ID),\n        lootDistributor = staticcall UndyHq(hq).getAddr(LOOT_DISTRIBUTOR_ID),\n        appraiser = staticcall UndyHq(hq).getAddr(APPRAISER_ID),\n        walletBackpack = staticcall UndyHq(hq).getAddr(WALLET_BACKPACK_ID),\n        billing = staticcall UndyHq(hq).getAddr(BILLING_ID),\n        vaultRegistry = staticcall UndyHq(hq).getAddr(VAULT_REGISTRY_ID),\n    )\n\n\n##########\n# Tokens #\n##########\n\n\n@view\n@internal\ndef _getUndyToken() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).undyToken()\n\n\n###########\n# Helpers #\n###########\n\n\n# undy hq\n\n\n@view\n@external\ndef getUndyHq() -> address:\n    return self._getUndyHq()\n\n\n@view\n@internal\ndef _getUndyHq() -> address:\n    return UNDY_HQ_FOR_ADDYS\n\n\n# utils\n\n\n@view\n@internal\ndef _isValidUndyAddr(_addr: address, _hq: address = empty(address)) -> bool:\n    hq: address = _hq\n    if _hq == empty(address):\n        hq = UNDY_HQ_FOR_ADDYS\n    \n    # core departments\n    if staticcall UndyHq(hq).isValidAddr(_addr):\n        return True\n\n    # lego book\n    legoBook: address = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID)\n    if legoBook != empty(address) and staticcall LegoBook(legoBook).isLegoAddr(_addr):\n        return True\n\n    # switchboard config\n    switchboard: address = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID)\n    if switchboard != empty(address) and staticcall Switchboard(switchboard).isSwitchboardAddr(_addr):\n        return True\n\n    return False\n\n\n@view\n@internal\ndef _isSwitchboardAddr(_addr: address) -> bool:\n    switchboard: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n    if switchboard == empty(address):\n        return False\n    return staticcall Switchboard(switchboard).isSwitchboardAddr(_addr)\n\n\n@view\n@internal\ndef _isLegoBookAddr(_addr: address) -> bool:\n    legoBook: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n    if legoBook == empty(address):\n        return False\n    return staticcall LegoBook(legoBook).isLegoAddr(_addr)\n\n\n###############\n# Departments #\n###############\n\n\n# ledger\n\n\n@view\n@internal\ndef _getLedgerId() -> uint256:\n    return LEDGER_ID\n\n\n@view\n@internal\ndef _getLedgerAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEDGER_ID)\n\n\n# mission control\n\n\n@view\n@internal\ndef _getMissionControlId() -> uint256:\n    return MISSION_CONTROL_ID\n\n\n@view\n@internal\ndef _getMissionControlAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(MISSION_CONTROL_ID)\n\n\n# lego book\n\n\n@view\n@internal\ndef _getLegoBookId() -> uint256:\n    return LEGO_BOOK_ID\n\n\n@view\n@internal\ndef _getLegoBookAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n\n\n# switchboard\n\n\n@view\n@internal\ndef _getSwitchboardId() -> uint256:\n    return SWITCHBOARD_ID\n\n\n@view\n@internal\ndef _getSwitchboardAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n\n\n# hatchery\n\n\n@view\n@internal\ndef _getHatcheryId() -> uint256:\n    return HATCHERY_ID\n\n\n@view\n@internal\ndef _getHatcheryAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(HATCHERY_ID)\n\n\n# loot distributor\n\n\n@view\n@internal\ndef _getLootDistributorId() -> uint256:\n    return LOOT_DISTRIBUTOR_ID\n\n\n@view\n@internal\ndef _getLootDistributorAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LOOT_DISTRIBUTOR_ID)\n\n\n# appraiser\n\n\n@view\n@internal\ndef _getAppraiserId() -> uint256:\n    return APPRAISER_ID\n\n\n@view\n@internal\ndef _getAppraiserAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(APPRAISER_ID)\n\n\n# wallet backpack\n\n\n@view\n@internal\ndef _getWalletBackpackId() -> uint256:\n    return WALLET_BACKPACK_ID\n\n\n@view\n@internal\ndef _getWalletBackpackAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(WALLET_BACKPACK_ID)\n\n\n# billing\n\n\n@view\n@internal\ndef _getBillingId() -> uint256:\n    return BILLING_ID\n\n\n@view\n@internal\ndef _getBillingAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(BILLING_ID)\n\n\n# vault registry\n\n\n@view\n@internal\ndef _getVaultRegistryId() -> uint256:\n    return VAULT_REGISTRY_ID\n\n\n@view\n@internal\ndef _getVaultRegistryAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(VAULT_REGISTRY_ID)",
            "sha256sum": "4df6b72db9bb417d1af81660175be1450cfb7b3575f3d17a5b8a130bff87b781"
          },
          "contracts/modules/YieldLegoData.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nuses: addys\n\nimport contracts.modules.Addys as addys\n\nfrom interfaces import WalletStructs as ws\nfrom interfaces import LegoStructs as ls\nfrom ethereum.ercs import IERC20\nfrom ethereum.ercs import IERC20Detailed\n\nevent AssetOpportunityAdded:\n    asset: indexed(address)\n    vaultAddr: indexed(address)\n\nevent AssetOpportunityRemoved:\n    asset: indexed(address)\n    vaultAddr: indexed(address)\n\nevent LegoPauseModified:\n    isPaused: bool\n\nevent LegoFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    balance: uint256\n\nevent PricePerShareSnapShotAdded:\n    vaultToken: indexed(address)\n    totalSupply: uint256\n    pricePerShare: uint256\n    lastAveragePricePerShare: uint256\n\nevent SnapShotPriceConfigSet:\n    minSnapshotDelay: uint256\n    maxNumSnapshots: uint256\n    maxUpsideDeviation: uint256\n    staleTime: uint256\n\n# core\nvaultToAsset: public(HashMap[address, ls.VaultTokenInfo]) # vault addr -> data\n\n# asset opportunities\nassetOpportunities: public(HashMap[address, HashMap[uint256, address]]) # asset -> index -> vault addr\nindexOfAssetOpportunity: public(HashMap[address, HashMap[address, uint256]]) # asset -> vault addr -> index\nnumAssetOpportunities: public(HashMap[address, uint256]) # asset -> number of opportunities\n\n# lego assets (iterable)\nassets: public(HashMap[uint256, address]) # index -> asset\nindexOfAsset: public(HashMap[address, uint256]) # asset -> index\nnumAssets: public(uint256) # num assets\n\n# price snapshots\nsnapShotData: public(HashMap[address, ls.SnapShotData]) # vault token -> data\nsnapShots: public(HashMap[address, HashMap[uint256, ls.SingleSnapShot]]) # vault token -> index -> snapshot\nsnapShotPriceConfig: public(ls.SnapShotPriceConfig) # config\n\nisPaused: public(bool)\n\nMAX_VAULTS: constant(uint256) = 40\nMAX_ASSETS: constant(uint256) = 20\nMAX_RECOVER_ASSETS: constant(uint256) = 20\nONE_DAY_SECONDS: constant(uint256) = 60 * 60 * 24\nONE_WEEK_SECONDS: constant(uint256) = ONE_DAY_SECONDS * 7\nHUNDRED_PERCENT: constant(uint256) = 100_00\n\n\n@deploy\ndef __init__(_shouldPause: bool):\n    self.isPaused = _shouldPause\n    self.numAssets = 1 # not using 0 index\n\n    # default snapshot price config\n    self.snapShotPriceConfig = ls.SnapShotPriceConfig(\n        minSnapshotDelay = 60 * 10, # 10 minutes\n        maxNumSnapshots = 20,\n        maxUpsideDeviation = 10_00, # 10%\n        staleTime = ONE_DAY_SECONDS, # 1 day\n    )\n\n\n#########\n# Views #\n#########\n\n\n# is lego asset\n\n\n@view\n@external\ndef isLegoAsset(_asset: address) -> bool:\n    return self._isLegoAsset(_asset)\n\n\n@view\n@internal\ndef _isLegoAsset(_asset: address) -> bool:\n    return self.indexOfAsset[_asset] != 0\n\n\n# vault opportunities\n\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, MAX_VAULTS]:\n    numOpportunities: uint256 = self.numAssetOpportunities[_asset]\n    if numOpportunities == 0:\n        return []\n    opportunities: DynArray[address, MAX_VAULTS] = []\n    for i: uint256 in range(1, numOpportunities, bound=MAX_VAULTS):\n        opportunities.append(self.assetOpportunities[_asset][i])\n    return opportunities\n\n\n# all assets registered\n\n\n@view\n@external\ndef getAssets() -> DynArray[address, MAX_ASSETS]:\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return []\n    assets: DynArray[address, MAX_ASSETS] = []\n    for i: uint256 in range(1, numAssets, bound=MAX_ASSETS):\n        assets.append(self.assets[i])\n    return assets\n\n\n################\n# Registration #\n################\n\n\n@view\n@external\ndef isAssetOpportunity(_asset: address, _vaultAddr: address) -> bool:\n    return self._isAssetOpportunity(_asset, _vaultAddr)\n\n\n@view\n@internal\ndef _isAssetOpportunity(_asset: address, _vaultAddr: address) -> bool:\n    return self.indexOfAssetOpportunity[_asset][_vaultAddr] != 0\n\n\n# add asset opportunity\n\n\n@internal\ndef _addAssetOpportunity(_asset: address, _vaultAddr: address) -> ls.VaultTokenInfo:\n    if self.indexOfAssetOpportunity[_asset][_vaultAddr] != 0:\n        return self.vaultToAsset[_vaultAddr]\n\n    if empty(address) in [_asset, _vaultAddr]:\n        return empty(ls.VaultTokenInfo)\n\n    # add asset opportunity\n    aid: uint256 = self.numAssetOpportunities[_asset]\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.assetOpportunities[_asset][aid] = _vaultAddr\n    self.indexOfAssetOpportunity[_asset][_vaultAddr] = aid\n    self.numAssetOpportunities[_asset] = aid + 1\n\n    # add mapping\n    vaultInfo: ls.VaultTokenInfo = ls.VaultTokenInfo(\n        underlyingAsset = _asset,\n        decimals = convert(staticcall IERC20Detailed(_vaultAddr).decimals(), uint256),\n        lastAveragePricePerShare = 0,\n    )\n    self.vaultToAsset[_vaultAddr] = vaultInfo\n\n    # add asset\n    self._addAsset(_asset)\n\n    log AssetOpportunityAdded(asset=_asset, vaultAddr=_vaultAddr)\n    return vaultInfo\n\n\n# remove asset opportunity\n\n\n@internal\ndef _removeAssetOpportunity(_asset: address, _vaultAddr: address):\n    numOpportunities: uint256 = self.numAssetOpportunities[_asset]\n    if numOpportunities == 0:\n        return\n\n    targetIndex: uint256 = self.indexOfAssetOpportunity[_asset][_vaultAddr]\n    if targetIndex == 0:\n        return\n\n    # update data\n    lastIndex: uint256 = numOpportunities - 1\n    self.numAssetOpportunities[_asset] = lastIndex\n    self.indexOfAssetOpportunity[_asset][_vaultAddr] = 0\n\n    self.vaultToAsset[_vaultAddr] = empty(ls.VaultTokenInfo)\n\n    # clear all snapshot data for the vault token to prevent contamination on re-add\n    self.snapShotData[_vaultAddr] = empty(ls.SnapShotData)\n\n    # clear all historical snapshots\n    config: ls.SnapShotPriceConfig = self.snapShotPriceConfig\n    for i: uint256 in range(config.maxNumSnapshots, bound=max_value(uint256)):\n        if i >= config.maxNumSnapshots:\n            break\n        self.snapShots[_vaultAddr][i] = empty(ls.SingleSnapShot)\n\n    # shift to replace the removed one\n    if targetIndex != lastIndex:\n        lastVaultAddr: address = self.assetOpportunities[_asset][lastIndex]\n        self.assetOpportunities[_asset][targetIndex] = lastVaultAddr\n        self.indexOfAssetOpportunity[_asset][lastVaultAddr] = targetIndex\n\n    # remove asset\n    if lastIndex <= 1:\n        self._removeAsset(_asset)\n\n    log AssetOpportunityRemoved(asset=_asset, vaultAddr=_vaultAddr)\n\n\n# add asset\n\n\n@internal\ndef _addAsset(_asset: address):\n    if self.indexOfAsset[_asset] != 0:\n        return\n\n    aid: uint256 = self.numAssets\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.assets[aid] = _asset\n    self.indexOfAsset[_asset] = aid\n    self.numAssets = aid + 1\n\n\n# remove asset\n\n\n@internal\ndef _removeAsset(_asset: address):\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return\n\n    targetIndex: uint256 = self.indexOfAsset[_asset]\n    if targetIndex == 0:\n        return\n\n    # update data\n    lastIndex: uint256 = numAssets - 1\n    self.numAssets = lastIndex\n    self.indexOfAsset[_asset] = 0\n\n    # shift to replace the removed one\n    if targetIndex != lastIndex:\n        lastAsset: address = self.assets[lastIndex]\n        self.assets[targetIndex] = lastAsset\n        self.indexOfAsset[lastAsset] = targetIndex\n\n\n# num lego assets (true number, use `numAssets` for iteration)\n\n\n@view\n@external\ndef getNumLegoAssets() -> uint256:\n    return self._getNumLegoAssets()\n\n\n@view\n@internal\ndef _getNumLegoAssets() -> uint256:\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return 0\n    return numAssets - 1\n\n\n###########\n# General #\n###########\n\n\n# fill mini addys\n\n\n@view\n@internal\ndef _getMiniAddys(_miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> ws.MiniAddys:\n    if _miniAddys.ledger != empty(address):\n        return _miniAddys\n    return ws.MiniAddys(\n        ledger = addys._getLedgerAddr(),\n        missionControl = addys._getMissionControlAddr(),\n        legoBook = addys._getLegoBookAddr(),\n        appraiser = addys._getAppraiserAddr(),\n    )\n\n\n# activate\n\n\n@external\ndef pause(_shouldPause: bool):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert _shouldPause != self.isPaused # dev: no change\n    self.isPaused = _shouldPause\n    log LegoPauseModified(isPaused=_shouldPause)\n\n\n# recover funds\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    self._recoverFunds(_recipient, _asset)\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, MAX_RECOVER_ASSETS]):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    for a: address in _assets:\n        self._recoverFunds(_recipient, a)\n\n\n@internal\ndef _recoverFunds(_recipient: address, _asset: address):\n    assert empty(address) not in [_recipient, _asset] # dev: invalid recipient or asset\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    assert balance != 0 # dev: nothing to recover\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log LegoFundsRecovered(asset=_asset, recipient=_recipient, balance=balance)\n\n\n###################\n# Price Snapshots #\n###################\n\n\n# add price snapshot\n\n\n@internal\ndef _addPriceSnapshot(_vaultToken: address, _pricePerShare: uint256, _vaultTokenDecimals: uint256) -> bool:\n    config: ls.SnapShotPriceConfig = self.snapShotPriceConfig\n    if config.maxNumSnapshots == 0:\n        return False\n\n    data: ls.SnapShotData = self.snapShotData[_vaultToken]\n\n    # already have snapshot for this time\n    if data.lastSnapShot.lastUpdate == block.timestamp:\n        return False\n\n    # check if snapshot is too recent\n    if data.lastSnapShot.lastUpdate + config.minSnapshotDelay > block.timestamp:\n        return False\n\n    # create and store new snapshot\n    newSnapshot: ls.SingleSnapShot = self._getLatestSnapshot(_vaultToken, _pricePerShare, _vaultTokenDecimals, data.lastSnapShot, config)\n    data.lastSnapShot = newSnapshot\n    self.snapShots[_vaultToken][data.nextIndex] = newSnapshot\n\n    # update index\n    data.nextIndex += 1\n    if data.nextIndex >= config.maxNumSnapshots:\n        data.nextIndex = 0\n\n    # save snap shot data\n    self.snapShotData[_vaultToken] = data\n\n    # update cached weighted average price per share\n    lastAveragePricePerShare: uint256 = self._getWeightedPricePerShare(_vaultToken, _pricePerShare)\n    self.vaultToAsset[_vaultToken].lastAveragePricePerShare = lastAveragePricePerShare\n\n    log PricePerShareSnapShotAdded(\n        vaultToken = _vaultToken,\n        totalSupply = newSnapshot.totalSupply,\n        pricePerShare = newSnapshot.pricePerShare,\n        lastAveragePricePerShare = lastAveragePricePerShare,\n    )\n    return True\n\n\n# weighted price per share\n\n\n@view\n@external\ndef getWeightedPricePerShare(_vaultToken: address) -> uint256:\n    data: ls.SnapShotData = self.snapShotData[_vaultToken]\n    return self._getWeightedPricePerShare(_vaultToken, data.lastSnapShot.pricePerShare)\n\n\n@view\n@internal\ndef _getWeightedPricePerShare(_vaultToken: address, _lastPricePerShare: uint256) -> uint256:\n    config: ls.SnapShotPriceConfig = self.snapShotPriceConfig\n    if config.maxNumSnapshots == 0:\n        return 0\n\n    # calculate weighted average price using all valid snapshots\n    numerator: uint256 = 0\n    denominator: uint256 = 0\n    for i: uint256 in range(config.maxNumSnapshots, bound=max_value(uint256)):\n\n        snapShot: ls.SingleSnapShot = self.snapShots[_vaultToken][i]\n        if snapShot.pricePerShare == 0 or snapShot.totalSupply == 0 or snapShot.lastUpdate == 0:\n            continue\n\n        # too stale, skip\n        if config.staleTime != 0 and block.timestamp > snapShot.lastUpdate + config.staleTime:\n            continue\n\n        numerator += (snapShot.totalSupply * snapShot.pricePerShare)\n        denominator += snapShot.totalSupply\n\n    # weighted price per share\n    weightedPricePerShare: uint256 = 0\n    if numerator != 0:\n        weightedPricePerShare = numerator // denominator\n    else:\n        weightedPricePerShare = _lastPricePerShare\n\n    return weightedPricePerShare\n\n\n# latest snapshot\n\n\n@view\n@external\ndef getLatestSnapshot(_vaultToken: address, _pricePerShare: uint256) -> ls.SingleSnapShot:\n    data: ls.SnapShotData = self.snapShotData[_vaultToken]\n    config: ls.SnapShotPriceConfig = self.snapShotPriceConfig\n    vaultTokenDecimals: uint256 = self.vaultToAsset[_vaultToken].decimals\n    return self._getLatestSnapshot(_vaultToken, _pricePerShare, vaultTokenDecimals, data.lastSnapShot, config)\n\n\n@view\n@internal\ndef _getLatestSnapshot(\n    _vaultToken: address,\n    _pricePerShare: uint256,\n    _vaultTokenDecimals: uint256,\n    _lastSnapShot: ls.SingleSnapShot,\n    _config: ls.SnapShotPriceConfig,\n) -> ls.SingleSnapShot:\n\n    # total supply (adjusted)\n    totalSupply: uint256 = staticcall IERC20(_vaultToken).totalSupply() // (10 ** _vaultTokenDecimals)\n    if totalSupply == 0:\n        totalSupply = 1\n\n    # throttle upside (extra safety check)\n    pricePerShare: uint256 = self._throttleUpside(_pricePerShare, _lastSnapShot.pricePerShare, _config.maxUpsideDeviation)\n\n    return ls.SingleSnapShot(\n        totalSupply = totalSupply,\n        pricePerShare = pricePerShare,\n        lastUpdate = block.timestamp,\n    )\n\n\n@view\n@internal\ndef _throttleUpside(_newValue: uint256, _prevValue: uint256, _maxUpside: uint256) -> uint256:\n    if _maxUpside == 0 or _prevValue == 0 or _newValue == 0:\n        return _newValue\n    maxPricePerShare: uint256 = _prevValue + (_prevValue * _maxUpside // HUNDRED_PERCENT)\n    return min(_newValue, maxPricePerShare)\n\n\n# snapshot price config\n\n\n@external\ndef setSnapShotPriceConfig(_config: ls.SnapShotPriceConfig):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert self._isValidPriceConfig(_config) # dev: invalid config\n    self.snapShotPriceConfig = _config\n    log SnapShotPriceConfigSet(\n        minSnapshotDelay=_config.minSnapshotDelay,\n        maxNumSnapshots=_config.maxNumSnapshots,\n        maxUpsideDeviation=_config.maxUpsideDeviation,\n        staleTime=_config.staleTime\n    )\n\n\n@view\n@external\ndef isValidPriceConfig(_config: ls.SnapShotPriceConfig) -> bool:\n    return self._isValidPriceConfig(_config)\n\n\n@view\n@internal\ndef _isValidPriceConfig(_config: ls.SnapShotPriceConfig) -> bool:\n    if _config.minSnapshotDelay > ONE_WEEK_SECONDS:\n        return False\n    if _config.maxNumSnapshots == 0 or _config.maxNumSnapshots > 25:\n        return False\n    if _config.maxUpsideDeviation > HUNDRED_PERCENT:\n        return False\n    return _config.staleTime < ONE_WEEK_SECONDS",
            "sha256sum": "50440c96dc8a7af22e7ad927bb6d3e308f137d5d3632e633e084b05510c94c28"
          },
          "contracts/legos/yield/Morpho.vy": {
            "content": "#     __   __ ___ _______ ___     ______       ___     _______ _______ _______ \n#    |  | |  |   |       |   |   |      |     |   |   |       |       |       |\n#    |  |_|  |   |    ___|   |   |  _    |    |   |   |    ___|    ___|   _   |\n#    |       |   |   |___|   |   | | |   |    |   |   |   |___|   | __|  | |  |\n#    |_     _|   |    ___|   |___| |_|   |    |   |___|    ___|   ||  |  |_|  |\n#      |   | |   |   |___|       |       |    |       |   |___|   |_| |       |\n#      |___| |___|_______|_______|______|     |_______|_______|_______|_______|\n#                                                                       \n#     \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n#     \u2551  ** Morpho Lego **                      \u2551\n#     \u2551  Integration with Morpho Protocol.      \u2551\n#     \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n#\n#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nimplements: Lego\nimplements: YieldLego\n\nexports: addys.__interface__\nexports: yld.__interface__\n\ninitializes: addys\ninitializes: yld[addys := addys]\n\nfrom interfaces import LegoPartner as Lego\nfrom interfaces import YieldLego as YieldLego\nfrom interfaces import WalletStructs as ws\nfrom interfaces import LegoStructs as ls\n\nimport contracts.modules.Addys as addys\nimport contracts.modules.YieldLegoData as yld\n\nfrom ethereum.ercs import IERC20\nfrom ethereum.ercs import IERC4626\nfrom ethereum.ercs import IERC20Detailed\n\ninterface Ledger:\n    def setVaultToken(_vaultToken: address, _legoId: uint256, _underlyingAsset: address, _decimals: uint256, _isRebasing: bool): nonpayable\n    def isRegisteredVaultToken(_vaultToken: address) -> bool: view\n    def isUserWallet(_user: address) -> bool: view\n\ninterface MorphoBlue:\n    def market(_id: bytes32) -> MorphoMarket: view\n    def position(_id: bytes32, _user: address) -> MorphoPosition: view\n    def idToMarketParams(_id: bytes32) -> MarketParams: view\n\ninterface MetaMorphoV1:\n    def MORPHO() -> address: view\n    def withdrawQueue(_index: uint256) -> bytes32: view\n    def withdrawQueueLength() -> uint256: view\n\ninterface Registry:\n    def getRegId(_addr: address) -> uint256: view\n    def isValidAddr(_addr: address) -> bool: view\n\ninterface MorphoRewardsDistributor:\n    def claim(_user: address, _rewardToken: address, _claimable: uint256, _proofs: DynArray[bytes32, MAX_PROOFS]) -> uint256: nonpayable\n\ninterface Appraiser:\n    def getUnderlyingUsdValue(_asset: address, _amount: uint256) -> uint256: view\n\ninterface VaultRegistry:\n    def isEarnVault(_vaultAddr: address) -> bool: view\n\ninterface MetaMorphoFactory:\n    def isMetaMorpho(_vault: address) -> bool: view\n\nstruct MorphoMarket:\n    totalSupplyAssets: uint128\n    totalSupplyShares: uint128\n    totalBorrowAssets: uint128\n    totalBorrowShares: uint128\n    lastUpdate: uint128\n    fee: uint128\n\nstruct MorphoPosition:\n    supplyShares: uint256\n    borrowShares: uint128\n    collateral: uint128\n\nstruct MarketParams:\n    loanToken: address\n    collateralToken: address\n    oracle: address\n    irm: address\n    lltv: uint256\n\nevent MorphoDeposit:\n    sender: indexed(address)\n    asset: indexed(address)\n    vaultToken: indexed(address)\n    assetAmountDeposited: uint256\n    usdValue: uint256\n    vaultTokenAmountReceived: uint256\n    recipient: address\n\nevent MorphoWithdrawal:\n    sender: indexed(address)\n    asset: indexed(address)\n    vaultToken: indexed(address)\n    assetAmountReceived: uint256\n    usdValue: uint256\n    vaultTokenAmountBurned: uint256\n    recipient: address\n\nevent MorphoRewardsAddrSet:\n    addr: address\n\n# rewards contract\nmorphoRewards: public(address)\n\n# morpho\nMORPHO_FACTORY: public(immutable(address))\nMORPHO_FACTORY_LEGACY: public(immutable(address))\nRIPE_REGISTRY: public(immutable(address))\n\nMAX_TOKEN_PATH: constant(uint256) = 5\nMAX_PROOFS: constant(uint256) = 25\nHUNDRED_PERCENT: constant(uint256) = 100_00\n\n\n@deploy\ndef __init__(\n    _undyHq: address,\n    _morphoFactory: address,\n    _morphoFactoryLegacy: address,\n    _morphoRewardsAddr: address,\n    _ripeRegistry: address,\n):\n    addys.__init__(_undyHq)\n    yld.__init__(False)\n\n    assert empty(address) not in [_morphoFactory, _morphoFactoryLegacy, _ripeRegistry] # dev: invalid addrs\n    MORPHO_FACTORY = _morphoFactory\n    MORPHO_FACTORY_LEGACY = _morphoFactoryLegacy\n    self.morphoRewards = _morphoRewardsAddr\n\n    RIPE_REGISTRY = _ripeRegistry\n\n\n@view\n@external\ndef hasCapability(_action: ws.ActionType) -> bool:\n    return _action in (\n        ws.ActionType.EARN_DEPOSIT | \n        ws.ActionType.EARN_WITHDRAW |\n        ws.ActionType.REWARDS\n    )\n\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    return [MORPHO_FACTORY, MORPHO_FACTORY_LEGACY]\n\n\n@view\n@external\ndef isYieldLego() -> bool:\n    return True\n\n\n@view\n@external\ndef isDexLego() -> bool:\n    return False\n\n\n###################\n# Underlying Data #\n###################\n\n\n# underlying asset\n\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    return self._getUnderlyingAsset(_vaultToken)\n\n\n@view\n@internal\ndef _getUnderlyingAsset(_vaultToken: address) -> address:\n    asset: address = yld.vaultToAsset[_vaultToken].underlyingAsset\n    if asset != empty(address):\n        return asset\n    return staticcall IERC4626(_vaultToken).asset()\n\n\n# underlying balances (both true and safe)\n\n\n@view\n@external\ndef getUnderlyingBalances(_vaultToken: address, _vaultTokenBalance: uint256) -> (uint256, uint256):\n    if _vaultTokenBalance == 0:\n        return 0, 0\n\n    trueUnderlying: uint256 = self._getUnderlyingAmount(_vaultToken, _vaultTokenBalance)\n    safeUnderlying: uint256 = self._getUnderlyingAmountSafe(_vaultToken, _vaultTokenBalance)\n    if safeUnderlying == 0:\n        safeUnderlying = trueUnderlying\n\n    return trueUnderlying, min(trueUnderlying, safeUnderlying)\n\n\n# underlying amount (true)\n\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    return self._getUnderlyingAmount(_vaultToken, _vaultTokenAmount)\n\n\n@view\n@internal\ndef _getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    return staticcall IERC4626(_vaultToken).previewRedeem(_vaultTokenAmount)\n\n\n# underlying amount (safe)\n\n\n@view\n@external\ndef getUnderlyingAmountSafe(_vaultToken: address, _vaultTokenBalance: uint256) -> uint256:\n    return self._getUnderlyingAmountSafe(_vaultToken, _vaultTokenBalance)\n\n\n@view\n@internal\ndef _getUnderlyingAmountSafe(_vaultToken: address, _vaultTokenBalance: uint256) -> uint256:\n    vaultInfo: ls.VaultTokenInfo = yld.vaultToAsset[_vaultToken]\n    if vaultInfo.decimals == 0:\n        return 0 # not registered\n\n    # safe underlying amount (using cached weighted average from snapshots)\n    return _vaultTokenBalance * vaultInfo.lastAveragePricePerShare // (10 ** vaultInfo.decimals)\n\n\n# underlying data (combined)\n\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> (address, uint256, uint256):\n    return self._getUnderlyingData(_vaultToken, _vaultTokenAmount, _appraiser)\n\n\n@view\n@internal\ndef _getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address) -> (address, uint256, uint256):\n    asset: address = self._getUnderlyingAsset(_vaultToken)\n    if asset == empty(address):\n        return empty(address), 0, 0 # invalid vault token\n    underlyingAmount: uint256 = self._getUnderlyingAmount(_vaultToken, _vaultTokenAmount)\n    usdValue: uint256 = self._getUsdValue(asset, underlyingAmount, _appraiser)\n    return asset, underlyingAmount, usdValue\n\n\n# usd value\n\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> uint256:\n    return self._getUsdValueOfVaultToken(_vaultToken, _vaultTokenAmount, _appraiser)\n\n\n@view\n@internal\ndef _getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address) -> uint256:\n    return self._getUnderlyingData(_vaultToken, _vaultTokenAmount, _appraiser)[2]\n\n\n@view\n@internal\ndef _getUsdValue(_asset: address, _amount: uint256, _appraiser: address) -> uint256:\n    appraiser: address = _appraiser\n    if _appraiser == empty(address):\n        appraiser = addys._getAppraiserAddr()\n    return staticcall Appraiser(appraiser).getUnderlyingUsdValue(_asset, _amount)\n\n\n###############\n# Other Utils #\n###############\n\n\n# basics\n\n\n@view\n@external\ndef isRebasing() -> bool:\n    return self._isRebasing()\n\n\n@view\n@internal\ndef _isRebasing() -> bool:\n    return False\n\n\n# price per share\n\n\n@view\n@external\ndef getPricePerShare(_vaultToken: address, _decimals: uint256 = 0) -> uint256:\n    decimals: uint256 = _decimals\n    if decimals == 0:\n        decimals = yld.vaultToAsset[_vaultToken].decimals\n    if decimals == 0:\n        decimals = convert(staticcall IERC20Detailed(_vaultToken).decimals(), uint256)\n    return self._getPricePerShare(_vaultToken, decimals)\n\n\n@view\n@internal\ndef _getPricePerShare(_vaultToken: address, _decimals: uint256) -> uint256:\n    return staticcall IERC4626(_vaultToken).previewRedeem(10 ** _decimals)\n\n\n# vault token amount\n\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    return staticcall IERC4626(_vaultToken).convertToShares(_assetAmount)\n\n\n# total assets\n\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    return self._totalAssets(_vaultToken)\n\n\n@view\n@internal\ndef _totalAssets(_vaultToken: address) -> uint256:\n    return staticcall IERC4626(_vaultToken).totalAssets()\n\n\n# total borrows (assets lent out from underlying markets)\n\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    return self._totalBorrows(_vaultToken)\n\n\n@view\n@internal\ndef _totalBorrows(_vaultToken: address) -> uint256:\n    morpho: address = staticcall MetaMorphoV1(_vaultToken).MORPHO()\n    queueLen: uint256 = staticcall MetaMorphoV1(_vaultToken).withdrawQueueLength()\n\n    # iterate through withdraw queue markets\n    totalBorrows: uint256 = 0\n    for i: uint256 in range(queueLen, bound=max_value(uint256)):\n        marketId: bytes32 = staticcall MetaMorphoV1(_vaultToken).withdrawQueue(i)\n\n        # vault's position in market\n        pos: MorphoPosition = staticcall MorphoBlue(morpho).position(marketId, _vaultToken)\n        if pos.supplyShares == 0:\n            continue\n\n        # market data\n        mkt: MorphoMarket = staticcall MorphoBlue(morpho).market(marketId)\n        if mkt.totalSupplyShares == 0 or mkt.totalSupplyAssets == 0:\n            continue\n\n        # convert once, reuse\n        totalSupplyAssets: uint256 = convert(mkt.totalSupplyAssets, uint256)\n        totalSupplyShares: uint256 = convert(mkt.totalSupplyShares, uint256)\n        totalBorrowAssets: uint256 = convert(mkt.totalBorrowAssets, uint256)\n\n        # calculate vault's supply assets from shares\n        vaultSupplyAssets: uint256 = pos.supplyShares * totalSupplyAssets // totalSupplyShares\n\n        # vault's share of borrows = (vaultSupply / totalSupply) * totalBorrows\n        vaultShareOfBorrows: uint256 = vaultSupplyAssets * totalBorrowAssets // totalSupplyAssets\n        totalBorrows += vaultShareOfBorrows\n\n    return totalBorrows\n\n\n# avail liquidity\n\n\n@view\n@external\ndef getAvailLiquidity(_vaultToken: address) -> uint256:\n    return self._getAvailLiquidity(_vaultToken)\n\n\n@view\n@internal\ndef _getAvailLiquidity(_vaultToken: address) -> uint256:\n    morpho: address = staticcall MetaMorphoV1(_vaultToken).MORPHO()\n    queueLen: uint256 = staticcall MetaMorphoV1(_vaultToken).withdrawQueueLength()\n\n    # iterate through withdraw queue markets\n    totalAvailLiquidity: uint256 = 0\n    for i: uint256 in range(queueLen, bound=max_value(uint256)):\n        marketId: bytes32 = staticcall MetaMorphoV1(_vaultToken).withdrawQueue(i)\n\n        # vault's position in market\n        pos: MorphoPosition = staticcall MorphoBlue(morpho).position(marketId, _vaultToken)\n        if pos.supplyShares == 0:\n            continue\n\n        # market data\n        mkt: MorphoMarket = staticcall MorphoBlue(morpho).market(marketId)\n        if mkt.totalSupplyShares == 0:\n            continue\n\n        # convert once, reuse\n        totalSupplyAssets: uint256 = convert(mkt.totalSupplyAssets, uint256)\n        totalSupplyShares: uint256 = convert(mkt.totalSupplyShares, uint256)\n        totalBorrowAssets: uint256 = convert(mkt.totalBorrowAssets, uint256)\n\n        # calculate vault's supply assets from shares\n        vaultSupplyAssets: uint256 = pos.supplyShares * totalSupplyAssets // totalSupplyShares\n\n        # market liquidity = totalSupplyAssets - totalBorrowAssets\n        marketLiquidity: uint256 = 0\n        if totalSupplyAssets > totalBorrowAssets:\n            marketLiquidity = totalSupplyAssets - totalBorrowAssets\n\n        # vault's available liquidity = min(vault's supply, market liquidity)\n        totalAvailLiquidity += min(vaultSupplyAssets, marketLiquidity)\n\n    return totalAvailLiquidity\n\n\n# utilization\n\n\n@view\n@external\ndef getUtilizationRatio(_vaultToken: address) -> uint256:\n    # utilization = borrows / totalAssets (how much is lent out vs available)\n    totalAssets: uint256 = self._totalAssets(_vaultToken)\n    if totalAssets == 0:\n        return 0\n    totalBorrows: uint256 = self._totalBorrows(_vaultToken)\n    return totalBorrows * HUNDRED_PERCENT // totalAssets\n\n\n# extras\n\n\n@view\n@external\ndef isEligibleForYieldBonus(_asset: address) -> bool:\n    return False\n\n\n@view\n@external\ndef getWithdrawalFees(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    return 0\n\n\n################\n# Registration #\n################\n\n\n# can vault be registered\n\n\n@view\n@external\ndef canRegisterVaultToken(_asset: address, _vaultToken: address) -> bool:\n    return self._canRegisterVaultToken(_asset, _vaultToken)\n\n\n@view\n@internal\ndef _canRegisterVaultToken(_asset: address, _vaultToken: address) -> bool:\n    if empty(address) in [_asset, _vaultToken]:\n        return False\n    if staticcall IERC4626(_vaultToken).asset() != _asset:\n        return False\n    # check V1 factories (v1.0 and v1.1)\n    return staticcall MetaMorphoFactory(MORPHO_FACTORY).isMetaMorpho(_vaultToken) or staticcall MetaMorphoFactory(MORPHO_FACTORY_LEGACY).isMetaMorpho(_vaultToken)\n\n\n# register vault token locally\n\n\n@external\ndef registerVaultTokenLocally(_asset: address, _vaultAddr: address) -> ls.VaultTokenInfo:\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert self._canRegisterVaultToken(_asset, _vaultAddr) # dev: cannot register vault token\n    assert not yld._isAssetOpportunity(_asset, _vaultAddr) # dev: already registered\n    vaultInfo: ls.VaultTokenInfo = self._registerVaultTokenLocally(_asset, _vaultAddr)\n    self._registerVaultTokenGlobally(_asset, _vaultAddr, vaultInfo.decimals, addys._getLedgerAddr(), addys._getLegoBookAddr())\n    return vaultInfo\n\n\n@internal\ndef _registerVaultTokenLocally(_asset: address, _vaultAddr: address) -> ls.VaultTokenInfo:\n    assert extcall IERC20(_asset).approve(_vaultAddr, max_value(uint256), default_return_value=True) # dev: max approval failed\n    vaultInfo: ls.VaultTokenInfo = yld._addAssetOpportunity(_asset, _vaultAddr)\n    assert vaultInfo.decimals != 0 # dev: invalid vault token\n    return vaultInfo\n\n\n# remove vault token locally\n\n\n@external\ndef deregisterVaultTokenLocally(_asset: address, _vaultAddr: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert yld._isAssetOpportunity(_asset, _vaultAddr) # dev: already registered\n    self._deregisterVaultTokenLocally(_asset, _vaultAddr)\n\n\n@internal\ndef _deregisterVaultTokenLocally(_asset: address, _vaultAddr: address):\n    assert extcall IERC20(_asset).approve(_vaultAddr, 0, default_return_value=True) # dev: max approval failed\n    yld._removeAssetOpportunity(_asset, _vaultAddr)\n\n\n# ledger registration\n\n\n@internal\ndef _registerVaultTokenGlobally(_underlyingAsset: address, _vaultToken: address, _decimals: uint256, _ledger: address, _legoBook: address):\n    if not staticcall Ledger(_ledger).isRegisteredVaultToken(_vaultToken):\n        legoId: uint256 = staticcall Registry(_legoBook).getRegId(self)\n        extcall Ledger(_ledger).setVaultToken(_vaultToken, legoId, _underlyingAsset, _decimals, self._isRebasing())\n\n\n#################\n# Yield Actions #\n#################\n\n\n# access control\n\n\n@view\n@internal\ndef _isAllowedToPerformAction(_caller: address) -> bool:\n    # NOTE: important to not trust `_miniAddys` here, that's why getting ledger and vault registry from addys\n    if staticcall VaultRegistry(addys._getVaultRegistryAddr()).isEarnVault(_caller):\n        return True\n    if staticcall Ledger(addys._getLedgerAddr()).isUserWallet(_caller):\n        return True\n    return staticcall Registry(RIPE_REGISTRY).isValidAddr(_caller) # Ripe Endaoment is allowed\n\n\n# add price snapshot\n\n\n@external\ndef addPriceSnapshot(_vaultToken: address) -> bool:\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    vaultInfo: ls.VaultTokenInfo = yld.vaultToAsset[_vaultToken]\n    assert vaultInfo.decimals != 0 # dev: not registered\n    pricePerShare: uint256 = self._getPricePerShare(_vaultToken, vaultInfo.decimals)\n    return yld._addPriceSnapshot(_vaultToken, pricePerShare, vaultInfo.decimals)\n\n\n# deposit\n\n\n@external\ndef depositForYield(\n    _asset: address,\n    _amount: uint256,\n    _vaultAddr: address,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, address, uint256, uint256):\n    assert self._isAllowedToPerformAction(msg.sender) # dev: no perms\n    assert not yld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = yld._getMiniAddys(_miniAddys)\n    vaultInfo: ls.VaultTokenInfo = self._getVaultInfoOnDeposit(_asset, _vaultAddr, miniAddys.ledger, miniAddys.legoBook)\n\n    # pre balances\n    preLegoBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n\n    # transfer deposit asset to this contract\n    depositAmount: uint256 = min(_amount, staticcall IERC20(_asset).balanceOf(msg.sender))\n    assert depositAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_asset).transferFrom(msg.sender, self, depositAmount, default_return_value=True) # dev: transfer failed\n\n    # deposit assets into lego partner\n    vaultTokenAmountReceived: uint256 = extcall IERC4626(_vaultAddr).deposit(depositAmount, _recipient)\n    assert vaultTokenAmountReceived != 0 # dev: no vault tokens received\n\n    # refund if full deposit didn't get through\n    currentLegoBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    refundAssetAmount: uint256 = 0\n    if currentLegoBalance > preLegoBalance:\n        refundAssetAmount = currentLegoBalance - preLegoBalance\n        assert extcall IERC20(_asset).transfer(msg.sender, refundAssetAmount, default_return_value=True) # dev: transfer failed\n        depositAmount -= refundAssetAmount\n\n    usdValue: uint256 = staticcall Appraiser(miniAddys.appraiser).getUnderlyingUsdValue(_asset, depositAmount)\n    log MorphoDeposit(\n        sender = msg.sender,\n        asset = _asset,\n        vaultToken = _vaultAddr,\n        assetAmountDeposited = depositAmount,\n        usdValue = usdValue,\n        vaultTokenAmountReceived = vaultTokenAmountReceived,\n        recipient = _recipient,\n    )\n\n    # add price snapshot\n    pricePerShare: uint256 = self._getPricePerShare(_vaultAddr, vaultInfo.decimals)\n    yld._addPriceSnapshot(_vaultAddr, pricePerShare, vaultInfo.decimals)\n\n    return depositAmount, _vaultAddr, vaultTokenAmountReceived, usdValue\n\n\n# vault info on deposit\n\n\n@internal\ndef _getVaultInfoOnDeposit(_asset: address, _vaultAddr: address, _ledger: address, _legoBook: address) -> ls.VaultTokenInfo:\n    vaultInfo: ls.VaultTokenInfo = yld.vaultToAsset[_vaultAddr]\n    if vaultInfo.decimals == 0:\n        assert self._canRegisterVaultToken(_asset, _vaultAddr) # dev: cannot register vault token\n        vaultInfo = self._registerVaultTokenLocally(_asset, _vaultAddr)\n        self._registerVaultTokenGlobally(_asset, _vaultAddr, vaultInfo.decimals, _ledger, _legoBook)\n    else:\n        assert vaultInfo.underlyingAsset == _asset # dev: asset mismatch\n    return vaultInfo\n\n\n# withdraw\n\n\n@external\ndef withdrawFromYield(\n    _vaultToken: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, address, uint256, uint256):\n    assert self._isAllowedToPerformAction(msg.sender) # dev: no perms\n    assert not yld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = yld._getMiniAddys(_miniAddys)\n    vaultInfo: ls.VaultTokenInfo = self._getVaultInfoOnWithdrawal(_vaultToken, miniAddys.ledger, miniAddys.legoBook)\n\n    # pre balances\n    preLegoVaultBalance: uint256 = staticcall IERC20(_vaultToken).balanceOf(self)\n\n    # transfer vaults tokens to this contract\n    vaultTokenAmount: uint256 = min(_amount, staticcall IERC20(_vaultToken).balanceOf(msg.sender))\n    assert vaultTokenAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_vaultToken).transferFrom(msg.sender, self, vaultTokenAmount, default_return_value=True) # dev: transfer failed\n\n    # withdraw assets from lego partner\n    assetAmountReceived: uint256 = extcall IERC4626(_vaultToken).redeem(vaultTokenAmount, _recipient, self)\n    assert assetAmountReceived != 0 # dev: no asset amount received\n\n    # refund if full withdrawal didn't happen\n    currentLegoVaultBalance: uint256 = staticcall IERC20(_vaultToken).balanceOf(self)\n    refundVaultTokenAmount: uint256 = 0\n    if currentLegoVaultBalance > preLegoVaultBalance:\n        refundVaultTokenAmount = currentLegoVaultBalance - preLegoVaultBalance\n        assert extcall IERC20(_vaultToken).transfer(msg.sender, refundVaultTokenAmount, default_return_value=True) # dev: transfer failed\n        vaultTokenAmount -= refundVaultTokenAmount\n\n    usdValue: uint256 = staticcall Appraiser(miniAddys.appraiser).getUnderlyingUsdValue(vaultInfo.underlyingAsset, assetAmountReceived)\n    log MorphoWithdrawal(\n        sender = msg.sender,\n        asset = vaultInfo.underlyingAsset,\n        vaultToken = _vaultToken,\n        assetAmountReceived = assetAmountReceived,\n        usdValue = usdValue,\n        vaultTokenAmountBurned = vaultTokenAmount,\n        recipient = _recipient,\n    )\n\n    # add price snapshot\n    pricePerShare: uint256 = self._getPricePerShare(_vaultToken, vaultInfo.decimals)\n    yld._addPriceSnapshot(_vaultToken, pricePerShare, vaultInfo.decimals)\n\n    return vaultTokenAmount, vaultInfo.underlyingAsset, assetAmountReceived, usdValue\n\n\n# vault info on withdrawal\n\n\n@internal\ndef _getVaultInfoOnWithdrawal(_vaultAddr: address, _ledger: address, _legoBook: address) -> ls.VaultTokenInfo:\n    vaultInfo: ls.VaultTokenInfo = yld.vaultToAsset[_vaultAddr]\n    if vaultInfo.decimals == 0:\n        asset: address = staticcall IERC4626(_vaultAddr).asset()\n        assert self._canRegisterVaultToken(asset, _vaultAddr) # dev: cannot register vault token\n        vaultInfo = self._registerVaultTokenLocally(asset, _vaultAddr)\n        self._registerVaultTokenGlobally(asset, _vaultAddr, vaultInfo.decimals, _ledger, _legoBook)\n    return vaultInfo\n\n\n#################\n# Claim Rewards #\n#################\n\n\n@external\ndef claimIncentives(\n    _user: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _proofs: DynArray[bytes32, MAX_PROOFS],\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    assert self._isAllowedToPerformAction(msg.sender) # dev: no perms\n    assert not yld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = yld._getMiniAddys(_miniAddys)\n    morphoRewards: address = self.morphoRewards\n    assert morphoRewards != empty(address) # dev: no morpho rewards addr set\n\n    rewardAmount: uint256 = extcall MorphoRewardsDistributor(morphoRewards).claim(_user, _rewardToken, _rewardAmount, _proofs)\n    usdValue: uint256 = staticcall Appraiser(miniAddys.appraiser).getUnderlyingUsdValue(_rewardToken, rewardAmount)\n    return rewardAmount, usdValue\n\n\n@external\ndef claimRewards(\n    _user: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _extraData: bytes32,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    # backwards compatibility\n    return 0, 0\n\n\n@view\n@external\ndef hasClaimableRewards(_user: address) -> bool:\n    # as far as we can tell, this must be done offchain\n    return False\n\n\n# set rewards addr\n\n\n@external\ndef setMorphoRewardsAddr(_addr: address) -> bool:\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert _addr != empty(address) # dev: invalid addr\n    self.morphoRewards = _addr\n    log MorphoRewardsAddrSet(addr=_addr)\n    return True\n\n\n#########\n# Other #\n#########\n\n\n@view\n@external\ndef getAccessForLego(_user: address, _action: ws.ActionType) -> (address, String[64], uint256):\n    return empty(address), empty(String[64]), 0\n\n\n@external\ndef swapTokens(\n    _amountIn: uint256,\n    _minAmountOut: uint256,\n    _tokenPath: DynArray[address, MAX_TOKEN_PATH],\n    _poolPath: DynArray[address, MAX_TOKEN_PATH - 1],\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256):\n    return 0, 0, 0\n\n\n@external\ndef mintOrRedeemAsset(\n    _tokenIn: address,\n    _tokenOut: address,\n    _tokenInAmount: uint256,\n    _minAmountOut: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, bool, uint256):\n    return 0, 0, False, 0\n\n\n@external\ndef confirmMintOrRedeemAsset(\n    _tokenIn: address,\n    _tokenOut: address,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef addCollateral(\n    _asset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef removeCollateral(\n    _asset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef borrow(\n    _borrowAsset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef repayDebt(\n    _paymentAsset: address,\n    _paymentAmount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef addLiquidity(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _amountA: uint256,\n    _amountB: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _minLpAmount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (address, uint256, uint256, uint256, uint256):\n    return empty(address), 0, 0, 0, 0\n\n\n@external\ndef removeLiquidity(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpToken: address,\n    _lpAmount: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, uint256):\n    return 0, 0, 0, 0\n\n\n@external\ndef addLiquidityConcentrated(\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _tickLower: int24,\n    _tickUpper: int24,\n    _amountA: uint256,\n    _amountB: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, uint256, uint256):\n    return 0, 0, 0, 0, 0\n\n\n@external\ndef removeLiquidityConcentrated(\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _liqToRemove: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, bool, uint256):\n    return 0, 0, 0, False, 0",
            "sha256sum": "88e29c3ea9dff1d6d77b33e3e7abba41093e25290633f87487110365edd15a4d"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/legos/yield/Morpho.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.3+commit.bff19ea2",
        "integrity": "b23e55b094ef4fe92e0f08148637366031d9b32569463c7920cddd4cb91dadde"
      },
      "args": "00000000000000000000000044cf3c4f000dfd76a35d03298049d37be688d6f9000000000000000000000000ff62a7c278c62ed665133147129245053bbf5918000000000000000000000000a9c3d3a366466fa809d1ae982fb2c46e5fc411010000000000000000000000005400dbb270c956e8985184335a1c62aca6ce13330000000000000000000000006162df1b329e157479f8f1407e888260e0ec3d2b",
      "file": "contracts/legos/yield/Morpho.vy"
    },
    "AeroClassic": {
      "address": "0xAB032BFa41AD31090C2744727C2cdA502e9025e0",
      "abi": [
        {
          "name": "AerodromeSwap",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenIn",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenOut",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amountIn",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "amountOut",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "numTokens",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AerodromeLiquidityAdded",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenA",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenB",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amountA",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "amountB",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "lpAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AerodromeLiquidityRemoved",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": false
            },
            {
              "name": "pool",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenA",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenB",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amountA",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "amountB",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "lpToken",
              "type": "address",
              "indexed": false
            },
            {
              "name": "lpAmountBurned",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LegoPauseModified",
          "inputs": [
            {
              "name": "isPaused",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LegoFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "balance",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddys",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "undyToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "hatchery",
                  "type": "address"
                },
                {
                  "name": "lootDistributor",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                },
                {
                  "name": "walletBackpack",
                  "type": "address"
                },
                {
                  "name": "billing",
                  "type": "address"
                },
                {
                  "name": "vaultRegistry",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUndyHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pause",
          "inputs": [
            {
              "name": "_shouldPause",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFundsMany",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_assets",
              "type": "address[]"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "legoId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isPaused",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasCapability",
          "inputs": [
            {
              "name": "_action",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRegistries",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isYieldLego",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isDexLego",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_tokenPath",
              "type": "address[]"
            },
            {
              "name": "_poolPath",
              "type": "address[]"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_tokenPath",
              "type": "address[]"
            },
            {
              "name": "_poolPath",
              "type": "address[]"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLpToken",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPoolForLpToken",
          "inputs": [
            {
              "name": "_lpToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getCoreRouterPool",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getDeepestLiqPool",
          "inputs": [
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "fee",
                  "type": "uint256"
                },
                {
                  "name": "liquidity",
                  "type": "uint256"
                },
                {
                  "name": "numCoins",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getBestSwapAmountOut",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountIn",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getSwapAmountOut",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountIn",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getBestSwapAmountIn",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountOut",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getSwapAmountIn",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountOut",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddLiqAmountsIn",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_availAmountA",
              "type": "uint256"
            },
            {
              "name": "_availAmountB",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRemoveLiqAmountsOut",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPrice",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_decimals",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPriceUnsafe",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_targetToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPriceUnsafe",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_targetToken",
              "type": "address"
            },
            {
              "name": "_appraiser",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositForYield",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositForYield",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawFromYield",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawFromYield",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_tokenInAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_tokenInAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmMintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmMintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_borrowAsset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_borrowAsset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_paymentAsset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_paymentAsset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimIncentives",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_proofs",
              "type": "bytes32[]"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimIncentives",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_proofs",
              "type": "bytes32[]"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAccessForLego",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_action",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "string"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "AERODROME_FACTORY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "AERODROME_ROUTER",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "RIPE_REGISTRY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "coreRouterPool",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_undyHq",
              "type": "address"
            },
            {
              "name": "_aerodromeFactory",
              "type": "address"
            },
            {
              "name": "_aerodromeRouter",
              "type": "address"
            },
            {
              "name": "_coreRouterPool",
              "type": "address"
            },
            {
              "name": "_ripeRegistry",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "interfaces/WalletStructs.vyi": {
            "content": "# @version 0.4.3\n\nflag ActionType:\n    TRANSFER\n    EARN_DEPOSIT\n    EARN_WITHDRAW\n    EARN_REBALANCE\n    SWAP\n    MINT_REDEEM\n    CONFIRM_MINT_REDEEM\n    ADD_COLLATERAL\n    REMOVE_COLLATERAL\n    BORROW\n    REPAY_DEBT\n    REWARDS\n    ETH_TO_WETH\n    WETH_TO_ETH\n    ADD_LIQ\n    REMOVE_LIQ\n    ADD_LIQ_CONC\n    REMOVE_LIQ_CONC\n    PAY_CHEQUE\n\nstruct WalletAssetData:\n    assetBalance: uint256\n    usdValue: uint256\n    isYieldAsset: bool\n    lastPricePerShare: uint256\n\nstruct ActionData:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    billing: address\n    vaultRegistry: address\n    wallet: address\n    walletConfig: address\n    walletOwner: address\n    inEjectMode: bool\n    isFrozen: bool\n    lastTotalUsdValue: uint256\n    signer: address\n    isManager: bool\n    legoId: uint256\n    legoAddr: address\n    eth: address\n    weth: address\n\nstruct MiniAddys:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    appraiser: address",
            "sha256sum": "466493c129135c95470aaf70eeddc936632f7b0f813396e5a7ddc03bea9da518"
          },
          "interfaces/LegoPartner.vyi": {
            "content": "# @version 0.4.3\n\nfrom interfaces import WalletStructs as ws\n\nMAX_TOKEN_PATH: constant(uint256) = 5\nMAX_RECOVER_ASSETS: constant(uint256) = 20\nMAX_PROOFS: constant(uint256) = 25\n\n@external\ndef addLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _tickLower: int24, _tickUpper: int24, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef addLiquidity(_pool: address, _tokenA: address, _tokenB: address, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _minLpAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (address, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef removeLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _liqToRemove: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef removeLiquidity(_pool: address, _tokenA: address, _tokenB: address, _lpToken: address, _lpAmount: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef mintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _tokenInAmount: uint256, _minAmountOut: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef swapTokens(_amountIn: uint256, _minAmountOut: uint256, _tokenPath: DynArray[address, MAX_TOKEN_PATH], _poolPath: DynArray[address, MAX_TOKEN_PATH - 1], _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256):\n    ...\n\n@external\ndef depositForYield(_asset: address, _amount: uint256, _vaultAddr: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef withdrawFromYield(_vaultToken: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef confirmMintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef borrow(_borrowAsset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef repayDebt(_paymentAsset: address, _paymentAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef claimIncentives(_user: address, _rewardToken: address, _rewardAmount: uint256, _proofs: DynArray[bytes32, MAX_PROOFS], _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef removeCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef addCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@view\n@external\ndef getAccessForLego(_user: address, _action: ws.ActionType) -> (address, String[64], uint256):\n    ...\n\n@view\n@external\ndef hasCapability(_action: ws.ActionType) -> bool:\n    ...\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    ...\n\n@view\n@external\ndef isYieldLego() -> bool:\n    ...\n\n@view\n@external\ndef isDexLego() -> bool:\n    ...\n\n\n# common\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "f2afb7bd72d4301aea77bbe4177b7ae954ba6f6b76af363965993eb92ad0b715"
          },
          "interfaces/DexLego.vyi": {
            "content": "# @version 0.4.3\n\n# used in smart contracts\n\n\n@view\n@external\ndef getLpToken(_pool: address) -> address:\n    ...\n\n\n# helper functions for server\n\n\n@view\n@external\ndef getPoolForLpToken(_lpToken: address) -> address:\n    ...\n\n\n@view\n@external\ndef getSwapAmountOut(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n) -> uint256:\n    ...\n\n\n@view\n@external\ndef getSwapAmountIn(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountOut: uint256,\n) -> uint256:\n    ...\n\n\n@view\n@external\ndef getAddLiqAmountsIn(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _availAmountA: uint256,\n    _availAmountB: uint256,\n) -> (uint256, uint256, uint256):\n    ...\n\n\n@view\n@external\ndef getRemoveLiqAmountsOut(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpAmount: uint256,\n) -> (uint256, uint256):\n    ...\n\n\n@view\n@external\ndef getPriceUnsafe(_pool: address, _targetToken: address, _appraiser: address = empty(address)) -> uint256:\n    ...\n\n\n@view\n@external\ndef getBestSwapAmountOut(_tokenIn: address, _tokenOut: address, _amountIn: uint256) -> (address, uint256):\n    ...\n\n\n@view\n@external\ndef getBestSwapAmountIn(_tokenIn: address, _tokenOut: address, _amountOut: uint256) -> (address, uint256):\n    ...\n\n\n@view\n@external\ndef getCoreRouterPool() -> address:\n    ...\n\n\n@view\n@external\ndef getPrice(_asset: address, _decimals: uint256) -> uint256:\n    ...\n",
            "sha256sum": "6248ad46926f00481cb3469bfc7af8fe36669c2ca0dd98e9a0befdda0fc43fd7"
          },
          "contracts/modules/Addys.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\ninterface UndyHq:\n    def isValidAddr(_addr: address) -> bool: view\n    def getAddr(_regId: uint256) -> address: view\n    def undyToken() -> address: view\n\ninterface Switchboard:\n    def isSwitchboardAddr(_addr: address) -> bool: view\n\ninterface LegoBook:\n    def isLegoAddr(_addr: address) -> bool: view\n\nstruct Addys:\n    hq: address\n    undyToken: address\n    ledger: address\n    missionControl: address\n    legoBook: address\n    switchboard: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    walletBackpack: address\n    billing: address\n    vaultRegistry: address\n\n# hq\nUNDY_HQ_FOR_ADDYS: immutable(address)\n\n# core addys\nLEDGER_ID: constant(uint256) = 1\nMISSION_CONTROL_ID: constant(uint256) = 2\nLEGO_BOOK_ID: constant(uint256) = 3\nSWITCHBOARD_ID: constant(uint256) = 4\nHATCHERY_ID: constant(uint256) = 5\nLOOT_DISTRIBUTOR_ID: constant(uint256) = 6\nAPPRAISER_ID: constant(uint256) = 7\nWALLET_BACKPACK_ID: constant(uint256) = 8\nBILLING_ID: constant(uint256) = 9\nVAULT_REGISTRY_ID: constant(uint256) = 10\n\n\n@deploy\ndef __init__(_undyHq: address):\n    assert _undyHq != empty(address) # dev: invalid undy hq\n    UNDY_HQ_FOR_ADDYS = _undyHq\n\n\n########\n# Core #\n########\n\n\n@view\n@external\ndef getAddys() -> Addys:\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _getAddys(_addys: Addys = empty(Addys)) -> Addys:\n    if _addys.hq != empty(address):\n        return _addys\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _generateAddys() -> Addys:\n    hq: address = UNDY_HQ_FOR_ADDYS\n    return Addys(\n        hq = hq,\n        undyToken = staticcall UndyHq(hq).undyToken(),\n        ledger = staticcall UndyHq(hq).getAddr(LEDGER_ID),\n        missionControl = staticcall UndyHq(hq).getAddr(MISSION_CONTROL_ID),\n        legoBook = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID),\n        switchboard = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID),\n        hatchery = staticcall UndyHq(hq).getAddr(HATCHERY_ID),\n        lootDistributor = staticcall UndyHq(hq).getAddr(LOOT_DISTRIBUTOR_ID),\n        appraiser = staticcall UndyHq(hq).getAddr(APPRAISER_ID),\n        walletBackpack = staticcall UndyHq(hq).getAddr(WALLET_BACKPACK_ID),\n        billing = staticcall UndyHq(hq).getAddr(BILLING_ID),\n        vaultRegistry = staticcall UndyHq(hq).getAddr(VAULT_REGISTRY_ID),\n    )\n\n\n##########\n# Tokens #\n##########\n\n\n@view\n@internal\ndef _getUndyToken() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).undyToken()\n\n\n###########\n# Helpers #\n###########\n\n\n# undy hq\n\n\n@view\n@external\ndef getUndyHq() -> address:\n    return self._getUndyHq()\n\n\n@view\n@internal\ndef _getUndyHq() -> address:\n    return UNDY_HQ_FOR_ADDYS\n\n\n# utils\n\n\n@view\n@internal\ndef _isValidUndyAddr(_addr: address, _hq: address = empty(address)) -> bool:\n    hq: address = _hq\n    if _hq == empty(address):\n        hq = UNDY_HQ_FOR_ADDYS\n    \n    # core departments\n    if staticcall UndyHq(hq).isValidAddr(_addr):\n        return True\n\n    # lego book\n    legoBook: address = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID)\n    if legoBook != empty(address) and staticcall LegoBook(legoBook).isLegoAddr(_addr):\n        return True\n\n    # switchboard config\n    switchboard: address = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID)\n    if switchboard != empty(address) and staticcall Switchboard(switchboard).isSwitchboardAddr(_addr):\n        return True\n\n    return False\n\n\n@view\n@internal\ndef _isSwitchboardAddr(_addr: address) -> bool:\n    switchboard: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n    if switchboard == empty(address):\n        return False\n    return staticcall Switchboard(switchboard).isSwitchboardAddr(_addr)\n\n\n@view\n@internal\ndef _isLegoBookAddr(_addr: address) -> bool:\n    legoBook: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n    if legoBook == empty(address):\n        return False\n    return staticcall LegoBook(legoBook).isLegoAddr(_addr)\n\n\n###############\n# Departments #\n###############\n\n\n# ledger\n\n\n@view\n@internal\ndef _getLedgerId() -> uint256:\n    return LEDGER_ID\n\n\n@view\n@internal\ndef _getLedgerAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEDGER_ID)\n\n\n# mission control\n\n\n@view\n@internal\ndef _getMissionControlId() -> uint256:\n    return MISSION_CONTROL_ID\n\n\n@view\n@internal\ndef _getMissionControlAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(MISSION_CONTROL_ID)\n\n\n# lego book\n\n\n@view\n@internal\ndef _getLegoBookId() -> uint256:\n    return LEGO_BOOK_ID\n\n\n@view\n@internal\ndef _getLegoBookAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n\n\n# switchboard\n\n\n@view\n@internal\ndef _getSwitchboardId() -> uint256:\n    return SWITCHBOARD_ID\n\n\n@view\n@internal\ndef _getSwitchboardAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n\n\n# hatchery\n\n\n@view\n@internal\ndef _getHatcheryId() -> uint256:\n    return HATCHERY_ID\n\n\n@view\n@internal\ndef _getHatcheryAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(HATCHERY_ID)\n\n\n# loot distributor\n\n\n@view\n@internal\ndef _getLootDistributorId() -> uint256:\n    return LOOT_DISTRIBUTOR_ID\n\n\n@view\n@internal\ndef _getLootDistributorAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LOOT_DISTRIBUTOR_ID)\n\n\n# appraiser\n\n\n@view\n@internal\ndef _getAppraiserId() -> uint256:\n    return APPRAISER_ID\n\n\n@view\n@internal\ndef _getAppraiserAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(APPRAISER_ID)\n\n\n# wallet backpack\n\n\n@view\n@internal\ndef _getWalletBackpackId() -> uint256:\n    return WALLET_BACKPACK_ID\n\n\n@view\n@internal\ndef _getWalletBackpackAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(WALLET_BACKPACK_ID)\n\n\n# billing\n\n\n@view\n@internal\ndef _getBillingId() -> uint256:\n    return BILLING_ID\n\n\n@view\n@internal\ndef _getBillingAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(BILLING_ID)\n\n\n# vault registry\n\n\n@view\n@internal\ndef _getVaultRegistryId() -> uint256:\n    return VAULT_REGISTRY_ID\n\n\n@view\n@internal\ndef _getVaultRegistryAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(VAULT_REGISTRY_ID)",
            "sha256sum": "4df6b72db9bb417d1af81660175be1450cfb7b3575f3d17a5b8a130bff87b781"
          },
          "contracts/modules/DexLegoData.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nuses: addys\n\nimport contracts.modules.Addys as addys\n\nfrom interfaces import WalletStructs as ws\nfrom ethereum.ercs import IERC20\n\nevent LegoPauseModified:\n    isPaused: bool\n\nevent LegoFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    balance: uint256\n\n# config\nlegoId: public(uint256)\nisPaused: public(bool)\n\nMAX_RECOVER_ASSETS: constant(uint256) = 20\n\n\n@deploy\ndef __init__(_shouldPause: bool):\n    self.isPaused = _shouldPause\n\n\n###########\n# General #\n###########\n\n\n# fill mini addys\n\n\n@view\n@internal\ndef _getMiniAddys(_miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> ws.MiniAddys:\n    if _miniAddys.ledger != empty(address):\n        return _miniAddys\n    return ws.MiniAddys(\n        ledger = addys._getLedgerAddr(),\n        missionControl = addys._getMissionControlAddr(),\n        legoBook = addys._getLegoBookAddr(),\n        appraiser = addys._getAppraiserAddr(),\n    )\n\n\n# activate\n\n\n@external\ndef pause(_shouldPause: bool):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert _shouldPause != self.isPaused # dev: no change\n    self.isPaused = _shouldPause\n    log LegoPauseModified(isPaused=_shouldPause)\n\n\n# recover funds\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    self._recoverFunds(_recipient, _asset)\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, MAX_RECOVER_ASSETS]):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    for a: address in _assets:\n        self._recoverFunds(_recipient, a)\n\n\n@internal\ndef _recoverFunds(_recipient: address, _asset: address):\n    assert empty(address) not in [_recipient, _asset] # dev: invalid recipient or asset\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    assert balance != 0 # dev: nothing to recover\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log LegoFundsRecovered(asset=_asset, recipient=_recipient, balance=balance)",
            "sha256sum": "75b15af2475ab409d4b5fd057509d14c20564ebd7fcb0850e3b61397d8e3af48"
          },
          "contracts/legos/dexes/AeroClassic.vy": {
            "content": "#     _____  _____  __  __    ____   _____  _____  _____ \n#    |  _  \\/   __\\/  \\/  \\  /  _/  /   __\\/   __\\/  _  \\\n#    |  |  ||   __|>-    -<  |  |---|   __||  |_ ||  |  |\n#    |_____/\\_____/\\__/\\__/  \\_____/\\_____/\\_____/\\_____/\n#                                                                       \n#     \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n#     \u2551  ** Aero Classic Lego **                \u2551\n#     \u2551  Integration with Aerodrome Classic.    \u2551\n#     \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n#\n#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nimplements: Lego\nimplements: DexLego\n\nexports: addys.__interface__\nexports: dld.__interface__\n\ninitializes: addys\ninitializes: dld[addys := addys]\n\nfrom interfaces import LegoPartner as Lego\nfrom interfaces import DexLego as DexLego\nfrom interfaces import WalletStructs as ws\n\nimport contracts.modules.Addys as addys\nimport contracts.modules.DexLegoData as dld\n\nfrom ethereum.ercs import IERC20\nfrom ethereum.ercs import IERC20Detailed\n\ninterface AeroRouter:\n    def addLiquidity(_tokenA: address, _tokenB: address, _isStable: bool, _amountADesired: uint256, _amountBDesired: uint256, _amountAMin: uint256, _amountBMin: uint256, _recipient: address, _deadline: uint256) -> (uint256, uint256, uint256): nonpayable\n    def removeLiquidity(_tokenA: address, _tokenB: address, _isStable: bool, _lpAmount: uint256, _amountAMin: uint256, _amountBMin: uint256, _recipient: address, _deadline: uint256) -> (uint256, uint256): nonpayable\n    def quoteAddLiquidity(_tokenA: address, _tokenB: address, _isStable: bool, _factory: address, _amountADesired: uint256, _amountBDesired: uint256) -> (uint256, uint256, uint256): view\n    def swapExactTokensForTokens(_amountIn: uint256, _amountOutMin: uint256, _path: DynArray[Route, 10], _to: address, _deadline: uint256) -> DynArray[uint256, 10]: nonpayable\n    def quoteRemoveLiquidity(_tokenA: address, _tokenB: address, _isStable: bool, _factory: address, _liquidity: uint256) -> (uint256, uint256): view\n\ninterface AeroClassicPool:\n    def swap(_amount0Out: uint256, _amount1Out: uint256, _recipient: address, _data: Bytes[256]): nonpayable\n    def getAmountOut(_amountIn: uint256, _tokenIn: address) -> uint256: view\n    def getReserves() -> (uint256, uint256, uint256): view\n    def tokens() -> (address, address): view\n    def stable() -> bool: view\n\ninterface Appraiser:\n    def getUsdValue(_asset: address, _amount: uint256, _missionControl: address = empty(address), _legoBook: address = empty(address), _ledger: address = empty(address)) -> uint256: view\n    def getRipePrice(_asset: address) -> uint256: view\n\ninterface AeroFactory:\n    def getPool(_tokenA: address, _tokenB: address, _isStable: bool) -> address: view\n    def getFee(_pool: address, _isStable: bool) -> uint256: view\n\ninterface VaultRegistry:\n    def isEarnVault(_vaultAddr: address) -> bool: view\n\ninterface Ledger:\n    def isUserWallet(_user: address) -> bool: view\n\ninterface Registry:\n    def isValidAddr(_addr: address) -> bool: view\n\nstruct BestPool:\n    pool: address\n    fee: uint256\n    liquidity: uint256\n    numCoins: uint256\n\nstruct Route:\n    from_: address\n    to: address \n    stable: bool\n    factory: address\n\nevent AerodromeSwap:\n    sender: indexed(address)\n    tokenIn: indexed(address)\n    tokenOut: indexed(address)\n    amountIn: uint256\n    amountOut: uint256\n    usdValue: uint256\n    numTokens: uint256\n    recipient: address\n\nevent AerodromeLiquidityAdded:\n    sender: indexed(address)\n    tokenA: indexed(address)\n    tokenB: indexed(address)\n    amountA: uint256\n    amountB: uint256\n    lpAmountReceived: uint256\n    usdValue: uint256\n    recipient: address\n\nevent AerodromeLiquidityRemoved:\n    sender: address\n    pool: indexed(address)\n    tokenA: indexed(address)\n    tokenB: indexed(address)\n    amountA: uint256\n    amountB: uint256\n    lpToken: address\n    lpAmountBurned: uint256\n    usdValue: uint256\n    recipient: address\n\n# aero\nAERODROME_FACTORY: public(immutable(address))\nAERODROME_ROUTER: public(immutable(address))\nRIPE_REGISTRY: public(immutable(address))\n\ncoreRouterPool: public(address)\n\nMAX_TOKEN_PATH: constant(uint256) = 5\nEIGHTEEN_DECIMALS: constant(uint256) = 10 ** 18\nMAX_PROOFS: constant(uint256) = 25\n\n\n@deploy\ndef __init__(\n    _undyHq: address,\n    _aerodromeFactory: address,\n    _aerodromeRouter: address,\n    _coreRouterPool: address,\n    _ripeRegistry: address,\n):\n    addys.__init__(_undyHq)\n    dld.__init__(False)\n\n    assert empty(address) not in [_aerodromeFactory, _aerodromeRouter, _coreRouterPool, _ripeRegistry] # dev: invalid addrs\n    AERODROME_FACTORY = _aerodromeFactory\n    AERODROME_ROUTER = _aerodromeRouter\n    RIPE_REGISTRY = _ripeRegistry\n    self.coreRouterPool = _coreRouterPool\n\n\n@view\n@external\ndef hasCapability(_action: ws.ActionType) -> bool:\n    return _action in (\n        ws.ActionType.SWAP |\n        ws.ActionType.ADD_LIQ | \n        ws.ActionType.REMOVE_LIQ\n    )\n\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    return [AERODROME_FACTORY, AERODROME_ROUTER]\n\n\n@view\n@external\ndef isYieldLego() -> bool:\n    return False\n\n\n@view\n@external\ndef isDexLego() -> bool:\n    return True\n\n\n@view\n@internal\ndef _isAllowedToPerformAction(_caller: address) -> bool:\n    if staticcall VaultRegistry(addys._getVaultRegistryAddr()).isEarnVault(_caller):\n        return True\n    if staticcall Ledger(addys._getLedgerAddr()).isUserWallet(_caller):\n        return True\n    return staticcall Registry(RIPE_REGISTRY).isValidAddr(_caller)\n\n\n#########\n# Swaps #\n#########\n\n\n@external\ndef swapTokens(\n    _amountIn: uint256,\n    _minAmountOut: uint256,\n    _tokenPath: DynArray[address, MAX_TOKEN_PATH],\n    _poolPath: DynArray[address, MAX_TOKEN_PATH - 1],\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256):\n    assert not dld.isPaused # dev: paused\n    assert self._isAllowedToPerformAction(msg.sender) # dev: no perms\n    miniAddys: ws.MiniAddys = dld._getMiniAddys(_miniAddys)\n\n    # validate inputs\n    numTokens: uint256 = len(_tokenPath)\n    numPools: uint256 = len(_poolPath)\n    assert numTokens >= 2 # dev: invalid path\n    assert numPools == numTokens - 1 # dev: invalid path\n\n    # get first token and last token\n    tokenIn: address = _tokenPath[0]\n    tokenOut: address = _tokenPath[numTokens - 1]\n\n    # pre balances\n    preLegoBalance: uint256 = staticcall IERC20(tokenIn).balanceOf(self)\n\n    # transfer deposit asset to this contract\n    amountIn: uint256 = min(_amountIn, staticcall IERC20(tokenIn).balanceOf(msg.sender))\n    assert amountIn != 0 # dev: nothing to transfer\n    assert extcall IERC20(tokenIn).transferFrom(msg.sender, self, amountIn, default_return_value=True) # dev: transfer failed\n\n    # adjust min amount out\n    minAmountOut: uint256 = _minAmountOut\n    if amountIn < _amountIn and _amountIn != max_value(uint256):\n        minAmountOut = _minAmountOut * amountIn // _amountIn\n\n    # transfer initial amount to first pool\n    assert extcall IERC20(tokenIn).transfer(_poolPath[0], amountIn, default_return_value=True) # dev: transfer failed\n\n    # iterate through swap routes\n    tempAmountIn: uint256 = amountIn\n    aeroFactory: address = AERODROME_FACTORY\n    for i: uint256 in range(numTokens - 1, bound=MAX_TOKEN_PATH):\n        tempTokenIn: address = _tokenPath[i]\n        tempTokenOut: address = _tokenPath[i + 1]\n        tempPool: address = _poolPath[i]\n\n        # transfer to next pool (or to recipient if last swap)\n        recipient: address = _recipient\n        if i < numTokens - 2:\n            recipient = _poolPath[i + 1]\n\n        # swap\n        tempAmountIn = self._swapTokensInPool(tempPool, tempTokenIn, tempTokenOut, tempAmountIn, recipient, aeroFactory)\n\n    # final amount\n    amountOut: uint256 = tempAmountIn\n    assert amountOut >= minAmountOut # dev: min amount out not met\n\n    # refund if full swap didn't get through\n    currentLegoBalance: uint256 = staticcall IERC20(tokenIn).balanceOf(self)\n    refundAssetAmount: uint256 = 0\n    if currentLegoBalance > preLegoBalance:\n        refundAssetAmount = currentLegoBalance - preLegoBalance\n        assert extcall IERC20(tokenIn).transfer(msg.sender, refundAssetAmount, default_return_value=True) # dev: transfer failed\n        amountIn -= refundAssetAmount\n\n    # get usd values\n    usdValue: uint256 = staticcall Appraiser(miniAddys.appraiser).getUsdValue(tokenIn, amountIn, miniAddys.missionControl, miniAddys.legoBook, miniAddys.ledger)\n    if usdValue == 0:\n        usdValue = staticcall Appraiser(miniAddys.appraiser).getUsdValue(tokenOut, amountOut, miniAddys.missionControl, miniAddys.legoBook, miniAddys.ledger)\n\n    log AerodromeSwap(\n        sender = msg.sender,\n        tokenIn = tokenIn,\n        tokenOut = tokenOut,\n        amountIn = amountIn,\n        amountOut = amountOut,\n        usdValue = usdValue,\n        numTokens = numTokens,\n        recipient = _recipient,\n    )\n    return amountIn, amountOut, usdValue\n\n\n# swap in pool\n\n\n@internal\ndef _swapTokensInPool(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n    _recipient: address,\n    _aeroFactory: address,\n) -> uint256:\n    token0: address = empty(address)\n    token1: address = empty(address)\n    token0, token1 = staticcall AeroClassicPool(_pool).tokens()\n\n    tokens: address[2] = [token0, token1]\n    assert _tokenIn in tokens # dev: invalid tokenIn\n    assert _tokenOut in tokens # dev: invalid tokenOut\n    assert _tokenIn != _tokenOut # dev: invalid tokens\n\n    # verify actual aerodrome pool\n    assert staticcall AeroFactory(_aeroFactory).getPool(_tokenIn, _tokenOut, staticcall AeroClassicPool(_pool).stable()) == _pool # dev: invalid pool\n\n    zeroForOne: bool = _tokenIn == token0\n    amountOut: uint256 = staticcall AeroClassicPool(_pool).getAmountOut(_amountIn, _tokenIn)\n    assert amountOut != 0 # dev: no tokens swapped\n\n    # put in correct order\n    amount0Out: uint256 = amountOut\n    amount1Out: uint256 = 0\n    if zeroForOne:\n        amount0Out = 0\n        amount1Out = amountOut\n\n    extcall AeroClassicPool(_pool).swap(amount0Out, amount1Out, _recipient, b\"\")\n    return amountOut\n\n\n#############\n# Liquidity #\n#############\n\n\n# add liquidity\n\n\n@external\ndef addLiquidity(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _amountA: uint256,\n    _amountB: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _minLpAmount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (address, uint256, uint256, uint256, uint256):\n    assert not dld.isPaused # dev: paused\n    assert self._isAllowedToPerformAction(msg.sender) # dev: no perms\n    miniAddys: ws.MiniAddys = dld._getMiniAddys(_miniAddys)\n\n    # validate tokens\n    token0: address = empty(address)\n    token1: address = empty(address)\n    token0, token1 = staticcall AeroClassicPool(_pool).tokens()\n\n    tokens: address[2] = [token0, token1]\n    assert _tokenA in tokens # dev: invalid tokenA\n    assert _tokenB in tokens # dev: invalid tokenB\n    assert _tokenA != _tokenB # dev: invalid tokens\n\n    # pre balances\n    preLegoBalanceA: uint256 = staticcall IERC20(_tokenA).balanceOf(self)\n    preLegoBalanceB: uint256 = staticcall IERC20(_tokenB).balanceOf(self)\n\n    # token a\n    liqAmountA: uint256 = min(_amountA, staticcall IERC20(_tokenA).balanceOf(msg.sender))\n    assert liqAmountA != 0 # dev: nothing to transfer\n    assert extcall IERC20(_tokenA).transferFrom(msg.sender, self, liqAmountA, default_return_value=True) # dev: transfer failed\n\n    # token b\n    liqAmountB: uint256 = min(_amountB, staticcall IERC20(_tokenB).balanceOf(msg.sender))\n    assert liqAmountB != 0 # dev: nothing to transfer\n    assert extcall IERC20(_tokenB).transferFrom(msg.sender, self, liqAmountB, default_return_value=True) # dev: transfer failed\n\n    # approvals\n    router: address = AERODROME_ROUTER\n    assert extcall IERC20(_tokenA).approve(router, liqAmountA, default_return_value=True) # dev: approval failed\n    assert extcall IERC20(_tokenB).approve(router, liqAmountB, default_return_value=True) # dev: approval failed\n\n    # add liquidity\n    lpAmountReceived: uint256 = 0\n    liqAmountA, liqAmountB, lpAmountReceived = extcall AeroRouter(router).addLiquidity(\n        _tokenA,\n        _tokenB,\n        staticcall AeroClassicPool(_pool).stable(),\n        liqAmountA,\n        liqAmountB,\n        _minAmountA,\n        _minAmountB,\n        _recipient,\n        block.timestamp,\n    )\n    assert lpAmountReceived != 0 # dev: no liquidity added\n    if _minLpAmount != 0:\n        assert lpAmountReceived >= _minLpAmount # dev: insufficient liquidity added\n\n    # reset approvals\n    assert extcall IERC20(_tokenA).approve(router, 0, default_return_value=True) # dev: approval failed\n    assert extcall IERC20(_tokenB).approve(router, 0, default_return_value=True) # dev: approval failed\n\n    # refund if full liquidity was not added\n    currentLegoBalanceA: uint256 = staticcall IERC20(_tokenA).balanceOf(self)\n    refundAssetAmountA: uint256 = 0\n    if currentLegoBalanceA > preLegoBalanceA:\n        refundAssetAmountA = currentLegoBalanceA - preLegoBalanceA\n        assert extcall IERC20(_tokenA).transfer(msg.sender, refundAssetAmountA, default_return_value=True) # dev: transfer failed\n\n    currentLegoBalanceB: uint256 = staticcall IERC20(_tokenB).balanceOf(self)\n    refundAssetAmountB: uint256 = 0\n    if currentLegoBalanceB > preLegoBalanceB:\n        refundAssetAmountB = currentLegoBalanceB - preLegoBalanceB\n        assert extcall IERC20(_tokenB).transfer(msg.sender, refundAssetAmountB, default_return_value=True) # dev: transfer failed\n\n    usdValue: uint256 = self._getUsdValue(_tokenA, liqAmountA, _tokenB, liqAmountB, miniAddys)\n    log AerodromeLiquidityAdded(\n        sender = msg.sender,\n        tokenA = _tokenA,\n        tokenB = _tokenB,\n        amountA = liqAmountA,\n        amountB = liqAmountB,\n        lpAmountReceived = lpAmountReceived,\n        usdValue = usdValue,\n        recipient = _recipient,\n    )\n    return _pool, lpAmountReceived, liqAmountA, liqAmountB, usdValue\n\n\n# remove liquidity\n\n\n@external\ndef removeLiquidity(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpToken: address,\n    _lpAmount: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, uint256):\n    assert not dld.isPaused # dev: paused\n    assert self._isAllowedToPerformAction(msg.sender) # dev: no perms\n    miniAddys: ws.MiniAddys = dld._getMiniAddys(_miniAddys)\n\n    # validate tokens\n    token0: address = empty(address)\n    token1: address = empty(address)\n    token0, token1 = staticcall AeroClassicPool(_pool).tokens()\n\n    tokens: address[2] = [token0, token1]\n    assert _tokenA in tokens # dev: invalid tokenA\n    assert _tokenB in tokens # dev: invalid tokenB\n    assert _tokenA != _tokenB # dev: invalid tokens\n\n    # pre balance\n    preLegoBalance: uint256 = staticcall IERC20(_lpToken).balanceOf(self)\n\n    # lp token\n    lpAmount: uint256 = min(_lpAmount, staticcall IERC20(_lpToken).balanceOf(msg.sender))\n    assert lpAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_lpToken).transferFrom(msg.sender, self, lpAmount, default_return_value=True) # dev: transfer failed\n\n    # approvals\n    router: address = AERODROME_ROUTER\n    assert extcall IERC20(_lpToken).approve(router, lpAmount, default_return_value=True) # dev: approval failed\n\n    # remove liquidity\n    amountA: uint256 = 0\n    amountB: uint256 = 0\n    amountA, amountB = extcall AeroRouter(router).removeLiquidity(\n        _tokenA,\n        _tokenB,\n        staticcall AeroClassicPool(_pool).stable(),\n        lpAmount,\n        _minAmountA,\n        _minAmountB,\n        _recipient,\n        block.timestamp,\n    )\n    assert amountA != 0 # dev: no amountA removed\n    assert amountB != 0 # dev: no amountB removed\n\n    # reset approvals\n    assert extcall IERC20(_lpToken).approve(router, 0, default_return_value=True) # dev: approval failed\n\n    # refund if full liquidity was not removed\n    currentLegoBalance: uint256 = staticcall IERC20(_lpToken).balanceOf(self)\n    refundedLpAmount: uint256 = 0\n    if currentLegoBalance > preLegoBalance:\n        refundedLpAmount = currentLegoBalance - preLegoBalance\n        assert extcall IERC20(_lpToken).transfer(msg.sender, refundedLpAmount, default_return_value=True) # dev: transfer failed\n        lpAmount -= refundedLpAmount\n\n    usdValue: uint256 = self._getUsdValue(_tokenA, amountA, _tokenB, amountB, miniAddys)\n    log AerodromeLiquidityRemoved(\n        sender = msg.sender,\n        pool = _pool,\n        tokenA = _tokenA,\n        tokenB = _tokenB,\n        amountA = amountA,\n        amountB = amountB,\n        lpToken = _lpToken,\n        lpAmountBurned = lpAmount,\n        usdValue = usdValue,\n        recipient = _recipient,\n    )\n    return amountA, amountB, lpAmount, usdValue\n\n\n# get usd value on liquidity actions\n\n\n@internal\ndef _getUsdValue(\n    _tokenA: address,\n    _amountA: uint256,\n    _tokenB: address,\n    _amountB: uint256,\n    _miniAddys: ws.MiniAddys,\n) -> uint256:\n\n    usdValueA: uint256 = 0\n    if _amountA != 0:\n        usdValueA = staticcall Appraiser(_miniAddys.appraiser).getUsdValue(_tokenA, _amountA, _miniAddys.missionControl, _miniAddys.legoBook, _miniAddys.ledger)\n\n    usdValueB: uint256 = 0\n    if _amountB != 0:\n        usdValueB = staticcall Appraiser(_miniAddys.appraiser).getUsdValue(_tokenB, _amountB, _miniAddys.missionControl, _miniAddys.legoBook, _miniAddys.ledger)\n\n    return usdValueA + usdValueB\n\n\n#############\n# Utilities #\n#############\n\n\n@view\n@external\ndef getLpToken(_pool: address) -> address:\n    # in uniswap v2, the lp token is the pool address\n    return _pool\n\n\n@view\n@external\ndef getPoolForLpToken(_lpToken: address) -> address:\n    # in uniswap v2, the pool is the lp token address\n    return _lpToken\n\n\n@view\n@external\ndef getCoreRouterPool() -> address:\n    return self.coreRouterPool\n\n\n@view\n@external\ndef getDeepestLiqPool(_tokenA: address, _tokenB: address) -> BestPool:\n    factory: address = AERODROME_FACTORY\n    reserve0: uint256 = 0\n    reserve1: uint256 = 0\n    na: uint256 = 0\n\n    # get pool options\n    stablePool: address = staticcall AeroFactory(factory).getPool(_tokenA, _tokenB, True)\n    volatilePool: address = staticcall AeroFactory(factory).getPool(_tokenA, _tokenB, False)\n\n    # no pools found\n    if stablePool == empty(address) and volatilePool == empty(address):\n        return empty(BestPool)\n\n    # stable pool\n    stableLiquidity: uint256 = 0\n    if stablePool != empty(address):\n        reserve0, reserve1, na = staticcall AeroClassicPool(stablePool).getReserves()\n        stableLiquidity = reserve0 + reserve1\n\n    # volatile pool\n    volatileLiquidity: uint256 = 0\n    if volatilePool != empty(address):\n        reserve0, reserve1, na = staticcall AeroClassicPool(volatilePool).getReserves()\n        volatileLiquidity = reserve0 + reserve1\n\n    # best pool determined by liquidity\n    bestPoolAddr: address = stablePool\n    bestLiquidity: uint256 = stableLiquidity\n    isStable: bool = True\n    if volatileLiquidity > stableLiquidity:\n        bestPoolAddr = volatilePool\n        bestLiquidity = volatileLiquidity\n        isStable = False\n\n    return BestPool(\n        pool=bestPoolAddr,\n        fee=staticcall AeroFactory(factory).getFee(bestPoolAddr, isStable),\n        liquidity=bestLiquidity,\n        numCoins=2,\n    )\n\n\n@view\n@external\ndef getBestSwapAmountOut(_tokenIn: address, _tokenOut: address, _amountIn: uint256) -> (address, uint256):\n    factory: address = AERODROME_FACTORY\n    stablePool: address = staticcall AeroFactory(factory).getPool(_tokenIn, _tokenOut, True)\n    volatilePool: address = staticcall AeroFactory(factory).getPool(_tokenIn, _tokenOut, False)\n    if stablePool == empty(address) and volatilePool == empty(address):\n        return empty(address), 0\n\n    # stable pool\n    stableAmountOut: uint256 = 0\n    if stablePool != empty(address):\n        stableAmountOut = staticcall AeroClassicPool(stablePool).getAmountOut(_amountIn, _tokenIn)\n\n    # volatile pool\n    volatileAmountOut: uint256 = 0\n    if volatilePool != empty(address):\n        volatileAmountOut = staticcall AeroClassicPool(volatilePool).getAmountOut(_amountIn, _tokenIn)\n\n    if stableAmountOut == 0 and volatileAmountOut == 0:\n        return empty(address), 0\n\n    pool: address = stablePool\n    amountOut: uint256 = stableAmountOut\n    if volatileAmountOut > stableAmountOut:\n        pool = volatilePool\n        amountOut = volatileAmountOut\n\n    return pool, amountOut\n\n\n@view\n@external\ndef getSwapAmountOut(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n) -> uint256:\n    return staticcall AeroClassicPool(_pool).getAmountOut(_amountIn, _tokenIn)\n\n\n@view\n@external\ndef getBestSwapAmountIn(_tokenIn: address, _tokenOut: address, _amountOut: uint256) -> (address, uint256):\n    # TODO: implement stable pools\n    pool: address = staticcall AeroFactory(AERODROME_FACTORY).getPool(_tokenIn, _tokenOut, False)\n    if pool == empty(address):\n        return empty(address), max_value(uint256)\n\n    token0: address = empty(address)\n    token1: address = empty(address)\n    token0, token1 = staticcall AeroClassicPool(pool).tokens()\n    return pool, self._getAmountInForVolatilePools(pool, token0 == _tokenIn, _amountOut)\n\n\n@view\n@external\ndef getSwapAmountIn(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountOut: uint256,\n) -> uint256:\n    if not staticcall AeroClassicPool(_pool).stable():\n        token0: address = empty(address)\n        token1: address = empty(address)\n        token0, token1 = staticcall AeroClassicPool(_pool).tokens()\n        return self._getAmountInForVolatilePools(_pool, token0 == _tokenIn, _amountOut)\n    else:\n        return max_value(uint256) # TODO: implement stable pools\n\n\n@view\n@external\ndef getAddLiqAmountsIn(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _availAmountA: uint256,\n    _availAmountB: uint256,\n) -> (uint256, uint256, uint256):\n    return staticcall AeroRouter(AERODROME_ROUTER).quoteAddLiquidity(_tokenA, _tokenB, staticcall AeroClassicPool(_pool).stable(), AERODROME_FACTORY, _availAmountA, _availAmountB)\n\n\n@view\n@external\ndef getRemoveLiqAmountsOut(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpAmount: uint256,\n) -> (uint256, uint256):\n    return staticcall AeroRouter(AERODROME_ROUTER).quoteRemoveLiquidity(_tokenA, _tokenB, staticcall AeroClassicPool(_pool).stable(), AERODROME_FACTORY, _lpAmount)\n\n\n@view\n@external\ndef getPrice(_asset: address, _decimals: uint256) -> uint256:\n    return 0 # TODO: implement price\n\n\n@view\n@external\ndef getPriceUnsafe(_pool: address, _targetToken: address, _appraiser: address = empty(address)) -> uint256:\n    if not staticcall AeroClassicPool(_pool).stable():\n        return self._getPriceUnsafeVolatilePool(_pool, _targetToken, _appraiser)\n    else:\n        return 0 # TODO: implement stable pools\n\n\n# internal utils\n\n\n@view\n@internal\ndef _getPriceUnsafeVolatilePool(_pool: address, _targetToken: address, _appraiser: address) -> uint256:\n    token0: address = empty(address)\n    token1: address = empty(address)\n    token0, token1 = staticcall AeroClassicPool(_pool).tokens()\n\n    # appraiser\n    appraiser: address = _appraiser\n    if _appraiser == empty(address):\n        appraiser = addys._getAppraiserAddr()\n\n    # alt price\n    altPrice: uint256 = 0\n    if _targetToken == token0:\n        altPrice = staticcall Appraiser(appraiser).getRipePrice(token1)\n    else:\n        altPrice = staticcall Appraiser(appraiser).getRipePrice(token0)\n\n    # return early if no alt price\n    if altPrice == 0:\n        return 0\n\n    # reserves\n    reserve0: uint256 = 0\n    reserve1: uint256 = 0\n    na: uint256 = 0\n    reserve0, reserve1, na = staticcall AeroClassicPool(_pool).getReserves()\n\n    # avoid division by zero\n    if reserve0 == 0 or reserve1 == 0:\n        return 0  \n\n    # price of token0 in token1\n    priceZeroToOne: uint256 = reserve1 * EIGHTEEN_DECIMALS // reserve0\n\n    # adjust for decimals: price should be in 18 decimals\n    decimals0: uint256 = convert(staticcall IERC20Detailed(token0).decimals(), uint256)\n    decimals1: uint256 = convert(staticcall IERC20Detailed(token1).decimals(), uint256)\n    if decimals0 > decimals1:\n        scaleFactor: uint256 = 10 ** (decimals0 - decimals1)\n        priceZeroToOne = priceZeroToOne * scaleFactor\n    elif decimals1 > decimals0:\n        scaleFactor: uint256 = 10 ** (decimals1 - decimals0)\n        priceZeroToOne = priceZeroToOne // scaleFactor\n\n    # if _targetToken is token1, make price inverse\n    priceToOther: uint256 = priceZeroToOne\n    if _targetToken == token1:\n        priceToOther = EIGHTEEN_DECIMALS * EIGHTEEN_DECIMALS // priceZeroToOne\n\n    return altPrice * priceToOther // EIGHTEEN_DECIMALS\n\n\n@view\n@internal\ndef _getAmountInForVolatilePools(_pool: address, _zeroForOne: bool, _amountOut: uint256) -> uint256:\n    if _amountOut == 0 or _amountOut == max_value(uint256):\n        return max_value(uint256)\n\n    reserve0: uint256 = 0\n    reserve1: uint256 = 0\n    na: uint256 = 0\n    reserve0, reserve1, na = staticcall AeroClassicPool(_pool).getReserves()\n    if reserve0 == 0 or reserve1 == 0:\n        return max_value(uint256)\n\n    # determine which token is which\n    reserveIn: uint256 = reserve0\n    reserveOut: uint256 = reserve1\n    if not _zeroForOne:\n        reserveIn = reserve1\n        reserveOut = reserve0\n\n    # prevent division by zero: if _amountOut == reserveOut,\n    if _amountOut >= reserveOut:\n        return max_value(uint256)\n\n    fee: uint256 = staticcall AeroFactory(AERODROME_FACTORY).getFee(_pool, False)\n    numerator: uint256 = reserveIn * _amountOut * 100_00\n    denominator: uint256 = (reserveOut - _amountOut) * (100_00 - fee)\n    return (numerator // denominator) + 1\n\n\n#########\n# Other #\n#########\n\n\n@external\ndef depositForYield(\n    _asset: address,\n    _amount: uint256,\n    _vaultAddr: address,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, address, uint256, uint256):\n    return 0, empty(address), 0, 0\n\n\n@external\ndef withdrawFromYield(\n    _vaultToken: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, address, uint256, uint256):\n    return 0, empty(address), 0, 0\n\n\n@external\ndef mintOrRedeemAsset(\n    _tokenIn: address,\n    _tokenOut: address,\n    _tokenInAmount: uint256,\n    _minAmountOut: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, bool, uint256):\n    return 0, 0, False, 0\n\n\n@external\ndef confirmMintOrRedeemAsset(\n    _tokenIn: address,\n    _tokenOut: address,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef addCollateral(\n    _asset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef removeCollateral(\n    _asset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef borrow(\n    _borrowAsset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef repayDebt(\n    _paymentAsset: address,\n    _paymentAmount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef claimRewards(\n    _user: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _extraData: bytes32,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    # backwards compatibility\n    return 0, 0\n\n\n@external\ndef claimIncentives(\n    _user: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _proofs: DynArray[bytes32, MAX_PROOFS],\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef addLiquidityConcentrated(\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _tickLower: int24,\n    _tickUpper: int24,\n    _amountA: uint256,\n    _amountB: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, uint256, uint256):\n    return 0, 0, 0, 0, 0\n\n\n@external\ndef removeLiquidityConcentrated(\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _liqToRemove: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, bool, uint256):\n    return 0, 0, 0, False, 0\n\n\n\n@view\n@external\ndef getAccessForLego(_user: address, _action: ws.ActionType) -> (address, String[64], uint256):\n    return empty(address), empty(String[64]), 0\n",
            "sha256sum": "6cdcbb9a2ef7cc0cbdb5c6551b017fca32648000cffe76bc6239628619de1966"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/legos/dexes/AeroClassic.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.3+commit.bff19ea2",
        "integrity": "625a97efc4b4409d4bfbd279c2a2633d789d07e024fb698e245151409e8c29b8"
      },
      "args": "00000000000000000000000044cf3c4f000dfd76a35d03298049d37be688d6f9000000000000000000000000420dd381b31aef6683db6b902084cb0ffece40da000000000000000000000000cf77a3ba9a5ca399b7c97c74d54e5b1beb874e43000000000000000000000000cdac0d6c6c59727a65f871236188350531885c430000000000000000000000006162df1b329e157479f8f1407e888260e0ec3d2b",
      "file": "contracts/legos/dexes/AeroClassic.vy"
    },
    "AeroSlipstream": {
      "address": "0x05a710A8CfCeaEAd0A2533bA3dc137EC37B1E2dD",
      "abi": [
        {
          "name": "AeroSlipStreamSwap",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenIn",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenOut",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amountIn",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "amountOut",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "numTokens",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AeroSlipStreamLiquidityAdded",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenA",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenB",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amountA",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "amountB",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "liquidityAdded",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "nftTokenId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AeroSlipStreamLiquidityRemoved",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": false
            },
            {
              "name": "pool",
              "type": "address",
              "indexed": true
            },
            {
              "name": "nftTokenId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "tokenA",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenB",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amountA",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "amountB",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "liquidityRemoved",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AeroSlipStreamNftRecovered",
          "inputs": [
            {
              "name": "collection",
              "type": "address",
              "indexed": true
            },
            {
              "name": "nftTokenId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AeroSlipstreamFeesCollected",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "nftTokenId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "token0",
              "type": "address",
              "indexed": true
            },
            {
              "name": "token1",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount0",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "amount1",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LegoPauseModified",
          "inputs": [
            {
              "name": "isPaused",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LegoFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "balance",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddys",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "undyToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "hatchery",
                  "type": "address"
                },
                {
                  "name": "lootDistributor",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                },
                {
                  "name": "walletBackpack",
                  "type": "address"
                },
                {
                  "name": "billing",
                  "type": "address"
                },
                {
                  "name": "vaultRegistry",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUndyHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pause",
          "inputs": [
            {
              "name": "_shouldPause",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFundsMany",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_assets",
              "type": "address[]"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "legoId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isPaused",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasCapability",
          "inputs": [
            {
              "name": "_action",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "onERC721Received",
          "inputs": [
            {
              "name": "_operator",
              "type": "address"
            },
            {
              "name": "_owner",
              "type": "address"
            },
            {
              "name": "_tokenId",
              "type": "uint256"
            },
            {
              "name": "_data",
              "type": "bytes"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bytes4"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRegistries",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isYieldLego",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isDexLego",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_tokenPath",
              "type": "address[]"
            },
            {
              "name": "_poolPath",
              "type": "address[]"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_tokenPath",
              "type": "address[]"
            },
            {
              "name": "_poolPath",
              "type": "address[]"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "uniswapV3SwapCallback",
          "inputs": [
            {
              "name": "_amount0Delta",
              "type": "int256"
            },
            {
              "name": "_amount1Delta",
              "type": "int256"
            },
            {
              "name": "_data",
              "type": "bytes"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLpToken",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPoolForLpToken",
          "inputs": [
            {
              "name": "_lpToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getCoreRouterPool",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getDeepestLiqPool",
          "inputs": [
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "fee",
                  "type": "uint256"
                },
                {
                  "name": "liquidity",
                  "type": "uint256"
                },
                {
                  "name": "numCoins",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getBestSwapAmountOut",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountIn",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getSwapAmountOut",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountIn",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getBestSwapAmountIn",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountOut",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getSwapAmountIn",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountOut",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddLiqAmountsIn",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_availAmountA",
              "type": "uint256"
            },
            {
              "name": "_availAmountB",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRemoveLiqAmountsOut",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPrice",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_decimals",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPriceUnsafe",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_targetToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPriceUnsafe",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_targetToken",
              "type": "address"
            },
            {
              "name": "_appraiser",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverNft",
          "inputs": [
            {
              "name": "_collection",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositForYield",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositForYield",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawFromYield",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawFromYield",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_tokenInAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_tokenInAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmMintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmMintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_borrowAsset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_borrowAsset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_paymentAsset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_paymentAsset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimIncentives",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_proofs",
              "type": "bytes32[]"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimIncentives",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_proofs",
              "type": "bytes32[]"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAccessForLego",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_action",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "string"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "AERO_SLIPSTREAM_FACTORY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "AERO_SLIPSTREAM_NFT_MANAGER",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "AERO_SLIPSTREAM_QUOTER",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "RIPE_REGISTRY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "coreRouterPool",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_undyHq",
              "type": "address"
            },
            {
              "name": "_aeroFactory",
              "type": "address"
            },
            {
              "name": "_aeroNftPositionManager",
              "type": "address"
            },
            {
              "name": "_aeroQuoter",
              "type": "address"
            },
            {
              "name": "_coreRouterPool",
              "type": "address"
            },
            {
              "name": "_ripeRegistry",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "interfaces/WalletStructs.vyi": {
            "content": "# @version 0.4.3\n\nflag ActionType:\n    TRANSFER\n    EARN_DEPOSIT\n    EARN_WITHDRAW\n    EARN_REBALANCE\n    SWAP\n    MINT_REDEEM\n    CONFIRM_MINT_REDEEM\n    ADD_COLLATERAL\n    REMOVE_COLLATERAL\n    BORROW\n    REPAY_DEBT\n    REWARDS\n    ETH_TO_WETH\n    WETH_TO_ETH\n    ADD_LIQ\n    REMOVE_LIQ\n    ADD_LIQ_CONC\n    REMOVE_LIQ_CONC\n    PAY_CHEQUE\n\nstruct WalletAssetData:\n    assetBalance: uint256\n    usdValue: uint256\n    isYieldAsset: bool\n    lastPricePerShare: uint256\n\nstruct ActionData:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    billing: address\n    vaultRegistry: address\n    wallet: address\n    walletConfig: address\n    walletOwner: address\n    inEjectMode: bool\n    isFrozen: bool\n    lastTotalUsdValue: uint256\n    signer: address\n    isManager: bool\n    legoId: uint256\n    legoAddr: address\n    eth: address\n    weth: address\n\nstruct MiniAddys:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    appraiser: address",
            "sha256sum": "466493c129135c95470aaf70eeddc936632f7b0f813396e5a7ddc03bea9da518"
          },
          "interfaces/LegoPartner.vyi": {
            "content": "# @version 0.4.3\n\nfrom interfaces import WalletStructs as ws\n\nMAX_TOKEN_PATH: constant(uint256) = 5\nMAX_RECOVER_ASSETS: constant(uint256) = 20\nMAX_PROOFS: constant(uint256) = 25\n\n@external\ndef addLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _tickLower: int24, _tickUpper: int24, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef addLiquidity(_pool: address, _tokenA: address, _tokenB: address, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _minLpAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (address, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef removeLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _liqToRemove: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef removeLiquidity(_pool: address, _tokenA: address, _tokenB: address, _lpToken: address, _lpAmount: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef mintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _tokenInAmount: uint256, _minAmountOut: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef swapTokens(_amountIn: uint256, _minAmountOut: uint256, _tokenPath: DynArray[address, MAX_TOKEN_PATH], _poolPath: DynArray[address, MAX_TOKEN_PATH - 1], _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256):\n    ...\n\n@external\ndef depositForYield(_asset: address, _amount: uint256, _vaultAddr: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef withdrawFromYield(_vaultToken: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef confirmMintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef borrow(_borrowAsset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef repayDebt(_paymentAsset: address, _paymentAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef claimIncentives(_user: address, _rewardToken: address, _rewardAmount: uint256, _proofs: DynArray[bytes32, MAX_PROOFS], _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef removeCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef addCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@view\n@external\ndef getAccessForLego(_user: address, _action: ws.ActionType) -> (address, String[64], uint256):\n    ...\n\n@view\n@external\ndef hasCapability(_action: ws.ActionType) -> bool:\n    ...\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    ...\n\n@view\n@external\ndef isYieldLego() -> bool:\n    ...\n\n@view\n@external\ndef isDexLego() -> bool:\n    ...\n\n\n# common\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "f2afb7bd72d4301aea77bbe4177b7ae954ba6f6b76af363965993eb92ad0b715"
          },
          "contracts/modules/Addys.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\ninterface UndyHq:\n    def isValidAddr(_addr: address) -> bool: view\n    def getAddr(_regId: uint256) -> address: view\n    def undyToken() -> address: view\n\ninterface Switchboard:\n    def isSwitchboardAddr(_addr: address) -> bool: view\n\ninterface LegoBook:\n    def isLegoAddr(_addr: address) -> bool: view\n\nstruct Addys:\n    hq: address\n    undyToken: address\n    ledger: address\n    missionControl: address\n    legoBook: address\n    switchboard: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    walletBackpack: address\n    billing: address\n    vaultRegistry: address\n\n# hq\nUNDY_HQ_FOR_ADDYS: immutable(address)\n\n# core addys\nLEDGER_ID: constant(uint256) = 1\nMISSION_CONTROL_ID: constant(uint256) = 2\nLEGO_BOOK_ID: constant(uint256) = 3\nSWITCHBOARD_ID: constant(uint256) = 4\nHATCHERY_ID: constant(uint256) = 5\nLOOT_DISTRIBUTOR_ID: constant(uint256) = 6\nAPPRAISER_ID: constant(uint256) = 7\nWALLET_BACKPACK_ID: constant(uint256) = 8\nBILLING_ID: constant(uint256) = 9\nVAULT_REGISTRY_ID: constant(uint256) = 10\n\n\n@deploy\ndef __init__(_undyHq: address):\n    assert _undyHq != empty(address) # dev: invalid undy hq\n    UNDY_HQ_FOR_ADDYS = _undyHq\n\n\n########\n# Core #\n########\n\n\n@view\n@external\ndef getAddys() -> Addys:\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _getAddys(_addys: Addys = empty(Addys)) -> Addys:\n    if _addys.hq != empty(address):\n        return _addys\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _generateAddys() -> Addys:\n    hq: address = UNDY_HQ_FOR_ADDYS\n    return Addys(\n        hq = hq,\n        undyToken = staticcall UndyHq(hq).undyToken(),\n        ledger = staticcall UndyHq(hq).getAddr(LEDGER_ID),\n        missionControl = staticcall UndyHq(hq).getAddr(MISSION_CONTROL_ID),\n        legoBook = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID),\n        switchboard = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID),\n        hatchery = staticcall UndyHq(hq).getAddr(HATCHERY_ID),\n        lootDistributor = staticcall UndyHq(hq).getAddr(LOOT_DISTRIBUTOR_ID),\n        appraiser = staticcall UndyHq(hq).getAddr(APPRAISER_ID),\n        walletBackpack = staticcall UndyHq(hq).getAddr(WALLET_BACKPACK_ID),\n        billing = staticcall UndyHq(hq).getAddr(BILLING_ID),\n        vaultRegistry = staticcall UndyHq(hq).getAddr(VAULT_REGISTRY_ID),\n    )\n\n\n##########\n# Tokens #\n##########\n\n\n@view\n@internal\ndef _getUndyToken() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).undyToken()\n\n\n###########\n# Helpers #\n###########\n\n\n# undy hq\n\n\n@view\n@external\ndef getUndyHq() -> address:\n    return self._getUndyHq()\n\n\n@view\n@internal\ndef _getUndyHq() -> address:\n    return UNDY_HQ_FOR_ADDYS\n\n\n# utils\n\n\n@view\n@internal\ndef _isValidUndyAddr(_addr: address, _hq: address = empty(address)) -> bool:\n    hq: address = _hq\n    if _hq == empty(address):\n        hq = UNDY_HQ_FOR_ADDYS\n    \n    # core departments\n    if staticcall UndyHq(hq).isValidAddr(_addr):\n        return True\n\n    # lego book\n    legoBook: address = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID)\n    if legoBook != empty(address) and staticcall LegoBook(legoBook).isLegoAddr(_addr):\n        return True\n\n    # switchboard config\n    switchboard: address = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID)\n    if switchboard != empty(address) and staticcall Switchboard(switchboard).isSwitchboardAddr(_addr):\n        return True\n\n    return False\n\n\n@view\n@internal\ndef _isSwitchboardAddr(_addr: address) -> bool:\n    switchboard: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n    if switchboard == empty(address):\n        return False\n    return staticcall Switchboard(switchboard).isSwitchboardAddr(_addr)\n\n\n@view\n@internal\ndef _isLegoBookAddr(_addr: address) -> bool:\n    legoBook: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n    if legoBook == empty(address):\n        return False\n    return staticcall LegoBook(legoBook).isLegoAddr(_addr)\n\n\n###############\n# Departments #\n###############\n\n\n# ledger\n\n\n@view\n@internal\ndef _getLedgerId() -> uint256:\n    return LEDGER_ID\n\n\n@view\n@internal\ndef _getLedgerAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEDGER_ID)\n\n\n# mission control\n\n\n@view\n@internal\ndef _getMissionControlId() -> uint256:\n    return MISSION_CONTROL_ID\n\n\n@view\n@internal\ndef _getMissionControlAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(MISSION_CONTROL_ID)\n\n\n# lego book\n\n\n@view\n@internal\ndef _getLegoBookId() -> uint256:\n    return LEGO_BOOK_ID\n\n\n@view\n@internal\ndef _getLegoBookAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n\n\n# switchboard\n\n\n@view\n@internal\ndef _getSwitchboardId() -> uint256:\n    return SWITCHBOARD_ID\n\n\n@view\n@internal\ndef _getSwitchboardAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n\n\n# hatchery\n\n\n@view\n@internal\ndef _getHatcheryId() -> uint256:\n    return HATCHERY_ID\n\n\n@view\n@internal\ndef _getHatcheryAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(HATCHERY_ID)\n\n\n# loot distributor\n\n\n@view\n@internal\ndef _getLootDistributorId() -> uint256:\n    return LOOT_DISTRIBUTOR_ID\n\n\n@view\n@internal\ndef _getLootDistributorAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LOOT_DISTRIBUTOR_ID)\n\n\n# appraiser\n\n\n@view\n@internal\ndef _getAppraiserId() -> uint256:\n    return APPRAISER_ID\n\n\n@view\n@internal\ndef _getAppraiserAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(APPRAISER_ID)\n\n\n# wallet backpack\n\n\n@view\n@internal\ndef _getWalletBackpackId() -> uint256:\n    return WALLET_BACKPACK_ID\n\n\n@view\n@internal\ndef _getWalletBackpackAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(WALLET_BACKPACK_ID)\n\n\n# billing\n\n\n@view\n@internal\ndef _getBillingId() -> uint256:\n    return BILLING_ID\n\n\n@view\n@internal\ndef _getBillingAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(BILLING_ID)\n\n\n# vault registry\n\n\n@view\n@internal\ndef _getVaultRegistryId() -> uint256:\n    return VAULT_REGISTRY_ID\n\n\n@view\n@internal\ndef _getVaultRegistryAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(VAULT_REGISTRY_ID)",
            "sha256sum": "4df6b72db9bb417d1af81660175be1450cfb7b3575f3d17a5b8a130bff87b781"
          },
          "contracts/modules/DexLegoData.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nuses: addys\n\nimport contracts.modules.Addys as addys\n\nfrom interfaces import WalletStructs as ws\nfrom ethereum.ercs import IERC20\n\nevent LegoPauseModified:\n    isPaused: bool\n\nevent LegoFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    balance: uint256\n\n# config\nlegoId: public(uint256)\nisPaused: public(bool)\n\nMAX_RECOVER_ASSETS: constant(uint256) = 20\n\n\n@deploy\ndef __init__(_shouldPause: bool):\n    self.isPaused = _shouldPause\n\n\n###########\n# General #\n###########\n\n\n# fill mini addys\n\n\n@view\n@internal\ndef _getMiniAddys(_miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> ws.MiniAddys:\n    if _miniAddys.ledger != empty(address):\n        return _miniAddys\n    return ws.MiniAddys(\n        ledger = addys._getLedgerAddr(),\n        missionControl = addys._getMissionControlAddr(),\n        legoBook = addys._getLegoBookAddr(),\n        appraiser = addys._getAppraiserAddr(),\n    )\n\n\n# activate\n\n\n@external\ndef pause(_shouldPause: bool):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert _shouldPause != self.isPaused # dev: no change\n    self.isPaused = _shouldPause\n    log LegoPauseModified(isPaused=_shouldPause)\n\n\n# recover funds\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    self._recoverFunds(_recipient, _asset)\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, MAX_RECOVER_ASSETS]):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    for a: address in _assets:\n        self._recoverFunds(_recipient, a)\n\n\n@internal\ndef _recoverFunds(_recipient: address, _asset: address):\n    assert empty(address) not in [_recipient, _asset] # dev: invalid recipient or asset\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    assert balance != 0 # dev: nothing to recover\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log LegoFundsRecovered(asset=_asset, recipient=_recipient, balance=balance)",
            "sha256sum": "75b15af2475ab409d4b5fd057509d14c20564ebd7fcb0850e3b61397d8e3af48"
          },
          "contracts/legos/dexes/AeroSlipstream.vy": {
            "content": "#     _____  _____  __  __    ____   _____  _____  _____ \n#    |  _  \\/   __\\/  \\/  \\  /  _/  /   __\\/   __\\/  _  \\\n#    |  |  ||   __|>-    -<  |  |---|   __||  |_ ||  |  |\n#    |_____/\\_____/\\__/\\__/  \\_____/\\_____/\\_____/\\_____/\n#                                                                       \n#     \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n#     \u2551  ** Aero Slipstream Lego **             \u2551\n#     \u2551  Integration with Aerodrome Slipstream. \u2551\n#     \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n#\n#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nimplements: Lego\nimplements: IUniswapV3Callback\n\nexports: addys.__interface__\nexports: dld.__interface__\n\ninitializes: addys\ninitializes: dld[addys := addys]\n\nfrom interfaces import LegoPartner as Lego\nfrom interfaces import WalletStructs as ws\n\nimport contracts.modules.Addys as addys\nimport contracts.modules.DexLegoData as dld\n\nfrom ethereum.ercs import IERC20\nfrom ethereum.ercs import IERC20Detailed\nfrom ethereum.ercs import IERC721\n\n# `getSwapAmountOut()` and `getSwapAmountIn()` cannot be view functions, sadly\n# keeping here to uncomment to test all other functions\n# implements: DexLego\n# from interfaces import DexLego as DexLego\n\ninterface AeroSlipStreamPool:\n    def swap(_recipient: address, _zeroForOne: bool, _amountSpecified: int256, _sqrtPriceLimitX96: uint160, _data: Bytes[256]) -> (int256, int256): nonpayable\n    def slot0() -> (uint160, int24, uint16, uint16, uint16, bool): view\n    def tickSpacing() -> int24: view\n    def liquidity() -> uint128: view\n    def token0() -> address: view\n    def token1() -> address: view\n    def fee() -> uint24: view\n\ninterface AeroNftPositionManager:\n    def increaseLiquidity(_params: IncreaseLiquidityParams) -> (uint128, uint256, uint256): nonpayable\n    def decreaseLiquidity(_params: DecreaseLiquidityParams) -> (uint256, uint256): nonpayable\n    def mint(_params: MintParams) -> (uint256, uint128, uint256, uint256): nonpayable\n    def collect(_params: CollectParams) -> (uint256, uint256): nonpayable\n    def positions(_tokenId: uint256) -> PositionData: view\n    def burn(_tokenId: uint256): nonpayable\n\ninterface Appraiser:\n    def getUsdValue(_asset: address, _amount: uint256, _missionControl: address = empty(address), _legoBook: address = empty(address), _ledger: address = empty(address)) -> uint256: view\n    def getRipePrice(_asset: address) -> uint256: view\n\ninterface AeroQuoter:\n    def quoteExactOutputSingle(_params: QuoteExactOutputSingleParams) -> (uint256, uint160, uint32, uint256): nonpayable\n    def quoteExactInputSingle(_params: QuoteExactInputSingleParams) -> (uint256, uint160, uint32, uint256): nonpayable\n\ninterface IUniswapV3Callback:\n    def uniswapV3SwapCallback(_amount0Delta: int256, _amount1Delta: int256, _data: Bytes[256]): nonpayable\n\ninterface AeroSlipStreamFactory:\n    def getPool(_tokenA: address, _tokenB: address, _tickSpacing: int24) -> address: view\n\ninterface VaultRegistry:\n    def isEarnVault(_vaultAddr: address) -> bool: view\n\ninterface Ledger:\n    def isUserWallet(_user: address) -> bool: view\n\ninterface Registry:\n    def isValidAddr(_addr: address) -> bool: view\n\nstruct PoolSwapData:\n    pool: address\n    tokenIn: address\n    amountInDesired: uint256\n    sender: address\n\nstruct BestPool:\n    pool: address\n    fee: uint256\n    liquidity: uint256\n    numCoins: uint256\n\nstruct QuoteExactInputSingleParams:\n    tokenIn: address\n    tokenOut: address\n    amountIn: uint256\n    tickSpacing: int24\n    sqrtPriceLimitX96: uint160\n\nstruct QuoteExactOutputSingleParams:\n    tokenIn: address\n    tokenOut: address\n    amount: uint256\n    tickSpacing: int24\n    sqrtPriceLimitX96: uint160\n\nstruct MintParams:\n    token0: address\n    token1: address\n    tickSpacing: int24\n    tickLower: int24\n    tickUpper: int24\n    amount0Desired: uint256\n    amount1Desired: uint256\n    amount0Min: uint256\n    amount1Min: uint256\n    recipient: address\n    deadline: uint256\n    sqrtPriceX96: uint160\n\nstruct IncreaseLiquidityParams:\n    tokenId: uint256\n    amount0Desired: uint256\n    amount1Desired: uint256\n    amount0Min: uint256\n    amount1Min: uint256\n    deadline: uint256\n\nstruct DecreaseLiquidityParams:\n    tokenId: uint256\n    liquidity: uint128\n    amount0Min: uint256\n    amount1Min: uint256\n    deadline: uint256\n\nstruct CollectParams:\n    tokenId: uint256\n    recipient: address\n    amount0Max: uint128\n    amount1Max: uint128\n\nstruct PositionData:\n    nonce: uint96\n    operator: address\n    token0: address\n    token1: address\n    tickSpacing: uint24\n    tickLower: int24\n    tickUpper: int24\n    liquidity: uint128\n    feeGrowthInside0LastX128: uint256\n    feeGrowthInside1LastX128: uint256\n    tokensOwed0: uint128\n    tokensOwed1: uint128\n\nevent AeroSlipStreamSwap:\n    sender: indexed(address)\n    tokenIn: indexed(address)\n    tokenOut: indexed(address)\n    amountIn: uint256\n    amountOut: uint256\n    usdValue: uint256\n    numTokens: uint256\n    recipient: address\n\nevent AeroSlipStreamLiquidityAdded:\n    sender: indexed(address)\n    tokenA: indexed(address)\n    tokenB: indexed(address)\n    amountA: uint256\n    amountB: uint256\n    liquidityAdded: uint256\n    nftTokenId: uint256\n    usdValue: uint256\n    recipient: address\n\nevent AeroSlipStreamLiquidityRemoved:\n    sender: address\n    pool: indexed(address)\n    nftTokenId: uint256\n    tokenA: indexed(address)\n    tokenB: indexed(address)\n    amountA: uint256\n    amountB: uint256\n    liquidityRemoved: uint256\n    usdValue: uint256\n    recipient: address\n\nevent AeroSlipStreamNftRecovered:\n    collection: indexed(address)\n    nftTokenId: uint256\n    recipient: indexed(address)\n\nevent AeroSlipstreamFeesCollected:\n    sender: indexed(address)\n    nftTokenId: uint256\n    token0: indexed(address)\n    token1: indexed(address)\n    amount0: uint256\n    amount1: uint256\n    recipient: address\n\n# transient storage\npoolSwapData: transient(PoolSwapData)\n\n# aero\nAERO_SLIPSTREAM_FACTORY: public(immutable(address))\nAERO_SLIPSTREAM_NFT_MANAGER: public(immutable(address))\nAERO_SLIPSTREAM_QUOTER: public(immutable(address))\nRIPE_REGISTRY: public(immutable(address))\ncoreRouterPool: public(address)\n\nTICK_SPACING: constant(int24[5]) = [1, 50, 100, 200, 2000]\nMIN_SQRT_RATIO_PLUS_ONE: constant(uint160) = 4295128740\nMAX_SQRT_RATIO_MINUS_ONE: constant(uint160) = 1461446703485210103287273052203988822378723970341\nTICK_LOWER: constant(int24) = -887272\nTICK_UPPER: constant(int24) = 887272\nERC721_RECEIVE_DATA: constant(Bytes[1024]) = b\"UE721\"\nEIGHTEEN_DECIMALS: constant(uint256) = 10 ** 18\nUNISWAP_Q96: constant(uint256) = 2 ** 96  # uniswap's fixed point scaling factor\nMAX_TOKEN_PATH: constant(uint256) = 5\nMAX_PROOFS: constant(uint256) = 25\n\n\n@deploy\ndef __init__(\n    _undyHq: address,\n    _aeroFactory: address,\n    _aeroNftPositionManager: address,\n    _aeroQuoter: address,\n    _coreRouterPool: address,\n    _ripeRegistry: address,\n):\n    addys.__init__(_undyHq)\n    dld.__init__(False)\n\n    assert empty(address) not in [_aeroFactory, _aeroNftPositionManager, _aeroQuoter, _coreRouterPool, _ripeRegistry] # dev: invalid addrs\n    AERO_SLIPSTREAM_FACTORY = _aeroFactory\n    AERO_SLIPSTREAM_NFT_MANAGER = _aeroNftPositionManager\n    AERO_SLIPSTREAM_QUOTER = _aeroQuoter\n    RIPE_REGISTRY = _ripeRegistry\n    self.coreRouterPool = _coreRouterPool\n\n\n@view\n@external\ndef hasCapability(_action: ws.ActionType) -> bool:\n    return _action in (\n        ws.ActionType.SWAP |\n        ws.ActionType.ADD_LIQ_CONC | \n        ws.ActionType.REMOVE_LIQ_CONC\n    )\n\n\n@view\n@external\ndef onERC721Received(_operator: address, _owner: address, _tokenId: uint256, _data: Bytes[1024]) -> bytes4:\n    # must implement method for safe NFT transfers\n    assert _data == ERC721_RECEIVE_DATA # dev: did not receive from within Underscore wallet\n    return method_id(\"onERC721Received(address,address,uint256,bytes)\", output_type=bytes4)\n\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    return [AERO_SLIPSTREAM_FACTORY, AERO_SLIPSTREAM_NFT_MANAGER, AERO_SLIPSTREAM_QUOTER]\n\n\n@view\n@external\ndef isYieldLego() -> bool:\n    return False\n\n\n@view\n@external\ndef isDexLego() -> bool:\n    return True\n\n\n@view\n@internal\ndef _isAllowedToPerformAction(_caller: address) -> bool:\n    if staticcall VaultRegistry(addys._getVaultRegistryAddr()).isEarnVault(_caller):\n        return True\n    if staticcall Ledger(addys._getLedgerAddr()).isUserWallet(_caller):\n        return True\n    return staticcall Registry(RIPE_REGISTRY).isValidAddr(_caller)\n\n\n#########\n# Swaps #\n#########\n\n\n@external\ndef swapTokens(\n    _amountIn: uint256,\n    _minAmountOut: uint256,\n    _tokenPath: DynArray[address, MAX_TOKEN_PATH],\n    _poolPath: DynArray[address, MAX_TOKEN_PATH - 1],\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256):\n    assert not dld.isPaused # dev: paused\n    assert self._isAllowedToPerformAction(msg.sender) # dev: no perms\n    miniAddys: ws.MiniAddys = dld._getMiniAddys(_miniAddys)\n\n    # validate inputs\n    numTokens: uint256 = len(_tokenPath)\n    numPools: uint256 = len(_poolPath)\n    assert numTokens >= 2 # dev: invalid path\n    assert numPools == numTokens - 1 # dev: invalid path\n\n    # get first token and last token\n    tokenIn: address = _tokenPath[0]\n    tokenOut: address = _tokenPath[numTokens - 1]\n\n    # pre balances\n    preLegoBalance: uint256 = staticcall IERC20(tokenIn).balanceOf(self)\n\n    # transfer deposit asset to this contract\n    amountIn: uint256 = min(_amountIn, staticcall IERC20(tokenIn).balanceOf(msg.sender))\n    assert amountIn != 0 # dev: nothing to transfer\n    assert extcall IERC20(tokenIn).transferFrom(msg.sender, self, amountIn, default_return_value=True) # dev: transfer failed\n\n    # adjust min amount out\n    minAmountOut: uint256 = _minAmountOut\n    if amountIn < _amountIn and _amountIn != max_value(uint256):\n        minAmountOut = _minAmountOut * amountIn // _amountIn\n\n    # iterate through swap routes\n    aeroFactory: address = AERO_SLIPSTREAM_FACTORY\n    tempAmountIn: uint256 = amountIn\n    for i: uint256 in range(numTokens - 1, bound=MAX_TOKEN_PATH):\n        tempTokenIn: address = _tokenPath[i]\n        tempTokenOut: address = _tokenPath[i + 1]\n        tempPool: address = _poolPath[i]\n\n        # transfer to self (or to recipient if last swap)\n        recipient: address = _recipient\n        if i < numTokens - 2:\n            recipient = self\n\n        # swap\n        tempAmountIn = self._swapTokensInPool(tempPool, tempTokenIn, tempTokenOut, tempAmountIn, msg.sender, recipient, aeroFactory)\n\n    # final amount\n    amountOut: uint256 = tempAmountIn\n    assert amountOut >= minAmountOut # dev: min amount out not met\n\n    # refund if full swap didn't get through\n    currentLegoBalance: uint256 = staticcall IERC20(tokenIn).balanceOf(self)\n    refundAssetAmount: uint256 = 0\n    if currentLegoBalance > preLegoBalance:\n        refundAssetAmount = currentLegoBalance - preLegoBalance\n        assert extcall IERC20(tokenIn).transfer(msg.sender, refundAssetAmount, default_return_value=True) # dev: transfer failed\n        amountIn -= refundAssetAmount\n\n    # get usd values\n    usdValue: uint256 = staticcall Appraiser(miniAddys.appraiser).getUsdValue(tokenIn, amountIn, miniAddys.missionControl, miniAddys.legoBook, miniAddys.ledger)\n    if usdValue == 0:\n        usdValue = staticcall Appraiser(miniAddys.appraiser).getUsdValue(tokenOut, amountOut, miniAddys.missionControl, miniAddys.legoBook, miniAddys.ledger)\n\n    log AeroSlipStreamSwap(\n        sender = msg.sender,\n        tokenIn = tokenIn,\n        tokenOut = tokenOut,\n        amountIn = amountIn,\n        amountOut = amountOut,\n        usdValue = usdValue,\n        numTokens = numTokens,\n        recipient = _recipient,\n    )\n    return amountIn, amountOut, usdValue\n\n\n# swap in pool\n\n\n@internal\ndef _swapTokensInPool(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n    _sender: address,\n    _recipient: address,\n    _aeroFactory: address,\n) -> uint256:\n    tokens: address[2] = [staticcall AeroSlipStreamPool(_pool).token0(), staticcall AeroSlipStreamPool(_pool).token1()]\n    assert _tokenIn in tokens # dev: invalid tokenIn\n    assert _tokenOut in tokens # dev: invalid tokenOut\n    assert _tokenIn != _tokenOut # dev: invalid tokens\n\n    # verify actual aero pool\n    assert staticcall AeroSlipStreamFactory(_aeroFactory).getPool(_tokenIn, _tokenOut, staticcall AeroSlipStreamPool(_pool).tickSpacing()) == _pool # dev: invalid pool\n\n    # save in transient storage (for use in callback)\n    self.poolSwapData = PoolSwapData(\n        pool=_pool,\n        tokenIn=_tokenIn,\n        amountInDesired=_amountIn,\n        sender=_sender,\n    )\n\n    zeroForOne: bool = _tokenIn == tokens[0]\n    sqrtPriceLimitX96: uint160 = MAX_SQRT_RATIO_MINUS_ONE\n    if zeroForOne:\n        sqrtPriceLimitX96 = MIN_SQRT_RATIO_PLUS_ONE\n\n    # perform swap\n    amount0: int256 = 0\n    amount1: int256 = 0\n    amount0, amount1 = extcall AeroSlipStreamPool(_pool).swap(_recipient, zeroForOne, convert(_amountIn, int256), sqrtPriceLimitX96, b\"\")\n\n    # check swap results\n    toAmount: uint256 = 0\n    if zeroForOne:\n        toAmount = convert(-amount1, uint256)\n    else:\n        toAmount = convert(-amount0, uint256)\n\n    assert toAmount != 0 # dev: no tokens swapped\n    return toAmount\n\n\n# callback\n\n\n@external\ndef uniswapV3SwapCallback(_amount0Delta: int256, _amount1Delta: int256, _data: Bytes[256]):\n    poolSwapData: PoolSwapData = self.poolSwapData\n    assert msg.sender == poolSwapData.pool # dev: no perms\n\n    # determine the amount to transfer based on deltas\n    # Positive delta = amount we owe the pool\n    # Negative delta = amount we receive from the pool\n    token0: address = staticcall AeroSlipStreamPool(poolSwapData.pool).token0()\n    amountToSend: uint256 = 0\n\n    # we're selling token0 for token1\n    if poolSwapData.tokenIn == token0:\n        assert _amount0Delta != 0 # dev: invalid delta\n        amountToSend = convert(_amount0Delta, uint256)\n\n    # we're selling token1 for token0\n    else:\n        assert _amount1Delta != 0 # dev: invalid delta\n        amountToSend = convert(_amount1Delta, uint256)\n\n    # transfer tokens to pool\n    assert extcall IERC20(poolSwapData.tokenIn).transfer(poolSwapData.pool, amountToSend, default_return_value=True) # dev: transfer failed\n\n    # refund unused tokens immediately (handles partial swaps in multi-hop routes)\n    if amountToSend < poolSwapData.amountInDesired:\n        refundAmount: uint256 = min(poolSwapData.amountInDesired - amountToSend, staticcall IERC20(poolSwapData.tokenIn).balanceOf(self))\n        assert extcall IERC20(poolSwapData.tokenIn).transfer(poolSwapData.sender, refundAmount, default_return_value=True) # dev: refund failed\n\n    self.poolSwapData = empty(PoolSwapData)\n\n\n#################\n# Add Liquidity #\n#################\n\n\n@external\ndef addLiquidityConcentrated(\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _tickLower: int24,\n    _tickUpper: int24,\n    _amountA: uint256,\n    _amountB: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, uint256, uint256):\n    assert not dld.isPaused # dev: paused\n    assert self._isAllowedToPerformAction(msg.sender) # dev: no perms\n    miniAddys: ws.MiniAddys = dld._getMiniAddys(_miniAddys)\n    nftPositionManager: address = AERO_SLIPSTREAM_NFT_MANAGER\n\n    # detect fee collection mode: if both tokens are empty and both amounts are zero\n    # this is a workaround to allow collecting fees without adding liquidity\n    isFeeCollectionMode: bool = (\n        _tokenA == empty(address) and\n        _tokenB == empty(address) and\n        _amountA == 0 and\n        _amountB == 0 and\n        _nftTokenId != 0\n    )\n    if isFeeCollectionMode:\n        return self._collectFeesOnly(_nftTokenId, _recipient, miniAddys)\n\n    # validate tokens\n    tokens: address[2] = [staticcall AeroSlipStreamPool(_pool).token0(), staticcall AeroSlipStreamPool(_pool).token1()]\n    assert _tokenA in tokens # dev: invalid tokenA\n    assert _tokenB in tokens # dev: invalid tokenB\n    assert _tokenA != _tokenB # dev: invalid tokens\n\n    # pre balances\n    preLegoBalanceA: uint256 = staticcall IERC20(_tokenA).balanceOf(self)\n    preLegoBalanceB: uint256 = staticcall IERC20(_tokenB).balanceOf(self)\n\n    # token a\n    liqAmountA: uint256 = min(_amountA, staticcall IERC20(_tokenA).balanceOf(msg.sender))\n    if liqAmountA != 0:\n        assert extcall IERC20(_tokenA).transferFrom(msg.sender, self, liqAmountA, default_return_value=True) # dev: transfer failed\n        assert extcall IERC20(_tokenA).approve(nftPositionManager, liqAmountA, default_return_value=True) # dev: approval failed\n\n    # token b\n    liqAmountB: uint256 = min(_amountB, staticcall IERC20(_tokenB).balanceOf(msg.sender))\n    if liqAmountB != 0:\n        assert extcall IERC20(_tokenB).transferFrom(msg.sender, self, liqAmountB, default_return_value=True) # dev: transfer failed\n        assert extcall IERC20(_tokenB).approve(nftPositionManager, liqAmountB, default_return_value=True) # dev: approval failed\n\n    # organized the index of tokens\n    token0: address = _tokenA\n    token1: address = _tokenB\n    amount0: uint256 = liqAmountA\n    amount1: uint256 = liqAmountB\n    minAmount0: uint256 = _minAmountA\n    minAmount1: uint256 = _minAmountB\n    if tokens[0] != _tokenA:\n        token0 = _tokenB\n        token1 = _tokenA\n        amount0 = liqAmountB\n        amount1 = liqAmountA\n        minAmount0 = _minAmountB\n        minAmount1 = _minAmountA\n\n    # add liquidity\n    nftTokenId: uint256 = _nftTokenId\n    liquidityAdded: uint256 = 0\n    liquidityAddedInt128: uint128 = 0\n    if _nftTokenId == 0:\n        nftTokenId, liquidityAddedInt128, amount0, amount1 = self._mintNewPosition(nftPositionManager, _pool, token0, token1, _tickLower, _tickUpper, amount0, amount1, minAmount0, minAmount1, _recipient)\n    else:\n        liquidityAddedInt128, amount0, amount1 = self._increaseExistingPosition(nftPositionManager, _nftTokenId, amount0, amount1, minAmount0, minAmount1, _recipient)\n\n    liquidityAdded = convert(liquidityAddedInt128, uint256)\n    assert liquidityAdded != 0 # dev: no liquidity added\n\n    # reset approvals\n    if liqAmountA != 0:\n        assert extcall IERC20(_tokenA).approve(nftPositionManager, 0, default_return_value=True) # dev: approval failed\n    if liqAmountB != 0:\n        assert extcall IERC20(_tokenB).approve(nftPositionManager, 0, default_return_value=True) # dev: approval failed\n\n    # refund if full liquidity was not added\n    currentLegoBalanceA: uint256 = staticcall IERC20(_tokenA).balanceOf(self)\n    refundAssetAmountA: uint256 = 0\n    if currentLegoBalanceA > preLegoBalanceA:\n        refundAssetAmountA = currentLegoBalanceA - preLegoBalanceA\n        assert extcall IERC20(_tokenA).transfer(msg.sender, refundAssetAmountA, default_return_value=True) # dev: transfer failed\n\n    currentLegoBalanceB: uint256 = staticcall IERC20(_tokenB).balanceOf(self)\n    refundAssetAmountB: uint256 = 0\n    if currentLegoBalanceB > preLegoBalanceB:\n        refundAssetAmountB = currentLegoBalanceB - preLegoBalanceB\n        assert extcall IERC20(_tokenB).transfer(msg.sender, refundAssetAmountB, default_return_value=True) # dev: transfer failed\n\n    # a/b amounts\n    liqAmountA = amount0\n    liqAmountB = amount1\n    if tokens[0] != _tokenA:\n        liqAmountA = amount1\n        liqAmountB = amount0\n\n    usdValue: uint256 = self._getUsdValue(_tokenA, liqAmountA, _tokenB, liqAmountB, miniAddys)\n    log AeroSlipStreamLiquidityAdded(\n        sender = msg.sender,\n        tokenA = _tokenA,\n        tokenB = _tokenB,\n        amountA = liqAmountA,\n        amountB = liqAmountB,\n        liquidityAdded = liquidityAdded,\n        nftTokenId = nftTokenId,\n        usdValue = usdValue,\n        recipient = _recipient,\n    )\n    return liquidityAdded, liqAmountA, liqAmountB, nftTokenId, usdValue\n\n\n# mint new position\n\n\n@internal\ndef _mintNewPosition(\n    _nftPositionManager: address,\n    _pool: address,\n    _token0: address,\n    _token1: address,\n    _tickLower: int24,\n    _tickUpper: int24,\n    _amount0: uint256,\n    _amount1: uint256,\n    _minAmount0: uint256,\n    _minAmount1: uint256,\n    _recipient: address,\n) -> (uint256, uint128, uint256, uint256):\n    tickSpacing: int24 = staticcall AeroSlipStreamPool(_pool).tickSpacing()\n\n    tickLower: int24 = 0\n    tickUpper: int24 = 0\n    tickLower, tickUpper = self._getTicks(tickSpacing, _tickLower, _tickUpper)\n\n    # mint new position\n    params: MintParams = MintParams(\n        token0=_token0,\n        token1=_token1,\n        tickSpacing=tickSpacing,\n        tickLower=tickLower,\n        tickUpper=tickUpper,\n        amount0Desired=_amount0,\n        amount1Desired=_amount1,\n        amount0Min=_minAmount0,\n        amount1Min=_minAmount1,\n        recipient=_recipient,\n        deadline=block.timestamp,\n        sqrtPriceX96=0,\n    )\n    return extcall AeroNftPositionManager(_nftPositionManager).mint(params)\n\n\n# get ticks\n\n\n@view\n@internal\ndef _getTicks(_tickSpacing: int24, _tickLower: int24, _tickUpper: int24) -> (int24, int24):\n    tickLower: int24 = _tickLower\n    if _tickLower == min_value(int24):\n        tickLower = (TICK_LOWER // _tickSpacing) * _tickSpacing\n\n    tickUpper: int24 = _tickUpper\n    if _tickUpper == max_value(int24):\n        tickUpper = (TICK_UPPER // _tickSpacing) * _tickSpacing\n\n    return tickLower, tickUpper\n\n\n# increase existing position\n\n\n@internal\ndef _increaseExistingPosition(\n    _nftPositionManager: address,\n    _tokenId: uint256,\n    _amount0: uint256,\n    _amount1: uint256,\n    _minAmount0: uint256,\n    _minAmount1: uint256,\n    _recipient: address,\n) -> (uint128, uint256, uint256):\n    assert staticcall IERC721(_nftPositionManager).ownerOf(_tokenId) == self # dev: nft not here\n\n    liquidityAddedInt128: uint128 = 0\n    amount0: uint256 = 0\n    amount1: uint256 = 0\n    params: IncreaseLiquidityParams = IncreaseLiquidityParams(\n        tokenId=_tokenId,\n        amount0Desired=_amount0,\n        amount1Desired=_amount1,\n        amount0Min=_minAmount0,\n        amount1Min=_minAmount1,\n        deadline=block.timestamp,\n    )\n    liquidityAddedInt128, amount0, amount1 = extcall AeroNftPositionManager(_nftPositionManager).increaseLiquidity(params)\n\n    # collect fees (if applicable) -- must be done before transferring nft\n    positionData: PositionData = staticcall AeroNftPositionManager(_nftPositionManager).positions(_tokenId)\n    self._collectFees(_nftPositionManager, _tokenId, _recipient, positionData)\n\n    # transfer nft to recipient\n    extcall IERC721(_nftPositionManager).safeTransferFrom(self, _recipient, _tokenId)\n\n    return liquidityAddedInt128, amount0, amount1\n\n\n# collect fees\n\n\n@internal\ndef _collectFees(_nftPositionManager: address, _tokenId: uint256, _recipient: address, _positionData: PositionData) -> (uint256, uint256):\n    if _positionData.tokensOwed0 == 0 and _positionData.tokensOwed1 == 0:\n        return 0, 0\n\n    params: CollectParams = CollectParams(\n        tokenId=_tokenId,\n        recipient=_recipient,\n        amount0Max=max_value(uint128),\n        amount1Max=max_value(uint128),\n    )\n    return extcall AeroNftPositionManager(_nftPositionManager).collect(params)\n\n\n# collect fees only (for empty positions)\n\n\n@internal\ndef _collectFeesOnly(\n    _nftTokenId: uint256,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys,\n) -> (uint256, uint256, uint256, uint256, uint256):\n    \"\"\"\n    Collect fees from a position without adding liquidity.\n    Used for edge case where position has zero liquidity but uncollected fees.\n    Returns values matching addLiquidityConcentrated signature.\n    \"\"\"\n    nftPositionManager: address = AERO_SLIPSTREAM_NFT_MANAGER\n\n    # verify we own the NFT\n    assert staticcall IERC721(nftPositionManager).ownerOf(_nftTokenId) == self # dev: nft not here\n\n    # get position data\n    positionData: PositionData = staticcall AeroNftPositionManager(nftPositionManager).positions(_nftTokenId)\n\n    # collect fees\n    amount0: uint256 = 0\n    amount1: uint256 = 0\n    amount0, amount1 = self._collectFees(nftPositionManager, _nftTokenId, _recipient, positionData)\n\n    # transfer nft back to recipient\n    extcall IERC721(nftPositionManager).safeTransferFrom(self, _recipient, _nftTokenId)\n\n    # calculate usd value of fees collected\n    usdValue: uint256 = self._getUsdValue(positionData.token0, amount0, positionData.token1, amount1, _miniAddys)\n\n    # emit event\n    log AeroSlipstreamFeesCollected(\n        sender=msg.sender,\n        nftTokenId=_nftTokenId,\n        token0=positionData.token0,\n        token1=positionData.token1,\n        amount0=amount0,\n        amount1=amount1,\n        recipient=_recipient,\n    )\n\n    # return values matching addLiquidityConcentrated signature\n    # liquidityAdded=0, amountA=amount0, amountB=amount1, nftTokenId, usdValue\n    return 0, amount0, amount1, _nftTokenId, usdValue\n\n\n####################\n# Remove Liquidity #\n####################\n\n\n@external\ndef removeLiquidityConcentrated(\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _liqToRemove: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, bool, uint256):\n    assert not dld.isPaused # dev: paused\n    assert self._isAllowedToPerformAction(msg.sender) # dev: no perms\n    miniAddys: ws.MiniAddys = dld._getMiniAddys(_miniAddys)\n\n    # make sure nft is here\n    nftPositionManager: address = AERO_SLIPSTREAM_NFT_MANAGER\n    assert staticcall IERC721(nftPositionManager).ownerOf(_nftTokenId) == self # dev: nft not here\n\n    # get position data\n    positionData: PositionData = staticcall AeroNftPositionManager(nftPositionManager).positions(_nftTokenId)\n    originalLiquidity: uint128 = positionData.liquidity\n\n    # validate tokens\n    tokens: address[2] = [positionData.token0, positionData.token1]\n    assert _tokenA in tokens # dev: invalid tokenA\n    assert _tokenB in tokens # dev: invalid tokenB\n    assert _tokenA != _tokenB # dev: invalid tokens\n\n    # organized the index of tokens\n    minAmount0: uint256 = _minAmountA\n    minAmount1: uint256 = _minAmountB\n    if _tokenA != tokens[0]:\n        minAmount0 = _minAmountB\n        minAmount1 = _minAmountA\n\n    # decrease liquidity\n    liqToRemove: uint256 = min(_liqToRemove, convert(positionData.liquidity, uint256))\n    assert liqToRemove != 0 # dev: no liquidity to remove\n\n    params: DecreaseLiquidityParams = DecreaseLiquidityParams(\n        tokenId=_nftTokenId,\n        liquidity=convert(liqToRemove, uint128),\n        amount0Min=minAmount0,\n        amount1Min=minAmount1,\n        deadline=block.timestamp,\n    )\n    amount0: uint256 = 0\n    amount1: uint256 = 0\n    amount0, amount1 = extcall AeroNftPositionManager(nftPositionManager).decreaseLiquidity(params)\n    assert amount0 != 0 or amount1 != 0 # dev: no liquidity removed\n\n    # a/b amounts\n    amountA: uint256 = amount0\n    amountB: uint256 = amount1\n    if _tokenA != tokens[0]:\n        amountA = amount1\n        amountB = amount0\n\n    # get latest position data -- collect withdrawn tokens AND any fees (if applicable)\n    positionData = staticcall AeroNftPositionManager(nftPositionManager).positions(_nftTokenId)\n    self._collectFees(nftPositionManager, _nftTokenId, _recipient, positionData)\n\n    # burn nft (if applicable)\n    isDepleted: bool = False\n    if positionData.liquidity == 0:\n        isDepleted = True\n        extcall AeroNftPositionManager(nftPositionManager).burn(_nftTokenId)\n\n    # transfer nft to recipient\n    else:\n        extcall IERC721(nftPositionManager).safeTransferFrom(self, _recipient, _nftTokenId)\n\n    usdValue: uint256 = self._getUsdValue(_tokenA, amountA, _tokenB, amountB, miniAddys)\n    liquidityRemoved: uint256 = convert(originalLiquidity - positionData.liquidity, uint256)\n    log AeroSlipStreamLiquidityRemoved(\n        sender = msg.sender,\n        pool = _pool,\n        nftTokenId = _nftTokenId,\n        tokenA = _tokenA,\n        tokenB = _tokenB,\n        amountA = amountA,\n        amountB = amountB,\n        liquidityRemoved = liquidityRemoved,\n        usdValue = usdValue,\n        recipient = _recipient,\n    )\n    return amountA, amountB, liquidityRemoved, isDepleted, usdValue\n\n\n# get usd value on liquidity actions\n\n\n@internal\ndef _getUsdValue(\n    _tokenA: address,\n    _amountA: uint256,\n    _tokenB: address,\n    _amountB: uint256,\n    _miniAddys: ws.MiniAddys,\n) -> uint256:\n\n    usdValueA: uint256 = 0\n    if _amountA != 0:\n        usdValueA = staticcall Appraiser(_miniAddys.appraiser).getUsdValue(_tokenA, _amountA, _miniAddys.missionControl, _miniAddys.legoBook, _miniAddys.ledger)\n\n    usdValueB: uint256 = 0\n    if _amountB != 0:\n        usdValueB = staticcall Appraiser(_miniAddys.appraiser).getUsdValue(_tokenB, _amountB, _miniAddys.missionControl, _miniAddys.legoBook, _miniAddys.ledger)\n\n    return usdValueA + usdValueB\n\n\n#############\n# Utilities #\n#############\n\n\n@view\n@external\ndef getLpToken(_pool: address) -> address:\n    # no lp tokens for aero slipstream (uni v3)\n    return empty(address)\n\n\n@view\n@external\ndef getPoolForLpToken(_lpToken: address) -> address:\n    # no lp tokens for aero slipstream (uni v3)\n    return empty(address)\n\n\n@view\n@external\ndef getCoreRouterPool() -> address:\n    return self.coreRouterPool\n\n\n@view\n@external\ndef getDeepestLiqPool(_tokenA: address, _tokenB: address) -> BestPool:\n    bestPoolAddr: address = empty(address)\n    na: int24 = 0\n    bestPoolAddr, na = self._getDeepestLiqPool(_tokenA, _tokenB)\n\n    if bestPoolAddr == empty(address):\n        return empty(BestPool)\n\n    # get token balances\n    tokenABal: uint256 = staticcall IERC20(_tokenA).balanceOf(bestPoolAddr)\n    tokenBBal: uint256 = staticcall IERC20(_tokenB).balanceOf(bestPoolAddr)\n\n    return BestPool(\n        pool=bestPoolAddr,\n        fee=convert(staticcall AeroSlipStreamPool(bestPoolAddr).fee() // 100, uint256), # normalize to have 100_00 denominator\n        liquidity=tokenABal + tokenBBal, # not exactly \"liquidity\" but this comparable to \"reserves\"\n        numCoins=2,\n    )\n\n\n# annoying that this cannot be view function, thanks uni v3\n@external\ndef getBestSwapAmountOut(_tokenIn: address, _tokenOut: address, _amountIn: uint256) -> (address, uint256):\n    bestPoolAddr: address = empty(address)\n    bestTickSpacing: int24 = 0\n    bestPoolAddr, bestTickSpacing = self._getDeepestLiqPool(_tokenIn, _tokenOut)\n    if bestPoolAddr == empty(address):\n        return empty(address), 0\n\n    amountOut: uint256 = 0\n    na1: uint160 = 0\n    na2: uint32 = 0\n    na3: uint256 = 0\n    amountOut, na1, na2, na3 = extcall AeroQuoter(AERO_SLIPSTREAM_QUOTER).quoteExactInputSingle(\n        QuoteExactInputSingleParams(\n            tokenIn=_tokenIn,\n            tokenOut=_tokenOut,\n            amountIn=_amountIn,\n            tickSpacing=bestTickSpacing,\n            sqrtPriceLimitX96=0,\n        )\n    )\n    return bestPoolAddr, amountOut\n\n\n# annoying that this cannot be view function, thanks uni v3\n@external\ndef getSwapAmountOut(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n) -> uint256:\n    amountOut: uint256 = 0\n    na1: uint160 = 0\n    na2: uint32 = 0\n    na3: uint256 = 0\n    amountOut, na1, na2, na3 = extcall AeroQuoter(AERO_SLIPSTREAM_QUOTER).quoteExactInputSingle(\n        QuoteExactInputSingleParams(\n            tokenIn=_tokenIn,\n            tokenOut=_tokenOut,\n            amountIn=_amountIn,\n            tickSpacing=staticcall AeroSlipStreamPool(_pool).tickSpacing(),\n            sqrtPriceLimitX96=0,\n        )\n    )\n    return amountOut\n\n\n# annoying that this cannot be view function, thanks uni v3\n@external\ndef getBestSwapAmountIn(_tokenIn: address, _tokenOut: address, _amountOut: uint256) -> (address, uint256):\n    if _amountOut == 0 or _amountOut == max_value(uint256):\n        return empty(address), max_value(uint256)\n\n    bestPoolAddr: address = empty(address)\n    bestTickSpacing: int24 = 0\n    bestPoolAddr, bestTickSpacing = self._getDeepestLiqPool(_tokenIn, _tokenOut)\n    if bestPoolAddr == empty(address):\n        return empty(address), 0\n\n    amountIn: uint256 = 0\n    na1: uint160 = 0\n    na2: uint32 = 0\n    na3: uint256 = 0\n    amountIn, na1, na2, na3 = extcall AeroQuoter(AERO_SLIPSTREAM_QUOTER).quoteExactOutputSingle(\n        QuoteExactOutputSingleParams(\n            tokenIn=_tokenIn,\n            tokenOut=_tokenOut,\n            amount=_amountOut,\n            tickSpacing=bestTickSpacing,\n            sqrtPriceLimitX96=0,\n        )\n    )\n    return bestPoolAddr, amountIn\n\n\n# annoying that this cannot be view function, thanks uni v3\n@external\ndef getSwapAmountIn(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountOut: uint256,\n) -> uint256:\n    if _amountOut == 0 or _amountOut == max_value(uint256):\n        return max_value(uint256)\n\n    amountIn: uint256 = 0\n    na1: uint160 = 0\n    na2: uint32 = 0\n    na3: uint256 = 0\n    amountIn, na1, na2, na3 = extcall AeroQuoter(AERO_SLIPSTREAM_QUOTER).quoteExactOutputSingle(\n        QuoteExactOutputSingleParams(\n            tokenIn=_tokenIn,\n            tokenOut=_tokenOut,\n            amount=_amountOut,\n            tickSpacing=staticcall AeroSlipStreamPool(_pool).tickSpacing(),\n            sqrtPriceLimitX96=0,\n        )\n    )\n    return amountIn\n\n\n@view\n@external\ndef getAddLiqAmountsIn(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _availAmountA: uint256,\n    _availAmountB: uint256,\n) -> (uint256, uint256, uint256):\n    token0: address = staticcall AeroSlipStreamPool(_pool).token0()\n\n    # get correct numerator and denominator\n    numerator: uint256 = 0\n    denominator: uint256 = 0\n    sqrtPriceX96Squared: uint256 = self._getSqrtPriceX96(_pool) ** 2\n    if _tokenA == token0:\n        numerator = sqrtPriceX96Squared\n        denominator = UNISWAP_Q96 ** 2\n    else:\n        numerator = UNISWAP_Q96 ** 2\n        denominator = sqrtPriceX96Squared\n\n    # calculate optimal amounts\n    amountA: uint256 = _availAmountA\n    amountB: uint256 = _availAmountA * numerator // denominator\n    if amountB > _availAmountB:\n        maybeAmountA: uint256 = _availAmountB * denominator // numerator\n        if maybeAmountA <= _availAmountA:\n            amountA = maybeAmountA\n            amountB = _availAmountB\n    return amountA, amountB, 0\n\n\n@view\n@external\ndef getRemoveLiqAmountsOut(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpAmount: uint256,\n) -> (uint256, uint256):\n    token0: address = staticcall AeroSlipStreamPool(_pool).token0()\n\n    # calculate expected amounts out\n    sqrtPriceX96: uint256 = self._getSqrtPriceX96(_pool)\n    amount0Out: uint256 = _lpAmount * UNISWAP_Q96 // sqrtPriceX96\n    amount1Out: uint256 = _lpAmount * sqrtPriceX96 // UNISWAP_Q96\n\n    # return amounts out\n    if _tokenA == token0:\n        return amount0Out, amount1Out\n    else:\n        return amount1Out, amount0Out\n\n\n@view\n@external\ndef getPrice(_asset: address, _decimals: uint256) -> uint256:\n    return 0 # TODO: implement price\n\n\n@view\n@external\ndef getPriceUnsafe(_pool: address, _targetToken: address, _appraiser: address = empty(address)) -> uint256:\n    token0: address = staticcall AeroSlipStreamPool(_pool).token0()\n    token1: address = staticcall AeroSlipStreamPool(_pool).token1()\n\n    # appraiser\n    appraiser: address = _appraiser\n    if _appraiser == empty(address):\n        appraiser = addys._getAppraiserAddr()\n\n    # alt price\n    altPrice: uint256 = 0\n    if _targetToken == token0:\n        altPrice = staticcall Appraiser(appraiser).getRipePrice(token1)\n    else:\n        altPrice = staticcall Appraiser(appraiser).getRipePrice(token0)\n\n    # return early if no alt price\n    if altPrice == 0:\n        return 0\n\n    # price of token0 in token1\n    sqrtPriceX96: uint256 = self._getSqrtPriceX96(_pool)\n    numerator: uint256 = sqrtPriceX96 ** 2 * EIGHTEEN_DECIMALS\n    priceZeroToOne: uint256 = numerator // (UNISWAP_Q96 ** 2)\n\n    # adjust for decimals: price should be in 18 decimals\n    decimals0: uint256 = convert(staticcall IERC20Detailed(token0).decimals(), uint256)\n    decimals1: uint256 = convert(staticcall IERC20Detailed(token1).decimals(), uint256)\n    if decimals0 > decimals1:\n        scaleFactor: uint256 = 10 ** (decimals0 - decimals1)\n        priceZeroToOne = priceZeroToOne * scaleFactor\n    elif decimals1 > decimals0:\n        scaleFactor: uint256 = 10 ** (decimals1 - decimals0)\n        priceZeroToOne = priceZeroToOne // scaleFactor\n\n    # if _targetToken is token1, make price inverse\n    priceToOther: uint256 = priceZeroToOne\n    if _targetToken == token1:\n        priceToOther = EIGHTEEN_DECIMALS * EIGHTEEN_DECIMALS // priceZeroToOne\n\n    return altPrice * priceToOther // EIGHTEEN_DECIMALS\n\n\n# internal utils\n\n\n@view\n@internal\ndef _getDeepestLiqPool(_tokenA: address, _tokenB: address) -> (address, int24):\n    bestPoolAddr: address = empty(address)\n    bestTickSpacing: int24 = 0\n    bestLiquidity: uint128 = 0\n\n    factory: address = AERO_SLIPSTREAM_FACTORY\n    for i: uint256 in range(5):\n        tickSpacing: int24 = TICK_SPACING[i]\n        pool: address = staticcall AeroSlipStreamFactory(factory).getPool(_tokenA, _tokenB, tickSpacing)\n        if pool == empty(address):\n            continue\n        liquidity: uint128 = staticcall AeroSlipStreamPool(pool).liquidity()\n        if liquidity > bestLiquidity:\n            bestPoolAddr = pool\n            bestTickSpacing = tickSpacing\n            bestLiquidity = liquidity\n\n    return bestPoolAddr, bestTickSpacing\n\n\n@view\n@internal\ndef _getSqrtPriceX96(_pool: address) -> uint256:\n    sqrtPriceX96: uint160 = 0\n    tick: int24 = 0\n    observationIndex: uint16 = 0\n    observationCardinality: uint16 = 0\n    observationCardinalityNext: uint16 = 0\n    unlocked: bool = False\n    sqrtPriceX96, tick, observationIndex, observationCardinality, observationCardinalityNext, unlocked = staticcall AeroSlipStreamPool(_pool).slot0()\n    return convert(sqrtPriceX96, uint256)\n\n\n# nft recovery\n\n\n@external\ndef recoverNft(_collection: address, _nftTokenId: uint256, _recipient: address) -> bool:\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n\n    if staticcall IERC721(_collection).ownerOf(_nftTokenId) != self:\n        return False\n\n    extcall IERC721(_collection).safeTransferFrom(self, _recipient, _nftTokenId)\n    log AeroSlipStreamNftRecovered(collection=_collection, nftTokenId=_nftTokenId, recipient=_recipient)\n    return True\n\n\n#########\n# Other #\n#########\n\n\n@external\ndef depositForYield(\n    _asset: address,\n    _amount: uint256,\n    _vaultAddr: address,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, address, uint256, uint256):\n    return 0, empty(address), 0, 0\n\n\n@external\ndef withdrawFromYield(\n    _vaultToken: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, address, uint256, uint256):\n    return 0, empty(address), 0, 0\n\n\n@external\ndef mintOrRedeemAsset(\n    _tokenIn: address,\n    _tokenOut: address,\n    _tokenInAmount: uint256,\n    _minAmountOut: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, bool, uint256):\n    return 0, 0, False, 0\n\n\n@external\ndef confirmMintOrRedeemAsset(\n    _tokenIn: address,\n    _tokenOut: address,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef addCollateral(\n    _asset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef removeCollateral(\n    _asset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef borrow(\n    _borrowAsset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef repayDebt(\n    _paymentAsset: address,\n    _paymentAmount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef claimRewards(\n    _user: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _extraData: bytes32,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    # backwards compatibility\n    return 0, 0\n\n\n@external\ndef claimIncentives(\n    _user: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _proofs: DynArray[bytes32, MAX_PROOFS],\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef addLiquidity(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _amountA: uint256,\n    _amountB: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _minLpAmount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (address, uint256, uint256, uint256, uint256):\n    return empty(address), 0, 0, 0, 0\n\n\n@external\ndef removeLiquidity(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpToken: address,\n    _lpAmount: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, uint256):\n    return 0, 0, 0, 0\n\n\n@view\n@external\ndef getAccessForLego(_user: address, _action: ws.ActionType) -> (address, String[64], uint256):\n    return empty(address), empty(String[64]), 0\n",
            "sha256sum": "d8bed498ccdef6f701629e8be098a23fe6e0b2d5d7331ff594a18fce061fb21c"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/legos/dexes/AeroSlipstream.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.3+commit.bff19ea2",
        "integrity": "964238ebae3c0130d3f0cd2d2c42c5190cc9a411cef7678a5115a2b489da0624"
      },
      "args": "00000000000000000000000044cf3c4f000dfd76a35d03298049d37be688d6f90000000000000000000000005e7bb104d84c7cb9b682aac2f3d509f5f406809a000000000000000000000000827922686190790b37229fd06084350e74485b72000000000000000000000000254cf9e1e6e233aa1ac962cb9b05b2cfeaae15b0000000000000000000000000b2cc224c1c9fee385f8ad6a55b4d94e92359dc590000000000000000000000006162df1b329e157479f8f1407e888260e0ec3d2b",
      "file": "contracts/legos/dexes/AeroSlipstream.vy"
    },
    "Curve": {
      "address": "0x2Fe42d5dC25658CE5A4D13A8D7E8C523011e59CE",
      "abi": [
        {
          "name": "CurveSwap",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenIn",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenOut",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amountIn",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "amountOut",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "numTokens",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "CurveLiquidityAdded",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenA",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenB",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amountA",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "amountB",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "lpAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "CurveLiquidityRemoved",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": false
            },
            {
              "name": "pool",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenA",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenB",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amountA",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "amountB",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "lpToken",
              "type": "address",
              "indexed": false
            },
            {
              "name": "lpAmountBurned",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LegoPauseModified",
          "inputs": [
            {
              "name": "isPaused",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LegoFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "balance",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddys",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "undyToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "hatchery",
                  "type": "address"
                },
                {
                  "name": "lootDistributor",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                },
                {
                  "name": "walletBackpack",
                  "type": "address"
                },
                {
                  "name": "billing",
                  "type": "address"
                },
                {
                  "name": "vaultRegistry",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUndyHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pause",
          "inputs": [
            {
              "name": "_shouldPause",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFundsMany",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_assets",
              "type": "address[]"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "legoId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isPaused",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasCapability",
          "inputs": [
            {
              "name": "_action",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRegistries",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isYieldLego",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isDexLego",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_tokenPath",
              "type": "address[]"
            },
            {
              "name": "_poolPath",
              "type": "address[]"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_tokenPath",
              "type": "address[]"
            },
            {
              "name": "_poolPath",
              "type": "address[]"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLpToken",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPoolForLpToken",
          "inputs": [
            {
              "name": "_lpToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getCoreRouterPool",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getDeepestLiqPool",
          "inputs": [
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "fee",
                  "type": "uint256"
                },
                {
                  "name": "liquidity",
                  "type": "uint256"
                },
                {
                  "name": "numCoins",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getBestSwapAmountOut",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountIn",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getSwapAmountOut",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountIn",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getBestSwapAmountIn",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountOut",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getSwapAmountIn",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountOut",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddLiqAmountsIn",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_availAmountA",
              "type": "uint256"
            },
            {
              "name": "_availAmountB",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRemoveLiqAmountsOut",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPrice",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_decimals",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPriceUnsafe",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_targetToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPriceUnsafe",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_targetToken",
              "type": "address"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAccessForLego",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_action",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "string"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "CURVE_META_REGISTRY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "CURVE_REGISTRIES",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "StableSwapNg",
                  "type": "address"
                },
                {
                  "name": "TwoCryptoNg",
                  "type": "address"
                },
                {
                  "name": "TricryptoNg",
                  "type": "address"
                },
                {
                  "name": "TwoCrypto",
                  "type": "address"
                },
                {
                  "name": "MetaPool",
                  "type": "address"
                },
                {
                  "name": "RateProvider",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "RIPE_REGISTRY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_undyHq",
              "type": "address"
            },
            {
              "name": "_curveAddressProvider",
              "type": "address"
            },
            {
              "name": "_ripeRegistry",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "interfaces/WalletStructs.vyi": {
            "content": "# @version 0.4.3\n\nflag ActionType:\n    TRANSFER\n    EARN_DEPOSIT\n    EARN_WITHDRAW\n    EARN_REBALANCE\n    SWAP\n    MINT_REDEEM\n    CONFIRM_MINT_REDEEM\n    ADD_COLLATERAL\n    REMOVE_COLLATERAL\n    BORROW\n    REPAY_DEBT\n    REWARDS\n    ETH_TO_WETH\n    WETH_TO_ETH\n    ADD_LIQ\n    REMOVE_LIQ\n    ADD_LIQ_CONC\n    REMOVE_LIQ_CONC\n    PAY_CHEQUE\n\nstruct WalletAssetData:\n    assetBalance: uint256\n    usdValue: uint256\n    isYieldAsset: bool\n    lastPricePerShare: uint256\n\nstruct ActionData:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    billing: address\n    vaultRegistry: address\n    wallet: address\n    walletConfig: address\n    walletOwner: address\n    inEjectMode: bool\n    isFrozen: bool\n    lastTotalUsdValue: uint256\n    signer: address\n    isManager: bool\n    legoId: uint256\n    legoAddr: address\n    eth: address\n    weth: address\n\nstruct MiniAddys:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    appraiser: address",
            "sha256sum": "466493c129135c95470aaf70eeddc936632f7b0f813396e5a7ddc03bea9da518"
          },
          "interfaces/LegoPartner.vyi": {
            "content": "# @version 0.4.3\n\nfrom interfaces import WalletStructs as ws\n\nMAX_TOKEN_PATH: constant(uint256) = 5\nMAX_RECOVER_ASSETS: constant(uint256) = 20\nMAX_PROOFS: constant(uint256) = 25\n\n@external\ndef addLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _tickLower: int24, _tickUpper: int24, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef addLiquidity(_pool: address, _tokenA: address, _tokenB: address, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _minLpAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (address, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef removeLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _liqToRemove: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef removeLiquidity(_pool: address, _tokenA: address, _tokenB: address, _lpToken: address, _lpAmount: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef mintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _tokenInAmount: uint256, _minAmountOut: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef swapTokens(_amountIn: uint256, _minAmountOut: uint256, _tokenPath: DynArray[address, MAX_TOKEN_PATH], _poolPath: DynArray[address, MAX_TOKEN_PATH - 1], _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256):\n    ...\n\n@external\ndef depositForYield(_asset: address, _amount: uint256, _vaultAddr: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef withdrawFromYield(_vaultToken: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef confirmMintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef borrow(_borrowAsset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef repayDebt(_paymentAsset: address, _paymentAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef claimIncentives(_user: address, _rewardToken: address, _rewardAmount: uint256, _proofs: DynArray[bytes32, MAX_PROOFS], _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef removeCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef addCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@view\n@external\ndef getAccessForLego(_user: address, _action: ws.ActionType) -> (address, String[64], uint256):\n    ...\n\n@view\n@external\ndef hasCapability(_action: ws.ActionType) -> bool:\n    ...\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    ...\n\n@view\n@external\ndef isYieldLego() -> bool:\n    ...\n\n@view\n@external\ndef isDexLego() -> bool:\n    ...\n\n\n# common\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "f2afb7bd72d4301aea77bbe4177b7ae954ba6f6b76af363965993eb92ad0b715"
          },
          "interfaces/DexLego.vyi": {
            "content": "# @version 0.4.3\n\n# used in smart contracts\n\n\n@view\n@external\ndef getLpToken(_pool: address) -> address:\n    ...\n\n\n# helper functions for server\n\n\n@view\n@external\ndef getPoolForLpToken(_lpToken: address) -> address:\n    ...\n\n\n@view\n@external\ndef getSwapAmountOut(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n) -> uint256:\n    ...\n\n\n@view\n@external\ndef getSwapAmountIn(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountOut: uint256,\n) -> uint256:\n    ...\n\n\n@view\n@external\ndef getAddLiqAmountsIn(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _availAmountA: uint256,\n    _availAmountB: uint256,\n) -> (uint256, uint256, uint256):\n    ...\n\n\n@view\n@external\ndef getRemoveLiqAmountsOut(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpAmount: uint256,\n) -> (uint256, uint256):\n    ...\n\n\n@view\n@external\ndef getPriceUnsafe(_pool: address, _targetToken: address, _appraiser: address = empty(address)) -> uint256:\n    ...\n\n\n@view\n@external\ndef getBestSwapAmountOut(_tokenIn: address, _tokenOut: address, _amountIn: uint256) -> (address, uint256):\n    ...\n\n\n@view\n@external\ndef getBestSwapAmountIn(_tokenIn: address, _tokenOut: address, _amountOut: uint256) -> (address, uint256):\n    ...\n\n\n@view\n@external\ndef getCoreRouterPool() -> address:\n    ...\n\n\n@view\n@external\ndef getPrice(_asset: address, _decimals: uint256) -> uint256:\n    ...\n",
            "sha256sum": "6248ad46926f00481cb3469bfc7af8fe36669c2ca0dd98e9a0befdda0fc43fd7"
          },
          "contracts/modules/Addys.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\ninterface UndyHq:\n    def isValidAddr(_addr: address) -> bool: view\n    def getAddr(_regId: uint256) -> address: view\n    def undyToken() -> address: view\n\ninterface Switchboard:\n    def isSwitchboardAddr(_addr: address) -> bool: view\n\ninterface LegoBook:\n    def isLegoAddr(_addr: address) -> bool: view\n\nstruct Addys:\n    hq: address\n    undyToken: address\n    ledger: address\n    missionControl: address\n    legoBook: address\n    switchboard: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    walletBackpack: address\n    billing: address\n    vaultRegistry: address\n\n# hq\nUNDY_HQ_FOR_ADDYS: immutable(address)\n\n# core addys\nLEDGER_ID: constant(uint256) = 1\nMISSION_CONTROL_ID: constant(uint256) = 2\nLEGO_BOOK_ID: constant(uint256) = 3\nSWITCHBOARD_ID: constant(uint256) = 4\nHATCHERY_ID: constant(uint256) = 5\nLOOT_DISTRIBUTOR_ID: constant(uint256) = 6\nAPPRAISER_ID: constant(uint256) = 7\nWALLET_BACKPACK_ID: constant(uint256) = 8\nBILLING_ID: constant(uint256) = 9\nVAULT_REGISTRY_ID: constant(uint256) = 10\n\n\n@deploy\ndef __init__(_undyHq: address):\n    assert _undyHq != empty(address) # dev: invalid undy hq\n    UNDY_HQ_FOR_ADDYS = _undyHq\n\n\n########\n# Core #\n########\n\n\n@view\n@external\ndef getAddys() -> Addys:\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _getAddys(_addys: Addys = empty(Addys)) -> Addys:\n    if _addys.hq != empty(address):\n        return _addys\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _generateAddys() -> Addys:\n    hq: address = UNDY_HQ_FOR_ADDYS\n    return Addys(\n        hq = hq,\n        undyToken = staticcall UndyHq(hq).undyToken(),\n        ledger = staticcall UndyHq(hq).getAddr(LEDGER_ID),\n        missionControl = staticcall UndyHq(hq).getAddr(MISSION_CONTROL_ID),\n        legoBook = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID),\n        switchboard = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID),\n        hatchery = staticcall UndyHq(hq).getAddr(HATCHERY_ID),\n        lootDistributor = staticcall UndyHq(hq).getAddr(LOOT_DISTRIBUTOR_ID),\n        appraiser = staticcall UndyHq(hq).getAddr(APPRAISER_ID),\n        walletBackpack = staticcall UndyHq(hq).getAddr(WALLET_BACKPACK_ID),\n        billing = staticcall UndyHq(hq).getAddr(BILLING_ID),\n        vaultRegistry = staticcall UndyHq(hq).getAddr(VAULT_REGISTRY_ID),\n    )\n\n\n##########\n# Tokens #\n##########\n\n\n@view\n@internal\ndef _getUndyToken() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).undyToken()\n\n\n###########\n# Helpers #\n###########\n\n\n# undy hq\n\n\n@view\n@external\ndef getUndyHq() -> address:\n    return self._getUndyHq()\n\n\n@view\n@internal\ndef _getUndyHq() -> address:\n    return UNDY_HQ_FOR_ADDYS\n\n\n# utils\n\n\n@view\n@internal\ndef _isValidUndyAddr(_addr: address, _hq: address = empty(address)) -> bool:\n    hq: address = _hq\n    if _hq == empty(address):\n        hq = UNDY_HQ_FOR_ADDYS\n    \n    # core departments\n    if staticcall UndyHq(hq).isValidAddr(_addr):\n        return True\n\n    # lego book\n    legoBook: address = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID)\n    if legoBook != empty(address) and staticcall LegoBook(legoBook).isLegoAddr(_addr):\n        return True\n\n    # switchboard config\n    switchboard: address = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID)\n    if switchboard != empty(address) and staticcall Switchboard(switchboard).isSwitchboardAddr(_addr):\n        return True\n\n    return False\n\n\n@view\n@internal\ndef _isSwitchboardAddr(_addr: address) -> bool:\n    switchboard: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n    if switchboard == empty(address):\n        return False\n    return staticcall Switchboard(switchboard).isSwitchboardAddr(_addr)\n\n\n@view\n@internal\ndef _isLegoBookAddr(_addr: address) -> bool:\n    legoBook: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n    if legoBook == empty(address):\n        return False\n    return staticcall LegoBook(legoBook).isLegoAddr(_addr)\n\n\n###############\n# Departments #\n###############\n\n\n# ledger\n\n\n@view\n@internal\ndef _getLedgerId() -> uint256:\n    return LEDGER_ID\n\n\n@view\n@internal\ndef _getLedgerAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEDGER_ID)\n\n\n# mission control\n\n\n@view\n@internal\ndef _getMissionControlId() -> uint256:\n    return MISSION_CONTROL_ID\n\n\n@view\n@internal\ndef _getMissionControlAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(MISSION_CONTROL_ID)\n\n\n# lego book\n\n\n@view\n@internal\ndef _getLegoBookId() -> uint256:\n    return LEGO_BOOK_ID\n\n\n@view\n@internal\ndef _getLegoBookAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n\n\n# switchboard\n\n\n@view\n@internal\ndef _getSwitchboardId() -> uint256:\n    return SWITCHBOARD_ID\n\n\n@view\n@internal\ndef _getSwitchboardAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n\n\n# hatchery\n\n\n@view\n@internal\ndef _getHatcheryId() -> uint256:\n    return HATCHERY_ID\n\n\n@view\n@internal\ndef _getHatcheryAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(HATCHERY_ID)\n\n\n# loot distributor\n\n\n@view\n@internal\ndef _getLootDistributorId() -> uint256:\n    return LOOT_DISTRIBUTOR_ID\n\n\n@view\n@internal\ndef _getLootDistributorAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LOOT_DISTRIBUTOR_ID)\n\n\n# appraiser\n\n\n@view\n@internal\ndef _getAppraiserId() -> uint256:\n    return APPRAISER_ID\n\n\n@view\n@internal\ndef _getAppraiserAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(APPRAISER_ID)\n\n\n# wallet backpack\n\n\n@view\n@internal\ndef _getWalletBackpackId() -> uint256:\n    return WALLET_BACKPACK_ID\n\n\n@view\n@internal\ndef _getWalletBackpackAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(WALLET_BACKPACK_ID)\n\n\n# billing\n\n\n@view\n@internal\ndef _getBillingId() -> uint256:\n    return BILLING_ID\n\n\n@view\n@internal\ndef _getBillingAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(BILLING_ID)\n\n\n# vault registry\n\n\n@view\n@internal\ndef _getVaultRegistryId() -> uint256:\n    return VAULT_REGISTRY_ID\n\n\n@view\n@internal\ndef _getVaultRegistryAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(VAULT_REGISTRY_ID)",
            "sha256sum": "4df6b72db9bb417d1af81660175be1450cfb7b3575f3d17a5b8a130bff87b781"
          },
          "contracts/modules/DexLegoData.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nuses: addys\n\nimport contracts.modules.Addys as addys\n\nfrom interfaces import WalletStructs as ws\nfrom ethereum.ercs import IERC20\n\nevent LegoPauseModified:\n    isPaused: bool\n\nevent LegoFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    balance: uint256\n\n# config\nlegoId: public(uint256)\nisPaused: public(bool)\n\nMAX_RECOVER_ASSETS: constant(uint256) = 20\n\n\n@deploy\ndef __init__(_shouldPause: bool):\n    self.isPaused = _shouldPause\n\n\n###########\n# General #\n###########\n\n\n# fill mini addys\n\n\n@view\n@internal\ndef _getMiniAddys(_miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> ws.MiniAddys:\n    if _miniAddys.ledger != empty(address):\n        return _miniAddys\n    return ws.MiniAddys(\n        ledger = addys._getLedgerAddr(),\n        missionControl = addys._getMissionControlAddr(),\n        legoBook = addys._getLegoBookAddr(),\n        appraiser = addys._getAppraiserAddr(),\n    )\n\n\n# activate\n\n\n@external\ndef pause(_shouldPause: bool):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert _shouldPause != self.isPaused # dev: no change\n    self.isPaused = _shouldPause\n    log LegoPauseModified(isPaused=_shouldPause)\n\n\n# recover funds\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    self._recoverFunds(_recipient, _asset)\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, MAX_RECOVER_ASSETS]):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    for a: address in _assets:\n        self._recoverFunds(_recipient, a)\n\n\n@internal\ndef _recoverFunds(_recipient: address, _asset: address):\n    assert empty(address) not in [_recipient, _asset] # dev: invalid recipient or asset\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    assert balance != 0 # dev: nothing to recover\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log LegoFundsRecovered(asset=_asset, recipient=_recipient, balance=balance)",
            "sha256sum": "75b15af2475ab409d4b5fd057509d14c20564ebd7fcb0850e3b61397d8e3af48"
          },
          "contracts/legos/dexes/Curve.vy": {
            "content": "#     _____  _____  __  __    ____   _____  _____  _____ \n#    |  _  \\/   __\\/  \\/  \\  /  _/  /   __\\/   __\\/  _  \\\n#    |  |  ||   __|>-    -<  |  |---|   __||  |_ ||  |  |\n#    |_____/\\_____/\\__/\\__/  \\_____/\\_____/\\_____/\\_____/\n#                                                                       \n#     \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n#     \u2551  ** Curve Lego **              \u2551\n#     \u2551  Integration with Curve DEX.   \u2551\n#     \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n#\n#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n# pragma optimize codesize\n\nimplements: DexLego\n\nexports: addys.__interface__\nexports: dld.__interface__\n\ninitializes: addys\ninitializes: dld[addys := addys]\n\nfrom interfaces import LegoPartner as Lego\nfrom interfaces import DexLego as DexLego\nfrom interfaces import WalletStructs as ws\n\nimport contracts.modules.Addys as addys\nimport contracts.modules.DexLegoData as dld\n\nfrom ethereum.ercs import IERC20\nfrom ethereum.ercs import IERC20Detailed\n\ninterface CurveMetaRegistry:\n    def get_coin_indices(_pool: address, _from: address, _to: address) -> (int128, int128, bool): view\n    def find_pools_for_coins(_from: address, _to: address) -> DynArray[address, MAX_POOLS]: view\n    def get_registry_handlers_from_pool(_pool: address) -> address[10]: view\n    def get_pool_from_lp_token(_lpToken: address) -> address: view\n    def get_base_registry(_addr: address) -> address: view\n    def get_balances(_pool: address) -> uint256[8]: view\n    def get_coins(_pool: address) -> address[8]: view\n    def get_n_coins(_pool: address) -> uint256: view\n    def get_lp_token(_pool: address) -> address: view\n    def is_registered(_pool: address) -> bool: view\n    def is_meta(_pool: address) -> bool: view\n\ninterface TwoCryptoPool:\n    def remove_liquidity_one_coin(_lpBurnAmount: uint256, _index: uint256, _minAmountOut: uint256, _useEth: bool = False, _recipient: address = msg.sender) -> uint256: nonpayable\n    def exchange(_i: uint256, _j: uint256, _dx: uint256, _min_dy: uint256, _use_eth: bool = False, _receiver: address = msg.sender) -> uint256: payable\n    def remove_liquidity(_lpBurnAmount: uint256, _minAmountsOut: uint256[2], _useEth: bool = False, _recipient: address = msg.sender): nonpayable\n    def add_liquidity(_amounts: uint256[2], _minLpAmount: uint256, _useEth: bool = False, _recipient: address = msg.sender) -> uint256: payable\n    def calc_withdraw_one_coin(_burnAmount: uint256, _index: uint256) -> uint256: view\n    def calc_token_amount(_amounts: uint256[2]) -> uint256: view\n\ninterface TwoCryptoNgPool:\n    def remove_liquidity_one_coin(_lpBurnAmount: uint256, _index: uint256, _minAmountOut: uint256, _recipient: address = msg.sender) -> uint256: nonpayable\n    def remove_liquidity(_lpBurnAmount: uint256, _minAmountsOut: uint256[2], _recipient: address = msg.sender) -> uint256[2]: nonpayable\n    def exchange(i: uint256, j: uint256, dx: uint256, min_dy: uint256, receiver: address = msg.sender) -> uint256: nonpayable\n    def add_liquidity(_amounts: uint256[2], _minLpAmount: uint256, _recipient: address = msg.sender) -> uint256: nonpayable\n    def calc_withdraw_one_coin(_burnAmount: uint256, _index: uint256) -> uint256: view\n    def calc_token_amount(_amounts: uint256[2], _isDeposit: bool) -> uint256: view\n\ninterface StableNgTwo:\n    def remove_liquidity(_lpBurnAmount: uint256, _minAmountsOut: DynArray[uint256, 2], _recipient: address = msg.sender, _claimAdminFees: bool = True) -> DynArray[uint256, 2]: nonpayable\n    def remove_liquidity_one_coin(_lpBurnAmount: uint256, _index: int128, _minAmountOut: uint256, _recipient: address = msg.sender) -> uint256: nonpayable\n    def add_liquidity(_amounts: DynArray[uint256, 2], _minLpAmount: uint256, _recipient: address = msg.sender) -> uint256: nonpayable\n    def calc_token_amount(_amounts: DynArray[uint256, 2], _isDeposit: bool) -> uint256: view\n    def calc_withdraw_one_coin(_burnAmount: uint256, _index: int128) -> uint256: view\n\ninterface TriCryptoPool:\n    def remove_liquidity(_lpBurnAmount: uint256, _minAmountsOut: uint256[3], _useEth: bool = False, _recipient: address = msg.sender, _claimAdminFees: bool = True) -> uint256[3]: nonpayable\n    def remove_liquidity_one_coin(_lpBurnAmount: uint256, _index: uint256, _minAmountOut: uint256, _useEth: bool = False, _recipient: address = msg.sender) -> uint256: nonpayable\n    def add_liquidity(_amounts: uint256[3], _minLpAmount: uint256, _useEth: bool = False, _recipient: address = msg.sender) -> uint256: payable\n    def calc_withdraw_one_coin(_burnAmount: uint256, _index: uint256) -> uint256: view\n    def calc_token_amount(_amounts: uint256[3], _isDeposit: bool) -> uint256: view\n\ninterface MetaPoolTwo:\n    def remove_liquidity(_lpBurnAmount: uint256, _minAmountsOut: uint256[2], _recipient: address = msg.sender) -> uint256[2]: nonpayable\n    def add_liquidity(_amounts: uint256[2], _minLpAmount: uint256, _recipient: address = msg.sender) -> uint256: nonpayable\n    def calc_token_amount(_amounts: uint256[2], _isDeposit: bool) -> uint256: view\n\ninterface MetaPoolThree:\n    def remove_liquidity(_lpBurnAmount: uint256, _minAmountsOut: uint256[3], _recipient: address = msg.sender) -> uint256[3]: nonpayable\n    def add_liquidity(_amounts: uint256[3], _minLpAmount: uint256, _recipient: address = msg.sender) -> uint256: nonpayable\n    def calc_token_amount(_amounts: uint256[3], _isDeposit: bool) -> uint256: view\n\ninterface MetaPoolFour:\n    def remove_liquidity(_lpBurnAmount: uint256, _minAmountsOut: uint256[4], _recipient: address = msg.sender) -> uint256[4]: nonpayable\n    def add_liquidity(_amounts: uint256[4], _minLpAmount: uint256, _recipient: address = msg.sender) -> uint256: nonpayable\n    def calc_token_amount(_amounts: uint256[4], _isDeposit: bool) -> uint256: view\n\ninterface MetaPoolCommon:\n    def remove_liquidity_one_coin(_lpBurnAmount: uint256, _index: int128, _minAmountOut: uint256, _recipient: address = msg.sender) -> uint256: nonpayable\n    def calc_withdraw_one_coin(_burnAmount: uint256, _index: int128) -> uint256: view\n\ninterface StableNgThree:\n    def add_liquidity(_amounts: DynArray[uint256, 3], _minLpAmount: uint256, _recipient: address = msg.sender) -> uint256: nonpayable\n    def calc_token_amount(_amounts: DynArray[uint256, 3], _isDeposit: bool) -> uint256: view\n\ninterface StableNgFour:\n    def add_liquidity(_amounts: DynArray[uint256, 4], _minLpAmount: uint256, _recipient: address = msg.sender) -> uint256: nonpayable\n    def calc_token_amount(_amounts: DynArray[uint256, 4], _isDeposit: bool) -> uint256: view\n\ninterface CommonCurvePool:\n    def exchange(_i: int128, _j: int128, _dx: uint256, _min_dy: uint256, _receiver: address = msg.sender) -> uint256: nonpayable\n    def fee() -> uint256: view\n\ninterface CurveRateProvider:\n    def get_quotes(_tokenIn: address, _tokenOut: address, _amountIn: uint256) -> DynArray[Quote, MAX_QUOTES]: view\n    def get_aggregated_rate(_tokenIn: address, _tokenOut: address) -> uint256: view\n\ninterface Appraiser:\n    def getUsdValue(_asset: address, _amount: uint256, _missionControl: address = empty(address), _legoBook: address = empty(address), _ledger: address = empty(address)) -> uint256: view\n\ninterface CryptoLegacyPool:\n    def exchange(_i: uint256, _j: uint256, _dx: uint256, _min_dy: uint256, _use_eth: bool = False) -> uint256: payable\n\ninterface VaultRegistry:\n    def isEarnVault(_vaultAddr: address) -> bool: view\n\ninterface Ledger:\n    def isUserWallet(_user: address) -> bool: view\n\ninterface CurveAddressProvider:\n    def get_address(_id: uint256) -> address: view\n\ninterface Registry:\n    def isValidAddr(_addr: address) -> bool: view\n\nflag PoolType:\n    STABLESWAP_NG\n    TWO_CRYPTO_NG\n    TRICRYPTO_NG\n    TWO_CRYPTO\n    METAPOOL\n    CRYPTO\n\nstruct Quote:\n    source_token_index: uint256\n    dest_token_index: uint256\n    is_underlying: bool\n    amount_out: uint256\n    pool: address\n    source_token_pool_balance: uint256\n    dest_token_pool_balance: uint256\n    pool_type: uint8\n\nstruct PoolData:\n    pool: address\n    indexTokenA: uint256\n    indexTokenB: uint256\n    poolType: PoolType\n    numCoins: uint256\n\nstruct BestPool:\n    pool: address\n    fee: uint256\n    liquidity: uint256\n    numCoins: uint256\n\nstruct CurveRegistries:\n    StableSwapNg: address\n    TwoCryptoNg: address\n    TricryptoNg: address\n    TwoCrypto: address\n    MetaPool: address\n    RateProvider: address\n\nevent CurveSwap:\n    sender: indexed(address)\n    tokenIn: indexed(address)\n    tokenOut: indexed(address)\n    amountIn: uint256\n    amountOut: uint256\n    usdValue: uint256\n    numTokens: uint256\n    recipient: address\n\nevent CurveLiquidityAdded:\n    sender: indexed(address)\n    tokenA: indexed(address)\n    tokenB: indexed(address)\n    amountA: uint256\n    amountB: uint256\n    lpAmountReceived: uint256\n    usdValue: uint256\n    recipient: address\n\nevent CurveLiquidityRemoved:\n    sender: address\n    pool: indexed(address)\n    tokenA: indexed(address)\n    tokenB: indexed(address)\n    amountA: uint256\n    amountB: uint256\n    lpToken: address\n    lpAmountBurned: uint256\n    usdValue: uint256\n    recipient: address\n\n# curve\nCURVE_META_REGISTRY: public(immutable(address))\nCURVE_REGISTRIES: public(immutable(CurveRegistries))\nRIPE_REGISTRY: public(immutable(address))\n\n# curve address provider ids\nMETAPOOL_FACTORY_ID: constant(uint256) = 3\nTWO_CRYPTO_FACTORY_ID: constant(uint256) = 6\nMETA_REGISTRY_ID: constant(uint256) = 7\nTRICRYPTO_NG_FACTORY_ID: constant(uint256) = 11\nSTABLESWAP_NG_FACTORY_ID: constant(uint256) = 12\nTWO_CRYPTO_NG_FACTORY_ID: constant(uint256) = 13\nRATE_PROVIDER_ID: constant(uint256) = 18\n\nMAX_POOLS: constant(uint256) = 50\nMAX_QUOTES: constant(uint256) = 100\nMAX_TOKEN_PATH: constant(uint256) = 5\n\n\n@deploy\ndef __init__(_undyHq: address, _curveAddressProvider: address, _ripeRegistry: address):\n    addys.__init__(_undyHq)\n    dld.__init__(False)\n\n    assert empty(address) not in [_curveAddressProvider, _ripeRegistry] # dev: invalid addrs\n    CURVE_META_REGISTRY = staticcall CurveAddressProvider(_curveAddressProvider).get_address(META_REGISTRY_ID)\n    CURVE_REGISTRIES = CurveRegistries(\n        StableSwapNg= staticcall CurveAddressProvider(_curveAddressProvider).get_address(STABLESWAP_NG_FACTORY_ID),\n        TwoCryptoNg= staticcall CurveAddressProvider(_curveAddressProvider).get_address(TWO_CRYPTO_NG_FACTORY_ID),\n        TricryptoNg= staticcall CurveAddressProvider(_curveAddressProvider).get_address(TRICRYPTO_NG_FACTORY_ID),\n        TwoCrypto= staticcall CurveAddressProvider(_curveAddressProvider).get_address(TWO_CRYPTO_FACTORY_ID),\n        MetaPool= staticcall CurveAddressProvider(_curveAddressProvider).get_address(METAPOOL_FACTORY_ID),\n        RateProvider= staticcall CurveAddressProvider(_curveAddressProvider).get_address(RATE_PROVIDER_ID),\n    )\n    RIPE_REGISTRY = _ripeRegistry\n\n\n@view\n@external\ndef hasCapability(_action: ws.ActionType) -> bool:\n    return _action in (\n        ws.ActionType.SWAP |\n        ws.ActionType.ADD_LIQ | \n        ws.ActionType.REMOVE_LIQ\n    )\n\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    return [CURVE_META_REGISTRY]\n\n\n@view\n@external\ndef isYieldLego() -> bool:\n    return False\n\n\n@view\n@external\ndef isDexLego() -> bool:\n    return True\n\n\n@view\n@internal\ndef _isAllowedToPerformAction(_caller: address) -> bool:\n    if staticcall VaultRegistry(addys._getVaultRegistryAddr()).isEarnVault(_caller):\n        return True\n    if staticcall Ledger(addys._getLedgerAddr()).isUserWallet(_caller):\n        return True\n    return staticcall Registry(RIPE_REGISTRY).isValidAddr(_caller)\n\n\n#########\n# Swaps #\n#########\n\n\n@external\ndef swapTokens(\n    _amountIn: uint256,\n    _minAmountOut: uint256,\n    _tokenPath: DynArray[address, MAX_TOKEN_PATH],\n    _poolPath: DynArray[address, MAX_TOKEN_PATH - 1],\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256):\n    assert not dld.isPaused # dev: paused\n    assert self._isAllowedToPerformAction(msg.sender) # dev: no perms\n    miniAddys: ws.MiniAddys = dld._getMiniAddys(_miniAddys)\n\n    # validate inputs\n    numTokens: uint256 = len(_tokenPath)\n    numPools: uint256 = len(_poolPath)\n    assert numTokens >= 2 # dev: invalid path\n    assert numPools == numTokens - 1 # dev: invalid path\n\n    # get first token and last token\n    tokenIn: address = _tokenPath[0]\n    tokenOut: address = _tokenPath[numTokens - 1]\n\n    # pre balances\n    preLegoBalance: uint256 = staticcall IERC20(tokenIn).balanceOf(self)\n\n    # transfer deposit asset to this contract\n    amountIn: uint256 = min(_amountIn, staticcall IERC20(tokenIn).balanceOf(msg.sender))\n    assert amountIn != 0 # dev: nothing to transfer\n    assert extcall IERC20(tokenIn).transferFrom(msg.sender, self, amountIn, default_return_value=True) # dev: transfer failed\n\n    # adjust min amount out\n    minAmountOut: uint256 = _minAmountOut\n    if amountIn < _amountIn and _amountIn != max_value(uint256):\n        minAmountOut = _minAmountOut * amountIn // _amountIn\n\n    # iterate through swap routes\n    tempAmountIn: uint256 = amountIn\n    curveMetaRegistry: address = CURVE_META_REGISTRY\n    for i: uint256 in range(numTokens - 1, bound=MAX_TOKEN_PATH):\n        tempTokenIn: address = _tokenPath[i]\n        tempTokenOut: address = _tokenPath[i + 1]\n        tempPool: address = _poolPath[i]\n\n        # transfer to self (or to recipient if last swap)\n        recipient: address = _recipient\n        if i < numTokens - 2:\n            recipient = self\n\n        # swap\n        tempAmountIn = self._swapTokensInPool(tempPool, tempTokenIn, tempTokenOut, tempAmountIn, recipient, curveMetaRegistry)\n\n    # final amount\n    amountOut: uint256 = tempAmountIn\n    assert amountOut >= minAmountOut # dev: min amount out not met\n\n    # refund if full swap didn't get through\n    currentLegoBalance: uint256 = staticcall IERC20(tokenIn).balanceOf(self)\n    refundAssetAmount: uint256 = 0\n    if currentLegoBalance > preLegoBalance:\n        refundAssetAmount = currentLegoBalance - preLegoBalance\n        assert extcall IERC20(tokenIn).transfer(msg.sender, refundAssetAmount, default_return_value=True) # dev: transfer failed\n        amountIn -= refundAssetAmount\n\n    # get usd values\n    usdValue: uint256 = staticcall Appraiser(miniAddys.appraiser).getUsdValue(tokenIn, amountIn, miniAddys.missionControl, miniAddys.legoBook, miniAddys.ledger)\n    if usdValue == 0:\n        usdValue = staticcall Appraiser(miniAddys.appraiser).getUsdValue(tokenOut, amountOut, miniAddys.missionControl, miniAddys.legoBook, miniAddys.ledger)\n\n    log CurveSwap(\n        sender = msg.sender,\n        tokenIn = tokenIn,\n        tokenOut = tokenOut,\n        amountIn = amountIn,\n        amountOut = amountOut,\n        usdValue = usdValue,\n        numTokens = numTokens,\n        recipient = _recipient,\n    )\n    return amountIn, amountOut, usdValue\n\n\n# swap in pool\n\n\n@internal\ndef _swapTokensInPool(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n    _recipient: address,\n    _curveMetaRegistry: address,\n) -> uint256:\n    amountOut: uint256 = 0\n    p: PoolData = self._getPoolData(_pool, _tokenIn, _tokenOut, _curveMetaRegistry)\n    assert extcall IERC20(_tokenIn).approve(_pool, _amountIn, default_return_value=True) # dev: approval failed\n\n    # stable ng\n    if p.poolType == PoolType.STABLESWAP_NG:\n        amountOut = extcall CommonCurvePool(_pool).exchange(convert(p.indexTokenA, int128), convert(p.indexTokenB, int128), _amountIn, 0, _recipient)\n\n    # two crypto ng\n    elif p.poolType == PoolType.TWO_CRYPTO_NG:\n        amountOut = extcall TwoCryptoNgPool(_pool).exchange(p.indexTokenA, p.indexTokenB, _amountIn, 0, _recipient)\n\n    # two crypto + tricrypto ng pools\n    elif p.poolType == PoolType.TRICRYPTO_NG or p.poolType == PoolType.TWO_CRYPTO:\n        amountOut = extcall TwoCryptoPool(_pool).exchange(p.indexTokenA, p.indexTokenB, _amountIn, 0, False, _recipient)\n\n    # meta pools\n    elif p.poolType == PoolType.METAPOOL:\n        if staticcall CurveMetaRegistry(_curveMetaRegistry).is_meta(_pool):\n            raise \"Not Implemented\"\n        else:\n            amountOut = extcall CommonCurvePool(_pool).exchange(convert(p.indexTokenA, int128), convert(p.indexTokenB, int128), _amountIn, 0, _recipient)\n\n    # crypto v1\n    else:\n        amountOut = extcall CryptoLegacyPool(_pool).exchange(p.indexTokenA, p.indexTokenB, _amountIn, 0, False)\n        if _recipient != self:\n            assert extcall IERC20(_tokenOut).transfer(_recipient, amountOut, default_return_value=True) # dev: transfer failed\n\n    assert extcall IERC20(_tokenIn).approve(_pool, 0, default_return_value=True) # dev: approval failed\n    assert amountOut != 0 # dev: no tokens swapped\n    return amountOut\n\n\n#################\n# Add Liquidity #\n#################\n\n\n@external\ndef addLiquidity(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _amountA: uint256,\n    _amountB: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _minLpAmount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (address, uint256, uint256, uint256, uint256):\n    assert not dld.isPaused # dev: paused\n    assert self._isAllowedToPerformAction(msg.sender) # dev: no perms\n    miniAddys: ws.MiniAddys = dld._getMiniAddys(_miniAddys)\n\n    assert empty(address) not in [_tokenA, _tokenB] # dev: invalid tokens\n    assert _tokenA != _tokenB # dev: invalid tokens\n\n    # pre balances\n    preLegoBalanceA: uint256 = staticcall IERC20(_tokenA).balanceOf(self)\n    preLegoBalanceB: uint256 = staticcall IERC20(_tokenB).balanceOf(self)\n\n    # token a\n    liqAmountA: uint256 = min(_amountA, staticcall IERC20(_tokenA).balanceOf(msg.sender))\n    if liqAmountA != 0:\n        assert extcall IERC20(_tokenA).transferFrom(msg.sender, self, liqAmountA, default_return_value=True) # dev: transfer failed\n        assert extcall IERC20(_tokenA).approve(_pool, liqAmountA, default_return_value=True) # dev: approval failed\n\n    # token b\n    liqAmountB: uint256 = min(_amountB, staticcall IERC20(_tokenB).balanceOf(msg.sender))\n    if liqAmountB != 0:\n        assert extcall IERC20(_tokenB).transferFrom(msg.sender, self, liqAmountB, default_return_value=True) # dev: transfer failed\n        assert extcall IERC20(_tokenB).approve(_pool, liqAmountB, default_return_value=True) # dev: approval failed\n\n    assert liqAmountA != 0 or liqAmountB != 0 # dev: need at least one token amount\n\n    # pool data\n    metaRegistry: address = CURVE_META_REGISTRY\n    p: PoolData = self._getPoolData(_pool, _tokenA, _tokenB, metaRegistry)\n\n    # add liquidity\n    lpAmountReceived: uint256 = 0\n    if p.poolType == PoolType.STABLESWAP_NG:\n        lpAmountReceived = self._addLiquidityStableNg(p, liqAmountA, liqAmountB, _minLpAmount, _recipient)\n    elif p.poolType == PoolType.TWO_CRYPTO_NG:\n        lpAmountReceived = self._addLiquidityTwoCryptoNg(p, liqAmountA, liqAmountB, _minLpAmount, _recipient)\n    elif p.poolType == PoolType.TWO_CRYPTO:\n        lpAmountReceived = self._addLiquidityTwoCrypto(p, liqAmountA, liqAmountB, _minLpAmount, _recipient)\n    elif p.poolType == PoolType.TRICRYPTO_NG:\n        lpAmountReceived = self._addLiquidityTricrypto(p, liqAmountA, liqAmountB, _minLpAmount, _recipient)\n    elif p.poolType == PoolType.METAPOOL and not staticcall CurveMetaRegistry(metaRegistry).is_meta(p.pool):\n        lpAmountReceived = self._addLiquidityMetaPool(p, liqAmountA, liqAmountB, _minLpAmount, _recipient)\n    assert lpAmountReceived != 0 # dev: no liquidity added\n\n    # handle token a refunds / approvals\n    refundAssetAmountA: uint256 = 0\n    if liqAmountA != 0:\n        assert extcall IERC20(_tokenA).approve(_pool, 0, default_return_value=True) # dev: approval failed\n\n        currentLegoBalanceA: uint256 = staticcall IERC20(_tokenA).balanceOf(self)\n        if currentLegoBalanceA > preLegoBalanceA:\n            refundAssetAmountA = currentLegoBalanceA - preLegoBalanceA\n            assert extcall IERC20(_tokenA).transfer(msg.sender, refundAssetAmountA, default_return_value=True) # dev: transfer failed\n            liqAmountA -= refundAssetAmountA\n\n    # handle token b refunds / approvals\n    refundAssetAmountB: uint256 = 0\n    if liqAmountB != 0:\n        assert extcall IERC20(_tokenB).approve(_pool, 0, default_return_value=True) # dev: approval failed\n\n        currentLegoBalanceB: uint256 = staticcall IERC20(_tokenB).balanceOf(self)\n        if currentLegoBalanceB > preLegoBalanceB:\n            refundAssetAmountB = currentLegoBalanceB - preLegoBalanceB\n            assert extcall IERC20(_tokenB).transfer(msg.sender, refundAssetAmountB, default_return_value=True) # dev: transfer failed\n            liqAmountB -= refundAssetAmountB\n\n    usdValue: uint256 = self._getUsdValue(_tokenA, liqAmountA, _tokenB, liqAmountB, miniAddys)\n    log CurveLiquidityAdded(\n        sender = msg.sender,\n        tokenA = _tokenA,\n        tokenB = _tokenB,\n        amountA = liqAmountA,\n        amountB = liqAmountB,\n        lpAmountReceived = lpAmountReceived,\n        usdValue = usdValue,\n        recipient = _recipient,\n    )\n    lpToken: address = staticcall CurveMetaRegistry(metaRegistry).get_lp_token(_pool)\n    return lpToken, lpAmountReceived, liqAmountA, liqAmountB, usdValue\n\n\n@internal\ndef _addLiquidityStableNg(\n    _p: PoolData,\n    _liqAmountA: uint256,\n    _liqAmountB: uint256,\n    _minLpAmount: uint256,\n    _recipient: address,\n) -> uint256:\n    lpAmountReceived: uint256 = 0\n\n    if _p.numCoins == 2:\n        amounts: DynArray[uint256, 2] = [0, 0]\n        amounts[_p.indexTokenA] = _liqAmountA\n        amounts[_p.indexTokenB] = _liqAmountB\n        lpAmountReceived = extcall StableNgTwo(_p.pool).add_liquidity(amounts, _minLpAmount, _recipient)\n\n    elif _p.numCoins == 3:\n        amounts: DynArray[uint256, 3] = [0, 0, 0]\n        amounts[_p.indexTokenA] = _liqAmountA\n        amounts[_p.indexTokenB] = _liqAmountB\n        lpAmountReceived = extcall StableNgThree(_p.pool).add_liquidity(amounts, _minLpAmount, _recipient)\n\n    elif _p.numCoins == 4:\n        amounts: DynArray[uint256, 4] = [0, 0, 0, 0]\n        amounts[_p.indexTokenA] = _liqAmountA\n        amounts[_p.indexTokenB] = _liqAmountB\n        lpAmountReceived = extcall StableNgFour(_p.pool).add_liquidity(amounts, _minLpAmount, _recipient)\n\n    return lpAmountReceived\n\n\n@internal\ndef _addLiquidityTwoCryptoNg(\n    _p: PoolData,\n    _liqAmountA: uint256,\n    _liqAmountB: uint256,\n    _minLpAmount: uint256,\n    _recipient: address,\n) -> uint256:\n    amounts: uint256[2] = [0, 0]\n    amounts[_p.indexTokenA] = _liqAmountA\n    amounts[_p.indexTokenB] = _liqAmountB\n    return extcall TwoCryptoNgPool(_p.pool).add_liquidity(amounts, _minLpAmount, _recipient)\n\n\n@internal\ndef _addLiquidityTwoCrypto(\n    _p: PoolData,\n    _liqAmountA: uint256,\n    _liqAmountB: uint256,\n    _minLpAmount: uint256,\n    _recipient: address,\n) -> uint256:\n    amounts: uint256[2] = [0, 0]\n    amounts[_p.indexTokenA] = _liqAmountA\n    amounts[_p.indexTokenB] = _liqAmountB\n    return extcall TwoCryptoPool(_p.pool).add_liquidity(amounts, _minLpAmount, False, _recipient)\n\n\n@internal\ndef _addLiquidityTricrypto(\n    _p: PoolData,\n    _liqAmountA: uint256,\n    _liqAmountB: uint256,\n    _minLpAmount: uint256,\n    _recipient: address,\n) -> uint256:\n    amounts: uint256[3] = [0, 0, 0]\n    amounts[_p.indexTokenA] = _liqAmountA\n    amounts[_p.indexTokenB] = _liqAmountB\n    return extcall TriCryptoPool(_p.pool).add_liquidity(amounts, _minLpAmount, False, _recipient)\n\n\n@internal\ndef _addLiquidityMetaPool(\n    _p: PoolData,\n    _liqAmountA: uint256,\n    _liqAmountB: uint256,\n    _minLpAmount: uint256,\n    _recipient: address,\n) -> uint256:\n    lpAmountReceived: uint256 = 0\n\n    if _p.numCoins == 2:\n        amounts: uint256[2] = [0, 0]\n        amounts[_p.indexTokenA] = _liqAmountA\n        amounts[_p.indexTokenB] = _liqAmountB\n        lpAmountReceived = extcall MetaPoolTwo(_p.pool).add_liquidity(amounts, _minLpAmount, _recipient)\n\n    elif _p.numCoins == 3:\n        amounts: uint256[3] = [0, 0, 0]\n        amounts[_p.indexTokenA] = _liqAmountA\n        amounts[_p.indexTokenB] = _liqAmountB\n        lpAmountReceived = extcall MetaPoolThree(_p.pool).add_liquidity(amounts, _minLpAmount, _recipient)\n\n    elif _p.numCoins == 4:\n        amounts: uint256[4] = [0, 0, 0, 0]\n        amounts[_p.indexTokenA] = _liqAmountA\n        amounts[_p.indexTokenB] = _liqAmountB\n        lpAmountReceived = extcall MetaPoolFour(_p.pool).add_liquidity(amounts, _minLpAmount, _recipient)\n\n    return lpAmountReceived\n\n\n####################\n# Remove Liquidity #\n####################\n\n\n@external\ndef removeLiquidity(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpToken: address,\n    _lpAmount: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, uint256):\n    assert not dld.isPaused # dev: paused\n    assert self._isAllowedToPerformAction(msg.sender) # dev: no perms\n    miniAddys: ws.MiniAddys = dld._getMiniAddys(_miniAddys)\n\n    # if one of the tokens is empty, it means they only want to remove liquidity for one token\n    assert _tokenA != empty(address) or _tokenB != empty(address) # dev: invalid tokens\n    assert _tokenA != _tokenB # dev: invalid tokens\n\n    isEmptyTokenA: bool = _tokenA == empty(address)\n    isOneCoinRemoval: bool = isEmptyTokenA or _tokenB == empty(address)\n\n    # pre balance\n    preLegoBalance: uint256 = staticcall IERC20(_lpToken).balanceOf(self)\n\n    # lp token amount\n    lpAmount: uint256 = min(_lpAmount, staticcall IERC20(_lpToken).balanceOf(msg.sender))\n    assert lpAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_lpToken).transferFrom(msg.sender, self, lpAmount, default_return_value=True) # dev: transfer failed\n\n    # approvals\n    assert extcall IERC20(_lpToken).approve(_pool, lpAmount, default_return_value=True) # dev: approval failed\n\n    # pool data\n    metaRegistry: address = CURVE_META_REGISTRY\n    p: PoolData = self._getPoolData(_pool, _tokenA, _tokenB, metaRegistry)\n\n    # remove liquidity\n    amountA: uint256 = 0\n    amountB: uint256 = 0\n    if p.poolType == PoolType.STABLESWAP_NG:\n        if isOneCoinRemoval:\n            amountA, amountB = self._removeLiquidityStableNgOneCoin(p, isEmptyTokenA, lpAmount, _minAmountA, _minAmountB, _recipient)\n        else:\n            amountA, amountB = self._removeLiquidityStableNg(p, lpAmount, _minAmountA, _minAmountB, _recipient)\n    elif p.poolType == PoolType.TWO_CRYPTO_NG:\n        if isOneCoinRemoval:\n            amountA, amountB = self._removeLiquidityTwoCryptoNgOneCoin(p, isEmptyTokenA, lpAmount, _minAmountA, _minAmountB, _recipient)\n        else:\n            amountA, amountB = self._removeLiquidityTwoCryptoNg(p, lpAmount, _minAmountA, _minAmountB, _recipient)\n    elif p.poolType == PoolType.TWO_CRYPTO:\n        if isOneCoinRemoval:\n            amountA, amountB = self._removeLiquidityTwoCryptoOneCoin(p, isEmptyTokenA, lpAmount, _minAmountA, _minAmountB, _recipient)\n        else:\n            amountA, amountB = self._removeLiquidityTwoCrypto(p, lpAmount, _tokenA, _tokenB, _minAmountA, _minAmountB, _recipient)\n    elif p.poolType == PoolType.TRICRYPTO_NG:\n        if isOneCoinRemoval:\n            amountA, amountB = self._removeLiquidityTricryptoOneCoin(p, isEmptyTokenA, lpAmount, _minAmountA, _minAmountB, _recipient)\n        else:\n            amountA, amountB = self._removeLiquidityTricrypto(p, lpAmount, _minAmountA, _minAmountB, _recipient)\n    elif p.poolType == PoolType.METAPOOL and not staticcall CurveMetaRegistry(metaRegistry).is_meta(p.pool):\n        if isOneCoinRemoval:\n            amountA, amountB = self._removeLiquidityMetaPoolOneCoin(p, isEmptyTokenA, lpAmount, _minAmountA, _minAmountB, _recipient)\n        else:\n            amountA, amountB = self._removeLiquidityMetaPool(p, lpAmount, _minAmountA, _minAmountB, _recipient)\n    assert amountA != 0 or amountB != 0 # dev: nothing removed\n\n    # reset approvals\n    assert extcall IERC20(_lpToken).approve(_pool, 0, default_return_value=True) # dev: approval failed\n\n    # refund if full liquidity was not removed\n    currentLegoBalance: uint256 = staticcall IERC20(_lpToken).balanceOf(self)\n    refundedLpAmount: uint256 = 0\n    if currentLegoBalance > preLegoBalance:\n        refundedLpAmount = currentLegoBalance - preLegoBalance\n        assert extcall IERC20(_lpToken).transfer(msg.sender, refundedLpAmount, default_return_value=True) # dev: transfer failed\n        lpAmount -= refundedLpAmount\n\n    usdValue: uint256 = self._getUsdValue(_tokenA, amountA, _tokenB, amountB, miniAddys)\n    log CurveLiquidityRemoved(\n        sender = msg.sender,\n        pool = _pool,\n        tokenA = _tokenA,\n        tokenB = _tokenB,\n        amountA = amountA,\n        amountB = amountB,\n        lpToken = _lpToken,\n        lpAmountBurned = lpAmount,\n        usdValue = usdValue,\n        recipient = _recipient,\n    )\n    return amountA, amountB, lpAmount, usdValue\n\n\n# stable ng\n\n\n@internal\ndef _removeLiquidityStableNgOneCoin(\n    _p: PoolData,\n    _isEmptyTokenA: bool,\n    _lpAmount: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _recipient: address,\n) -> (uint256, uint256):\n    tokenIndex: uint256 = 0\n    minAmountOut: uint256 = 0\n    tokenIndex, minAmountOut = self._getTokenIndexAndMinAmountOut(_isEmptyTokenA, _p.indexTokenA, _p.indexTokenB, _minAmountA, _minAmountB)\n    amountOut: uint256 = extcall StableNgTwo(_p.pool).remove_liquidity_one_coin(_lpAmount, convert(tokenIndex, int128), minAmountOut, _recipient)\n    return self._getTokenAmounts(_isEmptyTokenA, amountOut)\n\n\n@internal\ndef _removeLiquidityStableNg(\n    _p: PoolData,\n    _lpAmount: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _recipient: address,\n) -> (uint256, uint256):\n\n    # only supporting 2-coin pools, can't give minAmountsOut for other coins\n    assert _p.numCoins == 2 # dev: invalid pool\n\n    minAmountsOut: DynArray[uint256, 2] = [0, 0]\n    minAmountsOut[_p.indexTokenA] = _minAmountA\n    minAmountsOut[_p.indexTokenB] = _minAmountB\n\n    # remove liquidity\n    amountsOut: DynArray[uint256, 2] = extcall StableNgTwo(_p.pool).remove_liquidity(_lpAmount, minAmountsOut, _recipient, False)\n    return amountsOut[_p.indexTokenA], amountsOut[_p.indexTokenB]\n\n\n# two crypto ng\n\n\n@internal\ndef _removeLiquidityTwoCryptoNgOneCoin(\n    _p: PoolData,\n    _isEmptyTokenA: bool,\n    _lpAmount: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _recipient: address,\n) -> (uint256, uint256):\n    tokenIndex: uint256 = 0\n    minAmountOut: uint256 = 0\n    tokenIndex, minAmountOut = self._getTokenIndexAndMinAmountOut(_isEmptyTokenA, _p.indexTokenA, _p.indexTokenB, _minAmountA, _minAmountB)\n    amountOut: uint256 = extcall TwoCryptoNgPool(_p.pool).remove_liquidity_one_coin(_lpAmount, tokenIndex, minAmountOut, _recipient)\n    return self._getTokenAmounts(_isEmptyTokenA, amountOut)\n\n\n@internal\ndef _removeLiquidityTwoCryptoNg(\n    _p: PoolData,\n    _lpAmount: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _recipient: address,\n) -> (uint256, uint256):\n\n    # only supporting 2-coin pools, can't give minAmountsOut for other coins\n    assert _p.numCoins == 2 # dev: invalid pool\n\n    minAmountsOut: uint256[2] = [0, 0]\n    minAmountsOut[_p.indexTokenA] = _minAmountA\n    minAmountsOut[_p.indexTokenB] = _minAmountB\n\n    # remove liquidity\n    amountsOut: uint256[2] = extcall TwoCryptoNgPool(_p.pool).remove_liquidity(_lpAmount, minAmountsOut, _recipient)\n    return amountsOut[_p.indexTokenA], amountsOut[_p.indexTokenB]\n\n\n# two crypto\n\n\n@internal\ndef _removeLiquidityTwoCryptoOneCoin(\n    _p: PoolData,\n    _isEmptyTokenA: bool,\n    _lpAmount: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _recipient: address,\n) -> (uint256, uint256):\n    tokenIndex: uint256 = 0\n    minAmountOut: uint256 = 0\n    tokenIndex, minAmountOut = self._getTokenIndexAndMinAmountOut(_isEmptyTokenA, _p.indexTokenA, _p.indexTokenB, _minAmountA, _minAmountB)\n    amountOut: uint256 = extcall TwoCryptoPool(_p.pool).remove_liquidity_one_coin(_lpAmount, tokenIndex, minAmountOut, False, _recipient)\n    return self._getTokenAmounts(_isEmptyTokenA, amountOut)\n\n\n@internal\ndef _removeLiquidityTwoCrypto(\n    _p: PoolData,\n    _lpAmount: uint256,\n    _tokenA: address,\n    _tokenB: address,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _recipient: address,\n) -> (uint256, uint256):\n\n    # only supporting 2-coin pools\n    assert _p.numCoins == 2 # dev: invalid pool\n\n    # pre balances\n    preBalTokenA: uint256 = staticcall IERC20(_tokenA).balanceOf(_recipient)\n    preBalTokenB: uint256 = staticcall IERC20(_tokenB).balanceOf(_recipient)\n\n    # organize min amounts out\n    minAmountsOut: uint256[2] = [0, 0]\n    minAmountsOut[_p.indexTokenA] = _minAmountA\n    minAmountsOut[_p.indexTokenB] = _minAmountB\n\n    # remove liquidity\n    extcall TwoCryptoPool(_p.pool).remove_liquidity(_lpAmount, minAmountsOut, False, _recipient)\n\n    # get amounts\n    amountA: uint256 = 0\n    postBalTokenA: uint256 = staticcall IERC20(_tokenA).balanceOf(_recipient)\n    if postBalTokenA > preBalTokenA:\n        amountA = postBalTokenA - preBalTokenA\n\n    amountB: uint256 = 0\n    postBalTokenB: uint256 = staticcall IERC20(_tokenB).balanceOf(_recipient)\n    if postBalTokenB > preBalTokenB:\n        amountB = postBalTokenB - preBalTokenB\n\n    return amountA, amountB\n\n\n# tricrypto ng\n\n\n@internal\ndef _removeLiquidityTricryptoOneCoin(\n    _p: PoolData,\n    _isEmptyTokenA: bool,\n    _lpAmount: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _recipient: address,\n) -> (uint256, uint256):\n    tokenIndex: uint256 = 0\n    minAmountOut: uint256 = 0\n    tokenIndex, minAmountOut = self._getTokenIndexAndMinAmountOut(_isEmptyTokenA, _p.indexTokenA, _p.indexTokenB, _minAmountA, _minAmountB)\n    amountOut: uint256 = extcall TriCryptoPool(_p.pool).remove_liquidity_one_coin(_lpAmount, tokenIndex, minAmountOut, False, _recipient)\n    return self._getTokenAmounts(_isEmptyTokenA, amountOut)\n\n\n@internal\ndef _removeLiquidityTricrypto(\n    _p: PoolData,\n    _lpAmount: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _recipient: address,\n) -> (uint256, uint256):\n    minAmountsOut: uint256[3] = [0, 0, 0]\n    minAmountsOut[_p.indexTokenA] = _minAmountA\n    minAmountsOut[_p.indexTokenB] = _minAmountB\n\n    # NOTE: user can only specify two min amounts out, the third will be set to zero\n\n    # remove liquidity\n    amountsOut: uint256[3] = extcall TriCryptoPool(_p.pool).remove_liquidity(_lpAmount, minAmountsOut, False, _recipient, False)\n    return amountsOut[_p.indexTokenA], amountsOut[_p.indexTokenB]\n\n\n# meta pool\n\n\n@internal\ndef _removeLiquidityMetaPoolOneCoin(\n    _p: PoolData,\n    _isEmptyTokenA: bool,\n    _lpAmount: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _recipient: address,\n) -> (uint256, uint256):\n    tokenIndex: uint256 = 0\n    minAmountOut: uint256 = 0\n    tokenIndex, minAmountOut = self._getTokenIndexAndMinAmountOut(_isEmptyTokenA, _p.indexTokenA, _p.indexTokenB, _minAmountA, _minAmountB)\n    amountOut: uint256 = extcall MetaPoolCommon(_p.pool).remove_liquidity_one_coin(_lpAmount, convert(tokenIndex, int128), minAmountOut, _recipient)\n    return self._getTokenAmounts(_isEmptyTokenA, amountOut)\n\n\n@internal\ndef _removeLiquidityMetaPool(\n    _p: PoolData,\n    _lpAmount: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _recipient: address,\n) -> (uint256, uint256):\n    amountA: uint256 = 0\n    amountB: uint256 = 0\n\n    # NOTE: user can only specify two min amounts out, the third/fourth will be set to zero\n\n    if _p.numCoins == 2:\n        minAmountsOut: uint256[2] = [0, 0]\n        minAmountsOut[_p.indexTokenA] = _minAmountA\n        minAmountsOut[_p.indexTokenB] = _minAmountB\n        amountsOut: uint256[2] = extcall MetaPoolTwo(_p.pool).remove_liquidity(_lpAmount, minAmountsOut, _recipient)\n        amountA = amountsOut[_p.indexTokenA]\n        amountB = amountsOut[_p.indexTokenB]\n\n    elif _p.numCoins == 3:\n        minAmountsOut: uint256[3] = [0, 0, 0]\n        minAmountsOut[_p.indexTokenA] = _minAmountA\n        minAmountsOut[_p.indexTokenB] = _minAmountB\n        amountsOut: uint256[3] = extcall MetaPoolThree(_p.pool).remove_liquidity(_lpAmount, minAmountsOut, _recipient)\n        amountA = amountsOut[_p.indexTokenA]\n        amountB = amountsOut[_p.indexTokenB]\n\n    elif _p.numCoins == 4:\n        minAmountsOut: uint256[4] = [0, 0, 0, 0]\n        minAmountsOut[_p.indexTokenA] = _minAmountA\n        minAmountsOut[_p.indexTokenB] = _minAmountB\n        amountsOut: uint256[4] = extcall MetaPoolFour(_p.pool).remove_liquidity(_lpAmount, minAmountsOut, _recipient)\n        amountA = amountsOut[_p.indexTokenA]\n        amountB = amountsOut[_p.indexTokenB]\n\n    else:\n        raise \"meta pool: pools beyond 4-coin are not supported\"\n\n    return amountA, amountB\n\n\n# utils\n\n\n@pure\n@internal\ndef _getTokenIndexAndMinAmountOut(\n    _isEmptyTokenA: bool,\n    _indexTokenA: uint256,\n    _indexTokenB: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n) -> (uint256, uint256):\n    tokenIndex: uint256 = _indexTokenA\n    minAmountOut: uint256 = _minAmountA\n    if _isEmptyTokenA:\n        tokenIndex = _indexTokenB\n        minAmountOut = _minAmountB\n    return tokenIndex, minAmountOut\n\n\n@pure\n@internal\ndef _getTokenAmounts(_isEmptyTokenA: bool, _amountOut: uint256) -> (uint256, uint256):\n    amountA: uint256 = 0\n    amountB: uint256 = 0\n    if _isEmptyTokenA:\n        amountB = _amountOut\n    else:\n        amountA = _amountOut\n    return amountA, amountB\n\n\n\n# get usd value on liquidity actions\n\n\n@internal\ndef _getUsdValue(\n    _tokenA: address,\n    _amountA: uint256,\n    _tokenB: address,\n    _amountB: uint256,\n    _miniAddys: ws.MiniAddys,\n) -> uint256:\n\n    usdValueA: uint256 = 0\n    if _amountA != 0:\n        usdValueA = staticcall Appraiser(_miniAddys.appraiser).getUsdValue(_tokenA, _amountA, _miniAddys.missionControl, _miniAddys.legoBook, _miniAddys.ledger)\n\n    usdValueB: uint256 = 0\n    if _amountB != 0:\n        usdValueB = staticcall Appraiser(_miniAddys.appraiser).getUsdValue(_tokenB, _amountB, _miniAddys.missionControl, _miniAddys.legoBook, _miniAddys.ledger)\n\n    return usdValueA + usdValueB\n\n\n#############\n# Utilities #\n#############\n\n\n@view\n@external\ndef getLpToken(_pool: address) -> address:\n    return staticcall CurveMetaRegistry(CURVE_META_REGISTRY).get_lp_token(_pool)\n\n\n@view\n@external\ndef getPoolForLpToken(_lpToken: address) -> address:\n    return staticcall CurveMetaRegistry(CURVE_META_REGISTRY).get_pool_from_lp_token(_lpToken)\n\n\n@view\n@external\ndef getCoreRouterPool() -> address:\n    return empty(address)\n\n\n@view\n@external\ndef getDeepestLiqPool(_tokenA: address, _tokenB: address) -> BestPool:\n    metaRegistry: address = CURVE_META_REGISTRY\n\n    # all pools with tokens\n    allPools: DynArray[address, MAX_POOLS] = staticcall CurveMetaRegistry(metaRegistry).find_pools_for_coins(_tokenA, _tokenB)\n    if len(allPools) == 0:\n        return empty(BestPool)\n\n    # get deepest liquidity pool\n    bestPoolAddr: address = empty(address)\n    na1: int128 = 0\n    na2: int128 = 0\n    bestLiquidity: uint256 = 0\n    bestPoolAddr, na1, na2, bestLiquidity = self._getDeepestLiqPool(_tokenA, _tokenB, allPools, metaRegistry)\n\n    if bestPoolAddr == empty(address):\n        return empty(BestPool)\n\n    return BestPool(\n        pool=bestPoolAddr,\n        fee=staticcall CommonCurvePool(bestPoolAddr).fee() // 1000000, # normalize to have 100_00 denominator\n        liquidity=bestLiquidity,\n        numCoins=staticcall CurveMetaRegistry(metaRegistry).get_n_coins(bestPoolAddr),\n    )\n\n\n@view\n@external\ndef getBestSwapAmountOut(_tokenIn: address, _tokenOut: address, _amountIn: uint256) -> (address, uint256):\n    return self._getBestSwapAmountOut(_tokenIn, _tokenOut, _amountIn)\n\n\n@view\n@internal\ndef _getBestSwapAmountOut(_tokenIn: address, _tokenOut: address, _amountIn: uint256) -> (address, uint256):\n    bestPool: address = empty(address)\n    bestAmountOut: uint256 = 0\n\n    quotes: DynArray[Quote, MAX_QUOTES] = staticcall CurveRateProvider(CURVE_REGISTRIES.RateProvider).get_quotes(_tokenIn, _tokenOut, _amountIn)\n    for quote: Quote in quotes:\n        if quote.amount_out > bestAmountOut:\n            bestAmountOut = quote.amount_out\n            bestPool = quote.pool\n\n    return bestPool, bestAmountOut\n\n\n@view\n@external\ndef getSwapAmountOut(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n) -> uint256:\n    quotes: DynArray[Quote, MAX_QUOTES] = staticcall CurveRateProvider(CURVE_REGISTRIES.RateProvider).get_quotes(_tokenIn, _tokenOut, _amountIn)\n    bestAmountOut: uint256 = 0\n    for quote: Quote in quotes:\n        if _pool == quote.pool:\n            return quote.amount_out\n    return 0\n\n\n@view\n@external\ndef getBestSwapAmountIn(_tokenIn: address, _tokenOut: address, _amountOut: uint256) -> (address, uint256):\n    if _amountOut == 0 or _amountOut == max_value(uint256):\n        return empty(address), max_value(uint256)\n\n    expAmountIn: uint256 = self._getSwapAmountIn(empty(address), _tokenIn, _tokenOut, _amountOut)\n    if expAmountIn == 0:\n        return empty(address), 0\n\n    # NOTE: this isn't perfect, but it's good enough\n\n    bestPool: address = empty(address)\n    na: uint256 = 0\n    bestPool, na = self._getBestSwapAmountOut(_tokenIn, _tokenOut, expAmountIn)\n    return bestPool, expAmountIn\n\n\n@view\n@external\ndef getSwapAmountIn(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountOut: uint256,\n) -> uint256:\n    if _amountOut == 0 or _amountOut == max_value(uint256):\n        return max_value(uint256)\n    return self._getSwapAmountIn(_pool, _tokenIn, _tokenOut, _amountOut)\n\n\n@view\n@internal\ndef _getSwapAmountIn(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountOut: uint256,\n) -> uint256:\n    rate: uint256 = staticcall CurveRateProvider(CURVE_REGISTRIES.RateProvider).get_aggregated_rate(_tokenIn, _tokenOut)\n    if rate == 0:\n        return 0\n    decimalsTokenIn: uint256 = convert(staticcall IERC20Detailed(_tokenIn).decimals(), uint256)\n    return _amountOut * (10 ** decimalsTokenIn) // rate\n\n\n@view\n@external\ndef getAddLiqAmountsIn(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _availAmountA: uint256,\n    _availAmountB: uint256,\n) -> (uint256, uint256, uint256):\n    metaRegistry: address = CURVE_META_REGISTRY\n    p: PoolData = self._getPoolData(_pool, _tokenA, _tokenB, metaRegistry)\n\n    balances: uint256[8] = staticcall CurveMetaRegistry(metaRegistry).get_balances(_pool)\n    reserveA: uint256 = balances[p.indexTokenA]\n    reserveB: uint256 = balances[p.indexTokenB]\n\n    # insufficient liquidity\n    if reserveA == 0 or reserveB == 0:\n        return 0, 0, 0\n\n    # calculate optimal amounts\n    amountA: uint256 = 0\n    amountB: uint256 = 0\n    amountA, amountB = self._getCorrectRatioAmounts(_availAmountA, _availAmountB, reserveA, reserveB)\n\n    expectedLpAmount: uint256 = 0\n    if p.poolType == PoolType.STABLESWAP_NG:\n        expectedLpAmount = self._getAddLiqAmountsInStableNg(p, amountA, amountB)\n    elif p.poolType == PoolType.TWO_CRYPTO_NG:\n        expectedLpAmount = self._getAddLiqAmountsInCryptoNg(p, amountA, amountB)\n    elif p.poolType == PoolType.TWO_CRYPTO:\n        expectedLpAmount = self._getAddLiqAmountsInTwoCrypto(p, amountA, amountB)\n    elif p.poolType == PoolType.TRICRYPTO_NG:\n        expectedLpAmount = self._getAddLiqAmountsInTricrypto(p, amountA, amountB)\n    elif p.poolType == PoolType.METAPOOL and not staticcall CurveMetaRegistry(metaRegistry).is_meta(p.pool):\n        expectedLpAmount = self._getAddLiqAmountsInMetaPool(p, amountA, amountB)\n\n    if expectedLpAmount == 0:\n        return 0, 0, 0\n\n    return amountA, amountB, expectedLpAmount\n\n\n@view\n@external\ndef getRemoveLiqAmountsOut(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpAmount: uint256,\n) -> (uint256, uint256):\n    metaRegistry: address = CURVE_META_REGISTRY\n    p: PoolData = self._getPoolData(_pool, _tokenA, _tokenB, metaRegistry)\n\n    # NOTE: in this case, allowing 0x0 for one token, signifying desire to withdraw just one token\n\n    # normal scenario, 2-coin pool\n    if _tokenA != empty(address) and _tokenB != empty(address):\n        return self._getRemoveLiqAmountsOutTwoCoinPool(p, _tokenA, _tokenB, _lpAmount, metaRegistry)\n\n    # withdraw just one token\n    amountOut: uint256 = 0\n    tokenIndex: uint256 = p.indexTokenA\n    if _tokenA == empty(address):\n        tokenIndex = p.indexTokenB\n\n    # perform calculation\n    if p.poolType == PoolType.STABLESWAP_NG:\n        amountOut = staticcall StableNgTwo(p.pool).calc_withdraw_one_coin(_lpAmount, convert(tokenIndex, int128))\n    elif p.poolType == PoolType.TWO_CRYPTO_NG:\n        amountOut = staticcall TwoCryptoNgPool(p.pool).calc_withdraw_one_coin(_lpAmount, tokenIndex)\n    elif p.poolType == PoolType.TWO_CRYPTO:\n        amountOut = staticcall TwoCryptoPool(p.pool).calc_withdraw_one_coin(_lpAmount, tokenIndex)\n    elif p.poolType == PoolType.TRICRYPTO_NG:\n        amountOut = staticcall TriCryptoPool(p.pool).calc_withdraw_one_coin(_lpAmount, tokenIndex)\n    elif p.poolType == PoolType.METAPOOL and not staticcall CurveMetaRegistry(metaRegistry).is_meta(p.pool):\n        amountOut = staticcall MetaPoolCommon(p.pool).calc_withdraw_one_coin(_lpAmount, convert(tokenIndex, int128))\n\n    # get in correct order\n    amountA: uint256 = amountOut\n    amountB: uint256 = 0\n    if _tokenA == empty(address):\n        amountA = 0\n        amountB = amountOut\n\n    return amountA, amountB\n\n\n@view\n@external\ndef getPrice(_asset: address, _decimals: uint256) -> uint256:\n    return 0 # TODO: implement price\n\n\n@view\n@external\ndef getPriceUnsafe(_pool: address, _targetToken: address, _oracleRegistry: address = empty(address)) -> uint256:\n    return 0\n\n\n# internal utils\n\n\n@view\n@internal\ndef _getDeepestLiqPool(_tokenA: address, _tokenB: address, _allPools: DynArray[address, MAX_POOLS], _metaRegistry: address) -> (address, int128, int128, uint256):\n    bestPoolAddr: address = empty(address)\n    bestTokenAIndex: int128 = 0\n    bestTokenBIndex: int128 = 0\n    bestLiquidity: uint256 = 0\n\n    for i: uint256 in range(len(_allPools), bound=MAX_POOLS):\n        pool: address = _allPools[i]\n        if pool == empty(address):\n            continue\n\n        # balances\n        balances: uint256[8] = staticcall CurveMetaRegistry(_metaRegistry).get_balances(pool)\n        if balances[0] == 0:\n            continue\n\n        # token indexes \n        indexTokenA: int128 = 0\n        indexTokenB: int128 = 0\n        na: bool = False\n        indexTokenA, indexTokenB, na = staticcall CurveMetaRegistry(_metaRegistry).get_coin_indices(pool, _tokenA, _tokenB)\n\n        # compare liquidity\n        liquidity: uint256 = balances[indexTokenA] + balances[indexTokenB]\n        if liquidity > bestLiquidity:\n            bestPoolAddr = pool\n            bestTokenAIndex = indexTokenA\n            bestTokenBIndex = indexTokenB\n            bestLiquidity = liquidity\n\n    return bestPoolAddr, bestTokenAIndex, bestTokenBIndex, bestLiquidity\n\n\n@view\n@internal\ndef _getPoolData(_pool: address, _tokenA: address, _tokenB: address, _metaRegistry: address) -> PoolData:\n    assert staticcall CurveMetaRegistry(_metaRegistry).is_registered(_pool) # dev: invalid pool\n    coins: address[8] = staticcall CurveMetaRegistry(_metaRegistry).get_coins(_pool)\n\n    # validate tokens\n    if _tokenA != empty(address):\n        assert _tokenA in coins # dev: invalid tokens\n    if _tokenB != empty(address):\n        assert _tokenB in coins # dev: invalid tokens\n\n    # get indices\n    indexTokenA: uint256 = max_value(uint256)\n    indexTokenB: uint256 = max_value(uint256)\n    numCoins: uint256 = 0\n    for coin: address in coins:\n        if coin == empty(address):\n            break\n        if coin == _tokenA:\n            indexTokenA = numCoins\n        elif coin == _tokenB:\n            indexTokenB = numCoins\n        numCoins += 1\n\n    return PoolData(\n        pool=_pool,\n        indexTokenA=indexTokenA,\n        indexTokenB=indexTokenB,\n        poolType=self._getPoolType(_pool, _metaRegistry),\n        numCoins=numCoins,\n    )\n\n\n@view\n@internal\ndef _getPoolType(_pool: address, _metaRegistry: address) -> PoolType:\n    # check what type of pool this is based on where it's registered on Curve\n    registryHandlers: address[10] = staticcall CurveMetaRegistry(_metaRegistry).get_registry_handlers_from_pool(_pool)\n    baseRegistry: address = staticcall CurveMetaRegistry(_metaRegistry).get_base_registry(registryHandlers[0])\n\n    curveRegistries: CurveRegistries = CURVE_REGISTRIES\n    poolType: PoolType = empty(PoolType)\n    if baseRegistry == curveRegistries.StableSwapNg:\n        poolType = PoolType.STABLESWAP_NG\n    elif baseRegistry == curveRegistries.TwoCryptoNg:\n        poolType = PoolType.TWO_CRYPTO_NG\n    elif baseRegistry == curveRegistries.TricryptoNg:\n        poolType = PoolType.TRICRYPTO_NG\n    elif baseRegistry == curveRegistries.TwoCrypto:\n        poolType = PoolType.TWO_CRYPTO\n    elif baseRegistry == curveRegistries.MetaPool:\n        poolType = PoolType.METAPOOL\n    else:\n        poolType = PoolType.CRYPTO\n    return poolType\n\n\n@view\n@internal\ndef _getAddLiqAmountsInStableNg(\n    _p: PoolData,\n    _liqAmountA: uint256,\n    _liqAmountB: uint256,\n) -> uint256:\n    expLpAmount: uint256 = 0\n\n    if _p.numCoins == 2:\n        amounts: DynArray[uint256, 2] = [0, 0]\n        amounts[_p.indexTokenA] = _liqAmountA\n        amounts[_p.indexTokenB] = _liqAmountB\n        expLpAmount = staticcall StableNgTwo(_p.pool).calc_token_amount(amounts, True)\n\n    elif _p.numCoins == 3:\n        amounts: DynArray[uint256, 3] = [0, 0, 0]\n        amounts[_p.indexTokenA] = _liqAmountA\n        amounts[_p.indexTokenB] = _liqAmountB\n        expLpAmount = staticcall StableNgThree(_p.pool).calc_token_amount(amounts, True)\n\n    elif _p.numCoins == 4:\n        amounts: DynArray[uint256, 4] = [0, 0, 0, 0]\n        amounts[_p.indexTokenA] = _liqAmountA\n        amounts[_p.indexTokenB] = _liqAmountB\n        expLpAmount = staticcall StableNgFour(_p.pool).calc_token_amount(amounts, True)\n\n    return expLpAmount\n\n\n@view\n@internal\ndef _getAddLiqAmountsInCryptoNg(\n    _p: PoolData,\n    _liqAmountA: uint256,\n    _liqAmountB: uint256,\n) -> uint256:\n    amounts: uint256[2] = [0, 0]\n    amounts[_p.indexTokenA] = _liqAmountA\n    amounts[_p.indexTokenB] = _liqAmountB\n    return staticcall TwoCryptoNgPool(_p.pool).calc_token_amount(amounts, True)\n\n\n@view\n@internal\ndef _getAddLiqAmountsInTwoCrypto(\n    _p: PoolData,\n    _liqAmountA: uint256,\n    _liqAmountB: uint256,\n) -> uint256:\n    amounts: uint256[2] = [0, 0]\n    amounts[_p.indexTokenA] = _liqAmountA\n    amounts[_p.indexTokenB] = _liqAmountB\n    return staticcall TwoCryptoPool(_p.pool).calc_token_amount(amounts)\n\n\n@view\n@internal\ndef _getAddLiqAmountsInTricrypto(\n    _p: PoolData,\n    _liqAmountA: uint256,\n    _liqAmountB: uint256,\n) -> uint256:\n    amounts: uint256[3] = [0, 0, 0]\n    amounts[_p.indexTokenA] = _liqAmountA\n    amounts[_p.indexTokenB] = _liqAmountB\n    return staticcall TriCryptoPool(_p.pool).calc_token_amount(amounts, True)\n\n\n@view\n@internal\ndef _getAddLiqAmountsInMetaPool(\n    _p: PoolData,\n    _liqAmountA: uint256,\n    _liqAmountB: uint256,\n) -> uint256:\n    expLpAmount: uint256 = 0\n\n    if _p.numCoins == 2:\n        amounts: uint256[2] = [0, 0]\n        amounts[_p.indexTokenA] = _liqAmountA\n        amounts[_p.indexTokenB] = _liqAmountB\n        expLpAmount = staticcall MetaPoolTwo(_p.pool).calc_token_amount(amounts, True)\n\n    elif _p.numCoins == 3:\n        amounts: uint256[3] = [0, 0, 0]\n        amounts[_p.indexTokenA] = _liqAmountA\n        amounts[_p.indexTokenB] = _liqAmountB\n        expLpAmount = staticcall MetaPoolThree(_p.pool).calc_token_amount(amounts, True)\n\n    elif _p.numCoins == 4:\n        amounts: uint256[4] = [0, 0, 0, 0]\n        amounts[_p.indexTokenA] = _liqAmountA\n        amounts[_p.indexTokenB] = _liqAmountB\n        expLpAmount = staticcall MetaPoolFour(_p.pool).calc_token_amount(amounts, True)\n\n    return expLpAmount\n\n\n@view\n@internal\ndef _getRemoveLiqAmountsOutTwoCoinPool(\n    _p: PoolData,\n    _tokenA: address,\n    _tokenB: address,\n    _lpAmount: uint256,\n    _metaRegistry: address,\n) -> (uint256, uint256):\n\n    # only supporting 2-coin pools\n    if _p.numCoins > 2:\n        return max_value(uint256), max_value(uint256)\n\n    # get balances\n    balances: uint256[8] = staticcall CurveMetaRegistry(_metaRegistry).get_balances(_p.pool)\n    reserveA: uint256 = balances[_p.indexTokenA]\n    reserveB: uint256 = balances[_p.indexTokenB]\n\n    # insufficient liquidity\n    if reserveA == 0 or reserveB == 0:\n        return max_value(uint256), max_value(uint256)\n\n    # calculate expected amounts out\n    lpToken: address = staticcall CurveMetaRegistry(_metaRegistry).get_lp_token(_p.pool)\n    totalSupply: uint256 = staticcall IERC20(lpToken).totalSupply()\n    expectedAmountA: uint256 = _lpAmount * reserveA // totalSupply\n    expectedAmountB: uint256 = _lpAmount * reserveB // totalSupply\n    return expectedAmountA, expectedAmountB\n\n\n@view\n@internal\ndef _getCorrectRatioAmounts(\n    _availAmountA: uint256,\n    _availAmountB: uint256,\n    _reserveA: uint256,\n    _reserveB: uint256,\n) -> (uint256, uint256):\n    amountA: uint256 = _availAmountA\n    amountB: uint256 = self._quote(_availAmountA, _reserveA, _reserveB)\n    if amountB > _availAmountB:\n        maybeAmountA: uint256 = self._quote(_availAmountB, _reserveB, _reserveA)\n        if maybeAmountA <= _availAmountA:\n            amountA = maybeAmountA\n            amountB = _availAmountB\n    return amountA, amountB\n\n\n@view\n@internal\ndef _quote(_amountA: uint256, _reserveA: uint256, _reserveB: uint256) -> uint256:\n    return (_amountA * _reserveB) // _reserveA\n\n\n@view\n@external\ndef getAccessForLego(_user: address, _action: ws.ActionType) -> (address, String[64], uint256):\n    return empty(address), empty(String[64]), 0\n",
            "sha256sum": "299ee2d54536567504a3ed483a9ec4c8e0f562af633367626e716428b7ae4617"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/legos/dexes/Curve.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.3+commit.bff19ea2",
        "integrity": "4ed181b57155aa4d6b7e28c2a2e09d42eadd3ac4b964e78b2deb50c41238e3b1"
      },
      "args": "00000000000000000000000044cf3c4f000dfd76a35d03298049d37be688d6f90000000000000000000000005ffe7fb82894076ecb99a30d6a32e969e6e35e980000000000000000000000006162df1b329e157479f8f1407e888260e0ec3d2b",
      "file": "contracts/legos/dexes/Curve.vy"
    },
    "UniswapV2": {
      "address": "0x6970932a453F1ee612ffEAd6574123289DB94958",
      "abi": [
        {
          "name": "UniswapV2Swap",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenIn",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenOut",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amountIn",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "amountOut",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "numTokens",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UniswapV2LiquidityAdded",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenA",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenB",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amountA",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "amountB",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "lpAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UniswapV2LiquidityRemoved",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": false
            },
            {
              "name": "pool",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenA",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenB",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amountA",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "amountB",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "lpToken",
              "type": "address",
              "indexed": false
            },
            {
              "name": "lpAmountBurned",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LegoPauseModified",
          "inputs": [
            {
              "name": "isPaused",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LegoFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "balance",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddys",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "undyToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "hatchery",
                  "type": "address"
                },
                {
                  "name": "lootDistributor",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                },
                {
                  "name": "walletBackpack",
                  "type": "address"
                },
                {
                  "name": "billing",
                  "type": "address"
                },
                {
                  "name": "vaultRegistry",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUndyHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pause",
          "inputs": [
            {
              "name": "_shouldPause",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFundsMany",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_assets",
              "type": "address[]"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "legoId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isPaused",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasCapability",
          "inputs": [
            {
              "name": "_action",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRegistries",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isYieldLego",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isDexLego",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_tokenPath",
              "type": "address[]"
            },
            {
              "name": "_poolPath",
              "type": "address[]"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_tokenPath",
              "type": "address[]"
            },
            {
              "name": "_poolPath",
              "type": "address[]"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLpToken",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPoolForLpToken",
          "inputs": [
            {
              "name": "_lpToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getCoreRouterPool",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getDeepestLiqPool",
          "inputs": [
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "fee",
                  "type": "uint256"
                },
                {
                  "name": "liquidity",
                  "type": "uint256"
                },
                {
                  "name": "numCoins",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getBestSwapAmountOut",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountIn",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getSwapAmountOut",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountIn",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getBestSwapAmountIn",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountOut",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getSwapAmountIn",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountOut",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddLiqAmountsIn",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_availAmountA",
              "type": "uint256"
            },
            {
              "name": "_availAmountB",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRemoveLiqAmountsOut",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPrice",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_decimals",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPriceUnsafe",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_targetToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPriceUnsafe",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_targetToken",
              "type": "address"
            },
            {
              "name": "_appraiser",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositForYield",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositForYield",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawFromYield",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawFromYield",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_tokenInAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_tokenInAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmMintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmMintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_borrowAsset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_borrowAsset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_paymentAsset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_paymentAsset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimIncentives",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_proofs",
              "type": "bytes32[]"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimIncentives",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_proofs",
              "type": "bytes32[]"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAccessForLego",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_action",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "string"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "UNISWAP_V2_FACTORY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "UNISWAP_V2_ROUTER",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "RIPE_REGISTRY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "coreRouterPool",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_undyHq",
              "type": "address"
            },
            {
              "name": "_uniswapV2Factory",
              "type": "address"
            },
            {
              "name": "_uniswapV2Router",
              "type": "address"
            },
            {
              "name": "_coreRouterPool",
              "type": "address"
            },
            {
              "name": "_ripeRegistry",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "interfaces/WalletStructs.vyi": {
            "content": "# @version 0.4.3\n\nflag ActionType:\n    TRANSFER\n    EARN_DEPOSIT\n    EARN_WITHDRAW\n    EARN_REBALANCE\n    SWAP\n    MINT_REDEEM\n    CONFIRM_MINT_REDEEM\n    ADD_COLLATERAL\n    REMOVE_COLLATERAL\n    BORROW\n    REPAY_DEBT\n    REWARDS\n    ETH_TO_WETH\n    WETH_TO_ETH\n    ADD_LIQ\n    REMOVE_LIQ\n    ADD_LIQ_CONC\n    REMOVE_LIQ_CONC\n    PAY_CHEQUE\n\nstruct WalletAssetData:\n    assetBalance: uint256\n    usdValue: uint256\n    isYieldAsset: bool\n    lastPricePerShare: uint256\n\nstruct ActionData:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    billing: address\n    vaultRegistry: address\n    wallet: address\n    walletConfig: address\n    walletOwner: address\n    inEjectMode: bool\n    isFrozen: bool\n    lastTotalUsdValue: uint256\n    signer: address\n    isManager: bool\n    legoId: uint256\n    legoAddr: address\n    eth: address\n    weth: address\n\nstruct MiniAddys:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    appraiser: address",
            "sha256sum": "466493c129135c95470aaf70eeddc936632f7b0f813396e5a7ddc03bea9da518"
          },
          "interfaces/LegoPartner.vyi": {
            "content": "# @version 0.4.3\n\nfrom interfaces import WalletStructs as ws\n\nMAX_TOKEN_PATH: constant(uint256) = 5\nMAX_RECOVER_ASSETS: constant(uint256) = 20\nMAX_PROOFS: constant(uint256) = 25\n\n@external\ndef addLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _tickLower: int24, _tickUpper: int24, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef addLiquidity(_pool: address, _tokenA: address, _tokenB: address, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _minLpAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (address, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef removeLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _liqToRemove: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef removeLiquidity(_pool: address, _tokenA: address, _tokenB: address, _lpToken: address, _lpAmount: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef mintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _tokenInAmount: uint256, _minAmountOut: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef swapTokens(_amountIn: uint256, _minAmountOut: uint256, _tokenPath: DynArray[address, MAX_TOKEN_PATH], _poolPath: DynArray[address, MAX_TOKEN_PATH - 1], _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256):\n    ...\n\n@external\ndef depositForYield(_asset: address, _amount: uint256, _vaultAddr: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef withdrawFromYield(_vaultToken: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef confirmMintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef borrow(_borrowAsset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef repayDebt(_paymentAsset: address, _paymentAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef claimIncentives(_user: address, _rewardToken: address, _rewardAmount: uint256, _proofs: DynArray[bytes32, MAX_PROOFS], _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef removeCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef addCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@view\n@external\ndef getAccessForLego(_user: address, _action: ws.ActionType) -> (address, String[64], uint256):\n    ...\n\n@view\n@external\ndef hasCapability(_action: ws.ActionType) -> bool:\n    ...\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    ...\n\n@view\n@external\ndef isYieldLego() -> bool:\n    ...\n\n@view\n@external\ndef isDexLego() -> bool:\n    ...\n\n\n# common\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "f2afb7bd72d4301aea77bbe4177b7ae954ba6f6b76af363965993eb92ad0b715"
          },
          "interfaces/DexLego.vyi": {
            "content": "# @version 0.4.3\n\n# used in smart contracts\n\n\n@view\n@external\ndef getLpToken(_pool: address) -> address:\n    ...\n\n\n# helper functions for server\n\n\n@view\n@external\ndef getPoolForLpToken(_lpToken: address) -> address:\n    ...\n\n\n@view\n@external\ndef getSwapAmountOut(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n) -> uint256:\n    ...\n\n\n@view\n@external\ndef getSwapAmountIn(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountOut: uint256,\n) -> uint256:\n    ...\n\n\n@view\n@external\ndef getAddLiqAmountsIn(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _availAmountA: uint256,\n    _availAmountB: uint256,\n) -> (uint256, uint256, uint256):\n    ...\n\n\n@view\n@external\ndef getRemoveLiqAmountsOut(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpAmount: uint256,\n) -> (uint256, uint256):\n    ...\n\n\n@view\n@external\ndef getPriceUnsafe(_pool: address, _targetToken: address, _appraiser: address = empty(address)) -> uint256:\n    ...\n\n\n@view\n@external\ndef getBestSwapAmountOut(_tokenIn: address, _tokenOut: address, _amountIn: uint256) -> (address, uint256):\n    ...\n\n\n@view\n@external\ndef getBestSwapAmountIn(_tokenIn: address, _tokenOut: address, _amountOut: uint256) -> (address, uint256):\n    ...\n\n\n@view\n@external\ndef getCoreRouterPool() -> address:\n    ...\n\n\n@view\n@external\ndef getPrice(_asset: address, _decimals: uint256) -> uint256:\n    ...\n",
            "sha256sum": "6248ad46926f00481cb3469bfc7af8fe36669c2ca0dd98e9a0befdda0fc43fd7"
          },
          "contracts/modules/Addys.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\ninterface UndyHq:\n    def isValidAddr(_addr: address) -> bool: view\n    def getAddr(_regId: uint256) -> address: view\n    def undyToken() -> address: view\n\ninterface Switchboard:\n    def isSwitchboardAddr(_addr: address) -> bool: view\n\ninterface LegoBook:\n    def isLegoAddr(_addr: address) -> bool: view\n\nstruct Addys:\n    hq: address\n    undyToken: address\n    ledger: address\n    missionControl: address\n    legoBook: address\n    switchboard: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    walletBackpack: address\n    billing: address\n    vaultRegistry: address\n\n# hq\nUNDY_HQ_FOR_ADDYS: immutable(address)\n\n# core addys\nLEDGER_ID: constant(uint256) = 1\nMISSION_CONTROL_ID: constant(uint256) = 2\nLEGO_BOOK_ID: constant(uint256) = 3\nSWITCHBOARD_ID: constant(uint256) = 4\nHATCHERY_ID: constant(uint256) = 5\nLOOT_DISTRIBUTOR_ID: constant(uint256) = 6\nAPPRAISER_ID: constant(uint256) = 7\nWALLET_BACKPACK_ID: constant(uint256) = 8\nBILLING_ID: constant(uint256) = 9\nVAULT_REGISTRY_ID: constant(uint256) = 10\n\n\n@deploy\ndef __init__(_undyHq: address):\n    assert _undyHq != empty(address) # dev: invalid undy hq\n    UNDY_HQ_FOR_ADDYS = _undyHq\n\n\n########\n# Core #\n########\n\n\n@view\n@external\ndef getAddys() -> Addys:\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _getAddys(_addys: Addys = empty(Addys)) -> Addys:\n    if _addys.hq != empty(address):\n        return _addys\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _generateAddys() -> Addys:\n    hq: address = UNDY_HQ_FOR_ADDYS\n    return Addys(\n        hq = hq,\n        undyToken = staticcall UndyHq(hq).undyToken(),\n        ledger = staticcall UndyHq(hq).getAddr(LEDGER_ID),\n        missionControl = staticcall UndyHq(hq).getAddr(MISSION_CONTROL_ID),\n        legoBook = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID),\n        switchboard = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID),\n        hatchery = staticcall UndyHq(hq).getAddr(HATCHERY_ID),\n        lootDistributor = staticcall UndyHq(hq).getAddr(LOOT_DISTRIBUTOR_ID),\n        appraiser = staticcall UndyHq(hq).getAddr(APPRAISER_ID),\n        walletBackpack = staticcall UndyHq(hq).getAddr(WALLET_BACKPACK_ID),\n        billing = staticcall UndyHq(hq).getAddr(BILLING_ID),\n        vaultRegistry = staticcall UndyHq(hq).getAddr(VAULT_REGISTRY_ID),\n    )\n\n\n##########\n# Tokens #\n##########\n\n\n@view\n@internal\ndef _getUndyToken() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).undyToken()\n\n\n###########\n# Helpers #\n###########\n\n\n# undy hq\n\n\n@view\n@external\ndef getUndyHq() -> address:\n    return self._getUndyHq()\n\n\n@view\n@internal\ndef _getUndyHq() -> address:\n    return UNDY_HQ_FOR_ADDYS\n\n\n# utils\n\n\n@view\n@internal\ndef _isValidUndyAddr(_addr: address, _hq: address = empty(address)) -> bool:\n    hq: address = _hq\n    if _hq == empty(address):\n        hq = UNDY_HQ_FOR_ADDYS\n    \n    # core departments\n    if staticcall UndyHq(hq).isValidAddr(_addr):\n        return True\n\n    # lego book\n    legoBook: address = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID)\n    if legoBook != empty(address) and staticcall LegoBook(legoBook).isLegoAddr(_addr):\n        return True\n\n    # switchboard config\n    switchboard: address = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID)\n    if switchboard != empty(address) and staticcall Switchboard(switchboard).isSwitchboardAddr(_addr):\n        return True\n\n    return False\n\n\n@view\n@internal\ndef _isSwitchboardAddr(_addr: address) -> bool:\n    switchboard: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n    if switchboard == empty(address):\n        return False\n    return staticcall Switchboard(switchboard).isSwitchboardAddr(_addr)\n\n\n@view\n@internal\ndef _isLegoBookAddr(_addr: address) -> bool:\n    legoBook: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n    if legoBook == empty(address):\n        return False\n    return staticcall LegoBook(legoBook).isLegoAddr(_addr)\n\n\n###############\n# Departments #\n###############\n\n\n# ledger\n\n\n@view\n@internal\ndef _getLedgerId() -> uint256:\n    return LEDGER_ID\n\n\n@view\n@internal\ndef _getLedgerAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEDGER_ID)\n\n\n# mission control\n\n\n@view\n@internal\ndef _getMissionControlId() -> uint256:\n    return MISSION_CONTROL_ID\n\n\n@view\n@internal\ndef _getMissionControlAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(MISSION_CONTROL_ID)\n\n\n# lego book\n\n\n@view\n@internal\ndef _getLegoBookId() -> uint256:\n    return LEGO_BOOK_ID\n\n\n@view\n@internal\ndef _getLegoBookAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n\n\n# switchboard\n\n\n@view\n@internal\ndef _getSwitchboardId() -> uint256:\n    return SWITCHBOARD_ID\n\n\n@view\n@internal\ndef _getSwitchboardAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n\n\n# hatchery\n\n\n@view\n@internal\ndef _getHatcheryId() -> uint256:\n    return HATCHERY_ID\n\n\n@view\n@internal\ndef _getHatcheryAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(HATCHERY_ID)\n\n\n# loot distributor\n\n\n@view\n@internal\ndef _getLootDistributorId() -> uint256:\n    return LOOT_DISTRIBUTOR_ID\n\n\n@view\n@internal\ndef _getLootDistributorAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LOOT_DISTRIBUTOR_ID)\n\n\n# appraiser\n\n\n@view\n@internal\ndef _getAppraiserId() -> uint256:\n    return APPRAISER_ID\n\n\n@view\n@internal\ndef _getAppraiserAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(APPRAISER_ID)\n\n\n# wallet backpack\n\n\n@view\n@internal\ndef _getWalletBackpackId() -> uint256:\n    return WALLET_BACKPACK_ID\n\n\n@view\n@internal\ndef _getWalletBackpackAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(WALLET_BACKPACK_ID)\n\n\n# billing\n\n\n@view\n@internal\ndef _getBillingId() -> uint256:\n    return BILLING_ID\n\n\n@view\n@internal\ndef _getBillingAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(BILLING_ID)\n\n\n# vault registry\n\n\n@view\n@internal\ndef _getVaultRegistryId() -> uint256:\n    return VAULT_REGISTRY_ID\n\n\n@view\n@internal\ndef _getVaultRegistryAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(VAULT_REGISTRY_ID)",
            "sha256sum": "4df6b72db9bb417d1af81660175be1450cfb7b3575f3d17a5b8a130bff87b781"
          },
          "contracts/modules/DexLegoData.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nuses: addys\n\nimport contracts.modules.Addys as addys\n\nfrom interfaces import WalletStructs as ws\nfrom ethereum.ercs import IERC20\n\nevent LegoPauseModified:\n    isPaused: bool\n\nevent LegoFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    balance: uint256\n\n# config\nlegoId: public(uint256)\nisPaused: public(bool)\n\nMAX_RECOVER_ASSETS: constant(uint256) = 20\n\n\n@deploy\ndef __init__(_shouldPause: bool):\n    self.isPaused = _shouldPause\n\n\n###########\n# General #\n###########\n\n\n# fill mini addys\n\n\n@view\n@internal\ndef _getMiniAddys(_miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> ws.MiniAddys:\n    if _miniAddys.ledger != empty(address):\n        return _miniAddys\n    return ws.MiniAddys(\n        ledger = addys._getLedgerAddr(),\n        missionControl = addys._getMissionControlAddr(),\n        legoBook = addys._getLegoBookAddr(),\n        appraiser = addys._getAppraiserAddr(),\n    )\n\n\n# activate\n\n\n@external\ndef pause(_shouldPause: bool):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert _shouldPause != self.isPaused # dev: no change\n    self.isPaused = _shouldPause\n    log LegoPauseModified(isPaused=_shouldPause)\n\n\n# recover funds\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    self._recoverFunds(_recipient, _asset)\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, MAX_RECOVER_ASSETS]):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    for a: address in _assets:\n        self._recoverFunds(_recipient, a)\n\n\n@internal\ndef _recoverFunds(_recipient: address, _asset: address):\n    assert empty(address) not in [_recipient, _asset] # dev: invalid recipient or asset\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    assert balance != 0 # dev: nothing to recover\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log LegoFundsRecovered(asset=_asset, recipient=_recipient, balance=balance)",
            "sha256sum": "75b15af2475ab409d4b5fd057509d14c20564ebd7fcb0850e3b61397d8e3af48"
          },
          "contracts/legos/dexes/UniswapV2.vy": {
            "content": "#     _____  _____  __  __    ____   _____  _____  _____ \n#    |  _  \\/   __\\/  \\/  \\  /  _/  /   __\\/   __\\/  _  \\\n#    |  |  ||   __|>-    -<  |  |---|   __||  |_ ||  |  |\n#    |_____/\\_____/\\__/\\__/  \\_____/\\_____/\\_____/\\_____/\n#                                                                       \n#     \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n#     \u2551  ** Uniswap V2 Lego **           \u2551\n#     \u2551  Integration with Uniswap V2.    \u2551\n#     \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n#\n#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nimplements: Lego\nimplements: DexLego\n\nexports: addys.__interface__\nexports: dld.__interface__\n\ninitializes: addys\ninitializes: dld[addys := addys]\n\nfrom interfaces import LegoPartner as Lego\nfrom interfaces import DexLego as DexLego\nfrom interfaces import WalletStructs as ws\n\nimport contracts.modules.Addys as addys\nimport contracts.modules.DexLegoData as dld\n\nfrom ethereum.ercs import IERC20\nfrom ethereum.ercs import IERC20Detailed\n\ninterface IUniswapV2Pair:\n    def swap(_amount0Out: uint256, _amount1Out: uint256, _recipient: address, _data: Bytes[256]): nonpayable\n    def getReserves() -> (uint112, uint112, uint32): view\n    def token0() -> address: view\n    def token1() -> address: view\n\ninterface Appraiser:\n    def getUsdValue(_asset: address, _amount: uint256, _missionControl: address = empty(address), _legoBook: address = empty(address), _ledger: address = empty(address)) -> uint256: view\n    def getRipePrice(_asset: address) -> uint256: view\n\ninterface UniV2Router:\n    def addLiquidity(_tokenA: address, _tokenB: address, _amountADesired: uint256, _amountBDesired: uint256, _amountAMin: uint256, _amountBMin: uint256, _recipient: address, _deadline: uint256) -> (uint256, uint256, uint256): nonpayable\n    def removeLiquidity(_tokenA: address, _tokenB: address, _lpAmount: uint256, _amountAMin: uint256, _amountBMin: uint256, _recipient: address, _deadline: uint256) -> (uint256, uint256): nonpayable\n\ninterface UniV2Factory:\n    def getPair(_tokenA: address, _tokenB: address) -> address: view\n\ninterface Ledger:\n    def isUserWallet(_user: address) -> bool: view\n\ninterface VaultRegistry:\n    def isEarnVault(_vaultAddr: address) -> bool: view\n\ninterface Registry:\n    def isValidAddr(_addr: address) -> bool: view\n\nstruct BestPool:\n    pool: address\n    fee: uint256\n    liquidity: uint256\n    numCoins: uint256\n\nevent UniswapV2Swap:\n    sender: indexed(address)\n    tokenIn: indexed(address)\n    tokenOut: indexed(address)\n    amountIn: uint256\n    amountOut: uint256\n    usdValue: uint256\n    numTokens: uint256\n    recipient: address\n\nevent UniswapV2LiquidityAdded:\n    sender: indexed(address)\n    tokenA: indexed(address)\n    tokenB: indexed(address)\n    amountA: uint256\n    amountB: uint256\n    lpAmountReceived: uint256\n    usdValue: uint256\n    recipient: address\n\nevent UniswapV2LiquidityRemoved:\n    sender: address\n    pool: indexed(address)\n    tokenA: indexed(address)\n    tokenB: indexed(address)\n    amountA: uint256\n    amountB: uint256\n    lpToken: address\n    lpAmountBurned: uint256\n    usdValue: uint256\n    recipient: address\n\n# uniswap v2\nUNISWAP_V2_FACTORY: public(immutable(address))\nUNISWAP_V2_ROUTER: public(immutable(address))\nRIPE_REGISTRY: public(immutable(address))\ncoreRouterPool: public(address)\n\nEIGHTEEN_DECIMALS: constant(uint256) = 10 ** 18\nMAX_TOKEN_PATH: constant(uint256) = 5\nMAX_PROOFS: constant(uint256) = 25\n\n\n@deploy\ndef __init__(\n    _undyHq: address,\n    _uniswapV2Factory: address,\n    _uniswapV2Router: address,\n    _coreRouterPool: address,\n    _ripeRegistry: address,\n):\n    addys.__init__(_undyHq)\n    dld.__init__(False)\n\n    assert empty(address) not in [_uniswapV2Factory, _uniswapV2Router, _coreRouterPool, _ripeRegistry] # dev: invalid addrs\n    UNISWAP_V2_FACTORY = _uniswapV2Factory\n    UNISWAP_V2_ROUTER = _uniswapV2Router\n    RIPE_REGISTRY = _ripeRegistry\n    self.coreRouterPool = _coreRouterPool\n\n\n@view\n@external\ndef hasCapability(_action: ws.ActionType) -> bool:\n    return _action in (\n        ws.ActionType.SWAP |\n        ws.ActionType.ADD_LIQ | \n        ws.ActionType.REMOVE_LIQ\n    )\n\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    return [UNISWAP_V2_FACTORY, UNISWAP_V2_ROUTER]\n\n\n@view\n@external\ndef isYieldLego() -> bool:\n    return False\n\n\n@view\n@external\ndef isDexLego() -> bool:\n    return True\n\n\n@view\n@internal\ndef _isAllowedToPerformAction(_caller: address) -> bool:\n    if staticcall VaultRegistry(addys._getVaultRegistryAddr()).isEarnVault(_caller):\n        return True\n    if staticcall Ledger(addys._getLedgerAddr()).isUserWallet(_caller):\n        return True\n    return staticcall Registry(RIPE_REGISTRY).isValidAddr(_caller)\n\n\n#########\n# Swaps #\n#########\n\n\n@external\ndef swapTokens(\n    _amountIn: uint256,\n    _minAmountOut: uint256,\n    _tokenPath: DynArray[address, MAX_TOKEN_PATH],\n    _poolPath: DynArray[address, MAX_TOKEN_PATH - 1],\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256):\n    assert not dld.isPaused # dev: paused\n    assert self._isAllowedToPerformAction(msg.sender) # dev: no perms\n    miniAddys: ws.MiniAddys = dld._getMiniAddys(_miniAddys)\n\n    # validate inputs\n    numTokens: uint256 = len(_tokenPath)\n    numPools: uint256 = len(_poolPath)\n    assert numTokens >= 2 # dev: invalid path\n    assert numPools == numTokens - 1 # dev: invalid path\n\n    # get first token and last token\n    tokenIn: address = _tokenPath[0]\n    tokenOut: address = _tokenPath[numTokens - 1]\n\n    # pre balances\n    preLegoBalance: uint256 = staticcall IERC20(tokenIn).balanceOf(self)\n\n    # transfer deposit asset to this contract\n    amountIn: uint256 = min(_amountIn, staticcall IERC20(tokenIn).balanceOf(msg.sender))\n    assert amountIn != 0 # dev: nothing to transfer\n    assert extcall IERC20(tokenIn).transferFrom(msg.sender, self, amountIn, default_return_value=True) # dev: transfer failed\n\n    # adjust min amount out\n    minAmountOut: uint256 = _minAmountOut\n    if amountIn < _amountIn and _amountIn != max_value(uint256):\n        minAmountOut = _minAmountOut * amountIn // _amountIn\n\n    # transfer initial amount to first pool\n    assert extcall IERC20(tokenIn).transfer(_poolPath[0], amountIn, default_return_value=True) # dev: transfer failed\n\n    # iterate through swap routes\n    tempAmountIn: uint256 = amountIn\n    uniswapV2Factory: address = UNISWAP_V2_FACTORY\n    for i: uint256 in range(numTokens - 1, bound=MAX_TOKEN_PATH):\n        tempTokenIn: address = _tokenPath[i]\n        tempTokenOut: address = _tokenPath[i + 1]\n        tempPool: address = _poolPath[i]\n\n        # transfer to next pool (or to recipient if last swap)\n        recipient: address = _recipient\n        if i < numTokens - 2:\n            recipient = _poolPath[i + 1]\n\n        # swap\n        tempAmountIn = self._swapTokensInPool(tempPool, tempTokenIn, tempTokenOut, tempAmountIn, recipient, uniswapV2Factory)\n\n    # final amount\n    amountOut: uint256 = tempAmountIn\n    assert amountOut >= minAmountOut # dev: min amount out not met\n\n    # refund if full swap didn't get through\n    currentLegoBalance: uint256 = staticcall IERC20(tokenIn).balanceOf(self)\n    refundAssetAmount: uint256 = 0\n    if currentLegoBalance > preLegoBalance:\n        refundAssetAmount = currentLegoBalance - preLegoBalance\n        assert extcall IERC20(tokenIn).transfer(msg.sender, refundAssetAmount, default_return_value=True) # dev: transfer failed\n        amountIn -= refundAssetAmount\n\n    # get usd values\n    usdValue: uint256 = staticcall Appraiser(miniAddys.appraiser).getUsdValue(tokenIn, amountIn, miniAddys.missionControl, miniAddys.legoBook, miniAddys.ledger)\n    if usdValue == 0:\n        usdValue = staticcall Appraiser(miniAddys.appraiser).getUsdValue(tokenOut, amountOut, miniAddys.missionControl, miniAddys.legoBook, miniAddys.ledger)\n\n    log UniswapV2Swap(\n        sender = msg.sender,\n        tokenIn = tokenIn,\n        tokenOut = tokenOut,\n        amountIn = amountIn,\n        amountOut = amountOut,\n        usdValue = usdValue,\n        numTokens = numTokens,\n        recipient = _recipient,\n    )\n    return amountIn, amountOut, usdValue\n\n\n# swap in pool\n\n\n@internal\ndef _swapTokensInPool(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n    _recipient: address,\n    _uniswapV2Factory: address,\n) -> uint256:\n    tokens: address[2] = [staticcall IUniswapV2Pair(_pool).token0(), staticcall IUniswapV2Pair(_pool).token1()]\n    assert _tokenIn in tokens # dev: invalid tokenIn\n    assert _tokenOut in tokens # dev: invalid tokenOut\n    assert _tokenIn != _tokenOut # dev: invalid tokens\n\n    # verify actual uniswap v2 pool\n    assert staticcall UniV2Factory(_uniswapV2Factory).getPair(_tokenIn, _tokenOut) == _pool # dev: invalid pool\n\n    zeroForOne: bool = _tokenIn == tokens[0]\n    amountOut: uint256 = self._getAmountOut(_pool, zeroForOne, _amountIn)\n    assert amountOut != 0 # dev: no tokens swapped\n\n    # put in correct order\n    amount0Out: uint256 = amountOut\n    amount1Out: uint256 = 0\n    if zeroForOne:\n        amount0Out = 0\n        amount1Out = amountOut\n\n    # perform swap\n    extcall IUniswapV2Pair(_pool).swap(amount0Out, amount1Out, _recipient, b\"\")\n    return amountOut\n\n\n#############\n# Liquidity #\n#############\n\n\n# add liquidity\n\n\n@external\ndef addLiquidity(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _amountA: uint256,\n    _amountB: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _minLpAmount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (address, uint256, uint256, uint256, uint256):\n    assert not dld.isPaused # dev: paused\n    assert self._isAllowedToPerformAction(msg.sender) # dev: no perms\n    miniAddys: ws.MiniAddys = dld._getMiniAddys(_miniAddys)\n\n    # validate tokens\n    tokens: address[2] = [staticcall IUniswapV2Pair(_pool).token0(), staticcall IUniswapV2Pair(_pool).token1()]\n    assert _tokenA in tokens # dev: invalid tokenA\n    assert _tokenB in tokens # dev: invalid tokenB\n    assert _tokenA != _tokenB # dev: invalid tokens\n\n    # pre balances\n    preLegoBalanceA: uint256 = staticcall IERC20(_tokenA).balanceOf(self)\n    preLegoBalanceB: uint256 = staticcall IERC20(_tokenB).balanceOf(self)\n\n    # token a\n    liqAmountA: uint256 = min(_amountA, staticcall IERC20(_tokenA).balanceOf(msg.sender))\n    assert liqAmountA != 0 # dev: nothing to transfer\n    assert extcall IERC20(_tokenA).transferFrom(msg.sender, self, liqAmountA, default_return_value=True) # dev: transfer failed\n\n    # token b\n    liqAmountB: uint256 = min(_amountB, staticcall IERC20(_tokenB).balanceOf(msg.sender))\n    assert liqAmountB != 0 # dev: nothing to transfer\n    assert extcall IERC20(_tokenB).transferFrom(msg.sender, self, liqAmountB, default_return_value=True) # dev: transfer failed\n\n    # approvals\n    router: address = UNISWAP_V2_ROUTER\n    assert extcall IERC20(_tokenA).approve(router, liqAmountA, default_return_value=True) # dev: approval failed\n    assert extcall IERC20(_tokenB).approve(router, liqAmountB, default_return_value=True) # dev: approval failed\n\n    # add liquidity\n    lpAmountReceived: uint256 = 0\n    liqAmountA, liqAmountB, lpAmountReceived = extcall UniV2Router(router).addLiquidity(\n        _tokenA,\n        _tokenB,\n        liqAmountA,\n        liqAmountB,\n        _minAmountA,\n        _minAmountB,\n        _recipient,\n        block.timestamp,\n    )\n    assert lpAmountReceived != 0 # dev: no liquidity added\n\n    # reset approvals\n    assert extcall IERC20(_tokenA).approve(router, 0, default_return_value=True) # dev: approval failed\n    assert extcall IERC20(_tokenB).approve(router, 0, default_return_value=True) # dev: approval failed\n\n    # refund if full liquidity was not added\n    currentLegoBalanceA: uint256 = staticcall IERC20(_tokenA).balanceOf(self)\n    refundAssetAmountA: uint256 = 0\n    if currentLegoBalanceA > preLegoBalanceA:\n        refundAssetAmountA = currentLegoBalanceA - preLegoBalanceA\n        assert extcall IERC20(_tokenA).transfer(msg.sender, refundAssetAmountA, default_return_value=True) # dev: transfer failed\n\n    currentLegoBalanceB: uint256 = staticcall IERC20(_tokenB).balanceOf(self)\n    refundAssetAmountB: uint256 = 0\n    if currentLegoBalanceB > preLegoBalanceB:\n        refundAssetAmountB = currentLegoBalanceB - preLegoBalanceB\n        assert extcall IERC20(_tokenB).transfer(msg.sender, refundAssetAmountB, default_return_value=True) # dev: transfer failed\n\n    usdValue: uint256 = self._getUsdValue(_tokenA, liqAmountA, _tokenB, liqAmountB, miniAddys)\n    log UniswapV2LiquidityAdded(\n        sender = msg.sender,\n        tokenA = _tokenA,\n        tokenB = _tokenB,\n        amountA = liqAmountA,\n        amountB = liqAmountB,\n        lpAmountReceived = lpAmountReceived,\n        usdValue = usdValue,\n        recipient = _recipient,\n    )\n    return _pool, lpAmountReceived, liqAmountA, liqAmountB, usdValue\n\n\n# remove liquidity\n\n\n@external\ndef removeLiquidity(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpToken: address,\n    _lpAmount: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, uint256):\n    assert not dld.isPaused # dev: paused\n    assert self._isAllowedToPerformAction(msg.sender) # dev: no perms\n    miniAddys: ws.MiniAddys = dld._getMiniAddys(_miniAddys)\n\n    # validate tokens\n    tokens: address[2] = [staticcall IUniswapV2Pair(_pool).token0(), staticcall IUniswapV2Pair(_pool).token1()]\n    assert _tokenA in tokens # dev: invalid tokenA\n    assert _tokenB in tokens # dev: invalid tokenB\n    assert _tokenA != _tokenB # dev: invalid tokens\n\n    # pre balance\n    preLegoBalance: uint256 = staticcall IERC20(_lpToken).balanceOf(self)\n\n    # lp token\n    lpAmount: uint256 = min(_lpAmount, staticcall IERC20(_lpToken).balanceOf(msg.sender))\n    assert lpAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_lpToken).transferFrom(msg.sender, self, lpAmount, default_return_value=True) # dev: transfer failed\n\n    # approvals\n    router: address = UNISWAP_V2_ROUTER\n    assert extcall IERC20(_lpToken).approve(router, lpAmount, default_return_value=True) # dev: approval failed\n\n    # remove liquidity\n    amountA: uint256 = 0\n    amountB: uint256 = 0\n    amountA, amountB = extcall UniV2Router(router).removeLiquidity(\n        _tokenA,\n        _tokenB,\n        lpAmount,\n        _minAmountA,\n        _minAmountB,\n        _recipient,\n        block.timestamp,\n    )\n    assert amountA != 0 # dev: no amountA removed\n    assert amountB != 0 # dev: no amountB removed\n\n    # reset approvals\n    assert extcall IERC20(_lpToken).approve(router, 0, default_return_value=True) # dev: approval failed\n\n    # refund if full liquidity was not removed\n    currentLegoBalance: uint256 = staticcall IERC20(_lpToken).balanceOf(self)\n    refundedLpAmount: uint256 = 0\n    if currentLegoBalance > preLegoBalance:\n        refundedLpAmount = currentLegoBalance - preLegoBalance\n        assert extcall IERC20(_lpToken).transfer(msg.sender, refundedLpAmount, default_return_value=True) # dev: transfer failed\n        lpAmount -= refundedLpAmount\n\n    usdValue: uint256 = self._getUsdValue(_tokenA, amountA, _tokenB, amountB, miniAddys)\n    log UniswapV2LiquidityRemoved(\n        sender = msg.sender,\n        pool = _pool,\n        tokenA = _tokenA,\n        tokenB = _tokenB,\n        amountA = amountA,\n        amountB = amountB,\n        lpToken = _lpToken,\n        lpAmountBurned = lpAmount,\n        usdValue = usdValue,\n        recipient = _recipient,\n    )\n    return amountA, amountB, lpAmount, usdValue\n\n\n# get usd value on liquidity actions\n\n\n@internal\ndef _getUsdValue(\n    _tokenA: address,\n    _amountA: uint256,\n    _tokenB: address,\n    _amountB: uint256,\n    _miniAddys: ws.MiniAddys,\n) -> uint256:\n\n    usdValueA: uint256 = 0\n    if _amountA != 0:\n        usdValueA = staticcall Appraiser(_miniAddys.appraiser).getUsdValue(_tokenA, _amountA, _miniAddys.missionControl, _miniAddys.legoBook, _miniAddys.ledger)\n\n    usdValueB: uint256 = 0\n    if _amountB != 0:\n        usdValueB = staticcall Appraiser(_miniAddys.appraiser).getUsdValue(_tokenB, _amountB, _miniAddys.missionControl, _miniAddys.legoBook, _miniAddys.ledger)\n\n    return usdValueA + usdValueB\n\n\n#############\n# Utilities #\n#############\n\n\n@view\n@external\ndef getLpToken(_pool: address) -> address:\n    # in uniswap v2, the lp token is the pool address\n    return _pool\n\n\n@view\n@external\ndef getPoolForLpToken(_lpToken: address) -> address:\n    # in uniswap v2, the pool is the lp token address\n    return _lpToken\n\n\n@view\n@external\ndef getCoreRouterPool() -> address:\n    return self.coreRouterPool\n\n\n@view\n@external\ndef getDeepestLiqPool(_tokenA: address, _tokenB: address) -> BestPool:\n    pool: address = staticcall UniV2Factory(UNISWAP_V2_FACTORY).getPair(_tokenA, _tokenB)\n    if pool == empty(address):\n        return empty(BestPool)\n\n    # get reserves\n    reserve0: uint112 = 0\n    reserve1: uint112 = 0\n    na: uint32 = 0\n    reserve0, reserve1, na = staticcall IUniswapV2Pair(pool).getReserves()\n\n    return BestPool(\n        pool=pool,\n        fee=30, # 0.3%, denominator is 100_00\n        liquidity=convert(reserve0 + reserve1, uint256),\n        numCoins=2,\n    )\n\n\n@view\n@external\ndef getBestSwapAmountOut(_tokenIn: address, _tokenOut: address, _amountIn: uint256) -> (address, uint256):\n    pool: address = staticcall UniV2Factory(UNISWAP_V2_FACTORY).getPair(_tokenIn, _tokenOut)\n    if pool == empty(address):\n        return empty(address), 0\n    token0: address = staticcall IUniswapV2Pair(pool).token0()\n    return pool, self._getAmountOut(pool, _tokenIn == token0, _amountIn)\n\n\n@view\n@external\ndef getSwapAmountOut(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n) -> uint256:\n    token0: address = staticcall IUniswapV2Pair(_pool).token0()\n    return self._getAmountOut(_pool, _tokenIn == token0, _amountIn)\n\n\n@view\n@external\ndef getBestSwapAmountIn(_tokenIn: address, _tokenOut: address, _amountOut: uint256) -> (address, uint256):\n    pool: address = staticcall UniV2Factory(UNISWAP_V2_FACTORY).getPair(_tokenIn, _tokenOut)\n    if pool == empty(address):\n        return empty(address), 0\n    token0: address = staticcall IUniswapV2Pair(pool).token0()\n    return pool, self._getAmountIn(pool, _tokenIn == token0, _amountOut)\n\n\n@view\n@external\ndef getSwapAmountIn(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountOut: uint256,\n) -> uint256:\n    token0: address = staticcall IUniswapV2Pair(_pool).token0()\n    return self._getAmountIn(_pool, _tokenIn == token0, _amountOut)\n\n\n@view\n@external\ndef getAddLiqAmountsIn(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _availAmountA: uint256,\n    _availAmountB: uint256,\n) -> (uint256, uint256, uint256):\n    token0: address = staticcall IUniswapV2Pair(_pool).token0()\n\n    reserveA: uint256 = 0\n    reserveB: uint256 = 0\n    reserveA, reserveB = self._getReserves(_pool, _tokenA == token0)\n\n    # insufficient liquidity\n    if reserveA == 0 or reserveB == 0:\n        return 0, 0, 0\n\n    # calculate optimal amounts\n    amountA: uint256 = _availAmountA\n    amountB: uint256 = self._quote(_availAmountA, reserveA, reserveB)\n    if amountB > _availAmountB:\n        maybeAmountA: uint256 = self._quote(_availAmountB, reserveB, reserveA)\n        if maybeAmountA <= _availAmountA:\n            amountA = maybeAmountA\n            amountB = _availAmountB\n    return amountA, amountB, 0\n\n\n@view\n@external\ndef getRemoveLiqAmountsOut(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpAmount: uint256,\n) -> (uint256, uint256):\n    token0: address = staticcall IUniswapV2Pair(_pool).token0()\n\n    reserveA: uint256 = 0\n    reserveB: uint256 = 0\n    reserveA, reserveB = self._getReserves(_pool, _tokenA == token0)\n\n    # insufficient liquidity\n    if reserveA == 0 or reserveB == 0:\n        return max_value(uint256), max_value(uint256)\n\n    # calculate expected amounts out\n    totalSupply: uint256 = staticcall IERC20(_pool).totalSupply()\n    expectedAmountA: uint256 = _lpAmount * reserveA // totalSupply\n    expectedAmountB: uint256 = _lpAmount * reserveB // totalSupply\n    return expectedAmountA, expectedAmountB\n\n\n@view\n@external\ndef getPrice(_asset: address, _decimals: uint256) -> uint256:\n    return 0 # TODO: implement price\n\n\n@view\n@external\ndef getPriceUnsafe(_pool: address, _targetToken: address, _appraiser: address = empty(address)) -> uint256:\n    token0: address = staticcall IUniswapV2Pair(_pool).token0()\n    token1: address = staticcall IUniswapV2Pair(_pool).token1()\n\n    # appraiser\n    appraiser: address = _appraiser\n    if _appraiser == empty(address):\n        appraiser = addys._getAppraiserAddr()\n\n    # alt price\n    altPrice: uint256 = 0\n    if _targetToken == token0:\n        altPrice = staticcall Appraiser(appraiser).getRipePrice(token1)\n    else:\n        altPrice = staticcall Appraiser(appraiser).getRipePrice(token0)\n\n    # return early if no alt price\n    if altPrice == 0:\n        return 0\n\n    # reserves\n    reserve0: uint112 = 0\n    reserve1: uint112 = 0\n    na: uint32 = 0\n    reserve0, reserve1, na = staticcall IUniswapV2Pair(_pool).getReserves()\n\n    # avoid division by zero\n    if reserve0 == 0 or reserve1 == 0:\n        return 0  \n\n    # price of token0 in token1\n    priceZeroToOne: uint256 = convert(reserve1, uint256) * EIGHTEEN_DECIMALS // convert(reserve0, uint256)\n\n    # adjust for decimals: price should be in 18 decimals\n    decimals0: uint256 = convert(staticcall IERC20Detailed(token0).decimals(), uint256)\n    decimals1: uint256 = convert(staticcall IERC20Detailed(token1).decimals(), uint256)\n    if decimals0 > decimals1:\n        scaleFactor: uint256 = 10 ** (decimals0 - decimals1)\n        priceZeroToOne = priceZeroToOne * scaleFactor\n    elif decimals1 > decimals0:\n        scaleFactor: uint256 = 10 ** (decimals1 - decimals0)\n        priceZeroToOne = priceZeroToOne // scaleFactor\n\n    # if _targetToken is token1, make price inverse\n    priceToOther: uint256 = priceZeroToOne\n    if _targetToken == token1:\n        priceToOther = EIGHTEEN_DECIMALS * EIGHTEEN_DECIMALS // priceZeroToOne\n\n    return altPrice * priceToOther // EIGHTEEN_DECIMALS\n\n\n# internal utils\n\n\n@view\n@internal\ndef _quote(_amountA: uint256, _reserveA: uint256, _reserveB: uint256) -> uint256:\n    return (_amountA * _reserveB) // _reserveA\n\n\n@view\n@internal\ndef _getReserves(_pool: address, _isTokenAZeroIndex: bool) -> (uint256, uint256):\n    reserve0: uint112 = 0\n    reserve1: uint112 = 0\n    na: uint32 = 0\n    reserve0, reserve1, na = staticcall IUniswapV2Pair(_pool).getReserves()\n\n    # determine which token is which\n    reserveA: uint256 = convert(reserve0, uint256)\n    reserveB: uint256 = convert(reserve1, uint256)\n    if not _isTokenAZeroIndex:\n        reserveA = convert(reserve1, uint256)\n        reserveB = convert(reserve0, uint256)\n\n    return reserveA, reserveB\n\n\n@view\n@internal\ndef _getAmountOut(\n    _pool: address,\n    _zeroForOne: bool,\n    _amountIn: uint256,\n) -> uint256:\n    if _amountIn == 0:\n        return 0\n\n    # get reserves\n    reserveIn: uint256 = 0\n    reserveOut: uint256 = 0\n    reserveIn, reserveOut = self._getReserves(_pool, _zeroForOne)\n    if reserveIn == 0 or reserveOut == 0:\n        return 0\n\n    # calculate amount out\n    amountInWithFee: uint256 = _amountIn * 997 # 1000 - 3 (0.3% fee)\n    numerator: uint256 = amountInWithFee * reserveOut\n    denominator: uint256 = (reserveIn * 1000) + amountInWithFee\n    return numerator // denominator\n\n\n@view\n@internal\ndef _getAmountIn(_pool: address, _zeroForOne: bool, _amountOut: uint256) -> uint256:\n    if _amountOut == 0 or _amountOut == max_value(uint256):\n        return max_value(uint256)\n\n    reserveIn: uint256 = 0\n    reserveOut: uint256 = 0\n    reserveIn, reserveOut = self._getReserves(_pool, _zeroForOne)\n    if reserveIn == 0 or reserveOut == 0:\n        return max_value(uint256)\n\n    # prevent division by zero: if _amountOut == reserveOut,\n    if _amountOut >= reserveOut:\n        return max_value(uint256)\n\n    numerator: uint256 = reserveIn * _amountOut * 1000\n    denominator: uint256 = (reserveOut - _amountOut) * 997\n    return (numerator // denominator) + 1\n\n\n#########\n# Other #\n#########\n\n\n@external\ndef depositForYield(\n    _asset: address,\n    _amount: uint256,\n    _vaultAddr: address,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, address, uint256, uint256):\n    return 0, empty(address), 0, 0\n\n\n@external\ndef withdrawFromYield(\n    _vaultToken: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, address, uint256, uint256):\n    return 0, empty(address), 0, 0\n\n\n@external\ndef mintOrRedeemAsset(\n    _tokenIn: address,\n    _tokenOut: address,\n    _tokenInAmount: uint256,\n    _minAmountOut: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, bool, uint256):\n    return 0, 0, False, 0\n\n\n@external\ndef confirmMintOrRedeemAsset(\n    _tokenIn: address,\n    _tokenOut: address,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef addCollateral(\n    _asset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef removeCollateral(\n    _asset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef borrow(\n    _borrowAsset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef repayDebt(\n    _paymentAsset: address,\n    _paymentAmount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef claimRewards(\n    _user: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _extraData: bytes32,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    # backwards compatibility\n    return 0, 0\n\n\n@external\ndef claimIncentives(\n    _user: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _proofs: DynArray[bytes32, MAX_PROOFS],\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef addLiquidityConcentrated(\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _tickLower: int24,\n    _tickUpper: int24,\n    _amountA: uint256,\n    _amountB: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, uint256, uint256):\n    return 0, 0, 0, 0, 0\n\n\n@external\ndef removeLiquidityConcentrated(\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _liqToRemove: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, bool, uint256):\n    return 0, 0, 0, False, 0\n\n\n\n@view\n@external\ndef getAccessForLego(_user: address, _action: ws.ActionType) -> (address, String[64], uint256):\n    return empty(address), empty(String[64]), 0\n",
            "sha256sum": "218bcba4ecbd42679674a733046232a5c07119bc7d47d9868f5f539c08a7129b"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/legos/dexes/UniswapV2.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.3+commit.bff19ea2",
        "integrity": "2a202aada0322f6f51ddd57a79a1aa4355e03cb580f597296c5e1341db6fcc66"
      },
      "args": "00000000000000000000000044cf3c4f000dfd76a35d03298049d37be688d6f90000000000000000000000008909dc15e40173ff4699343b6eb8132c65e18ec60000000000000000000000004752ba5dbc23f44d87826276bf6fd6b1c372ad2400000000000000000000000088a43bbdf9d098eec7bceda4e2494615dfd9bb9c0000000000000000000000006162df1b329e157479f8f1407e888260e0ec3d2b",
      "file": "contracts/legos/dexes/UniswapV2.vy"
    },
    "UniswapV3": {
      "address": "0xA87f42e2101CEada8f6A8105635fD40d141ba5CF",
      "abi": [
        {
          "name": "UniswapV3Swap",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenIn",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenOut",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amountIn",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "amountOut",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "numTokens",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UniswapV3LiquidityAdded",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenA",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenB",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amountA",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "amountB",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "liquidityAdded",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "nftTokenId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UniswapV3LiquidityRemoved",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": false
            },
            {
              "name": "pool",
              "type": "address",
              "indexed": true
            },
            {
              "name": "nftTokenId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "tokenA",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenB",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amountA",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "amountB",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "liquidityRemoved",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UniswapV3NftRecovered",
          "inputs": [
            {
              "name": "collection",
              "type": "address",
              "indexed": true
            },
            {
              "name": "nftTokenId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UniswapV3FeesCollected",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "nftTokenId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "token0",
              "type": "address",
              "indexed": true
            },
            {
              "name": "token1",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount0",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "amount1",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LegoPauseModified",
          "inputs": [
            {
              "name": "isPaused",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LegoFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "balance",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddys",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "undyToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "hatchery",
                  "type": "address"
                },
                {
                  "name": "lootDistributor",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                },
                {
                  "name": "walletBackpack",
                  "type": "address"
                },
                {
                  "name": "billing",
                  "type": "address"
                },
                {
                  "name": "vaultRegistry",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUndyHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pause",
          "inputs": [
            {
              "name": "_shouldPause",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFundsMany",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_assets",
              "type": "address[]"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "legoId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isPaused",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasCapability",
          "inputs": [
            {
              "name": "_action",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "onERC721Received",
          "inputs": [
            {
              "name": "_operator",
              "type": "address"
            },
            {
              "name": "_owner",
              "type": "address"
            },
            {
              "name": "_tokenId",
              "type": "uint256"
            },
            {
              "name": "_data",
              "type": "bytes"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bytes4"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRegistries",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isYieldLego",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isDexLego",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_tokenPath",
              "type": "address[]"
            },
            {
              "name": "_poolPath",
              "type": "address[]"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_tokenPath",
              "type": "address[]"
            },
            {
              "name": "_poolPath",
              "type": "address[]"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "uniswapV3SwapCallback",
          "inputs": [
            {
              "name": "_amount0Delta",
              "type": "int256"
            },
            {
              "name": "_amount1Delta",
              "type": "int256"
            },
            {
              "name": "_data",
              "type": "bytes"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLpToken",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPoolForLpToken",
          "inputs": [
            {
              "name": "_lpToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getCoreRouterPool",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getDeepestLiqPool",
          "inputs": [
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "fee",
                  "type": "uint256"
                },
                {
                  "name": "liquidity",
                  "type": "uint256"
                },
                {
                  "name": "numCoins",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getBestSwapAmountOut",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountIn",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getSwapAmountOut",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountIn",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getBestSwapAmountIn",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountOut",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getSwapAmountIn",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountOut",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddLiqAmountsIn",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_availAmountA",
              "type": "uint256"
            },
            {
              "name": "_availAmountB",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRemoveLiqAmountsOut",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPrice",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_decimals",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPriceUnsafe",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_targetToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPriceUnsafe",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_targetToken",
              "type": "address"
            },
            {
              "name": "_appraiser",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverNft",
          "inputs": [
            {
              "name": "_collection",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositForYield",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositForYield",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawFromYield",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawFromYield",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_tokenInAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_tokenInAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmMintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmMintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_borrowAsset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_borrowAsset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_paymentAsset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_paymentAsset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimIncentives",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_proofs",
              "type": "bytes32[]"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimIncentives",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_proofs",
              "type": "bytes32[]"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAccessForLego",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_action",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "string"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "UNIV3_FACTORY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "UNIV3_NFT_MANAGER",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "UNIV3_QUOTER",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "RIPE_REGISTRY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "coreRouterPool",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_undyHq",
              "type": "address"
            },
            {
              "name": "_uniswapV3Factory",
              "type": "address"
            },
            {
              "name": "_uniNftPositionManager",
              "type": "address"
            },
            {
              "name": "_uniV3Quoter",
              "type": "address"
            },
            {
              "name": "_coreRouterPool",
              "type": "address"
            },
            {
              "name": "_ripeRegistry",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "interfaces/WalletStructs.vyi": {
            "content": "# @version 0.4.3\n\nflag ActionType:\n    TRANSFER\n    EARN_DEPOSIT\n    EARN_WITHDRAW\n    EARN_REBALANCE\n    SWAP\n    MINT_REDEEM\n    CONFIRM_MINT_REDEEM\n    ADD_COLLATERAL\n    REMOVE_COLLATERAL\n    BORROW\n    REPAY_DEBT\n    REWARDS\n    ETH_TO_WETH\n    WETH_TO_ETH\n    ADD_LIQ\n    REMOVE_LIQ\n    ADD_LIQ_CONC\n    REMOVE_LIQ_CONC\n    PAY_CHEQUE\n\nstruct WalletAssetData:\n    assetBalance: uint256\n    usdValue: uint256\n    isYieldAsset: bool\n    lastPricePerShare: uint256\n\nstruct ActionData:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    billing: address\n    vaultRegistry: address\n    wallet: address\n    walletConfig: address\n    walletOwner: address\n    inEjectMode: bool\n    isFrozen: bool\n    lastTotalUsdValue: uint256\n    signer: address\n    isManager: bool\n    legoId: uint256\n    legoAddr: address\n    eth: address\n    weth: address\n\nstruct MiniAddys:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    appraiser: address",
            "sha256sum": "466493c129135c95470aaf70eeddc936632f7b0f813396e5a7ddc03bea9da518"
          },
          "interfaces/LegoPartner.vyi": {
            "content": "# @version 0.4.3\n\nfrom interfaces import WalletStructs as ws\n\nMAX_TOKEN_PATH: constant(uint256) = 5\nMAX_RECOVER_ASSETS: constant(uint256) = 20\nMAX_PROOFS: constant(uint256) = 25\n\n@external\ndef addLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _tickLower: int24, _tickUpper: int24, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef addLiquidity(_pool: address, _tokenA: address, _tokenB: address, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _minLpAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (address, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef removeLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _liqToRemove: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef removeLiquidity(_pool: address, _tokenA: address, _tokenB: address, _lpToken: address, _lpAmount: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef mintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _tokenInAmount: uint256, _minAmountOut: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef swapTokens(_amountIn: uint256, _minAmountOut: uint256, _tokenPath: DynArray[address, MAX_TOKEN_PATH], _poolPath: DynArray[address, MAX_TOKEN_PATH - 1], _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256):\n    ...\n\n@external\ndef depositForYield(_asset: address, _amount: uint256, _vaultAddr: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef withdrawFromYield(_vaultToken: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef confirmMintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef borrow(_borrowAsset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef repayDebt(_paymentAsset: address, _paymentAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef claimIncentives(_user: address, _rewardToken: address, _rewardAmount: uint256, _proofs: DynArray[bytes32, MAX_PROOFS], _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef removeCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef addCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@view\n@external\ndef getAccessForLego(_user: address, _action: ws.ActionType) -> (address, String[64], uint256):\n    ...\n\n@view\n@external\ndef hasCapability(_action: ws.ActionType) -> bool:\n    ...\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    ...\n\n@view\n@external\ndef isYieldLego() -> bool:\n    ...\n\n@view\n@external\ndef isDexLego() -> bool:\n    ...\n\n\n# common\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "f2afb7bd72d4301aea77bbe4177b7ae954ba6f6b76af363965993eb92ad0b715"
          },
          "contracts/modules/Addys.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\ninterface UndyHq:\n    def isValidAddr(_addr: address) -> bool: view\n    def getAddr(_regId: uint256) -> address: view\n    def undyToken() -> address: view\n\ninterface Switchboard:\n    def isSwitchboardAddr(_addr: address) -> bool: view\n\ninterface LegoBook:\n    def isLegoAddr(_addr: address) -> bool: view\n\nstruct Addys:\n    hq: address\n    undyToken: address\n    ledger: address\n    missionControl: address\n    legoBook: address\n    switchboard: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    walletBackpack: address\n    billing: address\n    vaultRegistry: address\n\n# hq\nUNDY_HQ_FOR_ADDYS: immutable(address)\n\n# core addys\nLEDGER_ID: constant(uint256) = 1\nMISSION_CONTROL_ID: constant(uint256) = 2\nLEGO_BOOK_ID: constant(uint256) = 3\nSWITCHBOARD_ID: constant(uint256) = 4\nHATCHERY_ID: constant(uint256) = 5\nLOOT_DISTRIBUTOR_ID: constant(uint256) = 6\nAPPRAISER_ID: constant(uint256) = 7\nWALLET_BACKPACK_ID: constant(uint256) = 8\nBILLING_ID: constant(uint256) = 9\nVAULT_REGISTRY_ID: constant(uint256) = 10\n\n\n@deploy\ndef __init__(_undyHq: address):\n    assert _undyHq != empty(address) # dev: invalid undy hq\n    UNDY_HQ_FOR_ADDYS = _undyHq\n\n\n########\n# Core #\n########\n\n\n@view\n@external\ndef getAddys() -> Addys:\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _getAddys(_addys: Addys = empty(Addys)) -> Addys:\n    if _addys.hq != empty(address):\n        return _addys\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _generateAddys() -> Addys:\n    hq: address = UNDY_HQ_FOR_ADDYS\n    return Addys(\n        hq = hq,\n        undyToken = staticcall UndyHq(hq).undyToken(),\n        ledger = staticcall UndyHq(hq).getAddr(LEDGER_ID),\n        missionControl = staticcall UndyHq(hq).getAddr(MISSION_CONTROL_ID),\n        legoBook = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID),\n        switchboard = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID),\n        hatchery = staticcall UndyHq(hq).getAddr(HATCHERY_ID),\n        lootDistributor = staticcall UndyHq(hq).getAddr(LOOT_DISTRIBUTOR_ID),\n        appraiser = staticcall UndyHq(hq).getAddr(APPRAISER_ID),\n        walletBackpack = staticcall UndyHq(hq).getAddr(WALLET_BACKPACK_ID),\n        billing = staticcall UndyHq(hq).getAddr(BILLING_ID),\n        vaultRegistry = staticcall UndyHq(hq).getAddr(VAULT_REGISTRY_ID),\n    )\n\n\n##########\n# Tokens #\n##########\n\n\n@view\n@internal\ndef _getUndyToken() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).undyToken()\n\n\n###########\n# Helpers #\n###########\n\n\n# undy hq\n\n\n@view\n@external\ndef getUndyHq() -> address:\n    return self._getUndyHq()\n\n\n@view\n@internal\ndef _getUndyHq() -> address:\n    return UNDY_HQ_FOR_ADDYS\n\n\n# utils\n\n\n@view\n@internal\ndef _isValidUndyAddr(_addr: address, _hq: address = empty(address)) -> bool:\n    hq: address = _hq\n    if _hq == empty(address):\n        hq = UNDY_HQ_FOR_ADDYS\n    \n    # core departments\n    if staticcall UndyHq(hq).isValidAddr(_addr):\n        return True\n\n    # lego book\n    legoBook: address = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID)\n    if legoBook != empty(address) and staticcall LegoBook(legoBook).isLegoAddr(_addr):\n        return True\n\n    # switchboard config\n    switchboard: address = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID)\n    if switchboard != empty(address) and staticcall Switchboard(switchboard).isSwitchboardAddr(_addr):\n        return True\n\n    return False\n\n\n@view\n@internal\ndef _isSwitchboardAddr(_addr: address) -> bool:\n    switchboard: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n    if switchboard == empty(address):\n        return False\n    return staticcall Switchboard(switchboard).isSwitchboardAddr(_addr)\n\n\n@view\n@internal\ndef _isLegoBookAddr(_addr: address) -> bool:\n    legoBook: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n    if legoBook == empty(address):\n        return False\n    return staticcall LegoBook(legoBook).isLegoAddr(_addr)\n\n\n###############\n# Departments #\n###############\n\n\n# ledger\n\n\n@view\n@internal\ndef _getLedgerId() -> uint256:\n    return LEDGER_ID\n\n\n@view\n@internal\ndef _getLedgerAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEDGER_ID)\n\n\n# mission control\n\n\n@view\n@internal\ndef _getMissionControlId() -> uint256:\n    return MISSION_CONTROL_ID\n\n\n@view\n@internal\ndef _getMissionControlAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(MISSION_CONTROL_ID)\n\n\n# lego book\n\n\n@view\n@internal\ndef _getLegoBookId() -> uint256:\n    return LEGO_BOOK_ID\n\n\n@view\n@internal\ndef _getLegoBookAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n\n\n# switchboard\n\n\n@view\n@internal\ndef _getSwitchboardId() -> uint256:\n    return SWITCHBOARD_ID\n\n\n@view\n@internal\ndef _getSwitchboardAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n\n\n# hatchery\n\n\n@view\n@internal\ndef _getHatcheryId() -> uint256:\n    return HATCHERY_ID\n\n\n@view\n@internal\ndef _getHatcheryAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(HATCHERY_ID)\n\n\n# loot distributor\n\n\n@view\n@internal\ndef _getLootDistributorId() -> uint256:\n    return LOOT_DISTRIBUTOR_ID\n\n\n@view\n@internal\ndef _getLootDistributorAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LOOT_DISTRIBUTOR_ID)\n\n\n# appraiser\n\n\n@view\n@internal\ndef _getAppraiserId() -> uint256:\n    return APPRAISER_ID\n\n\n@view\n@internal\ndef _getAppraiserAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(APPRAISER_ID)\n\n\n# wallet backpack\n\n\n@view\n@internal\ndef _getWalletBackpackId() -> uint256:\n    return WALLET_BACKPACK_ID\n\n\n@view\n@internal\ndef _getWalletBackpackAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(WALLET_BACKPACK_ID)\n\n\n# billing\n\n\n@view\n@internal\ndef _getBillingId() -> uint256:\n    return BILLING_ID\n\n\n@view\n@internal\ndef _getBillingAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(BILLING_ID)\n\n\n# vault registry\n\n\n@view\n@internal\ndef _getVaultRegistryId() -> uint256:\n    return VAULT_REGISTRY_ID\n\n\n@view\n@internal\ndef _getVaultRegistryAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(VAULT_REGISTRY_ID)",
            "sha256sum": "4df6b72db9bb417d1af81660175be1450cfb7b3575f3d17a5b8a130bff87b781"
          },
          "contracts/modules/DexLegoData.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nuses: addys\n\nimport contracts.modules.Addys as addys\n\nfrom interfaces import WalletStructs as ws\nfrom ethereum.ercs import IERC20\n\nevent LegoPauseModified:\n    isPaused: bool\n\nevent LegoFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    balance: uint256\n\n# config\nlegoId: public(uint256)\nisPaused: public(bool)\n\nMAX_RECOVER_ASSETS: constant(uint256) = 20\n\n\n@deploy\ndef __init__(_shouldPause: bool):\n    self.isPaused = _shouldPause\n\n\n###########\n# General #\n###########\n\n\n# fill mini addys\n\n\n@view\n@internal\ndef _getMiniAddys(_miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> ws.MiniAddys:\n    if _miniAddys.ledger != empty(address):\n        return _miniAddys\n    return ws.MiniAddys(\n        ledger = addys._getLedgerAddr(),\n        missionControl = addys._getMissionControlAddr(),\n        legoBook = addys._getLegoBookAddr(),\n        appraiser = addys._getAppraiserAddr(),\n    )\n\n\n# activate\n\n\n@external\ndef pause(_shouldPause: bool):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert _shouldPause != self.isPaused # dev: no change\n    self.isPaused = _shouldPause\n    log LegoPauseModified(isPaused=_shouldPause)\n\n\n# recover funds\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    self._recoverFunds(_recipient, _asset)\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, MAX_RECOVER_ASSETS]):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    for a: address in _assets:\n        self._recoverFunds(_recipient, a)\n\n\n@internal\ndef _recoverFunds(_recipient: address, _asset: address):\n    assert empty(address) not in [_recipient, _asset] # dev: invalid recipient or asset\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    assert balance != 0 # dev: nothing to recover\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log LegoFundsRecovered(asset=_asset, recipient=_recipient, balance=balance)",
            "sha256sum": "75b15af2475ab409d4b5fd057509d14c20564ebd7fcb0850e3b61397d8e3af48"
          },
          "contracts/legos/dexes/UniswapV3.vy": {
            "content": "#     _____  _____  __  __    ____   _____  _____  _____ \n#    |  _  \\/   __\\/  \\/  \\  /  _/  /   __\\/   __\\/  _  \\\n#    |  |  ||   __|>-    -<  |  |---|   __||  |_ ||  |  |\n#    |_____/\\_____/\\__/\\__/  \\_____/\\_____/\\_____/\\_____/\n#                                                                       \n#     \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n#     \u2551  ** Uniswap V3 Lego **           \u2551\n#     \u2551  Integration with Uniswap V3.    \u2551\n#     \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n#\n#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nimplements: Lego\nimplements: IUniswapV3Callback\n\nexports: addys.__interface__\nexports: dld.__interface__\n\ninitializes: addys\ninitializes: dld[addys := addys]\n\nfrom interfaces import LegoPartner as Lego\nfrom interfaces import WalletStructs as ws\n\nimport contracts.modules.Addys as addys\nimport contracts.modules.DexLegoData as dld\n\nfrom ethereum.ercs import IERC20\nfrom ethereum.ercs import IERC20Detailed\nfrom ethereum.ercs import IERC721\n\n# `getSwapAmountOut()` and `getSwapAmountIn()` cannot be view functions, sadly\n# keeping here to uncomment to test all other functions\n# implements: DexLego\n# from interfaces import DexLego as DexLego\n\ninterface UniV3Pool:\n    def slot0() -> (uint160, int24, uint16, uint16, uint16, uint8, bool): view\n    def swap(_recipient: address, _zeroForOne: bool, _amountSpecified: int256, _sqrtPriceLimitX96: uint160, _data: Bytes[256]) -> (int256, int256): nonpayable\n    def liquidity() -> uint128: view\n    def tickSpacing() -> int24: view\n    def token0() -> address: view\n    def token1() -> address: view\n    def fee() -> uint24: view\n\ninterface UniV3NftPositionManager:\n    def increaseLiquidity(_params: IncreaseLiquidityParams) -> (uint128, uint256, uint256): nonpayable\n    def decreaseLiquidity(_params: DecreaseLiquidityParams) -> (uint256, uint256): nonpayable\n    def mint(_params: MintParams) -> (uint256, uint128, uint256, uint256): nonpayable\n    def collect(_params: CollectParams) -> (uint256, uint256): nonpayable\n    def positions(_tokenId: uint256) -> PositionData: view\n    def burn(_tokenId: uint256): nonpayable\n\ninterface UniV3Quoter:\n    def quoteExactOutputSingle(_params: QuoteExactOutputSingleParams) -> (uint256, uint160, uint32, uint256): nonpayable\n    def quoteExactInputSingle(_params: QuoteExactInputSingleParams) -> (uint256, uint160, uint32, uint256): nonpayable\n    def quoteExactInput(_path: Bytes[1024], _amountIn: uint256) -> uint256: nonpayable\n\ninterface Appraiser:\n    def getUsdValue(_asset: address, _amount: uint256, _missionControl: address = empty(address), _legoBook: address = empty(address), _ledger: address = empty(address)) -> uint256: view\n    def getRipePrice(_asset: address) -> uint256: view\n\ninterface IUniswapV3Callback:\n    def uniswapV3SwapCallback(_amount0Delta: int256, _amount1Delta: int256, _data: Bytes[256]): nonpayable\n\ninterface UniV3Factory:\n    def getPool(_tokenA: address, _tokenB: address, _fee: uint24) -> address: view\n\ninterface VaultRegistry:\n    def isEarnVault(_vaultAddr: address) -> bool: view\n\ninterface Ledger:\n    def isUserWallet(_user: address) -> bool: view\n\ninterface Registry:\n    def isValidAddr(_addr: address) -> bool: view\n\nstruct QuoteExactInputSingleParams:\n    tokenIn: address\n    tokenOut: address\n    amountIn: uint256\n    fee: uint24\n    sqrtPriceLimitX96: uint160\n\nstruct QuoteExactOutputSingleParams:\n    tokenIn: address\n    tokenOut: address\n    amount: uint256\n    fee: uint24\n    sqrtPriceLimitX96: uint160\n\nstruct BestPool:\n    pool: address\n    fee: uint256\n    liquidity: uint256\n    numCoins: uint256\n\nstruct MintParams:\n    token0: address\n    token1: address\n    fee: uint24\n    tickLower: int24\n    tickUpper: int24\n    amount0Desired: uint256\n    amount1Desired: uint256\n    amount0Min: uint256\n    amount1Min: uint256\n    recipient: address\n    deadline: uint256\n\nstruct IncreaseLiquidityParams:\n    tokenId: uint256\n    amount0Desired: uint256\n    amount1Desired: uint256\n    amount0Min: uint256\n    amount1Min: uint256\n    deadline: uint256\n\nstruct DecreaseLiquidityParams:\n    tokenId: uint256\n    liquidity: uint128\n    amount0Min: uint256\n    amount1Min: uint256\n    deadline: uint256\n\nstruct CollectParams:\n    tokenId: uint256\n    recipient: address\n    amount0Max: uint128\n    amount1Max: uint128\n\nstruct PositionData:\n    nonce: uint96\n    operator: address\n    token0: address\n    token1: address\n    fee: uint24\n    tickLower: int24\n    tickUpper: int24\n    liquidity: uint128\n    feeGrowthInside0LastX128: uint256\n    feeGrowthInside1LastX128: uint256\n    tokensOwed0: uint128\n    tokensOwed1: uint128\n\nstruct PoolSwapData:\n    pool: address\n    tokenIn: address\n    amountInDesired: uint256\n    sender: address\n\nevent UniswapV3Swap:\n    sender: indexed(address)\n    tokenIn: indexed(address)\n    tokenOut: indexed(address)\n    amountIn: uint256\n    amountOut: uint256\n    usdValue: uint256\n    numTokens: uint256\n    recipient: address\n\nevent UniswapV3LiquidityAdded:\n    sender: indexed(address)\n    tokenA: indexed(address)\n    tokenB: indexed(address)\n    amountA: uint256\n    amountB: uint256\n    liquidityAdded: uint256\n    nftTokenId: uint256\n    usdValue: uint256\n    recipient: address\n\nevent UniswapV3LiquidityRemoved:\n    sender: address\n    pool: indexed(address)\n    nftTokenId: uint256\n    tokenA: indexed(address)\n    tokenB: indexed(address)\n    amountA: uint256\n    amountB: uint256\n    liquidityRemoved: uint256\n    usdValue: uint256\n    recipient: address\n\nevent UniswapV3NftRecovered:\n    collection: indexed(address)\n    nftTokenId: uint256\n    recipient: indexed(address)\n\nevent UniswapV3FeesCollected:\n    sender: indexed(address)\n    nftTokenId: uint256\n    token0: indexed(address)\n    token1: indexed(address)\n    amount0: uint256\n    amount1: uint256\n    recipient: address\n\n# transient storage\npoolSwapData: transient(PoolSwapData)\n\n# uniswap v3\nUNIV3_FACTORY: public(immutable(address))\nUNIV3_NFT_MANAGER: public(immutable(address))\nUNIV3_QUOTER: public(immutable(address))\nRIPE_REGISTRY: public(immutable(address))\ncoreRouterPool: public(address)\n\nFEE_TIERS: constant(uint24[4]) = [100, 500, 3000, 10000] # 0.01%, 0.05%, 0.3%, 1%\nMIN_SQRT_RATIO_PLUS_ONE: constant(uint160) = 4295128740\nMAX_SQRT_RATIO_MINUS_ONE: constant(uint160) = 1461446703485210103287273052203988822378723970341\nTICK_LOWER: constant(int24) = -887272\nTICK_UPPER: constant(int24) = 887272\nERC721_RECEIVE_DATA: constant(Bytes[1024]) = b\"UE721\"\nEIGHTEEN_DECIMALS: constant(uint256) = 10 ** 18\nUNISWAP_Q96: constant(uint256) = 2 ** 96  # uniswap's fixed point scaling factor\nMAX_TOKEN_PATH: constant(uint256) = 5\nMAX_PROOFS: constant(uint256) = 25\n\n\n@deploy\ndef __init__(\n    _undyHq: address,\n    _uniswapV3Factory: address,\n    _uniNftPositionManager: address,\n    _uniV3Quoter: address,\n    _coreRouterPool: address,\n    _ripeRegistry: address,\n):\n    addys.__init__(_undyHq)\n    dld.__init__(False)\n\n    assert empty(address) not in [_uniswapV3Factory, _uniNftPositionManager, _uniV3Quoter, _coreRouterPool, _ripeRegistry] # dev: invalid addrs\n    UNIV3_FACTORY = _uniswapV3Factory\n    UNIV3_NFT_MANAGER = _uniNftPositionManager\n    UNIV3_QUOTER = _uniV3Quoter\n    RIPE_REGISTRY = _ripeRegistry\n    self.coreRouterPool = _coreRouterPool\n\n\n@view\n@external\ndef hasCapability(_action: ws.ActionType) -> bool:\n    return _action in (\n        ws.ActionType.SWAP |\n        ws.ActionType.ADD_LIQ_CONC | \n        ws.ActionType.REMOVE_LIQ_CONC\n    )\n\n\n@view\n@external\ndef onERC721Received(_operator: address, _owner: address, _tokenId: uint256, _data: Bytes[1024]) -> bytes4:\n    # must implement method for safe NFT transfers\n    assert _data == ERC721_RECEIVE_DATA # dev: did not receive from within Underscore wallet\n    return method_id(\"onERC721Received(address,address,uint256,bytes)\", output_type=bytes4)\n\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    return [UNIV3_FACTORY, UNIV3_NFT_MANAGER, UNIV3_QUOTER]\n\n\n@view\n@external\ndef isYieldLego() -> bool:\n    return False\n\n\n@view\n@external\ndef isDexLego() -> bool:\n    return True\n\n\n@view\n@internal\ndef _isAllowedToPerformAction(_caller: address) -> bool:\n    if staticcall VaultRegistry(addys._getVaultRegistryAddr()).isEarnVault(_caller):\n        return True\n    if staticcall Ledger(addys._getLedgerAddr()).isUserWallet(_caller):\n        return True\n    return staticcall Registry(RIPE_REGISTRY).isValidAddr(_caller)\n\n\n#########\n# Swaps #\n#########\n\n\n@external\ndef swapTokens(\n    _amountIn: uint256,\n    _minAmountOut: uint256,\n    _tokenPath: DynArray[address, MAX_TOKEN_PATH],\n    _poolPath: DynArray[address, MAX_TOKEN_PATH - 1],\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256):\n    assert not dld.isPaused # dev: paused\n    assert self._isAllowedToPerformAction(msg.sender) # dev: no perms\n    miniAddys: ws.MiniAddys = dld._getMiniAddys(_miniAddys)\n\n    # validate inputs\n    numTokens: uint256 = len(_tokenPath)\n    numPools: uint256 = len(_poolPath)\n    assert numTokens >= 2 # dev: invalid path\n    assert numPools == numTokens - 1 # dev: invalid path\n\n    # get first token and last token\n    tokenIn: address = _tokenPath[0]\n    tokenOut: address = _tokenPath[numTokens - 1]\n\n    # pre balances\n    preLegoBalance: uint256 = staticcall IERC20(tokenIn).balanceOf(self)\n\n    # transfer deposit asset to this contract\n    amountIn: uint256 = min(_amountIn, staticcall IERC20(tokenIn).balanceOf(msg.sender))\n    assert amountIn != 0 # dev: nothing to transfer\n    assert extcall IERC20(tokenIn).transferFrom(msg.sender, self, amountIn, default_return_value=True) # dev: transfer failed\n\n    # adjust min amount out\n    minAmountOut: uint256 = _minAmountOut\n    if amountIn < _amountIn and _amountIn != max_value(uint256):\n        minAmountOut = _minAmountOut * amountIn // _amountIn\n\n    # iterate through swap routes\n    tempAmountIn: uint256 = amountIn\n    uniswapV3Factory: address = UNIV3_FACTORY\n    for i: uint256 in range(numTokens - 1, bound=MAX_TOKEN_PATH):\n        tempTokenIn: address = _tokenPath[i]\n        tempTokenOut: address = _tokenPath[i + 1]\n        tempPool: address = _poolPath[i]\n\n        # transfer to self (or to recipient if last swap)\n        recipient: address = _recipient\n        if i < numTokens - 2:\n            recipient = self\n\n        # swap\n        tempAmountIn = self._swapTokensInPool(tempPool, tempTokenIn, tempTokenOut, tempAmountIn, msg.sender, recipient, uniswapV3Factory)\n\n    # final amount\n    amountOut: uint256 = tempAmountIn\n    assert amountOut >= minAmountOut # dev: min amount out not met\n\n    # refund if full swap didn't get through\n    currentLegoBalance: uint256 = staticcall IERC20(tokenIn).balanceOf(self)\n    refundAssetAmount: uint256 = 0\n    if currentLegoBalance > preLegoBalance:\n        refundAssetAmount = currentLegoBalance - preLegoBalance\n        assert extcall IERC20(tokenIn).transfer(msg.sender, refundAssetAmount, default_return_value=True) # dev: transfer failed\n        amountIn -= refundAssetAmount\n\n    # get usd values\n    usdValue: uint256 = staticcall Appraiser(miniAddys.appraiser).getUsdValue(tokenIn, amountIn, miniAddys.missionControl, miniAddys.legoBook, miniAddys.ledger)\n    if usdValue == 0:\n        usdValue = staticcall Appraiser(miniAddys.appraiser).getUsdValue(tokenOut, amountOut, miniAddys.missionControl, miniAddys.legoBook, miniAddys.ledger)\n\n    log UniswapV3Swap(\n        sender = msg.sender,\n        tokenIn = tokenIn,\n        tokenOut = tokenOut,\n        amountIn = amountIn,\n        amountOut = amountOut,\n        usdValue = usdValue,\n        numTokens = numTokens,\n        recipient = _recipient,\n    )\n    return amountIn, amountOut, usdValue\n\n\n# swap in pool\n\n\n@internal\ndef _swapTokensInPool(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n    _sender: address,\n    _recipient: address,\n    _uniswapV3Factory: address,\n) -> uint256:\n    tokens: address[2] = [staticcall UniV3Pool(_pool).token0(), staticcall UniV3Pool(_pool).token1()]\n    assert _tokenIn in tokens # dev: invalid tokenIn\n    assert _tokenOut in tokens # dev: invalid tokenOut\n    assert _tokenIn != _tokenOut # dev: invalid tokens\n\n    # verify actual uniswap v3 pool\n    assert staticcall UniV3Factory(_uniswapV3Factory).getPool(_tokenIn, _tokenOut, staticcall UniV3Pool(_pool).fee()) == _pool # dev: invalid pool\n\n    # save in transient storage (for use in callback)\n    self.poolSwapData = PoolSwapData(\n        pool=_pool,\n        tokenIn=_tokenIn,\n        amountInDesired=_amountIn,\n        sender=_sender,\n    )\n\n    zeroForOne: bool = _tokenIn == tokens[0]\n    sqrtPriceLimitX96: uint160 = MAX_SQRT_RATIO_MINUS_ONE\n    if zeroForOne:\n        sqrtPriceLimitX96 = MIN_SQRT_RATIO_PLUS_ONE\n\n    # perform swap\n    amount0: int256 = 0\n    amount1: int256 = 0\n    amount0, amount1 = extcall UniV3Pool(_pool).swap(_recipient, zeroForOne, convert(_amountIn, int256), sqrtPriceLimitX96, b\"\")\n\n    toAmount: uint256 = 0\n    if zeroForOne:\n        toAmount = convert(-amount1, uint256)\n    else:\n        toAmount = convert(-amount0, uint256)\n\n    assert toAmount != 0 # dev: no tokens swapped\n    return toAmount\n\n\n# callback\n\n\n@external\ndef uniswapV3SwapCallback(_amount0Delta: int256, _amount1Delta: int256, _data: Bytes[256]):\n    poolSwapData: PoolSwapData = self.poolSwapData\n    assert msg.sender == poolSwapData.pool # dev: no perms\n\n    # determine the amount to transfer based on deltas\n    # Positive delta = amount we owe the pool\n    # Negative delta = amount we receive from the pool\n    token0: address = staticcall UniV3Pool(poolSwapData.pool).token0()\n    amountToSend: uint256 = 0\n\n    # we're selling token0 for token1\n    if poolSwapData.tokenIn == token0:\n        assert _amount0Delta != 0 # dev: invalid delta\n        amountToSend = convert(_amount0Delta, uint256)\n\n    # we're selling token1 for token0\n    else:\n        assert _amount1Delta != 0 # dev: invalid delta\n        amountToSend = convert(_amount1Delta, uint256)\n\n    # transfer tokens to pool\n    assert extcall IERC20(poolSwapData.tokenIn).transfer(poolSwapData.pool, amountToSend, default_return_value=True) # dev: transfer failed\n\n    # refund unused tokens immediately (handles partial swaps in multi-hop routes)\n    if amountToSend < poolSwapData.amountInDesired:\n        refundAmount: uint256 = min(poolSwapData.amountInDesired - amountToSend, staticcall IERC20(poolSwapData.tokenIn).balanceOf(self))\n        assert extcall IERC20(poolSwapData.tokenIn).transfer(poolSwapData.sender, refundAmount, default_return_value=True) # dev: refund failed\n\n    self.poolSwapData = empty(PoolSwapData)\n\n\n#################\n# Add Liquidity #\n#################\n\n\n@external\ndef addLiquidityConcentrated(\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _tickLower: int24,\n    _tickUpper: int24,\n    _amountA: uint256,\n    _amountB: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, uint256, uint256):\n    assert not dld.isPaused # dev: paused\n    assert self._isAllowedToPerformAction(msg.sender) # dev: no perms\n    miniAddys: ws.MiniAddys = dld._getMiniAddys(_miniAddys)\n    nftPositionManager: address = UNIV3_NFT_MANAGER\n\n    # detect fee collection mode: if both tokens are empty and both amounts are zero\n    # this is a workaround to allow collecting fees without adding liquidity\n    isFeeCollectionMode: bool = (\n        _tokenA == empty(address) and\n        _tokenB == empty(address) and\n        _amountA == 0 and\n        _amountB == 0 and\n        _nftTokenId != 0\n    )\n    if isFeeCollectionMode:\n        return self._collectFeesOnly(_nftTokenId, _recipient, nftPositionManager, miniAddys)\n\n    # validate tokens\n    tokens: address[2] = [staticcall UniV3Pool(_pool).token0(), staticcall UniV3Pool(_pool).token1()]\n    assert _tokenA in tokens # dev: invalid tokenA\n    assert _tokenB in tokens # dev: invalid tokenB\n    assert _tokenA != _tokenB # dev: invalid tokens\n\n    # pre balances\n    preLegoBalanceA: uint256 = staticcall IERC20(_tokenA).balanceOf(self)\n    preLegoBalanceB: uint256 = staticcall IERC20(_tokenB).balanceOf(self)\n\n    # token a\n    liqAmountA: uint256 = min(_amountA, staticcall IERC20(_tokenA).balanceOf(msg.sender))\n    if liqAmountA != 0:\n        assert extcall IERC20(_tokenA).transferFrom(msg.sender, self, liqAmountA, default_return_value=True) # dev: transfer failed\n        assert extcall IERC20(_tokenA).approve(nftPositionManager, liqAmountA, default_return_value=True) # dev: approval failed\n\n    # token b\n    liqAmountB: uint256 = min(_amountB, staticcall IERC20(_tokenB).balanceOf(msg.sender))\n    if liqAmountB != 0:\n        assert extcall IERC20(_tokenB).transferFrom(msg.sender, self, liqAmountB, default_return_value=True) # dev: transfer failed\n        assert extcall IERC20(_tokenB).approve(nftPositionManager, liqAmountB, default_return_value=True) # dev: approval failed\n\n    # organized the index of tokens\n    token0: address = _tokenA\n    token1: address = _tokenB\n    amount0: uint256 = liqAmountA\n    amount1: uint256 = liqAmountB\n    minAmount0: uint256 = _minAmountA\n    minAmount1: uint256 = _minAmountB\n    if tokens[0] != _tokenA:\n        token0 = _tokenB\n        token1 = _tokenA\n        amount0 = liqAmountB\n        amount1 = liqAmountA\n        minAmount0 = _minAmountB\n        minAmount1 = _minAmountA\n\n    # add liquidity\n    nftTokenId: uint256 = _nftTokenId\n    liquidityAdded: uint256 = 0\n    liquidityAddedInt128: uint128 = 0\n    if _nftTokenId == 0:\n        nftTokenId, liquidityAddedInt128, amount0, amount1 = self._mintNewPosition(nftPositionManager, _pool, token0, token1, _tickLower, _tickUpper, amount0, amount1, minAmount0, minAmount1, _recipient)\n    else:\n        liquidityAddedInt128, amount0, amount1 = self._increaseExistingPosition(nftPositionManager, _nftTokenId, amount0, amount1, minAmount0, minAmount1, _recipient)\n\n    liquidityAdded = convert(liquidityAddedInt128, uint256)\n    assert liquidityAdded != 0 # dev: no liquidity added\n\n    # reset approvals\n    if liqAmountA != 0:\n        assert extcall IERC20(_tokenA).approve(nftPositionManager, 0, default_return_value=True) # dev: approval failed\n    if liqAmountB != 0:\n        assert extcall IERC20(_tokenB).approve(nftPositionManager, 0, default_return_value=True) # dev: approval failed\n\n    # refund if full liquidity was not added\n    currentLegoBalanceA: uint256 = staticcall IERC20(_tokenA).balanceOf(self)\n    refundAssetAmountA: uint256 = 0\n    if currentLegoBalanceA > preLegoBalanceA:\n        refundAssetAmountA = currentLegoBalanceA - preLegoBalanceA\n        assert extcall IERC20(_tokenA).transfer(msg.sender, refundAssetAmountA, default_return_value=True) # dev: transfer failed\n\n    currentLegoBalanceB: uint256 = staticcall IERC20(_tokenB).balanceOf(self)\n    refundAssetAmountB: uint256 = 0\n    if currentLegoBalanceB > preLegoBalanceB:\n        refundAssetAmountB = currentLegoBalanceB - preLegoBalanceB\n        assert extcall IERC20(_tokenB).transfer(msg.sender, refundAssetAmountB, default_return_value=True) # dev: transfer failed\n\n    # a/b amounts\n    liqAmountA = amount0\n    liqAmountB = amount1\n    if tokens[0] != _tokenA:\n        liqAmountA = amount1\n        liqAmountB = amount0\n\n    usdValue: uint256 = self._getUsdValue(_tokenA, liqAmountA, _tokenB, liqAmountB, miniAddys)\n    log UniswapV3LiquidityAdded(\n        sender = msg.sender,\n        tokenA = _tokenA,\n        tokenB = _tokenB,\n        amountA = liqAmountA,\n        amountB = liqAmountB,\n        liquidityAdded = liquidityAdded,\n        nftTokenId = nftTokenId,\n        usdValue = usdValue,\n        recipient = _recipient,\n    )\n    return liquidityAdded, liqAmountA, liqAmountB, nftTokenId, usdValue\n\n\n# mint new position\n\n\n@internal\ndef _mintNewPosition(\n    _nftPositionManager: address,\n    _pool: address,\n    _token0: address,\n    _token1: address,\n    _tickLower: int24,\n    _tickUpper: int24,\n    _amount0: uint256,\n    _amount1: uint256,\n    _minAmount0: uint256,\n    _minAmount1: uint256,\n    _recipient: address,\n) -> (uint256, uint128, uint256, uint256):\n    tickLower: int24 = 0\n    tickUpper: int24 = 0\n    tickLower, tickUpper = self._getTicks(_pool, _tickLower, _tickUpper)\n\n    # mint new position\n    params: MintParams = MintParams(\n        token0=_token0,\n        token1=_token1,\n        fee=staticcall UniV3Pool(_pool).fee(),\n        tickLower=tickLower,\n        tickUpper=tickUpper,\n        amount0Desired=_amount0,\n        amount1Desired=_amount1,\n        amount0Min=_minAmount0,\n        amount1Min=_minAmount1,\n        recipient=_recipient,\n        deadline=block.timestamp,\n    )\n    return extcall UniV3NftPositionManager(_nftPositionManager).mint(params)\n\n\n# get ticks\n\n\n@view\n@internal\ndef _getTicks(_pool: address, _tickLower: int24, _tickUpper: int24) -> (int24, int24):\n    tickSpacing: int24 = 0\n    if _tickLower == min_value(int24) or _tickUpper == max_value(int24):\n        tickSpacing = staticcall UniV3Pool(_pool).tickSpacing()\n\n    tickLower: int24 = _tickLower\n    if _tickLower == min_value(int24):\n        tickLower = (TICK_LOWER // tickSpacing) * tickSpacing\n\n    tickUpper: int24 = _tickUpper\n    if _tickUpper == max_value(int24):\n        tickUpper = (TICK_UPPER // tickSpacing) * tickSpacing\n\n    return tickLower, tickUpper\n\n\n# increase existing position\n\n\n@internal\ndef _increaseExistingPosition(\n    _nftPositionManager: address,\n    _tokenId: uint256,\n    _amount0: uint256,\n    _amount1: uint256,\n    _minAmount0: uint256,\n    _minAmount1: uint256,\n    _recipient: address,\n) -> (uint128, uint256, uint256):\n    assert staticcall IERC721(_nftPositionManager).ownerOf(_tokenId) == self # dev: nft not here\n\n    liquidityAddedInt128: uint128 = 0\n    amount0: uint256 = 0\n    amount1: uint256 = 0\n    params: IncreaseLiquidityParams = IncreaseLiquidityParams(\n        tokenId=_tokenId,\n        amount0Desired=_amount0,\n        amount1Desired=_amount1,\n        amount0Min=_minAmount0,\n        amount1Min=_minAmount1,\n        deadline=block.timestamp,\n    )\n    liquidityAddedInt128, amount0, amount1 = extcall UniV3NftPositionManager(_nftPositionManager).increaseLiquidity(params)\n\n    # collect fees (if applicable) -- must be done before transferring nft\n    positionData: PositionData = staticcall UniV3NftPositionManager(_nftPositionManager).positions(_tokenId)\n    self._collectFees(_nftPositionManager, _tokenId, _recipient, positionData)\n\n    # transfer nft to recipient\n    extcall IERC721(_nftPositionManager).safeTransferFrom(self, _recipient, _tokenId)\n\n    return liquidityAddedInt128, amount0, amount1\n\n\n# collect fees\n\n\n@internal\ndef _collectFees(_nftPositionManager: address, _tokenId: uint256, _recipient: address, _positionData: PositionData) -> (uint256, uint256):\n    if _positionData.tokensOwed0 == 0 and _positionData.tokensOwed1 == 0:\n        return 0, 0\n\n    params: CollectParams = CollectParams(\n        tokenId=_tokenId,\n        recipient=_recipient,\n        amount0Max=max_value(uint128),\n        amount1Max=max_value(uint128),\n    )\n    return extcall UniV3NftPositionManager(_nftPositionManager).collect(params)\n\n\n# collect fees only (for empty positions)\n\n\n@internal\ndef _collectFeesOnly(\n    _nftTokenId: uint256,\n    _recipient: address,\n    _nftPositionManager: address,\n    _miniAddys: ws.MiniAddys,\n) -> (uint256, uint256, uint256, uint256, uint256):\n    assert staticcall IERC721(_nftPositionManager).ownerOf(_nftTokenId) == self # dev: nft not here\n\n    # get position data\n    positionData: PositionData = staticcall UniV3NftPositionManager(_nftPositionManager).positions(_nftTokenId)\n\n    # collect fees\n    amount0: uint256 = 0\n    amount1: uint256 = 0\n    amount0, amount1 = self._collectFees(_nftPositionManager, _nftTokenId, _recipient, positionData)\n\n    # transfer nft back to recipient\n    extcall IERC721(_nftPositionManager).safeTransferFrom(self, _recipient, _nftTokenId)\n\n    # calculate usd value of fees collected\n    usdValue: uint256 = self._getUsdValue(positionData.token0, amount0, positionData.token1, amount1, _miniAddys)\n\n    log UniswapV3FeesCollected(\n        sender=msg.sender,\n        nftTokenId=_nftTokenId,\n        token0=positionData.token0,\n        token1=positionData.token1,\n        amount0=amount0,\n        amount1=amount1,\n        recipient=_recipient,\n    )\n    return 0, amount0, amount1, _nftTokenId, usdValue\n\n\n####################\n# Remove Liquidity #\n####################\n\n\n@external\ndef removeLiquidityConcentrated(\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _liqToRemove: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, bool, uint256):\n    assert not dld.isPaused # dev: paused\n    assert self._isAllowedToPerformAction(msg.sender) # dev: no perms\n    miniAddys: ws.MiniAddys = dld._getMiniAddys(_miniAddys)\n\n    # make sure nft is here\n    nftPositionManager: address = UNIV3_NFT_MANAGER\n    assert staticcall IERC721(nftPositionManager).ownerOf(_nftTokenId) == self # dev: nft not here\n\n    # get position data\n    positionData: PositionData = staticcall UniV3NftPositionManager(nftPositionManager).positions(_nftTokenId)\n    originalLiquidity: uint128 = positionData.liquidity\n\n    # validate tokens\n    tokens: address[2] = [positionData.token0, positionData.token1]\n    assert _tokenA in tokens # dev: invalid tokenA\n    assert _tokenB in tokens # dev: invalid tokenB\n    assert _tokenA != _tokenB # dev: invalid tokens\n\n    # organized the index of tokens\n    minAmount0: uint256 = _minAmountA\n    minAmount1: uint256 = _minAmountB\n    if _tokenA != tokens[0]:\n        minAmount0 = _minAmountB\n        minAmount1 = _minAmountA\n\n    # decrease liquidity\n    liqToRemove: uint256 = min(_liqToRemove, convert(positionData.liquidity, uint256))\n    assert liqToRemove != 0 # dev: no liquidity to remove\n\n    params: DecreaseLiquidityParams = DecreaseLiquidityParams(\n        tokenId=_nftTokenId,\n        liquidity=convert(liqToRemove, uint128),\n        amount0Min=minAmount0,\n        amount1Min=minAmount1,\n        deadline=block.timestamp,\n    )\n    amount0: uint256 = 0\n    amount1: uint256 = 0\n    amount0, amount1 = extcall UniV3NftPositionManager(nftPositionManager).decreaseLiquidity(params)\n    assert amount0 != 0 or amount1 != 0 # dev: no liquidity removed\n\n    # a/b amounts\n    amountA: uint256 = amount0\n    amountB: uint256 = amount1\n    if _tokenA != tokens[0]:\n        amountA = amount1\n        amountB = amount0\n\n    # get latest position data -- collect withdrawn tokens AND any fees (if applicable)\n    positionData = staticcall UniV3NftPositionManager(nftPositionManager).positions(_nftTokenId)\n    self._collectFees(nftPositionManager, _nftTokenId, _recipient, positionData)\n\n    # burn nft (if applicable)\n    isDepleted: bool = False\n    if positionData.liquidity == 0:\n        isDepleted = True\n        extcall UniV3NftPositionManager(nftPositionManager).burn(_nftTokenId)\n\n    # transfer nft to recipient\n    else:\n        extcall IERC721(nftPositionManager).safeTransferFrom(self, _recipient, _nftTokenId)\n\n    usdValue: uint256 = self._getUsdValue(_tokenA, amountA, _tokenB, amountB, miniAddys)\n    liquidityRemoved: uint256 = convert(originalLiquidity - positionData.liquidity, uint256)\n    log UniswapV3LiquidityRemoved(\n        sender = msg.sender,\n        pool = _pool,\n        nftTokenId = _nftTokenId,\n        tokenA = _tokenA,\n        tokenB = _tokenB,\n        amountA = amountA,\n        amountB = amountB,\n        liquidityRemoved = liquidityRemoved,\n        usdValue = usdValue,\n        recipient = _recipient,\n    )\n    return amountA, amountB, liquidityRemoved, isDepleted, usdValue\n\n\n# get usd value on liquidity actions\n\n\n@internal\ndef _getUsdValue(\n    _tokenA: address,\n    _amountA: uint256,\n    _tokenB: address,\n    _amountB: uint256,\n    _miniAddys: ws.MiniAddys,\n) -> uint256:\n\n    usdValueA: uint256 = 0\n    if _amountA != 0:\n        usdValueA = staticcall Appraiser(_miniAddys.appraiser).getUsdValue(_tokenA, _amountA, _miniAddys.missionControl, _miniAddys.legoBook, _miniAddys.ledger)\n\n    usdValueB: uint256 = 0\n    if _amountB != 0:\n        usdValueB = staticcall Appraiser(_miniAddys.appraiser).getUsdValue(_tokenB, _amountB, _miniAddys.missionControl, _miniAddys.legoBook, _miniAddys.ledger)\n\n    return usdValueA + usdValueB\n\n\n#############\n# Utilities #\n#############\n\n\n@view\n@external\ndef getLpToken(_pool: address) -> address:\n    # no lp tokens for uniswap v3\n    return empty(address)\n\n\n@view\n@external\ndef getPoolForLpToken(_lpToken: address) -> address:\n    # no lp tokens for uniswap v3\n    return empty(address)\n\n\n@view\n@external\ndef getCoreRouterPool() -> address:\n    return self.coreRouterPool\n\n\n@view\n@external\ndef getDeepestLiqPool(_tokenA: address, _tokenB: address) -> BestPool:\n    bestPoolAddr: address = empty(address)\n    bestFeeTier: uint24 = 0\n    bestPoolAddr, bestFeeTier = self._getDeepestLiqPool(_tokenA, _tokenB)\n\n    if bestPoolAddr == empty(address):\n        return empty(BestPool)\n\n    # get token balances\n    tokenABal: uint256 = staticcall IERC20(_tokenA).balanceOf(bestPoolAddr)\n    tokenBBal: uint256 = staticcall IERC20(_tokenB).balanceOf(bestPoolAddr)\n\n    return BestPool(\n        pool=bestPoolAddr,\n        fee=convert(bestFeeTier // 100, uint256), # normalize to have 100_00 denominator\n        liquidity=tokenABal + tokenBBal, # not exactly \"liquidity\" but this comparable to \"reserves\"\n        numCoins=2,\n    )\n\n\n# annoying that this cannot be view function, thanks uni v3\n@external\ndef getBestSwapAmountOut(_tokenIn: address, _tokenOut: address, _amountIn: uint256) -> (address, uint256):\n    bestPoolAddr: address = empty(address)\n    bestFeeTier: uint24 = 0\n    bestPoolAddr, bestFeeTier = self._getDeepestLiqPool(_tokenIn, _tokenOut)\n\n    if bestPoolAddr == empty(address):\n        return empty(address), 0\n\n    amountOut: uint256 = 0\n    na1: uint160 = 0\n    na2: uint32 = 0\n    na3: uint256 = 0\n    amountOut, na1, na2, na3 = extcall UniV3Quoter(UNIV3_QUOTER).quoteExactInputSingle(\n        QuoteExactInputSingleParams(\n            tokenIn=_tokenIn,\n            tokenOut=_tokenOut,\n            amountIn=_amountIn,\n            fee=bestFeeTier,\n            sqrtPriceLimitX96=0,\n        )\n    )\n    return bestPoolAddr, amountOut\n\n\n# annoying that this cannot be view function, thanks uni v3\n@external\ndef getSwapAmountOut(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n) -> uint256:\n    amountOut: uint256 = 0\n    na1: uint160 = 0\n    na2: uint32 = 0\n    na3: uint256 = 0\n    amountOut, na1, na2, na3 = extcall UniV3Quoter(UNIV3_QUOTER).quoteExactInputSingle(\n        QuoteExactInputSingleParams(\n            tokenIn=_tokenIn,\n            tokenOut=_tokenOut,\n            amountIn=_amountIn,\n            fee=staticcall UniV3Pool(_pool).fee(),\n            sqrtPriceLimitX96=0,\n        )\n    )\n    return amountOut\n\n\n# annoying that this cannot be view function, thanks uni v3\n@external\ndef getBestSwapAmountIn(_tokenIn: address, _tokenOut: address, _amountOut: uint256) -> (address, uint256):\n    if _amountOut == 0 or _amountOut == max_value(uint256):\n        return empty(address), max_value(uint256)\n\n    bestPoolAddr: address = empty(address)\n    bestFeeTier: uint24 = 0\n    bestPoolAddr, bestFeeTier = self._getDeepestLiqPool(_tokenIn, _tokenOut)\n    if bestPoolAddr == empty(address):\n        return empty(address), 0\n\n    amountIn: uint256 = 0\n    na1: uint160 = 0\n    na2: uint32 = 0\n    na3: uint256 = 0\n    amountIn, na1, na2, na3 = extcall UniV3Quoter(UNIV3_QUOTER).quoteExactOutputSingle(\n        QuoteExactOutputSingleParams(\n            tokenIn=_tokenIn,\n            tokenOut=_tokenOut,\n            amount=_amountOut,\n            fee=bestFeeTier,\n            sqrtPriceLimitX96=0,\n        )\n    )\n    return bestPoolAddr, amountIn\n\n\n# annoying that this cannot be view function, thanks uni v3\n@external\ndef getSwapAmountIn(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountOut: uint256,\n) -> uint256:\n    if _amountOut == 0 or _amountOut == max_value(uint256):\n        return max_value(uint256)\n\n    amountIn: uint256 = 0\n    na1: uint160 = 0\n    na2: uint32 = 0\n    na3: uint256 = 0\n    amountIn, na1, na2, na3 = extcall UniV3Quoter(UNIV3_QUOTER).quoteExactOutputSingle(\n        QuoteExactOutputSingleParams(\n            tokenIn=_tokenIn,\n            tokenOut=_tokenOut,\n            amount=_amountOut,\n            fee=staticcall UniV3Pool(_pool).fee(),\n            sqrtPriceLimitX96=0,\n        )\n    )\n    return amountIn\n\n\n@view\n@external\ndef getAddLiqAmountsIn(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _availAmountA: uint256,\n    _availAmountB: uint256,\n) -> (uint256, uint256, uint256):\n    token0: address = staticcall UniV3Pool(_pool).token0()\n\n    # get correct numerator and denominator\n    numerator: uint256 = 0\n    denominator: uint256 = 0\n    sqrtPriceX96Squared: uint256 = self._getSqrtPriceX96(_pool) ** 2\n    if _tokenA == token0:\n        numerator = sqrtPriceX96Squared\n        denominator = UNISWAP_Q96 ** 2\n    else:\n        numerator = UNISWAP_Q96 ** 2\n        denominator = sqrtPriceX96Squared\n\n    # calculate optimal amounts\n    amountA: uint256 = _availAmountA\n    amountB: uint256 = _availAmountA * numerator // denominator\n    if amountB > _availAmountB:\n        maybeAmountA: uint256 = _availAmountB * denominator // numerator\n        if maybeAmountA <= _availAmountA:\n            amountA = maybeAmountA\n            amountB = _availAmountB\n    return amountA, amountB, 0\n\n\n@view\n@external\ndef getRemoveLiqAmountsOut(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpAmount: uint256,\n) -> (uint256, uint256):\n    token0: address = staticcall UniV3Pool(_pool).token0()\n\n    # calculate expected amounts out\n    sqrtPriceX96: uint256 = self._getSqrtPriceX96(_pool)\n    amount0Out: uint256 = _lpAmount * UNISWAP_Q96 // sqrtPriceX96\n    amount1Out: uint256 = _lpAmount * sqrtPriceX96 // UNISWAP_Q96\n\n    # return amounts out\n    if _tokenA == token0:\n        return amount0Out, amount1Out\n    else:\n        return amount1Out, amount0Out\n\n\n@view\n@external\ndef getPrice(_asset: address, _decimals: uint256) -> uint256:\n    return 0 # TODO: implement price\n\n\n@view\n@external\ndef getPriceUnsafe(_pool: address, _targetToken: address, _appraiser: address = empty(address)) -> uint256:\n    token0: address = staticcall UniV3Pool(_pool).token0()\n    token1: address = staticcall UniV3Pool(_pool).token1()\n\n    # appraiser\n    appraiser: address = _appraiser\n    if _appraiser == empty(address):\n        appraiser = addys._getAppraiserAddr()\n\n    # alt price\n    altPrice: uint256 = 0\n    if _targetToken == token0:\n        altPrice = staticcall Appraiser(appraiser).getRipePrice(token1)\n    else:\n        altPrice = staticcall Appraiser(appraiser).getRipePrice(token0)\n\n    # return early if no alt price\n    if altPrice == 0:\n        return 0\n\n    # price of token0 in token1\n    sqrtPriceX96: uint256 = self._getSqrtPriceX96(_pool)\n    numerator: uint256 = sqrtPriceX96 ** 2 * EIGHTEEN_DECIMALS\n    priceZeroToOne: uint256 = numerator // (UNISWAP_Q96 ** 2)\n\n    # adjust for decimals: price should be in 18 decimals\n    decimals0: uint256 = convert(staticcall IERC20Detailed(token0).decimals(), uint256)\n    decimals1: uint256 = convert(staticcall IERC20Detailed(token1).decimals(), uint256)\n    if decimals0 > decimals1:\n        scaleFactor: uint256 = 10 ** (decimals0 - decimals1)\n        priceZeroToOne = priceZeroToOne * scaleFactor\n    elif decimals1 > decimals0:\n        scaleFactor: uint256 = 10 ** (decimals1 - decimals0)\n        priceZeroToOne = priceZeroToOne // scaleFactor\n\n    # if _targetToken is token1, make price inverse\n    priceToOther: uint256 = priceZeroToOne\n    if _targetToken == token1:\n        priceToOther = EIGHTEEN_DECIMALS * EIGHTEEN_DECIMALS // priceZeroToOne\n\n    return altPrice * priceToOther // EIGHTEEN_DECIMALS\n\n\n# internal utils\n\n\n@view\n@internal\ndef _getDeepestLiqPool(_tokenA: address, _tokenB: address) -> (address, uint24):\n    bestPoolAddr: address = empty(address)\n    bestFeeTier: uint24 = 0\n    bestLiquidity: uint128 = 0\n\n    factory: address = UNIV3_FACTORY\n    for i: uint256 in range(4):\n        fee: uint24 = FEE_TIERS[i]\n        pool: address = staticcall UniV3Factory(factory).getPool(_tokenA, _tokenB, fee)\n        if pool == empty(address):\n            continue\n        liquidity: uint128 = staticcall UniV3Pool(pool).liquidity()\n        if liquidity > bestLiquidity:\n            bestPoolAddr = pool\n            bestFeeTier = fee\n            bestLiquidity = liquidity\n\n    return bestPoolAddr, bestFeeTier\n\n\n@view\n@internal\ndef _getSqrtPriceX96(_pool: address) -> uint256:\n    sqrtPriceX96: uint160 = 0\n    tick: int24 = 0\n    observationIndex: uint16 = 0\n    observationCardinality: uint16 = 0\n    observationCardinalityNext: uint16 = 0\n    feeProtocol: uint8 = 0\n    unlocked: bool = False\n    sqrtPriceX96, tick, observationIndex, observationCardinality, observationCardinalityNext, feeProtocol, unlocked = staticcall UniV3Pool(_pool).slot0()\n    return convert(sqrtPriceX96, uint256)\n\n\n# nft recovery\n\n\n@external\ndef recoverNft(_collection: address, _nftTokenId: uint256, _recipient: address) -> bool:\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n\n    if staticcall IERC721(_collection).ownerOf(_nftTokenId) != self:\n        return False\n\n    extcall IERC721(_collection).safeTransferFrom(self, _recipient, _nftTokenId)\n    log UniswapV3NftRecovered(collection=_collection, nftTokenId=_nftTokenId, recipient=_recipient)\n    return True\n\n\n#########\n# Other #\n#########\n\n\n@external\ndef depositForYield(\n    _asset: address,\n    _amount: uint256,\n    _vaultAddr: address,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, address, uint256, uint256):\n    return 0, empty(address), 0, 0\n\n\n@external\ndef withdrawFromYield(\n    _vaultToken: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, address, uint256, uint256):\n    return 0, empty(address), 0, 0\n\n\n@external\ndef mintOrRedeemAsset(\n    _tokenIn: address,\n    _tokenOut: address,\n    _tokenInAmount: uint256,\n    _minAmountOut: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, bool, uint256):\n    return 0, 0, False, 0\n\n\n@external\ndef confirmMintOrRedeemAsset(\n    _tokenIn: address,\n    _tokenOut: address,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef addCollateral(\n    _asset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef removeCollateral(\n    _asset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef borrow(\n    _borrowAsset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef repayDebt(\n    _paymentAsset: address,\n    _paymentAmount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef claimRewards(\n    _user: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _extraData: bytes32,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    # backwards compatibility\n    return 0, 0\n\n\n@external\ndef claimIncentives(\n    _user: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _proofs: DynArray[bytes32, MAX_PROOFS],\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef addLiquidity(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _amountA: uint256,\n    _amountB: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _minLpAmount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (address, uint256, uint256, uint256, uint256):\n    return empty(address), 0, 0, 0, 0\n\n\n@external\ndef removeLiquidity(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpToken: address,\n    _lpAmount: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, uint256):\n    return 0, 0, 0, 0\n\n@view\n@external\ndef getAccessForLego(_user: address, _action: ws.ActionType) -> (address, String[64], uint256):\n    return empty(address), empty(String[64]), 0\n",
            "sha256sum": "d1892efafddb64d5e8c340084a2075d0331ebfb33a94f1db06016825154c96b0"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/legos/dexes/UniswapV3.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.3+commit.bff19ea2",
        "integrity": "bc69aceb37e5bdf17115cef9b1a581ee7ecd3885450773296a27ed7ff2133915"
      },
      "args": "00000000000000000000000044cf3c4f000dfd76a35d03298049d37be688d6f900000000000000000000000033128a8fc17869897dce68ed026d694621f6fdfd00000000000000000000000003a520b32c04bf3beef7beb72e919cf822ed34f10000000000000000000000003d4e44eb1374240ce5f1b871ab261cd16335b76a000000000000000000000000d0b53d9277642d899df5c87a3966a349a798f2240000000000000000000000006162df1b329e157479f8f1407e888260e0ec3d2b",
      "file": "contracts/legos/dexes/UniswapV3.vy"
    },
    "UnderscoreLego": {
      "address": "0x91bd328378E0aFAc2936B38F91D62fc8b893e741",
      "abi": [
        {
          "name": "UnderscoreEarnVaultDeposit",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountDeposited",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultTokenAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UnderscoreEarnVaultWithdrawal",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultTokenAmountBurned",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LegoPauseModified",
          "inputs": [
            {
              "name": "isPaused",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LegoFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "balance",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "SnapShotPriceConfigSet",
          "inputs": [
            {
              "name": "minSnapshotDelay",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "maxNumSnapshots",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "maxUpsideDeviation",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "staleTime",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetOpportunityAdded",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultAddr",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetOpportunityRemoved",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultAddr",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PricePerShareSnapShotAdded",
          "inputs": [
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "totalSupply",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "pricePerShare",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "lastAveragePricePerShare",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddys",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "undyToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "hatchery",
                  "type": "address"
                },
                {
                  "name": "lootDistributor",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                },
                {
                  "name": "walletBackpack",
                  "type": "address"
                },
                {
                  "name": "billing",
                  "type": "address"
                },
                {
                  "name": "vaultRegistry",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUndyHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isLegoAsset",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssetOpportunities",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isAssetOpportunity",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getNumLegoAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pause",
          "inputs": [
            {
              "name": "_shouldPause",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFundsMany",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_assets",
              "type": "address[]"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getWeightedPricePerShare",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLatestSnapshot",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_pricePerShare",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "totalSupply",
                  "type": "uint256"
                },
                {
                  "name": "pricePerShare",
                  "type": "uint256"
                },
                {
                  "name": "lastUpdate",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setSnapShotPriceConfig",
          "inputs": [
            {
              "name": "_config",
              "type": "tuple",
              "components": [
                {
                  "name": "minSnapshotDelay",
                  "type": "uint256"
                },
                {
                  "name": "maxNumSnapshots",
                  "type": "uint256"
                },
                {
                  "name": "maxUpsideDeviation",
                  "type": "uint256"
                },
                {
                  "name": "staleTime",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidPriceConfig",
          "inputs": [
            {
              "name": "_config",
              "type": "tuple",
              "components": [
                {
                  "name": "minSnapshotDelay",
                  "type": "uint256"
                },
                {
                  "name": "maxNumSnapshots",
                  "type": "uint256"
                },
                {
                  "name": "maxUpsideDeviation",
                  "type": "uint256"
                },
                {
                  "name": "staleTime",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "vaultToAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "underlyingAsset",
                  "type": "address"
                },
                {
                  "name": "decimals",
                  "type": "uint256"
                },
                {
                  "name": "lastAveragePricePerShare",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assetOpportunities",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAssetOpportunity",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssetOpportunities",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assets",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "snapShotData",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "lastSnapShot",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "totalSupply",
                      "type": "uint256"
                    },
                    {
                      "name": "pricePerShare",
                      "type": "uint256"
                    },
                    {
                      "name": "lastUpdate",
                      "type": "uint256"
                    }
                  ]
                },
                {
                  "name": "nextIndex",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "snapShots",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "totalSupply",
                  "type": "uint256"
                },
                {
                  "name": "pricePerShare",
                  "type": "uint256"
                },
                {
                  "name": "lastUpdate",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "snapShotPriceConfig",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "minSnapshotDelay",
                  "type": "uint256"
                },
                {
                  "name": "maxNumSnapshots",
                  "type": "uint256"
                },
                {
                  "name": "maxUpsideDeviation",
                  "type": "uint256"
                },
                {
                  "name": "staleTime",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isPaused",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasCapability",
          "inputs": [
            {
              "name": "_action",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRegistries",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isYieldLego",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isDexLego",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAsset",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingBalances",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenBalance",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAmount",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAmountSafe",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenBalance",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingData",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingData",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            },
            {
              "name": "_appraiser",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValueOfVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValueOfVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            },
            {
              "name": "_appraiser",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isRebasing",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPricePerShare",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPricePerShare",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_decimals",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getVaultTokenAmount",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_assetAmount",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalAssets",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalBorrows",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAvailLiquidity",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUtilizationRatio",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isEligibleForYieldBonus",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getWithdrawalFees",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canRegisterVaultToken",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "registerVaultTokenLocally",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "underlyingAsset",
                  "type": "address"
                },
                {
                  "name": "decimals",
                  "type": "uint256"
                },
                {
                  "name": "lastAveragePricePerShare",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "deregisterVaultTokenLocally",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addPriceSnapshot",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositForYield",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositForYield",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawFromYield",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawFromYield",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimIncentives",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_proofs",
              "type": "bytes32[]"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimIncentives",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_proofs",
              "type": "bytes32[]"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasClaimableRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAccessForLego",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_action",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "string"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_tokenPath",
              "type": "address[]"
            },
            {
              "name": "_poolPath",
              "type": "address[]"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_tokenPath",
              "type": "address[]"
            },
            {
              "name": "_poolPath",
              "type": "address[]"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_tokenInAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_tokenInAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmMintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmMintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_borrowAsset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_borrowAsset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_paymentAsset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_paymentAsset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "RIPE_REGISTRY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_undyHq",
              "type": "address"
            },
            {
              "name": "_ripeRegistry",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "interfaces/WalletStructs.vyi": {
            "content": "# @version 0.4.3\n\nflag ActionType:\n    TRANSFER\n    EARN_DEPOSIT\n    EARN_WITHDRAW\n    EARN_REBALANCE\n    SWAP\n    MINT_REDEEM\n    CONFIRM_MINT_REDEEM\n    ADD_COLLATERAL\n    REMOVE_COLLATERAL\n    BORROW\n    REPAY_DEBT\n    REWARDS\n    ETH_TO_WETH\n    WETH_TO_ETH\n    ADD_LIQ\n    REMOVE_LIQ\n    ADD_LIQ_CONC\n    REMOVE_LIQ_CONC\n    PAY_CHEQUE\n\nstruct WalletAssetData:\n    assetBalance: uint256\n    usdValue: uint256\n    isYieldAsset: bool\n    lastPricePerShare: uint256\n\nstruct ActionData:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    billing: address\n    vaultRegistry: address\n    wallet: address\n    walletConfig: address\n    walletOwner: address\n    inEjectMode: bool\n    isFrozen: bool\n    lastTotalUsdValue: uint256\n    signer: address\n    isManager: bool\n    legoId: uint256\n    legoAddr: address\n    eth: address\n    weth: address\n\nstruct MiniAddys:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    appraiser: address",
            "sha256sum": "466493c129135c95470aaf70eeddc936632f7b0f813396e5a7ddc03bea9da518"
          },
          "interfaces/LegoPartner.vyi": {
            "content": "# @version 0.4.3\n\nfrom interfaces import WalletStructs as ws\n\nMAX_TOKEN_PATH: constant(uint256) = 5\nMAX_RECOVER_ASSETS: constant(uint256) = 20\nMAX_PROOFS: constant(uint256) = 25\n\n@external\ndef addLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _tickLower: int24, _tickUpper: int24, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef addLiquidity(_pool: address, _tokenA: address, _tokenB: address, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _minLpAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (address, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef removeLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _liqToRemove: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef removeLiquidity(_pool: address, _tokenA: address, _tokenB: address, _lpToken: address, _lpAmount: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef mintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _tokenInAmount: uint256, _minAmountOut: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef swapTokens(_amountIn: uint256, _minAmountOut: uint256, _tokenPath: DynArray[address, MAX_TOKEN_PATH], _poolPath: DynArray[address, MAX_TOKEN_PATH - 1], _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256):\n    ...\n\n@external\ndef depositForYield(_asset: address, _amount: uint256, _vaultAddr: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef withdrawFromYield(_vaultToken: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef confirmMintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef borrow(_borrowAsset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef repayDebt(_paymentAsset: address, _paymentAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef claimIncentives(_user: address, _rewardToken: address, _rewardAmount: uint256, _proofs: DynArray[bytes32, MAX_PROOFS], _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef removeCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef addCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@view\n@external\ndef getAccessForLego(_user: address, _action: ws.ActionType) -> (address, String[64], uint256):\n    ...\n\n@view\n@external\ndef hasCapability(_action: ws.ActionType) -> bool:\n    ...\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    ...\n\n@view\n@external\ndef isYieldLego() -> bool:\n    ...\n\n@view\n@external\ndef isDexLego() -> bool:\n    ...\n\n\n# common\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "f2afb7bd72d4301aea77bbe4177b7ae954ba6f6b76af363965993eb92ad0b715"
          },
          "interfaces/LegoStructs.vyi": {
            "content": "# @version 0.4.3\n\nstruct VaultTokenInfo:\n    underlyingAsset: address\n    decimals: uint256\n    lastAveragePricePerShare: uint256\n\nstruct SnapShotPriceConfig:\n    minSnapshotDelay: uint256\n    maxNumSnapshots: uint256\n    maxUpsideDeviation: uint256\n    staleTime: uint256\n\nstruct SingleSnapShot:\n    totalSupply: uint256\n    pricePerShare: uint256\n    lastUpdate: uint256\n\nstruct SnapShotData:\n    lastSnapShot: SingleSnapShot\n    nextIndex: uint256\n",
            "sha256sum": "8ae48be17d812d57fbd671bbf0593e8abf175ad0924e47c5997823cac19ec806"
          },
          "interfaces/YieldLego.vyi": {
            "content": "# @version 0.4.3\n\nfrom interfaces import LegoStructs as ls\n\n\n###################\n# Underlying Data #\n###################\n\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    ...\n\n\n@view\n@external\ndef getUnderlyingBalances(_vaultToken: address, _vaultTokenBalance: uint256) -> (uint256, uint256):\n    ...\n\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    ...\n\n\n@view\n@external\ndef getUnderlyingAmountSafe(_vaultToken: address, _vaultTokenBalance: uint256) -> uint256:\n    ...\n\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> (address, uint256, uint256):\n    ...\n\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> uint256:\n    ...\n\n\n###############\n# Other Utils #\n###############\n\n\n@view\n@external\ndef isRebasing() -> bool:\n    ...\n\n\n@view\n@external\ndef getPricePerShare(_vaultToken: address, _decimals: uint256 = 0) -> uint256:\n    ...\n\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef canRegisterVaultToken(_asset: address, _vaultToken: address) -> bool:\n    ...\n\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef getUtilizationRatio(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef getAvailLiquidity(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef isEligibleForYieldBonus(_asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef getWithdrawalFees(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    ...\n\n\n###################\n# Yield Lego Data #\n###################\n\n\n@view\n@external\ndef isLegoAsset(_asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, 40]:\n    ...\n\n\n@view\n@external\ndef getAssets() -> DynArray[address, 20]:\n    ...\n\n\n@view\n@external\ndef isAssetOpportunity(_asset: address, _vaultAddr: address) -> bool:\n    ...\n\n\n@view\n@external\ndef getNumLegoAssets() -> uint256:\n    ...\n\n\n@view\n@external\ndef assets(_index: uint256) -> address:\n    ...\n\n\n@view\n@external\ndef indexOfAsset(_asset: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef numAssets() -> uint256:\n    ...\n\n\n@view\n@external\ndef assetOpportunities(_asset: address, _index: uint256) -> address:\n    ...\n\n\n@view\n@external\ndef indexOfAssetOpportunity(_asset: address, _vaultAddr: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef numAssetOpportunities(_asset: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef vaultToAsset(_vaultAddr: address) -> ls.VaultTokenInfo:\n    ...\n\n\n# price snapshots\n\n\n@external\ndef addPriceSnapshot(_vaultToken: address) -> bool:\n    ...\n\n\n@view\n@external\ndef snapShotPriceConfig() -> ls.SnapShotPriceConfig:\n    ...\n\n\n@view\n@external\ndef snapShotData(_vaultToken: address) -> ls.SnapShotData:\n    ...\n\n\n@view\n@external\ndef snapShots(_vaultToken: address, _index: uint256) -> ls.SingleSnapShot:\n    ...\n\n\n@view\n@external\ndef getWeightedPricePerShare(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef getLatestSnapshot(_vaultToken: address, _pricePerShare: uint256) -> ls.SingleSnapShot:\n    ...\n\n\n@external\ndef setSnapShotPriceConfig(_config: ls.SnapShotPriceConfig):\n    ...\n",
            "sha256sum": "db91c139f6018f5218b389d08c8703bc16fb994aa948805dbfea27e072f382ec"
          },
          "contracts/modules/Addys.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\ninterface UndyHq:\n    def isValidAddr(_addr: address) -> bool: view\n    def getAddr(_regId: uint256) -> address: view\n    def undyToken() -> address: view\n\ninterface Switchboard:\n    def isSwitchboardAddr(_addr: address) -> bool: view\n\ninterface LegoBook:\n    def isLegoAddr(_addr: address) -> bool: view\n\nstruct Addys:\n    hq: address\n    undyToken: address\n    ledger: address\n    missionControl: address\n    legoBook: address\n    switchboard: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    walletBackpack: address\n    billing: address\n    vaultRegistry: address\n\n# hq\nUNDY_HQ_FOR_ADDYS: immutable(address)\n\n# core addys\nLEDGER_ID: constant(uint256) = 1\nMISSION_CONTROL_ID: constant(uint256) = 2\nLEGO_BOOK_ID: constant(uint256) = 3\nSWITCHBOARD_ID: constant(uint256) = 4\nHATCHERY_ID: constant(uint256) = 5\nLOOT_DISTRIBUTOR_ID: constant(uint256) = 6\nAPPRAISER_ID: constant(uint256) = 7\nWALLET_BACKPACK_ID: constant(uint256) = 8\nBILLING_ID: constant(uint256) = 9\nVAULT_REGISTRY_ID: constant(uint256) = 10\n\n\n@deploy\ndef __init__(_undyHq: address):\n    assert _undyHq != empty(address) # dev: invalid undy hq\n    UNDY_HQ_FOR_ADDYS = _undyHq\n\n\n########\n# Core #\n########\n\n\n@view\n@external\ndef getAddys() -> Addys:\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _getAddys(_addys: Addys = empty(Addys)) -> Addys:\n    if _addys.hq != empty(address):\n        return _addys\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _generateAddys() -> Addys:\n    hq: address = UNDY_HQ_FOR_ADDYS\n    return Addys(\n        hq = hq,\n        undyToken = staticcall UndyHq(hq).undyToken(),\n        ledger = staticcall UndyHq(hq).getAddr(LEDGER_ID),\n        missionControl = staticcall UndyHq(hq).getAddr(MISSION_CONTROL_ID),\n        legoBook = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID),\n        switchboard = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID),\n        hatchery = staticcall UndyHq(hq).getAddr(HATCHERY_ID),\n        lootDistributor = staticcall UndyHq(hq).getAddr(LOOT_DISTRIBUTOR_ID),\n        appraiser = staticcall UndyHq(hq).getAddr(APPRAISER_ID),\n        walletBackpack = staticcall UndyHq(hq).getAddr(WALLET_BACKPACK_ID),\n        billing = staticcall UndyHq(hq).getAddr(BILLING_ID),\n        vaultRegistry = staticcall UndyHq(hq).getAddr(VAULT_REGISTRY_ID),\n    )\n\n\n##########\n# Tokens #\n##########\n\n\n@view\n@internal\ndef _getUndyToken() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).undyToken()\n\n\n###########\n# Helpers #\n###########\n\n\n# undy hq\n\n\n@view\n@external\ndef getUndyHq() -> address:\n    return self._getUndyHq()\n\n\n@view\n@internal\ndef _getUndyHq() -> address:\n    return UNDY_HQ_FOR_ADDYS\n\n\n# utils\n\n\n@view\n@internal\ndef _isValidUndyAddr(_addr: address, _hq: address = empty(address)) -> bool:\n    hq: address = _hq\n    if _hq == empty(address):\n        hq = UNDY_HQ_FOR_ADDYS\n    \n    # core departments\n    if staticcall UndyHq(hq).isValidAddr(_addr):\n        return True\n\n    # lego book\n    legoBook: address = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID)\n    if legoBook != empty(address) and staticcall LegoBook(legoBook).isLegoAddr(_addr):\n        return True\n\n    # switchboard config\n    switchboard: address = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID)\n    if switchboard != empty(address) and staticcall Switchboard(switchboard).isSwitchboardAddr(_addr):\n        return True\n\n    return False\n\n\n@view\n@internal\ndef _isSwitchboardAddr(_addr: address) -> bool:\n    switchboard: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n    if switchboard == empty(address):\n        return False\n    return staticcall Switchboard(switchboard).isSwitchboardAddr(_addr)\n\n\n@view\n@internal\ndef _isLegoBookAddr(_addr: address) -> bool:\n    legoBook: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n    if legoBook == empty(address):\n        return False\n    return staticcall LegoBook(legoBook).isLegoAddr(_addr)\n\n\n###############\n# Departments #\n###############\n\n\n# ledger\n\n\n@view\n@internal\ndef _getLedgerId() -> uint256:\n    return LEDGER_ID\n\n\n@view\n@internal\ndef _getLedgerAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEDGER_ID)\n\n\n# mission control\n\n\n@view\n@internal\ndef _getMissionControlId() -> uint256:\n    return MISSION_CONTROL_ID\n\n\n@view\n@internal\ndef _getMissionControlAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(MISSION_CONTROL_ID)\n\n\n# lego book\n\n\n@view\n@internal\ndef _getLegoBookId() -> uint256:\n    return LEGO_BOOK_ID\n\n\n@view\n@internal\ndef _getLegoBookAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n\n\n# switchboard\n\n\n@view\n@internal\ndef _getSwitchboardId() -> uint256:\n    return SWITCHBOARD_ID\n\n\n@view\n@internal\ndef _getSwitchboardAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n\n\n# hatchery\n\n\n@view\n@internal\ndef _getHatcheryId() -> uint256:\n    return HATCHERY_ID\n\n\n@view\n@internal\ndef _getHatcheryAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(HATCHERY_ID)\n\n\n# loot distributor\n\n\n@view\n@internal\ndef _getLootDistributorId() -> uint256:\n    return LOOT_DISTRIBUTOR_ID\n\n\n@view\n@internal\ndef _getLootDistributorAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LOOT_DISTRIBUTOR_ID)\n\n\n# appraiser\n\n\n@view\n@internal\ndef _getAppraiserId() -> uint256:\n    return APPRAISER_ID\n\n\n@view\n@internal\ndef _getAppraiserAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(APPRAISER_ID)\n\n\n# wallet backpack\n\n\n@view\n@internal\ndef _getWalletBackpackId() -> uint256:\n    return WALLET_BACKPACK_ID\n\n\n@view\n@internal\ndef _getWalletBackpackAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(WALLET_BACKPACK_ID)\n\n\n# billing\n\n\n@view\n@internal\ndef _getBillingId() -> uint256:\n    return BILLING_ID\n\n\n@view\n@internal\ndef _getBillingAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(BILLING_ID)\n\n\n# vault registry\n\n\n@view\n@internal\ndef _getVaultRegistryId() -> uint256:\n    return VAULT_REGISTRY_ID\n\n\n@view\n@internal\ndef _getVaultRegistryAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(VAULT_REGISTRY_ID)",
            "sha256sum": "4df6b72db9bb417d1af81660175be1450cfb7b3575f3d17a5b8a130bff87b781"
          },
          "contracts/modules/YieldLegoData.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nuses: addys\n\nimport contracts.modules.Addys as addys\n\nfrom interfaces import WalletStructs as ws\nfrom interfaces import LegoStructs as ls\nfrom ethereum.ercs import IERC20\nfrom ethereum.ercs import IERC20Detailed\n\nevent AssetOpportunityAdded:\n    asset: indexed(address)\n    vaultAddr: indexed(address)\n\nevent AssetOpportunityRemoved:\n    asset: indexed(address)\n    vaultAddr: indexed(address)\n\nevent LegoPauseModified:\n    isPaused: bool\n\nevent LegoFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    balance: uint256\n\nevent PricePerShareSnapShotAdded:\n    vaultToken: indexed(address)\n    totalSupply: uint256\n    pricePerShare: uint256\n    lastAveragePricePerShare: uint256\n\nevent SnapShotPriceConfigSet:\n    minSnapshotDelay: uint256\n    maxNumSnapshots: uint256\n    maxUpsideDeviation: uint256\n    staleTime: uint256\n\n# core\nvaultToAsset: public(HashMap[address, ls.VaultTokenInfo]) # vault addr -> data\n\n# asset opportunities\nassetOpportunities: public(HashMap[address, HashMap[uint256, address]]) # asset -> index -> vault addr\nindexOfAssetOpportunity: public(HashMap[address, HashMap[address, uint256]]) # asset -> vault addr -> index\nnumAssetOpportunities: public(HashMap[address, uint256]) # asset -> number of opportunities\n\n# lego assets (iterable)\nassets: public(HashMap[uint256, address]) # index -> asset\nindexOfAsset: public(HashMap[address, uint256]) # asset -> index\nnumAssets: public(uint256) # num assets\n\n# price snapshots\nsnapShotData: public(HashMap[address, ls.SnapShotData]) # vault token -> data\nsnapShots: public(HashMap[address, HashMap[uint256, ls.SingleSnapShot]]) # vault token -> index -> snapshot\nsnapShotPriceConfig: public(ls.SnapShotPriceConfig) # config\n\nisPaused: public(bool)\n\nMAX_VAULTS: constant(uint256) = 40\nMAX_ASSETS: constant(uint256) = 20\nMAX_RECOVER_ASSETS: constant(uint256) = 20\nONE_DAY_SECONDS: constant(uint256) = 60 * 60 * 24\nONE_WEEK_SECONDS: constant(uint256) = ONE_DAY_SECONDS * 7\nHUNDRED_PERCENT: constant(uint256) = 100_00\n\n\n@deploy\ndef __init__(_shouldPause: bool):\n    self.isPaused = _shouldPause\n    self.numAssets = 1 # not using 0 index\n\n    # default snapshot price config\n    self.snapShotPriceConfig = ls.SnapShotPriceConfig(\n        minSnapshotDelay = 60 * 10, # 10 minutes\n        maxNumSnapshots = 20,\n        maxUpsideDeviation = 10_00, # 10%\n        staleTime = ONE_DAY_SECONDS, # 1 day\n    )\n\n\n#########\n# Views #\n#########\n\n\n# is lego asset\n\n\n@view\n@external\ndef isLegoAsset(_asset: address) -> bool:\n    return self._isLegoAsset(_asset)\n\n\n@view\n@internal\ndef _isLegoAsset(_asset: address) -> bool:\n    return self.indexOfAsset[_asset] != 0\n\n\n# vault opportunities\n\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, MAX_VAULTS]:\n    numOpportunities: uint256 = self.numAssetOpportunities[_asset]\n    if numOpportunities == 0:\n        return []\n    opportunities: DynArray[address, MAX_VAULTS] = []\n    for i: uint256 in range(1, numOpportunities, bound=MAX_VAULTS):\n        opportunities.append(self.assetOpportunities[_asset][i])\n    return opportunities\n\n\n# all assets registered\n\n\n@view\n@external\ndef getAssets() -> DynArray[address, MAX_ASSETS]:\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return []\n    assets: DynArray[address, MAX_ASSETS] = []\n    for i: uint256 in range(1, numAssets, bound=MAX_ASSETS):\n        assets.append(self.assets[i])\n    return assets\n\n\n################\n# Registration #\n################\n\n\n@view\n@external\ndef isAssetOpportunity(_asset: address, _vaultAddr: address) -> bool:\n    return self._isAssetOpportunity(_asset, _vaultAddr)\n\n\n@view\n@internal\ndef _isAssetOpportunity(_asset: address, _vaultAddr: address) -> bool:\n    return self.indexOfAssetOpportunity[_asset][_vaultAddr] != 0\n\n\n# add asset opportunity\n\n\n@internal\ndef _addAssetOpportunity(_asset: address, _vaultAddr: address) -> ls.VaultTokenInfo:\n    if self.indexOfAssetOpportunity[_asset][_vaultAddr] != 0:\n        return self.vaultToAsset[_vaultAddr]\n\n    if empty(address) in [_asset, _vaultAddr]:\n        return empty(ls.VaultTokenInfo)\n\n    # add asset opportunity\n    aid: uint256 = self.numAssetOpportunities[_asset]\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.assetOpportunities[_asset][aid] = _vaultAddr\n    self.indexOfAssetOpportunity[_asset][_vaultAddr] = aid\n    self.numAssetOpportunities[_asset] = aid + 1\n\n    # add mapping\n    vaultInfo: ls.VaultTokenInfo = ls.VaultTokenInfo(\n        underlyingAsset = _asset,\n        decimals = convert(staticcall IERC20Detailed(_vaultAddr).decimals(), uint256),\n        lastAveragePricePerShare = 0,\n    )\n    self.vaultToAsset[_vaultAddr] = vaultInfo\n\n    # add asset\n    self._addAsset(_asset)\n\n    log AssetOpportunityAdded(asset=_asset, vaultAddr=_vaultAddr)\n    return vaultInfo\n\n\n# remove asset opportunity\n\n\n@internal\ndef _removeAssetOpportunity(_asset: address, _vaultAddr: address):\n    numOpportunities: uint256 = self.numAssetOpportunities[_asset]\n    if numOpportunities == 0:\n        return\n\n    targetIndex: uint256 = self.indexOfAssetOpportunity[_asset][_vaultAddr]\n    if targetIndex == 0:\n        return\n\n    # update data\n    lastIndex: uint256 = numOpportunities - 1\n    self.numAssetOpportunities[_asset] = lastIndex\n    self.indexOfAssetOpportunity[_asset][_vaultAddr] = 0\n\n    self.vaultToAsset[_vaultAddr] = empty(ls.VaultTokenInfo)\n\n    # clear all snapshot data for the vault token to prevent contamination on re-add\n    self.snapShotData[_vaultAddr] = empty(ls.SnapShotData)\n\n    # clear all historical snapshots\n    config: ls.SnapShotPriceConfig = self.snapShotPriceConfig\n    for i: uint256 in range(config.maxNumSnapshots, bound=max_value(uint256)):\n        if i >= config.maxNumSnapshots:\n            break\n        self.snapShots[_vaultAddr][i] = empty(ls.SingleSnapShot)\n\n    # shift to replace the removed one\n    if targetIndex != lastIndex:\n        lastVaultAddr: address = self.assetOpportunities[_asset][lastIndex]\n        self.assetOpportunities[_asset][targetIndex] = lastVaultAddr\n        self.indexOfAssetOpportunity[_asset][lastVaultAddr] = targetIndex\n\n    # remove asset\n    if lastIndex <= 1:\n        self._removeAsset(_asset)\n\n    log AssetOpportunityRemoved(asset=_asset, vaultAddr=_vaultAddr)\n\n\n# add asset\n\n\n@internal\ndef _addAsset(_asset: address):\n    if self.indexOfAsset[_asset] != 0:\n        return\n\n    aid: uint256 = self.numAssets\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.assets[aid] = _asset\n    self.indexOfAsset[_asset] = aid\n    self.numAssets = aid + 1\n\n\n# remove asset\n\n\n@internal\ndef _removeAsset(_asset: address):\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return\n\n    targetIndex: uint256 = self.indexOfAsset[_asset]\n    if targetIndex == 0:\n        return\n\n    # update data\n    lastIndex: uint256 = numAssets - 1\n    self.numAssets = lastIndex\n    self.indexOfAsset[_asset] = 0\n\n    # shift to replace the removed one\n    if targetIndex != lastIndex:\n        lastAsset: address = self.assets[lastIndex]\n        self.assets[targetIndex] = lastAsset\n        self.indexOfAsset[lastAsset] = targetIndex\n\n\n# num lego assets (true number, use `numAssets` for iteration)\n\n\n@view\n@external\ndef getNumLegoAssets() -> uint256:\n    return self._getNumLegoAssets()\n\n\n@view\n@internal\ndef _getNumLegoAssets() -> uint256:\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return 0\n    return numAssets - 1\n\n\n###########\n# General #\n###########\n\n\n# fill mini addys\n\n\n@view\n@internal\ndef _getMiniAddys(_miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> ws.MiniAddys:\n    if _miniAddys.ledger != empty(address):\n        return _miniAddys\n    return ws.MiniAddys(\n        ledger = addys._getLedgerAddr(),\n        missionControl = addys._getMissionControlAddr(),\n        legoBook = addys._getLegoBookAddr(),\n        appraiser = addys._getAppraiserAddr(),\n    )\n\n\n# activate\n\n\n@external\ndef pause(_shouldPause: bool):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert _shouldPause != self.isPaused # dev: no change\n    self.isPaused = _shouldPause\n    log LegoPauseModified(isPaused=_shouldPause)\n\n\n# recover funds\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    self._recoverFunds(_recipient, _asset)\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, MAX_RECOVER_ASSETS]):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    for a: address in _assets:\n        self._recoverFunds(_recipient, a)\n\n\n@internal\ndef _recoverFunds(_recipient: address, _asset: address):\n    assert empty(address) not in [_recipient, _asset] # dev: invalid recipient or asset\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    assert balance != 0 # dev: nothing to recover\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log LegoFundsRecovered(asset=_asset, recipient=_recipient, balance=balance)\n\n\n###################\n# Price Snapshots #\n###################\n\n\n# add price snapshot\n\n\n@internal\ndef _addPriceSnapshot(_vaultToken: address, _pricePerShare: uint256, _vaultTokenDecimals: uint256) -> bool:\n    config: ls.SnapShotPriceConfig = self.snapShotPriceConfig\n    if config.maxNumSnapshots == 0:\n        return False\n\n    data: ls.SnapShotData = self.snapShotData[_vaultToken]\n\n    # already have snapshot for this time\n    if data.lastSnapShot.lastUpdate == block.timestamp:\n        return False\n\n    # check if snapshot is too recent\n    if data.lastSnapShot.lastUpdate + config.minSnapshotDelay > block.timestamp:\n        return False\n\n    # create and store new snapshot\n    newSnapshot: ls.SingleSnapShot = self._getLatestSnapshot(_vaultToken, _pricePerShare, _vaultTokenDecimals, data.lastSnapShot, config)\n    data.lastSnapShot = newSnapshot\n    self.snapShots[_vaultToken][data.nextIndex] = newSnapshot\n\n    # update index\n    data.nextIndex += 1\n    if data.nextIndex >= config.maxNumSnapshots:\n        data.nextIndex = 0\n\n    # save snap shot data\n    self.snapShotData[_vaultToken] = data\n\n    # update cached weighted average price per share\n    lastAveragePricePerShare: uint256 = self._getWeightedPricePerShare(_vaultToken, _pricePerShare)\n    self.vaultToAsset[_vaultToken].lastAveragePricePerShare = lastAveragePricePerShare\n\n    log PricePerShareSnapShotAdded(\n        vaultToken = _vaultToken,\n        totalSupply = newSnapshot.totalSupply,\n        pricePerShare = newSnapshot.pricePerShare,\n        lastAveragePricePerShare = lastAveragePricePerShare,\n    )\n    return True\n\n\n# weighted price per share\n\n\n@view\n@external\ndef getWeightedPricePerShare(_vaultToken: address) -> uint256:\n    data: ls.SnapShotData = self.snapShotData[_vaultToken]\n    return self._getWeightedPricePerShare(_vaultToken, data.lastSnapShot.pricePerShare)\n\n\n@view\n@internal\ndef _getWeightedPricePerShare(_vaultToken: address, _lastPricePerShare: uint256) -> uint256:\n    config: ls.SnapShotPriceConfig = self.snapShotPriceConfig\n    if config.maxNumSnapshots == 0:\n        return 0\n\n    # calculate weighted average price using all valid snapshots\n    numerator: uint256 = 0\n    denominator: uint256 = 0\n    for i: uint256 in range(config.maxNumSnapshots, bound=max_value(uint256)):\n\n        snapShot: ls.SingleSnapShot = self.snapShots[_vaultToken][i]\n        if snapShot.pricePerShare == 0 or snapShot.totalSupply == 0 or snapShot.lastUpdate == 0:\n            continue\n\n        # too stale, skip\n        if config.staleTime != 0 and block.timestamp > snapShot.lastUpdate + config.staleTime:\n            continue\n\n        numerator += (snapShot.totalSupply * snapShot.pricePerShare)\n        denominator += snapShot.totalSupply\n\n    # weighted price per share\n    weightedPricePerShare: uint256 = 0\n    if numerator != 0:\n        weightedPricePerShare = numerator // denominator\n    else:\n        weightedPricePerShare = _lastPricePerShare\n\n    return weightedPricePerShare\n\n\n# latest snapshot\n\n\n@view\n@external\ndef getLatestSnapshot(_vaultToken: address, _pricePerShare: uint256) -> ls.SingleSnapShot:\n    data: ls.SnapShotData = self.snapShotData[_vaultToken]\n    config: ls.SnapShotPriceConfig = self.snapShotPriceConfig\n    vaultTokenDecimals: uint256 = self.vaultToAsset[_vaultToken].decimals\n    return self._getLatestSnapshot(_vaultToken, _pricePerShare, vaultTokenDecimals, data.lastSnapShot, config)\n\n\n@view\n@internal\ndef _getLatestSnapshot(\n    _vaultToken: address,\n    _pricePerShare: uint256,\n    _vaultTokenDecimals: uint256,\n    _lastSnapShot: ls.SingleSnapShot,\n    _config: ls.SnapShotPriceConfig,\n) -> ls.SingleSnapShot:\n\n    # total supply (adjusted)\n    totalSupply: uint256 = staticcall IERC20(_vaultToken).totalSupply() // (10 ** _vaultTokenDecimals)\n    if totalSupply == 0:\n        totalSupply = 1\n\n    # throttle upside (extra safety check)\n    pricePerShare: uint256 = self._throttleUpside(_pricePerShare, _lastSnapShot.pricePerShare, _config.maxUpsideDeviation)\n\n    return ls.SingleSnapShot(\n        totalSupply = totalSupply,\n        pricePerShare = pricePerShare,\n        lastUpdate = block.timestamp,\n    )\n\n\n@view\n@internal\ndef _throttleUpside(_newValue: uint256, _prevValue: uint256, _maxUpside: uint256) -> uint256:\n    if _maxUpside == 0 or _prevValue == 0 or _newValue == 0:\n        return _newValue\n    maxPricePerShare: uint256 = _prevValue + (_prevValue * _maxUpside // HUNDRED_PERCENT)\n    return min(_newValue, maxPricePerShare)\n\n\n# snapshot price config\n\n\n@external\ndef setSnapShotPriceConfig(_config: ls.SnapShotPriceConfig):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert self._isValidPriceConfig(_config) # dev: invalid config\n    self.snapShotPriceConfig = _config\n    log SnapShotPriceConfigSet(\n        minSnapshotDelay=_config.minSnapshotDelay,\n        maxNumSnapshots=_config.maxNumSnapshots,\n        maxUpsideDeviation=_config.maxUpsideDeviation,\n        staleTime=_config.staleTime\n    )\n\n\n@view\n@external\ndef isValidPriceConfig(_config: ls.SnapShotPriceConfig) -> bool:\n    return self._isValidPriceConfig(_config)\n\n\n@view\n@internal\ndef _isValidPriceConfig(_config: ls.SnapShotPriceConfig) -> bool:\n    if _config.minSnapshotDelay > ONE_WEEK_SECONDS:\n        return False\n    if _config.maxNumSnapshots == 0 or _config.maxNumSnapshots > 25:\n        return False\n    if _config.maxUpsideDeviation > HUNDRED_PERCENT:\n        return False\n    return _config.staleTime < ONE_WEEK_SECONDS",
            "sha256sum": "50440c96dc8a7af22e7ad927bb6d3e308f137d5d3632e633e084b05510c94c28"
          },
          "contracts/legos/UnderscoreLego.vy": {
            "content": "#     __   __ ___ _______ ___     ______       ___     _______ _______ _______ \n#    |  | |  |   |       |   |   |      |     |   |   |       |       |       |\n#    |  |_|  |   |    ___|   |   |  _    |    |   |   |    ___|    ___|   _   |\n#    |       |   |   |___|   |   | | |   |    |   |   |   |___|   | __|  | |  |\n#    |_     _|   |    ___|   |___| |_|   |    |   |___|    ___|   ||  |  |_|  |\n#      |   | |   |   |___|       |       |    |       |   |___|   |_| |       |\n#      |___| |___|_______|_______|______|     |_______|_______|_______|_______|\n#                                                                       \n#     \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n#     \u2551  ** Underscore Lego **                    \u2551\n#     \u2551  Integration with Underscore Protocol     \u2551\n#     \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n#\n#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nimplements: Lego\nimplements: YieldLego\n\nexports: addys.__interface__\nexports: yld.__interface__\n\ninitializes: addys\ninitializes: yld[addys := addys]\n\nfrom interfaces import LegoPartner as Lego\nfrom interfaces import YieldLego as YieldLego\nfrom interfaces import WalletStructs as ws\nfrom interfaces import LegoStructs as ls\n\nimport contracts.modules.Addys as addys\nimport contracts.modules.YieldLegoData as yld\n\nfrom ethereum.ercs import IERC20\nfrom ethereum.ercs import IERC4626\nfrom ethereum.ercs import IERC20Detailed\n\ninterface LootDistributor:\n    def claimRevShareAndBonusLoot(_user: address) -> uint256: nonpayable\n    def getClaimableDepositRewards(_user: address) -> uint256: view\n    def claimDepositRewards(_user: address) -> uint256: nonpayable\n    def getTotalClaimableAssets(_user: address) -> uint256: view\n\ninterface Ledger:\n    def setVaultToken(_vaultToken: address, _legoId: uint256, _underlyingAsset: address, _decimals: uint256, _isRebasing: bool): nonpayable\n    def isRegisteredVaultToken(_vaultToken: address) -> bool: view\n    def isUserWallet(_user: address) -> bool: view\n\ninterface Registry:\n    def getRegId(_addr: address) -> uint256: view\n    def isValidAddr(_addr: address) -> bool: view\n\ninterface Appraiser:\n    def getUnderlyingUsdValue(_asset: address, _amount: uint256) -> uint256: view\n\ninterface VaultRegistry:\n    def isEarnVault(_vaultAddr: address) -> bool: view\n\ninterface RipeRegistry:\n    def ripeToken() -> address: view\n\nevent UnderscoreEarnVaultDeposit:\n    sender: indexed(address)\n    asset: indexed(address)\n    vaultToken: indexed(address)\n    assetAmountDeposited: uint256\n    usdValue: uint256\n    vaultTokenAmountReceived: uint256\n    recipient: address\n\nevent UnderscoreEarnVaultWithdrawal:\n    sender: indexed(address)\n    asset: indexed(address)\n    vaultToken: indexed(address)\n    assetAmountReceived: uint256\n    usdValue: uint256\n    vaultTokenAmountBurned: uint256\n    recipient: address\n\nRIPE_REGISTRY: public(immutable(address))\nRIPE_TOKEN: immutable(address)\n\nMAX_TOKEN_PATH: constant(uint256) = 5\nMAX_PROOFS: constant(uint256) = 25\n\n\n@deploy\ndef __init__(_undyHq: address, _ripeRegistry: address):\n    addys.__init__(_undyHq)\n    yld.__init__(False)\n\n    assert _ripeRegistry != empty(address) # dev: invalid addrs\n    RIPE_REGISTRY = _ripeRegistry\n    RIPE_TOKEN = staticcall RipeRegistry(_ripeRegistry).ripeToken()\n\n\n@view\n@external\ndef hasCapability(_action: ws.ActionType) -> bool:\n    return _action in (\n        ws.ActionType.EARN_DEPOSIT | \n        ws.ActionType.EARN_WITHDRAW |\n        ws.ActionType.REWARDS\n    )\n\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    return [addys._getVaultRegistryAddr()]\n\n\n@view\n@external\ndef isYieldLego() -> bool:\n    return True\n\n\n@view\n@external\ndef isDexLego() -> bool:\n    return False\n\n\n###################\n# Underlying Data #\n###################\n\n\n# underlying asset\n\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    return self._getUnderlyingAsset(_vaultToken)\n\n\n@view\n@internal\ndef _getUnderlyingAsset(_vaultToken: address) -> address:\n    asset: address = yld.vaultToAsset[_vaultToken].underlyingAsset\n    if asset != empty(address):\n        return asset\n    return staticcall IERC4626(_vaultToken).asset()\n\n\n# underlying balances (both true and safe)\n\n\n@view\n@external\ndef getUnderlyingBalances(_vaultToken: address, _vaultTokenBalance: uint256) -> (uint256, uint256):\n    if _vaultTokenBalance == 0:\n        return 0, 0\n\n    trueUnderlying: uint256 = self._getUnderlyingAmount(_vaultToken, _vaultTokenBalance)\n    safeUnderlying: uint256 = self._getUnderlyingAmountSafe(_vaultToken, _vaultTokenBalance)\n    if safeUnderlying == 0:\n        safeUnderlying = trueUnderlying\n\n    return trueUnderlying, min(trueUnderlying, safeUnderlying)\n\n\n# underlying amount (true)\n\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    return self._getUnderlyingAmount(_vaultToken, _vaultTokenAmount)\n\n\n@view\n@internal\ndef _getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    return staticcall IERC4626(_vaultToken).convertToAssets(_vaultTokenAmount)\n\n\n# underlying amount (safe)\n\n\n@view\n@external\ndef getUnderlyingAmountSafe(_vaultToken: address, _vaultTokenBalance: uint256) -> uint256:\n    return self._getUnderlyingAmountSafe(_vaultToken, _vaultTokenBalance)\n\n\n@view\n@internal\ndef _getUnderlyingAmountSafe(_vaultToken: address, _vaultTokenBalance: uint256) -> uint256:\n    vaultInfo: ls.VaultTokenInfo = yld.vaultToAsset[_vaultToken]\n    if vaultInfo.decimals == 0:\n        return 0 # not registered\n\n    # safe underlying amount (using cached weighted average from snapshots)\n    return _vaultTokenBalance * vaultInfo.lastAveragePricePerShare // (10 ** vaultInfo.decimals)\n\n\n# underlying data (combined)\n\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> (address, uint256, uint256):\n    return self._getUnderlyingData(_vaultToken, _vaultTokenAmount, _appraiser)\n\n\n@view\n@internal\ndef _getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address) -> (address, uint256, uint256):\n    asset: address = self._getUnderlyingAsset(_vaultToken)\n    if asset == empty(address):\n        return empty(address), 0, 0 # invalid vault token\n    underlyingAmount: uint256 = self._getUnderlyingAmount(_vaultToken, _vaultTokenAmount)\n    usdValue: uint256 = self._getUsdValue(asset, underlyingAmount, _appraiser)\n    return asset, underlyingAmount, usdValue\n\n\n# usd value\n\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> uint256:\n    return self._getUsdValueOfVaultToken(_vaultToken, _vaultTokenAmount, _appraiser)\n\n\n@view\n@internal\ndef _getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address) -> uint256:\n    return self._getUnderlyingData(_vaultToken, _vaultTokenAmount, _appraiser)[2]\n\n\n@view\n@internal\ndef _getUsdValue(_asset: address, _amount: uint256, _appraiser: address) -> uint256:\n    appraiser: address = _appraiser\n    if _appraiser == empty(address):\n        appraiser = addys._getAppraiserAddr()\n    return staticcall Appraiser(appraiser).getUnderlyingUsdValue(_asset, _amount)\n\n\n###############\n# Other Utils #\n###############\n\n\n# basics\n\n\n@view\n@external\ndef isRebasing() -> bool:\n    return self._isRebasing()\n\n\n@view\n@internal\ndef _isRebasing() -> bool:\n    return False\n\n\n# price per share\n\n\n@view\n@external\ndef getPricePerShare(_vaultToken: address, _decimals: uint256 = 0) -> uint256:\n    decimals: uint256 = _decimals\n    if decimals == 0:\n        decimals = yld.vaultToAsset[_vaultToken].decimals\n    if decimals == 0:\n        decimals = convert(staticcall IERC20Detailed(_vaultToken).decimals(), uint256)\n    return self._getPricePerShare(_vaultToken, decimals)\n\n\n@view\n@internal\ndef _getPricePerShare(_vaultToken: address, _decimals: uint256) -> uint256:\n    return staticcall IERC4626(_vaultToken).convertToAssets(10 ** _decimals)\n\n\n# vault token amount\n\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    return staticcall IERC4626(_vaultToken).convertToShares(_assetAmount)\n\n\n# total assets\n\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    return staticcall IERC4626(_vaultToken).totalAssets()\n\n\n# total borrows\n\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    # no borrowing related to _vaultToken\n    return 0\n\n\n# avail liquidity\n\n\n@view\n@external\ndef getAvailLiquidity(_vaultToken: address) -> uint256:\n    return staticcall IERC4626(_vaultToken).totalAssets()\n\n\n# utilization\n\n\n@view\n@external\ndef getUtilizationRatio(_vaultToken: address) -> uint256:\n    # no borrowing related to _vaultToken\n    return 0\n\n\n# extras\n\n\n@view\n@external\ndef isEligibleForYieldBonus(_asset: address) -> bool:\n    return True # !\n\n\n@view\n@external\ndef getWithdrawalFees(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    return 0\n\n\n################\n# Registration #\n################\n\n\n# can vault be registered\n\n\n@view\n@external\ndef canRegisterVaultToken(_asset: address, _vaultToken: address) -> bool:\n    return self._canRegisterVaultToken(_asset, _vaultToken)\n\n\n@view\n@internal\ndef _canRegisterVaultToken(_asset: address, _vaultToken: address) -> bool:\n    if empty(address) in [_asset, _vaultToken]:\n        return False\n    if staticcall IERC4626(_vaultToken).asset() != _asset:\n        return False\n    return staticcall VaultRegistry(addys._getVaultRegistryAddr()).isEarnVault(_vaultToken)\n\n\n# register vault token locally\n\n\n@external\ndef registerVaultTokenLocally(_asset: address, _vaultAddr: address) -> ls.VaultTokenInfo:\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert self._canRegisterVaultToken(_asset, _vaultAddr) # dev: cannot register vault token\n    assert not yld._isAssetOpportunity(_asset, _vaultAddr) # dev: already registered\n    vaultInfo: ls.VaultTokenInfo = self._registerVaultTokenLocally(_asset, _vaultAddr)\n    self._registerVaultTokenGlobally(_asset, _vaultAddr, vaultInfo.decimals, addys._getLedgerAddr(), addys._getLegoBookAddr())\n    return vaultInfo\n\n\n@internal\ndef _registerVaultTokenLocally(_asset: address, _vaultAddr: address) -> ls.VaultTokenInfo:\n    assert extcall IERC20(_asset).approve(_vaultAddr, max_value(uint256), default_return_value=True) # dev: max approval failed\n    vaultInfo: ls.VaultTokenInfo = yld._addAssetOpportunity(_asset, _vaultAddr)\n    assert vaultInfo.decimals != 0 # dev: invalid vault token\n    return vaultInfo\n\n\n# remove vault token locally\n\n\n@external\ndef deregisterVaultTokenLocally(_asset: address, _vaultAddr: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert yld._isAssetOpportunity(_asset, _vaultAddr) # dev: already registered\n    self._deregisterVaultTokenLocally(_asset, _vaultAddr)\n\n\n@internal\ndef _deregisterVaultTokenLocally(_asset: address, _vaultAddr: address):\n    assert extcall IERC20(_asset).approve(_vaultAddr, 0, default_return_value=True) # dev: max approval failed\n    yld._removeAssetOpportunity(_asset, _vaultAddr)\n\n\n# ledger registration\n\n\n@internal\ndef _registerVaultTokenGlobally(_underlyingAsset: address, _vaultToken: address, _decimals: uint256, _ledger: address, _legoBook: address):\n    if not staticcall Ledger(_ledger).isRegisteredVaultToken(_vaultToken):\n        legoId: uint256 = staticcall Registry(_legoBook).getRegId(self)\n        extcall Ledger(_ledger).setVaultToken(_vaultToken, legoId, _underlyingAsset, _decimals, self._isRebasing())\n\n\n#################\n# Yield Actions #\n#################\n\n\n# access control\n\n\n@view\n@internal\ndef _isAllowedToPerformAction(_caller: address) -> bool:\n    # NOTE: important to not trust `_miniAddys` here, that's why getting ledger and vault registry from addys\n    if staticcall VaultRegistry(addys._getVaultRegistryAddr()).isEarnVault(_caller):\n        return True\n    if staticcall Ledger(addys._getLedgerAddr()).isUserWallet(_caller):\n        return True\n    return staticcall Registry(RIPE_REGISTRY).isValidAddr(_caller) # Ripe Endaoment is allowed\n\n\n# add price snapshot\n\n\n@external\ndef addPriceSnapshot(_vaultToken: address) -> bool:\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    vaultInfo: ls.VaultTokenInfo = yld.vaultToAsset[_vaultToken]\n    assert vaultInfo.decimals != 0 # dev: not registered\n    pricePerShare: uint256 = self._getPricePerShare(_vaultToken, vaultInfo.decimals)\n    return yld._addPriceSnapshot(_vaultToken, pricePerShare, vaultInfo.decimals)\n\n\n# deposit\n\n\n@external\ndef depositForYield(\n    _asset: address,\n    _amount: uint256,\n    _vaultAddr: address,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, address, uint256, uint256):\n    assert self._isAllowedToPerformAction(msg.sender) # dev: no perms\n    assert not yld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = yld._getMiniAddys(_miniAddys)\n    vaultInfo: ls.VaultTokenInfo = self._getVaultInfoOnDeposit(_asset, _vaultAddr, miniAddys.ledger, miniAddys.legoBook)\n\n    # pre balances\n    preLegoBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n\n    # transfer deposit asset to this contract\n    depositAmount: uint256 = min(_amount, staticcall IERC20(_asset).balanceOf(msg.sender))\n    assert depositAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_asset).transferFrom(msg.sender, self, depositAmount, default_return_value=True) # dev: transfer failed\n\n    # deposit assets into lego partner\n    vaultTokenAmountReceived: uint256 = extcall IERC4626(_vaultAddr).deposit(depositAmount, _recipient)\n    assert vaultTokenAmountReceived != 0 # dev: no vault tokens received\n\n    # refund if full deposit didn't get through\n    currentLegoBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    refundAssetAmount: uint256 = 0\n    if currentLegoBalance > preLegoBalance:\n        refundAssetAmount = currentLegoBalance - preLegoBalance\n        assert extcall IERC20(_asset).transfer(msg.sender, refundAssetAmount, default_return_value=True) # dev: transfer failed\n        depositAmount -= refundAssetAmount\n\n    usdValue: uint256 = staticcall Appraiser(miniAddys.appraiser).getUnderlyingUsdValue(_asset, depositAmount)\n    log UnderscoreEarnVaultDeposit(\n        sender = msg.sender,\n        asset = _asset,\n        vaultToken = _vaultAddr,\n        assetAmountDeposited = depositAmount,\n        usdValue = usdValue,\n        vaultTokenAmountReceived = vaultTokenAmountReceived,\n        recipient = _recipient,\n    )\n\n    # add price snapshot\n    pricePerShare: uint256 = self._getPricePerShare(_vaultAddr, vaultInfo.decimals)\n    yld._addPriceSnapshot(_vaultAddr, pricePerShare, vaultInfo.decimals)\n\n    return depositAmount, _vaultAddr, vaultTokenAmountReceived, usdValue\n\n\n# vault info on deposit\n\n\n@internal\ndef _getVaultInfoOnDeposit(_asset: address, _vaultAddr: address, _ledger: address, _legoBook: address) -> ls.VaultTokenInfo:\n    vaultInfo: ls.VaultTokenInfo = yld.vaultToAsset[_vaultAddr]\n    if vaultInfo.decimals == 0:\n        assert self._canRegisterVaultToken(_asset, _vaultAddr) # dev: cannot register vault token\n        vaultInfo = self._registerVaultTokenLocally(_asset, _vaultAddr)\n        self._registerVaultTokenGlobally(_asset, _vaultAddr, vaultInfo.decimals, _ledger, _legoBook)\n    else:\n        assert vaultInfo.underlyingAsset == _asset # dev: asset mismatch\n    return vaultInfo\n\n\n# withdraw\n\n\n@external\ndef withdrawFromYield(\n    _vaultToken: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, address, uint256, uint256):\n    assert self._isAllowedToPerformAction(msg.sender) # dev: no perms\n    assert not yld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = yld._getMiniAddys(_miniAddys)\n    vaultInfo: ls.VaultTokenInfo = self._getVaultInfoOnWithdrawal(_vaultToken, miniAddys.ledger, miniAddys.legoBook)\n\n    # pre balances\n    preLegoVaultBalance: uint256 = staticcall IERC20(_vaultToken).balanceOf(self)\n\n    # transfer vaults tokens to this contract\n    vaultTokenAmount: uint256 = min(_amount, staticcall IERC20(_vaultToken).balanceOf(msg.sender))\n    assert vaultTokenAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_vaultToken).transferFrom(msg.sender, self, vaultTokenAmount, default_return_value=True) # dev: transfer failed\n\n    # withdraw assets from lego partner\n    assetAmountReceived: uint256 = extcall IERC4626(_vaultToken).redeem(vaultTokenAmount, _recipient, self)\n    assert assetAmountReceived != 0 # dev: no asset amount received\n\n    # refund if full withdrawal didn't happen\n    currentLegoVaultBalance: uint256 = staticcall IERC20(_vaultToken).balanceOf(self)\n    refundVaultTokenAmount: uint256 = 0\n    if currentLegoVaultBalance > preLegoVaultBalance:\n        refundVaultTokenAmount = currentLegoVaultBalance - preLegoVaultBalance\n        assert extcall IERC20(_vaultToken).transfer(msg.sender, refundVaultTokenAmount, default_return_value=True) # dev: transfer failed\n        vaultTokenAmount -= refundVaultTokenAmount\n\n    usdValue: uint256 = staticcall Appraiser(miniAddys.appraiser).getUnderlyingUsdValue(vaultInfo.underlyingAsset, assetAmountReceived)\n    log UnderscoreEarnVaultWithdrawal(\n        sender = msg.sender,\n        asset = vaultInfo.underlyingAsset,\n        vaultToken = _vaultToken,\n        assetAmountReceived = assetAmountReceived,\n        usdValue = usdValue,\n        vaultTokenAmountBurned = vaultTokenAmount,\n        recipient = _recipient,\n    )\n\n    # add price snapshot\n    pricePerShare: uint256 = self._getPricePerShare(_vaultToken, vaultInfo.decimals)\n    yld._addPriceSnapshot(_vaultToken, pricePerShare, vaultInfo.decimals)\n\n    return vaultTokenAmount, vaultInfo.underlyingAsset, assetAmountReceived, usdValue\n\n\n# vault info on withdrawal\n\n\n@internal\ndef _getVaultInfoOnWithdrawal(_vaultAddr: address, _ledger: address, _legoBook: address) -> ls.VaultTokenInfo:\n    vaultInfo: ls.VaultTokenInfo = yld.vaultToAsset[_vaultAddr]\n    if vaultInfo.decimals == 0:\n        asset: address = staticcall IERC4626(_vaultAddr).asset()\n        assert self._canRegisterVaultToken(asset, _vaultAddr) # dev: cannot register vault token\n        vaultInfo = self._registerVaultTokenLocally(asset, _vaultAddr)\n        self._registerVaultTokenGlobally(asset, _vaultAddr, vaultInfo.decimals, _ledger, _legoBook)\n    return vaultInfo\n\n\n##############\n# Claim Loot #\n##############\n\n\n@external\ndef claimIncentives(\n    _user: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _proofs: DynArray[bytes32, MAX_PROOFS],\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    assert self._isAllowedToPerformAction(msg.sender) # dev: no perms\n    miniAddys: ws.MiniAddys = yld._getMiniAddys(_miniAddys)\n    return self._claimIncentives(_user, _rewardToken, _rewardAmount, _proofs, miniAddys.appraiser)\n\n\n@external\ndef claimRewards(\n    _user: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _extraData: bytes32,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    assert self._isAllowedToPerformAction(msg.sender) # dev: no perms\n    miniAddys: ws.MiniAddys = yld._getMiniAddys(_miniAddys)\n    return self._claimIncentives(_user, _rewardToken, _rewardAmount, [], miniAddys.appraiser)\n\n\n@internal\ndef _claimIncentives(\n    _user: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _proofs: DynArray[bytes32, MAX_PROOFS],\n    _appraiser: address,\n) -> (uint256, uint256):\n    lootDistributor: address = addys._getLootDistributorAddr()\n\n    # rev share and loot bonus\n    totalClaimableAssets: uint256 = staticcall LootDistributor(lootDistributor).getTotalClaimableAssets(_user)\n    if totalClaimableAssets != 0:\n        extcall LootDistributor(lootDistributor).claimRevShareAndBonusLoot(_user)\n\n    # deposit rewards\n    depositRewards: uint256 = staticcall LootDistributor(lootDistributor).getClaimableDepositRewards(_user)\n    if depositRewards != 0:\n        depositRewards = extcall LootDistributor(lootDistributor).claimDepositRewards(_user)\n\n    usdValue: uint256 = staticcall Appraiser(_appraiser).getUnderlyingUsdValue(_rewardToken, depositRewards)\n    if _rewardToken == RIPE_TOKEN:\n        return 0, usdValue\n\n    return depositRewards, usdValue\n\n\n# has claimable rewards\n\n\n@view\n@external\ndef hasClaimableRewards(_user: address) -> bool:\n    lootDistributor: address = addys._getLootDistributorAddr()\n    totalClaimableAssets: uint256 = staticcall LootDistributor(lootDistributor).getTotalClaimableAssets(_user)\n    if totalClaimableAssets != 0:\n        return True\n    depositRewards: uint256 = staticcall LootDistributor(lootDistributor).getClaimableDepositRewards(_user)\n    return depositRewards != 0\n\n\n#########\n# Other #\n#########\n\n\n@view\n@external\ndef getAccessForLego(_user: address, _action: ws.ActionType) -> (address, String[64], uint256):\n    return empty(address), empty(String[64]), 0\n\n\n@external\ndef swapTokens(\n    _amountIn: uint256,\n    _minAmountOut: uint256,\n    _tokenPath: DynArray[address, MAX_TOKEN_PATH],\n    _poolPath: DynArray[address, MAX_TOKEN_PATH - 1],\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256):\n    return 0, 0, 0\n\n\n@external\ndef mintOrRedeemAsset(\n    _tokenIn: address,\n    _tokenOut: address,\n    _tokenInAmount: uint256,\n    _minAmountOut: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, bool, uint256):\n    return 0, 0, False, 0\n\n\n@external\ndef confirmMintOrRedeemAsset(\n    _tokenIn: address,\n    _tokenOut: address,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef addCollateral(\n    _asset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef removeCollateral(\n    _asset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef borrow(\n    _borrowAsset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef repayDebt(\n    _paymentAsset: address,\n    _paymentAmount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef addLiquidity(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _amountA: uint256,\n    _amountB: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _minLpAmount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (address, uint256, uint256, uint256, uint256):\n    return empty(address), 0, 0, 0, 0\n\n\n@external\ndef removeLiquidity(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpToken: address,\n    _lpAmount: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, uint256):\n    return 0, 0, 0, 0\n\n\n@external\ndef addLiquidityConcentrated(\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _tickLower: int24,\n    _tickUpper: int24,\n    _amountA: uint256,\n    _amountB: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, uint256, uint256):\n    return 0, 0, 0, 0, 0\n\n\n@external\ndef removeLiquidityConcentrated(\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _liqToRemove: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, bool, uint256):\n    return 0, 0, 0, False, 0",
            "sha256sum": "7f959f577a47558b51d4dbf25d3289c90a2144fad67febb217b348f559aef991"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/legos/UnderscoreLego.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.3+commit.bff19ea2",
        "integrity": "7959c04fd3ef43794ac7d22ad8f1fe602a3b991737dbaece9c4efa277a6a522c"
      },
      "args": "00000000000000000000000044cf3c4f000dfd76a35d03298049d37be688d6f90000000000000000000000006162df1b329e157479f8f1407e888260e0ec3d2b",
      "file": "contracts/legos/UnderscoreLego.vy"
    },
    "40Acres": {
      "address": "0x3f67b2ec379A94398029994e48ea1421E933103A",
      "abi": [
        {
          "name": "FortyAcresDeposit",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountDeposited",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultTokenAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "FortyAcresWithdrawal",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultTokenAmountBurned",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LegoPauseModified",
          "inputs": [
            {
              "name": "isPaused",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LegoFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "balance",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "SnapShotPriceConfigSet",
          "inputs": [
            {
              "name": "minSnapshotDelay",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "maxNumSnapshots",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "maxUpsideDeviation",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "staleTime",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetOpportunityAdded",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultAddr",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetOpportunityRemoved",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultAddr",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PricePerShareSnapShotAdded",
          "inputs": [
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "totalSupply",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "pricePerShare",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "lastAveragePricePerShare",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddys",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "undyToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "hatchery",
                  "type": "address"
                },
                {
                  "name": "lootDistributor",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                },
                {
                  "name": "walletBackpack",
                  "type": "address"
                },
                {
                  "name": "billing",
                  "type": "address"
                },
                {
                  "name": "vaultRegistry",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUndyHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isLegoAsset",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssetOpportunities",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isAssetOpportunity",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getNumLegoAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pause",
          "inputs": [
            {
              "name": "_shouldPause",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFundsMany",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_assets",
              "type": "address[]"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getWeightedPricePerShare",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLatestSnapshot",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_pricePerShare",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "totalSupply",
                  "type": "uint256"
                },
                {
                  "name": "pricePerShare",
                  "type": "uint256"
                },
                {
                  "name": "lastUpdate",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setSnapShotPriceConfig",
          "inputs": [
            {
              "name": "_config",
              "type": "tuple",
              "components": [
                {
                  "name": "minSnapshotDelay",
                  "type": "uint256"
                },
                {
                  "name": "maxNumSnapshots",
                  "type": "uint256"
                },
                {
                  "name": "maxUpsideDeviation",
                  "type": "uint256"
                },
                {
                  "name": "staleTime",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidPriceConfig",
          "inputs": [
            {
              "name": "_config",
              "type": "tuple",
              "components": [
                {
                  "name": "minSnapshotDelay",
                  "type": "uint256"
                },
                {
                  "name": "maxNumSnapshots",
                  "type": "uint256"
                },
                {
                  "name": "maxUpsideDeviation",
                  "type": "uint256"
                },
                {
                  "name": "staleTime",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "vaultToAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "underlyingAsset",
                  "type": "address"
                },
                {
                  "name": "decimals",
                  "type": "uint256"
                },
                {
                  "name": "lastAveragePricePerShare",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assetOpportunities",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAssetOpportunity",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssetOpportunities",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assets",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "snapShotData",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "lastSnapShot",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "totalSupply",
                      "type": "uint256"
                    },
                    {
                      "name": "pricePerShare",
                      "type": "uint256"
                    },
                    {
                      "name": "lastUpdate",
                      "type": "uint256"
                    }
                  ]
                },
                {
                  "name": "nextIndex",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "snapShots",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "totalSupply",
                  "type": "uint256"
                },
                {
                  "name": "pricePerShare",
                  "type": "uint256"
                },
                {
                  "name": "lastUpdate",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "snapShotPriceConfig",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "minSnapshotDelay",
                  "type": "uint256"
                },
                {
                  "name": "maxNumSnapshots",
                  "type": "uint256"
                },
                {
                  "name": "maxUpsideDeviation",
                  "type": "uint256"
                },
                {
                  "name": "staleTime",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isPaused",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasCapability",
          "inputs": [
            {
              "name": "_action",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRegistries",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isYieldLego",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isDexLego",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAsset",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingBalances",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenBalance",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAmount",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAmountSafe",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenBalance",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingData",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingData",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            },
            {
              "name": "_appraiser",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValueOfVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValueOfVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            },
            {
              "name": "_appraiser",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isRebasing",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPricePerShare",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPricePerShare",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_decimals",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getVaultTokenAmount",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_assetAmount",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalAssets",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalBorrows",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAvailLiquidity",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUtilizationRatio",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isEligibleForYieldBonus",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getWithdrawalFees",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canRegisterVaultToken",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "registerVaultTokenLocally",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "underlyingAsset",
                  "type": "address"
                },
                {
                  "name": "decimals",
                  "type": "uint256"
                },
                {
                  "name": "lastAveragePricePerShare",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "deregisterVaultTokenLocally",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addPriceSnapshot",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositForYield",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositForYield",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawFromYield",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawFromYield",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAccessForLego",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_action",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "string"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimIncentives",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_proofs",
              "type": "bytes32[]"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimIncentives",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_proofs",
              "type": "bytes32[]"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasClaimableRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_tokenPath",
              "type": "address[]"
            },
            {
              "name": "_poolPath",
              "type": "address[]"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_tokenPath",
              "type": "address[]"
            },
            {
              "name": "_poolPath",
              "type": "address[]"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_tokenInAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_tokenInAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmMintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmMintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_borrowAsset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_borrowAsset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_paymentAsset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_paymentAsset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "RIPE_REGISTRY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "FORTY_ACRES_USDC_VAULT",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "FORTY_ACRES_LOANS",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_undyHq",
              "type": "address"
            },
            {
              "name": "_fortyAcresVault",
              "type": "address"
            },
            {
              "name": "_fortyAcresLoans",
              "type": "address"
            },
            {
              "name": "_ripeRegistry",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "interfaces/WalletStructs.vyi": {
            "content": "# @version 0.4.3\n\nflag ActionType:\n    TRANSFER\n    EARN_DEPOSIT\n    EARN_WITHDRAW\n    EARN_REBALANCE\n    SWAP\n    MINT_REDEEM\n    CONFIRM_MINT_REDEEM\n    ADD_COLLATERAL\n    REMOVE_COLLATERAL\n    BORROW\n    REPAY_DEBT\n    REWARDS\n    ETH_TO_WETH\n    WETH_TO_ETH\n    ADD_LIQ\n    REMOVE_LIQ\n    ADD_LIQ_CONC\n    REMOVE_LIQ_CONC\n    PAY_CHEQUE\n\nstruct WalletAssetData:\n    assetBalance: uint256\n    usdValue: uint256\n    isYieldAsset: bool\n    lastPricePerShare: uint256\n\nstruct ActionData:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    billing: address\n    vaultRegistry: address\n    wallet: address\n    walletConfig: address\n    walletOwner: address\n    inEjectMode: bool\n    isFrozen: bool\n    lastTotalUsdValue: uint256\n    signer: address\n    isManager: bool\n    legoId: uint256\n    legoAddr: address\n    eth: address\n    weth: address\n\nstruct MiniAddys:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    appraiser: address",
            "sha256sum": "466493c129135c95470aaf70eeddc936632f7b0f813396e5a7ddc03bea9da518"
          },
          "interfaces/LegoPartner.vyi": {
            "content": "# @version 0.4.3\n\nfrom interfaces import WalletStructs as ws\n\nMAX_TOKEN_PATH: constant(uint256) = 5\nMAX_RECOVER_ASSETS: constant(uint256) = 20\nMAX_PROOFS: constant(uint256) = 25\n\n@external\ndef addLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _tickLower: int24, _tickUpper: int24, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef addLiquidity(_pool: address, _tokenA: address, _tokenB: address, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _minLpAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (address, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef removeLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _liqToRemove: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef removeLiquidity(_pool: address, _tokenA: address, _tokenB: address, _lpToken: address, _lpAmount: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef mintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _tokenInAmount: uint256, _minAmountOut: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef swapTokens(_amountIn: uint256, _minAmountOut: uint256, _tokenPath: DynArray[address, MAX_TOKEN_PATH], _poolPath: DynArray[address, MAX_TOKEN_PATH - 1], _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256):\n    ...\n\n@external\ndef depositForYield(_asset: address, _amount: uint256, _vaultAddr: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef withdrawFromYield(_vaultToken: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef confirmMintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef borrow(_borrowAsset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef repayDebt(_paymentAsset: address, _paymentAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef claimIncentives(_user: address, _rewardToken: address, _rewardAmount: uint256, _proofs: DynArray[bytes32, MAX_PROOFS], _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef removeCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef addCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@view\n@external\ndef getAccessForLego(_user: address, _action: ws.ActionType) -> (address, String[64], uint256):\n    ...\n\n@view\n@external\ndef hasCapability(_action: ws.ActionType) -> bool:\n    ...\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    ...\n\n@view\n@external\ndef isYieldLego() -> bool:\n    ...\n\n@view\n@external\ndef isDexLego() -> bool:\n    ...\n\n\n# common\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "f2afb7bd72d4301aea77bbe4177b7ae954ba6f6b76af363965993eb92ad0b715"
          },
          "interfaces/LegoStructs.vyi": {
            "content": "# @version 0.4.3\n\nstruct VaultTokenInfo:\n    underlyingAsset: address\n    decimals: uint256\n    lastAveragePricePerShare: uint256\n\nstruct SnapShotPriceConfig:\n    minSnapshotDelay: uint256\n    maxNumSnapshots: uint256\n    maxUpsideDeviation: uint256\n    staleTime: uint256\n\nstruct SingleSnapShot:\n    totalSupply: uint256\n    pricePerShare: uint256\n    lastUpdate: uint256\n\nstruct SnapShotData:\n    lastSnapShot: SingleSnapShot\n    nextIndex: uint256\n",
            "sha256sum": "8ae48be17d812d57fbd671bbf0593e8abf175ad0924e47c5997823cac19ec806"
          },
          "interfaces/YieldLego.vyi": {
            "content": "# @version 0.4.3\n\nfrom interfaces import LegoStructs as ls\n\n\n###################\n# Underlying Data #\n###################\n\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    ...\n\n\n@view\n@external\ndef getUnderlyingBalances(_vaultToken: address, _vaultTokenBalance: uint256) -> (uint256, uint256):\n    ...\n\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    ...\n\n\n@view\n@external\ndef getUnderlyingAmountSafe(_vaultToken: address, _vaultTokenBalance: uint256) -> uint256:\n    ...\n\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> (address, uint256, uint256):\n    ...\n\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> uint256:\n    ...\n\n\n###############\n# Other Utils #\n###############\n\n\n@view\n@external\ndef isRebasing() -> bool:\n    ...\n\n\n@view\n@external\ndef getPricePerShare(_vaultToken: address, _decimals: uint256 = 0) -> uint256:\n    ...\n\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef canRegisterVaultToken(_asset: address, _vaultToken: address) -> bool:\n    ...\n\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef getUtilizationRatio(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef getAvailLiquidity(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef isEligibleForYieldBonus(_asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef getWithdrawalFees(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    ...\n\n\n###################\n# Yield Lego Data #\n###################\n\n\n@view\n@external\ndef isLegoAsset(_asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, 40]:\n    ...\n\n\n@view\n@external\ndef getAssets() -> DynArray[address, 20]:\n    ...\n\n\n@view\n@external\ndef isAssetOpportunity(_asset: address, _vaultAddr: address) -> bool:\n    ...\n\n\n@view\n@external\ndef getNumLegoAssets() -> uint256:\n    ...\n\n\n@view\n@external\ndef assets(_index: uint256) -> address:\n    ...\n\n\n@view\n@external\ndef indexOfAsset(_asset: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef numAssets() -> uint256:\n    ...\n\n\n@view\n@external\ndef assetOpportunities(_asset: address, _index: uint256) -> address:\n    ...\n\n\n@view\n@external\ndef indexOfAssetOpportunity(_asset: address, _vaultAddr: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef numAssetOpportunities(_asset: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef vaultToAsset(_vaultAddr: address) -> ls.VaultTokenInfo:\n    ...\n\n\n# price snapshots\n\n\n@external\ndef addPriceSnapshot(_vaultToken: address) -> bool:\n    ...\n\n\n@view\n@external\ndef snapShotPriceConfig() -> ls.SnapShotPriceConfig:\n    ...\n\n\n@view\n@external\ndef snapShotData(_vaultToken: address) -> ls.SnapShotData:\n    ...\n\n\n@view\n@external\ndef snapShots(_vaultToken: address, _index: uint256) -> ls.SingleSnapShot:\n    ...\n\n\n@view\n@external\ndef getWeightedPricePerShare(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef getLatestSnapshot(_vaultToken: address, _pricePerShare: uint256) -> ls.SingleSnapShot:\n    ...\n\n\n@external\ndef setSnapShotPriceConfig(_config: ls.SnapShotPriceConfig):\n    ...\n",
            "sha256sum": "db91c139f6018f5218b389d08c8703bc16fb994aa948805dbfea27e072f382ec"
          },
          "contracts/modules/Addys.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\ninterface UndyHq:\n    def isValidAddr(_addr: address) -> bool: view\n    def getAddr(_regId: uint256) -> address: view\n    def undyToken() -> address: view\n\ninterface Switchboard:\n    def isSwitchboardAddr(_addr: address) -> bool: view\n\ninterface LegoBook:\n    def isLegoAddr(_addr: address) -> bool: view\n\nstruct Addys:\n    hq: address\n    undyToken: address\n    ledger: address\n    missionControl: address\n    legoBook: address\n    switchboard: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    walletBackpack: address\n    billing: address\n    vaultRegistry: address\n\n# hq\nUNDY_HQ_FOR_ADDYS: immutable(address)\n\n# core addys\nLEDGER_ID: constant(uint256) = 1\nMISSION_CONTROL_ID: constant(uint256) = 2\nLEGO_BOOK_ID: constant(uint256) = 3\nSWITCHBOARD_ID: constant(uint256) = 4\nHATCHERY_ID: constant(uint256) = 5\nLOOT_DISTRIBUTOR_ID: constant(uint256) = 6\nAPPRAISER_ID: constant(uint256) = 7\nWALLET_BACKPACK_ID: constant(uint256) = 8\nBILLING_ID: constant(uint256) = 9\nVAULT_REGISTRY_ID: constant(uint256) = 10\n\n\n@deploy\ndef __init__(_undyHq: address):\n    assert _undyHq != empty(address) # dev: invalid undy hq\n    UNDY_HQ_FOR_ADDYS = _undyHq\n\n\n########\n# Core #\n########\n\n\n@view\n@external\ndef getAddys() -> Addys:\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _getAddys(_addys: Addys = empty(Addys)) -> Addys:\n    if _addys.hq != empty(address):\n        return _addys\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _generateAddys() -> Addys:\n    hq: address = UNDY_HQ_FOR_ADDYS\n    return Addys(\n        hq = hq,\n        undyToken = staticcall UndyHq(hq).undyToken(),\n        ledger = staticcall UndyHq(hq).getAddr(LEDGER_ID),\n        missionControl = staticcall UndyHq(hq).getAddr(MISSION_CONTROL_ID),\n        legoBook = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID),\n        switchboard = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID),\n        hatchery = staticcall UndyHq(hq).getAddr(HATCHERY_ID),\n        lootDistributor = staticcall UndyHq(hq).getAddr(LOOT_DISTRIBUTOR_ID),\n        appraiser = staticcall UndyHq(hq).getAddr(APPRAISER_ID),\n        walletBackpack = staticcall UndyHq(hq).getAddr(WALLET_BACKPACK_ID),\n        billing = staticcall UndyHq(hq).getAddr(BILLING_ID),\n        vaultRegistry = staticcall UndyHq(hq).getAddr(VAULT_REGISTRY_ID),\n    )\n\n\n##########\n# Tokens #\n##########\n\n\n@view\n@internal\ndef _getUndyToken() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).undyToken()\n\n\n###########\n# Helpers #\n###########\n\n\n# undy hq\n\n\n@view\n@external\ndef getUndyHq() -> address:\n    return self._getUndyHq()\n\n\n@view\n@internal\ndef _getUndyHq() -> address:\n    return UNDY_HQ_FOR_ADDYS\n\n\n# utils\n\n\n@view\n@internal\ndef _isValidUndyAddr(_addr: address, _hq: address = empty(address)) -> bool:\n    hq: address = _hq\n    if _hq == empty(address):\n        hq = UNDY_HQ_FOR_ADDYS\n    \n    # core departments\n    if staticcall UndyHq(hq).isValidAddr(_addr):\n        return True\n\n    # lego book\n    legoBook: address = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID)\n    if legoBook != empty(address) and staticcall LegoBook(legoBook).isLegoAddr(_addr):\n        return True\n\n    # switchboard config\n    switchboard: address = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID)\n    if switchboard != empty(address) and staticcall Switchboard(switchboard).isSwitchboardAddr(_addr):\n        return True\n\n    return False\n\n\n@view\n@internal\ndef _isSwitchboardAddr(_addr: address) -> bool:\n    switchboard: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n    if switchboard == empty(address):\n        return False\n    return staticcall Switchboard(switchboard).isSwitchboardAddr(_addr)\n\n\n@view\n@internal\ndef _isLegoBookAddr(_addr: address) -> bool:\n    legoBook: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n    if legoBook == empty(address):\n        return False\n    return staticcall LegoBook(legoBook).isLegoAddr(_addr)\n\n\n###############\n# Departments #\n###############\n\n\n# ledger\n\n\n@view\n@internal\ndef _getLedgerId() -> uint256:\n    return LEDGER_ID\n\n\n@view\n@internal\ndef _getLedgerAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEDGER_ID)\n\n\n# mission control\n\n\n@view\n@internal\ndef _getMissionControlId() -> uint256:\n    return MISSION_CONTROL_ID\n\n\n@view\n@internal\ndef _getMissionControlAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(MISSION_CONTROL_ID)\n\n\n# lego book\n\n\n@view\n@internal\ndef _getLegoBookId() -> uint256:\n    return LEGO_BOOK_ID\n\n\n@view\n@internal\ndef _getLegoBookAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n\n\n# switchboard\n\n\n@view\n@internal\ndef _getSwitchboardId() -> uint256:\n    return SWITCHBOARD_ID\n\n\n@view\n@internal\ndef _getSwitchboardAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n\n\n# hatchery\n\n\n@view\n@internal\ndef _getHatcheryId() -> uint256:\n    return HATCHERY_ID\n\n\n@view\n@internal\ndef _getHatcheryAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(HATCHERY_ID)\n\n\n# loot distributor\n\n\n@view\n@internal\ndef _getLootDistributorId() -> uint256:\n    return LOOT_DISTRIBUTOR_ID\n\n\n@view\n@internal\ndef _getLootDistributorAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LOOT_DISTRIBUTOR_ID)\n\n\n# appraiser\n\n\n@view\n@internal\ndef _getAppraiserId() -> uint256:\n    return APPRAISER_ID\n\n\n@view\n@internal\ndef _getAppraiserAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(APPRAISER_ID)\n\n\n# wallet backpack\n\n\n@view\n@internal\ndef _getWalletBackpackId() -> uint256:\n    return WALLET_BACKPACK_ID\n\n\n@view\n@internal\ndef _getWalletBackpackAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(WALLET_BACKPACK_ID)\n\n\n# billing\n\n\n@view\n@internal\ndef _getBillingId() -> uint256:\n    return BILLING_ID\n\n\n@view\n@internal\ndef _getBillingAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(BILLING_ID)\n\n\n# vault registry\n\n\n@view\n@internal\ndef _getVaultRegistryId() -> uint256:\n    return VAULT_REGISTRY_ID\n\n\n@view\n@internal\ndef _getVaultRegistryAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(VAULT_REGISTRY_ID)",
            "sha256sum": "4df6b72db9bb417d1af81660175be1450cfb7b3575f3d17a5b8a130bff87b781"
          },
          "contracts/modules/YieldLegoData.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nuses: addys\n\nimport contracts.modules.Addys as addys\n\nfrom interfaces import WalletStructs as ws\nfrom interfaces import LegoStructs as ls\nfrom ethereum.ercs import IERC20\nfrom ethereum.ercs import IERC20Detailed\n\nevent AssetOpportunityAdded:\n    asset: indexed(address)\n    vaultAddr: indexed(address)\n\nevent AssetOpportunityRemoved:\n    asset: indexed(address)\n    vaultAddr: indexed(address)\n\nevent LegoPauseModified:\n    isPaused: bool\n\nevent LegoFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    balance: uint256\n\nevent PricePerShareSnapShotAdded:\n    vaultToken: indexed(address)\n    totalSupply: uint256\n    pricePerShare: uint256\n    lastAveragePricePerShare: uint256\n\nevent SnapShotPriceConfigSet:\n    minSnapshotDelay: uint256\n    maxNumSnapshots: uint256\n    maxUpsideDeviation: uint256\n    staleTime: uint256\n\n# core\nvaultToAsset: public(HashMap[address, ls.VaultTokenInfo]) # vault addr -> data\n\n# asset opportunities\nassetOpportunities: public(HashMap[address, HashMap[uint256, address]]) # asset -> index -> vault addr\nindexOfAssetOpportunity: public(HashMap[address, HashMap[address, uint256]]) # asset -> vault addr -> index\nnumAssetOpportunities: public(HashMap[address, uint256]) # asset -> number of opportunities\n\n# lego assets (iterable)\nassets: public(HashMap[uint256, address]) # index -> asset\nindexOfAsset: public(HashMap[address, uint256]) # asset -> index\nnumAssets: public(uint256) # num assets\n\n# price snapshots\nsnapShotData: public(HashMap[address, ls.SnapShotData]) # vault token -> data\nsnapShots: public(HashMap[address, HashMap[uint256, ls.SingleSnapShot]]) # vault token -> index -> snapshot\nsnapShotPriceConfig: public(ls.SnapShotPriceConfig) # config\n\nisPaused: public(bool)\n\nMAX_VAULTS: constant(uint256) = 40\nMAX_ASSETS: constant(uint256) = 20\nMAX_RECOVER_ASSETS: constant(uint256) = 20\nONE_DAY_SECONDS: constant(uint256) = 60 * 60 * 24\nONE_WEEK_SECONDS: constant(uint256) = ONE_DAY_SECONDS * 7\nHUNDRED_PERCENT: constant(uint256) = 100_00\n\n\n@deploy\ndef __init__(_shouldPause: bool):\n    self.isPaused = _shouldPause\n    self.numAssets = 1 # not using 0 index\n\n    # default snapshot price config\n    self.snapShotPriceConfig = ls.SnapShotPriceConfig(\n        minSnapshotDelay = 60 * 10, # 10 minutes\n        maxNumSnapshots = 20,\n        maxUpsideDeviation = 10_00, # 10%\n        staleTime = ONE_DAY_SECONDS, # 1 day\n    )\n\n\n#########\n# Views #\n#########\n\n\n# is lego asset\n\n\n@view\n@external\ndef isLegoAsset(_asset: address) -> bool:\n    return self._isLegoAsset(_asset)\n\n\n@view\n@internal\ndef _isLegoAsset(_asset: address) -> bool:\n    return self.indexOfAsset[_asset] != 0\n\n\n# vault opportunities\n\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, MAX_VAULTS]:\n    numOpportunities: uint256 = self.numAssetOpportunities[_asset]\n    if numOpportunities == 0:\n        return []\n    opportunities: DynArray[address, MAX_VAULTS] = []\n    for i: uint256 in range(1, numOpportunities, bound=MAX_VAULTS):\n        opportunities.append(self.assetOpportunities[_asset][i])\n    return opportunities\n\n\n# all assets registered\n\n\n@view\n@external\ndef getAssets() -> DynArray[address, MAX_ASSETS]:\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return []\n    assets: DynArray[address, MAX_ASSETS] = []\n    for i: uint256 in range(1, numAssets, bound=MAX_ASSETS):\n        assets.append(self.assets[i])\n    return assets\n\n\n################\n# Registration #\n################\n\n\n@view\n@external\ndef isAssetOpportunity(_asset: address, _vaultAddr: address) -> bool:\n    return self._isAssetOpportunity(_asset, _vaultAddr)\n\n\n@view\n@internal\ndef _isAssetOpportunity(_asset: address, _vaultAddr: address) -> bool:\n    return self.indexOfAssetOpportunity[_asset][_vaultAddr] != 0\n\n\n# add asset opportunity\n\n\n@internal\ndef _addAssetOpportunity(_asset: address, _vaultAddr: address) -> ls.VaultTokenInfo:\n    if self.indexOfAssetOpportunity[_asset][_vaultAddr] != 0:\n        return self.vaultToAsset[_vaultAddr]\n\n    if empty(address) in [_asset, _vaultAddr]:\n        return empty(ls.VaultTokenInfo)\n\n    # add asset opportunity\n    aid: uint256 = self.numAssetOpportunities[_asset]\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.assetOpportunities[_asset][aid] = _vaultAddr\n    self.indexOfAssetOpportunity[_asset][_vaultAddr] = aid\n    self.numAssetOpportunities[_asset] = aid + 1\n\n    # add mapping\n    vaultInfo: ls.VaultTokenInfo = ls.VaultTokenInfo(\n        underlyingAsset = _asset,\n        decimals = convert(staticcall IERC20Detailed(_vaultAddr).decimals(), uint256),\n        lastAveragePricePerShare = 0,\n    )\n    self.vaultToAsset[_vaultAddr] = vaultInfo\n\n    # add asset\n    self._addAsset(_asset)\n\n    log AssetOpportunityAdded(asset=_asset, vaultAddr=_vaultAddr)\n    return vaultInfo\n\n\n# remove asset opportunity\n\n\n@internal\ndef _removeAssetOpportunity(_asset: address, _vaultAddr: address):\n    numOpportunities: uint256 = self.numAssetOpportunities[_asset]\n    if numOpportunities == 0:\n        return\n\n    targetIndex: uint256 = self.indexOfAssetOpportunity[_asset][_vaultAddr]\n    if targetIndex == 0:\n        return\n\n    # update data\n    lastIndex: uint256 = numOpportunities - 1\n    self.numAssetOpportunities[_asset] = lastIndex\n    self.indexOfAssetOpportunity[_asset][_vaultAddr] = 0\n\n    self.vaultToAsset[_vaultAddr] = empty(ls.VaultTokenInfo)\n\n    # clear all snapshot data for the vault token to prevent contamination on re-add\n    self.snapShotData[_vaultAddr] = empty(ls.SnapShotData)\n\n    # clear all historical snapshots\n    config: ls.SnapShotPriceConfig = self.snapShotPriceConfig\n    for i: uint256 in range(config.maxNumSnapshots, bound=max_value(uint256)):\n        if i >= config.maxNumSnapshots:\n            break\n        self.snapShots[_vaultAddr][i] = empty(ls.SingleSnapShot)\n\n    # shift to replace the removed one\n    if targetIndex != lastIndex:\n        lastVaultAddr: address = self.assetOpportunities[_asset][lastIndex]\n        self.assetOpportunities[_asset][targetIndex] = lastVaultAddr\n        self.indexOfAssetOpportunity[_asset][lastVaultAddr] = targetIndex\n\n    # remove asset\n    if lastIndex <= 1:\n        self._removeAsset(_asset)\n\n    log AssetOpportunityRemoved(asset=_asset, vaultAddr=_vaultAddr)\n\n\n# add asset\n\n\n@internal\ndef _addAsset(_asset: address):\n    if self.indexOfAsset[_asset] != 0:\n        return\n\n    aid: uint256 = self.numAssets\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.assets[aid] = _asset\n    self.indexOfAsset[_asset] = aid\n    self.numAssets = aid + 1\n\n\n# remove asset\n\n\n@internal\ndef _removeAsset(_asset: address):\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return\n\n    targetIndex: uint256 = self.indexOfAsset[_asset]\n    if targetIndex == 0:\n        return\n\n    # update data\n    lastIndex: uint256 = numAssets - 1\n    self.numAssets = lastIndex\n    self.indexOfAsset[_asset] = 0\n\n    # shift to replace the removed one\n    if targetIndex != lastIndex:\n        lastAsset: address = self.assets[lastIndex]\n        self.assets[targetIndex] = lastAsset\n        self.indexOfAsset[lastAsset] = targetIndex\n\n\n# num lego assets (true number, use `numAssets` for iteration)\n\n\n@view\n@external\ndef getNumLegoAssets() -> uint256:\n    return self._getNumLegoAssets()\n\n\n@view\n@internal\ndef _getNumLegoAssets() -> uint256:\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return 0\n    return numAssets - 1\n\n\n###########\n# General #\n###########\n\n\n# fill mini addys\n\n\n@view\n@internal\ndef _getMiniAddys(_miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> ws.MiniAddys:\n    if _miniAddys.ledger != empty(address):\n        return _miniAddys\n    return ws.MiniAddys(\n        ledger = addys._getLedgerAddr(),\n        missionControl = addys._getMissionControlAddr(),\n        legoBook = addys._getLegoBookAddr(),\n        appraiser = addys._getAppraiserAddr(),\n    )\n\n\n# activate\n\n\n@external\ndef pause(_shouldPause: bool):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert _shouldPause != self.isPaused # dev: no change\n    self.isPaused = _shouldPause\n    log LegoPauseModified(isPaused=_shouldPause)\n\n\n# recover funds\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    self._recoverFunds(_recipient, _asset)\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, MAX_RECOVER_ASSETS]):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    for a: address in _assets:\n        self._recoverFunds(_recipient, a)\n\n\n@internal\ndef _recoverFunds(_recipient: address, _asset: address):\n    assert empty(address) not in [_recipient, _asset] # dev: invalid recipient or asset\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    assert balance != 0 # dev: nothing to recover\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log LegoFundsRecovered(asset=_asset, recipient=_recipient, balance=balance)\n\n\n###################\n# Price Snapshots #\n###################\n\n\n# add price snapshot\n\n\n@internal\ndef _addPriceSnapshot(_vaultToken: address, _pricePerShare: uint256, _vaultTokenDecimals: uint256) -> bool:\n    config: ls.SnapShotPriceConfig = self.snapShotPriceConfig\n    if config.maxNumSnapshots == 0:\n        return False\n\n    data: ls.SnapShotData = self.snapShotData[_vaultToken]\n\n    # already have snapshot for this time\n    if data.lastSnapShot.lastUpdate == block.timestamp:\n        return False\n\n    # check if snapshot is too recent\n    if data.lastSnapShot.lastUpdate + config.minSnapshotDelay > block.timestamp:\n        return False\n\n    # create and store new snapshot\n    newSnapshot: ls.SingleSnapShot = self._getLatestSnapshot(_vaultToken, _pricePerShare, _vaultTokenDecimals, data.lastSnapShot, config)\n    data.lastSnapShot = newSnapshot\n    self.snapShots[_vaultToken][data.nextIndex] = newSnapshot\n\n    # update index\n    data.nextIndex += 1\n    if data.nextIndex >= config.maxNumSnapshots:\n        data.nextIndex = 0\n\n    # save snap shot data\n    self.snapShotData[_vaultToken] = data\n\n    # update cached weighted average price per share\n    lastAveragePricePerShare: uint256 = self._getWeightedPricePerShare(_vaultToken, _pricePerShare)\n    self.vaultToAsset[_vaultToken].lastAveragePricePerShare = lastAveragePricePerShare\n\n    log PricePerShareSnapShotAdded(\n        vaultToken = _vaultToken,\n        totalSupply = newSnapshot.totalSupply,\n        pricePerShare = newSnapshot.pricePerShare,\n        lastAveragePricePerShare = lastAveragePricePerShare,\n    )\n    return True\n\n\n# weighted price per share\n\n\n@view\n@external\ndef getWeightedPricePerShare(_vaultToken: address) -> uint256:\n    data: ls.SnapShotData = self.snapShotData[_vaultToken]\n    return self._getWeightedPricePerShare(_vaultToken, data.lastSnapShot.pricePerShare)\n\n\n@view\n@internal\ndef _getWeightedPricePerShare(_vaultToken: address, _lastPricePerShare: uint256) -> uint256:\n    config: ls.SnapShotPriceConfig = self.snapShotPriceConfig\n    if config.maxNumSnapshots == 0:\n        return 0\n\n    # calculate weighted average price using all valid snapshots\n    numerator: uint256 = 0\n    denominator: uint256 = 0\n    for i: uint256 in range(config.maxNumSnapshots, bound=max_value(uint256)):\n\n        snapShot: ls.SingleSnapShot = self.snapShots[_vaultToken][i]\n        if snapShot.pricePerShare == 0 or snapShot.totalSupply == 0 or snapShot.lastUpdate == 0:\n            continue\n\n        # too stale, skip\n        if config.staleTime != 0 and block.timestamp > snapShot.lastUpdate + config.staleTime:\n            continue\n\n        numerator += (snapShot.totalSupply * snapShot.pricePerShare)\n        denominator += snapShot.totalSupply\n\n    # weighted price per share\n    weightedPricePerShare: uint256 = 0\n    if numerator != 0:\n        weightedPricePerShare = numerator // denominator\n    else:\n        weightedPricePerShare = _lastPricePerShare\n\n    return weightedPricePerShare\n\n\n# latest snapshot\n\n\n@view\n@external\ndef getLatestSnapshot(_vaultToken: address, _pricePerShare: uint256) -> ls.SingleSnapShot:\n    data: ls.SnapShotData = self.snapShotData[_vaultToken]\n    config: ls.SnapShotPriceConfig = self.snapShotPriceConfig\n    vaultTokenDecimals: uint256 = self.vaultToAsset[_vaultToken].decimals\n    return self._getLatestSnapshot(_vaultToken, _pricePerShare, vaultTokenDecimals, data.lastSnapShot, config)\n\n\n@view\n@internal\ndef _getLatestSnapshot(\n    _vaultToken: address,\n    _pricePerShare: uint256,\n    _vaultTokenDecimals: uint256,\n    _lastSnapShot: ls.SingleSnapShot,\n    _config: ls.SnapShotPriceConfig,\n) -> ls.SingleSnapShot:\n\n    # total supply (adjusted)\n    totalSupply: uint256 = staticcall IERC20(_vaultToken).totalSupply() // (10 ** _vaultTokenDecimals)\n    if totalSupply == 0:\n        totalSupply = 1\n\n    # throttle upside (extra safety check)\n    pricePerShare: uint256 = self._throttleUpside(_pricePerShare, _lastSnapShot.pricePerShare, _config.maxUpsideDeviation)\n\n    return ls.SingleSnapShot(\n        totalSupply = totalSupply,\n        pricePerShare = pricePerShare,\n        lastUpdate = block.timestamp,\n    )\n\n\n@view\n@internal\ndef _throttleUpside(_newValue: uint256, _prevValue: uint256, _maxUpside: uint256) -> uint256:\n    if _maxUpside == 0 or _prevValue == 0 or _newValue == 0:\n        return _newValue\n    maxPricePerShare: uint256 = _prevValue + (_prevValue * _maxUpside // HUNDRED_PERCENT)\n    return min(_newValue, maxPricePerShare)\n\n\n# snapshot price config\n\n\n@external\ndef setSnapShotPriceConfig(_config: ls.SnapShotPriceConfig):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert self._isValidPriceConfig(_config) # dev: invalid config\n    self.snapShotPriceConfig = _config\n    log SnapShotPriceConfigSet(\n        minSnapshotDelay=_config.minSnapshotDelay,\n        maxNumSnapshots=_config.maxNumSnapshots,\n        maxUpsideDeviation=_config.maxUpsideDeviation,\n        staleTime=_config.staleTime\n    )\n\n\n@view\n@external\ndef isValidPriceConfig(_config: ls.SnapShotPriceConfig) -> bool:\n    return self._isValidPriceConfig(_config)\n\n\n@view\n@internal\ndef _isValidPriceConfig(_config: ls.SnapShotPriceConfig) -> bool:\n    if _config.minSnapshotDelay > ONE_WEEK_SECONDS:\n        return False\n    if _config.maxNumSnapshots == 0 or _config.maxNumSnapshots > 25:\n        return False\n    if _config.maxUpsideDeviation > HUNDRED_PERCENT:\n        return False\n    return _config.staleTime < ONE_WEEK_SECONDS",
            "sha256sum": "50440c96dc8a7af22e7ad927bb6d3e308f137d5d3632e633e084b05510c94c28"
          },
          "contracts/legos/yield/40Acres.vy": {
            "content": "#     __   __ ___ _______ ___     ______       ___     _______ _______ _______ \n#    |  | |  |   |       |   |   |      |     |   |   |       |       |       |\n#    |  |_|  |   |    ___|   |   |  _    |    |   |   |    ___|    ___|   _   |\n#    |       |   |   |___|   |   | | |   |    |   |   |   |___|   | __|  | |  |\n#    |_     _|   |    ___|   |___| |_|   |    |   |___|    ___|   ||  |  |_|  |\n#      |   | |   |   |___|       |       |    |       |   |___|   |_| |       |\n#      |___| |___|_______|_______|______|     |_______|_______|_______|_______|\n#                                                                       \n#     \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n#     \u2551  ** 40 Acres **                     \u2551\n#     \u2551  Integration with 40 Acres Protocol.\u2551\n#     \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n#\n#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nimplements: Lego\nimplements: YieldLego\n\nexports: addys.__interface__\nexports: yld.__interface__\n\ninitializes: addys\ninitializes: yld[addys := addys]\n\nfrom interfaces import LegoPartner as Lego\nfrom interfaces import YieldLego as YieldLego\nfrom interfaces import WalletStructs as ws\nfrom interfaces import LegoStructs as ls\n\nimport contracts.modules.Addys as addys\nimport contracts.modules.YieldLegoData as yld\n\nfrom ethereum.ercs import IERC20\nfrom ethereum.ercs import IERC4626\nfrom ethereum.ercs import IERC20Detailed\n\ninterface Ledger:\n    def setVaultToken(_vaultToken: address, _legoId: uint256, _underlyingAsset: address, _decimals: uint256, _isRebasing: bool): nonpayable\n    def isRegisteredVaultToken(_vaultToken: address) -> bool: view\n    def isUserWallet(_user: address) -> bool: view\n\ninterface Registry:\n    def getRegId(_addr: address) -> uint256: view\n    def isValidAddr(_addr: address) -> bool: view\n\ninterface Appraiser:\n    def getUnderlyingUsdValue(_asset: address, _amount: uint256) -> uint256: view\n\ninterface VaultRegistry:\n    def isEarnVault(_vaultAddr: address) -> bool: view\n\ninterface FortyAcresLoans:\n    def activeAssets() -> uint256: view\n\nevent FortyAcresDeposit:\n    sender: indexed(address)\n    asset: indexed(address)\n    vaultToken: indexed(address)\n    assetAmountDeposited: uint256\n    usdValue: uint256\n    vaultTokenAmountReceived: uint256\n    recipient: address\n\nevent FortyAcresWithdrawal:\n    sender: indexed(address)\n    asset: indexed(address)\n    vaultToken: indexed(address)\n    assetAmountReceived: uint256\n    usdValue: uint256\n    vaultTokenAmountBurned: uint256\n    recipient: address\n\nRIPE_REGISTRY: public(immutable(address))\nFORTY_ACRES_USDC_VAULT: public(immutable(address))\nFORTY_ACRES_LOANS: public(immutable(address))\nMAX_TOKEN_PATH: constant(uint256) = 5\nMAX_PROOFS: constant(uint256) = 25\nHUNDRED_PERCENT: constant(uint256) = 100_00\n\n\n@deploy\ndef __init__(\n    _undyHq: address,\n    _fortyAcresVault: address,\n    _fortyAcresLoans: address,\n    _ripeRegistry: address,\n):\n    addys.__init__(_undyHq)\n    yld.__init__(False)\n\n    assert empty(address) not in [_fortyAcresVault, _fortyAcresLoans, _ripeRegistry] # dev: invalid addrs\n    FORTY_ACRES_USDC_VAULT = _fortyAcresVault\n    FORTY_ACRES_LOANS = _fortyAcresLoans\n    RIPE_REGISTRY = _ripeRegistry\n\n\n@view\n@external\ndef hasCapability(_action: ws.ActionType) -> bool:\n    return _action in (\n        ws.ActionType.EARN_DEPOSIT | \n        ws.ActionType.EARN_WITHDRAW\n    )\n\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    return []\n\n\n@view\n@external\ndef isYieldLego() -> bool:\n    return True\n\n\n@view\n@external\ndef isDexLego() -> bool:\n    return False\n\n\n###################\n# Underlying Data #\n###################\n\n\n# underlying asset\n\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    return self._getUnderlyingAsset(_vaultToken)\n\n\n@view\n@internal\ndef _getUnderlyingAsset(_vaultToken: address) -> address:\n    asset: address = yld.vaultToAsset[_vaultToken].underlyingAsset\n    if asset != empty(address):\n        return asset\n    return staticcall IERC4626(_vaultToken).asset()\n\n\n# underlying balances (both true and safe)\n\n\n@view\n@external\ndef getUnderlyingBalances(_vaultToken: address, _vaultTokenBalance: uint256) -> (uint256, uint256):\n    if _vaultTokenBalance == 0:\n        return 0, 0\n\n    trueUnderlying: uint256 = self._getUnderlyingAmount(_vaultToken, _vaultTokenBalance)\n    safeUnderlying: uint256 = self._getUnderlyingAmountSafe(_vaultToken, _vaultTokenBalance)\n    if safeUnderlying == 0:\n        safeUnderlying = trueUnderlying\n\n    return trueUnderlying, min(trueUnderlying, safeUnderlying)\n\n\n# underlying amount (true)\n\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    return self._getUnderlyingAmount(_vaultToken, _vaultTokenAmount)\n\n\n@view\n@internal\ndef _getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    return staticcall IERC4626(_vaultToken).previewRedeem(_vaultTokenAmount)\n\n\n# underlying amount (safe)\n\n\n@view\n@external\ndef getUnderlyingAmountSafe(_vaultToken: address, _vaultTokenBalance: uint256) -> uint256:\n    return self._getUnderlyingAmountSafe(_vaultToken, _vaultTokenBalance)\n\n\n@view\n@internal\ndef _getUnderlyingAmountSafe(_vaultToken: address, _vaultTokenBalance: uint256) -> uint256:\n    vaultInfo: ls.VaultTokenInfo = yld.vaultToAsset[_vaultToken]\n    if vaultInfo.decimals == 0:\n        return 0 # not registered\n\n    # safe underlying amount (using cached weighted average from snapshots)\n    return _vaultTokenBalance * vaultInfo.lastAveragePricePerShare // (10 ** vaultInfo.decimals)\n\n\n# underlying data (combined)\n\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> (address, uint256, uint256):\n    return self._getUnderlyingData(_vaultToken, _vaultTokenAmount, _appraiser)\n\n\n@view\n@internal\ndef _getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address) -> (address, uint256, uint256):\n    asset: address = self._getUnderlyingAsset(_vaultToken)\n    if asset == empty(address):\n        return empty(address), 0, 0 # invalid vault token\n    underlyingAmount: uint256 = self._getUnderlyingAmount(_vaultToken, _vaultTokenAmount)\n    usdValue: uint256 = self._getUsdValue(asset, underlyingAmount, _appraiser)\n    return asset, underlyingAmount, usdValue\n\n\n# usd value\n\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> uint256:\n    return self._getUsdValueOfVaultToken(_vaultToken, _vaultTokenAmount, _appraiser)\n\n\n@view\n@internal\ndef _getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address) -> uint256:\n    return self._getUnderlyingData(_vaultToken, _vaultTokenAmount, _appraiser)[2]\n\n\n@view\n@internal\ndef _getUsdValue(_asset: address, _amount: uint256, _appraiser: address) -> uint256:\n    appraiser: address = _appraiser\n    if _appraiser == empty(address):\n        appraiser = addys._getAppraiserAddr()\n    return staticcall Appraiser(appraiser).getUnderlyingUsdValue(_asset, _amount)\n\n\n###############\n# Other Utils #\n###############\n\n\n# basics\n\n\n@view\n@external\ndef isRebasing() -> bool:\n    return self._isRebasing()\n\n\n@view\n@internal\ndef _isRebasing() -> bool:\n    return False\n\n\n# price per share\n\n\n@view\n@external\ndef getPricePerShare(_vaultToken: address, _decimals: uint256 = 0) -> uint256:\n    decimals: uint256 = _decimals\n    if decimals == 0:\n        decimals = yld.vaultToAsset[_vaultToken].decimals\n    if decimals == 0:\n        decimals = convert(staticcall IERC20Detailed(_vaultToken).decimals(), uint256)\n    return self._getPricePerShare(_vaultToken, decimals)\n\n\n@view\n@internal\ndef _getPricePerShare(_vaultToken: address, _decimals: uint256) -> uint256:\n    return staticcall IERC4626(_vaultToken).previewRedeem(10 ** _decimals)\n\n\n# vault token amount\n\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    return staticcall IERC4626(_vaultToken).convertToShares(_assetAmount)\n\n\n# total assets\n\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    if _vaultToken != FORTY_ACRES_USDC_VAULT:\n        return 0\n    return self._totalAssets(_vaultToken)\n\n\n@view\n@internal\ndef _totalAssets(_vaultToken: address) -> uint256:\n    return staticcall IERC4626(_vaultToken).totalAssets()\n\n\n# total borrows\n\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    if _vaultToken != FORTY_ACRES_USDC_VAULT:\n        return 0\n    return self._totalBorrows(FORTY_ACRES_LOANS)\n\n\n@view\n@internal\ndef _totalBorrows(_fortyAcresLoans: address) -> uint256:\n    return staticcall FortyAcresLoans(_fortyAcresLoans).activeAssets()\n\n\n# avail liquidity\n\n\n@view\n@external\ndef getAvailLiquidity(_vaultToken: address) -> uint256:\n    if _vaultToken != FORTY_ACRES_USDC_VAULT:\n        return 0\n    totalAssets: uint256 = self._totalAssets(_vaultToken)\n    totalBorrows: uint256 = self._totalBorrows(FORTY_ACRES_LOANS)\n    if totalAssets <= totalBorrows:\n        return 0\n    return totalAssets - totalBorrows\n\n\n# utilization\n\n\n@view\n@external\ndef getUtilizationRatio(_vaultToken: address) -> uint256:\n    if _vaultToken != FORTY_ACRES_USDC_VAULT:\n        return 0\n    totalAssets: uint256 = self._totalAssets(_vaultToken)\n    totalBorrows: uint256 = self._totalBorrows(FORTY_ACRES_LOANS)\n    return totalBorrows * HUNDRED_PERCENT // totalAssets\n\n\n# extras\n\n\n@view\n@external\ndef isEligibleForYieldBonus(_asset: address) -> bool:\n    return False\n\n\n@view\n@external\ndef getWithdrawalFees(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    return 0\n\n\n################\n# Registration #\n################\n\n\n# can vault be registered\n\n\n@view\n@external\ndef canRegisterVaultToken(_asset: address, _vaultToken: address) -> bool:\n    return self._canRegisterVaultToken(_asset, _vaultToken)\n\n\n@view\n@internal\ndef _canRegisterVaultToken(_asset: address, _vaultToken: address) -> bool:\n    if empty(address) in [_asset, _vaultToken]:\n        return False\n    return staticcall IERC4626(_vaultToken).asset() == _asset and _vaultToken == FORTY_ACRES_USDC_VAULT\n\n\n# register vault token locally\n\n\n@external\ndef registerVaultTokenLocally(_asset: address, _vaultAddr: address) -> ls.VaultTokenInfo:\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert self._canRegisterVaultToken(_asset, _vaultAddr) # dev: cannot register vault token\n    assert not yld._isAssetOpportunity(_asset, _vaultAddr) # dev: already registered\n    vaultInfo: ls.VaultTokenInfo = self._registerVaultTokenLocally(_asset, _vaultAddr)\n    self._registerVaultTokenGlobally(_asset, _vaultAddr, vaultInfo.decimals, addys._getLedgerAddr(), addys._getLegoBookAddr())\n    return vaultInfo\n\n\n@internal\ndef _registerVaultTokenLocally(_asset: address, _vaultAddr: address) -> ls.VaultTokenInfo:\n    assert extcall IERC20(_asset).approve(_vaultAddr, max_value(uint256), default_return_value=True) # dev: max approval failed\n    vaultInfo: ls.VaultTokenInfo = yld._addAssetOpportunity(_asset, _vaultAddr)\n    assert vaultInfo.decimals != 0 # dev: invalid vault token\n    return vaultInfo\n\n\n# remove vault token locally\n\n\n@external\ndef deregisterVaultTokenLocally(_asset: address, _vaultAddr: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert yld._isAssetOpportunity(_asset, _vaultAddr) # dev: already registered\n    self._deregisterVaultTokenLocally(_asset, _vaultAddr)\n\n\n@internal\ndef _deregisterVaultTokenLocally(_asset: address, _vaultAddr: address):\n    assert extcall IERC20(_asset).approve(_vaultAddr, 0, default_return_value=True) # dev: max approval failed\n    yld._removeAssetOpportunity(_asset, _vaultAddr)\n\n\n# ledger registration\n\n\n@internal\ndef _registerVaultTokenGlobally(_underlyingAsset: address, _vaultToken: address, _decimals: uint256, _ledger: address, _legoBook: address):\n    if not staticcall Ledger(_ledger).isRegisteredVaultToken(_vaultToken):\n        legoId: uint256 = staticcall Registry(_legoBook).getRegId(self)\n        extcall Ledger(_ledger).setVaultToken(_vaultToken, legoId, _underlyingAsset, _decimals, self._isRebasing())\n\n\n#################\n# Yield Actions #\n#################\n\n\n# access control\n\n\n@view\n@internal\ndef _isAllowedToPerformAction(_caller: address) -> bool:\n    # NOTE: important to not trust `_miniAddys` here, that's why getting ledger and vault registry from addys\n    if staticcall VaultRegistry(addys._getVaultRegistryAddr()).isEarnVault(_caller):\n        return True\n    if staticcall Ledger(addys._getLedgerAddr()).isUserWallet(_caller):\n        return True\n    return staticcall Registry(RIPE_REGISTRY).isValidAddr(_caller) # Ripe Endaoment is allowed\n\n\n# add price snapshot\n\n\n@external\ndef addPriceSnapshot(_vaultToken: address) -> bool:\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    vaultInfo: ls.VaultTokenInfo = yld.vaultToAsset[_vaultToken]\n    assert vaultInfo.decimals != 0 # dev: not registered\n    pricePerShare: uint256 = self._getPricePerShare(_vaultToken, vaultInfo.decimals)\n    return yld._addPriceSnapshot(_vaultToken, pricePerShare, vaultInfo.decimals)\n\n\n# deposit\n\n\n@external\ndef depositForYield(\n    _asset: address,\n    _amount: uint256,\n    _vaultAddr: address,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, address, uint256, uint256):\n    assert self._isAllowedToPerformAction(msg.sender) # dev: no perms\n    assert not yld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = yld._getMiniAddys(_miniAddys)\n    vaultInfo: ls.VaultTokenInfo = self._getVaultInfoOnDeposit(_asset, _vaultAddr, miniAddys.ledger, miniAddys.legoBook)\n\n    # pre balances\n    preLegoBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n\n    # transfer deposit asset to this contract\n    depositAmount: uint256 = min(_amount, staticcall IERC20(_asset).balanceOf(msg.sender))\n    assert depositAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_asset).transferFrom(msg.sender, self, depositAmount, default_return_value=True) # dev: transfer failed\n\n    # deposit assets into lego partner\n    vaultTokenAmountReceived: uint256 = extcall IERC4626(_vaultAddr).deposit(depositAmount, _recipient)\n    assert vaultTokenAmountReceived != 0 # dev: no vault tokens received\n\n    # refund if full deposit didn't get through\n    currentLegoBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    refundAssetAmount: uint256 = 0\n    if currentLegoBalance > preLegoBalance:\n        refundAssetAmount = currentLegoBalance - preLegoBalance\n        assert extcall IERC20(_asset).transfer(msg.sender, refundAssetAmount, default_return_value=True) # dev: transfer failed\n        depositAmount -= refundAssetAmount\n\n    usdValue: uint256 = staticcall Appraiser(miniAddys.appraiser).getUnderlyingUsdValue(_asset, depositAmount)\n    log FortyAcresDeposit(\n        sender = msg.sender,\n        asset = _asset,\n        vaultToken = _vaultAddr,\n        assetAmountDeposited = depositAmount,\n        usdValue = usdValue,\n        vaultTokenAmountReceived = vaultTokenAmountReceived,\n        recipient = _recipient,\n    )\n\n    # add price snapshot\n    pricePerShare: uint256 = self._getPricePerShare(_vaultAddr, vaultInfo.decimals)\n    yld._addPriceSnapshot(_vaultAddr, pricePerShare, vaultInfo.decimals)\n\n    return depositAmount, _vaultAddr, vaultTokenAmountReceived, usdValue\n\n\n# vault info on deposit\n\n\n@internal\ndef _getVaultInfoOnDeposit(_asset: address, _vaultAddr: address, _ledger: address, _legoBook: address) -> ls.VaultTokenInfo:\n    vaultInfo: ls.VaultTokenInfo = yld.vaultToAsset[_vaultAddr]\n    if vaultInfo.decimals == 0:\n        assert self._canRegisterVaultToken(_asset, _vaultAddr) # dev: cannot register vault token\n        vaultInfo = self._registerVaultTokenLocally(_asset, _vaultAddr)\n        self._registerVaultTokenGlobally(_asset, _vaultAddr, vaultInfo.decimals, _ledger, _legoBook)\n    else:\n        assert vaultInfo.underlyingAsset == _asset # dev: asset mismatch\n    return vaultInfo\n\n\n# withdraw\n\n\n@external\ndef withdrawFromYield(\n    _vaultToken: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, address, uint256, uint256):\n    assert self._isAllowedToPerformAction(msg.sender) # dev: no perms\n    assert not yld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = yld._getMiniAddys(_miniAddys)\n    vaultInfo: ls.VaultTokenInfo = self._getVaultInfoOnWithdrawal(_vaultToken, miniAddys.ledger, miniAddys.legoBook)\n\n    # pre balances\n    preLegoVaultBalance: uint256 = staticcall IERC20(_vaultToken).balanceOf(self)\n\n    # transfer vaults tokens to this contract\n    vaultTokenAmount: uint256 = min(_amount, staticcall IERC20(_vaultToken).balanceOf(msg.sender))\n    assert vaultTokenAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_vaultToken).transferFrom(msg.sender, self, vaultTokenAmount, default_return_value=True) # dev: transfer failed\n\n    # withdraw assets from lego partner\n    assetAmountReceived: uint256 = extcall IERC4626(_vaultToken).redeem(vaultTokenAmount, _recipient, self)\n    assert assetAmountReceived != 0 # dev: no asset amount received\n\n    # refund if full withdrawal didn't happen\n    currentLegoVaultBalance: uint256 = staticcall IERC20(_vaultToken).balanceOf(self)\n    refundVaultTokenAmount: uint256 = 0\n    if currentLegoVaultBalance > preLegoVaultBalance:\n        refundVaultTokenAmount = currentLegoVaultBalance - preLegoVaultBalance\n        assert extcall IERC20(_vaultToken).transfer(msg.sender, refundVaultTokenAmount, default_return_value=True) # dev: transfer failed\n        vaultTokenAmount -= refundVaultTokenAmount\n\n    usdValue: uint256 = staticcall Appraiser(miniAddys.appraiser).getUnderlyingUsdValue(vaultInfo.underlyingAsset, assetAmountReceived)\n    log FortyAcresWithdrawal(\n        sender = msg.sender,\n        asset = vaultInfo.underlyingAsset,\n        vaultToken = _vaultToken,\n        assetAmountReceived = assetAmountReceived,\n        usdValue = usdValue,\n        vaultTokenAmountBurned = vaultTokenAmount,\n        recipient = _recipient,\n    )\n\n    # add price snapshot\n    pricePerShare: uint256 = self._getPricePerShare(_vaultToken, vaultInfo.decimals)\n    yld._addPriceSnapshot(_vaultToken, pricePerShare, vaultInfo.decimals)\n\n    return vaultTokenAmount, vaultInfo.underlyingAsset, assetAmountReceived, usdValue\n\n\n# vault info on withdrawal\n\n\n@internal\ndef _getVaultInfoOnWithdrawal(_vaultAddr: address, _ledger: address, _legoBook: address) -> ls.VaultTokenInfo:\n    vaultInfo: ls.VaultTokenInfo = yld.vaultToAsset[_vaultAddr]\n    if vaultInfo.decimals == 0:\n        asset: address = staticcall IERC4626(_vaultAddr).asset()\n        assert self._canRegisterVaultToken(asset, _vaultAddr) # dev: cannot register vault token\n        vaultInfo = self._registerVaultTokenLocally(asset, _vaultAddr)\n        self._registerVaultTokenGlobally(asset, _vaultAddr, vaultInfo.decimals, _ledger, _legoBook)\n    return vaultInfo\n\n\n#########\n# Other #\n#########\n\n\n@view\n@external\ndef getAccessForLego(_user: address, _action: ws.ActionType) -> (address, String[64], uint256):\n    return empty(address), empty(String[64]), 0\n\n\n@external\ndef claimRewards(\n    _user: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _extraData: bytes32,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    # backwards compatibility\n    return 0, 0\n\n\n@external\ndef claimIncentives(\n    _user: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _proofs: DynArray[bytes32, MAX_PROOFS],\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@view\n@external\ndef hasClaimableRewards(_user: address) -> bool:\n    return False\n\n\n@external\ndef swapTokens(\n    _amountIn: uint256,\n    _minAmountOut: uint256,\n    _tokenPath: DynArray[address, MAX_TOKEN_PATH],\n    _poolPath: DynArray[address, MAX_TOKEN_PATH - 1],\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256):\n    return 0, 0, 0\n\n\n@external\ndef mintOrRedeemAsset(\n    _tokenIn: address,\n    _tokenOut: address,\n    _tokenInAmount: uint256,\n    _minAmountOut: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, bool, uint256):\n    return 0, 0, False, 0\n\n\n@external\ndef confirmMintOrRedeemAsset(\n    _tokenIn: address,\n    _tokenOut: address,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef addCollateral(\n    _asset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef removeCollateral(\n    _asset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef borrow(\n    _borrowAsset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef repayDebt(\n    _paymentAsset: address,\n    _paymentAmount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef addLiquidity(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _amountA: uint256,\n    _amountB: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _minLpAmount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (address, uint256, uint256, uint256, uint256):\n    return empty(address), 0, 0, 0, 0\n\n\n@external\ndef removeLiquidity(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpToken: address,\n    _lpAmount: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, uint256):\n    return 0, 0, 0, 0\n\n\n@external\ndef addLiquidityConcentrated(\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _tickLower: int24,\n    _tickUpper: int24,\n    _amountA: uint256,\n    _amountB: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, uint256, uint256):\n    return 0, 0, 0, 0, 0\n\n\n@external\ndef removeLiquidityConcentrated(\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _liqToRemove: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, bool, uint256):\n    return 0, 0, 0, False, 0",
            "sha256sum": "bc74f89e67c3f4d3932c5bb2868d1953c605819f0261a5fa11a0b0a8c24b6ff7"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/legos/yield/40Acres.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.3+commit.bff19ea2",
        "integrity": "69b3e21db672b9f1e20be442d3de0f0e7b3af3f9638c9aa26482dd3df963e9db"
      },
      "args": "00000000000000000000000044cf3c4f000dfd76a35d03298049d37be688d6f9000000000000000000000000b99b6df96d4d5448cc0a5b3e0ef7896df9507cf500000000000000000000000087f18b377e625b62c708d5f6ea96ec193558efd00000000000000000000000006162df1b329e157479f8f1407e888260e0ec3d2b",
      "file": "contracts/legos/yield/40Acres.vy"
    },
    "Wasabi": {
      "address": "0xE1fb055fE1Fad2D5f980a7954Ebf1539CA676D1e",
      "abi": [
        {
          "name": "WasabiDeposit",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountDeposited",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultTokenAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "WasabiWithdrawal",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultTokenAmountBurned",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LegoPauseModified",
          "inputs": [
            {
              "name": "isPaused",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LegoFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "balance",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "SnapShotPriceConfigSet",
          "inputs": [
            {
              "name": "minSnapshotDelay",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "maxNumSnapshots",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "maxUpsideDeviation",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "staleTime",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetOpportunityAdded",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultAddr",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetOpportunityRemoved",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultAddr",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PricePerShareSnapShotAdded",
          "inputs": [
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "totalSupply",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "pricePerShare",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "lastAveragePricePerShare",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddys",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "undyToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "hatchery",
                  "type": "address"
                },
                {
                  "name": "lootDistributor",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                },
                {
                  "name": "walletBackpack",
                  "type": "address"
                },
                {
                  "name": "billing",
                  "type": "address"
                },
                {
                  "name": "vaultRegistry",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUndyHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isLegoAsset",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssetOpportunities",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isAssetOpportunity",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getNumLegoAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pause",
          "inputs": [
            {
              "name": "_shouldPause",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFundsMany",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_assets",
              "type": "address[]"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getWeightedPricePerShare",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLatestSnapshot",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_pricePerShare",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "totalSupply",
                  "type": "uint256"
                },
                {
                  "name": "pricePerShare",
                  "type": "uint256"
                },
                {
                  "name": "lastUpdate",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setSnapShotPriceConfig",
          "inputs": [
            {
              "name": "_config",
              "type": "tuple",
              "components": [
                {
                  "name": "minSnapshotDelay",
                  "type": "uint256"
                },
                {
                  "name": "maxNumSnapshots",
                  "type": "uint256"
                },
                {
                  "name": "maxUpsideDeviation",
                  "type": "uint256"
                },
                {
                  "name": "staleTime",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidPriceConfig",
          "inputs": [
            {
              "name": "_config",
              "type": "tuple",
              "components": [
                {
                  "name": "minSnapshotDelay",
                  "type": "uint256"
                },
                {
                  "name": "maxNumSnapshots",
                  "type": "uint256"
                },
                {
                  "name": "maxUpsideDeviation",
                  "type": "uint256"
                },
                {
                  "name": "staleTime",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "vaultToAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "underlyingAsset",
                  "type": "address"
                },
                {
                  "name": "decimals",
                  "type": "uint256"
                },
                {
                  "name": "lastAveragePricePerShare",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assetOpportunities",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAssetOpportunity",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssetOpportunities",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assets",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "snapShotData",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "lastSnapShot",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "totalSupply",
                      "type": "uint256"
                    },
                    {
                      "name": "pricePerShare",
                      "type": "uint256"
                    },
                    {
                      "name": "lastUpdate",
                      "type": "uint256"
                    }
                  ]
                },
                {
                  "name": "nextIndex",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "snapShots",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "totalSupply",
                  "type": "uint256"
                },
                {
                  "name": "pricePerShare",
                  "type": "uint256"
                },
                {
                  "name": "lastUpdate",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "snapShotPriceConfig",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "minSnapshotDelay",
                  "type": "uint256"
                },
                {
                  "name": "maxNumSnapshots",
                  "type": "uint256"
                },
                {
                  "name": "maxUpsideDeviation",
                  "type": "uint256"
                },
                {
                  "name": "staleTime",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isPaused",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasCapability",
          "inputs": [
            {
              "name": "_action",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRegistries",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isYieldLego",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isDexLego",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAsset",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingBalances",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenBalance",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAmount",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAmountSafe",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenBalance",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingData",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingData",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            },
            {
              "name": "_appraiser",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValueOfVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValueOfVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            },
            {
              "name": "_appraiser",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isRebasing",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPricePerShare",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPricePerShare",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_decimals",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getVaultTokenAmount",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_assetAmount",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalAssets",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalBorrows",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAvailLiquidity",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUtilizationRatio",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isEligibleForYieldBonus",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getWithdrawalFees",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canRegisterVaultToken",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "registerVaultTokenLocally",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "underlyingAsset",
                  "type": "address"
                },
                {
                  "name": "decimals",
                  "type": "uint256"
                },
                {
                  "name": "lastAveragePricePerShare",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "deregisterVaultTokenLocally",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addPriceSnapshot",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositForYield",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositForYield",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawFromYield",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawFromYield",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAccessForLego",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_action",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "string"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimIncentives",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_proofs",
              "type": "bytes32[]"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimIncentives",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_proofs",
              "type": "bytes32[]"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasClaimableRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_tokenPath",
              "type": "address[]"
            },
            {
              "name": "_poolPath",
              "type": "address[]"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_tokenPath",
              "type": "address[]"
            },
            {
              "name": "_poolPath",
              "type": "address[]"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_tokenInAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_tokenInAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmMintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmMintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_borrowAsset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_borrowAsset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_paymentAsset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_paymentAsset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "WASABI_LONG_POOL",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "WASABI_SHORT_POOL",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "RIPE_REGISTRY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_undyHq",
              "type": "address"
            },
            {
              "name": "_wasabiLongPool",
              "type": "address"
            },
            {
              "name": "_wasabiShortPool",
              "type": "address"
            },
            {
              "name": "_ripeRegistry",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "interfaces/WalletStructs.vyi": {
            "content": "# @version 0.4.3\n\nflag ActionType:\n    TRANSFER\n    EARN_DEPOSIT\n    EARN_WITHDRAW\n    EARN_REBALANCE\n    SWAP\n    MINT_REDEEM\n    CONFIRM_MINT_REDEEM\n    ADD_COLLATERAL\n    REMOVE_COLLATERAL\n    BORROW\n    REPAY_DEBT\n    REWARDS\n    ETH_TO_WETH\n    WETH_TO_ETH\n    ADD_LIQ\n    REMOVE_LIQ\n    ADD_LIQ_CONC\n    REMOVE_LIQ_CONC\n    PAY_CHEQUE\n\nstruct WalletAssetData:\n    assetBalance: uint256\n    usdValue: uint256\n    isYieldAsset: bool\n    lastPricePerShare: uint256\n\nstruct ActionData:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    billing: address\n    vaultRegistry: address\n    wallet: address\n    walletConfig: address\n    walletOwner: address\n    inEjectMode: bool\n    isFrozen: bool\n    lastTotalUsdValue: uint256\n    signer: address\n    isManager: bool\n    legoId: uint256\n    legoAddr: address\n    eth: address\n    weth: address\n\nstruct MiniAddys:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    appraiser: address",
            "sha256sum": "466493c129135c95470aaf70eeddc936632f7b0f813396e5a7ddc03bea9da518"
          },
          "interfaces/LegoPartner.vyi": {
            "content": "# @version 0.4.3\n\nfrom interfaces import WalletStructs as ws\n\nMAX_TOKEN_PATH: constant(uint256) = 5\nMAX_RECOVER_ASSETS: constant(uint256) = 20\nMAX_PROOFS: constant(uint256) = 25\n\n@external\ndef addLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _tickLower: int24, _tickUpper: int24, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef addLiquidity(_pool: address, _tokenA: address, _tokenB: address, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _minLpAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (address, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef removeLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _liqToRemove: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef removeLiquidity(_pool: address, _tokenA: address, _tokenB: address, _lpToken: address, _lpAmount: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef mintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _tokenInAmount: uint256, _minAmountOut: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef swapTokens(_amountIn: uint256, _minAmountOut: uint256, _tokenPath: DynArray[address, MAX_TOKEN_PATH], _poolPath: DynArray[address, MAX_TOKEN_PATH - 1], _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256):\n    ...\n\n@external\ndef depositForYield(_asset: address, _amount: uint256, _vaultAddr: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef withdrawFromYield(_vaultToken: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef confirmMintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef borrow(_borrowAsset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef repayDebt(_paymentAsset: address, _paymentAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef claimIncentives(_user: address, _rewardToken: address, _rewardAmount: uint256, _proofs: DynArray[bytes32, MAX_PROOFS], _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef removeCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef addCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@view\n@external\ndef getAccessForLego(_user: address, _action: ws.ActionType) -> (address, String[64], uint256):\n    ...\n\n@view\n@external\ndef hasCapability(_action: ws.ActionType) -> bool:\n    ...\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    ...\n\n@view\n@external\ndef isYieldLego() -> bool:\n    ...\n\n@view\n@external\ndef isDexLego() -> bool:\n    ...\n\n\n# common\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "f2afb7bd72d4301aea77bbe4177b7ae954ba6f6b76af363965993eb92ad0b715"
          },
          "interfaces/LegoStructs.vyi": {
            "content": "# @version 0.4.3\n\nstruct VaultTokenInfo:\n    underlyingAsset: address\n    decimals: uint256\n    lastAveragePricePerShare: uint256\n\nstruct SnapShotPriceConfig:\n    minSnapshotDelay: uint256\n    maxNumSnapshots: uint256\n    maxUpsideDeviation: uint256\n    staleTime: uint256\n\nstruct SingleSnapShot:\n    totalSupply: uint256\n    pricePerShare: uint256\n    lastUpdate: uint256\n\nstruct SnapShotData:\n    lastSnapShot: SingleSnapShot\n    nextIndex: uint256\n",
            "sha256sum": "8ae48be17d812d57fbd671bbf0593e8abf175ad0924e47c5997823cac19ec806"
          },
          "interfaces/YieldLego.vyi": {
            "content": "# @version 0.4.3\n\nfrom interfaces import LegoStructs as ls\n\n\n###################\n# Underlying Data #\n###################\n\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    ...\n\n\n@view\n@external\ndef getUnderlyingBalances(_vaultToken: address, _vaultTokenBalance: uint256) -> (uint256, uint256):\n    ...\n\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    ...\n\n\n@view\n@external\ndef getUnderlyingAmountSafe(_vaultToken: address, _vaultTokenBalance: uint256) -> uint256:\n    ...\n\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> (address, uint256, uint256):\n    ...\n\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> uint256:\n    ...\n\n\n###############\n# Other Utils #\n###############\n\n\n@view\n@external\ndef isRebasing() -> bool:\n    ...\n\n\n@view\n@external\ndef getPricePerShare(_vaultToken: address, _decimals: uint256 = 0) -> uint256:\n    ...\n\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef canRegisterVaultToken(_asset: address, _vaultToken: address) -> bool:\n    ...\n\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef getUtilizationRatio(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef getAvailLiquidity(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef isEligibleForYieldBonus(_asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef getWithdrawalFees(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    ...\n\n\n###################\n# Yield Lego Data #\n###################\n\n\n@view\n@external\ndef isLegoAsset(_asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, 40]:\n    ...\n\n\n@view\n@external\ndef getAssets() -> DynArray[address, 20]:\n    ...\n\n\n@view\n@external\ndef isAssetOpportunity(_asset: address, _vaultAddr: address) -> bool:\n    ...\n\n\n@view\n@external\ndef getNumLegoAssets() -> uint256:\n    ...\n\n\n@view\n@external\ndef assets(_index: uint256) -> address:\n    ...\n\n\n@view\n@external\ndef indexOfAsset(_asset: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef numAssets() -> uint256:\n    ...\n\n\n@view\n@external\ndef assetOpportunities(_asset: address, _index: uint256) -> address:\n    ...\n\n\n@view\n@external\ndef indexOfAssetOpportunity(_asset: address, _vaultAddr: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef numAssetOpportunities(_asset: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef vaultToAsset(_vaultAddr: address) -> ls.VaultTokenInfo:\n    ...\n\n\n# price snapshots\n\n\n@external\ndef addPriceSnapshot(_vaultToken: address) -> bool:\n    ...\n\n\n@view\n@external\ndef snapShotPriceConfig() -> ls.SnapShotPriceConfig:\n    ...\n\n\n@view\n@external\ndef snapShotData(_vaultToken: address) -> ls.SnapShotData:\n    ...\n\n\n@view\n@external\ndef snapShots(_vaultToken: address, _index: uint256) -> ls.SingleSnapShot:\n    ...\n\n\n@view\n@external\ndef getWeightedPricePerShare(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef getLatestSnapshot(_vaultToken: address, _pricePerShare: uint256) -> ls.SingleSnapShot:\n    ...\n\n\n@external\ndef setSnapShotPriceConfig(_config: ls.SnapShotPriceConfig):\n    ...\n",
            "sha256sum": "db91c139f6018f5218b389d08c8703bc16fb994aa948805dbfea27e072f382ec"
          },
          "contracts/modules/Addys.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\ninterface UndyHq:\n    def isValidAddr(_addr: address) -> bool: view\n    def getAddr(_regId: uint256) -> address: view\n    def undyToken() -> address: view\n\ninterface Switchboard:\n    def isSwitchboardAddr(_addr: address) -> bool: view\n\ninterface LegoBook:\n    def isLegoAddr(_addr: address) -> bool: view\n\nstruct Addys:\n    hq: address\n    undyToken: address\n    ledger: address\n    missionControl: address\n    legoBook: address\n    switchboard: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    walletBackpack: address\n    billing: address\n    vaultRegistry: address\n\n# hq\nUNDY_HQ_FOR_ADDYS: immutable(address)\n\n# core addys\nLEDGER_ID: constant(uint256) = 1\nMISSION_CONTROL_ID: constant(uint256) = 2\nLEGO_BOOK_ID: constant(uint256) = 3\nSWITCHBOARD_ID: constant(uint256) = 4\nHATCHERY_ID: constant(uint256) = 5\nLOOT_DISTRIBUTOR_ID: constant(uint256) = 6\nAPPRAISER_ID: constant(uint256) = 7\nWALLET_BACKPACK_ID: constant(uint256) = 8\nBILLING_ID: constant(uint256) = 9\nVAULT_REGISTRY_ID: constant(uint256) = 10\n\n\n@deploy\ndef __init__(_undyHq: address):\n    assert _undyHq != empty(address) # dev: invalid undy hq\n    UNDY_HQ_FOR_ADDYS = _undyHq\n\n\n########\n# Core #\n########\n\n\n@view\n@external\ndef getAddys() -> Addys:\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _getAddys(_addys: Addys = empty(Addys)) -> Addys:\n    if _addys.hq != empty(address):\n        return _addys\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _generateAddys() -> Addys:\n    hq: address = UNDY_HQ_FOR_ADDYS\n    return Addys(\n        hq = hq,\n        undyToken = staticcall UndyHq(hq).undyToken(),\n        ledger = staticcall UndyHq(hq).getAddr(LEDGER_ID),\n        missionControl = staticcall UndyHq(hq).getAddr(MISSION_CONTROL_ID),\n        legoBook = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID),\n        switchboard = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID),\n        hatchery = staticcall UndyHq(hq).getAddr(HATCHERY_ID),\n        lootDistributor = staticcall UndyHq(hq).getAddr(LOOT_DISTRIBUTOR_ID),\n        appraiser = staticcall UndyHq(hq).getAddr(APPRAISER_ID),\n        walletBackpack = staticcall UndyHq(hq).getAddr(WALLET_BACKPACK_ID),\n        billing = staticcall UndyHq(hq).getAddr(BILLING_ID),\n        vaultRegistry = staticcall UndyHq(hq).getAddr(VAULT_REGISTRY_ID),\n    )\n\n\n##########\n# Tokens #\n##########\n\n\n@view\n@internal\ndef _getUndyToken() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).undyToken()\n\n\n###########\n# Helpers #\n###########\n\n\n# undy hq\n\n\n@view\n@external\ndef getUndyHq() -> address:\n    return self._getUndyHq()\n\n\n@view\n@internal\ndef _getUndyHq() -> address:\n    return UNDY_HQ_FOR_ADDYS\n\n\n# utils\n\n\n@view\n@internal\ndef _isValidUndyAddr(_addr: address, _hq: address = empty(address)) -> bool:\n    hq: address = _hq\n    if _hq == empty(address):\n        hq = UNDY_HQ_FOR_ADDYS\n    \n    # core departments\n    if staticcall UndyHq(hq).isValidAddr(_addr):\n        return True\n\n    # lego book\n    legoBook: address = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID)\n    if legoBook != empty(address) and staticcall LegoBook(legoBook).isLegoAddr(_addr):\n        return True\n\n    # switchboard config\n    switchboard: address = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID)\n    if switchboard != empty(address) and staticcall Switchboard(switchboard).isSwitchboardAddr(_addr):\n        return True\n\n    return False\n\n\n@view\n@internal\ndef _isSwitchboardAddr(_addr: address) -> bool:\n    switchboard: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n    if switchboard == empty(address):\n        return False\n    return staticcall Switchboard(switchboard).isSwitchboardAddr(_addr)\n\n\n@view\n@internal\ndef _isLegoBookAddr(_addr: address) -> bool:\n    legoBook: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n    if legoBook == empty(address):\n        return False\n    return staticcall LegoBook(legoBook).isLegoAddr(_addr)\n\n\n###############\n# Departments #\n###############\n\n\n# ledger\n\n\n@view\n@internal\ndef _getLedgerId() -> uint256:\n    return LEDGER_ID\n\n\n@view\n@internal\ndef _getLedgerAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEDGER_ID)\n\n\n# mission control\n\n\n@view\n@internal\ndef _getMissionControlId() -> uint256:\n    return MISSION_CONTROL_ID\n\n\n@view\n@internal\ndef _getMissionControlAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(MISSION_CONTROL_ID)\n\n\n# lego book\n\n\n@view\n@internal\ndef _getLegoBookId() -> uint256:\n    return LEGO_BOOK_ID\n\n\n@view\n@internal\ndef _getLegoBookAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n\n\n# switchboard\n\n\n@view\n@internal\ndef _getSwitchboardId() -> uint256:\n    return SWITCHBOARD_ID\n\n\n@view\n@internal\ndef _getSwitchboardAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n\n\n# hatchery\n\n\n@view\n@internal\ndef _getHatcheryId() -> uint256:\n    return HATCHERY_ID\n\n\n@view\n@internal\ndef _getHatcheryAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(HATCHERY_ID)\n\n\n# loot distributor\n\n\n@view\n@internal\ndef _getLootDistributorId() -> uint256:\n    return LOOT_DISTRIBUTOR_ID\n\n\n@view\n@internal\ndef _getLootDistributorAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LOOT_DISTRIBUTOR_ID)\n\n\n# appraiser\n\n\n@view\n@internal\ndef _getAppraiserId() -> uint256:\n    return APPRAISER_ID\n\n\n@view\n@internal\ndef _getAppraiserAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(APPRAISER_ID)\n\n\n# wallet backpack\n\n\n@view\n@internal\ndef _getWalletBackpackId() -> uint256:\n    return WALLET_BACKPACK_ID\n\n\n@view\n@internal\ndef _getWalletBackpackAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(WALLET_BACKPACK_ID)\n\n\n# billing\n\n\n@view\n@internal\ndef _getBillingId() -> uint256:\n    return BILLING_ID\n\n\n@view\n@internal\ndef _getBillingAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(BILLING_ID)\n\n\n# vault registry\n\n\n@view\n@internal\ndef _getVaultRegistryId() -> uint256:\n    return VAULT_REGISTRY_ID\n\n\n@view\n@internal\ndef _getVaultRegistryAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(VAULT_REGISTRY_ID)",
            "sha256sum": "4df6b72db9bb417d1af81660175be1450cfb7b3575f3d17a5b8a130bff87b781"
          },
          "contracts/modules/YieldLegoData.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nuses: addys\n\nimport contracts.modules.Addys as addys\n\nfrom interfaces import WalletStructs as ws\nfrom interfaces import LegoStructs as ls\nfrom ethereum.ercs import IERC20\nfrom ethereum.ercs import IERC20Detailed\n\nevent AssetOpportunityAdded:\n    asset: indexed(address)\n    vaultAddr: indexed(address)\n\nevent AssetOpportunityRemoved:\n    asset: indexed(address)\n    vaultAddr: indexed(address)\n\nevent LegoPauseModified:\n    isPaused: bool\n\nevent LegoFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    balance: uint256\n\nevent PricePerShareSnapShotAdded:\n    vaultToken: indexed(address)\n    totalSupply: uint256\n    pricePerShare: uint256\n    lastAveragePricePerShare: uint256\n\nevent SnapShotPriceConfigSet:\n    minSnapshotDelay: uint256\n    maxNumSnapshots: uint256\n    maxUpsideDeviation: uint256\n    staleTime: uint256\n\n# core\nvaultToAsset: public(HashMap[address, ls.VaultTokenInfo]) # vault addr -> data\n\n# asset opportunities\nassetOpportunities: public(HashMap[address, HashMap[uint256, address]]) # asset -> index -> vault addr\nindexOfAssetOpportunity: public(HashMap[address, HashMap[address, uint256]]) # asset -> vault addr -> index\nnumAssetOpportunities: public(HashMap[address, uint256]) # asset -> number of opportunities\n\n# lego assets (iterable)\nassets: public(HashMap[uint256, address]) # index -> asset\nindexOfAsset: public(HashMap[address, uint256]) # asset -> index\nnumAssets: public(uint256) # num assets\n\n# price snapshots\nsnapShotData: public(HashMap[address, ls.SnapShotData]) # vault token -> data\nsnapShots: public(HashMap[address, HashMap[uint256, ls.SingleSnapShot]]) # vault token -> index -> snapshot\nsnapShotPriceConfig: public(ls.SnapShotPriceConfig) # config\n\nisPaused: public(bool)\n\nMAX_VAULTS: constant(uint256) = 40\nMAX_ASSETS: constant(uint256) = 20\nMAX_RECOVER_ASSETS: constant(uint256) = 20\nONE_DAY_SECONDS: constant(uint256) = 60 * 60 * 24\nONE_WEEK_SECONDS: constant(uint256) = ONE_DAY_SECONDS * 7\nHUNDRED_PERCENT: constant(uint256) = 100_00\n\n\n@deploy\ndef __init__(_shouldPause: bool):\n    self.isPaused = _shouldPause\n    self.numAssets = 1 # not using 0 index\n\n    # default snapshot price config\n    self.snapShotPriceConfig = ls.SnapShotPriceConfig(\n        minSnapshotDelay = 60 * 10, # 10 minutes\n        maxNumSnapshots = 20,\n        maxUpsideDeviation = 10_00, # 10%\n        staleTime = ONE_DAY_SECONDS, # 1 day\n    )\n\n\n#########\n# Views #\n#########\n\n\n# is lego asset\n\n\n@view\n@external\ndef isLegoAsset(_asset: address) -> bool:\n    return self._isLegoAsset(_asset)\n\n\n@view\n@internal\ndef _isLegoAsset(_asset: address) -> bool:\n    return self.indexOfAsset[_asset] != 0\n\n\n# vault opportunities\n\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, MAX_VAULTS]:\n    numOpportunities: uint256 = self.numAssetOpportunities[_asset]\n    if numOpportunities == 0:\n        return []\n    opportunities: DynArray[address, MAX_VAULTS] = []\n    for i: uint256 in range(1, numOpportunities, bound=MAX_VAULTS):\n        opportunities.append(self.assetOpportunities[_asset][i])\n    return opportunities\n\n\n# all assets registered\n\n\n@view\n@external\ndef getAssets() -> DynArray[address, MAX_ASSETS]:\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return []\n    assets: DynArray[address, MAX_ASSETS] = []\n    for i: uint256 in range(1, numAssets, bound=MAX_ASSETS):\n        assets.append(self.assets[i])\n    return assets\n\n\n################\n# Registration #\n################\n\n\n@view\n@external\ndef isAssetOpportunity(_asset: address, _vaultAddr: address) -> bool:\n    return self._isAssetOpportunity(_asset, _vaultAddr)\n\n\n@view\n@internal\ndef _isAssetOpportunity(_asset: address, _vaultAddr: address) -> bool:\n    return self.indexOfAssetOpportunity[_asset][_vaultAddr] != 0\n\n\n# add asset opportunity\n\n\n@internal\ndef _addAssetOpportunity(_asset: address, _vaultAddr: address) -> ls.VaultTokenInfo:\n    if self.indexOfAssetOpportunity[_asset][_vaultAddr] != 0:\n        return self.vaultToAsset[_vaultAddr]\n\n    if empty(address) in [_asset, _vaultAddr]:\n        return empty(ls.VaultTokenInfo)\n\n    # add asset opportunity\n    aid: uint256 = self.numAssetOpportunities[_asset]\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.assetOpportunities[_asset][aid] = _vaultAddr\n    self.indexOfAssetOpportunity[_asset][_vaultAddr] = aid\n    self.numAssetOpportunities[_asset] = aid + 1\n\n    # add mapping\n    vaultInfo: ls.VaultTokenInfo = ls.VaultTokenInfo(\n        underlyingAsset = _asset,\n        decimals = convert(staticcall IERC20Detailed(_vaultAddr).decimals(), uint256),\n        lastAveragePricePerShare = 0,\n    )\n    self.vaultToAsset[_vaultAddr] = vaultInfo\n\n    # add asset\n    self._addAsset(_asset)\n\n    log AssetOpportunityAdded(asset=_asset, vaultAddr=_vaultAddr)\n    return vaultInfo\n\n\n# remove asset opportunity\n\n\n@internal\ndef _removeAssetOpportunity(_asset: address, _vaultAddr: address):\n    numOpportunities: uint256 = self.numAssetOpportunities[_asset]\n    if numOpportunities == 0:\n        return\n\n    targetIndex: uint256 = self.indexOfAssetOpportunity[_asset][_vaultAddr]\n    if targetIndex == 0:\n        return\n\n    # update data\n    lastIndex: uint256 = numOpportunities - 1\n    self.numAssetOpportunities[_asset] = lastIndex\n    self.indexOfAssetOpportunity[_asset][_vaultAddr] = 0\n\n    self.vaultToAsset[_vaultAddr] = empty(ls.VaultTokenInfo)\n\n    # clear all snapshot data for the vault token to prevent contamination on re-add\n    self.snapShotData[_vaultAddr] = empty(ls.SnapShotData)\n\n    # clear all historical snapshots\n    config: ls.SnapShotPriceConfig = self.snapShotPriceConfig\n    for i: uint256 in range(config.maxNumSnapshots, bound=max_value(uint256)):\n        if i >= config.maxNumSnapshots:\n            break\n        self.snapShots[_vaultAddr][i] = empty(ls.SingleSnapShot)\n\n    # shift to replace the removed one\n    if targetIndex != lastIndex:\n        lastVaultAddr: address = self.assetOpportunities[_asset][lastIndex]\n        self.assetOpportunities[_asset][targetIndex] = lastVaultAddr\n        self.indexOfAssetOpportunity[_asset][lastVaultAddr] = targetIndex\n\n    # remove asset\n    if lastIndex <= 1:\n        self._removeAsset(_asset)\n\n    log AssetOpportunityRemoved(asset=_asset, vaultAddr=_vaultAddr)\n\n\n# add asset\n\n\n@internal\ndef _addAsset(_asset: address):\n    if self.indexOfAsset[_asset] != 0:\n        return\n\n    aid: uint256 = self.numAssets\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.assets[aid] = _asset\n    self.indexOfAsset[_asset] = aid\n    self.numAssets = aid + 1\n\n\n# remove asset\n\n\n@internal\ndef _removeAsset(_asset: address):\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return\n\n    targetIndex: uint256 = self.indexOfAsset[_asset]\n    if targetIndex == 0:\n        return\n\n    # update data\n    lastIndex: uint256 = numAssets - 1\n    self.numAssets = lastIndex\n    self.indexOfAsset[_asset] = 0\n\n    # shift to replace the removed one\n    if targetIndex != lastIndex:\n        lastAsset: address = self.assets[lastIndex]\n        self.assets[targetIndex] = lastAsset\n        self.indexOfAsset[lastAsset] = targetIndex\n\n\n# num lego assets (true number, use `numAssets` for iteration)\n\n\n@view\n@external\ndef getNumLegoAssets() -> uint256:\n    return self._getNumLegoAssets()\n\n\n@view\n@internal\ndef _getNumLegoAssets() -> uint256:\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return 0\n    return numAssets - 1\n\n\n###########\n# General #\n###########\n\n\n# fill mini addys\n\n\n@view\n@internal\ndef _getMiniAddys(_miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> ws.MiniAddys:\n    if _miniAddys.ledger != empty(address):\n        return _miniAddys\n    return ws.MiniAddys(\n        ledger = addys._getLedgerAddr(),\n        missionControl = addys._getMissionControlAddr(),\n        legoBook = addys._getLegoBookAddr(),\n        appraiser = addys._getAppraiserAddr(),\n    )\n\n\n# activate\n\n\n@external\ndef pause(_shouldPause: bool):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert _shouldPause != self.isPaused # dev: no change\n    self.isPaused = _shouldPause\n    log LegoPauseModified(isPaused=_shouldPause)\n\n\n# recover funds\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    self._recoverFunds(_recipient, _asset)\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, MAX_RECOVER_ASSETS]):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    for a: address in _assets:\n        self._recoverFunds(_recipient, a)\n\n\n@internal\ndef _recoverFunds(_recipient: address, _asset: address):\n    assert empty(address) not in [_recipient, _asset] # dev: invalid recipient or asset\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    assert balance != 0 # dev: nothing to recover\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log LegoFundsRecovered(asset=_asset, recipient=_recipient, balance=balance)\n\n\n###################\n# Price Snapshots #\n###################\n\n\n# add price snapshot\n\n\n@internal\ndef _addPriceSnapshot(_vaultToken: address, _pricePerShare: uint256, _vaultTokenDecimals: uint256) -> bool:\n    config: ls.SnapShotPriceConfig = self.snapShotPriceConfig\n    if config.maxNumSnapshots == 0:\n        return False\n\n    data: ls.SnapShotData = self.snapShotData[_vaultToken]\n\n    # already have snapshot for this time\n    if data.lastSnapShot.lastUpdate == block.timestamp:\n        return False\n\n    # check if snapshot is too recent\n    if data.lastSnapShot.lastUpdate + config.minSnapshotDelay > block.timestamp:\n        return False\n\n    # create and store new snapshot\n    newSnapshot: ls.SingleSnapShot = self._getLatestSnapshot(_vaultToken, _pricePerShare, _vaultTokenDecimals, data.lastSnapShot, config)\n    data.lastSnapShot = newSnapshot\n    self.snapShots[_vaultToken][data.nextIndex] = newSnapshot\n\n    # update index\n    data.nextIndex += 1\n    if data.nextIndex >= config.maxNumSnapshots:\n        data.nextIndex = 0\n\n    # save snap shot data\n    self.snapShotData[_vaultToken] = data\n\n    # update cached weighted average price per share\n    lastAveragePricePerShare: uint256 = self._getWeightedPricePerShare(_vaultToken, _pricePerShare)\n    self.vaultToAsset[_vaultToken].lastAveragePricePerShare = lastAveragePricePerShare\n\n    log PricePerShareSnapShotAdded(\n        vaultToken = _vaultToken,\n        totalSupply = newSnapshot.totalSupply,\n        pricePerShare = newSnapshot.pricePerShare,\n        lastAveragePricePerShare = lastAveragePricePerShare,\n    )\n    return True\n\n\n# weighted price per share\n\n\n@view\n@external\ndef getWeightedPricePerShare(_vaultToken: address) -> uint256:\n    data: ls.SnapShotData = self.snapShotData[_vaultToken]\n    return self._getWeightedPricePerShare(_vaultToken, data.lastSnapShot.pricePerShare)\n\n\n@view\n@internal\ndef _getWeightedPricePerShare(_vaultToken: address, _lastPricePerShare: uint256) -> uint256:\n    config: ls.SnapShotPriceConfig = self.snapShotPriceConfig\n    if config.maxNumSnapshots == 0:\n        return 0\n\n    # calculate weighted average price using all valid snapshots\n    numerator: uint256 = 0\n    denominator: uint256 = 0\n    for i: uint256 in range(config.maxNumSnapshots, bound=max_value(uint256)):\n\n        snapShot: ls.SingleSnapShot = self.snapShots[_vaultToken][i]\n        if snapShot.pricePerShare == 0 or snapShot.totalSupply == 0 or snapShot.lastUpdate == 0:\n            continue\n\n        # too stale, skip\n        if config.staleTime != 0 and block.timestamp > snapShot.lastUpdate + config.staleTime:\n            continue\n\n        numerator += (snapShot.totalSupply * snapShot.pricePerShare)\n        denominator += snapShot.totalSupply\n\n    # weighted price per share\n    weightedPricePerShare: uint256 = 0\n    if numerator != 0:\n        weightedPricePerShare = numerator // denominator\n    else:\n        weightedPricePerShare = _lastPricePerShare\n\n    return weightedPricePerShare\n\n\n# latest snapshot\n\n\n@view\n@external\ndef getLatestSnapshot(_vaultToken: address, _pricePerShare: uint256) -> ls.SingleSnapShot:\n    data: ls.SnapShotData = self.snapShotData[_vaultToken]\n    config: ls.SnapShotPriceConfig = self.snapShotPriceConfig\n    vaultTokenDecimals: uint256 = self.vaultToAsset[_vaultToken].decimals\n    return self._getLatestSnapshot(_vaultToken, _pricePerShare, vaultTokenDecimals, data.lastSnapShot, config)\n\n\n@view\n@internal\ndef _getLatestSnapshot(\n    _vaultToken: address,\n    _pricePerShare: uint256,\n    _vaultTokenDecimals: uint256,\n    _lastSnapShot: ls.SingleSnapShot,\n    _config: ls.SnapShotPriceConfig,\n) -> ls.SingleSnapShot:\n\n    # total supply (adjusted)\n    totalSupply: uint256 = staticcall IERC20(_vaultToken).totalSupply() // (10 ** _vaultTokenDecimals)\n    if totalSupply == 0:\n        totalSupply = 1\n\n    # throttle upside (extra safety check)\n    pricePerShare: uint256 = self._throttleUpside(_pricePerShare, _lastSnapShot.pricePerShare, _config.maxUpsideDeviation)\n\n    return ls.SingleSnapShot(\n        totalSupply = totalSupply,\n        pricePerShare = pricePerShare,\n        lastUpdate = block.timestamp,\n    )\n\n\n@view\n@internal\ndef _throttleUpside(_newValue: uint256, _prevValue: uint256, _maxUpside: uint256) -> uint256:\n    if _maxUpside == 0 or _prevValue == 0 or _newValue == 0:\n        return _newValue\n    maxPricePerShare: uint256 = _prevValue + (_prevValue * _maxUpside // HUNDRED_PERCENT)\n    return min(_newValue, maxPricePerShare)\n\n\n# snapshot price config\n\n\n@external\ndef setSnapShotPriceConfig(_config: ls.SnapShotPriceConfig):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert self._isValidPriceConfig(_config) # dev: invalid config\n    self.snapShotPriceConfig = _config\n    log SnapShotPriceConfigSet(\n        minSnapshotDelay=_config.minSnapshotDelay,\n        maxNumSnapshots=_config.maxNumSnapshots,\n        maxUpsideDeviation=_config.maxUpsideDeviation,\n        staleTime=_config.staleTime\n    )\n\n\n@view\n@external\ndef isValidPriceConfig(_config: ls.SnapShotPriceConfig) -> bool:\n    return self._isValidPriceConfig(_config)\n\n\n@view\n@internal\ndef _isValidPriceConfig(_config: ls.SnapShotPriceConfig) -> bool:\n    if _config.minSnapshotDelay > ONE_WEEK_SECONDS:\n        return False\n    if _config.maxNumSnapshots == 0 or _config.maxNumSnapshots > 25:\n        return False\n    if _config.maxUpsideDeviation > HUNDRED_PERCENT:\n        return False\n    return _config.staleTime < ONE_WEEK_SECONDS",
            "sha256sum": "50440c96dc8a7af22e7ad927bb6d3e308f137d5d3632e633e084b05510c94c28"
          },
          "contracts/legos/yield/Wasabi.vy": {
            "content": "#     __   __ ___ _______ ___     ______       ___     _______ _______ _______ \n#    |  | |  |   |       |   |   |      |     |   |   |       |       |       |\n#    |  |_|  |   |    ___|   |   |  _    |    |   |   |    ___|    ___|   _   |\n#    |       |   |   |___|   |   | | |   |    |   |   |   |___|   | __|  | |  |\n#    |_     _|   |    ___|   |___| |_|   |    |   |___|    ___|   ||  |  |_|  |\n#      |   | |   |   |___|       |       |    |       |   |___|   |_| |       |\n#      |___| |___|_______|_______|______|     |_______|_______|_______|_______|\n#                                                                       \n#     \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n#     \u2551  ** Wasabi Protocol **              \u2551\n#     \u2551  Integration with Wasabi Protocol.  \u2551\n#     \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n#\n#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nimplements: Lego\nimplements: YieldLego\n\nexports: addys.__interface__\nexports: yld.__interface__\n\ninitializes: addys\ninitializes: yld[addys := addys]\n\nfrom interfaces import LegoPartner as Lego\nfrom interfaces import YieldLego as YieldLego\nfrom interfaces import WalletStructs as ws\nfrom interfaces import LegoStructs as ls\n\nimport contracts.modules.Addys as addys\nimport contracts.modules.YieldLegoData as yld\n\nfrom ethereum.ercs import IERC20\nfrom ethereum.ercs import IERC4626\nfrom ethereum.ercs import IERC20Detailed\n\ninterface Ledger:\n    def setVaultToken(_vaultToken: address, _legoId: uint256, _underlyingAsset: address, _decimals: uint256, _isRebasing: bool): nonpayable\n    def isRegisteredVaultToken(_vaultToken: address) -> bool: view\n    def isUserWallet(_user: address) -> bool: view\n\ninterface Registry:\n    def getRegId(_addr: address) -> uint256: view\n    def isValidAddr(_addr: address) -> bool: view\n\ninterface Appraiser:\n    def getUnderlyingUsdValue(_asset: address, _amount: uint256) -> uint256: view\n\ninterface VaultRegistry:\n    def isEarnVault(_vaultAddr: address) -> bool: view\n\ninterface WasabiRegistry:\n    def getVault(_asset: address) -> address: view\n\nevent WasabiDeposit:\n    sender: indexed(address)\n    asset: indexed(address)\n    vaultToken: indexed(address)\n    assetAmountDeposited: uint256\n    usdValue: uint256\n    vaultTokenAmountReceived: uint256\n    recipient: address\n\nevent WasabiWithdrawal:\n    sender: indexed(address)\n    asset: indexed(address)\n    vaultToken: indexed(address)\n    assetAmountReceived: uint256\n    usdValue: uint256\n    vaultTokenAmountBurned: uint256\n    recipient: address\n\n# wasabi\nWASABI_LONG_POOL: public(immutable(address))\nWASABI_SHORT_POOL: public(immutable(address))\nRIPE_REGISTRY: public(immutable(address))\n\nMAX_TOKEN_PATH: constant(uint256) = 5\nMAX_PROOFS: constant(uint256) = 25\nHUNDRED_PERCENT: constant(uint256) = 100_00\n\n\n@deploy\ndef __init__(_undyHq: address, _wasabiLongPool: address, _wasabiShortPool: address, _ripeRegistry: address):\n    addys.__init__(_undyHq)\n    yld.__init__(False)\n\n    assert empty(address) not in [_wasabiLongPool, _wasabiShortPool, _ripeRegistry] # dev: invalid addrs\n    WASABI_LONG_POOL = _wasabiLongPool\n    WASABI_SHORT_POOL = _wasabiShortPool\n    RIPE_REGISTRY = _ripeRegistry\n\n\n@view\n@external\ndef hasCapability(_action: ws.ActionType) -> bool:\n    return _action in (\n        ws.ActionType.EARN_DEPOSIT | \n        ws.ActionType.EARN_WITHDRAW\n    )\n\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    return [WASABI_LONG_POOL, WASABI_SHORT_POOL]\n\n\n@view\n@external\ndef isYieldLego() -> bool:\n    return True\n\n\n@view\n@external\ndef isDexLego() -> bool:\n    return False\n\n\n###################\n# Underlying Data #\n###################\n\n\n# underlying asset\n\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    return self._getUnderlyingAsset(_vaultToken)\n\n\n@view\n@internal\ndef _getUnderlyingAsset(_vaultToken: address) -> address:\n    asset: address = yld.vaultToAsset[_vaultToken].underlyingAsset\n    if asset != empty(address):\n        return asset\n    return staticcall IERC4626(_vaultToken).asset()\n\n\n# underlying balances (both true and safe)\n\n\n@view\n@external\ndef getUnderlyingBalances(_vaultToken: address, _vaultTokenBalance: uint256) -> (uint256, uint256):\n    if _vaultTokenBalance == 0:\n        return 0, 0\n\n    trueUnderlying: uint256 = self._getUnderlyingAmount(_vaultToken, _vaultTokenBalance)\n    safeUnderlying: uint256 = self._getUnderlyingAmountSafe(_vaultToken, _vaultTokenBalance)\n    if safeUnderlying == 0:\n        safeUnderlying = trueUnderlying\n\n    return trueUnderlying, min(trueUnderlying, safeUnderlying)\n\n\n# underlying amount (true)\n\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    return self._getUnderlyingAmount(_vaultToken, _vaultTokenAmount)\n\n\n@view\n@internal\ndef _getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    return staticcall IERC4626(_vaultToken).previewRedeem(_vaultTokenAmount)\n\n\n# underlying amount (safe)\n\n\n@view\n@external\ndef getUnderlyingAmountSafe(_vaultToken: address, _vaultTokenBalance: uint256) -> uint256:\n    return self._getUnderlyingAmountSafe(_vaultToken, _vaultTokenBalance)\n\n\n@view\n@internal\ndef _getUnderlyingAmountSafe(_vaultToken: address, _vaultTokenBalance: uint256) -> uint256:\n    vaultInfo: ls.VaultTokenInfo = yld.vaultToAsset[_vaultToken]\n    if vaultInfo.decimals == 0:\n        return 0 # not registered\n\n    # safe underlying amount (using cached weighted average from snapshots)\n    return _vaultTokenBalance * vaultInfo.lastAveragePricePerShare // (10 ** vaultInfo.decimals)\n\n\n# underlying data (combined)\n\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> (address, uint256, uint256):\n    return self._getUnderlyingData(_vaultToken, _vaultTokenAmount, _appraiser)\n\n\n@view\n@internal\ndef _getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address) -> (address, uint256, uint256):\n    asset: address = self._getUnderlyingAsset(_vaultToken)\n    if asset == empty(address):\n        return empty(address), 0, 0 # invalid vault token\n    underlyingAmount: uint256 = self._getUnderlyingAmount(_vaultToken, _vaultTokenAmount)\n    usdValue: uint256 = self._getUsdValue(asset, underlyingAmount, _appraiser)\n    return asset, underlyingAmount, usdValue\n\n\n# usd value\n\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> uint256:\n    return self._getUsdValueOfVaultToken(_vaultToken, _vaultTokenAmount, _appraiser)\n\n\n@view\n@internal\ndef _getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address) -> uint256:\n    return self._getUnderlyingData(_vaultToken, _vaultTokenAmount, _appraiser)[2]\n\n\n@view\n@internal\ndef _getUsdValue(_asset: address, _amount: uint256, _appraiser: address) -> uint256:\n    appraiser: address = _appraiser\n    if _appraiser == empty(address):\n        appraiser = addys._getAppraiserAddr()\n    return staticcall Appraiser(appraiser).getUnderlyingUsdValue(_asset, _amount)\n\n\n###############\n# Other Utils #\n###############\n\n\n# basics\n\n\n@view\n@external\ndef isRebasing() -> bool:\n    return self._isRebasing()\n\n\n@view\n@internal\ndef _isRebasing() -> bool:\n    return False\n\n\n# price per share\n\n\n@view\n@external\ndef getPricePerShare(_vaultToken: address, _decimals: uint256 = 0) -> uint256:\n    decimals: uint256 = _decimals\n    if decimals == 0:\n        decimals = yld.vaultToAsset[_vaultToken].decimals\n    if decimals == 0:\n        decimals = convert(staticcall IERC20Detailed(_vaultToken).decimals(), uint256)\n    return self._getPricePerShare(_vaultToken, decimals)\n\n\n@view\n@internal\ndef _getPricePerShare(_vaultToken: address, _decimals: uint256) -> uint256:\n    return staticcall IERC4626(_vaultToken).previewRedeem(10 ** _decimals)\n\n\n# vault token amount\n\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    return staticcall IERC4626(_vaultToken).convertToShares(_assetAmount)\n\n\n# total assets\n\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    return self._totalAssets(_vaultToken)\n\n\n@view\n@internal\ndef _totalAssets(_vaultToken: address) -> uint256:\n    return staticcall IERC4626(_vaultToken).totalAssets()\n\n\n# total borrows\n\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    return self._totalBorrows(_vaultToken)\n\n\n@view\n@internal\ndef _totalBorrows(_vaultToken: address) -> uint256:\n    # totalBorrows = totalAssets - available liquidity (underlying balance in vault)\n    totalAssets: uint256 = self._totalAssets(_vaultToken)\n    availLiquidity: uint256 = self._getAvailLiquidity(_vaultToken)\n    if totalAssets <= availLiquidity:\n        return 0\n    return totalAssets - availLiquidity\n\n\n# avail liquidity\n\n\n@view\n@external\ndef getAvailLiquidity(_vaultToken: address) -> uint256:\n    return self._getAvailLiquidity(_vaultToken)\n\n\n@view\n@internal\ndef _getAvailLiquidity(_vaultToken: address) -> uint256:\n    # available liquidity = underlying tokens actually held in the vault\n    asset: address = staticcall IERC4626(_vaultToken).asset()\n    return staticcall IERC20(asset).balanceOf(_vaultToken)\n\n\n# utilization\n\n\n@view\n@external\ndef getUtilizationRatio(_vaultToken: address) -> uint256:\n    totalAssets: uint256 = self._totalAssets(_vaultToken)\n    if totalAssets == 0:\n        return 0\n    totalBorrows: uint256 = self._totalBorrows(_vaultToken)\n    return totalBorrows * HUNDRED_PERCENT // totalAssets\n\n\n# extras\n\n\n@view\n@external\ndef isEligibleForYieldBonus(_asset: address) -> bool:\n    return False\n\n\n@view\n@external\ndef getWithdrawalFees(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    return 0\n\n\n################\n# Registration #\n################\n\n\n# can vault be registered\n\n\n@view\n@external\ndef canRegisterVaultToken(_asset: address, _vaultToken: address) -> bool:\n    return self._canRegisterVaultToken(_asset, _vaultToken)\n\n\n@view\n@internal\ndef _canRegisterVaultToken(_asset: address, _vaultToken: address) -> bool:\n    if empty(address) in [_asset, _vaultToken]:\n        return False\n    if staticcall IERC4626(_vaultToken).asset() != _asset:\n        return False\n    return staticcall WasabiRegistry(WASABI_LONG_POOL).getVault(_asset) == _vaultToken or staticcall WasabiRegistry(WASABI_SHORT_POOL).getVault(_asset) == _vaultToken\n\n\n# register vault token locally\n\n\n@external\ndef registerVaultTokenLocally(_asset: address, _vaultAddr: address) -> ls.VaultTokenInfo:\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert self._canRegisterVaultToken(_asset, _vaultAddr) # dev: cannot register vault token\n    assert not yld._isAssetOpportunity(_asset, _vaultAddr) # dev: already registered\n    vaultInfo: ls.VaultTokenInfo = self._registerVaultTokenLocally(_asset, _vaultAddr)\n    self._registerVaultTokenGlobally(_asset, _vaultAddr, vaultInfo.decimals, addys._getLedgerAddr(), addys._getLegoBookAddr())\n    return vaultInfo\n\n\n@internal\ndef _registerVaultTokenLocally(_asset: address, _vaultAddr: address) -> ls.VaultTokenInfo:\n    assert extcall IERC20(_asset).approve(_vaultAddr, max_value(uint256), default_return_value=True) # dev: max approval failed\n    vaultInfo: ls.VaultTokenInfo = yld._addAssetOpportunity(_asset, _vaultAddr)\n    assert vaultInfo.decimals != 0 # dev: invalid vault token\n    return vaultInfo\n\n\n# remove vault token locally\n\n\n@external\ndef deregisterVaultTokenLocally(_asset: address, _vaultAddr: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert yld._isAssetOpportunity(_asset, _vaultAddr) # dev: already registered\n    self._deregisterVaultTokenLocally(_asset, _vaultAddr)\n\n\n@internal\ndef _deregisterVaultTokenLocally(_asset: address, _vaultAddr: address):\n    assert extcall IERC20(_asset).approve(_vaultAddr, 0, default_return_value=True) # dev: max approval failed\n    yld._removeAssetOpportunity(_asset, _vaultAddr)\n\n\n# ledger registration\n\n\n@internal\ndef _registerVaultTokenGlobally(_underlyingAsset: address, _vaultToken: address, _decimals: uint256, _ledger: address, _legoBook: address):\n    if not staticcall Ledger(_ledger).isRegisteredVaultToken(_vaultToken):\n        legoId: uint256 = staticcall Registry(_legoBook).getRegId(self)\n        extcall Ledger(_ledger).setVaultToken(_vaultToken, legoId, _underlyingAsset, _decimals, self._isRebasing())\n\n\n#################\n# Yield Actions #\n#################\n\n\n# access control\n\n\n@view\n@internal\ndef _isAllowedToPerformAction(_caller: address) -> bool:\n    # NOTE: important to not trust `_miniAddys` here, that's why getting ledger and vault registry from addys\n    if staticcall VaultRegistry(addys._getVaultRegistryAddr()).isEarnVault(_caller):\n        return True\n    if staticcall Ledger(addys._getLedgerAddr()).isUserWallet(_caller):\n        return True\n    return staticcall Registry(RIPE_REGISTRY).isValidAddr(_caller) # Ripe Endaoment is allowed\n\n\n# add price snapshot\n\n\n@external\ndef addPriceSnapshot(_vaultToken: address) -> bool:\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    vaultInfo: ls.VaultTokenInfo = yld.vaultToAsset[_vaultToken]\n    assert vaultInfo.decimals != 0 # dev: not registered\n    pricePerShare: uint256 = self._getPricePerShare(_vaultToken, vaultInfo.decimals)\n    return yld._addPriceSnapshot(_vaultToken, pricePerShare, vaultInfo.decimals)\n\n\n# deposit\n\n\n@external\ndef depositForYield(\n    _asset: address,\n    _amount: uint256,\n    _vaultAddr: address,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, address, uint256, uint256):\n    assert self._isAllowedToPerformAction(msg.sender) # dev: no perms\n    assert not yld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = yld._getMiniAddys(_miniAddys)\n    vaultInfo: ls.VaultTokenInfo = self._getVaultInfoOnDeposit(_asset, _vaultAddr, miniAddys.ledger, miniAddys.legoBook)\n\n    # pre balances\n    preLegoBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n\n    # transfer deposit asset to this contract\n    depositAmount: uint256 = min(_amount, staticcall IERC20(_asset).balanceOf(msg.sender))\n    assert depositAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_asset).transferFrom(msg.sender, self, depositAmount, default_return_value=True) # dev: transfer failed\n\n    # deposit assets into lego partner\n    vaultTokenAmountReceived: uint256 = extcall IERC4626(_vaultAddr).deposit(depositAmount, _recipient)\n    assert vaultTokenAmountReceived != 0 # dev: no vault tokens received\n\n    # refund if full deposit didn't get through\n    currentLegoBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    refundAssetAmount: uint256 = 0\n    if currentLegoBalance > preLegoBalance:\n        refundAssetAmount = currentLegoBalance - preLegoBalance\n        assert extcall IERC20(_asset).transfer(msg.sender, refundAssetAmount, default_return_value=True) # dev: transfer failed\n        depositAmount -= refundAssetAmount\n\n    usdValue: uint256 = staticcall Appraiser(miniAddys.appraiser).getUnderlyingUsdValue(_asset, depositAmount)\n    log WasabiDeposit(\n        sender = msg.sender,\n        asset = _asset,\n        vaultToken = _vaultAddr,\n        assetAmountDeposited = depositAmount,\n        usdValue = usdValue,\n        vaultTokenAmountReceived = vaultTokenAmountReceived,\n        recipient = _recipient,\n    )\n\n    # add price snapshot\n    pricePerShare: uint256 = self._getPricePerShare(_vaultAddr, vaultInfo.decimals)\n    yld._addPriceSnapshot(_vaultAddr, pricePerShare, vaultInfo.decimals)\n\n    return depositAmount, _vaultAddr, vaultTokenAmountReceived, usdValue\n\n\n# vault info on deposit\n\n\n@internal\ndef _getVaultInfoOnDeposit(_asset: address, _vaultAddr: address, _ledger: address, _legoBook: address) -> ls.VaultTokenInfo:\n    vaultInfo: ls.VaultTokenInfo = yld.vaultToAsset[_vaultAddr]\n    if vaultInfo.decimals == 0:\n        assert self._canRegisterVaultToken(_asset, _vaultAddr) # dev: cannot register vault token\n        vaultInfo = self._registerVaultTokenLocally(_asset, _vaultAddr)\n        self._registerVaultTokenGlobally(_asset, _vaultAddr, vaultInfo.decimals, _ledger, _legoBook)\n    else:\n        assert vaultInfo.underlyingAsset == _asset # dev: asset mismatch\n    return vaultInfo\n\n\n# withdraw\n\n\n@external\ndef withdrawFromYield(\n    _vaultToken: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, address, uint256, uint256):\n    assert self._isAllowedToPerformAction(msg.sender) # dev: no perms\n    assert not yld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = yld._getMiniAddys(_miniAddys)\n    vaultInfo: ls.VaultTokenInfo = self._getVaultInfoOnWithdrawal(_vaultToken, miniAddys.ledger, miniAddys.legoBook)\n\n    # pre balances\n    preLegoVaultBalance: uint256 = staticcall IERC20(_vaultToken).balanceOf(self)\n\n    # transfer vaults tokens to this contract\n    vaultTokenAmount: uint256 = min(_amount, staticcall IERC20(_vaultToken).balanceOf(msg.sender))\n    assert vaultTokenAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_vaultToken).transferFrom(msg.sender, self, vaultTokenAmount, default_return_value=True) # dev: transfer failed\n\n    # withdraw assets from lego partner\n    assetAmountReceived: uint256 = extcall IERC4626(_vaultToken).redeem(vaultTokenAmount, _recipient, self)\n    assert assetAmountReceived != 0 # dev: no asset amount received\n\n    # refund if full withdrawal didn't happen\n    currentLegoVaultBalance: uint256 = staticcall IERC20(_vaultToken).balanceOf(self)\n    refundVaultTokenAmount: uint256 = 0\n    if currentLegoVaultBalance > preLegoVaultBalance:\n        refundVaultTokenAmount = currentLegoVaultBalance - preLegoVaultBalance\n        assert extcall IERC20(_vaultToken).transfer(msg.sender, refundVaultTokenAmount, default_return_value=True) # dev: transfer failed\n        vaultTokenAmount -= refundVaultTokenAmount\n\n    usdValue: uint256 = staticcall Appraiser(miniAddys.appraiser).getUnderlyingUsdValue(vaultInfo.underlyingAsset, assetAmountReceived)\n    log WasabiWithdrawal(\n        sender = msg.sender,\n        asset = vaultInfo.underlyingAsset,\n        vaultToken = _vaultToken,\n        assetAmountReceived = assetAmountReceived,\n        usdValue = usdValue,\n        vaultTokenAmountBurned = vaultTokenAmount,\n        recipient = _recipient,\n    )\n\n    # add price snapshot\n    pricePerShare: uint256 = self._getPricePerShare(_vaultToken, vaultInfo.decimals)\n    yld._addPriceSnapshot(_vaultToken, pricePerShare, vaultInfo.decimals)\n\n    return vaultTokenAmount, vaultInfo.underlyingAsset, assetAmountReceived, usdValue\n\n\n# vault info on withdrawal\n\n\n@internal\ndef _getVaultInfoOnWithdrawal(_vaultAddr: address, _ledger: address, _legoBook: address) -> ls.VaultTokenInfo:\n    vaultInfo: ls.VaultTokenInfo = yld.vaultToAsset[_vaultAddr]\n    if vaultInfo.decimals == 0:\n        asset: address = staticcall IERC4626(_vaultAddr).asset()\n        assert self._canRegisterVaultToken(asset, _vaultAddr) # dev: cannot register vault token\n        vaultInfo = self._registerVaultTokenLocally(asset, _vaultAddr)\n        self._registerVaultTokenGlobally(asset, _vaultAddr, vaultInfo.decimals, _ledger, _legoBook)\n    return vaultInfo\n\n\n#########\n# Other #\n#########\n\n\n@view\n@external\ndef getAccessForLego(_user: address, _action: ws.ActionType) -> (address, String[64], uint256):\n    return empty(address), empty(String[64]), 0\n\n\n@external\ndef claimRewards(\n    _user: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _extraData: bytes32,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    # backwards compatibility\n    return 0, 0\n\n\n@external\ndef claimIncentives(\n    _user: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _proofs: DynArray[bytes32, MAX_PROOFS],\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@view\n@external\ndef hasClaimableRewards(_user: address) -> bool:\n    return False\n\n\n@external\ndef swapTokens(\n    _amountIn: uint256,\n    _minAmountOut: uint256,\n    _tokenPath: DynArray[address, MAX_TOKEN_PATH],\n    _poolPath: DynArray[address, MAX_TOKEN_PATH - 1],\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256):\n    return 0, 0, 0\n\n\n@external\ndef mintOrRedeemAsset(\n    _tokenIn: address,\n    _tokenOut: address,\n    _tokenInAmount: uint256,\n    _minAmountOut: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, bool, uint256):\n    return 0, 0, False, 0\n\n\n@external\ndef confirmMintOrRedeemAsset(\n    _tokenIn: address,\n    _tokenOut: address,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef addCollateral(\n    _asset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef removeCollateral(\n    _asset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef borrow(\n    _borrowAsset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef repayDebt(\n    _paymentAsset: address,\n    _paymentAmount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef addLiquidity(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _amountA: uint256,\n    _amountB: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _minLpAmount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (address, uint256, uint256, uint256, uint256):\n    return empty(address), 0, 0, 0, 0\n\n\n@external\ndef removeLiquidity(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpToken: address,\n    _lpAmount: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, uint256):\n    return 0, 0, 0, 0\n\n\n@external\ndef addLiquidityConcentrated(\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _tickLower: int24,\n    _tickUpper: int24,\n    _amountA: uint256,\n    _amountB: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, uint256, uint256):\n    return 0, 0, 0, 0, 0\n\n\n@external\ndef removeLiquidityConcentrated(\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _liqToRemove: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, bool, uint256):\n    return 0, 0, 0, False, 0",
            "sha256sum": "50ea15d923e735abda301c956db5bce2ab804159f400dd625ee38c83be60838c"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/legos/yield/Wasabi.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.3+commit.bff19ea2",
        "integrity": "21707be2127c237dc2f9937da39c3abcba991b768d537effcce694bd10520c81"
      },
      "args": "00000000000000000000000044cf3c4f000dfd76a35d03298049d37be688d6f9000000000000000000000000bdae5df498a45c5f058e3a09afe9ba4da7b248aa000000000000000000000000a456c77d358c9c89f4dfb294fa2a47470b7da37c0000000000000000000000006162df1b329e157479f8f1407e888260e0ec3d2b",
      "file": "contracts/legos/yield/Wasabi.vy"
    },
    "Avantis": {
      "address": "0x94D287b679c9eB26067b1Aa59D230B2D559e66bb",
      "abi": [
        {
          "name": "AvantisDeposit",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountDeposited",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultTokenAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AvantisWithdrawal",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultTokenAmountBurned",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LegoPauseModified",
          "inputs": [
            {
              "name": "isPaused",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LegoFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "balance",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "SnapShotPriceConfigSet",
          "inputs": [
            {
              "name": "minSnapshotDelay",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "maxNumSnapshots",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "maxUpsideDeviation",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "staleTime",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetOpportunityAdded",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultAddr",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetOpportunityRemoved",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultAddr",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PricePerShareSnapShotAdded",
          "inputs": [
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "totalSupply",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "pricePerShare",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "lastAveragePricePerShare",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddys",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "undyToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "hatchery",
                  "type": "address"
                },
                {
                  "name": "lootDistributor",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                },
                {
                  "name": "walletBackpack",
                  "type": "address"
                },
                {
                  "name": "billing",
                  "type": "address"
                },
                {
                  "name": "vaultRegistry",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUndyHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isLegoAsset",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssetOpportunities",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isAssetOpportunity",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getNumLegoAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pause",
          "inputs": [
            {
              "name": "_shouldPause",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFundsMany",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_assets",
              "type": "address[]"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getWeightedPricePerShare",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLatestSnapshot",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_pricePerShare",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "totalSupply",
                  "type": "uint256"
                },
                {
                  "name": "pricePerShare",
                  "type": "uint256"
                },
                {
                  "name": "lastUpdate",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setSnapShotPriceConfig",
          "inputs": [
            {
              "name": "_config",
              "type": "tuple",
              "components": [
                {
                  "name": "minSnapshotDelay",
                  "type": "uint256"
                },
                {
                  "name": "maxNumSnapshots",
                  "type": "uint256"
                },
                {
                  "name": "maxUpsideDeviation",
                  "type": "uint256"
                },
                {
                  "name": "staleTime",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidPriceConfig",
          "inputs": [
            {
              "name": "_config",
              "type": "tuple",
              "components": [
                {
                  "name": "minSnapshotDelay",
                  "type": "uint256"
                },
                {
                  "name": "maxNumSnapshots",
                  "type": "uint256"
                },
                {
                  "name": "maxUpsideDeviation",
                  "type": "uint256"
                },
                {
                  "name": "staleTime",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "vaultToAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "underlyingAsset",
                  "type": "address"
                },
                {
                  "name": "decimals",
                  "type": "uint256"
                },
                {
                  "name": "lastAveragePricePerShare",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assetOpportunities",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAssetOpportunity",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssetOpportunities",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assets",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "snapShotData",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "lastSnapShot",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "totalSupply",
                      "type": "uint256"
                    },
                    {
                      "name": "pricePerShare",
                      "type": "uint256"
                    },
                    {
                      "name": "lastUpdate",
                      "type": "uint256"
                    }
                  ]
                },
                {
                  "name": "nextIndex",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "snapShots",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "totalSupply",
                  "type": "uint256"
                },
                {
                  "name": "pricePerShare",
                  "type": "uint256"
                },
                {
                  "name": "lastUpdate",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "snapShotPriceConfig",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "minSnapshotDelay",
                  "type": "uint256"
                },
                {
                  "name": "maxNumSnapshots",
                  "type": "uint256"
                },
                {
                  "name": "maxUpsideDeviation",
                  "type": "uint256"
                },
                {
                  "name": "staleTime",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isPaused",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasCapability",
          "inputs": [
            {
              "name": "_action",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRegistries",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isYieldLego",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isDexLego",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAsset",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingBalances",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenBalance",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAmount",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAmountSafe",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenBalance",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingData",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingData",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            },
            {
              "name": "_appraiser",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValueOfVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValueOfVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            },
            {
              "name": "_appraiser",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isRebasing",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPricePerShare",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPricePerShare",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_decimals",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getVaultTokenAmount",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_assetAmount",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalAssets",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalBorrows",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAvailLiquidity",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUtilizationRatio",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isEligibleForYieldBonus",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getWithdrawalFees",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canRegisterVaultToken",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "registerVaultTokenLocally",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "underlyingAsset",
                  "type": "address"
                },
                {
                  "name": "decimals",
                  "type": "uint256"
                },
                {
                  "name": "lastAveragePricePerShare",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "deregisterVaultTokenLocally",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addPriceSnapshot",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositForYield",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositForYield",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawFromYield",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawFromYield",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAccessForLego",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_action",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "string"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimIncentives",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_proofs",
              "type": "bytes32[]"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimIncentives",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_proofs",
              "type": "bytes32[]"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasClaimableRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_tokenPath",
              "type": "address[]"
            },
            {
              "name": "_poolPath",
              "type": "address[]"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_tokenPath",
              "type": "address[]"
            },
            {
              "name": "_poolPath",
              "type": "address[]"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_tokenInAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_tokenInAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmMintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmMintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_borrowAsset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_borrowAsset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_paymentAsset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_paymentAsset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "AVANTIS_USDC_VAULT",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "RIPE_REGISTRY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_undyHq",
              "type": "address"
            },
            {
              "name": "_avantisUsdcVault",
              "type": "address"
            },
            {
              "name": "_ripeRegistry",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "interfaces/WalletStructs.vyi": {
            "content": "# @version 0.4.3\n\nflag ActionType:\n    TRANSFER\n    EARN_DEPOSIT\n    EARN_WITHDRAW\n    EARN_REBALANCE\n    SWAP\n    MINT_REDEEM\n    CONFIRM_MINT_REDEEM\n    ADD_COLLATERAL\n    REMOVE_COLLATERAL\n    BORROW\n    REPAY_DEBT\n    REWARDS\n    ETH_TO_WETH\n    WETH_TO_ETH\n    ADD_LIQ\n    REMOVE_LIQ\n    ADD_LIQ_CONC\n    REMOVE_LIQ_CONC\n    PAY_CHEQUE\n\nstruct WalletAssetData:\n    assetBalance: uint256\n    usdValue: uint256\n    isYieldAsset: bool\n    lastPricePerShare: uint256\n\nstruct ActionData:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    billing: address\n    vaultRegistry: address\n    wallet: address\n    walletConfig: address\n    walletOwner: address\n    inEjectMode: bool\n    isFrozen: bool\n    lastTotalUsdValue: uint256\n    signer: address\n    isManager: bool\n    legoId: uint256\n    legoAddr: address\n    eth: address\n    weth: address\n\nstruct MiniAddys:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    appraiser: address",
            "sha256sum": "466493c129135c95470aaf70eeddc936632f7b0f813396e5a7ddc03bea9da518"
          },
          "interfaces/LegoPartner.vyi": {
            "content": "# @version 0.4.3\n\nfrom interfaces import WalletStructs as ws\n\nMAX_TOKEN_PATH: constant(uint256) = 5\nMAX_RECOVER_ASSETS: constant(uint256) = 20\nMAX_PROOFS: constant(uint256) = 25\n\n@external\ndef addLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _tickLower: int24, _tickUpper: int24, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef addLiquidity(_pool: address, _tokenA: address, _tokenB: address, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _minLpAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (address, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef removeLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _liqToRemove: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef removeLiquidity(_pool: address, _tokenA: address, _tokenB: address, _lpToken: address, _lpAmount: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef mintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _tokenInAmount: uint256, _minAmountOut: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef swapTokens(_amountIn: uint256, _minAmountOut: uint256, _tokenPath: DynArray[address, MAX_TOKEN_PATH], _poolPath: DynArray[address, MAX_TOKEN_PATH - 1], _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256):\n    ...\n\n@external\ndef depositForYield(_asset: address, _amount: uint256, _vaultAddr: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef withdrawFromYield(_vaultToken: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef confirmMintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef borrow(_borrowAsset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef repayDebt(_paymentAsset: address, _paymentAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef claimIncentives(_user: address, _rewardToken: address, _rewardAmount: uint256, _proofs: DynArray[bytes32, MAX_PROOFS], _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef removeCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef addCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@view\n@external\ndef getAccessForLego(_user: address, _action: ws.ActionType) -> (address, String[64], uint256):\n    ...\n\n@view\n@external\ndef hasCapability(_action: ws.ActionType) -> bool:\n    ...\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    ...\n\n@view\n@external\ndef isYieldLego() -> bool:\n    ...\n\n@view\n@external\ndef isDexLego() -> bool:\n    ...\n\n\n# common\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "f2afb7bd72d4301aea77bbe4177b7ae954ba6f6b76af363965993eb92ad0b715"
          },
          "interfaces/LegoStructs.vyi": {
            "content": "# @version 0.4.3\n\nstruct VaultTokenInfo:\n    underlyingAsset: address\n    decimals: uint256\n    lastAveragePricePerShare: uint256\n\nstruct SnapShotPriceConfig:\n    minSnapshotDelay: uint256\n    maxNumSnapshots: uint256\n    maxUpsideDeviation: uint256\n    staleTime: uint256\n\nstruct SingleSnapShot:\n    totalSupply: uint256\n    pricePerShare: uint256\n    lastUpdate: uint256\n\nstruct SnapShotData:\n    lastSnapShot: SingleSnapShot\n    nextIndex: uint256\n",
            "sha256sum": "8ae48be17d812d57fbd671bbf0593e8abf175ad0924e47c5997823cac19ec806"
          },
          "interfaces/YieldLego.vyi": {
            "content": "# @version 0.4.3\n\nfrom interfaces import LegoStructs as ls\n\n\n###################\n# Underlying Data #\n###################\n\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    ...\n\n\n@view\n@external\ndef getUnderlyingBalances(_vaultToken: address, _vaultTokenBalance: uint256) -> (uint256, uint256):\n    ...\n\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    ...\n\n\n@view\n@external\ndef getUnderlyingAmountSafe(_vaultToken: address, _vaultTokenBalance: uint256) -> uint256:\n    ...\n\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> (address, uint256, uint256):\n    ...\n\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> uint256:\n    ...\n\n\n###############\n# Other Utils #\n###############\n\n\n@view\n@external\ndef isRebasing() -> bool:\n    ...\n\n\n@view\n@external\ndef getPricePerShare(_vaultToken: address, _decimals: uint256 = 0) -> uint256:\n    ...\n\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef canRegisterVaultToken(_asset: address, _vaultToken: address) -> bool:\n    ...\n\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef getUtilizationRatio(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef getAvailLiquidity(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef isEligibleForYieldBonus(_asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef getWithdrawalFees(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    ...\n\n\n###################\n# Yield Lego Data #\n###################\n\n\n@view\n@external\ndef isLegoAsset(_asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, 40]:\n    ...\n\n\n@view\n@external\ndef getAssets() -> DynArray[address, 20]:\n    ...\n\n\n@view\n@external\ndef isAssetOpportunity(_asset: address, _vaultAddr: address) -> bool:\n    ...\n\n\n@view\n@external\ndef getNumLegoAssets() -> uint256:\n    ...\n\n\n@view\n@external\ndef assets(_index: uint256) -> address:\n    ...\n\n\n@view\n@external\ndef indexOfAsset(_asset: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef numAssets() -> uint256:\n    ...\n\n\n@view\n@external\ndef assetOpportunities(_asset: address, _index: uint256) -> address:\n    ...\n\n\n@view\n@external\ndef indexOfAssetOpportunity(_asset: address, _vaultAddr: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef numAssetOpportunities(_asset: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef vaultToAsset(_vaultAddr: address) -> ls.VaultTokenInfo:\n    ...\n\n\n# price snapshots\n\n\n@external\ndef addPriceSnapshot(_vaultToken: address) -> bool:\n    ...\n\n\n@view\n@external\ndef snapShotPriceConfig() -> ls.SnapShotPriceConfig:\n    ...\n\n\n@view\n@external\ndef snapShotData(_vaultToken: address) -> ls.SnapShotData:\n    ...\n\n\n@view\n@external\ndef snapShots(_vaultToken: address, _index: uint256) -> ls.SingleSnapShot:\n    ...\n\n\n@view\n@external\ndef getWeightedPricePerShare(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef getLatestSnapshot(_vaultToken: address, _pricePerShare: uint256) -> ls.SingleSnapShot:\n    ...\n\n\n@external\ndef setSnapShotPriceConfig(_config: ls.SnapShotPriceConfig):\n    ...\n",
            "sha256sum": "db91c139f6018f5218b389d08c8703bc16fb994aa948805dbfea27e072f382ec"
          },
          "contracts/modules/Addys.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\ninterface UndyHq:\n    def isValidAddr(_addr: address) -> bool: view\n    def getAddr(_regId: uint256) -> address: view\n    def undyToken() -> address: view\n\ninterface Switchboard:\n    def isSwitchboardAddr(_addr: address) -> bool: view\n\ninterface LegoBook:\n    def isLegoAddr(_addr: address) -> bool: view\n\nstruct Addys:\n    hq: address\n    undyToken: address\n    ledger: address\n    missionControl: address\n    legoBook: address\n    switchboard: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    walletBackpack: address\n    billing: address\n    vaultRegistry: address\n\n# hq\nUNDY_HQ_FOR_ADDYS: immutable(address)\n\n# core addys\nLEDGER_ID: constant(uint256) = 1\nMISSION_CONTROL_ID: constant(uint256) = 2\nLEGO_BOOK_ID: constant(uint256) = 3\nSWITCHBOARD_ID: constant(uint256) = 4\nHATCHERY_ID: constant(uint256) = 5\nLOOT_DISTRIBUTOR_ID: constant(uint256) = 6\nAPPRAISER_ID: constant(uint256) = 7\nWALLET_BACKPACK_ID: constant(uint256) = 8\nBILLING_ID: constant(uint256) = 9\nVAULT_REGISTRY_ID: constant(uint256) = 10\n\n\n@deploy\ndef __init__(_undyHq: address):\n    assert _undyHq != empty(address) # dev: invalid undy hq\n    UNDY_HQ_FOR_ADDYS = _undyHq\n\n\n########\n# Core #\n########\n\n\n@view\n@external\ndef getAddys() -> Addys:\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _getAddys(_addys: Addys = empty(Addys)) -> Addys:\n    if _addys.hq != empty(address):\n        return _addys\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _generateAddys() -> Addys:\n    hq: address = UNDY_HQ_FOR_ADDYS\n    return Addys(\n        hq = hq,\n        undyToken = staticcall UndyHq(hq).undyToken(),\n        ledger = staticcall UndyHq(hq).getAddr(LEDGER_ID),\n        missionControl = staticcall UndyHq(hq).getAddr(MISSION_CONTROL_ID),\n        legoBook = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID),\n        switchboard = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID),\n        hatchery = staticcall UndyHq(hq).getAddr(HATCHERY_ID),\n        lootDistributor = staticcall UndyHq(hq).getAddr(LOOT_DISTRIBUTOR_ID),\n        appraiser = staticcall UndyHq(hq).getAddr(APPRAISER_ID),\n        walletBackpack = staticcall UndyHq(hq).getAddr(WALLET_BACKPACK_ID),\n        billing = staticcall UndyHq(hq).getAddr(BILLING_ID),\n        vaultRegistry = staticcall UndyHq(hq).getAddr(VAULT_REGISTRY_ID),\n    )\n\n\n##########\n# Tokens #\n##########\n\n\n@view\n@internal\ndef _getUndyToken() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).undyToken()\n\n\n###########\n# Helpers #\n###########\n\n\n# undy hq\n\n\n@view\n@external\ndef getUndyHq() -> address:\n    return self._getUndyHq()\n\n\n@view\n@internal\ndef _getUndyHq() -> address:\n    return UNDY_HQ_FOR_ADDYS\n\n\n# utils\n\n\n@view\n@internal\ndef _isValidUndyAddr(_addr: address, _hq: address = empty(address)) -> bool:\n    hq: address = _hq\n    if _hq == empty(address):\n        hq = UNDY_HQ_FOR_ADDYS\n    \n    # core departments\n    if staticcall UndyHq(hq).isValidAddr(_addr):\n        return True\n\n    # lego book\n    legoBook: address = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID)\n    if legoBook != empty(address) and staticcall LegoBook(legoBook).isLegoAddr(_addr):\n        return True\n\n    # switchboard config\n    switchboard: address = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID)\n    if switchboard != empty(address) and staticcall Switchboard(switchboard).isSwitchboardAddr(_addr):\n        return True\n\n    return False\n\n\n@view\n@internal\ndef _isSwitchboardAddr(_addr: address) -> bool:\n    switchboard: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n    if switchboard == empty(address):\n        return False\n    return staticcall Switchboard(switchboard).isSwitchboardAddr(_addr)\n\n\n@view\n@internal\ndef _isLegoBookAddr(_addr: address) -> bool:\n    legoBook: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n    if legoBook == empty(address):\n        return False\n    return staticcall LegoBook(legoBook).isLegoAddr(_addr)\n\n\n###############\n# Departments #\n###############\n\n\n# ledger\n\n\n@view\n@internal\ndef _getLedgerId() -> uint256:\n    return LEDGER_ID\n\n\n@view\n@internal\ndef _getLedgerAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEDGER_ID)\n\n\n# mission control\n\n\n@view\n@internal\ndef _getMissionControlId() -> uint256:\n    return MISSION_CONTROL_ID\n\n\n@view\n@internal\ndef _getMissionControlAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(MISSION_CONTROL_ID)\n\n\n# lego book\n\n\n@view\n@internal\ndef _getLegoBookId() -> uint256:\n    return LEGO_BOOK_ID\n\n\n@view\n@internal\ndef _getLegoBookAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n\n\n# switchboard\n\n\n@view\n@internal\ndef _getSwitchboardId() -> uint256:\n    return SWITCHBOARD_ID\n\n\n@view\n@internal\ndef _getSwitchboardAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n\n\n# hatchery\n\n\n@view\n@internal\ndef _getHatcheryId() -> uint256:\n    return HATCHERY_ID\n\n\n@view\n@internal\ndef _getHatcheryAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(HATCHERY_ID)\n\n\n# loot distributor\n\n\n@view\n@internal\ndef _getLootDistributorId() -> uint256:\n    return LOOT_DISTRIBUTOR_ID\n\n\n@view\n@internal\ndef _getLootDistributorAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LOOT_DISTRIBUTOR_ID)\n\n\n# appraiser\n\n\n@view\n@internal\ndef _getAppraiserId() -> uint256:\n    return APPRAISER_ID\n\n\n@view\n@internal\ndef _getAppraiserAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(APPRAISER_ID)\n\n\n# wallet backpack\n\n\n@view\n@internal\ndef _getWalletBackpackId() -> uint256:\n    return WALLET_BACKPACK_ID\n\n\n@view\n@internal\ndef _getWalletBackpackAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(WALLET_BACKPACK_ID)\n\n\n# billing\n\n\n@view\n@internal\ndef _getBillingId() -> uint256:\n    return BILLING_ID\n\n\n@view\n@internal\ndef _getBillingAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(BILLING_ID)\n\n\n# vault registry\n\n\n@view\n@internal\ndef _getVaultRegistryId() -> uint256:\n    return VAULT_REGISTRY_ID\n\n\n@view\n@internal\ndef _getVaultRegistryAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(VAULT_REGISTRY_ID)",
            "sha256sum": "4df6b72db9bb417d1af81660175be1450cfb7b3575f3d17a5b8a130bff87b781"
          },
          "contracts/modules/YieldLegoData.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nuses: addys\n\nimport contracts.modules.Addys as addys\n\nfrom interfaces import WalletStructs as ws\nfrom interfaces import LegoStructs as ls\nfrom ethereum.ercs import IERC20\nfrom ethereum.ercs import IERC20Detailed\n\nevent AssetOpportunityAdded:\n    asset: indexed(address)\n    vaultAddr: indexed(address)\n\nevent AssetOpportunityRemoved:\n    asset: indexed(address)\n    vaultAddr: indexed(address)\n\nevent LegoPauseModified:\n    isPaused: bool\n\nevent LegoFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    balance: uint256\n\nevent PricePerShareSnapShotAdded:\n    vaultToken: indexed(address)\n    totalSupply: uint256\n    pricePerShare: uint256\n    lastAveragePricePerShare: uint256\n\nevent SnapShotPriceConfigSet:\n    minSnapshotDelay: uint256\n    maxNumSnapshots: uint256\n    maxUpsideDeviation: uint256\n    staleTime: uint256\n\n# core\nvaultToAsset: public(HashMap[address, ls.VaultTokenInfo]) # vault addr -> data\n\n# asset opportunities\nassetOpportunities: public(HashMap[address, HashMap[uint256, address]]) # asset -> index -> vault addr\nindexOfAssetOpportunity: public(HashMap[address, HashMap[address, uint256]]) # asset -> vault addr -> index\nnumAssetOpportunities: public(HashMap[address, uint256]) # asset -> number of opportunities\n\n# lego assets (iterable)\nassets: public(HashMap[uint256, address]) # index -> asset\nindexOfAsset: public(HashMap[address, uint256]) # asset -> index\nnumAssets: public(uint256) # num assets\n\n# price snapshots\nsnapShotData: public(HashMap[address, ls.SnapShotData]) # vault token -> data\nsnapShots: public(HashMap[address, HashMap[uint256, ls.SingleSnapShot]]) # vault token -> index -> snapshot\nsnapShotPriceConfig: public(ls.SnapShotPriceConfig) # config\n\nisPaused: public(bool)\n\nMAX_VAULTS: constant(uint256) = 40\nMAX_ASSETS: constant(uint256) = 20\nMAX_RECOVER_ASSETS: constant(uint256) = 20\nONE_DAY_SECONDS: constant(uint256) = 60 * 60 * 24\nONE_WEEK_SECONDS: constant(uint256) = ONE_DAY_SECONDS * 7\nHUNDRED_PERCENT: constant(uint256) = 100_00\n\n\n@deploy\ndef __init__(_shouldPause: bool):\n    self.isPaused = _shouldPause\n    self.numAssets = 1 # not using 0 index\n\n    # default snapshot price config\n    self.snapShotPriceConfig = ls.SnapShotPriceConfig(\n        minSnapshotDelay = 60 * 10, # 10 minutes\n        maxNumSnapshots = 20,\n        maxUpsideDeviation = 10_00, # 10%\n        staleTime = ONE_DAY_SECONDS, # 1 day\n    )\n\n\n#########\n# Views #\n#########\n\n\n# is lego asset\n\n\n@view\n@external\ndef isLegoAsset(_asset: address) -> bool:\n    return self._isLegoAsset(_asset)\n\n\n@view\n@internal\ndef _isLegoAsset(_asset: address) -> bool:\n    return self.indexOfAsset[_asset] != 0\n\n\n# vault opportunities\n\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, MAX_VAULTS]:\n    numOpportunities: uint256 = self.numAssetOpportunities[_asset]\n    if numOpportunities == 0:\n        return []\n    opportunities: DynArray[address, MAX_VAULTS] = []\n    for i: uint256 in range(1, numOpportunities, bound=MAX_VAULTS):\n        opportunities.append(self.assetOpportunities[_asset][i])\n    return opportunities\n\n\n# all assets registered\n\n\n@view\n@external\ndef getAssets() -> DynArray[address, MAX_ASSETS]:\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return []\n    assets: DynArray[address, MAX_ASSETS] = []\n    for i: uint256 in range(1, numAssets, bound=MAX_ASSETS):\n        assets.append(self.assets[i])\n    return assets\n\n\n################\n# Registration #\n################\n\n\n@view\n@external\ndef isAssetOpportunity(_asset: address, _vaultAddr: address) -> bool:\n    return self._isAssetOpportunity(_asset, _vaultAddr)\n\n\n@view\n@internal\ndef _isAssetOpportunity(_asset: address, _vaultAddr: address) -> bool:\n    return self.indexOfAssetOpportunity[_asset][_vaultAddr] != 0\n\n\n# add asset opportunity\n\n\n@internal\ndef _addAssetOpportunity(_asset: address, _vaultAddr: address) -> ls.VaultTokenInfo:\n    if self.indexOfAssetOpportunity[_asset][_vaultAddr] != 0:\n        return self.vaultToAsset[_vaultAddr]\n\n    if empty(address) in [_asset, _vaultAddr]:\n        return empty(ls.VaultTokenInfo)\n\n    # add asset opportunity\n    aid: uint256 = self.numAssetOpportunities[_asset]\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.assetOpportunities[_asset][aid] = _vaultAddr\n    self.indexOfAssetOpportunity[_asset][_vaultAddr] = aid\n    self.numAssetOpportunities[_asset] = aid + 1\n\n    # add mapping\n    vaultInfo: ls.VaultTokenInfo = ls.VaultTokenInfo(\n        underlyingAsset = _asset,\n        decimals = convert(staticcall IERC20Detailed(_vaultAddr).decimals(), uint256),\n        lastAveragePricePerShare = 0,\n    )\n    self.vaultToAsset[_vaultAddr] = vaultInfo\n\n    # add asset\n    self._addAsset(_asset)\n\n    log AssetOpportunityAdded(asset=_asset, vaultAddr=_vaultAddr)\n    return vaultInfo\n\n\n# remove asset opportunity\n\n\n@internal\ndef _removeAssetOpportunity(_asset: address, _vaultAddr: address):\n    numOpportunities: uint256 = self.numAssetOpportunities[_asset]\n    if numOpportunities == 0:\n        return\n\n    targetIndex: uint256 = self.indexOfAssetOpportunity[_asset][_vaultAddr]\n    if targetIndex == 0:\n        return\n\n    # update data\n    lastIndex: uint256 = numOpportunities - 1\n    self.numAssetOpportunities[_asset] = lastIndex\n    self.indexOfAssetOpportunity[_asset][_vaultAddr] = 0\n\n    self.vaultToAsset[_vaultAddr] = empty(ls.VaultTokenInfo)\n\n    # clear all snapshot data for the vault token to prevent contamination on re-add\n    self.snapShotData[_vaultAddr] = empty(ls.SnapShotData)\n\n    # clear all historical snapshots\n    config: ls.SnapShotPriceConfig = self.snapShotPriceConfig\n    for i: uint256 in range(config.maxNumSnapshots, bound=max_value(uint256)):\n        if i >= config.maxNumSnapshots:\n            break\n        self.snapShots[_vaultAddr][i] = empty(ls.SingleSnapShot)\n\n    # shift to replace the removed one\n    if targetIndex != lastIndex:\n        lastVaultAddr: address = self.assetOpportunities[_asset][lastIndex]\n        self.assetOpportunities[_asset][targetIndex] = lastVaultAddr\n        self.indexOfAssetOpportunity[_asset][lastVaultAddr] = targetIndex\n\n    # remove asset\n    if lastIndex <= 1:\n        self._removeAsset(_asset)\n\n    log AssetOpportunityRemoved(asset=_asset, vaultAddr=_vaultAddr)\n\n\n# add asset\n\n\n@internal\ndef _addAsset(_asset: address):\n    if self.indexOfAsset[_asset] != 0:\n        return\n\n    aid: uint256 = self.numAssets\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.assets[aid] = _asset\n    self.indexOfAsset[_asset] = aid\n    self.numAssets = aid + 1\n\n\n# remove asset\n\n\n@internal\ndef _removeAsset(_asset: address):\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return\n\n    targetIndex: uint256 = self.indexOfAsset[_asset]\n    if targetIndex == 0:\n        return\n\n    # update data\n    lastIndex: uint256 = numAssets - 1\n    self.numAssets = lastIndex\n    self.indexOfAsset[_asset] = 0\n\n    # shift to replace the removed one\n    if targetIndex != lastIndex:\n        lastAsset: address = self.assets[lastIndex]\n        self.assets[targetIndex] = lastAsset\n        self.indexOfAsset[lastAsset] = targetIndex\n\n\n# num lego assets (true number, use `numAssets` for iteration)\n\n\n@view\n@external\ndef getNumLegoAssets() -> uint256:\n    return self._getNumLegoAssets()\n\n\n@view\n@internal\ndef _getNumLegoAssets() -> uint256:\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return 0\n    return numAssets - 1\n\n\n###########\n# General #\n###########\n\n\n# fill mini addys\n\n\n@view\n@internal\ndef _getMiniAddys(_miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> ws.MiniAddys:\n    if _miniAddys.ledger != empty(address):\n        return _miniAddys\n    return ws.MiniAddys(\n        ledger = addys._getLedgerAddr(),\n        missionControl = addys._getMissionControlAddr(),\n        legoBook = addys._getLegoBookAddr(),\n        appraiser = addys._getAppraiserAddr(),\n    )\n\n\n# activate\n\n\n@external\ndef pause(_shouldPause: bool):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert _shouldPause != self.isPaused # dev: no change\n    self.isPaused = _shouldPause\n    log LegoPauseModified(isPaused=_shouldPause)\n\n\n# recover funds\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    self._recoverFunds(_recipient, _asset)\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, MAX_RECOVER_ASSETS]):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    for a: address in _assets:\n        self._recoverFunds(_recipient, a)\n\n\n@internal\ndef _recoverFunds(_recipient: address, _asset: address):\n    assert empty(address) not in [_recipient, _asset] # dev: invalid recipient or asset\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    assert balance != 0 # dev: nothing to recover\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log LegoFundsRecovered(asset=_asset, recipient=_recipient, balance=balance)\n\n\n###################\n# Price Snapshots #\n###################\n\n\n# add price snapshot\n\n\n@internal\ndef _addPriceSnapshot(_vaultToken: address, _pricePerShare: uint256, _vaultTokenDecimals: uint256) -> bool:\n    config: ls.SnapShotPriceConfig = self.snapShotPriceConfig\n    if config.maxNumSnapshots == 0:\n        return False\n\n    data: ls.SnapShotData = self.snapShotData[_vaultToken]\n\n    # already have snapshot for this time\n    if data.lastSnapShot.lastUpdate == block.timestamp:\n        return False\n\n    # check if snapshot is too recent\n    if data.lastSnapShot.lastUpdate + config.minSnapshotDelay > block.timestamp:\n        return False\n\n    # create and store new snapshot\n    newSnapshot: ls.SingleSnapShot = self._getLatestSnapshot(_vaultToken, _pricePerShare, _vaultTokenDecimals, data.lastSnapShot, config)\n    data.lastSnapShot = newSnapshot\n    self.snapShots[_vaultToken][data.nextIndex] = newSnapshot\n\n    # update index\n    data.nextIndex += 1\n    if data.nextIndex >= config.maxNumSnapshots:\n        data.nextIndex = 0\n\n    # save snap shot data\n    self.snapShotData[_vaultToken] = data\n\n    # update cached weighted average price per share\n    lastAveragePricePerShare: uint256 = self._getWeightedPricePerShare(_vaultToken, _pricePerShare)\n    self.vaultToAsset[_vaultToken].lastAveragePricePerShare = lastAveragePricePerShare\n\n    log PricePerShareSnapShotAdded(\n        vaultToken = _vaultToken,\n        totalSupply = newSnapshot.totalSupply,\n        pricePerShare = newSnapshot.pricePerShare,\n        lastAveragePricePerShare = lastAveragePricePerShare,\n    )\n    return True\n\n\n# weighted price per share\n\n\n@view\n@external\ndef getWeightedPricePerShare(_vaultToken: address) -> uint256:\n    data: ls.SnapShotData = self.snapShotData[_vaultToken]\n    return self._getWeightedPricePerShare(_vaultToken, data.lastSnapShot.pricePerShare)\n\n\n@view\n@internal\ndef _getWeightedPricePerShare(_vaultToken: address, _lastPricePerShare: uint256) -> uint256:\n    config: ls.SnapShotPriceConfig = self.snapShotPriceConfig\n    if config.maxNumSnapshots == 0:\n        return 0\n\n    # calculate weighted average price using all valid snapshots\n    numerator: uint256 = 0\n    denominator: uint256 = 0\n    for i: uint256 in range(config.maxNumSnapshots, bound=max_value(uint256)):\n\n        snapShot: ls.SingleSnapShot = self.snapShots[_vaultToken][i]\n        if snapShot.pricePerShare == 0 or snapShot.totalSupply == 0 or snapShot.lastUpdate == 0:\n            continue\n\n        # too stale, skip\n        if config.staleTime != 0 and block.timestamp > snapShot.lastUpdate + config.staleTime:\n            continue\n\n        numerator += (snapShot.totalSupply * snapShot.pricePerShare)\n        denominator += snapShot.totalSupply\n\n    # weighted price per share\n    weightedPricePerShare: uint256 = 0\n    if numerator != 0:\n        weightedPricePerShare = numerator // denominator\n    else:\n        weightedPricePerShare = _lastPricePerShare\n\n    return weightedPricePerShare\n\n\n# latest snapshot\n\n\n@view\n@external\ndef getLatestSnapshot(_vaultToken: address, _pricePerShare: uint256) -> ls.SingleSnapShot:\n    data: ls.SnapShotData = self.snapShotData[_vaultToken]\n    config: ls.SnapShotPriceConfig = self.snapShotPriceConfig\n    vaultTokenDecimals: uint256 = self.vaultToAsset[_vaultToken].decimals\n    return self._getLatestSnapshot(_vaultToken, _pricePerShare, vaultTokenDecimals, data.lastSnapShot, config)\n\n\n@view\n@internal\ndef _getLatestSnapshot(\n    _vaultToken: address,\n    _pricePerShare: uint256,\n    _vaultTokenDecimals: uint256,\n    _lastSnapShot: ls.SingleSnapShot,\n    _config: ls.SnapShotPriceConfig,\n) -> ls.SingleSnapShot:\n\n    # total supply (adjusted)\n    totalSupply: uint256 = staticcall IERC20(_vaultToken).totalSupply() // (10 ** _vaultTokenDecimals)\n    if totalSupply == 0:\n        totalSupply = 1\n\n    # throttle upside (extra safety check)\n    pricePerShare: uint256 = self._throttleUpside(_pricePerShare, _lastSnapShot.pricePerShare, _config.maxUpsideDeviation)\n\n    return ls.SingleSnapShot(\n        totalSupply = totalSupply,\n        pricePerShare = pricePerShare,\n        lastUpdate = block.timestamp,\n    )\n\n\n@view\n@internal\ndef _throttleUpside(_newValue: uint256, _prevValue: uint256, _maxUpside: uint256) -> uint256:\n    if _maxUpside == 0 or _prevValue == 0 or _newValue == 0:\n        return _newValue\n    maxPricePerShare: uint256 = _prevValue + (_prevValue * _maxUpside // HUNDRED_PERCENT)\n    return min(_newValue, maxPricePerShare)\n\n\n# snapshot price config\n\n\n@external\ndef setSnapShotPriceConfig(_config: ls.SnapShotPriceConfig):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert self._isValidPriceConfig(_config) # dev: invalid config\n    self.snapShotPriceConfig = _config\n    log SnapShotPriceConfigSet(\n        minSnapshotDelay=_config.minSnapshotDelay,\n        maxNumSnapshots=_config.maxNumSnapshots,\n        maxUpsideDeviation=_config.maxUpsideDeviation,\n        staleTime=_config.staleTime\n    )\n\n\n@view\n@external\ndef isValidPriceConfig(_config: ls.SnapShotPriceConfig) -> bool:\n    return self._isValidPriceConfig(_config)\n\n\n@view\n@internal\ndef _isValidPriceConfig(_config: ls.SnapShotPriceConfig) -> bool:\n    if _config.minSnapshotDelay > ONE_WEEK_SECONDS:\n        return False\n    if _config.maxNumSnapshots == 0 or _config.maxNumSnapshots > 25:\n        return False\n    if _config.maxUpsideDeviation > HUNDRED_PERCENT:\n        return False\n    return _config.staleTime < ONE_WEEK_SECONDS",
            "sha256sum": "50440c96dc8a7af22e7ad927bb6d3e308f137d5d3632e633e084b05510c94c28"
          },
          "contracts/legos/yield/Avantis.vy": {
            "content": "#     __   __ ___ _______ ___     ______       ___     _______ _______ _______ \n#    |  | |  |   |       |   |   |      |     |   |   |       |       |       |\n#    |  |_|  |   |    ___|   |   |  _    |    |   |   |    ___|    ___|   _   |\n#    |       |   |   |___|   |   | | |   |    |   |   |   |___|   | __|  | |  |\n#    |_     _|   |    ___|   |___| |_|   |    |   |___|    ___|   ||  |  |_|  |\n#      |   | |   |   |___|       |       |    |       |   |___|   |_| |       |\n#      |___| |___|_______|_______|______|     |_______|_______|_______|_______|\n#                                                                       \n#     \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n#     \u2551  ** Avantis **                      \u2551\n#     \u2551  Integration with Avantis Protocol. \u2551\n#     \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n#\n#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nimplements: Lego\nimplements: YieldLego\n\nexports: addys.__interface__\nexports: yld.__interface__\n\ninitializes: addys\ninitializes: yld[addys := addys]\n\nfrom interfaces import LegoPartner as Lego\nfrom interfaces import YieldLego as YieldLego\nfrom interfaces import WalletStructs as ws\nfrom interfaces import LegoStructs as ls\n\nimport contracts.modules.Addys as addys\nimport contracts.modules.YieldLegoData as yld\n\nfrom ethereum.ercs import IERC20\nfrom ethereum.ercs import IERC4626\nfrom ethereum.ercs import IERC20Detailed\n\ninterface Ledger:\n    def setVaultToken(_vaultToken: address, _legoId: uint256, _underlyingAsset: address, _decimals: uint256, _isRebasing: bool): nonpayable\n    def isRegisteredVaultToken(_vaultToken: address) -> bool: view\n    def isUserWallet(_user: address) -> bool: view\n\ninterface Registry:\n    def getRegId(_addr: address) -> uint256: view\n    def isValidAddr(_addr: address) -> bool: view\n\ninterface AvantisVault:\n    def getWithdrawalFeesTotal(_amount: uint256) -> uint256: view\n    def totalReserved() -> uint256: view\n\ninterface Appraiser:\n    def getUnderlyingUsdValue(_asset: address, _amount: uint256) -> uint256: view\n\ninterface VaultRegistry:\n    def isEarnVault(_vaultAddr: address) -> bool: view\n\nevent AvantisDeposit:\n    sender: indexed(address)\n    asset: indexed(address)\n    vaultToken: indexed(address)\n    assetAmountDeposited: uint256\n    usdValue: uint256\n    vaultTokenAmountReceived: uint256\n    recipient: address\n\nevent AvantisWithdrawal:\n    sender: indexed(address)\n    asset: indexed(address)\n    vaultToken: indexed(address)\n    assetAmountReceived: uint256\n    usdValue: uint256\n    vaultTokenAmountBurned: uint256\n    recipient: address\n\nAVANTIS_USDC_VAULT: public(immutable(address))\nRIPE_REGISTRY: public(immutable(address))\n\nMAX_TOKEN_PATH: constant(uint256) = 5\nMAX_PROOFS: constant(uint256) = 25\nHUNDRED_PERCENT: constant(uint256) = 100_00\n\n\n@deploy\ndef __init__(_undyHq: address, _avantisUsdcVault: address, _ripeRegistry: address):\n    addys.__init__(_undyHq)\n    yld.__init__(False)\n\n    assert _avantisUsdcVault != empty(address) # dev: invalid addr\n    AVANTIS_USDC_VAULT = _avantisUsdcVault\n\n    assert _ripeRegistry != empty(address) # dev: invalid addrs\n    RIPE_REGISTRY = _ripeRegistry\n\n\n@view\n@external\ndef hasCapability(_action: ws.ActionType) -> bool:\n    return _action in (\n        ws.ActionType.EARN_DEPOSIT | \n        ws.ActionType.EARN_WITHDRAW\n    )\n\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    return []\n\n\n@view\n@external\ndef isYieldLego() -> bool:\n    return True\n\n\n@view\n@external\ndef isDexLego() -> bool:\n    return False\n\n\n###################\n# Underlying Data #\n###################\n\n\n# underlying asset\n\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    return self._getUnderlyingAsset(_vaultToken)\n\n\n@view\n@internal\ndef _getUnderlyingAsset(_vaultToken: address) -> address:\n    asset: address = yld.vaultToAsset[_vaultToken].underlyingAsset\n    if asset != empty(address):\n        return asset\n    return staticcall IERC4626(_vaultToken).asset()\n\n\n# underlying balances (both true and safe)\n\n\n@view\n@external\ndef getUnderlyingBalances(_vaultToken: address, _vaultTokenBalance: uint256) -> (uint256, uint256):\n    if _vaultTokenBalance == 0:\n        return 0, 0\n\n    trueUnderlying: uint256 = self._getUnderlyingAmount(_vaultToken, _vaultTokenBalance)\n    safeUnderlying: uint256 = self._getUnderlyingAmountSafe(_vaultToken, _vaultTokenBalance)\n    if safeUnderlying == 0:\n        safeUnderlying = trueUnderlying\n\n    return trueUnderlying, min(trueUnderlying, safeUnderlying)\n\n\n# underlying amount (true)\n\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    return self._getUnderlyingAmount(_vaultToken, _vaultTokenAmount)\n\n\n@view\n@internal\ndef _getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    return staticcall IERC4626(_vaultToken).previewRedeem(_vaultTokenAmount)\n\n\n# underlying amount (safe)\n\n\n@view\n@external\ndef getUnderlyingAmountSafe(_vaultToken: address, _vaultTokenBalance: uint256) -> uint256:\n    return self._getUnderlyingAmountSafe(_vaultToken, _vaultTokenBalance)\n\n\n@view\n@internal\ndef _getUnderlyingAmountSafe(_vaultToken: address, _vaultTokenBalance: uint256) -> uint256:\n    vaultInfo: ls.VaultTokenInfo = yld.vaultToAsset[_vaultToken]\n    if vaultInfo.decimals == 0:\n        return 0 # not registered\n\n    # safe underlying amount (using cached weighted average from snapshots)\n    return _vaultTokenBalance * vaultInfo.lastAveragePricePerShare // (10 ** vaultInfo.decimals)\n\n\n# underlying data (combined)\n\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> (address, uint256, uint256):\n    return self._getUnderlyingData(_vaultToken, _vaultTokenAmount, _appraiser)\n\n\n@view\n@internal\ndef _getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address) -> (address, uint256, uint256):\n    asset: address = self._getUnderlyingAsset(_vaultToken)\n    if asset == empty(address):\n        return empty(address), 0, 0 # invalid vault token\n    underlyingAmount: uint256 = self._getUnderlyingAmount(_vaultToken, _vaultTokenAmount)\n    usdValue: uint256 = self._getUsdValue(asset, underlyingAmount, _appraiser)\n    return asset, underlyingAmount, usdValue\n\n\n# usd value\n\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> uint256:\n    return self._getUsdValueOfVaultToken(_vaultToken, _vaultTokenAmount, _appraiser)\n\n\n@view\n@internal\ndef _getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address) -> uint256:\n    return self._getUnderlyingData(_vaultToken, _vaultTokenAmount, _appraiser)[2]\n\n\n@view\n@internal\ndef _getUsdValue(_asset: address, _amount: uint256, _appraiser: address) -> uint256:\n    appraiser: address = _appraiser\n    if _appraiser == empty(address):\n        appraiser = addys._getAppraiserAddr()\n    return staticcall Appraiser(appraiser).getUnderlyingUsdValue(_asset, _amount)\n\n\n###############\n# Other Utils #\n###############\n\n\n# basics\n\n\n@view\n@external\ndef isRebasing() -> bool:\n    return self._isRebasing()\n\n\n@view\n@internal\ndef _isRebasing() -> bool:\n    return False\n\n\n# price per share\n\n\n@view\n@external\ndef getPricePerShare(_vaultToken: address, _decimals: uint256 = 0) -> uint256:\n    decimals: uint256 = _decimals\n    if decimals == 0:\n        decimals = yld.vaultToAsset[_vaultToken].decimals\n    if decimals == 0:\n        decimals = convert(staticcall IERC20Detailed(_vaultToken).decimals(), uint256)\n    return self._getPricePerShare(_vaultToken, decimals)\n\n\n@view\n@internal\ndef _getPricePerShare(_vaultToken: address, _decimals: uint256) -> uint256:\n    return staticcall IERC4626(_vaultToken).previewRedeem(10 ** _decimals)\n\n\n# vault token amount\n\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    return staticcall IERC4626(_vaultToken).convertToShares(_assetAmount)\n\n\n# total assets\n\n\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    return self._totalAssets(_vaultToken)\n\n\n@view\n@internal\ndef _totalAssets(_vaultToken: address) -> uint256:\n    return staticcall IERC4626(_vaultToken).totalAssets()\n\n\n# total borrows\n\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    return self._totalBorrows(_vaultToken)\n\n\n@view\n@internal\ndef _totalBorrows(_vaultToken: address) -> uint256:\n    # totalReserved = capital reserved for open positions (virtual borrows)\n    return staticcall AvantisVault(_vaultToken).totalReserved()\n\n\n# avail liquidity\n\n\n@view\n@external\ndef getAvailLiquidity(_vaultToken: address) -> uint256:\n    return self._getAvailLiquidity(_vaultToken)\n\n\n@view\n@internal\ndef _getAvailLiquidity(_vaultToken: address) -> uint256:\n    # available liquidity = total assets - reserved (locked for positions)\n    totalAssets: uint256 = self._totalAssets(_vaultToken)\n    totalReserved: uint256 = self._totalBorrows(_vaultToken)\n    if totalAssets <= totalReserved:\n        return 0\n    return totalAssets - totalReserved\n\n\n# utilization\n\n\n@view\n@external\ndef getUtilizationRatio(_vaultToken: address) -> uint256:\n    # calculate utilization as totalBorrows / totalAssets (consistent with other legos)\n    # note: vault's utilizationRatio() measures OI against limits, not against TVL\n    totalAssets: uint256 = self._totalAssets(_vaultToken)\n    if totalAssets == 0:\n        return 0\n    totalBorrows: uint256 = self._totalBorrows(_vaultToken)\n    return totalBorrows * HUNDRED_PERCENT // totalAssets\n\n\n# extras\n\n\n@view\n@external\ndef isEligibleForYieldBonus(_asset: address) -> bool:\n    return False\n\n\n@view\n@external\ndef getWithdrawalFees(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    return staticcall AvantisVault(_vaultToken).getWithdrawalFeesTotal(_vaultTokenAmount)\n\n\n################\n# Registration #\n################\n\n\n# can vault be registered\n\n\n@view\n@external\ndef canRegisterVaultToken(_asset: address, _vaultToken: address) -> bool:\n    return self._canRegisterVaultToken(_asset, _vaultToken)\n\n\n@view\n@internal\ndef _canRegisterVaultToken(_asset: address, _vaultToken: address) -> bool:\n    if empty(address) in [_asset, _vaultToken]:\n        return False\n    return staticcall IERC4626(_vaultToken).asset() == _asset and _vaultToken == AVANTIS_USDC_VAULT\n\n\n# register vault token locally\n\n\n@external\ndef registerVaultTokenLocally(_asset: address, _vaultAddr: address) -> ls.VaultTokenInfo:\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert self._canRegisterVaultToken(_asset, _vaultAddr) # dev: cannot register vault token\n    assert not yld._isAssetOpportunity(_asset, _vaultAddr) # dev: already registered\n    vaultInfo: ls.VaultTokenInfo = self._registerVaultTokenLocally(_asset, _vaultAddr)\n    self._registerVaultTokenGlobally(_asset, _vaultAddr, vaultInfo.decimals, addys._getLedgerAddr(), addys._getLegoBookAddr())\n    return vaultInfo\n\n\n@internal\ndef _registerVaultTokenLocally(_asset: address, _vaultAddr: address) -> ls.VaultTokenInfo:\n    assert extcall IERC20(_asset).approve(_vaultAddr, max_value(uint256), default_return_value=True) # dev: max approval failed\n    vaultInfo: ls.VaultTokenInfo = yld._addAssetOpportunity(_asset, _vaultAddr)\n    assert vaultInfo.decimals != 0 # dev: invalid vault token\n    return vaultInfo\n\n\n# remove vault token locally\n\n\n@external\ndef deregisterVaultTokenLocally(_asset: address, _vaultAddr: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert yld._isAssetOpportunity(_asset, _vaultAddr) # dev: already registered\n    self._deregisterVaultTokenLocally(_asset, _vaultAddr)\n\n\n@internal\ndef _deregisterVaultTokenLocally(_asset: address, _vaultAddr: address):\n    assert extcall IERC20(_asset).approve(_vaultAddr, 0, default_return_value=True) # dev: max approval failed\n    yld._removeAssetOpportunity(_asset, _vaultAddr)\n\n\n# ledger registration\n\n\n@internal\ndef _registerVaultTokenGlobally(_underlyingAsset: address, _vaultToken: address, _decimals: uint256, _ledger: address, _legoBook: address):\n    if not staticcall Ledger(_ledger).isRegisteredVaultToken(_vaultToken):\n        legoId: uint256 = staticcall Registry(_legoBook).getRegId(self)\n        extcall Ledger(_ledger).setVaultToken(_vaultToken, legoId, _underlyingAsset, _decimals, self._isRebasing())\n\n\n#################\n# Yield Actions #\n#################\n\n\n@view\n@internal\ndef _isAllowedToPerformAction(_caller: address) -> bool:\n    # NOTE: important to not trust `_miniAddys` here, that's why getting ledger and vault registry from addys\n    if staticcall VaultRegistry(addys._getVaultRegistryAddr()).isEarnVault(_caller):\n        return True\n    if staticcall Ledger(addys._getLedgerAddr()).isUserWallet(_caller):\n        return True\n    return staticcall Registry(RIPE_REGISTRY).isValidAddr(_caller) # Ripe Endaoment is allowed\n\n\n# add price snapshot\n\n\n@external\ndef addPriceSnapshot(_vaultToken: address) -> bool:\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    vaultInfo: ls.VaultTokenInfo = yld.vaultToAsset[_vaultToken]\n    assert vaultInfo.decimals != 0 # dev: not registered\n    pricePerShare: uint256 = self._getPricePerShare(_vaultToken, vaultInfo.decimals)\n    return yld._addPriceSnapshot(_vaultToken, pricePerShare, vaultInfo.decimals)\n\n\n# deposit\n\n\n@external\ndef depositForYield(\n    _asset: address,\n    _amount: uint256,\n    _vaultAddr: address,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, address, uint256, uint256):\n    assert self._isAllowedToPerformAction(msg.sender) # dev: no perms\n    assert not yld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = yld._getMiniAddys(_miniAddys)\n    vaultInfo: ls.VaultTokenInfo = self._getVaultInfoOnDeposit(_asset, _vaultAddr, miniAddys.ledger, miniAddys.legoBook)\n\n    # pre balances\n    preLegoBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n\n    # transfer deposit asset to this contract\n    depositAmount: uint256 = min(_amount, staticcall IERC20(_asset).balanceOf(msg.sender))\n    assert depositAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_asset).transferFrom(msg.sender, self, depositAmount, default_return_value=True) # dev: transfer failed\n\n    # deposit assets into lego partner\n    vaultTokenAmountReceived: uint256 = extcall IERC4626(_vaultAddr).deposit(depositAmount, _recipient)\n    assert vaultTokenAmountReceived != 0 # dev: no vault tokens received\n\n    # refund if full deposit didn't get through\n    currentLegoBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    refundAssetAmount: uint256 = 0\n    if currentLegoBalance > preLegoBalance:\n        refundAssetAmount = currentLegoBalance - preLegoBalance\n        assert extcall IERC20(_asset).transfer(msg.sender, refundAssetAmount, default_return_value=True) # dev: transfer failed\n        depositAmount -= refundAssetAmount\n\n    usdValue: uint256 = staticcall Appraiser(miniAddys.appraiser).getUnderlyingUsdValue(_asset, depositAmount)\n    log AvantisDeposit(\n        sender = msg.sender,\n        asset = _asset,\n        vaultToken = _vaultAddr,\n        assetAmountDeposited = depositAmount,\n        usdValue = usdValue,\n        vaultTokenAmountReceived = vaultTokenAmountReceived,\n        recipient = _recipient,\n    )\n\n    # add price snapshot\n    pricePerShare: uint256 = self._getPricePerShare(_vaultAddr, vaultInfo.decimals)\n    yld._addPriceSnapshot(_vaultAddr, pricePerShare, vaultInfo.decimals)\n\n    return depositAmount, _vaultAddr, vaultTokenAmountReceived, usdValue\n\n\n# vault info on deposit\n\n\n@internal\ndef _getVaultInfoOnDeposit(_asset: address, _vaultAddr: address, _ledger: address, _legoBook: address) -> ls.VaultTokenInfo:\n    vaultInfo: ls.VaultTokenInfo = yld.vaultToAsset[_vaultAddr]\n    if vaultInfo.decimals == 0:\n        assert self._canRegisterVaultToken(_asset, _vaultAddr) # dev: cannot register vault token\n        vaultInfo = self._registerVaultTokenLocally(_asset, _vaultAddr)\n        self._registerVaultTokenGlobally(_asset, _vaultAddr, vaultInfo.decimals, _ledger, _legoBook)\n    else:\n        assert vaultInfo.underlyingAsset == _asset # dev: asset mismatch\n    return vaultInfo\n\n\n# withdraw\n\n\n@external\ndef withdrawFromYield(\n    _vaultToken: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, address, uint256, uint256):\n    assert self._isAllowedToPerformAction(msg.sender) # dev: no perms\n    assert not yld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = yld._getMiniAddys(_miniAddys)\n    vaultInfo: ls.VaultTokenInfo = self._getVaultInfoOnWithdrawal(_vaultToken, miniAddys.ledger, miniAddys.legoBook)\n\n    # pre balances\n    preLegoVaultBalance: uint256 = staticcall IERC20(_vaultToken).balanceOf(self)\n\n    # transfer vaults tokens to this contract\n    vaultTokenAmount: uint256 = min(_amount, staticcall IERC20(_vaultToken).balanceOf(msg.sender))\n    assert vaultTokenAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_vaultToken).transferFrom(msg.sender, self, vaultTokenAmount, default_return_value=True) # dev: transfer failed\n\n    # withdraw assets from lego partner\n    assetAmountReceived: uint256 = extcall IERC4626(_vaultToken).redeem(vaultTokenAmount, _recipient, self)\n    assert assetAmountReceived != 0 # dev: no asset amount received\n\n    # refund if full withdrawal didn't happen\n    currentLegoVaultBalance: uint256 = staticcall IERC20(_vaultToken).balanceOf(self)\n    refundVaultTokenAmount: uint256 = 0\n    if currentLegoVaultBalance > preLegoVaultBalance:\n        refundVaultTokenAmount = currentLegoVaultBalance - preLegoVaultBalance\n        assert extcall IERC20(_vaultToken).transfer(msg.sender, refundVaultTokenAmount, default_return_value=True) # dev: transfer failed\n        vaultTokenAmount -= refundVaultTokenAmount\n\n    usdValue: uint256 = staticcall Appraiser(miniAddys.appraiser).getUnderlyingUsdValue(vaultInfo.underlyingAsset, assetAmountReceived)\n    log AvantisWithdrawal(\n        sender = msg.sender,\n        asset = vaultInfo.underlyingAsset,\n        vaultToken = _vaultToken,\n        assetAmountReceived = assetAmountReceived,\n        usdValue = usdValue,\n        vaultTokenAmountBurned = vaultTokenAmount,\n        recipient = _recipient,\n    )\n\n    # add price snapshot\n    pricePerShare: uint256 = self._getPricePerShare(_vaultToken, vaultInfo.decimals)\n    yld._addPriceSnapshot(_vaultToken, pricePerShare, vaultInfo.decimals)\n\n    return vaultTokenAmount, vaultInfo.underlyingAsset, assetAmountReceived, usdValue\n\n\n# vault info on withdrawal\n\n\n@internal\ndef _getVaultInfoOnWithdrawal(_vaultAddr: address, _ledger: address, _legoBook: address) -> ls.VaultTokenInfo:\n    vaultInfo: ls.VaultTokenInfo = yld.vaultToAsset[_vaultAddr]\n    if vaultInfo.decimals == 0:\n        asset: address = staticcall IERC4626(_vaultAddr).asset()\n        assert self._canRegisterVaultToken(asset, _vaultAddr) # dev: cannot register vault token\n        vaultInfo = self._registerVaultTokenLocally(asset, _vaultAddr)\n        self._registerVaultTokenGlobally(asset, _vaultAddr, vaultInfo.decimals, _ledger, _legoBook)\n    return vaultInfo\n\n\n#########\n# Other #\n#########\n\n\n@view\n@external\ndef getAccessForLego(_user: address, _action: ws.ActionType) -> (address, String[64], uint256):\n    return empty(address), empty(String[64]), 0\n\n\n@external\ndef claimRewards(\n    _user: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _extraData: bytes32,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    # backwards compatibility\n    return 0, 0\n\n\n@external\ndef claimIncentives(\n    _user: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _proofs: DynArray[bytes32, MAX_PROOFS],\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@view\n@external\ndef hasClaimableRewards(_user: address) -> bool:\n    return False\n\n\n@external\ndef swapTokens(\n    _amountIn: uint256,\n    _minAmountOut: uint256,\n    _tokenPath: DynArray[address, MAX_TOKEN_PATH],\n    _poolPath: DynArray[address, MAX_TOKEN_PATH - 1],\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256):\n    return 0, 0, 0\n\n\n@external\ndef mintOrRedeemAsset(\n    _tokenIn: address,\n    _tokenOut: address,\n    _tokenInAmount: uint256,\n    _minAmountOut: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, bool, uint256):\n    return 0, 0, False, 0\n\n\n@external\ndef confirmMintOrRedeemAsset(\n    _tokenIn: address,\n    _tokenOut: address,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef addCollateral(\n    _asset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef removeCollateral(\n    _asset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef borrow(\n    _borrowAsset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef repayDebt(\n    _paymentAsset: address,\n    _paymentAmount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef addLiquidity(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _amountA: uint256,\n    _amountB: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _minLpAmount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (address, uint256, uint256, uint256, uint256):\n    return empty(address), 0, 0, 0, 0\n\n\n@external\ndef removeLiquidity(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpToken: address,\n    _lpAmount: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, uint256):\n    return 0, 0, 0, 0\n\n\n@external\ndef addLiquidityConcentrated(\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _tickLower: int24,\n    _tickUpper: int24,\n    _amountA: uint256,\n    _amountB: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, uint256, uint256):\n    return 0, 0, 0, 0, 0\n\n\n@external\ndef removeLiquidityConcentrated(\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _liqToRemove: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, bool, uint256):\n    return 0, 0, 0, False, 0",
            "sha256sum": "4e0bf649236689c186704b7500a3e589222bd928b2d7501caf2b000edfc78421"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/legos/yield/Avantis.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.3+commit.bff19ea2",
        "integrity": "8d5f6bdefe75b23b6e55c2914e09fcfa1b1111be4a5fef24d2e8c751be5c6110"
      },
      "args": "00000000000000000000000044cf3c4f000dfd76a35d03298049d37be688d6f9000000000000000000000000944766f715b51967e56afde5f0aa76ceacc9e7f90000000000000000000000006162df1b329e157479f8f1407e888260e0ec3d2b",
      "file": "contracts/legos/yield/Avantis.vy"
    },
    "SkyPsm": {
      "address": "0x09437b00357c02a30B9aFB30292B087eC2E36983",
      "abi": [
        {
          "name": "SkyPsmDeposit",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountDeposited",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultTokenAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "SkyPsmWithdrawal",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultTokenAmountBurned",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "SlippageSet",
          "inputs": [
            {
              "name": "slippage",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LegoPauseModified",
          "inputs": [
            {
              "name": "isPaused",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LegoFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "balance",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "SnapShotPriceConfigSet",
          "inputs": [
            {
              "name": "minSnapshotDelay",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "maxNumSnapshots",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "maxUpsideDeviation",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "staleTime",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetOpportunityAdded",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultAddr",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetOpportunityRemoved",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultAddr",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PricePerShareSnapShotAdded",
          "inputs": [
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "totalSupply",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "pricePerShare",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "lastAveragePricePerShare",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddys",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "undyToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "hatchery",
                  "type": "address"
                },
                {
                  "name": "lootDistributor",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                },
                {
                  "name": "walletBackpack",
                  "type": "address"
                },
                {
                  "name": "billing",
                  "type": "address"
                },
                {
                  "name": "vaultRegistry",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUndyHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isLegoAsset",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssetOpportunities",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isAssetOpportunity",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getNumLegoAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pause",
          "inputs": [
            {
              "name": "_shouldPause",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFundsMany",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_assets",
              "type": "address[]"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getWeightedPricePerShare",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLatestSnapshot",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_pricePerShare",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "totalSupply",
                  "type": "uint256"
                },
                {
                  "name": "pricePerShare",
                  "type": "uint256"
                },
                {
                  "name": "lastUpdate",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setSnapShotPriceConfig",
          "inputs": [
            {
              "name": "_config",
              "type": "tuple",
              "components": [
                {
                  "name": "minSnapshotDelay",
                  "type": "uint256"
                },
                {
                  "name": "maxNumSnapshots",
                  "type": "uint256"
                },
                {
                  "name": "maxUpsideDeviation",
                  "type": "uint256"
                },
                {
                  "name": "staleTime",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidPriceConfig",
          "inputs": [
            {
              "name": "_config",
              "type": "tuple",
              "components": [
                {
                  "name": "minSnapshotDelay",
                  "type": "uint256"
                },
                {
                  "name": "maxNumSnapshots",
                  "type": "uint256"
                },
                {
                  "name": "maxUpsideDeviation",
                  "type": "uint256"
                },
                {
                  "name": "staleTime",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "vaultToAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "underlyingAsset",
                  "type": "address"
                },
                {
                  "name": "decimals",
                  "type": "uint256"
                },
                {
                  "name": "lastAveragePricePerShare",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assetOpportunities",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAssetOpportunity",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssetOpportunities",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assets",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "snapShotData",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "lastSnapShot",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "totalSupply",
                      "type": "uint256"
                    },
                    {
                      "name": "pricePerShare",
                      "type": "uint256"
                    },
                    {
                      "name": "lastUpdate",
                      "type": "uint256"
                    }
                  ]
                },
                {
                  "name": "nextIndex",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "snapShots",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "totalSupply",
                  "type": "uint256"
                },
                {
                  "name": "pricePerShare",
                  "type": "uint256"
                },
                {
                  "name": "lastUpdate",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "snapShotPriceConfig",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "minSnapshotDelay",
                  "type": "uint256"
                },
                {
                  "name": "maxNumSnapshots",
                  "type": "uint256"
                },
                {
                  "name": "maxUpsideDeviation",
                  "type": "uint256"
                },
                {
                  "name": "staleTime",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isPaused",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasCapability",
          "inputs": [
            {
              "name": "_action",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRegistries",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isYieldLego",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isDexLego",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAsset",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingBalances",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenBalance",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAmount",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAmountSafe",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenBalance",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingData",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingData",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            },
            {
              "name": "_appraiser",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValueOfVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValueOfVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            },
            {
              "name": "_appraiser",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isRebasing",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPricePerShare",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPricePerShare",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_decimals",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getVaultTokenAmount",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_assetAmount",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalAssets",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalBorrows",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAvailLiquidity",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUtilizationRatio",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isEligibleForYieldBonus",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getWithdrawalFees",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canRegisterVaultToken",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "registerVaultTokenLocally",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "underlyingAsset",
                  "type": "address"
                },
                {
                  "name": "decimals",
                  "type": "uint256"
                },
                {
                  "name": "lastAveragePricePerShare",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "deregisterVaultTokenLocally",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addPriceSnapshot",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositForYield",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositForYield",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawFromYield",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawFromYield",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setSlippage",
          "inputs": [
            {
              "name": "_slippage",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAccessForLego",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_action",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "string"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimIncentives",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_proofs",
              "type": "bytes32[]"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimIncentives",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_proofs",
              "type": "bytes32[]"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasClaimableRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_tokenPath",
              "type": "address[]"
            },
            {
              "name": "_poolPath",
              "type": "address[]"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_tokenPath",
              "type": "address[]"
            },
            {
              "name": "_poolPath",
              "type": "address[]"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_tokenInAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_tokenInAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmMintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmMintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_borrowAsset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_borrowAsset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_paymentAsset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_paymentAsset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "slippage",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "SKY_PSM",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "USDS",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "SUSDS",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "RIPE_REGISTRY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_undyHq",
              "type": "address"
            },
            {
              "name": "_skyPsm",
              "type": "address"
            },
            {
              "name": "_ripeRegistry",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "interfaces/WalletStructs.vyi": {
            "content": "# @version 0.4.3\n\nflag ActionType:\n    TRANSFER\n    EARN_DEPOSIT\n    EARN_WITHDRAW\n    EARN_REBALANCE\n    SWAP\n    MINT_REDEEM\n    CONFIRM_MINT_REDEEM\n    ADD_COLLATERAL\n    REMOVE_COLLATERAL\n    BORROW\n    REPAY_DEBT\n    REWARDS\n    ETH_TO_WETH\n    WETH_TO_ETH\n    ADD_LIQ\n    REMOVE_LIQ\n    ADD_LIQ_CONC\n    REMOVE_LIQ_CONC\n    PAY_CHEQUE\n\nstruct WalletAssetData:\n    assetBalance: uint256\n    usdValue: uint256\n    isYieldAsset: bool\n    lastPricePerShare: uint256\n\nstruct ActionData:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    billing: address\n    vaultRegistry: address\n    wallet: address\n    walletConfig: address\n    walletOwner: address\n    inEjectMode: bool\n    isFrozen: bool\n    lastTotalUsdValue: uint256\n    signer: address\n    isManager: bool\n    legoId: uint256\n    legoAddr: address\n    eth: address\n    weth: address\n\nstruct MiniAddys:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    appraiser: address",
            "sha256sum": "466493c129135c95470aaf70eeddc936632f7b0f813396e5a7ddc03bea9da518"
          },
          "interfaces/LegoPartner.vyi": {
            "content": "# @version 0.4.3\n\nfrom interfaces import WalletStructs as ws\n\nMAX_TOKEN_PATH: constant(uint256) = 5\nMAX_RECOVER_ASSETS: constant(uint256) = 20\nMAX_PROOFS: constant(uint256) = 25\n\n@external\ndef addLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _tickLower: int24, _tickUpper: int24, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef addLiquidity(_pool: address, _tokenA: address, _tokenB: address, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _minLpAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (address, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef removeLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _liqToRemove: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef removeLiquidity(_pool: address, _tokenA: address, _tokenB: address, _lpToken: address, _lpAmount: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef mintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _tokenInAmount: uint256, _minAmountOut: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef swapTokens(_amountIn: uint256, _minAmountOut: uint256, _tokenPath: DynArray[address, MAX_TOKEN_PATH], _poolPath: DynArray[address, MAX_TOKEN_PATH - 1], _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256):\n    ...\n\n@external\ndef depositForYield(_asset: address, _amount: uint256, _vaultAddr: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef withdrawFromYield(_vaultToken: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef confirmMintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef borrow(_borrowAsset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef repayDebt(_paymentAsset: address, _paymentAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef claimIncentives(_user: address, _rewardToken: address, _rewardAmount: uint256, _proofs: DynArray[bytes32, MAX_PROOFS], _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef removeCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef addCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@view\n@external\ndef getAccessForLego(_user: address, _action: ws.ActionType) -> (address, String[64], uint256):\n    ...\n\n@view\n@external\ndef hasCapability(_action: ws.ActionType) -> bool:\n    ...\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    ...\n\n@view\n@external\ndef isYieldLego() -> bool:\n    ...\n\n@view\n@external\ndef isDexLego() -> bool:\n    ...\n\n\n# common\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "f2afb7bd72d4301aea77bbe4177b7ae954ba6f6b76af363965993eb92ad0b715"
          },
          "interfaces/LegoStructs.vyi": {
            "content": "# @version 0.4.3\n\nstruct VaultTokenInfo:\n    underlyingAsset: address\n    decimals: uint256\n    lastAveragePricePerShare: uint256\n\nstruct SnapShotPriceConfig:\n    minSnapshotDelay: uint256\n    maxNumSnapshots: uint256\n    maxUpsideDeviation: uint256\n    staleTime: uint256\n\nstruct SingleSnapShot:\n    totalSupply: uint256\n    pricePerShare: uint256\n    lastUpdate: uint256\n\nstruct SnapShotData:\n    lastSnapShot: SingleSnapShot\n    nextIndex: uint256\n",
            "sha256sum": "8ae48be17d812d57fbd671bbf0593e8abf175ad0924e47c5997823cac19ec806"
          },
          "interfaces/YieldLego.vyi": {
            "content": "# @version 0.4.3\n\nfrom interfaces import LegoStructs as ls\n\n\n###################\n# Underlying Data #\n###################\n\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    ...\n\n\n@view\n@external\ndef getUnderlyingBalances(_vaultToken: address, _vaultTokenBalance: uint256) -> (uint256, uint256):\n    ...\n\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    ...\n\n\n@view\n@external\ndef getUnderlyingAmountSafe(_vaultToken: address, _vaultTokenBalance: uint256) -> uint256:\n    ...\n\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> (address, uint256, uint256):\n    ...\n\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> uint256:\n    ...\n\n\n###############\n# Other Utils #\n###############\n\n\n@view\n@external\ndef isRebasing() -> bool:\n    ...\n\n\n@view\n@external\ndef getPricePerShare(_vaultToken: address, _decimals: uint256 = 0) -> uint256:\n    ...\n\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef canRegisterVaultToken(_asset: address, _vaultToken: address) -> bool:\n    ...\n\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef getUtilizationRatio(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef getAvailLiquidity(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef isEligibleForYieldBonus(_asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef getWithdrawalFees(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    ...\n\n\n###################\n# Yield Lego Data #\n###################\n\n\n@view\n@external\ndef isLegoAsset(_asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, 40]:\n    ...\n\n\n@view\n@external\ndef getAssets() -> DynArray[address, 20]:\n    ...\n\n\n@view\n@external\ndef isAssetOpportunity(_asset: address, _vaultAddr: address) -> bool:\n    ...\n\n\n@view\n@external\ndef getNumLegoAssets() -> uint256:\n    ...\n\n\n@view\n@external\ndef assets(_index: uint256) -> address:\n    ...\n\n\n@view\n@external\ndef indexOfAsset(_asset: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef numAssets() -> uint256:\n    ...\n\n\n@view\n@external\ndef assetOpportunities(_asset: address, _index: uint256) -> address:\n    ...\n\n\n@view\n@external\ndef indexOfAssetOpportunity(_asset: address, _vaultAddr: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef numAssetOpportunities(_asset: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef vaultToAsset(_vaultAddr: address) -> ls.VaultTokenInfo:\n    ...\n\n\n# price snapshots\n\n\n@external\ndef addPriceSnapshot(_vaultToken: address) -> bool:\n    ...\n\n\n@view\n@external\ndef snapShotPriceConfig() -> ls.SnapShotPriceConfig:\n    ...\n\n\n@view\n@external\ndef snapShotData(_vaultToken: address) -> ls.SnapShotData:\n    ...\n\n\n@view\n@external\ndef snapShots(_vaultToken: address, _index: uint256) -> ls.SingleSnapShot:\n    ...\n\n\n@view\n@external\ndef getWeightedPricePerShare(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef getLatestSnapshot(_vaultToken: address, _pricePerShare: uint256) -> ls.SingleSnapShot:\n    ...\n\n\n@external\ndef setSnapShotPriceConfig(_config: ls.SnapShotPriceConfig):\n    ...\n",
            "sha256sum": "db91c139f6018f5218b389d08c8703bc16fb994aa948805dbfea27e072f382ec"
          },
          "contracts/modules/Addys.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\ninterface UndyHq:\n    def isValidAddr(_addr: address) -> bool: view\n    def getAddr(_regId: uint256) -> address: view\n    def undyToken() -> address: view\n\ninterface Switchboard:\n    def isSwitchboardAddr(_addr: address) -> bool: view\n\ninterface LegoBook:\n    def isLegoAddr(_addr: address) -> bool: view\n\nstruct Addys:\n    hq: address\n    undyToken: address\n    ledger: address\n    missionControl: address\n    legoBook: address\n    switchboard: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    walletBackpack: address\n    billing: address\n    vaultRegistry: address\n\n# hq\nUNDY_HQ_FOR_ADDYS: immutable(address)\n\n# core addys\nLEDGER_ID: constant(uint256) = 1\nMISSION_CONTROL_ID: constant(uint256) = 2\nLEGO_BOOK_ID: constant(uint256) = 3\nSWITCHBOARD_ID: constant(uint256) = 4\nHATCHERY_ID: constant(uint256) = 5\nLOOT_DISTRIBUTOR_ID: constant(uint256) = 6\nAPPRAISER_ID: constant(uint256) = 7\nWALLET_BACKPACK_ID: constant(uint256) = 8\nBILLING_ID: constant(uint256) = 9\nVAULT_REGISTRY_ID: constant(uint256) = 10\n\n\n@deploy\ndef __init__(_undyHq: address):\n    assert _undyHq != empty(address) # dev: invalid undy hq\n    UNDY_HQ_FOR_ADDYS = _undyHq\n\n\n########\n# Core #\n########\n\n\n@view\n@external\ndef getAddys() -> Addys:\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _getAddys(_addys: Addys = empty(Addys)) -> Addys:\n    if _addys.hq != empty(address):\n        return _addys\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _generateAddys() -> Addys:\n    hq: address = UNDY_HQ_FOR_ADDYS\n    return Addys(\n        hq = hq,\n        undyToken = staticcall UndyHq(hq).undyToken(),\n        ledger = staticcall UndyHq(hq).getAddr(LEDGER_ID),\n        missionControl = staticcall UndyHq(hq).getAddr(MISSION_CONTROL_ID),\n        legoBook = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID),\n        switchboard = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID),\n        hatchery = staticcall UndyHq(hq).getAddr(HATCHERY_ID),\n        lootDistributor = staticcall UndyHq(hq).getAddr(LOOT_DISTRIBUTOR_ID),\n        appraiser = staticcall UndyHq(hq).getAddr(APPRAISER_ID),\n        walletBackpack = staticcall UndyHq(hq).getAddr(WALLET_BACKPACK_ID),\n        billing = staticcall UndyHq(hq).getAddr(BILLING_ID),\n        vaultRegistry = staticcall UndyHq(hq).getAddr(VAULT_REGISTRY_ID),\n    )\n\n\n##########\n# Tokens #\n##########\n\n\n@view\n@internal\ndef _getUndyToken() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).undyToken()\n\n\n###########\n# Helpers #\n###########\n\n\n# undy hq\n\n\n@view\n@external\ndef getUndyHq() -> address:\n    return self._getUndyHq()\n\n\n@view\n@internal\ndef _getUndyHq() -> address:\n    return UNDY_HQ_FOR_ADDYS\n\n\n# utils\n\n\n@view\n@internal\ndef _isValidUndyAddr(_addr: address, _hq: address = empty(address)) -> bool:\n    hq: address = _hq\n    if _hq == empty(address):\n        hq = UNDY_HQ_FOR_ADDYS\n    \n    # core departments\n    if staticcall UndyHq(hq).isValidAddr(_addr):\n        return True\n\n    # lego book\n    legoBook: address = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID)\n    if legoBook != empty(address) and staticcall LegoBook(legoBook).isLegoAddr(_addr):\n        return True\n\n    # switchboard config\n    switchboard: address = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID)\n    if switchboard != empty(address) and staticcall Switchboard(switchboard).isSwitchboardAddr(_addr):\n        return True\n\n    return False\n\n\n@view\n@internal\ndef _isSwitchboardAddr(_addr: address) -> bool:\n    switchboard: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n    if switchboard == empty(address):\n        return False\n    return staticcall Switchboard(switchboard).isSwitchboardAddr(_addr)\n\n\n@view\n@internal\ndef _isLegoBookAddr(_addr: address) -> bool:\n    legoBook: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n    if legoBook == empty(address):\n        return False\n    return staticcall LegoBook(legoBook).isLegoAddr(_addr)\n\n\n###############\n# Departments #\n###############\n\n\n# ledger\n\n\n@view\n@internal\ndef _getLedgerId() -> uint256:\n    return LEDGER_ID\n\n\n@view\n@internal\ndef _getLedgerAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEDGER_ID)\n\n\n# mission control\n\n\n@view\n@internal\ndef _getMissionControlId() -> uint256:\n    return MISSION_CONTROL_ID\n\n\n@view\n@internal\ndef _getMissionControlAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(MISSION_CONTROL_ID)\n\n\n# lego book\n\n\n@view\n@internal\ndef _getLegoBookId() -> uint256:\n    return LEGO_BOOK_ID\n\n\n@view\n@internal\ndef _getLegoBookAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n\n\n# switchboard\n\n\n@view\n@internal\ndef _getSwitchboardId() -> uint256:\n    return SWITCHBOARD_ID\n\n\n@view\n@internal\ndef _getSwitchboardAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n\n\n# hatchery\n\n\n@view\n@internal\ndef _getHatcheryId() -> uint256:\n    return HATCHERY_ID\n\n\n@view\n@internal\ndef _getHatcheryAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(HATCHERY_ID)\n\n\n# loot distributor\n\n\n@view\n@internal\ndef _getLootDistributorId() -> uint256:\n    return LOOT_DISTRIBUTOR_ID\n\n\n@view\n@internal\ndef _getLootDistributorAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LOOT_DISTRIBUTOR_ID)\n\n\n# appraiser\n\n\n@view\n@internal\ndef _getAppraiserId() -> uint256:\n    return APPRAISER_ID\n\n\n@view\n@internal\ndef _getAppraiserAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(APPRAISER_ID)\n\n\n# wallet backpack\n\n\n@view\n@internal\ndef _getWalletBackpackId() -> uint256:\n    return WALLET_BACKPACK_ID\n\n\n@view\n@internal\ndef _getWalletBackpackAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(WALLET_BACKPACK_ID)\n\n\n# billing\n\n\n@view\n@internal\ndef _getBillingId() -> uint256:\n    return BILLING_ID\n\n\n@view\n@internal\ndef _getBillingAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(BILLING_ID)\n\n\n# vault registry\n\n\n@view\n@internal\ndef _getVaultRegistryId() -> uint256:\n    return VAULT_REGISTRY_ID\n\n\n@view\n@internal\ndef _getVaultRegistryAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(VAULT_REGISTRY_ID)",
            "sha256sum": "4df6b72db9bb417d1af81660175be1450cfb7b3575f3d17a5b8a130bff87b781"
          },
          "contracts/modules/YieldLegoData.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nuses: addys\n\nimport contracts.modules.Addys as addys\n\nfrom interfaces import WalletStructs as ws\nfrom interfaces import LegoStructs as ls\nfrom ethereum.ercs import IERC20\nfrom ethereum.ercs import IERC20Detailed\n\nevent AssetOpportunityAdded:\n    asset: indexed(address)\n    vaultAddr: indexed(address)\n\nevent AssetOpportunityRemoved:\n    asset: indexed(address)\n    vaultAddr: indexed(address)\n\nevent LegoPauseModified:\n    isPaused: bool\n\nevent LegoFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    balance: uint256\n\nevent PricePerShareSnapShotAdded:\n    vaultToken: indexed(address)\n    totalSupply: uint256\n    pricePerShare: uint256\n    lastAveragePricePerShare: uint256\n\nevent SnapShotPriceConfigSet:\n    minSnapshotDelay: uint256\n    maxNumSnapshots: uint256\n    maxUpsideDeviation: uint256\n    staleTime: uint256\n\n# core\nvaultToAsset: public(HashMap[address, ls.VaultTokenInfo]) # vault addr -> data\n\n# asset opportunities\nassetOpportunities: public(HashMap[address, HashMap[uint256, address]]) # asset -> index -> vault addr\nindexOfAssetOpportunity: public(HashMap[address, HashMap[address, uint256]]) # asset -> vault addr -> index\nnumAssetOpportunities: public(HashMap[address, uint256]) # asset -> number of opportunities\n\n# lego assets (iterable)\nassets: public(HashMap[uint256, address]) # index -> asset\nindexOfAsset: public(HashMap[address, uint256]) # asset -> index\nnumAssets: public(uint256) # num assets\n\n# price snapshots\nsnapShotData: public(HashMap[address, ls.SnapShotData]) # vault token -> data\nsnapShots: public(HashMap[address, HashMap[uint256, ls.SingleSnapShot]]) # vault token -> index -> snapshot\nsnapShotPriceConfig: public(ls.SnapShotPriceConfig) # config\n\nisPaused: public(bool)\n\nMAX_VAULTS: constant(uint256) = 40\nMAX_ASSETS: constant(uint256) = 20\nMAX_RECOVER_ASSETS: constant(uint256) = 20\nONE_DAY_SECONDS: constant(uint256) = 60 * 60 * 24\nONE_WEEK_SECONDS: constant(uint256) = ONE_DAY_SECONDS * 7\nHUNDRED_PERCENT: constant(uint256) = 100_00\n\n\n@deploy\ndef __init__(_shouldPause: bool):\n    self.isPaused = _shouldPause\n    self.numAssets = 1 # not using 0 index\n\n    # default snapshot price config\n    self.snapShotPriceConfig = ls.SnapShotPriceConfig(\n        minSnapshotDelay = 60 * 10, # 10 minutes\n        maxNumSnapshots = 20,\n        maxUpsideDeviation = 10_00, # 10%\n        staleTime = ONE_DAY_SECONDS, # 1 day\n    )\n\n\n#########\n# Views #\n#########\n\n\n# is lego asset\n\n\n@view\n@external\ndef isLegoAsset(_asset: address) -> bool:\n    return self._isLegoAsset(_asset)\n\n\n@view\n@internal\ndef _isLegoAsset(_asset: address) -> bool:\n    return self.indexOfAsset[_asset] != 0\n\n\n# vault opportunities\n\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, MAX_VAULTS]:\n    numOpportunities: uint256 = self.numAssetOpportunities[_asset]\n    if numOpportunities == 0:\n        return []\n    opportunities: DynArray[address, MAX_VAULTS] = []\n    for i: uint256 in range(1, numOpportunities, bound=MAX_VAULTS):\n        opportunities.append(self.assetOpportunities[_asset][i])\n    return opportunities\n\n\n# all assets registered\n\n\n@view\n@external\ndef getAssets() -> DynArray[address, MAX_ASSETS]:\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return []\n    assets: DynArray[address, MAX_ASSETS] = []\n    for i: uint256 in range(1, numAssets, bound=MAX_ASSETS):\n        assets.append(self.assets[i])\n    return assets\n\n\n################\n# Registration #\n################\n\n\n@view\n@external\ndef isAssetOpportunity(_asset: address, _vaultAddr: address) -> bool:\n    return self._isAssetOpportunity(_asset, _vaultAddr)\n\n\n@view\n@internal\ndef _isAssetOpportunity(_asset: address, _vaultAddr: address) -> bool:\n    return self.indexOfAssetOpportunity[_asset][_vaultAddr] != 0\n\n\n# add asset opportunity\n\n\n@internal\ndef _addAssetOpportunity(_asset: address, _vaultAddr: address) -> ls.VaultTokenInfo:\n    if self.indexOfAssetOpportunity[_asset][_vaultAddr] != 0:\n        return self.vaultToAsset[_vaultAddr]\n\n    if empty(address) in [_asset, _vaultAddr]:\n        return empty(ls.VaultTokenInfo)\n\n    # add asset opportunity\n    aid: uint256 = self.numAssetOpportunities[_asset]\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.assetOpportunities[_asset][aid] = _vaultAddr\n    self.indexOfAssetOpportunity[_asset][_vaultAddr] = aid\n    self.numAssetOpportunities[_asset] = aid + 1\n\n    # add mapping\n    vaultInfo: ls.VaultTokenInfo = ls.VaultTokenInfo(\n        underlyingAsset = _asset,\n        decimals = convert(staticcall IERC20Detailed(_vaultAddr).decimals(), uint256),\n        lastAveragePricePerShare = 0,\n    )\n    self.vaultToAsset[_vaultAddr] = vaultInfo\n\n    # add asset\n    self._addAsset(_asset)\n\n    log AssetOpportunityAdded(asset=_asset, vaultAddr=_vaultAddr)\n    return vaultInfo\n\n\n# remove asset opportunity\n\n\n@internal\ndef _removeAssetOpportunity(_asset: address, _vaultAddr: address):\n    numOpportunities: uint256 = self.numAssetOpportunities[_asset]\n    if numOpportunities == 0:\n        return\n\n    targetIndex: uint256 = self.indexOfAssetOpportunity[_asset][_vaultAddr]\n    if targetIndex == 0:\n        return\n\n    # update data\n    lastIndex: uint256 = numOpportunities - 1\n    self.numAssetOpportunities[_asset] = lastIndex\n    self.indexOfAssetOpportunity[_asset][_vaultAddr] = 0\n\n    self.vaultToAsset[_vaultAddr] = empty(ls.VaultTokenInfo)\n\n    # clear all snapshot data for the vault token to prevent contamination on re-add\n    self.snapShotData[_vaultAddr] = empty(ls.SnapShotData)\n\n    # clear all historical snapshots\n    config: ls.SnapShotPriceConfig = self.snapShotPriceConfig\n    for i: uint256 in range(config.maxNumSnapshots, bound=max_value(uint256)):\n        if i >= config.maxNumSnapshots:\n            break\n        self.snapShots[_vaultAddr][i] = empty(ls.SingleSnapShot)\n\n    # shift to replace the removed one\n    if targetIndex != lastIndex:\n        lastVaultAddr: address = self.assetOpportunities[_asset][lastIndex]\n        self.assetOpportunities[_asset][targetIndex] = lastVaultAddr\n        self.indexOfAssetOpportunity[_asset][lastVaultAddr] = targetIndex\n\n    # remove asset\n    if lastIndex <= 1:\n        self._removeAsset(_asset)\n\n    log AssetOpportunityRemoved(asset=_asset, vaultAddr=_vaultAddr)\n\n\n# add asset\n\n\n@internal\ndef _addAsset(_asset: address):\n    if self.indexOfAsset[_asset] != 0:\n        return\n\n    aid: uint256 = self.numAssets\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.assets[aid] = _asset\n    self.indexOfAsset[_asset] = aid\n    self.numAssets = aid + 1\n\n\n# remove asset\n\n\n@internal\ndef _removeAsset(_asset: address):\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return\n\n    targetIndex: uint256 = self.indexOfAsset[_asset]\n    if targetIndex == 0:\n        return\n\n    # update data\n    lastIndex: uint256 = numAssets - 1\n    self.numAssets = lastIndex\n    self.indexOfAsset[_asset] = 0\n\n    # shift to replace the removed one\n    if targetIndex != lastIndex:\n        lastAsset: address = self.assets[lastIndex]\n        self.assets[targetIndex] = lastAsset\n        self.indexOfAsset[lastAsset] = targetIndex\n\n\n# num lego assets (true number, use `numAssets` for iteration)\n\n\n@view\n@external\ndef getNumLegoAssets() -> uint256:\n    return self._getNumLegoAssets()\n\n\n@view\n@internal\ndef _getNumLegoAssets() -> uint256:\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return 0\n    return numAssets - 1\n\n\n###########\n# General #\n###########\n\n\n# fill mini addys\n\n\n@view\n@internal\ndef _getMiniAddys(_miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> ws.MiniAddys:\n    if _miniAddys.ledger != empty(address):\n        return _miniAddys\n    return ws.MiniAddys(\n        ledger = addys._getLedgerAddr(),\n        missionControl = addys._getMissionControlAddr(),\n        legoBook = addys._getLegoBookAddr(),\n        appraiser = addys._getAppraiserAddr(),\n    )\n\n\n# activate\n\n\n@external\ndef pause(_shouldPause: bool):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert _shouldPause != self.isPaused # dev: no change\n    self.isPaused = _shouldPause\n    log LegoPauseModified(isPaused=_shouldPause)\n\n\n# recover funds\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    self._recoverFunds(_recipient, _asset)\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, MAX_RECOVER_ASSETS]):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    for a: address in _assets:\n        self._recoverFunds(_recipient, a)\n\n\n@internal\ndef _recoverFunds(_recipient: address, _asset: address):\n    assert empty(address) not in [_recipient, _asset] # dev: invalid recipient or asset\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    assert balance != 0 # dev: nothing to recover\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log LegoFundsRecovered(asset=_asset, recipient=_recipient, balance=balance)\n\n\n###################\n# Price Snapshots #\n###################\n\n\n# add price snapshot\n\n\n@internal\ndef _addPriceSnapshot(_vaultToken: address, _pricePerShare: uint256, _vaultTokenDecimals: uint256) -> bool:\n    config: ls.SnapShotPriceConfig = self.snapShotPriceConfig\n    if config.maxNumSnapshots == 0:\n        return False\n\n    data: ls.SnapShotData = self.snapShotData[_vaultToken]\n\n    # already have snapshot for this time\n    if data.lastSnapShot.lastUpdate == block.timestamp:\n        return False\n\n    # check if snapshot is too recent\n    if data.lastSnapShot.lastUpdate + config.minSnapshotDelay > block.timestamp:\n        return False\n\n    # create and store new snapshot\n    newSnapshot: ls.SingleSnapShot = self._getLatestSnapshot(_vaultToken, _pricePerShare, _vaultTokenDecimals, data.lastSnapShot, config)\n    data.lastSnapShot = newSnapshot\n    self.snapShots[_vaultToken][data.nextIndex] = newSnapshot\n\n    # update index\n    data.nextIndex += 1\n    if data.nextIndex >= config.maxNumSnapshots:\n        data.nextIndex = 0\n\n    # save snap shot data\n    self.snapShotData[_vaultToken] = data\n\n    # update cached weighted average price per share\n    lastAveragePricePerShare: uint256 = self._getWeightedPricePerShare(_vaultToken, _pricePerShare)\n    self.vaultToAsset[_vaultToken].lastAveragePricePerShare = lastAveragePricePerShare\n\n    log PricePerShareSnapShotAdded(\n        vaultToken = _vaultToken,\n        totalSupply = newSnapshot.totalSupply,\n        pricePerShare = newSnapshot.pricePerShare,\n        lastAveragePricePerShare = lastAveragePricePerShare,\n    )\n    return True\n\n\n# weighted price per share\n\n\n@view\n@external\ndef getWeightedPricePerShare(_vaultToken: address) -> uint256:\n    data: ls.SnapShotData = self.snapShotData[_vaultToken]\n    return self._getWeightedPricePerShare(_vaultToken, data.lastSnapShot.pricePerShare)\n\n\n@view\n@internal\ndef _getWeightedPricePerShare(_vaultToken: address, _lastPricePerShare: uint256) -> uint256:\n    config: ls.SnapShotPriceConfig = self.snapShotPriceConfig\n    if config.maxNumSnapshots == 0:\n        return 0\n\n    # calculate weighted average price using all valid snapshots\n    numerator: uint256 = 0\n    denominator: uint256 = 0\n    for i: uint256 in range(config.maxNumSnapshots, bound=max_value(uint256)):\n\n        snapShot: ls.SingleSnapShot = self.snapShots[_vaultToken][i]\n        if snapShot.pricePerShare == 0 or snapShot.totalSupply == 0 or snapShot.lastUpdate == 0:\n            continue\n\n        # too stale, skip\n        if config.staleTime != 0 and block.timestamp > snapShot.lastUpdate + config.staleTime:\n            continue\n\n        numerator += (snapShot.totalSupply * snapShot.pricePerShare)\n        denominator += snapShot.totalSupply\n\n    # weighted price per share\n    weightedPricePerShare: uint256 = 0\n    if numerator != 0:\n        weightedPricePerShare = numerator // denominator\n    else:\n        weightedPricePerShare = _lastPricePerShare\n\n    return weightedPricePerShare\n\n\n# latest snapshot\n\n\n@view\n@external\ndef getLatestSnapshot(_vaultToken: address, _pricePerShare: uint256) -> ls.SingleSnapShot:\n    data: ls.SnapShotData = self.snapShotData[_vaultToken]\n    config: ls.SnapShotPriceConfig = self.snapShotPriceConfig\n    vaultTokenDecimals: uint256 = self.vaultToAsset[_vaultToken].decimals\n    return self._getLatestSnapshot(_vaultToken, _pricePerShare, vaultTokenDecimals, data.lastSnapShot, config)\n\n\n@view\n@internal\ndef _getLatestSnapshot(\n    _vaultToken: address,\n    _pricePerShare: uint256,\n    _vaultTokenDecimals: uint256,\n    _lastSnapShot: ls.SingleSnapShot,\n    _config: ls.SnapShotPriceConfig,\n) -> ls.SingleSnapShot:\n\n    # total supply (adjusted)\n    totalSupply: uint256 = staticcall IERC20(_vaultToken).totalSupply() // (10 ** _vaultTokenDecimals)\n    if totalSupply == 0:\n        totalSupply = 1\n\n    # throttle upside (extra safety check)\n    pricePerShare: uint256 = self._throttleUpside(_pricePerShare, _lastSnapShot.pricePerShare, _config.maxUpsideDeviation)\n\n    return ls.SingleSnapShot(\n        totalSupply = totalSupply,\n        pricePerShare = pricePerShare,\n        lastUpdate = block.timestamp,\n    )\n\n\n@view\n@internal\ndef _throttleUpside(_newValue: uint256, _prevValue: uint256, _maxUpside: uint256) -> uint256:\n    if _maxUpside == 0 or _prevValue == 0 or _newValue == 0:\n        return _newValue\n    maxPricePerShare: uint256 = _prevValue + (_prevValue * _maxUpside // HUNDRED_PERCENT)\n    return min(_newValue, maxPricePerShare)\n\n\n# snapshot price config\n\n\n@external\ndef setSnapShotPriceConfig(_config: ls.SnapShotPriceConfig):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert self._isValidPriceConfig(_config) # dev: invalid config\n    self.snapShotPriceConfig = _config\n    log SnapShotPriceConfigSet(\n        minSnapshotDelay=_config.minSnapshotDelay,\n        maxNumSnapshots=_config.maxNumSnapshots,\n        maxUpsideDeviation=_config.maxUpsideDeviation,\n        staleTime=_config.staleTime\n    )\n\n\n@view\n@external\ndef isValidPriceConfig(_config: ls.SnapShotPriceConfig) -> bool:\n    return self._isValidPriceConfig(_config)\n\n\n@view\n@internal\ndef _isValidPriceConfig(_config: ls.SnapShotPriceConfig) -> bool:\n    if _config.minSnapshotDelay > ONE_WEEK_SECONDS:\n        return False\n    if _config.maxNumSnapshots == 0 or _config.maxNumSnapshots > 25:\n        return False\n    if _config.maxUpsideDeviation > HUNDRED_PERCENT:\n        return False\n    return _config.staleTime < ONE_WEEK_SECONDS",
            "sha256sum": "50440c96dc8a7af22e7ad927bb6d3e308f137d5d3632e633e084b05510c94c28"
          },
          "contracts/legos/yield/SkyPsm.vy": {
            "content": "#     __   __ ___ _______ ___     ______       ___     _______ _______ _______ \n#    |  | |  |   |       |   |   |      |     |   |   |       |       |       |\n#    |  |_|  |   |    ___|   |   |  _    |    |   |   |    ___|    ___|   _   |\n#    |       |   |   |___|   |   | | |   |    |   |   |   |___|   | __|  | |  |\n#    |_     _|   |    ___|   |___| |_|   |    |   |___|    ___|   ||  |  |_|  |\n#      |   | |   |   |___|       |       |    |       |   |___|   |_| |       |\n#      |___| |___|_______|_______|______|     |_______|_______|_______|_______|\n#                                                                       \n#     \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n#     \u2551  ** Sky Psm **                    \u2551\n#     \u2551  Integration with Sky Protocol.   \u2551\n#     \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n#\n#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nimplements: Lego\nimplements: YieldLego\n\nexports: addys.__interface__\nexports: yld.__interface__\n\ninitializes: addys\ninitializes: yld[addys := addys]\n\nfrom interfaces import LegoPartner as Lego\nfrom interfaces import YieldLego as YieldLego\nfrom interfaces import WalletStructs as ws\nfrom interfaces import LegoStructs as ls\n\nimport contracts.modules.Addys as addys\nimport contracts.modules.YieldLegoData as yld\n\nfrom ethereum.ercs import IERC20\nfrom ethereum.ercs import IERC20Detailed\n\ninterface SkyPsm:\n    def swapExactIn(_assetIn: address, _assetOut: address, _amountIn: uint256, _minAmountOut: uint256, _receiver: address, _referralCode: uint256) -> uint256: nonpayable\n    def previewSwapExactIn(_assetIn: address, _assetOut: address, _amountIn: uint256) -> uint256: view\n    def totalAssets() -> uint256: view\n    def susds() -> address: view\n    def usds() -> address: view\n\ninterface Ledger:\n    def setVaultToken(_vaultToken: address, _legoId: uint256, _underlyingAsset: address, _decimals: uint256, _isRebasing: bool): nonpayable\n    def isRegisteredVaultToken(_vaultToken: address) -> bool: view\n    def isUserWallet(_user: address) -> bool: view\n\ninterface Registry:\n    def getRegId(_addr: address) -> uint256: view\n    def isValidAddr(_addr: address) -> bool: view\n\ninterface Appraiser:\n    def getUnderlyingUsdValue(_asset: address, _amount: uint256) -> uint256: view\n\ninterface VaultRegistry:\n    def isEarnVault(_vaultAddr: address) -> bool: view\n\nevent SkyPsmDeposit:\n    sender: indexed(address)\n    asset: indexed(address)\n    vaultToken: indexed(address)\n    assetAmountDeposited: uint256\n    usdValue: uint256\n    vaultTokenAmountReceived: uint256\n    recipient: address\n\nevent SkyPsmWithdrawal:\n    sender: indexed(address)\n    asset: indexed(address)\n    vaultToken: indexed(address)\n    assetAmountReceived: uint256\n    usdValue: uint256\n    vaultTokenAmountBurned: uint256\n    recipient: address\n\nevent SlippageSet:\n    slippage: uint256\n\nslippage: public(uint256)\n\nMAX_TOKEN_PATH: constant(uint256) = 5\nHUNDRED_PERCENT: constant(uint256) = 100_00 # 100.00%\nMAX_PROOFS: constant(uint256) = 25\n\nSKY_PSM: public(immutable(address))\nUSDS: public(immutable(address))\nSUSDS: public(immutable(address))\nRIPE_REGISTRY: public(immutable(address))\n\n\n@deploy\ndef __init__(_undyHq: address, _skyPsm: address, _ripeRegistry: address):\n    addys.__init__(_undyHq)\n    yld.__init__(False)\n\n    self.slippage = 50 # 0.50%\n\n    assert _skyPsm != empty(address) # dev: invalid addrs\n    SKY_PSM = _skyPsm\n    USDS = staticcall SkyPsm(_skyPsm).usds()\n    SUSDS = staticcall SkyPsm(_skyPsm).susds()\n\n    assert _ripeRegistry != empty(address) # dev: invalid addrs\n    RIPE_REGISTRY = _ripeRegistry\n\n\n@view\n@external\ndef hasCapability(_action: ws.ActionType) -> bool:\n    return _action in (\n        ws.ActionType.EARN_DEPOSIT | \n        ws.ActionType.EARN_WITHDRAW\n    )\n\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    return [SKY_PSM]\n\n\n@view\n@external\ndef isYieldLego() -> bool:\n    return True\n\n\n@view\n@external\ndef isDexLego() -> bool:\n    return False\n\n\n###################\n# Underlying Data #\n###################\n\n\n# underlying asset\n\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    return self._getUnderlyingAsset(_vaultToken)\n\n\n@view\n@internal\ndef _getUnderlyingAsset(_vaultToken: address) -> address:\n    asset: address = yld.vaultToAsset[_vaultToken].underlyingAsset\n    if asset != empty(address):\n        return asset\n    if _vaultToken == SUSDS:\n        return USDS\n    return empty(address)\n\n\n# underlying balances (both true and safe)\n\n\n@view\n@external\ndef getUnderlyingBalances(_vaultToken: address, _vaultTokenBalance: uint256) -> (uint256, uint256):\n    if _vaultTokenBalance == 0:\n        return 0, 0\n\n    trueUnderlying: uint256 = self._getUnderlyingAmount(_vaultToken, _vaultTokenBalance)\n    safeUnderlying: uint256 = self._getUnderlyingAmountSafe(_vaultToken, _vaultTokenBalance)\n    if safeUnderlying == 0:\n        safeUnderlying = trueUnderlying\n\n    return trueUnderlying, min(trueUnderlying, safeUnderlying)\n\n\n# underlying amount (true)\n\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    return self._getUnderlyingAmount(_vaultToken, _vaultTokenAmount)\n\n\n@view\n@internal\ndef _getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    asset: address = self._getUnderlyingAsset(_vaultToken)\n    if asset == empty(address):\n        return 0 # invalid vault token\n    return staticcall SkyPsm(SKY_PSM).previewSwapExactIn(_vaultToken, asset, _vaultTokenAmount)\n\n\n# underlying amount (safe)\n\n\n@view\n@external\ndef getUnderlyingAmountSafe(_vaultToken: address, _vaultTokenBalance: uint256) -> uint256:\n    return self._getUnderlyingAmountSafe(_vaultToken, _vaultTokenBalance)\n\n\n@view\n@internal\ndef _getUnderlyingAmountSafe(_vaultToken: address, _vaultTokenBalance: uint256) -> uint256:\n    vaultInfo: ls.VaultTokenInfo = yld.vaultToAsset[_vaultToken]\n    if vaultInfo.decimals == 0:\n        return 0 # not registered\n\n    # safe underlying amount (using cached weighted average from snapshots)\n    return _vaultTokenBalance * vaultInfo.lastAveragePricePerShare // (10 ** vaultInfo.decimals)\n\n\n# underlying data (combined)\n\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> (address, uint256, uint256):\n    return self._getUnderlyingData(_vaultToken, _vaultTokenAmount, _appraiser)\n\n\n@view\n@internal\ndef _getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address) -> (address, uint256, uint256):\n    asset: address = self._getUnderlyingAsset(_vaultToken)\n    if asset == empty(address):\n        return empty(address), 0, 0 # invalid vault token\n    underlyingAmount: uint256 = self._getUnderlyingAmount(_vaultToken, _vaultTokenAmount)\n    usdValue: uint256 = self._getUsdValue(asset, underlyingAmount, _appraiser)\n    return asset, underlyingAmount, usdValue\n\n\n# usd value\n\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> uint256:\n    return self._getUsdValueOfVaultToken(_vaultToken, _vaultTokenAmount, _appraiser)\n\n\n@view\n@internal\ndef _getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address) -> uint256:\n    return self._getUnderlyingData(_vaultToken, _vaultTokenAmount, _appraiser)[2]\n\n\n@view\n@internal\ndef _getUsdValue(_asset: address, _amount: uint256, _appraiser: address) -> uint256:\n    appraiser: address = _appraiser\n    if _appraiser == empty(address):\n        appraiser = addys._getAppraiserAddr()\n    return staticcall Appraiser(appraiser).getUnderlyingUsdValue(_asset, _amount)\n\n\n###############\n# Other Utils #\n###############\n\n\n# basics\n\n\n@view\n@external\ndef isRebasing() -> bool:\n    return self._isRebasing()\n\n\n@view\n@internal\ndef _isRebasing() -> bool:\n    return False\n\n\n# price per share\n\n\n@view\n@external\ndef getPricePerShare(_vaultToken: address, _decimals: uint256 = 0) -> uint256:\n    decimals: uint256 = _decimals\n    if decimals == 0:\n        decimals = yld.vaultToAsset[_vaultToken].decimals\n    if decimals == 0:\n        decimals = convert(staticcall IERC20Detailed(_vaultToken).decimals(), uint256)\n    return self._getPricePerShare(_vaultToken, decimals)\n\n\n@view\n@internal\ndef _getPricePerShare(_vaultToken: address, _decimals: uint256) -> uint256:\n    return staticcall SkyPsm(SKY_PSM).previewSwapExactIn(_vaultToken, USDS, 10 ** _decimals)\n\n\n# vault token amount\n\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    return staticcall SkyPsm(SKY_PSM).previewSwapExactIn(_asset, _vaultToken, _assetAmount)\n\n\n# total assets\n\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    return staticcall SkyPsm(SKY_PSM).totalAssets()\n\n\n# total borrows\n\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    # PSM has no borrowing mechanism - it's a pure liquidity pool\n    return 0\n\n\n# avail liquidity\n\n\n@view\n@external\ndef getAvailLiquidity(_vaultToken: address) -> uint256:\n    # all liquidity is always available in PSM (no borrows/locks)\n    return staticcall SkyPsm(SKY_PSM).totalAssets()\n\n\n# utilization\n\n\n@view\n@external\ndef getUtilizationRatio(_vaultToken: address) -> uint256:\n    # 0% utilization since PSM has no borrowing\n    return 0\n\n\n# extras\n\n\n@view\n@external\ndef isEligibleForYieldBonus(_asset: address) -> bool:\n    return False\n\n\n@view\n@external\ndef getWithdrawalFees(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    return 0\n\n\n################\n# Registration #\n################\n\n\n# can vault be registered\n\n\n@view\n@external\ndef canRegisterVaultToken(_asset: address, _vaultToken: address) -> bool:\n    return self._canRegisterVaultToken(_asset, _vaultToken)\n\n\n@view\n@internal\ndef _canRegisterVaultToken(_asset: address, _vaultToken: address) -> bool:\n    if empty(address) in [_asset, _vaultToken]:\n        return False\n    return _asset == USDS and _vaultToken == SUSDS\n\n\n# register vault token locally\n\n\n@external\ndef registerVaultTokenLocally(_asset: address, _vaultAddr: address) -> ls.VaultTokenInfo:\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert self._canRegisterVaultToken(_asset, _vaultAddr) # dev: cannot register vault token\n    assert not yld._isAssetOpportunity(_asset, _vaultAddr) # dev: already registered\n    vaultInfo: ls.VaultTokenInfo = self._registerVaultTokenLocally(_asset, _vaultAddr)\n    self._registerVaultTokenGlobally(_asset, _vaultAddr, vaultInfo.decimals, addys._getLedgerAddr(), addys._getLegoBookAddr())\n    return vaultInfo\n\n\n@internal\ndef _registerVaultTokenLocally(_asset: address, _vaultAddr: address) -> ls.VaultTokenInfo:\n    skyPsm: address = SKY_PSM\n    assert extcall IERC20(_asset).approve(skyPsm, max_value(uint256), default_return_value=True) # dev: max approval failed\n    assert extcall IERC20(_vaultAddr).approve(skyPsm, max_value(uint256), default_return_value=True) # dev: max approval failed\n    vaultInfo: ls.VaultTokenInfo = yld._addAssetOpportunity(_asset, _vaultAddr)\n    assert vaultInfo.decimals != 0 # dev: invalid vault token\n    return vaultInfo\n\n\n# remove vault token locally\n\n\n@external\ndef deregisterVaultTokenLocally(_asset: address, _vaultAddr: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert yld._isAssetOpportunity(_asset, _vaultAddr) # dev: already registered\n    self._deregisterVaultTokenLocally(_asset, _vaultAddr)\n\n\n@internal\ndef _deregisterVaultTokenLocally(_asset: address, _vaultAddr: address):\n    skyPsm: address = SKY_PSM\n    assert extcall IERC20(_asset).approve(skyPsm, 0, default_return_value=True) # dev: max approval failed\n    assert extcall IERC20(_vaultAddr).approve(skyPsm, 0, default_return_value=True) # dev: max approval failed\n    yld._removeAssetOpportunity(_asset, _vaultAddr)\n\n\n# ledger registration\n\n\n@internal\ndef _registerVaultTokenGlobally(_underlyingAsset: address, _vaultToken: address, _decimals: uint256, _ledger: address, _legoBook: address):\n    if not staticcall Ledger(_ledger).isRegisteredVaultToken(_vaultToken):\n        legoId: uint256 = staticcall Registry(_legoBook).getRegId(self)\n        extcall Ledger(_ledger).setVaultToken(_vaultToken, legoId, _underlyingAsset, _decimals, self._isRebasing())\n\n\n#################\n# Yield Actions #\n#################\n\n\n# access control\n\n\n@view\n@internal\ndef _isAllowedToPerformAction(_caller: address) -> bool:\n    # NOTE: important to not trust `_miniAddys` here, that's why getting ledger and vault registry from addys\n    if staticcall VaultRegistry(addys._getVaultRegistryAddr()).isEarnVault(_caller):\n        return True\n    if staticcall Ledger(addys._getLedgerAddr()).isUserWallet(_caller):\n        return True\n    return staticcall Registry(RIPE_REGISTRY).isValidAddr(_caller) # Ripe Endaoment is allowed\n\n\n# add price snapshot\n\n\n@external\ndef addPriceSnapshot(_vaultToken: address) -> bool:\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    vaultInfo: ls.VaultTokenInfo = yld.vaultToAsset[_vaultToken]\n    assert vaultInfo.decimals != 0 # dev: not registered\n    pricePerShare: uint256 = self._getPricePerShare(_vaultToken, vaultInfo.decimals)\n    return yld._addPriceSnapshot(_vaultToken, pricePerShare, vaultInfo.decimals)\n\n\n# deposit\n\n\n@external\ndef depositForYield(\n    _asset: address,\n    _amount: uint256,\n    _vaultAddr: address,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, address, uint256, uint256):\n    assert self._isAllowedToPerformAction(msg.sender) # dev: no perms\n    assert not yld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = yld._getMiniAddys(_miniAddys)\n    vaultInfo: ls.VaultTokenInfo = self._getVaultInfoOnDeposit(_asset, _vaultAddr, miniAddys.ledger, miniAddys.legoBook)\n\n    # pre balances\n    preLegoBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n\n    # transfer deposit asset to this contract\n    depositAmount: uint256 = min(_amount, staticcall IERC20(_asset).balanceOf(msg.sender))\n    assert depositAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_asset).transferFrom(msg.sender, self, depositAmount, default_return_value=True) # dev: transfer failed\n\n    # deposit assets into lego partner\n    skyPsm: address = SKY_PSM\n    expectedVaultTokenAmount: uint256 = staticcall SkyPsm(skyPsm).previewSwapExactIn(_asset, _vaultAddr, depositAmount)\n    minAmountOut: uint256 = expectedVaultTokenAmount * (HUNDRED_PERCENT - self.slippage) // HUNDRED_PERCENT\n    vaultTokenAmountReceived: uint256 = extcall SkyPsm(skyPsm).swapExactIn(_asset, _vaultAddr, depositAmount, minAmountOut, _recipient, 0)\n    assert vaultTokenAmountReceived != 0 # dev: no vault tokens received\n\n    # refund if full deposit didn't get through\n    currentLegoBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    refundAssetAmount: uint256 = 0\n    if currentLegoBalance > preLegoBalance:\n        refundAssetAmount = currentLegoBalance - preLegoBalance\n        assert extcall IERC20(_asset).transfer(msg.sender, refundAssetAmount, default_return_value=True) # dev: transfer failed\n        depositAmount -= refundAssetAmount\n\n    usdValue: uint256 = staticcall Appraiser(miniAddys.appraiser).getUnderlyingUsdValue(_asset, depositAmount)\n    log SkyPsmDeposit(\n        sender = msg.sender,\n        asset = _asset,\n        vaultToken = _vaultAddr,\n        assetAmountDeposited = depositAmount,\n        usdValue = usdValue,\n        vaultTokenAmountReceived = vaultTokenAmountReceived,\n        recipient = _recipient,\n    )\n\n    # add price snapshot\n    pricePerShare: uint256 = self._getPricePerShare(_vaultAddr, vaultInfo.decimals)\n    yld._addPriceSnapshot(_vaultAddr, pricePerShare, vaultInfo.decimals)\n\n    return depositAmount, _vaultAddr, vaultTokenAmountReceived, usdValue\n\n\n# vault info on deposit\n\n\n@internal\ndef _getVaultInfoOnDeposit(_asset: address, _vaultAddr: address, _ledger: address, _legoBook: address) -> ls.VaultTokenInfo:\n    vaultInfo: ls.VaultTokenInfo = yld.vaultToAsset[_vaultAddr]\n    if vaultInfo.decimals == 0:\n        assert self._canRegisterVaultToken(_asset, _vaultAddr) # dev: cannot register vault token\n        vaultInfo = self._registerVaultTokenLocally(_asset, _vaultAddr)\n        self._registerVaultTokenGlobally(_asset, _vaultAddr, vaultInfo.decimals, _ledger, _legoBook)\n    else:\n        assert vaultInfo.underlyingAsset == _asset # dev: asset mismatch\n    return vaultInfo\n\n\n# withdraw\n\n\n@external\ndef withdrawFromYield(\n    _vaultToken: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, address, uint256, uint256):\n    assert self._isAllowedToPerformAction(msg.sender) # dev: no perms\n    assert not yld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = yld._getMiniAddys(_miniAddys)\n    vaultInfo: ls.VaultTokenInfo = self._getVaultInfoOnWithdrawal(_vaultToken, miniAddys.ledger, miniAddys.legoBook)\n\n    # pre balances\n    preLegoVaultBalance: uint256 = staticcall IERC20(_vaultToken).balanceOf(self)\n\n    # transfer vaults tokens to this contract\n    vaultTokenAmount: uint256 = min(_amount, staticcall IERC20(_vaultToken).balanceOf(msg.sender))\n    assert vaultTokenAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_vaultToken).transferFrom(msg.sender, self, vaultTokenAmount, default_return_value=True) # dev: transfer failed\n\n    # withdraw assets from lego partner\n    skyPsm: address = SKY_PSM\n    expectedAssetAmount: uint256 = staticcall SkyPsm(skyPsm).previewSwapExactIn(_vaultToken, vaultInfo.underlyingAsset, vaultTokenAmount)\n    minAmountOut: uint256 = expectedAssetAmount * (HUNDRED_PERCENT - self.slippage) // HUNDRED_PERCENT\n    assetAmountReceived: uint256 = extcall SkyPsm(skyPsm).swapExactIn(_vaultToken, vaultInfo.underlyingAsset, vaultTokenAmount, minAmountOut, _recipient, 0)\n    assert assetAmountReceived != 0 # dev: no asset amount received\n\n    # refund if full withdrawal didn't happen\n    currentLegoVaultBalance: uint256 = staticcall IERC20(_vaultToken).balanceOf(self)\n    refundVaultTokenAmount: uint256 = 0\n    if currentLegoVaultBalance > preLegoVaultBalance:\n        refundVaultTokenAmount = currentLegoVaultBalance - preLegoVaultBalance\n        assert extcall IERC20(_vaultToken).transfer(msg.sender, refundVaultTokenAmount, default_return_value=True) # dev: transfer failed\n        vaultTokenAmount -= refundVaultTokenAmount\n\n    usdValue: uint256 = staticcall Appraiser(miniAddys.appraiser).getUnderlyingUsdValue(vaultInfo.underlyingAsset, assetAmountReceived)\n    log SkyPsmWithdrawal(\n        sender = msg.sender,\n        asset = vaultInfo.underlyingAsset,\n        vaultToken = _vaultToken,\n        assetAmountReceived = assetAmountReceived,\n        usdValue = usdValue,\n        vaultTokenAmountBurned = vaultTokenAmount,\n        recipient = _recipient,\n    )\n\n    # add price snapshot\n    pricePerShare: uint256 = self._getPricePerShare(_vaultToken, vaultInfo.decimals)\n    yld._addPriceSnapshot(_vaultToken, pricePerShare, vaultInfo.decimals)\n\n    return vaultTokenAmount, vaultInfo.underlyingAsset, assetAmountReceived, usdValue\n\n\n# vault info on withdrawal\n\n\n@internal\ndef _getVaultInfoOnWithdrawal(_vaultAddr: address, _ledger: address, _legoBook: address) -> ls.VaultTokenInfo:\n    vaultInfo: ls.VaultTokenInfo = yld.vaultToAsset[_vaultAddr]\n    if vaultInfo.decimals == 0:\n        asset: address = USDS\n        assert self._canRegisterVaultToken(asset, _vaultAddr) # dev: cannot register vault token\n        vaultInfo = self._registerVaultTokenLocally(asset, _vaultAddr)\n        self._registerVaultTokenGlobally(asset, _vaultAddr, vaultInfo.decimals, _ledger, _legoBook)\n    return vaultInfo\n\n\n# set slippage\n\n\n@external\ndef setSlippage(_slippage: uint256) -> bool:\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert _slippage != 0 and _slippage < HUNDRED_PERCENT # dev: invalid slippage\n    self.slippage = _slippage\n    log SlippageSet(slippage=_slippage)\n    return True\n\n\n#########\n# Other #\n#########\n\n\n@view\n@external\ndef getAccessForLego(_user: address, _action: ws.ActionType) -> (address, String[64], uint256):\n    return empty(address), empty(String[64]), 0\n\n\n@external\ndef claimRewards(\n    _user: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _extraData: bytes32,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    # backwards compatibility\n    return 0, 0\n\n\n@external\ndef claimIncentives(\n    _user: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _proofs: DynArray[bytes32, MAX_PROOFS],\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@view\n@external\ndef hasClaimableRewards(_user: address) -> bool:\n    return False\n\n\n@external\ndef swapTokens(\n    _amountIn: uint256,\n    _minAmountOut: uint256,\n    _tokenPath: DynArray[address, MAX_TOKEN_PATH],\n    _poolPath: DynArray[address, MAX_TOKEN_PATH - 1],\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256):\n    return 0, 0, 0\n\n\n@external\ndef mintOrRedeemAsset(\n    _tokenIn: address,\n    _tokenOut: address,\n    _tokenInAmount: uint256,\n    _minAmountOut: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, bool, uint256):\n    return 0, 0, False, 0\n\n\n@external\ndef confirmMintOrRedeemAsset(\n    _tokenIn: address,\n    _tokenOut: address,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef addCollateral(\n    _asset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef removeCollateral(\n    _asset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef borrow(\n    _borrowAsset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef repayDebt(\n    _paymentAsset: address,\n    _paymentAmount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef addLiquidity(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _amountA: uint256,\n    _amountB: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _minLpAmount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (address, uint256, uint256, uint256, uint256):\n    return empty(address), 0, 0, 0, 0\n\n\n@external\ndef removeLiquidity(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpToken: address,\n    _lpAmount: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, uint256):\n    return 0, 0, 0, 0\n\n\n@external\ndef addLiquidityConcentrated(\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _tickLower: int24,\n    _tickUpper: int24,\n    _amountA: uint256,\n    _amountB: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, uint256, uint256):\n    return 0, 0, 0, 0, 0\n\n\n@external\ndef removeLiquidityConcentrated(\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _liqToRemove: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, bool, uint256):\n    return 0, 0, 0, False, 0",
            "sha256sum": "66768136d6e3bfa42a323b831bc00ef5503c27444030f08814de1e30b431ba8d"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/legos/yield/SkyPsm.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.3+commit.bff19ea2",
        "integrity": "9f08667430d1fc6683b30ccf921180744c0d0541b01c574e98ac853e0970326f"
      },
      "args": "00000000000000000000000044cf3c4f000dfd76a35d03298049d37be688d6f90000000000000000000000001601843c5e9bc251a3272907010afa41fa18347e0000000000000000000000006162df1b329e157479f8f1407e888260e0ec3d2b",
      "file": "contracts/legos/yield/SkyPsm.vy"
    },
    "LegoTools": {
      "address": "0xef443Aaa7981166948cEd9499bD69E3C0E19003f",
      "abi": [
        {
          "name": "DepartmentPauseModified",
          "inputs": [
            {
              "name": "isPaused",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "DepartmentFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "balance",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddys",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "undyToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "hatchery",
                  "type": "address"
                },
                {
                  "name": "lootDistributor",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                },
                {
                  "name": "walletBackpack",
                  "type": "address"
                },
                {
                  "name": "billing",
                  "type": "address"
                },
                {
                  "name": "vaultRegistry",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUndyHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canMintUndy",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pause",
          "inputs": [
            {
              "name": "_shouldPause",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFundsMany",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_assets",
              "type": "address[]"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isPaused",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "aaveV3",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "aaveV3Id",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "compoundV3",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "compoundV3Id",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "euler",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "eulerId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "fluid",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "fluidId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "moonwell",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "moonwellId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "morpho",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "morphoId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "uniswapV2",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "uniswapV2Id",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "uniswapV3",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "uniswapV3Id",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "aerodrome",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "aerodromeId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "aerodromeSlipstream",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "aerodromeSlipstreamId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "curve",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "curveId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAsset",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAsset",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_legoBook",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingForUser",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingForUser",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_legoBook",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getVaultTokensForUser",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple[]",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "vaultToken",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getVaultTokensForUser",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_legoBook",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple[]",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "vaultToken",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_legoBook",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getVaultTokenAmount",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_assetAmount",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getVaultTokenAmount",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_assetAmount",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_legoBook",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLegoInfoFromVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "string"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLegoInfoFromVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_legoBook",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "string"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingData",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "amount",
                  "type": "uint256"
                },
                {
                  "name": "usdValue",
                  "type": "uint256"
                },
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "legoAddr",
                  "type": "address"
                },
                {
                  "name": "legoDesc",
                  "type": "string"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingData",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_legoBook",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "amount",
                  "type": "uint256"
                },
                {
                  "name": "usdValue",
                  "type": "uint256"
                },
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "legoAddr",
                  "type": "address"
                },
                {
                  "name": "legoDesc",
                  "type": "string"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getRoutesAndSwapInstructionsAmountOut",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_slippage",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple[]",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "minAmountOut",
                  "type": "uint256"
                },
                {
                  "name": "tokenPath",
                  "type": "address[]"
                },
                {
                  "name": "poolPath",
                  "type": "address[]"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getRoutesAndSwapInstructionsAmountOut",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_slippage",
              "type": "uint256"
            },
            {
              "name": "_includeLegoIds",
              "type": "uint256[]"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple[]",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "minAmountOut",
                  "type": "uint256"
                },
                {
                  "name": "tokenPath",
                  "type": "address[]"
                },
                {
                  "name": "poolPath",
                  "type": "address[]"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getRoutesAndSwapInstructionsAmountIn",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountOut",
              "type": "uint256"
            },
            {
              "name": "_amountInAvailable",
              "type": "uint256"
            },
            {
              "name": "_slippage",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple[]",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "minAmountOut",
                  "type": "uint256"
                },
                {
                  "name": "tokenPath",
                  "type": "address[]"
                },
                {
                  "name": "poolPath",
                  "type": "address[]"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getRoutesAndSwapInstructionsAmountIn",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountOut",
              "type": "uint256"
            },
            {
              "name": "_amountInAvailable",
              "type": "uint256"
            },
            {
              "name": "_slippage",
              "type": "uint256"
            },
            {
              "name": "_includeLegoIds",
              "type": "uint256[]"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple[]",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "minAmountOut",
                  "type": "uint256"
                },
                {
                  "name": "tokenPath",
                  "type": "address[]"
                },
                {
                  "name": "poolPath",
                  "type": "address[]"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "prepareSwapInstructionsAmountOut",
          "inputs": [
            {
              "name": "_slippage",
              "type": "uint256"
            },
            {
              "name": "_routes",
              "type": "tuple[]",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "name": "tokenOut",
                  "type": "address"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "amountOut",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple[]",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "minAmountOut",
                  "type": "uint256"
                },
                {
                  "name": "tokenPath",
                  "type": "address[]"
                },
                {
                  "name": "poolPath",
                  "type": "address[]"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getBestSwapRoutesAmountOut",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountIn",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple[]",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "name": "tokenOut",
                  "type": "address"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "amountOut",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getBestSwapRoutesAmountOut",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_includeLegoIds",
              "type": "uint256[]"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple[]",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "name": "tokenOut",
                  "type": "address"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "amountOut",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getBestSwapAmountOutWithRouterPool",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountIn",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "tuple[]",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "name": "tokenOut",
                  "type": "address"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "amountOut",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getBestSwapAmountOutWithRouterPool",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_includeLegoIds",
              "type": "uint256[]"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "tuple[]",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "name": "tokenOut",
                  "type": "address"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "amountOut",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getBestSwapAmountOutSinglePool",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountIn",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "name": "tokenOut",
                  "type": "address"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "amountOut",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getBestSwapAmountOutSinglePool",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_includeLegoIds",
              "type": "uint256[]"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "name": "tokenOut",
                  "type": "address"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "amountOut",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getSwapAmountOutViaRouterPool",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountIn",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "name": "tokenOut",
                  "type": "address"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "amountOut",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getSwapAmountOutViaRouterPool",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_includeLegoIds",
              "type": "uint256[]"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "name": "tokenOut",
                  "type": "address"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "amountOut",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getBestSwapRoutesAmountIn",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountOut",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple[]",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "name": "tokenOut",
                  "type": "address"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "amountOut",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getBestSwapRoutesAmountIn",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountOut",
              "type": "uint256"
            },
            {
              "name": "_includeLegoIds",
              "type": "uint256[]"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple[]",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "name": "tokenOut",
                  "type": "address"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "amountOut",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getBestSwapAmountInWithRouterPool",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountOut",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "tuple[]",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "name": "tokenOut",
                  "type": "address"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "amountOut",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getBestSwapAmountInWithRouterPool",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountOut",
              "type": "uint256"
            },
            {
              "name": "_includeLegoIds",
              "type": "uint256[]"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "tuple[]",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "name": "tokenOut",
                  "type": "address"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "amountOut",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getBestSwapAmountInSinglePool",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountOut",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "name": "tokenOut",
                  "type": "address"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "amountOut",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getBestSwapAmountInSinglePool",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountOut",
              "type": "uint256"
            },
            {
              "name": "_includeLegoIds",
              "type": "uint256[]"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "name": "tokenOut",
                  "type": "address"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "amountOut",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getSwapAmountInViaRouterPool",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountOut",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "name": "tokenOut",
                  "type": "address"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "amountOut",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getSwapAmountInViaRouterPool",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountOut",
              "type": "uint256"
            },
            {
              "name": "_includeLegoIds",
              "type": "uint256[]"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "name": "tokenOut",
                  "type": "address"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "amountOut",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ROUTER_TOKENA",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ROUTER_TOKENB",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "AAVE_V3_ID",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "COMPOUND_V3_ID",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "EULER_ID",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "FLUID_ID",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MOONWELL_ID",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MORPHO_ID",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "UNISWAP_V2_ID",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "UNISWAP_V3_ID",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "AERODROME_ID",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "AERODROME_SLIPSTREAM_ID",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "CURVE_ID",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_undyHq",
              "type": "address"
            },
            {
              "name": "_routerTokenA",
              "type": "address"
            },
            {
              "name": "_routerTokenB",
              "type": "address"
            },
            {
              "name": "_aaveV3Id",
              "type": "uint256"
            },
            {
              "name": "_compoundV3Id",
              "type": "uint256"
            },
            {
              "name": "_eulerId",
              "type": "uint256"
            },
            {
              "name": "_fluidId",
              "type": "uint256"
            },
            {
              "name": "_moonwellId",
              "type": "uint256"
            },
            {
              "name": "_morphoId",
              "type": "uint256"
            },
            {
              "name": "_uniswapV2Id",
              "type": "uint256"
            },
            {
              "name": "_uniswapV3Id",
              "type": "uint256"
            },
            {
              "name": "_aerodromeId",
              "type": "uint256"
            },
            {
              "name": "_aerodromeSlipstreamId",
              "type": "uint256"
            },
            {
              "name": "_curveId",
              "type": "uint256"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "interfaces/WalletStructs.vyi": {
            "content": "# @version 0.4.3\n\nflag ActionType:\n    TRANSFER\n    EARN_DEPOSIT\n    EARN_WITHDRAW\n    EARN_REBALANCE\n    SWAP\n    MINT_REDEEM\n    CONFIRM_MINT_REDEEM\n    ADD_COLLATERAL\n    REMOVE_COLLATERAL\n    BORROW\n    REPAY_DEBT\n    REWARDS\n    ETH_TO_WETH\n    WETH_TO_ETH\n    ADD_LIQ\n    REMOVE_LIQ\n    ADD_LIQ_CONC\n    REMOVE_LIQ_CONC\n    PAY_CHEQUE\n\nstruct WalletAssetData:\n    assetBalance: uint256\n    usdValue: uint256\n    isYieldAsset: bool\n    lastPricePerShare: uint256\n\nstruct ActionData:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    billing: address\n    vaultRegistry: address\n    wallet: address\n    walletConfig: address\n    walletOwner: address\n    inEjectMode: bool\n    isFrozen: bool\n    lastTotalUsdValue: uint256\n    signer: address\n    isManager: bool\n    legoId: uint256\n    legoAddr: address\n    eth: address\n    weth: address\n\nstruct MiniAddys:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    appraiser: address",
            "sha256sum": "466493c129135c95470aaf70eeddc936632f7b0f813396e5a7ddc03bea9da518"
          },
          "interfaces/LegoPartner.vyi": {
            "content": "# @version 0.4.3\n\nfrom interfaces import WalletStructs as ws\n\nMAX_TOKEN_PATH: constant(uint256) = 5\nMAX_RECOVER_ASSETS: constant(uint256) = 20\nMAX_PROOFS: constant(uint256) = 25\n\n@external\ndef addLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _tickLower: int24, _tickUpper: int24, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef addLiquidity(_pool: address, _tokenA: address, _tokenB: address, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _minLpAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (address, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef removeLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _liqToRemove: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef removeLiquidity(_pool: address, _tokenA: address, _tokenB: address, _lpToken: address, _lpAmount: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef mintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _tokenInAmount: uint256, _minAmountOut: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef swapTokens(_amountIn: uint256, _minAmountOut: uint256, _tokenPath: DynArray[address, MAX_TOKEN_PATH], _poolPath: DynArray[address, MAX_TOKEN_PATH - 1], _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256):\n    ...\n\n@external\ndef depositForYield(_asset: address, _amount: uint256, _vaultAddr: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef withdrawFromYield(_vaultToken: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef confirmMintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef borrow(_borrowAsset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef repayDebt(_paymentAsset: address, _paymentAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef claimIncentives(_user: address, _rewardToken: address, _rewardAmount: uint256, _proofs: DynArray[bytes32, MAX_PROOFS], _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef removeCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef addCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@view\n@external\ndef getAccessForLego(_user: address, _action: ws.ActionType) -> (address, String[64], uint256):\n    ...\n\n@view\n@external\ndef hasCapability(_action: ws.ActionType) -> bool:\n    ...\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    ...\n\n@view\n@external\ndef isYieldLego() -> bool:\n    ...\n\n@view\n@external\ndef isDexLego() -> bool:\n    ...\n\n\n# common\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "f2afb7bd72d4301aea77bbe4177b7ae954ba6f6b76af363965993eb92ad0b715"
          },
          "interfaces/LegoStructs.vyi": {
            "content": "# @version 0.4.3\n\nstruct VaultTokenInfo:\n    underlyingAsset: address\n    decimals: uint256\n    lastAveragePricePerShare: uint256\n\nstruct SnapShotPriceConfig:\n    minSnapshotDelay: uint256\n    maxNumSnapshots: uint256\n    maxUpsideDeviation: uint256\n    staleTime: uint256\n\nstruct SingleSnapShot:\n    totalSupply: uint256\n    pricePerShare: uint256\n    lastUpdate: uint256\n\nstruct SnapShotData:\n    lastSnapShot: SingleSnapShot\n    nextIndex: uint256\n",
            "sha256sum": "8ae48be17d812d57fbd671bbf0593e8abf175ad0924e47c5997823cac19ec806"
          },
          "interfaces/YieldLego.vyi": {
            "content": "# @version 0.4.3\n\nfrom interfaces import LegoStructs as ls\n\n\n###################\n# Underlying Data #\n###################\n\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    ...\n\n\n@view\n@external\ndef getUnderlyingBalances(_vaultToken: address, _vaultTokenBalance: uint256) -> (uint256, uint256):\n    ...\n\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    ...\n\n\n@view\n@external\ndef getUnderlyingAmountSafe(_vaultToken: address, _vaultTokenBalance: uint256) -> uint256:\n    ...\n\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> (address, uint256, uint256):\n    ...\n\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> uint256:\n    ...\n\n\n###############\n# Other Utils #\n###############\n\n\n@view\n@external\ndef isRebasing() -> bool:\n    ...\n\n\n@view\n@external\ndef getPricePerShare(_vaultToken: address, _decimals: uint256 = 0) -> uint256:\n    ...\n\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef canRegisterVaultToken(_asset: address, _vaultToken: address) -> bool:\n    ...\n\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef getUtilizationRatio(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef getAvailLiquidity(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef isEligibleForYieldBonus(_asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef getWithdrawalFees(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    ...\n\n\n###################\n# Yield Lego Data #\n###################\n\n\n@view\n@external\ndef isLegoAsset(_asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, 40]:\n    ...\n\n\n@view\n@external\ndef getAssets() -> DynArray[address, 20]:\n    ...\n\n\n@view\n@external\ndef isAssetOpportunity(_asset: address, _vaultAddr: address) -> bool:\n    ...\n\n\n@view\n@external\ndef getNumLegoAssets() -> uint256:\n    ...\n\n\n@view\n@external\ndef assets(_index: uint256) -> address:\n    ...\n\n\n@view\n@external\ndef indexOfAsset(_asset: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef numAssets() -> uint256:\n    ...\n\n\n@view\n@external\ndef assetOpportunities(_asset: address, _index: uint256) -> address:\n    ...\n\n\n@view\n@external\ndef indexOfAssetOpportunity(_asset: address, _vaultAddr: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef numAssetOpportunities(_asset: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef vaultToAsset(_vaultAddr: address) -> ls.VaultTokenInfo:\n    ...\n\n\n# price snapshots\n\n\n@external\ndef addPriceSnapshot(_vaultToken: address) -> bool:\n    ...\n\n\n@view\n@external\ndef snapShotPriceConfig() -> ls.SnapShotPriceConfig:\n    ...\n\n\n@view\n@external\ndef snapShotData(_vaultToken: address) -> ls.SnapShotData:\n    ...\n\n\n@view\n@external\ndef snapShots(_vaultToken: address, _index: uint256) -> ls.SingleSnapShot:\n    ...\n\n\n@view\n@external\ndef getWeightedPricePerShare(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef getLatestSnapshot(_vaultToken: address, _pricePerShare: uint256) -> ls.SingleSnapShot:\n    ...\n\n\n@external\ndef setSnapShotPriceConfig(_config: ls.SnapShotPriceConfig):\n    ...\n",
            "sha256sum": "db91c139f6018f5218b389d08c8703bc16fb994aa948805dbfea27e072f382ec"
          },
          "interfaces/DexLego.vyi": {
            "content": "# @version 0.4.3\n\n# used in smart contracts\n\n\n@view\n@external\ndef getLpToken(_pool: address) -> address:\n    ...\n\n\n# helper functions for server\n\n\n@view\n@external\ndef getPoolForLpToken(_lpToken: address) -> address:\n    ...\n\n\n@view\n@external\ndef getSwapAmountOut(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n) -> uint256:\n    ...\n\n\n@view\n@external\ndef getSwapAmountIn(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountOut: uint256,\n) -> uint256:\n    ...\n\n\n@view\n@external\ndef getAddLiqAmountsIn(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _availAmountA: uint256,\n    _availAmountB: uint256,\n) -> (uint256, uint256, uint256):\n    ...\n\n\n@view\n@external\ndef getRemoveLiqAmountsOut(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpAmount: uint256,\n) -> (uint256, uint256):\n    ...\n\n\n@view\n@external\ndef getPriceUnsafe(_pool: address, _targetToken: address, _appraiser: address = empty(address)) -> uint256:\n    ...\n\n\n@view\n@external\ndef getBestSwapAmountOut(_tokenIn: address, _tokenOut: address, _amountIn: uint256) -> (address, uint256):\n    ...\n\n\n@view\n@external\ndef getBestSwapAmountIn(_tokenIn: address, _tokenOut: address, _amountOut: uint256) -> (address, uint256):\n    ...\n\n\n@view\n@external\ndef getCoreRouterPool() -> address:\n    ...\n\n\n@view\n@external\ndef getPrice(_asset: address, _decimals: uint256) -> uint256:\n    ...\n",
            "sha256sum": "6248ad46926f00481cb3469bfc7af8fe36669c2ca0dd98e9a0befdda0fc43fd7"
          },
          "interfaces/Department.vyi": {
            "content": "# @version 0.4.3\n\n\n###########\n# Minting #\n###########\n\n\n@view\n@external\ndef canMintUndy() -> bool:\n    # used in UndyHq.vy\n    ...\n\n\n########\n# Undy #\n########\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "53e48da591c4ee36045a8950c9d3a01458456b471b797df536e9a9f54404e721"
          },
          "contracts/modules/Addys.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\ninterface UndyHq:\n    def isValidAddr(_addr: address) -> bool: view\n    def getAddr(_regId: uint256) -> address: view\n    def undyToken() -> address: view\n\ninterface Switchboard:\n    def isSwitchboardAddr(_addr: address) -> bool: view\n\ninterface LegoBook:\n    def isLegoAddr(_addr: address) -> bool: view\n\nstruct Addys:\n    hq: address\n    undyToken: address\n    ledger: address\n    missionControl: address\n    legoBook: address\n    switchboard: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    walletBackpack: address\n    billing: address\n    vaultRegistry: address\n\n# hq\nUNDY_HQ_FOR_ADDYS: immutable(address)\n\n# core addys\nLEDGER_ID: constant(uint256) = 1\nMISSION_CONTROL_ID: constant(uint256) = 2\nLEGO_BOOK_ID: constant(uint256) = 3\nSWITCHBOARD_ID: constant(uint256) = 4\nHATCHERY_ID: constant(uint256) = 5\nLOOT_DISTRIBUTOR_ID: constant(uint256) = 6\nAPPRAISER_ID: constant(uint256) = 7\nWALLET_BACKPACK_ID: constant(uint256) = 8\nBILLING_ID: constant(uint256) = 9\nVAULT_REGISTRY_ID: constant(uint256) = 10\n\n\n@deploy\ndef __init__(_undyHq: address):\n    assert _undyHq != empty(address) # dev: invalid undy hq\n    UNDY_HQ_FOR_ADDYS = _undyHq\n\n\n########\n# Core #\n########\n\n\n@view\n@external\ndef getAddys() -> Addys:\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _getAddys(_addys: Addys = empty(Addys)) -> Addys:\n    if _addys.hq != empty(address):\n        return _addys\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _generateAddys() -> Addys:\n    hq: address = UNDY_HQ_FOR_ADDYS\n    return Addys(\n        hq = hq,\n        undyToken = staticcall UndyHq(hq).undyToken(),\n        ledger = staticcall UndyHq(hq).getAddr(LEDGER_ID),\n        missionControl = staticcall UndyHq(hq).getAddr(MISSION_CONTROL_ID),\n        legoBook = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID),\n        switchboard = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID),\n        hatchery = staticcall UndyHq(hq).getAddr(HATCHERY_ID),\n        lootDistributor = staticcall UndyHq(hq).getAddr(LOOT_DISTRIBUTOR_ID),\n        appraiser = staticcall UndyHq(hq).getAddr(APPRAISER_ID),\n        walletBackpack = staticcall UndyHq(hq).getAddr(WALLET_BACKPACK_ID),\n        billing = staticcall UndyHq(hq).getAddr(BILLING_ID),\n        vaultRegistry = staticcall UndyHq(hq).getAddr(VAULT_REGISTRY_ID),\n    )\n\n\n##########\n# Tokens #\n##########\n\n\n@view\n@internal\ndef _getUndyToken() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).undyToken()\n\n\n###########\n# Helpers #\n###########\n\n\n# undy hq\n\n\n@view\n@external\ndef getUndyHq() -> address:\n    return self._getUndyHq()\n\n\n@view\n@internal\ndef _getUndyHq() -> address:\n    return UNDY_HQ_FOR_ADDYS\n\n\n# utils\n\n\n@view\n@internal\ndef _isValidUndyAddr(_addr: address, _hq: address = empty(address)) -> bool:\n    hq: address = _hq\n    if _hq == empty(address):\n        hq = UNDY_HQ_FOR_ADDYS\n    \n    # core departments\n    if staticcall UndyHq(hq).isValidAddr(_addr):\n        return True\n\n    # lego book\n    legoBook: address = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID)\n    if legoBook != empty(address) and staticcall LegoBook(legoBook).isLegoAddr(_addr):\n        return True\n\n    # switchboard config\n    switchboard: address = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID)\n    if switchboard != empty(address) and staticcall Switchboard(switchboard).isSwitchboardAddr(_addr):\n        return True\n\n    return False\n\n\n@view\n@internal\ndef _isSwitchboardAddr(_addr: address) -> bool:\n    switchboard: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n    if switchboard == empty(address):\n        return False\n    return staticcall Switchboard(switchboard).isSwitchboardAddr(_addr)\n\n\n@view\n@internal\ndef _isLegoBookAddr(_addr: address) -> bool:\n    legoBook: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n    if legoBook == empty(address):\n        return False\n    return staticcall LegoBook(legoBook).isLegoAddr(_addr)\n\n\n###############\n# Departments #\n###############\n\n\n# ledger\n\n\n@view\n@internal\ndef _getLedgerId() -> uint256:\n    return LEDGER_ID\n\n\n@view\n@internal\ndef _getLedgerAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEDGER_ID)\n\n\n# mission control\n\n\n@view\n@internal\ndef _getMissionControlId() -> uint256:\n    return MISSION_CONTROL_ID\n\n\n@view\n@internal\ndef _getMissionControlAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(MISSION_CONTROL_ID)\n\n\n# lego book\n\n\n@view\n@internal\ndef _getLegoBookId() -> uint256:\n    return LEGO_BOOK_ID\n\n\n@view\n@internal\ndef _getLegoBookAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n\n\n# switchboard\n\n\n@view\n@internal\ndef _getSwitchboardId() -> uint256:\n    return SWITCHBOARD_ID\n\n\n@view\n@internal\ndef _getSwitchboardAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n\n\n# hatchery\n\n\n@view\n@internal\ndef _getHatcheryId() -> uint256:\n    return HATCHERY_ID\n\n\n@view\n@internal\ndef _getHatcheryAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(HATCHERY_ID)\n\n\n# loot distributor\n\n\n@view\n@internal\ndef _getLootDistributorId() -> uint256:\n    return LOOT_DISTRIBUTOR_ID\n\n\n@view\n@internal\ndef _getLootDistributorAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LOOT_DISTRIBUTOR_ID)\n\n\n# appraiser\n\n\n@view\n@internal\ndef _getAppraiserId() -> uint256:\n    return APPRAISER_ID\n\n\n@view\n@internal\ndef _getAppraiserAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(APPRAISER_ID)\n\n\n# wallet backpack\n\n\n@view\n@internal\ndef _getWalletBackpackId() -> uint256:\n    return WALLET_BACKPACK_ID\n\n\n@view\n@internal\ndef _getWalletBackpackAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(WALLET_BACKPACK_ID)\n\n\n# billing\n\n\n@view\n@internal\ndef _getBillingId() -> uint256:\n    return BILLING_ID\n\n\n@view\n@internal\ndef _getBillingAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(BILLING_ID)\n\n\n# vault registry\n\n\n@view\n@internal\ndef _getVaultRegistryId() -> uint256:\n    return VAULT_REGISTRY_ID\n\n\n@view\n@internal\ndef _getVaultRegistryAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(VAULT_REGISTRY_ID)",
            "sha256sum": "4df6b72db9bb417d1af81660175be1450cfb7b3575f3d17a5b8a130bff87b781"
          },
          "contracts/modules/DeptBasics.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nuses: addys\nimplements: dept\n\nimport contracts.modules.Addys as addys\nimport interfaces.Department as dept\nfrom ethereum.ercs import IERC20\n\nevent DepartmentPauseModified:\n    isPaused: bool\n\nevent DepartmentFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    balance: uint256\n\nisPaused: public(bool)\n\nCAN_MINT_UNDY: immutable(bool)\nMAX_RECOVER_ASSETS: constant(uint256) = 20\n\n\n@deploy\ndef __init__(_shouldPause: bool, _canMintUndy: bool):\n    self.isPaused = _shouldPause\n    CAN_MINT_UNDY = _canMintUndy\n\n\n###########\n# Minting #\n###########\n\n\n@view\n@external\ndef canMintUndy() -> bool:\n    return CAN_MINT_UNDY\n\n\n########\n# Undy #\n########\n\n\n# activate\n\n\n@external\ndef pause(_shouldPause: bool):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert _shouldPause != self.isPaused # dev: no change\n    self.isPaused = _shouldPause\n    log DepartmentPauseModified(isPaused=_shouldPause)\n\n\n# recover funds\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    self._recoverFunds(_recipient, _asset)\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, MAX_RECOVER_ASSETS]):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    for a: address in _assets:\n        self._recoverFunds(_recipient, a)\n\n\n@internal\ndef _recoverFunds(_recipient: address, _asset: address):\n    assert empty(address) not in [_recipient, _asset] # dev: invalid recipient or asset\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    assert balance != 0 # dev: nothing to recover\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log DepartmentFundsRecovered(asset=_asset, recipient=_recipient, balance=balance)\n",
            "sha256sum": "976a50a3807bcf71f3f1c57de5cd7a59fe4e8f27b4d4560e774073962f44d1ac"
          },
          "contracts/legos/LegoTools.vy": {
            "content": "#     __                   _____         _     \n#    |  |   ___ ___ ___   |_   _|___ ___| |___ \n#    |  |__| -_| . | . |    | | | . | . | |_ -|\n#    |_____|___|_  |___|    |_| |___|___|_|___|\n#              |___|                           \n#\n#     \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n#     \u2551  ** Lego Tools **                         \u2551\n#     \u2551  Tools for interacting with the legos.    \u2551\n#     \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n#\n#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nimplements: Department\n\nexports: addys.__interface__\nexports: deptBasics.__interface__\n\ninitializes: addys\ninitializes: deptBasics[addys := addys]\n\nfrom interfaces import LegoPartner\nfrom interfaces import YieldLego\nfrom interfaces import DexLego\nfrom interfaces import Department\n\nimport contracts.modules.Addys as addys\nimport contracts.modules.DeptBasics as deptBasics\nfrom ethereum.ercs import IERC20\n\ninterface LegoDexNonStandard:\n    def getSwapAmountOut(_pool: address, _tokenIn: address, _tokenOut: address, _amountIn: uint256) -> uint256: nonpayable\n    def getSwapAmountIn(_pool: address, _tokenIn: address, _tokenOut: address, _amountOut: uint256) -> uint256: nonpayable\n    def getBestSwapAmountIn(_tokenIn: address, _tokenOut: address, _amountOut: uint256) -> (address, uint256): nonpayable\n    def getBestSwapAmountOut(_tokenIn: address, _tokenOut: address, _amountIn: uint256) -> (address, uint256): nonpayable\n\ninterface Registry:\n    def getAddrInfo(_regId: uint256) -> AddressInfo: view\n    def isValidRegId(_regId: uint256) -> bool: view\n    def getAddr(_regId: uint256) -> address: view\n    def numAddrs() -> uint256: view\n\ninterface Appraiser:\n    def getUsdValue(_asset: address, _amount: uint256, _missionControl: address = empty(address), _legoBook: address = empty(address), _ledger: address = empty(address)) -> uint256: view\n\nstruct AddressInfo:\n    addr: address\n    version: uint256\n    lastModified: uint256\n    description: String[64]\n\nstruct SwapRoute:\n    legoId: uint256\n    pool: address\n    tokenIn: address\n    tokenOut: address\n    amountIn: uint256\n    amountOut: uint256\n\nstruct SwapInstruction:\n    legoId: uint256\n    amountIn: uint256\n    minAmountOut: uint256\n    tokenPath: DynArray[address, MAX_TOKEN_PATH]\n    poolPath: DynArray[address, MAX_TOKEN_PATH - 1]\n\nstruct UnderlyingData:\n    asset: address\n    amount: uint256\n    usdValue: uint256\n    legoId: uint256\n    legoAddr: address\n    legoDesc: String[64]\n\nstruct VaultTokenInfo:\n    legoId: uint256\n    vaultToken: address\n\n# key router tokens\nROUTER_TOKENA: public(immutable(address))\nROUTER_TOKENB: public(immutable(address))\n\n# yield lego ids\nAAVE_V3_ID: public(immutable(uint256))\nCOMPOUND_V3_ID: public(immutable(uint256))\nEULER_ID: public(immutable(uint256))\nFLUID_ID: public(immutable(uint256))\nMOONWELL_ID: public(immutable(uint256))\nMORPHO_ID: public(immutable(uint256))\n\n# dex lego ids\nUNISWAP_V2_ID: public(immutable(uint256))\nUNISWAP_V3_ID: public(immutable(uint256))\nAERODROME_ID: public(immutable(uint256))\nAERODROME_SLIPSTREAM_ID: public(immutable(uint256))\nCURVE_ID: public(immutable(uint256))\n\nMAX_VAULTS_FOR_USER: constant(uint256) = 50\nMAX_VAULTS: constant(uint256) = 40\nMAX_ROUTES: constant(uint256) = 10\nMAX_TOKEN_PATH: constant(uint256) = 5\nMAX_SWAP_INSTRUCTIONS: constant(uint256) = 5\nMAX_LEGOS: constant(uint256) = 10\nHUNDRED_PERCENT: constant(uint256) = 100_00 # 100%\n\n\n@deploy\ndef __init__(\n    _undyHq: address,\n    _routerTokenA: address,\n    _routerTokenB: address,\n    # yield lego ids\n    _aaveV3Id: uint256,\n    _compoundV3Id: uint256,\n    _eulerId: uint256,\n    _fluidId: uint256,\n    _moonwellId: uint256,\n    _morphoId: uint256,\n    # dex lego ids\n    _uniswapV2Id: uint256,\n    _uniswapV3Id: uint256,\n    _aerodromeId: uint256,\n    _aerodromeSlipstreamId: uint256,\n    _curveId: uint256,\n):\n    addys.__init__(_undyHq)\n    deptBasics.__init__(False, False) # no minting\n\n    assert empty(address) not in [_routerTokenA, _routerTokenB] # dev: invalid address\n    ROUTER_TOKENA = _routerTokenA\n    ROUTER_TOKENB = _routerTokenB\n\n    # yield lego ids\n    legoBook: address = addys._getLegoBookAddr()\n    assert staticcall Registry(legoBook).isValidRegId(_aaveV3Id) # dev: invalid id\n    assert staticcall Registry(legoBook).isValidRegId(_compoundV3Id) # dev: invalid id\n    assert staticcall Registry(legoBook).isValidRegId(_eulerId) # dev: invalid id\n    assert staticcall Registry(legoBook).isValidRegId(_fluidId) # dev: invalid id\n    assert staticcall Registry(legoBook).isValidRegId(_moonwellId) # dev: invalid id\n    assert staticcall Registry(legoBook).isValidRegId(_morphoId) # dev: invalid id\n\n    AAVE_V3_ID = _aaveV3Id\n    COMPOUND_V3_ID = _compoundV3Id\n    EULER_ID = _eulerId\n    FLUID_ID = _fluidId\n    MOONWELL_ID = _moonwellId\n    MORPHO_ID = _morphoId\n\n    # dex lego ids\n    assert staticcall Registry(legoBook).isValidRegId(_uniswapV2Id) # dev: invalid id\n    assert staticcall Registry(legoBook).isValidRegId(_uniswapV3Id) # dev: invalid id\n    assert staticcall Registry(legoBook).isValidRegId(_aerodromeId) # dev: invalid id\n    assert staticcall Registry(legoBook).isValidRegId(_aerodromeSlipstreamId) # dev: invalid id\n    assert staticcall Registry(legoBook).isValidRegId(_curveId) # dev: invalid id\n\n    UNISWAP_V2_ID = _uniswapV2Id\n    UNISWAP_V3_ID = _uniswapV3Id\n    AERODROME_ID = _aerodromeId\n    AERODROME_SLIPSTREAM_ID = _aerodromeSlipstreamId\n    CURVE_ID = _curveId\n\n\n###############\n# Yield Legos #\n###############\n\n\n@view\n@external\ndef aaveV3() -> address:\n    return staticcall Registry(addys._getLegoBookAddr()).getAddr(AAVE_V3_ID)\n\n\n@view\n@external\ndef aaveV3Id() -> uint256:\n    return AAVE_V3_ID\n\n\n@view\n@external\ndef compoundV3() -> address:\n    return staticcall Registry(addys._getLegoBookAddr()).getAddr(COMPOUND_V3_ID)\n\n\n@view\n@external\ndef compoundV3Id() -> uint256:\n    return COMPOUND_V3_ID\n\n\n@view\n@external\ndef euler() -> address:\n    return staticcall Registry(addys._getLegoBookAddr()).getAddr(EULER_ID)\n\n\n@view\n@external\ndef eulerId() -> uint256:\n    return EULER_ID\n\n\n@view\n@external\ndef fluid() -> address:\n    return staticcall Registry(addys._getLegoBookAddr()).getAddr(FLUID_ID)\n\n\n@view\n@external\ndef fluidId() -> uint256:\n    return FLUID_ID\n\n\n@view\n@external\ndef moonwell() -> address:\n    return staticcall Registry(addys._getLegoBookAddr()).getAddr(MOONWELL_ID)\n\n\n@view\n@external\ndef moonwellId() -> uint256:\n    return MOONWELL_ID\n\n\n@view\n@external\ndef morpho() -> address:\n    return staticcall Registry(addys._getLegoBookAddr()).getAddr(MORPHO_ID)\n\n\n@view\n@external\ndef morphoId() -> uint256:\n    return MORPHO_ID\n\n\n#############\n# DEX Legos #\n#############\n\n\n@view\n@external\ndef uniswapV2() -> address:\n    return staticcall Registry(addys._getLegoBookAddr()).getAddr(UNISWAP_V2_ID)\n\n\n@view\n@external\ndef uniswapV2Id() -> uint256:\n    return UNISWAP_V2_ID\n\n\n@view\n@external\ndef uniswapV3() -> address:\n    return staticcall Registry(addys._getLegoBookAddr()).getAddr(UNISWAP_V3_ID)\n\n\n@view\n@external\ndef uniswapV3Id() -> uint256:\n    return UNISWAP_V3_ID\n\n\n@view\n@external\ndef aerodrome() -> address:\n    return staticcall Registry(addys._getLegoBookAddr()).getAddr(AERODROME_ID)\n\n\n@view\n@external\ndef aerodromeId() -> uint256:\n    return AERODROME_ID\n\n\n@view\n@external\ndef aerodromeSlipstream() -> address:\n    return staticcall Registry(addys._getLegoBookAddr()).getAddr(AERODROME_SLIPSTREAM_ID)\n\n\n@view\n@external\ndef aerodromeSlipstreamId() -> uint256:\n    return AERODROME_SLIPSTREAM_ID\n\n\n@view\n@external\ndef curve() -> address:\n    return staticcall Registry(addys._getLegoBookAddr()).getAddr(CURVE_ID)\n\n\n@view\n@external\ndef curveId() -> uint256:\n    return CURVE_ID\n\n\n#################\n# Yield Helpers #\n#################\n\n\n# get underlying asset (given a vault token)\n\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address, _legoBook: address = empty(address)) -> address:\n    if _vaultToken == empty(address):\n        return empty(address)\n\n    legoBook: address = _legoBook\n    if _legoBook == empty(address):\n        legoBook = addys._getLegoBookAddr()\n\n    numLegos: uint256 = staticcall Registry(legoBook).numAddrs()\n    if numLegos == 0:\n        return empty(address)\n\n    for i: uint256 in range(1, numLegos, bound=max_value(uint256)):\n        legoAddr: address = staticcall Registry(legoBook).getAddr(i)\n        if not staticcall LegoPartner(legoAddr).isYieldLego():\n            continue\n\n        asset: address = staticcall YieldLego(legoAddr).getUnderlyingAsset(_vaultToken)\n        if asset != empty(address):\n            return asset\n\n    return empty(address)\n\n\n# get underlying amount (given user and underlying asset)\n\n\n@view\n@external\ndef getUnderlyingForUser(_user: address, _asset: address, _legoBook: address = empty(address)) -> uint256:\n    if empty(address) in [_user, _asset]:\n        return 0\n\n    legoBook: address = _legoBook\n    if _legoBook == empty(address):\n        legoBook = addys._getLegoBookAddr()\n\n    numLegos: uint256 = staticcall Registry(legoBook).numAddrs()\n    if numLegos == 0:\n        return 0\n\n    totalDeposited: uint256 = 0\n    for i: uint256 in range(1, numLegos, bound=max_value(uint256)):\n        legoAddr: address = staticcall Registry(legoBook).getAddr(i)\n        if not staticcall LegoPartner(legoAddr).isYieldLego():\n            continue\n\n        legoVaultTokens: DynArray[address, MAX_VAULTS] = staticcall YieldLego(legoAddr).getAssetOpportunities(_asset)\n        if len(legoVaultTokens) == 0:\n            continue\n\n        for vaultToken: address in legoVaultTokens:\n            if vaultToken == empty(address):\n                continue\n            vaultTokenBal: uint256 = staticcall IERC20(vaultToken).balanceOf(_user)\n            if vaultTokenBal != 0:\n                totalDeposited += staticcall YieldLego(legoAddr).getUnderlyingAmount(vaultToken, vaultTokenBal)\n\n    return totalDeposited\n\n\n# get all vault tokens (given user and underlying asset)\n\n\n@view\n@external\ndef getVaultTokensForUser(_user: address, _asset: address, _legoBook: address = empty(address)) -> DynArray[VaultTokenInfo, MAX_VAULTS_FOR_USER]:\n    if empty(address) in [_user, _asset]:\n        return []\n\n    legoBook: address = _legoBook\n    if _legoBook == empty(address):\n        legoBook = addys._getLegoBookAddr()\n\n    numLegos: uint256 = staticcall Registry(legoBook).numAddrs()\n    if numLegos == 0:\n        return []\n\n    vaultTokens: DynArray[VaultTokenInfo, MAX_VAULTS_FOR_USER] = []\n    for i: uint256 in range(1, numLegos, bound=max_value(uint256)):\n        legoAddr: address = staticcall Registry(legoBook).getAddr(i)\n        if not staticcall LegoPartner(legoAddr).isYieldLego():\n            continue\n\n        legoVaultTokens: DynArray[address, MAX_VAULTS] = staticcall YieldLego(legoAddr).getAssetOpportunities(_asset)\n        if len(legoVaultTokens) == 0:\n            continue\n\n        for vaultToken: address in legoVaultTokens:\n            if vaultToken == empty(address):\n                continue\n            if staticcall IERC20(vaultToken).balanceOf(_user) != 0:\n                vaultTokens.append(VaultTokenInfo(\n                    legoId=i,\n                    vaultToken=vaultToken\n                ))\n\n    return vaultTokens\n\n\n# is vault token (given a vault token)\n\n\n@view\n@external\ndef isVaultToken(_vaultToken: address, _legoBook: address = empty(address)) -> bool:\n    if _vaultToken == empty(address):\n        return False\n\n    legoBook: address = _legoBook\n    if _legoBook == empty(address):\n        legoBook = addys._getLegoBookAddr()\n\n    numLegos: uint256 = staticcall Registry(legoBook).numAddrs()\n    if numLegos == 0:\n        return False\n\n    for i: uint256 in range(1, numLegos, bound=max_value(uint256)):\n        legoAddr: address = staticcall Registry(legoBook).getAddr(i)\n        if not staticcall LegoPartner(legoAddr).isYieldLego():\n            continue\n\n        if staticcall YieldLego(legoAddr).isLegoAsset(_vaultToken):\n            return True\n\n    return False\n\n\n# get vault token amount (given an underlying asset, underlying amount, and vault token)\n\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address, _legoBook: address = empty(address)) -> uint256:\n    if _assetAmount == 0 or _asset == empty(address) or _vaultToken == empty(address):\n        return 0\n\n    legoBook: address = _legoBook\n    if _legoBook == empty(address):\n        legoBook = addys._getLegoBookAddr()\n\n    numLegos: uint256 = staticcall Registry(legoBook).numAddrs()\n    if numLegos == 0:\n        return 0\n\n    for i: uint256 in range(1, numLegos, bound=max_value(uint256)):\n        legoAddr: address = staticcall Registry(legoBook).getAddr(i)\n        if not staticcall LegoPartner(legoAddr).isYieldLego():\n            continue\n\n        vaultTokenAmount: uint256 = staticcall YieldLego(legoAddr).getVaultTokenAmount(_asset, _assetAmount, _vaultToken)\n        if vaultTokenAmount != 0:\n            return vaultTokenAmount\n\n    return 0\n\n\n# get lego info (given a vault token)\n\n\n@view\n@external\ndef getLegoInfoFromVaultToken(_vaultToken: address, _legoBook: address = empty(address)) -> (uint256, address, String[64]):\n    if _vaultToken == empty(address):\n        return 0, empty(address), \"\"\n\n    legoBook: address = _legoBook\n    if _legoBook == empty(address):\n        legoBook = addys._getLegoBookAddr()\n\n    numLegos: uint256 = staticcall Registry(legoBook).numAddrs()\n    if numLegos == 0:\n        return 0, empty(address), \"\"\n\n    for i: uint256 in range(1, numLegos, bound=max_value(uint256)):\n        legoInfo: AddressInfo = staticcall Registry(legoBook).getAddrInfo(i)\n        if not staticcall LegoPartner(legoInfo.addr).isYieldLego():\n            continue\n\n        if staticcall YieldLego(legoInfo.addr).isLegoAsset(_vaultToken):\n            return i, legoInfo.addr, legoInfo.description\n\n    return 0, empty(address), \"\"\n\n\n# get underlying data (given an underlying asset, underlying amount)\n\n\n@view\n@external\ndef getUnderlyingData(_asset: address, _amount: uint256, _legoBook: address = empty(address)) -> UnderlyingData:\n    if _amount == 0 or _asset == empty(address):\n        return empty(UnderlyingData)\n\n    legoBook: address = _legoBook\n    if _legoBook == empty(address):\n        legoBook = addys._getLegoBookAddr()\n\n    numLegos: uint256 = staticcall Registry(legoBook).numAddrs()\n    if numLegos == 0:\n        return empty(UnderlyingData)\n\n    appraiser: address = addys._getAppraiserAddr()\n    for i: uint256 in range(1, numLegos, bound=max_value(uint256)):\n        legoInfo: AddressInfo = staticcall Registry(legoBook).getAddrInfo(i)\n        if not staticcall LegoPartner(legoInfo.addr).isYieldLego():\n            continue\n\n        asset: address = empty(address)\n        underlyingAmount: uint256 = 0\n        usdValue: uint256 = 0\n        asset, underlyingAmount, usdValue = staticcall YieldLego(legoInfo.addr).getUnderlyingData(_asset, _amount, appraiser)\n        if asset != empty(address):\n            return UnderlyingData(\n                asset = asset,\n                amount = underlyingAmount,\n                usdValue = usdValue,\n                legoId = i,\n                legoAddr = legoInfo.addr,\n                legoDesc = legoInfo.description,\n            )\n\n    # fallback to appraiser\n    return UnderlyingData(\n        asset = _asset,\n        amount = _amount,\n        usdValue = staticcall Appraiser(appraiser).getUsdValue(_asset, _amount, empty(address), legoBook),\n        legoId = 0,\n        legoAddr = empty(address),\n        legoDesc = \"\",\n    )\n\n\n###############\n# Dex Helpers #\n###############\n\n\n# get routes and swap instructions (amountIn as input)\n\n\n@external\ndef getRoutesAndSwapInstructionsAmountOut(\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n    _slippage: uint256,\n    _includeLegoIds: DynArray[uint256, MAX_LEGOS] = [],\n) -> DynArray[SwapInstruction, MAX_SWAP_INSTRUCTIONS]:\n    routes: DynArray[SwapRoute, MAX_ROUTES] = self._getBestSwapRoutesAmountOut(_tokenIn, _tokenOut, _amountIn, _includeLegoIds)\n    return self._prepareSwapInstructionsAmountOut(_slippage, routes)\n\n\n# get routes and swap instructions (amountOut as input)\n\n\n@external\ndef getRoutesAndSwapInstructionsAmountIn(\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountOut: uint256,\n    _amountInAvailable: uint256,\n    _slippage: uint256,\n    _includeLegoIds: DynArray[uint256, MAX_LEGOS] = [],\n) -> DynArray[SwapInstruction, MAX_SWAP_INSTRUCTIONS]:\n    routes: DynArray[SwapRoute, MAX_ROUTES] = self._getBestSwapRoutesAmountIn(_tokenIn, _tokenOut, _amountOut, _includeLegoIds)\n    if len(routes) == 0:\n        return []\n\n    # let's re-run the routes with amountIn as input (this is more accurate, for example, Aerodrome doesn't have getAmountIn for stable pools\n    amountIn: uint256 = min(_amountInAvailable, routes[0].amountIn)\n    routes = self._getBestSwapRoutesAmountOut(_tokenIn, _tokenOut, amountIn, _includeLegoIds)\n    return self._prepareSwapInstructionsAmountOut(_slippage, routes)\n\n\n########################\n# Dex: Swap Amount Out #\n########################\n\n\n# prepare swap instructions (amountIn as input)\n\n\n@external\ndef prepareSwapInstructionsAmountOut(_slippage: uint256, _routes: DynArray[SwapRoute, MAX_ROUTES]) -> DynArray[SwapInstruction, MAX_SWAP_INSTRUCTIONS]:\n    return self._prepareSwapInstructionsAmountOut(_slippage, _routes)\n\n\n@internal\ndef _prepareSwapInstructionsAmountOut(_slippage: uint256, _routes: DynArray[SwapRoute, MAX_ROUTES]) -> DynArray[SwapInstruction, MAX_SWAP_INSTRUCTIONS]:\n    if len(_routes) == 0:\n        return []\n\n    instructions: DynArray[SwapInstruction, MAX_SWAP_INSTRUCTIONS] = []\n\n    # start with first route\n    prevRoute: SwapRoute = _routes[0]\n    prevInstruction: SwapInstruction = self._createNewInstruction(prevRoute, _slippage)\n\n    # iterate thru swap routes, skip first\n    for i: uint256 in range(1, len(_routes), bound=MAX_ROUTES):\n        newRoute: SwapRoute = _routes[i]\n        assert prevRoute.tokenOut == newRoute.tokenIn # dev: invalid route\n\n        # add to previous instruction\n        if prevRoute.legoId == newRoute.legoId:\n            prevInstruction.minAmountOut = newRoute.amountOut * (HUNDRED_PERCENT - _slippage) // HUNDRED_PERCENT\n            prevInstruction.tokenPath.append(newRoute.tokenOut)\n            prevInstruction.poolPath.append(newRoute.pool)\n\n        # create new instruction\n        else:\n            instructions.append(prevInstruction)\n            prevInstruction = self._createNewInstruction(newRoute, _slippage)\n\n        # set previous item\n        prevRoute = newRoute\n\n    # add last instruction\n    instructions.append(prevInstruction)\n    return instructions\n\n\n@view\n@internal\ndef _createNewInstruction(_route: SwapRoute, _slippage: uint256) -> SwapInstruction:\n    return SwapInstruction(\n        legoId=_route.legoId,\n        amountIn=_route.amountIn,\n        minAmountOut=_route.amountOut * (HUNDRED_PERCENT - _slippage) // HUNDRED_PERCENT,\n        tokenPath=[_route.tokenIn, _route.tokenOut],\n        poolPath=[_route.pool],\n    )\n\n\n# best swap routes (amountIn as input)\n\n\n@external\ndef getBestSwapRoutesAmountOut(\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n    _includeLegoIds: DynArray[uint256, MAX_LEGOS] = [],\n) -> DynArray[SwapRoute, MAX_ROUTES]:\n    return self._getBestSwapRoutesAmountOut(_tokenIn, _tokenOut, _amountIn, _includeLegoIds)\n\n\n@internal\ndef _getBestSwapRoutesAmountOut(\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n    _includeLegoIds: DynArray[uint256, MAX_LEGOS],\n) -> DynArray[SwapRoute, MAX_ROUTES]:\n    if _tokenIn == _tokenOut or _amountIn == 0 or empty(address) in [_tokenIn, _tokenOut]:\n        return []\n\n    bestSwapRoutes: DynArray[SwapRoute, MAX_ROUTES] = []\n\n    # required data\n    legoBook: address = addys._getLegoBookAddr()\n    numLegos: uint256 = staticcall Registry(legoBook).numAddrs()\n    routerTokenA: address = ROUTER_TOKENA\n    routerTokenB: address = ROUTER_TOKENB\n\n    # direct swap route\n    directSwapRoute: SwapRoute = self._getBestSwapAmountOutSinglePool(_tokenIn, _tokenOut, _amountIn, numLegos, legoBook, _includeLegoIds)\n\n    # check with router pools\n    withRouterHopAmountOut: uint256 = 0\n    withHopRoutes: DynArray[SwapRoute, MAX_ROUTES] = []\n    withRouterHopAmountOut, withHopRoutes = self._getBestSwapAmountOutWithRouterPool(routerTokenA, routerTokenB, _tokenIn, _tokenOut, _amountIn, numLegos, legoBook, _includeLegoIds)\n\n    # compare direct swap route with hop routes\n    if directSwapRoute.amountOut > withRouterHopAmountOut:\n        bestSwapRoutes = [directSwapRoute]\n\n    # update router token pool (if possible)\n    elif withRouterHopAmountOut != 0:\n        bestSwapRoutes = withHopRoutes\n\n    return bestSwapRoutes\n\n\n# check various routes via core router pools\n\n\n@external\ndef getBestSwapAmountOutWithRouterPool(\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n    _includeLegoIds: DynArray[uint256, MAX_LEGOS] = [],\n) -> (uint256, DynArray[SwapRoute, MAX_ROUTES]):\n    legoBook: address = addys._getLegoBookAddr()\n    numLegos: uint256 = staticcall Registry(legoBook).numAddrs()\n    return self._getBestSwapAmountOutWithRouterPool(ROUTER_TOKENA, ROUTER_TOKENB, _tokenIn, _tokenOut, _amountIn, numLegos, legoBook, _includeLegoIds)\n\n\n@internal\ndef _getBestSwapAmountOutWithRouterPool(\n    _routerTokenA: address,\n    _routerTokenB: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n    _numLegos: uint256,\n    _legoRegistry: address,\n    _includeLegoIds: DynArray[uint256, MAX_LEGOS],\n) -> (uint256, DynArray[SwapRoute, MAX_ROUTES]):\n\n    # nothing to do, already have router pool to use\n    if self._isRouterPool(_tokenIn, _tokenOut, _routerTokenA, _routerTokenB):\n        return 0, []\n\n    isMultiHop: bool = False\n    finalAmountOut: uint256 = 0\n    bestSwapRoutes: DynArray[SwapRoute, MAX_ROUTES] = []\n    firstRoute: SwapRoute = empty(SwapRoute)\n    secondRoute: SwapRoute = empty(SwapRoute)\n\n    # usdc -> weth -> tokenOut\n    if _tokenIn == _routerTokenA:\n        firstRoute = self._getSwapAmountOutViaRouterPool(_routerTokenA, _routerTokenB, _amountIn, _numLegos, _legoRegistry, _includeLegoIds)\n        if firstRoute.amountOut != 0:\n            secondRoute = self._getBestSwapAmountOutSinglePool(_routerTokenB, _tokenOut, firstRoute.amountOut, _numLegos, _legoRegistry, _includeLegoIds)\n\n    # tokenIn -> weth -> usdc\n    elif _tokenOut == _routerTokenA:\n        firstRoute = self._getBestSwapAmountOutSinglePool(_tokenIn, _routerTokenB, _amountIn, _numLegos, _legoRegistry, _includeLegoIds)\n        if firstRoute.amountOut != 0:\n            secondRoute = self._getSwapAmountOutViaRouterPool(_routerTokenB, _routerTokenA, firstRoute.amountOut, _numLegos, _legoRegistry, _includeLegoIds)\n\n    # weth -> usdc -> tokenOut\n    elif _tokenIn == _routerTokenB:\n        firstRoute = self._getSwapAmountOutViaRouterPool(_routerTokenB, _routerTokenA, _amountIn, _numLegos, _legoRegistry, _includeLegoIds)\n        if firstRoute.amountOut != 0:\n            secondRoute = self._getBestSwapAmountOutSinglePool(_routerTokenA, _tokenOut, firstRoute.amountOut, _numLegos, _legoRegistry, _includeLegoIds)\n\n    # tokenIn -> usdc -> weth\n    elif _tokenOut == _routerTokenB:\n        firstRoute = self._getBestSwapAmountOutSinglePool(_tokenIn, _routerTokenA, _amountIn, _numLegos, _legoRegistry, _includeLegoIds)\n        if firstRoute.amountOut != 0:\n            secondRoute = self._getSwapAmountOutViaRouterPool(_routerTokenA, _routerTokenB, firstRoute.amountOut, _numLegos, _legoRegistry, _includeLegoIds)\n\n    # let's try multi hop routes\n    else:\n        isMultiHop = True\n\n        # router token A as starting point\n        viaRouterTokenAAmountOut: uint256 = 0\n        viaRouterTokenARoutes: DynArray[SwapRoute, MAX_ROUTES] = []\n        viaRouterTokenAAmountOut, viaRouterTokenARoutes = self._checkRouterPoolForMiddleSwapAmountOut(_routerTokenA, _routerTokenB, _tokenIn, _tokenOut, _amountIn, _numLegos, _legoRegistry, _includeLegoIds)\n\n        # router token B as starting point\n        viaRouterTokenBAmountOut: uint256 = 0\n        viaRouterTokenBRoutes: DynArray[SwapRoute, MAX_ROUTES] = []\n        viaRouterTokenBAmountOut, viaRouterTokenBRoutes = self._checkRouterPoolForMiddleSwapAmountOut(_routerTokenB, _routerTokenA, _tokenIn, _tokenOut, _amountIn, _numLegos, _legoRegistry, _includeLegoIds)\n\n        # compare\n        if viaRouterTokenAAmountOut > viaRouterTokenBAmountOut:\n            finalAmountOut = viaRouterTokenAAmountOut\n            bestSwapRoutes = viaRouterTokenARoutes\n        elif viaRouterTokenBAmountOut != 0:\n            finalAmountOut = viaRouterTokenBAmountOut\n            bestSwapRoutes = viaRouterTokenBRoutes\n\n    if not isMultiHop:\n        finalAmountOut = secondRoute.amountOut\n        bestSwapRoutes = [firstRoute, secondRoute]\n\n    return finalAmountOut, bestSwapRoutes\n\n\n@internal\ndef _checkRouterPoolForMiddleSwapAmountOut(\n    _firstRouterTokenHop: address,\n    _secondRouterTokenHop: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n    _numLegos: uint256,\n    _legoRegistry: address,\n    _includeLegoIds: DynArray[uint256, MAX_LEGOS],\n) -> (uint256, DynArray[SwapRoute, MAX_ROUTES]):\n    secondHopToTokenOut: SwapRoute = empty(SwapRoute)\n\n    # tokenIn -> first Router Token\n    tokenInToFirstHop: SwapRoute = self._getBestSwapAmountOutSinglePool(_tokenIn, _firstRouterTokenHop, _amountIn, _numLegos, _legoRegistry, _includeLegoIds)\n    if tokenInToFirstHop.amountOut == 0:\n        return 0, []\n\n    # first Router Token -> tokenOut\n    firstHopToTokenOut: SwapRoute = self._getBestSwapAmountOutSinglePool(_firstRouterTokenHop, _tokenOut, tokenInToFirstHop.amountOut, _numLegos, _legoRegistry, _includeLegoIds)\n\n    # first Router Token -> second Router Token -- this will always happen in router pools (i.e. usdc <-> weth)\n    firstHopToSecondHop: SwapRoute = self._getSwapAmountOutViaRouterPool(_firstRouterTokenHop, _secondRouterTokenHop, tokenInToFirstHop.amountOut, _numLegos, _legoRegistry, _includeLegoIds)\n\n    # second Router Token -> tokenOut\n    if firstHopToSecondHop.amountOut != 0:\n        secondHopToTokenOut = self._getBestSwapAmountOutSinglePool(_secondRouterTokenHop, _tokenOut, firstHopToSecondHop.amountOut, _numLegos, _legoRegistry, _includeLegoIds)\n\n    # compare routes\n    if firstHopToTokenOut.amountOut > secondHopToTokenOut.amountOut:\n        return firstHopToTokenOut.amountOut, [tokenInToFirstHop, firstHopToTokenOut]\n    elif secondHopToTokenOut.amountOut != 0:\n        return secondHopToTokenOut.amountOut, [tokenInToFirstHop, firstHopToSecondHop, secondHopToTokenOut]\n    return 0, []\n\n\n# single pool\n\n\n@external\ndef getBestSwapAmountOutSinglePool(\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n    _includeLegoIds: DynArray[uint256, MAX_LEGOS] = [],\n) -> SwapRoute:\n    legoBook: address = addys._getLegoBookAddr()\n    numLegos: uint256 = staticcall Registry(legoBook).numAddrs()\n    return self._getBestSwapAmountOutSinglePool(_tokenIn, _tokenOut, _amountIn, numLegos, legoBook, _includeLegoIds)\n\n\n@internal\ndef _getBestSwapAmountOutSinglePool(\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n    _numLegos: uint256,\n    _legoRegistry: address,\n    _includeLegoIds: DynArray[uint256, MAX_LEGOS],\n) -> SwapRoute:\n\n    bestRoute: SwapRoute = SwapRoute(\n        legoId=0,\n        pool=empty(address),\n        tokenIn=_tokenIn,\n        tokenOut=_tokenOut,\n        amountIn=_amountIn,\n        amountOut=0,\n    )\n\n    if _numLegos == 0:\n        return bestRoute\n\n    shouldCheckLegoIds: bool = len(_includeLegoIds) != 0\n    for i: uint256 in range(1, _numLegos, bound=max_value(uint256)):\n\n        # skip if we should check lego ids and it's not in the list\n        if shouldCheckLegoIds and i not in _includeLegoIds:\n            continue\n\n        # get lego addr\n        legoAddr: address = staticcall Registry(_legoRegistry).getAddr(i)\n        if not staticcall LegoPartner(legoAddr).isDexLego():\n            continue\n\n        pool: address = empty(address)\n        amountOut: uint256 = 0\n        if i in [UNISWAP_V3_ID, AERODROME_SLIPSTREAM_ID]:\n            pool, amountOut = extcall LegoDexNonStandard(legoAddr).getBestSwapAmountOut(_tokenIn, _tokenOut, _amountIn)\n        else:\n            pool, amountOut = staticcall DexLego(legoAddr).getBestSwapAmountOut(_tokenIn, _tokenOut, _amountIn)\n\n        # compare best\n        if pool != empty(address) and amountOut > bestRoute.amountOut:\n            bestRoute.pool = pool\n            bestRoute.amountOut = amountOut\n            bestRoute.legoId = i\n\n    return bestRoute\n\n\n# router pool only\n\n\n@external\ndef getSwapAmountOutViaRouterPool(\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n    _includeLegoIds: DynArray[uint256, MAX_LEGOS] = [],\n) -> SwapRoute:\n    legoBook: address = addys._getLegoBookAddr()\n    numLegos: uint256 = staticcall Registry(legoBook).numAddrs()\n    return self._getSwapAmountOutViaRouterPool(_tokenIn, _tokenOut, _amountIn, numLegos, legoBook, _includeLegoIds)\n\n\n@internal\ndef _getSwapAmountOutViaRouterPool(\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n    _numLegos: uint256,\n    _legoRegistry: address,\n    _includeLegoIds: DynArray[uint256, MAX_LEGOS],\n) -> SwapRoute:\n\n    # NOTE: _tokenIn and _tokenOut need to be ROUTER_TOKENA/ROUTER_TOKENB -- in the `getCoreRouterPool()` pool\n\n    bestRoute: SwapRoute = SwapRoute(\n        legoId=0,\n        pool=empty(address),\n        tokenIn=_tokenIn,\n        tokenOut=_tokenOut,\n        amountIn=_amountIn,\n        amountOut=0,\n    )\n\n    if _numLegos == 0:\n        return bestRoute\n\n    shouldCheckLegoIds: bool = len(_includeLegoIds) != 0\n    for i: uint256 in range(1, _numLegos, bound=max_value(uint256)):\n\n        # skip if we should check lego ids and it's not in the list\n        if shouldCheckLegoIds and i not in _includeLegoIds:\n            continue\n\n        # get lego addr\n        legoAddr: address = staticcall Registry(_legoRegistry).getAddr(i)\n        if not staticcall LegoPartner(legoAddr).isDexLego():\n            continue\n\n        pool: address = staticcall DexLego(legoAddr).getCoreRouterPool()\n        if pool == empty(address):\n            continue\n\n        amountOut: uint256 = 0\n        if i in [UNISWAP_V3_ID, AERODROME_SLIPSTREAM_ID]:\n            amountOut = extcall LegoDexNonStandard(legoAddr).getSwapAmountOut(pool, _tokenIn, _tokenOut, _amountIn)\n        else:\n            amountOut = staticcall DexLego(legoAddr).getSwapAmountOut(pool, _tokenIn, _tokenOut, _amountIn)\n\n        # compare best\n        if amountOut > bestRoute.amountOut:\n            bestRoute.pool = pool\n            bestRoute.amountOut = amountOut\n            bestRoute.legoId = i\n\n    return bestRoute\n\n\n#######################\n# Dex: Swap Amount In #\n#######################\n\n\n# best swap routes (amountOut as input)\n\n\n@external\ndef getBestSwapRoutesAmountIn(\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountOut: uint256,\n    _includeLegoIds: DynArray[uint256, MAX_LEGOS] = [],\n) -> DynArray[SwapRoute, MAX_ROUTES]:\n    return self._getBestSwapRoutesAmountIn(_tokenIn, _tokenOut, _amountOut, _includeLegoIds)\n\n\n@internal\ndef _getBestSwapRoutesAmountIn(\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountOut: uint256,\n    _includeLegoIds: DynArray[uint256, MAX_LEGOS],\n) -> DynArray[SwapRoute, MAX_ROUTES]:\n    if _tokenIn == _tokenOut or _amountOut == 0 or empty(address) in [_tokenIn, _tokenOut]:\n        return []\n\n    bestSwapRoutes: DynArray[SwapRoute, MAX_ROUTES] = []\n\n    # required data\n    legoBook: address = addys._getLegoBookAddr()\n    numLegos: uint256 = staticcall Registry(legoBook).numAddrs()\n    routerTokenA: address = ROUTER_TOKENA\n    routerTokenB: address = ROUTER_TOKENB\n\n    # direct swap route\n    directSwapRoute: SwapRoute = self._getBestSwapAmountInSinglePool(_tokenIn, _tokenOut, _amountOut, numLegos, legoBook, _includeLegoIds)\n\n    # check with router pools\n    withRouterHopAmountIn: uint256 = 0\n    withHopRoutes: DynArray[SwapRoute, MAX_ROUTES] = []\n    withRouterHopAmountIn, withHopRoutes = self._getBestSwapAmountInWithRouterPool(routerTokenA, routerTokenB, _tokenIn, _tokenOut, _amountOut, numLegos, legoBook, _includeLegoIds)\n\n    # compare direct swap route with hop routes\n    if directSwapRoute.amountIn < withRouterHopAmountIn:\n        bestSwapRoutes = [directSwapRoute]\n\n    # update router token pool (if possible)\n    elif withRouterHopAmountIn != max_value(uint256):\n        bestSwapRoutes = withHopRoutes\n\n    return bestSwapRoutes\n\n\n# check various routes via core router pools\n\n\n@external\ndef getBestSwapAmountInWithRouterPool(\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountOut: uint256,\n    _includeLegoIds: DynArray[uint256, MAX_LEGOS] = [],\n) -> (uint256, DynArray[SwapRoute, MAX_ROUTES]):\n    legoBook: address = addys._getLegoBookAddr()\n    numLegos: uint256 = staticcall Registry(legoBook).numAddrs()\n    return self._getBestSwapAmountInWithRouterPool(ROUTER_TOKENA, ROUTER_TOKENB, _tokenIn, _tokenOut, _amountOut, numLegos, legoBook, _includeLegoIds)\n\n\n@internal\ndef _getBestSwapAmountInWithRouterPool(\n    _routerTokenA: address,\n    _routerTokenB: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountOut: uint256,\n    _numLegos: uint256,\n    _legoRegistry: address,\n    _includeLegoIds: DynArray[uint256, MAX_LEGOS],\n) -> (uint256, DynArray[SwapRoute, MAX_ROUTES]):\n\n    # nothing to do, already have router pool to use\n    if self._isRouterPool(_tokenIn, _tokenOut, _routerTokenA, _routerTokenB):\n        return max_value(uint256), []\n\n    isMultiHop: bool = False\n    finalAmountIn: uint256 = max_value(uint256)\n    bestSwapRoutes: DynArray[SwapRoute, MAX_ROUTES] = []\n    firstRoute: SwapRoute = empty(SwapRoute)\n    secondRoute: SwapRoute = empty(SwapRoute)\n\n    # usdc -> weth -> tokenOut\n    if _tokenIn == _routerTokenA:\n        secondRoute = self._getBestSwapAmountInSinglePool(_routerTokenB, _tokenOut, _amountOut, _numLegos, _legoRegistry, _includeLegoIds)\n        if secondRoute.amountIn != max_value(uint256):\n            firstRoute = self._getSwapAmountInViaRouterPool(_routerTokenA, _routerTokenB, secondRoute.amountIn, _numLegos, _legoRegistry, _includeLegoIds)\n\n    # tokenIn -> weth -> usdc\n    elif _tokenOut == _routerTokenA:\n        secondRoute = self._getSwapAmountInViaRouterPool(_routerTokenB, _routerTokenA, _amountOut, _numLegos, _legoRegistry, _includeLegoIds)\n        if secondRoute.amountIn != max_value(uint256):\n            firstRoute = self._getBestSwapAmountInSinglePool(_tokenIn, _routerTokenB, secondRoute.amountIn, _numLegos, _legoRegistry, _includeLegoIds)\n\n    # weth -> usdc -> tokenOut\n    elif _tokenIn == _routerTokenB:\n        secondRoute = self._getBestSwapAmountInSinglePool(_routerTokenA, _tokenOut, _amountOut, _numLegos, _legoRegistry, _includeLegoIds)\n        if secondRoute.amountIn != max_value(uint256):\n            firstRoute = self._getSwapAmountInViaRouterPool(_routerTokenB, _routerTokenA, secondRoute.amountIn, _numLegos, _legoRegistry, _includeLegoIds)\n\n    # tokenIn -> usdc -> weth\n    elif _tokenOut == _routerTokenB:\n        secondRoute = self._getSwapAmountInViaRouterPool(_routerTokenA, _routerTokenB, _amountOut, _numLegos, _legoRegistry, _includeLegoIds)\n        if secondRoute.amountIn != max_value(uint256):\n            firstRoute = self._getBestSwapAmountInSinglePool(_tokenIn, _routerTokenA, secondRoute.amountIn, _numLegos, _legoRegistry, _includeLegoIds)\n\n    # let's try multi hop routes\n    else:\n        isMultiHop = True\n\n        # router token A as starting point\n        viaRouterTokenAAmountIn: uint256 = 0\n        viaRouterTokenARoutes: DynArray[SwapRoute, MAX_ROUTES] = []\n        viaRouterTokenAAmountIn, viaRouterTokenARoutes = self._checkRouterPoolForMiddleSwapAmountIn(_routerTokenA, _routerTokenB, _tokenIn, _tokenOut, _amountOut, _numLegos, _legoRegistry, _includeLegoIds)\n\n        # router token B as starting point\n        viaRouterTokenBAmountIn: uint256 = 0\n        viaRouterTokenBRoutes: DynArray[SwapRoute, MAX_ROUTES] = []\n        viaRouterTokenBAmountIn, viaRouterTokenBRoutes = self._checkRouterPoolForMiddleSwapAmountIn(_routerTokenB, _routerTokenA, _tokenIn, _tokenOut, _amountOut, _numLegos, _legoRegistry, _includeLegoIds)\n\n        # compare\n        if viaRouterTokenAAmountIn < viaRouterTokenBAmountIn:\n            finalAmountIn = viaRouterTokenAAmountIn\n            bestSwapRoutes = viaRouterTokenARoutes\n        elif viaRouterTokenBAmountIn != max_value(uint256):\n            finalAmountIn = viaRouterTokenBAmountIn\n            bestSwapRoutes = viaRouterTokenBRoutes\n\n    if not isMultiHop:\n        finalAmountIn = firstRoute.amountIn\n        bestSwapRoutes = [firstRoute, secondRoute]\n\n    return finalAmountIn, bestSwapRoutes\n\n\n@internal\ndef _checkRouterPoolForMiddleSwapAmountIn(\n    _firstRouterToken: address,\n    _secondRouterToken: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountOut: uint256,\n    _numLegos: uint256,\n    _legoRegistry: address,\n    _includeLegoIds: DynArray[uint256, MAX_LEGOS],\n) -> (uint256, DynArray[SwapRoute, MAX_ROUTES]):\n    tokenInToFirstHop: SwapRoute = empty(SwapRoute)\n    tokenInToFirstHop.amountIn = max_value(uint256)\n\n    # second Router Token -> tokenOut\n    secondHopToTokenOut: SwapRoute = self._getBestSwapAmountInSinglePool(_secondRouterToken, _tokenOut, _amountOut, _numLegos, _legoRegistry, _includeLegoIds)\n    if secondHopToTokenOut.amountIn == max_value(uint256):\n        return max_value(uint256), []\n\n    # tokenIn -> second Router Token\n    tokenInToSecondHop: SwapRoute = self._getBestSwapAmountInSinglePool(_tokenIn, _secondRouterToken, secondHopToTokenOut.amountIn, _numLegos, _legoRegistry, _includeLegoIds)\n\n    # first Router Token -> second Router Token -- this will always happen in router pools (i.e. usdc <-> weth)\n    firstHopToSecondHop: SwapRoute = self._getSwapAmountInViaRouterPool(_firstRouterToken, _secondRouterToken, secondHopToTokenOut.amountIn, _numLegos, _legoRegistry, _includeLegoIds)\n\n    # tokenIn -> first Router Token\n    if firstHopToSecondHop.amountIn != max_value(uint256):\n        tokenInToFirstHop = self._getBestSwapAmountInSinglePool(_tokenIn, _firstRouterToken, firstHopToSecondHop.amountIn, _numLegos, _legoRegistry, _includeLegoIds)\n\n    # compare routes\n    if tokenInToSecondHop.amountIn < tokenInToFirstHop.amountIn:\n        return tokenInToSecondHop.amountIn, [tokenInToSecondHop, secondHopToTokenOut]\n    elif tokenInToFirstHop.amountIn != max_value(uint256):\n        return tokenInToFirstHop.amountIn, [tokenInToFirstHop, firstHopToSecondHop, secondHopToTokenOut]\n    return max_value(uint256), []\n\n\n# single pool\n\n\n@external\ndef getBestSwapAmountInSinglePool(\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountOut: uint256,\n    _includeLegoIds: DynArray[uint256, MAX_LEGOS] = [],\n) -> SwapRoute:\n    legoBook: address = addys._getLegoBookAddr()\n    numLegos: uint256 = staticcall Registry(legoBook).numAddrs()\n    return self._getBestSwapAmountInSinglePool(_tokenIn, _tokenOut, _amountOut, numLegos, legoBook, _includeLegoIds)\n\n\n@internal\ndef _getBestSwapAmountInSinglePool(\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountOut: uint256,\n    _numLegos: uint256,\n    _legoRegistry: address,\n    _includeLegoIds: DynArray[uint256, MAX_LEGOS],\n) -> SwapRoute:\n\n    bestRoute: SwapRoute = SwapRoute(\n        legoId=0,\n        pool=empty(address),\n        tokenIn=_tokenIn,\n        tokenOut=_tokenOut,\n        amountIn=max_value(uint256),\n        amountOut=_amountOut,\n    )\n\n    if _numLegos == 0:\n        return bestRoute\n\n    shouldCheckLegoIds: bool = len(_includeLegoIds) != 0\n    for i: uint256 in range(1, _numLegos, bound=max_value(uint256)):\n\n        # skip if we should check lego ids and it's not in the list\n        if shouldCheckLegoIds and i not in _includeLegoIds:\n            continue\n\n        # get lego addr\n        legoAddr: address = staticcall Registry(_legoRegistry).getAddr(i)\n        if not staticcall LegoPartner(legoAddr).isDexLego():\n            continue\n\n        pool: address = empty(address)\n        amountIn: uint256 = max_value(uint256)\n        if i in [UNISWAP_V3_ID, AERODROME_SLIPSTREAM_ID]:\n            pool, amountIn = extcall LegoDexNonStandard(legoAddr).getBestSwapAmountIn(_tokenIn, _tokenOut, _amountOut)\n        else:\n            pool, amountIn = staticcall DexLego(legoAddr).getBestSwapAmountIn(_tokenIn, _tokenOut, _amountOut)\n\n        # compare best\n        if pool != empty(address) and amountIn != 0 and amountIn < bestRoute.amountIn:\n            bestRoute.pool = pool\n            bestRoute.amountIn = amountIn\n            bestRoute.legoId = i\n\n    return bestRoute\n\n\n# router pool only\n\n\n@external\ndef getSwapAmountInViaRouterPool(\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountOut: uint256,\n    _includeLegoIds: DynArray[uint256, MAX_LEGOS] = [],\n) -> SwapRoute:\n    legoBook: address = addys._getLegoBookAddr()\n    numLegos: uint256 = staticcall Registry(legoBook).numAddrs()\n    return self._getSwapAmountInViaRouterPool(_tokenIn, _tokenOut, _amountOut, numLegos, legoBook, _includeLegoIds)\n\n\n@internal\ndef _getSwapAmountInViaRouterPool(\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountOut: uint256,\n    _numLegos: uint256,\n    _legoRegistry: address,\n    _includeLegoIds: DynArray[uint256, MAX_LEGOS],\n) -> SwapRoute:\n\n    # NOTE: _tokenIn and _tokenOut need to be ROUTER_TOKENA/ROUTER_TOKENB -- in the `getCoreRouterPool()` pool\n\n    bestRoute: SwapRoute = SwapRoute(\n        legoId=0,\n        pool=empty(address),\n        tokenIn=_tokenIn,\n        tokenOut=_tokenOut,\n        amountIn=max_value(uint256),\n        amountOut=_amountOut,\n    )\n\n    if _numLegos == 0:\n        return bestRoute\n\n    shouldCheckLegoIds: bool = len(_includeLegoIds) != 0\n    for i: uint256 in range(1, _numLegos, bound=max_value(uint256)):\n\n        # skip if we should check lego ids and it's not in the list\n        if shouldCheckLegoIds and i not in _includeLegoIds:\n            continue\n\n        # get lego addr\n        legoAddr: address = staticcall Registry(_legoRegistry).getAddr(i)\n        if not staticcall LegoPartner(legoAddr).isDexLego():\n            continue\n\n        # get router pool\n        pool: address = staticcall DexLego(legoAddr).getCoreRouterPool()\n        if pool == empty(address):\n            continue\n\n        amountIn: uint256 = max_value(uint256)\n        if i in [UNISWAP_V3_ID, AERODROME_SLIPSTREAM_ID]:\n            amountIn = extcall LegoDexNonStandard(legoAddr).getSwapAmountIn(pool, _tokenIn, _tokenOut, _amountOut)\n        else:\n            amountIn = staticcall DexLego(legoAddr).getSwapAmountIn(pool, _tokenIn, _tokenOut, _amountOut)\n\n        # compare best\n        if amountIn != 0 and amountIn < bestRoute.amountIn:\n            bestRoute.pool = pool\n            bestRoute.amountIn = amountIn\n            bestRoute.legoId = i\n\n    return bestRoute\n\n\n@view\n@internal\ndef _isRouterPool(_tokenIn: address, _tokenOut: address, _routerTokenA: address, _routerTokenB: address) -> bool:\n    return _tokenIn in [_routerTokenA, _routerTokenB] and _tokenOut in [_routerTokenA, _routerTokenB]\n",
            "sha256sum": "cb62a47e7bc03cdab4d3337ca34428abe504be8bad255fedb234792706af5b9a"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/legos/LegoTools.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.3+commit.bff19ea2",
        "integrity": "20c88d8f92c5283955072fbf7118e6698516f9adc5f5b300d8d22219d611ab5f"
      },
      "args": "00000000000000000000000044cf3c4f000dfd76a35d03298049d37be688d6f9000000000000000000000000833589fcd6edb6e08f4c7c32d4f71b54bda029130000000000000000000000004200000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000500000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000007000000000000000000000000000000000000000000000000000000000000000b000000000000000000000000000000000000000000000000000000000000000c00000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000009000000000000000000000000000000000000000000000000000000000000000a",
      "file": "contracts/legos/LegoTools.vy"
    }
  }
}