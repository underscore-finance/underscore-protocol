{
  "contracts": {
    "LevgVaultHelper": {
      "address": "0xB6B6F77e064574747324541924486f8437de8338",
      "abi": [
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddys",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "undyToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "hatchery",
                  "type": "address"
                },
                {
                  "name": "lootDistributor",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                },
                {
                  "name": "walletBackpack",
                  "type": "address"
                },
                {
                  "name": "billing",
                  "type": "address"
                },
                {
                  "name": "vaultRegistry",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUndyHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getSwappableUsdcAmount",
          "inputs": [
            {
              "name": "_wallet",
              "type": "address"
            },
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_currentBalance",
              "type": "uint256"
            },
            {
              "name": "_leverageVaultToken",
              "type": "address"
            },
            {
              "name": "_leverageVaultTokenLegoId",
              "type": "uint256"
            },
            {
              "name": "_leverageVaultTokenRipeVaultId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getSwappableUsdcAmount",
          "inputs": [
            {
              "name": "_wallet",
              "type": "address"
            },
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_currentBalance",
              "type": "uint256"
            },
            {
              "name": "_leverageVaultToken",
              "type": "address"
            },
            {
              "name": "_leverageVaultTokenLegoId",
              "type": "uint256"
            },
            {
              "name": "_leverageVaultTokenRipeVaultId",
              "type": "uint256"
            },
            {
              "name": "_usdc",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getSwappableUsdcAmount",
          "inputs": [
            {
              "name": "_wallet",
              "type": "address"
            },
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_currentBalance",
              "type": "uint256"
            },
            {
              "name": "_leverageVaultToken",
              "type": "address"
            },
            {
              "name": "_leverageVaultTokenLegoId",
              "type": "uint256"
            },
            {
              "name": "_leverageVaultTokenRipeVaultId",
              "type": "uint256"
            },
            {
              "name": "_usdc",
              "type": "address"
            },
            {
              "name": "_green",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getSwappableUsdcAmount",
          "inputs": [
            {
              "name": "_wallet",
              "type": "address"
            },
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_currentBalance",
              "type": "uint256"
            },
            {
              "name": "_leverageVaultToken",
              "type": "address"
            },
            {
              "name": "_leverageVaultTokenLegoId",
              "type": "uint256"
            },
            {
              "name": "_leverageVaultTokenRipeVaultId",
              "type": "uint256"
            },
            {
              "name": "_usdc",
              "type": "address"
            },
            {
              "name": "_green",
              "type": "address"
            },
            {
              "name": "_savingsGreen",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getSwappableUsdcAmount",
          "inputs": [
            {
              "name": "_wallet",
              "type": "address"
            },
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_currentBalance",
              "type": "uint256"
            },
            {
              "name": "_leverageVaultToken",
              "type": "address"
            },
            {
              "name": "_leverageVaultTokenLegoId",
              "type": "uint256"
            },
            {
              "name": "_leverageVaultTokenRipeVaultId",
              "type": "uint256"
            },
            {
              "name": "_usdc",
              "type": "address"
            },
            {
              "name": "_green",
              "type": "address"
            },
            {
              "name": "_savingsGreen",
              "type": "address"
            },
            {
              "name": "_legoBook",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getMaxBorrowAmount",
          "inputs": [
            {
              "name": "_wallet",
              "type": "address"
            },
            {
              "name": "_underlyingAsset",
              "type": "address"
            },
            {
              "name": "_collateralVaultToken",
              "type": "address"
            },
            {
              "name": "_collateralVaultTokenLegoId",
              "type": "uint256"
            },
            {
              "name": "_collateralVaultTokenRipeVaultId",
              "type": "uint256"
            },
            {
              "name": "_netUserCapital",
              "type": "uint256"
            },
            {
              "name": "_maxDebtRatio",
              "type": "uint256"
            },
            {
              "name": "_isUsdcVault",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getMaxBorrowAmount",
          "inputs": [
            {
              "name": "_wallet",
              "type": "address"
            },
            {
              "name": "_underlyingAsset",
              "type": "address"
            },
            {
              "name": "_collateralVaultToken",
              "type": "address"
            },
            {
              "name": "_collateralVaultTokenLegoId",
              "type": "uint256"
            },
            {
              "name": "_collateralVaultTokenRipeVaultId",
              "type": "uint256"
            },
            {
              "name": "_netUserCapital",
              "type": "uint256"
            },
            {
              "name": "_maxDebtRatio",
              "type": "uint256"
            },
            {
              "name": "_isUsdcVault",
              "type": "bool"
            },
            {
              "name": "_legoBook",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "performPostSwapValidation",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenInAmount",
              "type": "uint256"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_tokenOutAmount",
              "type": "uint256"
            },
            {
              "name": "_usdcSlippageAllowed",
              "type": "uint256"
            },
            {
              "name": "_greenSlippageAllowed",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "performPostSwapValidation",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenInAmount",
              "type": "uint256"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_tokenOutAmount",
              "type": "uint256"
            },
            {
              "name": "_usdcSlippageAllowed",
              "type": "uint256"
            },
            {
              "name": "_greenSlippageAllowed",
              "type": "uint256"
            },
            {
              "name": "_usdc",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "performPostSwapValidation",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenInAmount",
              "type": "uint256"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_tokenOutAmount",
              "type": "uint256"
            },
            {
              "name": "_usdcSlippageAllowed",
              "type": "uint256"
            },
            {
              "name": "_greenSlippageAllowed",
              "type": "uint256"
            },
            {
              "name": "_usdc",
              "type": "address"
            },
            {
              "name": "_green",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getTotalAssetsForUsdcVault",
          "inputs": [
            {
              "name": "_wallet",
              "type": "address"
            },
            {
              "name": "_collateralVaultToken",
              "type": "address"
            },
            {
              "name": "_collateralVaultTokenLegoId",
              "type": "uint256"
            },
            {
              "name": "_collateralVaultTokenRipeVaultId",
              "type": "uint256"
            },
            {
              "name": "_leverageVaultToken",
              "type": "address"
            },
            {
              "name": "_leverageVaultTokenLegoId",
              "type": "uint256"
            },
            {
              "name": "_leverageVaultTokenRipeVaultId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getTotalAssetsForUsdcVault",
          "inputs": [
            {
              "name": "_wallet",
              "type": "address"
            },
            {
              "name": "_collateralVaultToken",
              "type": "address"
            },
            {
              "name": "_collateralVaultTokenLegoId",
              "type": "uint256"
            },
            {
              "name": "_collateralVaultTokenRipeVaultId",
              "type": "uint256"
            },
            {
              "name": "_leverageVaultToken",
              "type": "address"
            },
            {
              "name": "_leverageVaultTokenLegoId",
              "type": "uint256"
            },
            {
              "name": "_leverageVaultTokenRipeVaultId",
              "type": "uint256"
            },
            {
              "name": "_shouldGetMax",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getTotalAssetsForUsdcVault",
          "inputs": [
            {
              "name": "_wallet",
              "type": "address"
            },
            {
              "name": "_collateralVaultToken",
              "type": "address"
            },
            {
              "name": "_collateralVaultTokenLegoId",
              "type": "uint256"
            },
            {
              "name": "_collateralVaultTokenRipeVaultId",
              "type": "uint256"
            },
            {
              "name": "_leverageVaultToken",
              "type": "address"
            },
            {
              "name": "_leverageVaultTokenLegoId",
              "type": "uint256"
            },
            {
              "name": "_leverageVaultTokenRipeVaultId",
              "type": "uint256"
            },
            {
              "name": "_shouldGetMax",
              "type": "bool"
            },
            {
              "name": "_usdc",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getTotalAssetsForUsdcVault",
          "inputs": [
            {
              "name": "_wallet",
              "type": "address"
            },
            {
              "name": "_collateralVaultToken",
              "type": "address"
            },
            {
              "name": "_collateralVaultTokenLegoId",
              "type": "uint256"
            },
            {
              "name": "_collateralVaultTokenRipeVaultId",
              "type": "uint256"
            },
            {
              "name": "_leverageVaultToken",
              "type": "address"
            },
            {
              "name": "_leverageVaultTokenLegoId",
              "type": "uint256"
            },
            {
              "name": "_leverageVaultTokenRipeVaultId",
              "type": "uint256"
            },
            {
              "name": "_shouldGetMax",
              "type": "bool"
            },
            {
              "name": "_usdc",
              "type": "address"
            },
            {
              "name": "_green",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getTotalAssetsForUsdcVault",
          "inputs": [
            {
              "name": "_wallet",
              "type": "address"
            },
            {
              "name": "_collateralVaultToken",
              "type": "address"
            },
            {
              "name": "_collateralVaultTokenLegoId",
              "type": "uint256"
            },
            {
              "name": "_collateralVaultTokenRipeVaultId",
              "type": "uint256"
            },
            {
              "name": "_leverageVaultToken",
              "type": "address"
            },
            {
              "name": "_leverageVaultTokenLegoId",
              "type": "uint256"
            },
            {
              "name": "_leverageVaultTokenRipeVaultId",
              "type": "uint256"
            },
            {
              "name": "_shouldGetMax",
              "type": "bool"
            },
            {
              "name": "_usdc",
              "type": "address"
            },
            {
              "name": "_green",
              "type": "address"
            },
            {
              "name": "_savingsGreen",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getTotalAssetsForUsdcVault",
          "inputs": [
            {
              "name": "_wallet",
              "type": "address"
            },
            {
              "name": "_collateralVaultToken",
              "type": "address"
            },
            {
              "name": "_collateralVaultTokenLegoId",
              "type": "uint256"
            },
            {
              "name": "_collateralVaultTokenRipeVaultId",
              "type": "uint256"
            },
            {
              "name": "_leverageVaultToken",
              "type": "address"
            },
            {
              "name": "_leverageVaultTokenLegoId",
              "type": "uint256"
            },
            {
              "name": "_leverageVaultTokenRipeVaultId",
              "type": "uint256"
            },
            {
              "name": "_shouldGetMax",
              "type": "bool"
            },
            {
              "name": "_usdc",
              "type": "address"
            },
            {
              "name": "_green",
              "type": "address"
            },
            {
              "name": "_savingsGreen",
              "type": "address"
            },
            {
              "name": "_legoBook",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getTotalAssetsForNonUsdcVault",
          "inputs": [
            {
              "name": "_wallet",
              "type": "address"
            },
            {
              "name": "_underlyingAsset",
              "type": "address"
            },
            {
              "name": "_collateralVaultToken",
              "type": "address"
            },
            {
              "name": "_collateralVaultTokenLegoId",
              "type": "uint256"
            },
            {
              "name": "_collateralVaultTokenRipeVaultId",
              "type": "uint256"
            },
            {
              "name": "_leverageVaultToken",
              "type": "address"
            },
            {
              "name": "_leverageVaultTokenLegoId",
              "type": "uint256"
            },
            {
              "name": "_leverageVaultTokenRipeVaultId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getTotalAssetsForNonUsdcVault",
          "inputs": [
            {
              "name": "_wallet",
              "type": "address"
            },
            {
              "name": "_underlyingAsset",
              "type": "address"
            },
            {
              "name": "_collateralVaultToken",
              "type": "address"
            },
            {
              "name": "_collateralVaultTokenLegoId",
              "type": "uint256"
            },
            {
              "name": "_collateralVaultTokenRipeVaultId",
              "type": "uint256"
            },
            {
              "name": "_leverageVaultToken",
              "type": "address"
            },
            {
              "name": "_leverageVaultTokenLegoId",
              "type": "uint256"
            },
            {
              "name": "_leverageVaultTokenRipeVaultId",
              "type": "uint256"
            },
            {
              "name": "_shouldGetMax",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getTotalAssetsForNonUsdcVault",
          "inputs": [
            {
              "name": "_wallet",
              "type": "address"
            },
            {
              "name": "_underlyingAsset",
              "type": "address"
            },
            {
              "name": "_collateralVaultToken",
              "type": "address"
            },
            {
              "name": "_collateralVaultTokenLegoId",
              "type": "uint256"
            },
            {
              "name": "_collateralVaultTokenRipeVaultId",
              "type": "uint256"
            },
            {
              "name": "_leverageVaultToken",
              "type": "address"
            },
            {
              "name": "_leverageVaultTokenLegoId",
              "type": "uint256"
            },
            {
              "name": "_leverageVaultTokenRipeVaultId",
              "type": "uint256"
            },
            {
              "name": "_shouldGetMax",
              "type": "bool"
            },
            {
              "name": "_usdc",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getTotalAssetsForNonUsdcVault",
          "inputs": [
            {
              "name": "_wallet",
              "type": "address"
            },
            {
              "name": "_underlyingAsset",
              "type": "address"
            },
            {
              "name": "_collateralVaultToken",
              "type": "address"
            },
            {
              "name": "_collateralVaultTokenLegoId",
              "type": "uint256"
            },
            {
              "name": "_collateralVaultTokenRipeVaultId",
              "type": "uint256"
            },
            {
              "name": "_leverageVaultToken",
              "type": "address"
            },
            {
              "name": "_leverageVaultTokenLegoId",
              "type": "uint256"
            },
            {
              "name": "_leverageVaultTokenRipeVaultId",
              "type": "uint256"
            },
            {
              "name": "_shouldGetMax",
              "type": "bool"
            },
            {
              "name": "_usdc",
              "type": "address"
            },
            {
              "name": "_green",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getTotalAssetsForNonUsdcVault",
          "inputs": [
            {
              "name": "_wallet",
              "type": "address"
            },
            {
              "name": "_underlyingAsset",
              "type": "address"
            },
            {
              "name": "_collateralVaultToken",
              "type": "address"
            },
            {
              "name": "_collateralVaultTokenLegoId",
              "type": "uint256"
            },
            {
              "name": "_collateralVaultTokenRipeVaultId",
              "type": "uint256"
            },
            {
              "name": "_leverageVaultToken",
              "type": "address"
            },
            {
              "name": "_leverageVaultTokenLegoId",
              "type": "uint256"
            },
            {
              "name": "_leverageVaultTokenRipeVaultId",
              "type": "uint256"
            },
            {
              "name": "_shouldGetMax",
              "type": "bool"
            },
            {
              "name": "_usdc",
              "type": "address"
            },
            {
              "name": "_green",
              "type": "address"
            },
            {
              "name": "_savingsGreen",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getTotalAssetsForNonUsdcVault",
          "inputs": [
            {
              "name": "_wallet",
              "type": "address"
            },
            {
              "name": "_underlyingAsset",
              "type": "address"
            },
            {
              "name": "_collateralVaultToken",
              "type": "address"
            },
            {
              "name": "_collateralVaultTokenLegoId",
              "type": "uint256"
            },
            {
              "name": "_collateralVaultTokenRipeVaultId",
              "type": "uint256"
            },
            {
              "name": "_leverageVaultToken",
              "type": "address"
            },
            {
              "name": "_leverageVaultTokenLegoId",
              "type": "uint256"
            },
            {
              "name": "_leverageVaultTokenRipeVaultId",
              "type": "uint256"
            },
            {
              "name": "_shouldGetMax",
              "type": "bool"
            },
            {
              "name": "_usdc",
              "type": "address"
            },
            {
              "name": "_green",
              "type": "address"
            },
            {
              "name": "_savingsGreen",
              "type": "address"
            },
            {
              "name": "_legoBook",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getCollateralBalance",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_ripeVaultId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getCollateralBalance",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_ripeVaultId",
              "type": "uint256"
            },
            {
              "name": "_vaultBook",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isSupportedAssetInVault",
          "inputs": [
            {
              "name": "_vaultId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getVaultBookAndDeleverage",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidVaultToken",
          "inputs": [
            {
              "name": "_underlyingAsset",
              "type": "address"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_ripeVaultId",
              "type": "uint256"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getBorrowRate",
          "inputs": [
            {
              "name": "_levgVault",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getDebtAmount",
          "inputs": [
            {
              "name": "_levgVault",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getVaultTokenAmounts",
          "inputs": [
            {
              "name": "_levgVault",
              "type": "address"
            },
            {
              "name": "_isCollateralAsset",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAmounts",
          "inputs": [
            {
              "name": "_levgVault",
              "type": "address"
            },
            {
              "name": "_isCollateralAsset",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getGreenAmounts",
          "inputs": [
            {
              "name": "_levgVault",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getTrueMaxBorrowAmountForVault",
          "inputs": [
            {
              "name": "_vault",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getMaxBorrowAmountForVault",
          "inputs": [
            {
              "name": "_vault",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "RIPE_REGISTRY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "GREEN_TOKEN",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "SAVINGS_GREEN",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "USDC",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_undyHq",
              "type": "address"
            },
            {
              "name": "_ripeRegistry",
              "type": "address"
            },
            {
              "name": "_usdc",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/modules/Addys.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\ninterface UndyHq:\n    def isValidAddr(_addr: address) -> bool: view\n    def getAddr(_regId: uint256) -> address: view\n    def undyToken() -> address: view\n\ninterface Switchboard:\n    def isSwitchboardAddr(_addr: address) -> bool: view\n\ninterface LegoBook:\n    def isLegoAddr(_addr: address) -> bool: view\n\nstruct Addys:\n    hq: address\n    undyToken: address\n    ledger: address\n    missionControl: address\n    legoBook: address\n    switchboard: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    walletBackpack: address\n    billing: address\n    vaultRegistry: address\n\n# hq\nUNDY_HQ_FOR_ADDYS: immutable(address)\n\n# core addys\nLEDGER_ID: constant(uint256) = 1\nMISSION_CONTROL_ID: constant(uint256) = 2\nLEGO_BOOK_ID: constant(uint256) = 3\nSWITCHBOARD_ID: constant(uint256) = 4\nHATCHERY_ID: constant(uint256) = 5\nLOOT_DISTRIBUTOR_ID: constant(uint256) = 6\nAPPRAISER_ID: constant(uint256) = 7\nWALLET_BACKPACK_ID: constant(uint256) = 8\nBILLING_ID: constant(uint256) = 9\nVAULT_REGISTRY_ID: constant(uint256) = 10\n\n\n@deploy\ndef __init__(_undyHq: address):\n    assert _undyHq != empty(address) # dev: invalid undy hq\n    UNDY_HQ_FOR_ADDYS = _undyHq\n\n\n########\n# Core #\n########\n\n\n@view\n@external\ndef getAddys() -> Addys:\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _getAddys(_addys: Addys = empty(Addys)) -> Addys:\n    if _addys.hq != empty(address):\n        return _addys\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _generateAddys() -> Addys:\n    hq: address = UNDY_HQ_FOR_ADDYS\n    return Addys(\n        hq = hq,\n        undyToken = staticcall UndyHq(hq).undyToken(),\n        ledger = staticcall UndyHq(hq).getAddr(LEDGER_ID),\n        missionControl = staticcall UndyHq(hq).getAddr(MISSION_CONTROL_ID),\n        legoBook = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID),\n        switchboard = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID),\n        hatchery = staticcall UndyHq(hq).getAddr(HATCHERY_ID),\n        lootDistributor = staticcall UndyHq(hq).getAddr(LOOT_DISTRIBUTOR_ID),\n        appraiser = staticcall UndyHq(hq).getAddr(APPRAISER_ID),\n        walletBackpack = staticcall UndyHq(hq).getAddr(WALLET_BACKPACK_ID),\n        billing = staticcall UndyHq(hq).getAddr(BILLING_ID),\n        vaultRegistry = staticcall UndyHq(hq).getAddr(VAULT_REGISTRY_ID),\n    )\n\n\n##########\n# Tokens #\n##########\n\n\n@view\n@internal\ndef _getUndyToken() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).undyToken()\n\n\n###########\n# Helpers #\n###########\n\n\n# undy hq\n\n\n@view\n@external\ndef getUndyHq() -> address:\n    return self._getUndyHq()\n\n\n@view\n@internal\ndef _getUndyHq() -> address:\n    return UNDY_HQ_FOR_ADDYS\n\n\n# utils\n\n\n@view\n@internal\ndef _isValidUndyAddr(_addr: address, _hq: address = empty(address)) -> bool:\n    hq: address = _hq\n    if _hq == empty(address):\n        hq = UNDY_HQ_FOR_ADDYS\n    \n    # core departments\n    if staticcall UndyHq(hq).isValidAddr(_addr):\n        return True\n\n    # lego book\n    legoBook: address = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID)\n    if legoBook != empty(address) and staticcall LegoBook(legoBook).isLegoAddr(_addr):\n        return True\n\n    # switchboard config\n    switchboard: address = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID)\n    if switchboard != empty(address) and staticcall Switchboard(switchboard).isSwitchboardAddr(_addr):\n        return True\n\n    return False\n\n\n@view\n@internal\ndef _isSwitchboardAddr(_addr: address) -> bool:\n    switchboard: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n    if switchboard == empty(address):\n        return False\n    return staticcall Switchboard(switchboard).isSwitchboardAddr(_addr)\n\n\n@view\n@internal\ndef _isLegoBookAddr(_addr: address) -> bool:\n    legoBook: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n    if legoBook == empty(address):\n        return False\n    return staticcall LegoBook(legoBook).isLegoAddr(_addr)\n\n\n###############\n# Departments #\n###############\n\n\n# ledger\n\n\n@view\n@internal\ndef _getLedgerId() -> uint256:\n    return LEDGER_ID\n\n\n@view\n@internal\ndef _getLedgerAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEDGER_ID)\n\n\n# mission control\n\n\n@view\n@internal\ndef _getMissionControlId() -> uint256:\n    return MISSION_CONTROL_ID\n\n\n@view\n@internal\ndef _getMissionControlAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(MISSION_CONTROL_ID)\n\n\n# lego book\n\n\n@view\n@internal\ndef _getLegoBookId() -> uint256:\n    return LEGO_BOOK_ID\n\n\n@view\n@internal\ndef _getLegoBookAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n\n\n# switchboard\n\n\n@view\n@internal\ndef _getSwitchboardId() -> uint256:\n    return SWITCHBOARD_ID\n\n\n@view\n@internal\ndef _getSwitchboardAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n\n\n# hatchery\n\n\n@view\n@internal\ndef _getHatcheryId() -> uint256:\n    return HATCHERY_ID\n\n\n@view\n@internal\ndef _getHatcheryAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(HATCHERY_ID)\n\n\n# loot distributor\n\n\n@view\n@internal\ndef _getLootDistributorId() -> uint256:\n    return LOOT_DISTRIBUTOR_ID\n\n\n@view\n@internal\ndef _getLootDistributorAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LOOT_DISTRIBUTOR_ID)\n\n\n# appraiser\n\n\n@view\n@internal\ndef _getAppraiserId() -> uint256:\n    return APPRAISER_ID\n\n\n@view\n@internal\ndef _getAppraiserAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(APPRAISER_ID)\n\n\n# wallet backpack\n\n\n@view\n@internal\ndef _getWalletBackpackId() -> uint256:\n    return WALLET_BACKPACK_ID\n\n\n@view\n@internal\ndef _getWalletBackpackAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(WALLET_BACKPACK_ID)\n\n\n# billing\n\n\n@view\n@internal\ndef _getBillingId() -> uint256:\n    return BILLING_ID\n\n\n@view\n@internal\ndef _getBillingAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(BILLING_ID)\n\n\n# vault registry\n\n\n@view\n@internal\ndef _getVaultRegistryId() -> uint256:\n    return VAULT_REGISTRY_ID\n\n\n@view\n@internal\ndef _getVaultRegistryAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(VAULT_REGISTRY_ID)",
            "sha256sum": "4df6b72db9bb417d1af81660175be1450cfb7b3575f3d17a5b8a130bff87b781"
          },
          "contracts/vaults/LevgVaultHelper.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nexports: addys.__interface__\ninitializes: addys\nimport contracts.modules.Addys as addys\n\nfrom ethereum.ercs import IERC20\nfrom ethereum.ercs import IERC4626\n\ninterface LevgVault:\n    def vaultToLegoId(_vaultToken: address) -> uint256: view\n    def collateralAsset() -> RipeAsset: view\n    def leverageAsset() -> RipeAsset: view\n    def netUserCapital() -> uint256: view\n    def maxDebtRatio() -> uint256: view\n    def asset() -> address: view\n    def USDC() -> address: view\n\ninterface YieldLego:\n    def getUnderlyingAmountSafe(_vaultToken: address, _vaultTokenBalance: uint256) -> uint256: view\n    def getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256: view\n    def canRegisterVaultToken(_asset: address, _vaultToken: address) -> bool: view\n\ninterface RipeCreditEngine:\n    def getMaxBorrowAmount(_user: address) -> uint256: view\n    def getUserDebtAmount(_user: address) -> uint256: view\n    def getBorrowRate(_user: address) -> uint256: view\n\ninterface RipePriceDesk:\n    def getAssetAmount(_asset: address, _usdValue: uint256, _shouldRaise: bool = False) -> uint256: view\n    def getUsdValue(_asset: address, _amount: uint256, _shouldRaise: bool = False) -> uint256: view\n\ninterface RipeMissionControl:\n    def isSupportedAssetInVault(_vaultId: uint256, _asset: address) -> bool: view\n    def getFirstVaultIdForAsset(_asset: address) -> uint256: view\n\ninterface RipeRegistry:\n    def savingsGreen() -> address: view\n    def greenToken() -> address: view\n\ninterface RipeDepositVault:\n    def getTotalAmountForUser(_user: address, _asset: address) -> uint256: view\n\ninterface Registry:\n    def getAddr(_regId: uint256) -> address: view\n\nstruct RipeAsset:\n    vaultToken: address\n    ripeVaultId: uint256\n\n# ripe addrs\nRIPE_REGISTRY: public(immutable(address))\nGREEN_TOKEN: public(immutable(address))\nSAVINGS_GREEN: public(immutable(address))\nUSDC: public(immutable(address))\n\nRIPE_MISSION_CONTROL_ID: constant(uint256) = 5\nRIPE_PRICE_DESK_ID: constant(uint256) = 7\nRIPE_VAULT_BOOK_ID: constant(uint256) = 8\nRIPE_CREDIT_ENGINE_ID: constant(uint256) = 13\nRIPE_DELEVERAGE_ID: constant(uint256) = 18\n\nHUNDRED_PERCENT: constant(uint256) = 100_00  # 100.00%\n\n\n@deploy\ndef __init__(_undyHq: address, _ripeRegistry: address, _usdc: address):\n    addys.__init__(_undyHq)\n\n    assert _ripeRegistry != empty(address) # dev: invalid ripe registry\n    RIPE_REGISTRY = _ripeRegistry\n    GREEN_TOKEN = staticcall RipeRegistry(RIPE_REGISTRY).greenToken()\n    SAVINGS_GREEN = staticcall RipeRegistry(RIPE_REGISTRY).savingsGreen()\n\n    assert _usdc != empty(address) # dev: invalid usdc\n    USDC = _usdc\n\n\n###################\n# Leverage Vaults #\n###################\n\n\n# pre swap validation\n\n\n@view\n@external\ndef getSwappableUsdcAmount(\n    _wallet: address,\n    _amountIn: uint256,\n    _currentBalance: uint256,\n    _leverageVaultToken: address,\n    _leverageVaultTokenLegoId: uint256,\n    _leverageVaultTokenRipeVaultId: uint256,\n    _usdc: address = empty(address),\n    _green: address = empty(address),\n    _savingsGreen: address = empty(address),\n    _legoBook: address = empty(address),\n) -> uint256:\n    usdc: address = _usdc if _usdc != empty(address) else USDC\n    green: address = _green if _green != empty(address) else GREEN_TOKEN\n    savingsGreen: address = _savingsGreen if _savingsGreen != empty(address) else SAVINGS_GREEN\n    legoBook: address = _legoBook if _legoBook != empty(address) else addys._getLegoBookAddr()\n\n    # user debt amount\n    ripeHq: address = RIPE_REGISTRY\n    creditEngine: address = staticcall Registry(ripeHq).getAddr(RIPE_CREDIT_ENGINE_ID)\n    userDebtAmount: uint256 = self._getUserDebtAmount(_wallet, creditEngine) # 18 decimals\n    if userDebtAmount == 0:\n        return _amountIn\n\n    # more ripe addrs\n    ripeMc: address = staticcall Registry(ripeHq).getAddr(RIPE_MISSION_CONTROL_ID)\n    ripeVaultBook: address = staticcall Registry(ripeHq).getAddr(RIPE_VAULT_BOOK_ID)\n    ripePriceDesk: address = staticcall Registry(ripeHq).getAddr(RIPE_PRICE_DESK_ID)\n\n    # usdc balance (in wallet, naked on ripe, via leverage vault)\n    usdcAmount: uint256 = _currentBalance\n    usdcAmount += self._getCollateralBalanceNoRipeVaultId(_wallet, usdc, ripeMc, ripeVaultBook)\n    usdcAmount += self._getUnderlyingForVaultToken(\n        _wallet,\n        _leverageVaultToken,\n        _leverageVaultTokenLegoId,\n        _leverageVaultTokenRipeVaultId,\n        False, # safe underlying amount\n        legoBook,\n        ripeVaultBook,\n    )\n\n    # convert to USD value\n    usdcValue: uint256 = self._getUsdValue(usdc, usdcAmount, True, ripePriceDesk) # 18 decimals\n\n    # green amount\n    greenSurplusAmount: uint256 = self._getUnderlyingGreenAmount(_wallet, green, savingsGreen, ripeMc, ripeVaultBook)\n    positiveValue: uint256 = greenSurplusAmount + usdcValue # treat green as $1 USD (most conservative, in this case)\n\n    # compare usd values\n    if userDebtAmount > positiveValue:\n        return 0\n\n    # calc asset amount\n    availUsdcAmount: uint256 = self._getAssetAmount(usdc, positiveValue - userDebtAmount, True, ripePriceDesk) # 6 decimals\n    return min(availUsdcAmount, _amountIn)\n\n\n# max borrow amount\n\n\n@view\n@external\ndef getMaxBorrowAmount(\n    _wallet: address,\n    _underlyingAsset: address,\n    _collateralVaultToken: address,\n    _collateralVaultTokenLegoId: uint256,\n    _collateralVaultTokenRipeVaultId: uint256,\n    _netUserCapital: uint256,\n    _maxDebtRatio: uint256,\n    _isUsdcVault: bool,\n    _legoBook: address = empty(address),\n) -> uint256:\n    leverageAsset: RipeAsset = staticcall LevgVault(_wallet).leverageAsset()\n    return self._getMaxBorrowAmount(_wallet, _underlyingAsset, _collateralVaultToken, _collateralVaultTokenLegoId, _collateralVaultTokenRipeVaultId, _netUserCapital, _maxDebtRatio, leverageAsset.vaultToken, _legoBook)\n\n\n@view\n@internal\ndef _getMaxBorrowAmount(\n    _wallet: address,\n    _underlyingAsset: address,\n    _collateralVaultToken: address,\n    _collateralVaultTokenLegoId: uint256,\n    _collateralVaultTokenRipeVaultId: uint256,\n    _netUserCapital: uint256,\n    _maxDebtRatio: uint256,\n    _leverageVaultToken: address,\n    _legoBook: address,\n) -> uint256:\n    if _maxDebtRatio == 0:\n        return max_value(uint256)\n\n    legoBook: address = _legoBook if _legoBook != empty(address) else addys._getLegoBookAddr()\n\n    # ripe addresses\n    ripeHq: address = RIPE_REGISTRY\n    ripeMc: address = staticcall Registry(ripeHq).getAddr(RIPE_MISSION_CONTROL_ID)\n    ripeVaultBook: address = staticcall Registry(ripeHq).getAddr(RIPE_VAULT_BOOK_ID)\n    priceDesk: address = staticcall Registry(ripeHq).getAddr(RIPE_PRICE_DESK_ID)\n    creditEngine: address = staticcall Registry(ripeHq).getAddr(RIPE_CREDIT_ENGINE_ID)\n\n    # for some usdc vaults where collateral + leverage are same, use netUserCapital only (can't distinguish user capital from leveraged positions)\n    underlyingAmount: uint256 = 0\n    if _collateralVaultToken == _leverageVaultToken:\n        underlyingAmount = _netUserCapital\n    else:\n        underlyingAmount = self._getTotalUnderlying(\n            _wallet,\n            _underlyingAsset,\n            _collateralVaultToken,\n            _collateralVaultTokenLegoId,\n            _collateralVaultTokenRipeVaultId,\n            empty(address),\n            0,\n            0,\n            False,\n            False, # safe underlying amount\n            legoBook,\n            ripeMc,\n            ripeVaultBook,\n        )\n\n    # convert to USD value\n    underlyingUsdValue: uint256 = self._getUsdValue(_underlyingAsset, underlyingAmount, True, priceDesk)\n\n    # current debt amount (in GREEN, 18 decimals, treated as $1 USD)\n    currentDebt: uint256 = self._getUserDebtAmount(_wallet, creditEngine)\n\n    # max allowed debt (in USD)\n    maxAllowedDebt: uint256 = underlyingUsdValue * _maxDebtRatio // HUNDRED_PERCENT\n    if currentDebt >= maxAllowedDebt:\n        return 0\n\n    return maxAllowedDebt - currentDebt\n\n\n# post swap validation\n\n\n@view\n@external\ndef performPostSwapValidation(\n    _tokenIn: address,\n    _tokenInAmount: uint256,\n    _tokenOut: address,\n    _tokenOutAmount: uint256,\n    _usdcSlippageAllowed: uint256,\n    _greenSlippageAllowed: uint256,\n    _usdc: address = empty(address),\n    _green: address = empty(address),\n) -> bool:\n    usdc: address = _usdc if _usdc != empty(address) else USDC\n    green: address = _green if _green != empty(address) else GREEN_TOKEN\n\n    # GREEN -> USDC swap validation\n    if _tokenIn == green and _tokenOut == usdc:\n\n        # Get USD value of USDC received (18 decimals)\n        ripePriceDesk: address = staticcall Registry(RIPE_REGISTRY).getAddr(RIPE_PRICE_DESK_ID)\n        usdcValue: uint256 = self._getUsdValue(usdc, _tokenOutAmount, True, ripePriceDesk)\n\n        # Minimum expected: greenAmount * (10000 - slippage) / 10000\n        # GREEN is 18 decimals and treated as $1 USD, so greenAmount = USD value\n        minExpected: uint256 = _tokenInAmount * (HUNDRED_PERCENT - _usdcSlippageAllowed) // HUNDRED_PERCENT\n        return usdcValue >= minExpected\n\n    # USDC -> GREEN swap validation\n    elif _tokenIn == usdc and _tokenOut == green:\n\n        # Get USD value of USDC sent (18 decimals)\n        ripePriceDesk: address = staticcall Registry(RIPE_REGISTRY).getAddr(RIPE_PRICE_DESK_ID)\n        usdcValue: uint256 = self._getUsdValue(usdc, _tokenInAmount, True, ripePriceDesk)\n\n        # Minimum expected: usdcValue * (10000 - slippage) / 10000\n        minExpected: uint256 = usdcValue * (HUNDRED_PERCENT - _greenSlippageAllowed) // HUNDRED_PERCENT\n        return _tokenOutAmount >= minExpected\n\n    return True\n\n\n# usdc vault\n\n\n@view\n@external\ndef getTotalAssetsForUsdcVault(\n    _wallet: address,\n    _collateralVaultToken: address,\n    _collateralVaultTokenLegoId: uint256,\n    _collateralVaultTokenRipeVaultId: uint256,\n    _leverageVaultToken: address,\n    _leverageVaultTokenLegoId: uint256,\n    _leverageVaultTokenRipeVaultId: uint256,\n    _shouldGetMax: bool = True,\n    _usdc: address = empty(address),\n    _green: address = empty(address),\n    _savingsGreen: address = empty(address),\n    _legoBook: address = empty(address),\n) -> uint256:\n    usdc: address = _usdc if _usdc != empty(address) else USDC\n    green: address = _green if _green != empty(address) else GREEN_TOKEN\n    savingsGreen: address = _savingsGreen if _savingsGreen != empty(address) else SAVINGS_GREEN\n    legoBook: address = _legoBook if _legoBook != empty(address) else addys._getLegoBookAddr()\n\n    # ripe addresses\n    ripeHq: address = RIPE_REGISTRY\n    ripeMc: address = staticcall Registry(ripeHq).getAddr(RIPE_MISSION_CONTROL_ID)\n    ripeVaultBook: address = staticcall Registry(ripeHq).getAddr(RIPE_VAULT_BOOK_ID)\n    creditEngine: address = staticcall Registry(ripeHq).getAddr(RIPE_CREDIT_ENGINE_ID)\n\n    # usdc amount\n    usdcAmount: uint256 = self._getTotalUnderlying(\n        _wallet,\n        usdc,\n        _collateralVaultToken,\n        _collateralVaultTokenLegoId,\n        _collateralVaultTokenRipeVaultId,\n        _leverageVaultToken,\n        _leverageVaultTokenLegoId,\n        _leverageVaultTokenRipeVaultId,\n        True,\n        _shouldGetMax,\n        legoBook,\n        ripeMc,\n        ripeVaultBook,\n    )\n\n    # green amounts\n    userDebtAmount: uint256 = self._getUserDebtAmount(_wallet, creditEngine) # 18 decimals\n    greenSurplusAmount: uint256 = self._getUnderlyingGreenAmount(_wallet, green, savingsGreen, ripeMc, ripeVaultBook)\n\n    # adjust usdc values based on green situation\n    if userDebtAmount > greenSurplusAmount:\n        userDebtAmount -= greenSurplusAmount # treat green as $1 USD (most conservative, in this case)\n        usdcAmount -= min(usdcAmount, userDebtAmount // (10 ** 12)) # normalize to 6 decimals\n\n    elif greenSurplusAmount > userDebtAmount:\n        ripePriceDesk: address = staticcall Registry(ripeHq).getAddr(RIPE_PRICE_DESK_ID)\n        extraGreen: uint256 = greenSurplusAmount - userDebtAmount\n        usdValueOfGreen: uint256 = min(self._getUsdValue(green, extraGreen, True, ripePriceDesk), extraGreen) # both 18 decimals\n        usdcAmount += self._getAssetAmount(usdc, usdValueOfGreen, True, ripePriceDesk)\n\n    return usdcAmount\n\n\n# non-usdc vault\n\n\n@view\n@external\ndef getTotalAssetsForNonUsdcVault(\n    _wallet: address,\n    _underlyingAsset: address,\n    _collateralVaultToken: address,\n    _collateralVaultTokenLegoId: uint256,\n    _collateralVaultTokenRipeVaultId: uint256,\n    _leverageVaultToken: address,\n    _leverageVaultTokenLegoId: uint256,\n    _leverageVaultTokenRipeVaultId: uint256,\n    _shouldGetMax: bool = True,\n    _usdc: address = empty(address),\n    _green: address = empty(address),\n    _savingsGreen: address = empty(address),\n    _legoBook: address = empty(address),\n) -> uint256:\n    usdc: address = _usdc if _usdc != empty(address) else USDC\n    green: address = _green if _green != empty(address) else GREEN_TOKEN\n    savingsGreen: address = _savingsGreen if _savingsGreen != empty(address) else SAVINGS_GREEN\n    legoBook: address = _legoBook if _legoBook != empty(address) else addys._getLegoBookAddr()\n\n    # ripe addresses\n    ripeHq: address = RIPE_REGISTRY\n    ripeMc: address = staticcall Registry(ripeHq).getAddr(RIPE_MISSION_CONTROL_ID)\n    ripeVaultBook: address = staticcall Registry(ripeHq).getAddr(RIPE_VAULT_BOOK_ID)\n    creditEngine: address = staticcall Registry(ripeHq).getAddr(RIPE_CREDIT_ENGINE_ID)\n    ripePriceDesk: address = staticcall Registry(ripeHq).getAddr(RIPE_PRICE_DESK_ID)\n\n    # phase 1: get underlying asset amount (WETH/CBBTC/etc)\n    underlyingAmount: uint256 = self._getTotalUnderlying(\n        _wallet,\n        _underlyingAsset,\n        _collateralVaultToken,\n        _collateralVaultTokenLegoId,\n        _collateralVaultTokenRipeVaultId,\n        _leverageVaultToken,\n        _leverageVaultTokenLegoId,\n        _leverageVaultTokenRipeVaultId,\n        False, # !\n        _shouldGetMax,\n        legoBook,\n        ripeMc,\n        ripeVaultBook,\n    )\n\n    # phase 2: get USDC (wallet + naked on ripe + leverage vault)\n    usdcAmount: uint256 = staticcall IERC20(usdc).balanceOf(_wallet)\n    usdcAmount += self._getCollateralBalanceNoRipeVaultId(_wallet, usdc, ripeMc, ripeVaultBook)\n    usdcAmount += self._getUnderlyingForVaultToken(_wallet, _leverageVaultToken, _leverageVaultTokenLegoId, _leverageVaultTokenRipeVaultId, _shouldGetMax, legoBook, ripeVaultBook)\n    usdcValue: uint256 = self._getUsdValue(usdc, usdcAmount, True, ripePriceDesk) # 18 decimals\n\n    # phase 3: calculate GREEN position\n    userDebtAmount: uint256 = self._getUserDebtAmount(_wallet, creditEngine) # 18 decimals\n    greenSurplusAmount: uint256 = self._getUnderlyingGreenAmount(_wallet, green, savingsGreen, ripeMc, ripeVaultBook)\n\n    # phase 4: convert (USDC +/- GREEN) to underlying asset and add/subtract\n    if userDebtAmount > greenSurplusAmount:\n\n        # net debt scenario: we owe GREEN\n        netDebt: uint256 = userDebtAmount - greenSurplusAmount # 18 decimals, treat GREEN as $1 USD (most conservative, in this case)\n\n        # USDC covers debt with surplus\n        if usdcValue > netDebt:\n            netPositiveValue: uint256 = usdcValue - netDebt\n            underlyingAmount += self._getAssetAmount(_underlyingAsset, netPositiveValue, True, ripePriceDesk)\n\n        # debt exceeds USDC value - leverage vault is underwater\n        else:\n            netNegativeValue: uint256 = netDebt - usdcValue\n            underlyingToSubtract: uint256 = self._getAssetAmount(_underlyingAsset, netNegativeValue, True, ripePriceDesk)\n            underlyingAmount -= min(underlyingAmount, underlyingToSubtract)\n\n    else:\n        extraGreen: uint256 = greenSurplusAmount - userDebtAmount # net surplus scenario: we have extra GREEN (or zero)\n        greenValue: uint256 = min(self._getUsdValue(green, extraGreen, True, ripePriceDesk), extraGreen) # both 18 decimals\n        totalPositiveValue: uint256 = usdcValue + greenValue\n        underlyingAmount += self._getAssetAmount(_underlyingAsset, totalPositiveValue, True, ripePriceDesk)\n\n    return underlyingAmount\n\n\n# underlying green amount\n\n\n@view\n@internal\ndef _getUnderlyingGreenAmount(\n    _wallet: address,\n    _green: address,\n    _savingsGreen: address,\n    _ripeMissionControl: address,\n    _ripeVaultBook: address,\n) -> uint256:\n    greenAmount: uint256 = staticcall IERC20(_green).balanceOf(_wallet)\n\n    # savings green balance\n    savingsGreenAmount: uint256= staticcall IERC20(_savingsGreen).balanceOf(_wallet)\n\n    # savings green on ripe protocol\n    savingsGreenAmount += self._getCollateralBalanceNoRipeVaultId(_wallet, _savingsGreen, _ripeMissionControl, _ripeVaultBook)\n\n    # calc underlying amount\n    if savingsGreenAmount != 0:\n        greenAmount += self._getUnderlyingAmount(_savingsGreen, savingsGreenAmount)\n\n    return greenAmount\n\n\n# underlying amount\n\n\n@view\n@internal\ndef _getTotalUnderlying(\n    _wallet: address,\n    _underlyingAsset: address,\n    _collateralVaultToken: address,\n    _collateralVaultTokenLegoId: uint256,\n    _collateralVaultTokenRipeVaultId: uint256,\n    _leverageVaultToken: address,\n    _leverageVaultTokenLegoId: uint256,\n    _leverageVaultTokenRipeVaultId: uint256,\n    _haveSameUnderlyingAsset: bool,\n    _shouldGetMax: bool,\n    _legoBook: address,\n    _ripeMissionControl: address,\n    _ripeVaultBook: address,\n) -> uint256:\n    underlyingAmount: uint256 = staticcall IERC20(_underlyingAsset).balanceOf(_wallet)\n\n    # check if underlying asset is on ripe protocol\n    underlyingAmount += self._getCollateralBalanceNoRipeVaultId(_wallet, _underlyingAsset, _ripeMissionControl, _ripeVaultBook)\n\n    # collateral vault amount\n    underlyingAmount += self._getUnderlyingForVaultToken(_wallet, _collateralVaultToken, _collateralVaultTokenLegoId, _collateralVaultTokenRipeVaultId, _shouldGetMax, _legoBook, _ripeVaultBook)\n\n    # leverage vault amount\n    if _haveSameUnderlyingAsset and _collateralVaultToken != _leverageVaultToken:\n        underlyingAmount += self._getUnderlyingForVaultToken(_wallet, _leverageVaultToken, _leverageVaultTokenLegoId, _leverageVaultTokenRipeVaultId, _shouldGetMax, _legoBook, _ripeVaultBook)\n\n    return underlyingAmount\n\n\n# underlying amount for vault token\n\n\n@view\n@internal\ndef _getUnderlyingForVaultToken(\n    _wallet: address,\n    _vaultToken: address,\n    _vaultTokenLegoId: uint256,\n    _ripeVaultId: uint256,\n    _shouldGetMax: bool,\n    _legoBook: address,\n    _ripeVaultBook: address,\n) -> uint256:\n    if _vaultToken == empty(address):\n        return 0\n\n    # vault token local balance\n    vaultTokenAmount: uint256 = staticcall IERC20(_vaultToken).balanceOf(_wallet)\n\n    # vault token on ripe protocol\n    if _ripeVaultId != 0:\n        ripeDepositAddr: address = staticcall Registry(_ripeVaultBook).getAddr(_ripeVaultId)\n        if ripeDepositAddr != empty(address):\n            vaultTokenAmount += self._getCollateralBalance(_wallet, _vaultToken, ripeDepositAddr)\n\n    if vaultTokenAmount == 0:\n        return 0\n\n    # calc underlying amount\n    underlyingAmount: uint256 = 0\n    legoAddr: address = staticcall Registry(_legoBook).getAddr(_vaultTokenLegoId)\n    if legoAddr != empty(address):\n        if _shouldGetMax:\n            underlyingAmount = staticcall YieldLego(legoAddr).getUnderlyingAmount(_vaultToken, vaultTokenAmount)\n        else:\n            underlyingAmount = staticcall YieldLego(legoAddr).getUnderlyingAmountSafe(_vaultToken, vaultTokenAmount)\n\n    return underlyingAmount\n\n\n# collateral balance\n\n\n@view\n@external\ndef getCollateralBalance(_user: address, _asset: address, _ripeVaultId: uint256, _vaultBook: address = empty(address)) -> uint256:\n    ripeHq: address = empty(address)\n\n    ripeVaultId: uint256 = _ripeVaultId\n    if ripeVaultId == 0:\n        ripeHq = RIPE_REGISTRY\n        mc: address = staticcall Registry(ripeHq).getAddr(RIPE_MISSION_CONTROL_ID)\n        ripeVaultId = staticcall RipeMissionControl(mc).getFirstVaultIdForAsset(_asset)\n\n    vaultBook: address = _vaultBook\n    if _vaultBook == empty(address):\n        ripeHq = ripeHq if ripeHq != empty(address) else RIPE_REGISTRY\n        vaultBook = staticcall Registry(ripeHq).getAddr(RIPE_VAULT_BOOK_ID)\n\n    vaultAddr: address = staticcall Registry(vaultBook).getAddr(ripeVaultId)\n    if vaultAddr == empty(address):\n        return 0\n\n    return self._getCollateralBalance(_user, _asset, vaultAddr)\n\n\n@view\n@internal\ndef _getCollateralBalance(_user: address, _asset: address, _vaultAddr: address) -> uint256:\n    return staticcall RipeDepositVault(_vaultAddr).getTotalAmountForUser(_user, _asset)\n\n\n# collateral balance no ripe vault id\n\n\n@view\n@internal\ndef _getCollateralBalanceNoRipeVaultId(_user: address, _asset: address, _ripeMc: address, _ripeVaultBook: address) -> uint256:\n    underlyingRipeId: uint256 = staticcall RipeMissionControl(_ripeMc).getFirstVaultIdForAsset(_asset)\n    if underlyingRipeId == 0:\n        return 0\n    ripeDepositAddr: address = staticcall Registry(_ripeVaultBook).getAddr(underlyingRipeId)\n    if ripeDepositAddr == empty(address):\n        return 0\n    return self._getCollateralBalance(_user, _asset, ripeDepositAddr)\n\n\n# supported asset\n\n\n@view\n@external\ndef isSupportedAssetInVault(_vaultId: uint256, _asset: address) -> bool:\n    return self._isSupportedAssetInVault(_vaultId, _asset)\n\n\n@view\n@internal\ndef _isSupportedAssetInVault(_vaultId: uint256, _asset: address) -> bool:\n    mc: address = staticcall Registry(RIPE_REGISTRY).getAddr(RIPE_MISSION_CONTROL_ID)\n    return staticcall RipeMissionControl(mc).isSupportedAssetInVault(_vaultId, _asset)\n\n\n# user debt amount\n\n\n@view\n@internal\ndef _getUserDebtAmount(_user: address, _creditEngine: address) -> uint256:\n    return staticcall RipeCreditEngine(_creditEngine).getUserDebtAmount(_user)\n\n\n# price related\n\n\n@view\n@internal\ndef _getAssetAmount(_asset: address, _usdValue: uint256, _shouldRaise: bool, _ripePriceDesk: address) -> uint256:\n    return staticcall RipePriceDesk(_ripePriceDesk).getAssetAmount(_asset, _usdValue, _shouldRaise)\n\n\n@view\n@internal\ndef _getUsdValue(_asset: address, _amount: uint256, _shouldRaise: bool, _ripePriceDesk: address) -> uint256:\n    return staticcall RipePriceDesk(_ripePriceDesk).getUsdValue(_asset, _amount, _shouldRaise)\n\n\n# underlying amount (true)\n\n\n@view\n@internal\ndef _getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    return staticcall IERC4626(_vaultToken).convertToAssets(_vaultTokenAmount)\n\n\n# get addrs\n\n\n@view\n@external\ndef getVaultBookAndDeleverage() -> (address, address):\n    ripeHq: address = RIPE_REGISTRY\n    vaultBook: address = staticcall Registry(ripeHq).getAddr(RIPE_VAULT_BOOK_ID)\n    deleverage: address = staticcall Registry(ripeHq).getAddr(RIPE_DELEVERAGE_ID)\n    return vaultBook, deleverage\n\n\n# validate vault token\n\n\n@view\n@external\ndef isValidVaultToken(_underlyingAsset: address, _vaultToken: address, _ripeVaultId: uint256, _legoId: uint256) -> bool:\n    if empty(address) in [_underlyingAsset, _vaultToken]:\n        return False\n\n    if 0 in [_ripeVaultId, _legoId]:\n        return False\n\n    # check lego id\n    legoAddr: address = staticcall Registry(addys._getLegoBookAddr()).getAddr(_legoId)\n    if not staticcall YieldLego(legoAddr).canRegisterVaultToken(_underlyingAsset, _vaultToken):\n        return False\n\n    # check ripe collateral asset\n    return self._isSupportedAssetInVault(_ripeVaultId, _vaultToken)\n\n\n####################\n# Helper Functions #\n####################\n\n\n@view\n@external\ndef getBorrowRate(_levgVault: address) -> uint256:\n    creditEngine: address = staticcall Registry(RIPE_REGISTRY).getAddr(RIPE_CREDIT_ENGINE_ID)\n    return staticcall RipeCreditEngine(creditEngine).getBorrowRate(_levgVault)\n\n\n@view\n@external\ndef getDebtAmount(_levgVault: address) -> uint256:\n    creditEngine: address = staticcall Registry(RIPE_REGISTRY).getAddr(RIPE_CREDIT_ENGINE_ID)\n    return staticcall RipeCreditEngine(creditEngine).getUserDebtAmount(_levgVault)\n\n\n# vault token amounts\n\n\n@view\n@external\ndef getVaultTokenAmounts(_levgVault: address, _isCollateralAsset: bool) -> (uint256, uint256):\n    assetData: RipeAsset = empty(RipeAsset)\n    if _isCollateralAsset:\n        assetData = staticcall LevgVault(_levgVault).collateralAsset()\n    else:\n        assetData = staticcall LevgVault(_levgVault).leverageAsset()\n\n    vaultToken: address = assetData.vaultToken\n    ripeVaultId: uint256 = assetData.ripeVaultId\n\n    # 1. vault token in wallet\n    vaultTokenInWallet: uint256 = 0\n    if vaultToken != empty(address):\n        vaultTokenInWallet = staticcall IERC20(vaultToken).balanceOf(_levgVault)\n\n    # 2. vault token in Ripe\n    vaultTokenInRipe: uint256 = 0\n    if vaultToken != empty(address) and ripeVaultId != 0:\n        ripeVaultBook: address = staticcall Registry(RIPE_REGISTRY).getAddr(RIPE_VAULT_BOOK_ID)\n        ripeDepositAddr: address = staticcall Registry(ripeVaultBook).getAddr(ripeVaultId)\n        if ripeDepositAddr != empty(address):\n            vaultTokenInRipe = self._getCollateralBalance(_levgVault, vaultToken, ripeDepositAddr)\n\n    return vaultTokenInWallet, vaultTokenInRipe\n\n\n# underlying amounts\n\n\n@view\n@external\ndef getUnderlyingAmounts(_levgVault: address, _isCollateralAsset: bool) -> (uint256, uint256, uint256, uint256):\n    underlyingAsset: address = empty(address)\n    assetData: RipeAsset = empty(RipeAsset)\n    if _isCollateralAsset:\n        underlyingAsset = staticcall LevgVault(_levgVault).asset()\n        assetData = staticcall LevgVault(_levgVault).collateralAsset()\n    else:\n        underlyingAsset = staticcall LevgVault(_levgVault).USDC()\n        assetData = staticcall LevgVault(_levgVault).leverageAsset()\n\n    vaultToken: address = assetData.vaultToken\n    ripeVaultId: uint256 = assetData.ripeVaultId\n    legoBook: address = addys._getLegoBookAddr()\n\n    # 1. underlying asset in wallet\n    underlyingInWallet: uint256 = staticcall IERC20(underlyingAsset).balanceOf(_levgVault)\n\n    # 2. vault token in wallet -> converted to underlying via lego\n    vaultTokenInWalletConverted: uint256 = 0\n    if vaultToken != empty(address):\n        vaultTokenInWallet: uint256 = staticcall IERC20(vaultToken).balanceOf(_levgVault)\n        if vaultTokenInWallet != 0:\n            legoId: uint256 = staticcall LevgVault(_levgVault).vaultToLegoId(vaultToken)\n            legoAddr: address = staticcall Registry(legoBook).getAddr(legoId)\n            if legoAddr != empty(address):\n                vaultTokenInWalletConverted = staticcall YieldLego(legoAddr).getUnderlyingAmount(vaultToken, vaultTokenInWallet)\n\n    # ripe addresses\n    ripeHq: address = RIPE_REGISTRY\n    ripeMc: address = staticcall Registry(ripeHq).getAddr(RIPE_MISSION_CONTROL_ID)\n    ripeVaultBook: address = staticcall Registry(ripeHq).getAddr(RIPE_VAULT_BOOK_ID)\n\n    # 3. underlying asset deposited in Ripe Protocol (raw)\n    underlyingInRipe: uint256 = self._getCollateralBalanceNoRipeVaultId(_levgVault, underlyingAsset, ripeMc, ripeVaultBook)\n\n    # 4. vault token in Ripe -> converted to underlying via lego\n    vaultTokenInRipeConverted: uint256 = 0\n    if vaultToken != empty(address) and ripeVaultId != 0:\n        ripeDepositAddr: address = staticcall Registry(ripeVaultBook).getAddr(ripeVaultId)\n        if ripeDepositAddr != empty(address):\n            vaultTokenInRipe: uint256 = self._getCollateralBalance(_levgVault, vaultToken, ripeDepositAddr)\n            if vaultTokenInRipe != 0:\n                legoId: uint256 = staticcall LevgVault(_levgVault).vaultToLegoId(vaultToken)\n                legoAddr: address = staticcall Registry(legoBook).getAddr(legoId)\n                if legoAddr != empty(address):\n                    vaultTokenInRipeConverted = staticcall YieldLego(legoAddr).getUnderlyingAmount(vaultToken, vaultTokenInRipe)\n\n    return underlyingInWallet, vaultTokenInWalletConverted, underlyingInRipe, vaultTokenInRipeConverted\n\n\n# green amounts\n\n\n@view\n@external\ndef getGreenAmounts(_levgVault: address) -> (uint256, uint256, uint256, uint256):\n    ripeHq: address = RIPE_REGISTRY\n    ripeMc: address = staticcall Registry(ripeHq).getAddr(RIPE_MISSION_CONTROL_ID)\n    ripeVaultBook: address = staticcall Registry(ripeHq).getAddr(RIPE_VAULT_BOOK_ID)\n    creditEngine: address = staticcall Registry(ripeHq).getAddr(RIPE_CREDIT_ENGINE_ID)\n\n    # 1. user debt in Ripe Protocol (denominated in GREEN)\n    userDebt: uint256 = self._getUserDebtAmount(_levgVault, creditEngine)\n\n    # 2. GREEN in wallet\n    greenInWallet: uint256 = staticcall IERC20(GREEN_TOKEN).balanceOf(_levgVault)\n\n    # 3. sGREEN in wallet -> converted to GREEN\n    savingsGreen: address = SAVINGS_GREEN\n    sGreenInWalletConverted: uint256 = 0\n    sGreenInWallet: uint256 = staticcall IERC20(savingsGreen).balanceOf(_levgVault)\n    if sGreenInWallet != 0:\n        sGreenInWalletConverted = self._getUnderlyingAmount(savingsGreen, sGreenInWallet)\n\n    # 4. sGREEN in Ripe -> converted to GREEN\n    sGreenInRipeConverted: uint256 = 0\n    sGreenInRipe: uint256 = self._getCollateralBalanceNoRipeVaultId(_levgVault, savingsGreen, ripeMc, ripeVaultBook)\n    if sGreenInRipe != 0:\n        sGreenInRipeConverted = self._getUnderlyingAmount(savingsGreen, sGreenInRipe)\n\n    return userDebt, greenInWallet, sGreenInWalletConverted, sGreenInRipeConverted\n\n\n# max borrow\n\n\n@view\n@external\ndef getTrueMaxBorrowAmountForVault(_vault: address) -> uint256:\n    maxDebtRatioLimit: uint256 = self._getMaxBorrowAmountForVault(_vault)\n    creditEngine: address = staticcall Registry(RIPE_REGISTRY).getAddr(RIPE_CREDIT_ENGINE_ID)\n    maxBorrowAmount: uint256 = staticcall RipeCreditEngine(creditEngine).getMaxBorrowAmount(_vault)\n    return min(maxDebtRatioLimit, maxBorrowAmount)\n\n\n@view\n@external\ndef getMaxBorrowAmountForVault(_vault: address) -> uint256:\n    return self._getMaxBorrowAmountForVault(_vault)\n\n\n@view\n@internal\ndef _getMaxBorrowAmountForVault(_vault: address) -> uint256:\n    underlyingAsset: address = staticcall LevgVault(_vault).asset()\n    collateralAsset: RipeAsset = staticcall LevgVault(_vault).collateralAsset()\n    leverageAsset: RipeAsset = staticcall LevgVault(_vault).leverageAsset()\n    netUserCapital: uint256 = staticcall LevgVault(_vault).netUserCapital()\n    maxDebtRatio: uint256 = staticcall LevgVault(_vault).maxDebtRatio()\n    collateralVaultTokenLegoId: uint256 = staticcall LevgVault(_vault).vaultToLegoId(collateralAsset.vaultToken)\n\n    return self._getMaxBorrowAmount(\n        _vault,\n        underlyingAsset,\n        collateralAsset.vaultToken,\n        collateralVaultTokenLegoId,\n        collateralAsset.ripeVaultId,\n        netUserCapital,\n        maxDebtRatio,\n        leverageAsset.vaultToken,\n        empty(address),\n    )",
            "sha256sum": "1b74ad6dbfacdec73c6e241547947d86f649ae9063941345f6c5dad2b5c4fc7a"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/vaults/LevgVaultHelper.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.3+commit.bff19ea2",
        "integrity": "a376288d5c8efad4091fede210e88b8e70d2a41d0d02555718f9219d9504ba5e"
      },
      "args": "00000000000000000000000044cf3c4f000dfd76a35d03298049d37be688d6f90000000000000000000000006162df1b329e157479f8f1407e888260e0ec3d2b000000000000000000000000833589fcd6edb6e08f4c7c32d4f71b54bda02913",
      "file": "contracts/vaults/LevgVaultHelper.vy"
    }
  }
}