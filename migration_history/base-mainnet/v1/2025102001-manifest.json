{
  "contracts": {
    "LegoTools": {
      "address": "0x9236af092494C91Da80364C8Df3557FB05C0094E",
      "abi": [
        {
          "name": "DepartmentPauseModified",
          "inputs": [
            {
              "name": "isPaused",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "DepartmentFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "balance",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddys",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "undyToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "hatchery",
                  "type": "address"
                },
                {
                  "name": "lootDistributor",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                },
                {
                  "name": "walletBackpack",
                  "type": "address"
                },
                {
                  "name": "billing",
                  "type": "address"
                },
                {
                  "name": "vaultRegistry",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUndyHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canMintUndy",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pause",
          "inputs": [
            {
              "name": "_shouldPause",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFundsMany",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_assets",
              "type": "address[]"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isPaused",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "aaveV3",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "aaveV3Id",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "compoundV3",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "compoundV3Id",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "euler",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "eulerId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "fluid",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "fluidId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "moonwell",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "moonwellId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "morpho",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "morphoId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "uniswapV2",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "uniswapV2Id",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "uniswapV3",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "uniswapV3Id",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "aerodrome",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "aerodromeId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "aerodromeSlipstream",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "aerodromeSlipstreamId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "curve",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "curveId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAsset",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAsset",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_legoBook",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingForUser",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingForUser",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_legoBook",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getVaultTokensForUser",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple[]",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "vaultToken",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getVaultTokensForUser",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_legoBook",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple[]",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "vaultToken",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_legoBook",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getVaultTokenAmount",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_assetAmount",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getVaultTokenAmount",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_assetAmount",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_legoBook",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLegoInfoFromVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "string"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLegoInfoFromVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_legoBook",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "string"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingData",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "amount",
                  "type": "uint256"
                },
                {
                  "name": "usdValue",
                  "type": "uint256"
                },
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "legoAddr",
                  "type": "address"
                },
                {
                  "name": "legoDesc",
                  "type": "string"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingData",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_legoBook",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "amount",
                  "type": "uint256"
                },
                {
                  "name": "usdValue",
                  "type": "uint256"
                },
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "legoAddr",
                  "type": "address"
                },
                {
                  "name": "legoDesc",
                  "type": "string"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getRoutesAndSwapInstructionsAmountOut",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_slippage",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple[]",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "minAmountOut",
                  "type": "uint256"
                },
                {
                  "name": "tokenPath",
                  "type": "address[]"
                },
                {
                  "name": "poolPath",
                  "type": "address[]"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getRoutesAndSwapInstructionsAmountOut",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_slippage",
              "type": "uint256"
            },
            {
              "name": "_includeLegoIds",
              "type": "uint256[]"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple[]",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "minAmountOut",
                  "type": "uint256"
                },
                {
                  "name": "tokenPath",
                  "type": "address[]"
                },
                {
                  "name": "poolPath",
                  "type": "address[]"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getRoutesAndSwapInstructionsAmountIn",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountOut",
              "type": "uint256"
            },
            {
              "name": "_amountInAvailable",
              "type": "uint256"
            },
            {
              "name": "_slippage",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple[]",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "minAmountOut",
                  "type": "uint256"
                },
                {
                  "name": "tokenPath",
                  "type": "address[]"
                },
                {
                  "name": "poolPath",
                  "type": "address[]"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getRoutesAndSwapInstructionsAmountIn",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountOut",
              "type": "uint256"
            },
            {
              "name": "_amountInAvailable",
              "type": "uint256"
            },
            {
              "name": "_slippage",
              "type": "uint256"
            },
            {
              "name": "_includeLegoIds",
              "type": "uint256[]"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple[]",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "minAmountOut",
                  "type": "uint256"
                },
                {
                  "name": "tokenPath",
                  "type": "address[]"
                },
                {
                  "name": "poolPath",
                  "type": "address[]"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "prepareSwapInstructionsAmountOut",
          "inputs": [
            {
              "name": "_slippage",
              "type": "uint256"
            },
            {
              "name": "_routes",
              "type": "tuple[]",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "name": "tokenOut",
                  "type": "address"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "amountOut",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple[]",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "minAmountOut",
                  "type": "uint256"
                },
                {
                  "name": "tokenPath",
                  "type": "address[]"
                },
                {
                  "name": "poolPath",
                  "type": "address[]"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getBestSwapRoutesAmountOut",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountIn",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple[]",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "name": "tokenOut",
                  "type": "address"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "amountOut",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getBestSwapRoutesAmountOut",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_includeLegoIds",
              "type": "uint256[]"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple[]",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "name": "tokenOut",
                  "type": "address"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "amountOut",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getBestSwapAmountOutWithRouterPool",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountIn",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "tuple[]",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "name": "tokenOut",
                  "type": "address"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "amountOut",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getBestSwapAmountOutWithRouterPool",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_includeLegoIds",
              "type": "uint256[]"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "tuple[]",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "name": "tokenOut",
                  "type": "address"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "amountOut",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getBestSwapAmountOutSinglePool",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountIn",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "name": "tokenOut",
                  "type": "address"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "amountOut",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getBestSwapAmountOutSinglePool",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_includeLegoIds",
              "type": "uint256[]"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "name": "tokenOut",
                  "type": "address"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "amountOut",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getSwapAmountOutViaRouterPool",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountIn",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "name": "tokenOut",
                  "type": "address"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "amountOut",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getSwapAmountOutViaRouterPool",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_includeLegoIds",
              "type": "uint256[]"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "name": "tokenOut",
                  "type": "address"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "amountOut",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getBestSwapRoutesAmountIn",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountOut",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple[]",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "name": "tokenOut",
                  "type": "address"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "amountOut",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getBestSwapRoutesAmountIn",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountOut",
              "type": "uint256"
            },
            {
              "name": "_includeLegoIds",
              "type": "uint256[]"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple[]",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "name": "tokenOut",
                  "type": "address"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "amountOut",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getBestSwapAmountInWithRouterPool",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountOut",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "tuple[]",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "name": "tokenOut",
                  "type": "address"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "amountOut",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getBestSwapAmountInWithRouterPool",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountOut",
              "type": "uint256"
            },
            {
              "name": "_includeLegoIds",
              "type": "uint256[]"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "tuple[]",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "name": "tokenOut",
                  "type": "address"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "amountOut",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getBestSwapAmountInSinglePool",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountOut",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "name": "tokenOut",
                  "type": "address"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "amountOut",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getBestSwapAmountInSinglePool",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountOut",
              "type": "uint256"
            },
            {
              "name": "_includeLegoIds",
              "type": "uint256[]"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "name": "tokenOut",
                  "type": "address"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "amountOut",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getSwapAmountInViaRouterPool",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountOut",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "name": "tokenOut",
                  "type": "address"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "amountOut",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getSwapAmountInViaRouterPool",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountOut",
              "type": "uint256"
            },
            {
              "name": "_includeLegoIds",
              "type": "uint256[]"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "name": "tokenOut",
                  "type": "address"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "amountOut",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ROUTER_TOKENA",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ROUTER_TOKENB",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "AAVE_V3_ID",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "COMPOUND_V3_ID",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "EULER_ID",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "FLUID_ID",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MOONWELL_ID",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MORPHO_ID",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "UNISWAP_V2_ID",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "UNISWAP_V3_ID",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "AERODROME_ID",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "AERODROME_SLIPSTREAM_ID",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "CURVE_ID",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_undyHq",
              "type": "address"
            },
            {
              "name": "_routerTokenA",
              "type": "address"
            },
            {
              "name": "_routerTokenB",
              "type": "address"
            },
            {
              "name": "_aaveV3Id",
              "type": "uint256"
            },
            {
              "name": "_compoundV3Id",
              "type": "uint256"
            },
            {
              "name": "_eulerId",
              "type": "uint256"
            },
            {
              "name": "_fluidId",
              "type": "uint256"
            },
            {
              "name": "_moonwellId",
              "type": "uint256"
            },
            {
              "name": "_morphoId",
              "type": "uint256"
            },
            {
              "name": "_uniswapV2Id",
              "type": "uint256"
            },
            {
              "name": "_uniswapV3Id",
              "type": "uint256"
            },
            {
              "name": "_aerodromeId",
              "type": "uint256"
            },
            {
              "name": "_aerodromeSlipstreamId",
              "type": "uint256"
            },
            {
              "name": "_curveId",
              "type": "uint256"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "interfaces/WalletStructs.vyi": {
            "content": "# @version 0.4.3\n\nflag ActionType:\n    TRANSFER\n    EARN_DEPOSIT\n    EARN_WITHDRAW\n    EARN_REBALANCE\n    SWAP\n    MINT_REDEEM\n    CONFIRM_MINT_REDEEM\n    ADD_COLLATERAL\n    REMOVE_COLLATERAL\n    BORROW\n    REPAY_DEBT\n    REWARDS\n    ETH_TO_WETH\n    WETH_TO_ETH\n    ADD_LIQ\n    REMOVE_LIQ\n    ADD_LIQ_CONC\n    REMOVE_LIQ_CONC\n    PAY_CHEQUE\n\nstruct WalletAssetData:\n    assetBalance: uint256\n    usdValue: uint256\n    isYieldAsset: bool\n    lastPricePerShare: uint256\n\nstruct ActionData:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    billing: address\n    wallet: address\n    walletConfig: address\n    walletOwner: address\n    inEjectMode: bool\n    isFrozen: bool\n    lastTotalUsdValue: uint256\n    signer: address\n    isManager: bool\n    legoId: uint256\n    legoAddr: address\n    eth: address\n    weth: address\n\nstruct MiniAddys:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    appraiser: address",
            "sha256sum": "9a4b4f59b3a62043e51b425a665064aae419a3c0bd0514b6b29a9441ae364bb9"
          },
          "interfaces/LegoPartner.vyi": {
            "content": "# @version 0.4.3\n\nfrom interfaces import WalletStructs as ws\n\nMAX_TOKEN_PATH: constant(uint256) = 5\nMAX_RECOVER_ASSETS: constant(uint256) = 20\n\n@external\ndef addLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _tickLower: int24, _tickUpper: int24, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef addLiquidity(_pool: address, _tokenA: address, _tokenB: address, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _minLpAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (address, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef removeLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _liqToRemove: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef removeLiquidity(_pool: address, _tokenA: address, _tokenB: address, _lpToken: address, _lpAmount: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef mintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _tokenInAmount: uint256, _minAmountOut: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef swapTokens(_amountIn: uint256, _minAmountOut: uint256, _tokenPath: DynArray[address, MAX_TOKEN_PATH], _poolPath: DynArray[address, MAX_TOKEN_PATH - 1], _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256):\n    ...\n\n@external\ndef depositForYield(_asset: address, _amount: uint256, _vaultAddr: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef withdrawFromYield(_vaultToken: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef confirmMintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef borrow(_borrowAsset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef repayDebt(_paymentAsset: address, _paymentAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef claimRewards(_user: address, _rewardToken: address, _rewardAmount: uint256, _extraData: bytes32, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef removeCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef addCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@view\n@external\ndef getAccessForLego(_user: address, _action: ws.ActionType) -> (address, String[64], uint256):\n    ...\n\n@view\n@external\ndef hasCapability(_action: ws.ActionType) -> bool:\n    ...\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    ...\n\n@view\n@external\ndef isYieldLego() -> bool:\n    ...\n\n@view\n@external\ndef isDexLego() -> bool:\n    ...\n\n\n# common\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "81db71fe4440a3b4b563134c9b5caf1d5705772a5f291fe874c9b5fb3cfb1623"
          },
          "interfaces/LegoStructs.vyi": {
            "content": "# @version 0.4.3\n\nstruct VaultTokenInfo:\n    underlyingAsset: address\n    decimals: uint256\n    lastAveragePricePerShare: uint256\n\nstruct SnapShotPriceConfig:\n    minSnapshotDelay: uint256\n    maxNumSnapshots: uint256\n    maxUpsideDeviation: uint256\n    staleTime: uint256\n\nstruct SingleSnapShot:\n    totalSupply: uint256\n    pricePerShare: uint256\n    lastUpdate: uint256\n\nstruct SnapShotData:\n    lastSnapShot: SingleSnapShot\n    nextIndex: uint256\n",
            "sha256sum": "8ae48be17d812d57fbd671bbf0593e8abf175ad0924e47c5997823cac19ec806"
          },
          "interfaces/YieldLego.vyi": {
            "content": "# @version 0.4.3\n\nfrom interfaces import LegoStructs as ls\n\n\n###################\n# Underlying Data #\n###################\n\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    ...\n\n\n@view\n@external\ndef getUnderlyingBalances(_vaultToken: address, _vaultTokenBalance: uint256) -> (uint256, uint256):\n    ...\n\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    ...\n\n\n@view\n@external\ndef getUnderlyingAmountSafe(_vaultToken: address, _vaultTokenBalance: uint256) -> uint256:\n    ...\n\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> (address, uint256, uint256):\n    ...\n\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> uint256:\n    ...\n\n\n###############\n# Other Utils #\n###############\n\n\n@view\n@external\ndef isRebasing() -> bool:\n    ...\n\n\n@view\n@external\ndef getPricePerShare(_vaultToken: address, _decimals: uint256 = 0) -> uint256:\n    ...\n\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef canRegisterVaultToken(_asset: address, _vaultToken: address) -> bool:\n    ...\n\n\n@view\n@external\ndef isEligibleVaultForTrialFunds(_vaultToken: address, _underlyingAsset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef isEligibleForYieldBonus(_asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    ...\n\n\n###################\n# Yield Lego Data #\n###################\n\n\n@view\n@external\ndef isLegoAsset(_asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, 40]:\n    ...\n\n\n@view\n@external\ndef getAssets() -> DynArray[address, 20]:\n    ...\n\n\n@view\n@external\ndef isAssetOpportunity(_asset: address, _vaultAddr: address) -> bool:\n    ...\n\n\n@view\n@external\ndef getNumLegoAssets() -> uint256:\n    ...\n\n\n@view\n@external\ndef assets(_index: uint256) -> address:\n    ...\n\n\n@view\n@external\ndef indexOfAsset(_asset: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef numAssets() -> uint256:\n    ...\n\n\n@view\n@external\ndef assetOpportunities(_asset: address, _index: uint256) -> address:\n    ...\n\n\n@view\n@external\ndef indexOfAssetOpportunity(_asset: address, _vaultAddr: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef numAssetOpportunities(_asset: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef vaultToAsset(_vaultAddr: address) -> ls.VaultTokenInfo:\n    ...\n\n\n# price snapshots\n\n\n@external\ndef addPriceSnapshot(_vaultToken: address) -> bool:\n    ...\n\n\n@view\n@external\ndef snapShotPriceConfig() -> ls.SnapShotPriceConfig:\n    ...\n\n\n@view\n@external\ndef snapShotData(_vaultToken: address) -> ls.SnapShotData:\n    ...\n\n\n@view\n@external\ndef snapShots(_vaultToken: address, _index: uint256) -> ls.SingleSnapShot:\n    ...\n\n\n@view\n@external\ndef getWeightedPricePerShare(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef getLatestSnapshot(_vaultToken: address, _pricePerShare: uint256) -> ls.SingleSnapShot:\n    ...\n\n\n@external\ndef setSnapShotPriceConfig(_config: ls.SnapShotPriceConfig):\n    ...\n",
            "sha256sum": "045a6bbd3d556234cf4fe925a303002dc0ac3c482d344ffbaf4bc52a7e6ad2df"
          },
          "interfaces/DexLego.vyi": {
            "content": "# @version 0.4.3\n\n# used in smart contracts\n\n\n@view\n@external\ndef getLpToken(_pool: address) -> address:\n    ...\n\n\n# helper functions for server\n\n\n@view\n@external\ndef getPoolForLpToken(_lpToken: address) -> address:\n    ...\n\n\n@view\n@external\ndef getSwapAmountOut(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n) -> uint256:\n    ...\n\n\n@view\n@external\ndef getSwapAmountIn(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountOut: uint256,\n) -> uint256:\n    ...\n\n\n@view\n@external\ndef getAddLiqAmountsIn(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _availAmountA: uint256,\n    _availAmountB: uint256,\n) -> (uint256, uint256, uint256):\n    ...\n\n\n@view\n@external\ndef getRemoveLiqAmountsOut(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpAmount: uint256,\n) -> (uint256, uint256):\n    ...\n\n\n@view\n@external\ndef getPriceUnsafe(_pool: address, _targetToken: address, _appraiser: address = empty(address)) -> uint256:\n    ...\n\n\n@view\n@external\ndef getBestSwapAmountOut(_tokenIn: address, _tokenOut: address, _amountIn: uint256) -> (address, uint256):\n    ...\n\n\n@view\n@external\ndef getBestSwapAmountIn(_tokenIn: address, _tokenOut: address, _amountOut: uint256) -> (address, uint256):\n    ...\n\n\n@view\n@external\ndef getCoreRouterPool() -> address:\n    ...\n\n\n@view\n@external\ndef getPrice(_asset: address, _decimals: uint256) -> uint256:\n    ...\n",
            "sha256sum": "6248ad46926f00481cb3469bfc7af8fe36669c2ca0dd98e9a0befdda0fc43fd7"
          },
          "interfaces/Department.vyi": {
            "content": "# @version 0.4.3\n\n\n###########\n# Minting #\n###########\n\n\n@view\n@external\ndef canMintUndy() -> bool:\n    # used in UndyHq.vy\n    ...\n\n\n########\n# Undy #\n########\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "53e48da591c4ee36045a8950c9d3a01458456b471b797df536e9a9f54404e721"
          },
          "contracts/modules/Addys.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\ninterface UndyHq:\n    def isValidAddr(_addr: address) -> bool: view\n    def getAddr(_regId: uint256) -> address: view\n    def undyToken() -> address: view\n\ninterface Switchboard:\n    def isSwitchboardAddr(_addr: address) -> bool: view\n\ninterface LegoBook:\n    def isLegoAddr(_addr: address) -> bool: view\n\nstruct Addys:\n    hq: address\n    undyToken: address\n    ledger: address\n    missionControl: address\n    legoBook: address\n    switchboard: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    walletBackpack: address\n    billing: address\n    vaultRegistry: address\n\n# hq\nUNDY_HQ_FOR_ADDYS: immutable(address)\n\n# core addys\nLEDGER_ID: constant(uint256) = 1\nMISSION_CONTROL_ID: constant(uint256) = 2\nLEGO_BOOK_ID: constant(uint256) = 3\nSWITCHBOARD_ID: constant(uint256) = 4\nHATCHERY_ID: constant(uint256) = 5\nLOOT_DISTRIBUTOR_ID: constant(uint256) = 6\nAPPRAISER_ID: constant(uint256) = 7\nWALLET_BACKPACK_ID: constant(uint256) = 8\nBILLING_ID: constant(uint256) = 9\nVAULT_REGISTRY_ID: constant(uint256) = 10\n\n\n@deploy\ndef __init__(_undyHq: address):\n    assert _undyHq != empty(address) # dev: invalid undy hq\n    UNDY_HQ_FOR_ADDYS = _undyHq\n\n\n########\n# Core #\n########\n\n\n@view\n@external\ndef getAddys() -> Addys:\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _getAddys(_addys: Addys = empty(Addys)) -> Addys:\n    if _addys.hq != empty(address):\n        return _addys\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _generateAddys() -> Addys:\n    hq: address = UNDY_HQ_FOR_ADDYS\n    return Addys(\n        hq = hq,\n        undyToken = staticcall UndyHq(hq).undyToken(),\n        ledger = staticcall UndyHq(hq).getAddr(LEDGER_ID),\n        missionControl = staticcall UndyHq(hq).getAddr(MISSION_CONTROL_ID),\n        legoBook = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID),\n        switchboard = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID),\n        hatchery = staticcall UndyHq(hq).getAddr(HATCHERY_ID),\n        lootDistributor = staticcall UndyHq(hq).getAddr(LOOT_DISTRIBUTOR_ID),\n        appraiser = staticcall UndyHq(hq).getAddr(APPRAISER_ID),\n        walletBackpack = staticcall UndyHq(hq).getAddr(WALLET_BACKPACK_ID),\n        billing = staticcall UndyHq(hq).getAddr(BILLING_ID),\n        vaultRegistry = staticcall UndyHq(hq).getAddr(VAULT_REGISTRY_ID),\n    )\n\n\n##########\n# Tokens #\n##########\n\n\n@view\n@internal\ndef _getUndyToken() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).undyToken()\n\n\n###########\n# Helpers #\n###########\n\n\n# undy hq\n\n\n@view\n@external\ndef getUndyHq() -> address:\n    return self._getUndyHq()\n\n\n@view\n@internal\ndef _getUndyHq() -> address:\n    return UNDY_HQ_FOR_ADDYS\n\n\n# utils\n\n\n@view\n@internal\ndef _isValidUndyAddr(_addr: address, _hq: address = empty(address)) -> bool:\n    hq: address = _hq\n    if _hq == empty(address):\n        hq = UNDY_HQ_FOR_ADDYS\n    \n    # core departments\n    if staticcall UndyHq(hq).isValidAddr(_addr):\n        return True\n\n    # lego book\n    legoBook: address = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID)\n    if legoBook != empty(address) and staticcall LegoBook(legoBook).isLegoAddr(_addr):\n        return True\n\n    # switchboard config\n    switchboard: address = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID)\n    if switchboard != empty(address) and staticcall Switchboard(switchboard).isSwitchboardAddr(_addr):\n        return True\n\n    return False\n\n\n@view\n@internal\ndef _isSwitchboardAddr(_addr: address) -> bool:\n    switchboard: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n    if switchboard == empty(address):\n        return False\n    return staticcall Switchboard(switchboard).isSwitchboardAddr(_addr)\n\n\n@view\n@internal\ndef _isLegoBookAddr(_addr: address) -> bool:\n    legoBook: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n    if legoBook == empty(address):\n        return False\n    return staticcall LegoBook(legoBook).isLegoAddr(_addr)\n\n\n###############\n# Departments #\n###############\n\n\n# ledger\n\n\n@view\n@internal\ndef _getLedgerId() -> uint256:\n    return LEDGER_ID\n\n\n@view\n@internal\ndef _getLedgerAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEDGER_ID)\n\n\n# mission control\n\n\n@view\n@internal\ndef _getMissionControlId() -> uint256:\n    return MISSION_CONTROL_ID\n\n\n@view\n@internal\ndef _getMissionControlAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(MISSION_CONTROL_ID)\n\n\n# lego book\n\n\n@view\n@internal\ndef _getLegoBookId() -> uint256:\n    return LEGO_BOOK_ID\n\n\n@view\n@internal\ndef _getLegoBookAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n\n\n# switchboard\n\n\n@view\n@internal\ndef _getSwitchboardId() -> uint256:\n    return SWITCHBOARD_ID\n\n\n@view\n@internal\ndef _getSwitchboardAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n\n\n# hatchery\n\n\n@view\n@internal\ndef _getHatcheryId() -> uint256:\n    return HATCHERY_ID\n\n\n@view\n@internal\ndef _getHatcheryAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(HATCHERY_ID)\n\n\n# loot distributor\n\n\n@view\n@internal\ndef _getLootDistributorId() -> uint256:\n    return LOOT_DISTRIBUTOR_ID\n\n\n@view\n@internal\ndef _getLootDistributorAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LOOT_DISTRIBUTOR_ID)\n\n\n# appraiser\n\n\n@view\n@internal\ndef _getAppraiserId() -> uint256:\n    return APPRAISER_ID\n\n\n@view\n@internal\ndef _getAppraiserAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(APPRAISER_ID)\n\n\n# wallet backpack\n\n\n@view\n@internal\ndef _getWalletBackpackId() -> uint256:\n    return WALLET_BACKPACK_ID\n\n\n@view\n@internal\ndef _getWalletBackpackAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(WALLET_BACKPACK_ID)\n\n\n# billing\n\n\n@view\n@internal\ndef _getBillingId() -> uint256:\n    return BILLING_ID\n\n\n@view\n@internal\ndef _getBillingAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(BILLING_ID)\n\n\n# vault registry\n\n\n@view\n@internal\ndef _getVaultRegistryId() -> uint256:\n    return VAULT_REGISTRY_ID\n\n\n@view\n@internal\ndef _getVaultRegistryAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(VAULT_REGISTRY_ID)",
            "sha256sum": "4df6b72db9bb417d1af81660175be1450cfb7b3575f3d17a5b8a130bff87b781"
          },
          "contracts/modules/DeptBasics.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nuses: addys\nimplements: dept\n\nimport contracts.modules.Addys as addys\nimport interfaces.Department as dept\nfrom ethereum.ercs import IERC20\n\nevent DepartmentPauseModified:\n    isPaused: bool\n\nevent DepartmentFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    balance: uint256\n\nisPaused: public(bool)\n\nCAN_MINT_UNDY: immutable(bool)\nMAX_RECOVER_ASSETS: constant(uint256) = 20\n\n\n@deploy\ndef __init__(_shouldPause: bool, _canMintUndy: bool):\n    self.isPaused = _shouldPause\n    CAN_MINT_UNDY = _canMintUndy\n\n\n###########\n# Minting #\n###########\n\n\n@view\n@external\ndef canMintUndy() -> bool:\n    return CAN_MINT_UNDY\n\n\n########\n# Undy #\n########\n\n\n# activate\n\n\n@external\ndef pause(_shouldPause: bool):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert _shouldPause != self.isPaused # dev: no change\n    self.isPaused = _shouldPause\n    log DepartmentPauseModified(isPaused=_shouldPause)\n\n\n# recover funds\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    self._recoverFunds(_recipient, _asset)\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, MAX_RECOVER_ASSETS]):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    for a: address in _assets:\n        self._recoverFunds(_recipient, a)\n\n\n@internal\ndef _recoverFunds(_recipient: address, _asset: address):\n    assert empty(address) not in [_recipient, _asset] # dev: invalid recipient or asset\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    assert balance != 0 # dev: nothing to recover\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log DepartmentFundsRecovered(asset=_asset, recipient=_recipient, balance=balance)\n",
            "sha256sum": "976a50a3807bcf71f3f1c57de5cd7a59fe4e8f27b4d4560e774073962f44d1ac"
          },
          "contracts/legos/LegoTools.vy": {
            "content": "#     __                   _____         _     \n#    |  |   ___ ___ ___   |_   _|___ ___| |___ \n#    |  |__| -_| . | . |    | | | . | . | |_ -|\n#    |_____|___|_  |___|    |_| |___|___|_|___|\n#              |___|                           \n#\n#     \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n#     \u2551  ** Lego Tools **                         \u2551\n#     \u2551  Tools for interacting with the legos.    \u2551\n#     \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n#\n#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nimplements: Department\n\nexports: addys.__interface__\nexports: deptBasics.__interface__\n\ninitializes: addys\ninitializes: deptBasics[addys := addys]\n\nfrom interfaces import LegoPartner\nfrom interfaces import YieldLego\nfrom interfaces import DexLego\nfrom interfaces import Department\n\nimport contracts.modules.Addys as addys\nimport contracts.modules.DeptBasics as deptBasics\nfrom ethereum.ercs import IERC20\n\ninterface LegoDexNonStandard:\n    def getSwapAmountOut(_pool: address, _tokenIn: address, _tokenOut: address, _amountIn: uint256) -> uint256: nonpayable\n    def getSwapAmountIn(_pool: address, _tokenIn: address, _tokenOut: address, _amountOut: uint256) -> uint256: nonpayable\n    def getBestSwapAmountIn(_tokenIn: address, _tokenOut: address, _amountOut: uint256) -> (address, uint256): nonpayable\n    def getBestSwapAmountOut(_tokenIn: address, _tokenOut: address, _amountIn: uint256) -> (address, uint256): nonpayable\n\ninterface Registry:\n    def getAddrInfo(_regId: uint256) -> AddressInfo: view\n    def isValidRegId(_regId: uint256) -> bool: view\n    def getAddr(_regId: uint256) -> address: view\n    def numAddrs() -> uint256: view\n\ninterface Appraiser:\n    def getUsdValue(_asset: address, _amount: uint256) -> uint256: view\n\nstruct AddressInfo:\n    addr: address\n    version: uint256\n    lastModified: uint256\n    description: String[64]\n\nstruct SwapRoute:\n    legoId: uint256\n    pool: address\n    tokenIn: address\n    tokenOut: address\n    amountIn: uint256\n    amountOut: uint256\n\nstruct SwapInstruction:\n    legoId: uint256\n    amountIn: uint256\n    minAmountOut: uint256\n    tokenPath: DynArray[address, MAX_TOKEN_PATH]\n    poolPath: DynArray[address, MAX_TOKEN_PATH - 1]\n\nstruct UnderlyingData:\n    asset: address\n    amount: uint256\n    usdValue: uint256\n    legoId: uint256\n    legoAddr: address\n    legoDesc: String[64]\n\nstruct VaultTokenInfo:\n    legoId: uint256\n    vaultToken: address\n\n# key router tokens\nROUTER_TOKENA: public(immutable(address))\nROUTER_TOKENB: public(immutable(address))\n\n# yield lego ids\nAAVE_V3_ID: public(immutable(uint256))\nCOMPOUND_V3_ID: public(immutable(uint256))\nEULER_ID: public(immutable(uint256))\nFLUID_ID: public(immutable(uint256))\nMOONWELL_ID: public(immutable(uint256))\nMORPHO_ID: public(immutable(uint256))\n\n# dex lego ids\nUNISWAP_V2_ID: public(immutable(uint256))\nUNISWAP_V3_ID: public(immutable(uint256))\nAERODROME_ID: public(immutable(uint256))\nAERODROME_SLIPSTREAM_ID: public(immutable(uint256))\nCURVE_ID: public(immutable(uint256))\n\nMAX_VAULTS_FOR_USER: constant(uint256) = 50\nMAX_VAULTS: constant(uint256) = 40\nMAX_ROUTES: constant(uint256) = 10\nMAX_TOKEN_PATH: constant(uint256) = 5\nMAX_SWAP_INSTRUCTIONS: constant(uint256) = 5\nMAX_LEGOS: constant(uint256) = 10\nHUNDRED_PERCENT: constant(uint256) = 100_00 # 100%\n\n\n@deploy\ndef __init__(\n    _undyHq: address,\n    _routerTokenA: address,\n    _routerTokenB: address,\n    # yield lego ids\n    _aaveV3Id: uint256,\n    _compoundV3Id: uint256,\n    _eulerId: uint256,\n    _fluidId: uint256,\n    _moonwellId: uint256,\n    _morphoId: uint256,\n    # dex lego ids\n    _uniswapV2Id: uint256,\n    _uniswapV3Id: uint256,\n    _aerodromeId: uint256,\n    _aerodromeSlipstreamId: uint256,\n    _curveId: uint256,\n):\n    addys.__init__(_undyHq)\n    deptBasics.__init__(False, False) # no minting\n\n    assert empty(address) not in [_routerTokenA, _routerTokenB] # dev: invalid address\n    ROUTER_TOKENA = _routerTokenA\n    ROUTER_TOKENB = _routerTokenB\n\n    # yield lego ids\n    legoBook: address = addys._getLegoBookAddr()\n    assert staticcall Registry(legoBook).isValidRegId(_aaveV3Id) # dev: invalid id\n    assert staticcall Registry(legoBook).isValidRegId(_compoundV3Id) # dev: invalid id\n    assert staticcall Registry(legoBook).isValidRegId(_eulerId) # dev: invalid id\n    assert staticcall Registry(legoBook).isValidRegId(_fluidId) # dev: invalid id\n    assert staticcall Registry(legoBook).isValidRegId(_moonwellId) # dev: invalid id\n    assert staticcall Registry(legoBook).isValidRegId(_morphoId) # dev: invalid id\n\n    AAVE_V3_ID = _aaveV3Id\n    COMPOUND_V3_ID = _compoundV3Id\n    EULER_ID = _eulerId\n    FLUID_ID = _fluidId\n    MOONWELL_ID = _moonwellId\n    MORPHO_ID = _morphoId\n\n    # dex lego ids\n    assert staticcall Registry(legoBook).isValidRegId(_uniswapV2Id) # dev: invalid id\n    assert staticcall Registry(legoBook).isValidRegId(_uniswapV3Id) # dev: invalid id\n    assert staticcall Registry(legoBook).isValidRegId(_aerodromeId) # dev: invalid id\n    assert staticcall Registry(legoBook).isValidRegId(_aerodromeSlipstreamId) # dev: invalid id\n    assert staticcall Registry(legoBook).isValidRegId(_curveId) # dev: invalid id\n\n    UNISWAP_V2_ID = _uniswapV2Id\n    UNISWAP_V3_ID = _uniswapV3Id\n    AERODROME_ID = _aerodromeId\n    AERODROME_SLIPSTREAM_ID = _aerodromeSlipstreamId\n    CURVE_ID = _curveId\n\n\n###############\n# Yield Legos #\n###############\n\n\n@view\n@external\ndef aaveV3() -> address:\n    return staticcall Registry(addys._getLegoBookAddr()).getAddr(AAVE_V3_ID)\n\n\n@view\n@external\ndef aaveV3Id() -> uint256:\n    return AAVE_V3_ID\n\n\n@view\n@external\ndef compoundV3() -> address:\n    return staticcall Registry(addys._getLegoBookAddr()).getAddr(COMPOUND_V3_ID)\n\n\n@view\n@external\ndef compoundV3Id() -> uint256:\n    return COMPOUND_V3_ID\n\n\n@view\n@external\ndef euler() -> address:\n    return staticcall Registry(addys._getLegoBookAddr()).getAddr(EULER_ID)\n\n\n@view\n@external\ndef eulerId() -> uint256:\n    return EULER_ID\n\n\n@view\n@external\ndef fluid() -> address:\n    return staticcall Registry(addys._getLegoBookAddr()).getAddr(FLUID_ID)\n\n\n@view\n@external\ndef fluidId() -> uint256:\n    return FLUID_ID\n\n\n@view\n@external\ndef moonwell() -> address:\n    return staticcall Registry(addys._getLegoBookAddr()).getAddr(MOONWELL_ID)\n\n\n@view\n@external\ndef moonwellId() -> uint256:\n    return MOONWELL_ID\n\n\n@view\n@external\ndef morpho() -> address:\n    return staticcall Registry(addys._getLegoBookAddr()).getAddr(MORPHO_ID)\n\n\n@view\n@external\ndef morphoId() -> uint256:\n    return MORPHO_ID\n\n\n#############\n# DEX Legos #\n#############\n\n\n@view\n@external\ndef uniswapV2() -> address:\n    return staticcall Registry(addys._getLegoBookAddr()).getAddr(UNISWAP_V2_ID)\n\n\n@view\n@external\ndef uniswapV2Id() -> uint256:\n    return UNISWAP_V2_ID\n\n\n@view\n@external\ndef uniswapV3() -> address:\n    return staticcall Registry(addys._getLegoBookAddr()).getAddr(UNISWAP_V3_ID)\n\n\n@view\n@external\ndef uniswapV3Id() -> uint256:\n    return UNISWAP_V3_ID\n\n\n@view\n@external\ndef aerodrome() -> address:\n    return staticcall Registry(addys._getLegoBookAddr()).getAddr(AERODROME_ID)\n\n\n@view\n@external\ndef aerodromeId() -> uint256:\n    return AERODROME_ID\n\n\n@view\n@external\ndef aerodromeSlipstream() -> address:\n    return staticcall Registry(addys._getLegoBookAddr()).getAddr(AERODROME_SLIPSTREAM_ID)\n\n\n@view\n@external\ndef aerodromeSlipstreamId() -> uint256:\n    return AERODROME_SLIPSTREAM_ID\n\n\n@view\n@external\ndef curve() -> address:\n    return staticcall Registry(addys._getLegoBookAddr()).getAddr(CURVE_ID)\n\n\n@view\n@external\ndef curveId() -> uint256:\n    return CURVE_ID\n\n\n#################\n# Yield Helpers #\n#################\n\n\n# get underlying asset (given a vault token)\n\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address, _legoBook: address = empty(address)) -> address:\n    if _vaultToken == empty(address):\n        return empty(address)\n\n    legoBook: address = _legoBook\n    if _legoBook == empty(address):\n        legoBook = addys._getLegoBookAddr()\n\n    numLegos: uint256 = staticcall Registry(legoBook).numAddrs()\n    if numLegos == 0:\n        return empty(address)\n\n    for i: uint256 in range(1, numLegos, bound=max_value(uint256)):\n        legoAddr: address = staticcall Registry(legoBook).getAddr(i)\n        if not staticcall LegoPartner(legoAddr).isYieldLego():\n            continue\n\n        asset: address = staticcall YieldLego(legoAddr).getUnderlyingAsset(_vaultToken)\n        if asset != empty(address):\n            return asset\n\n    return empty(address)\n\n\n# get underlying amount (given user and underlying asset)\n\n\n@view\n@external\ndef getUnderlyingForUser(_user: address, _asset: address, _legoBook: address = empty(address)) -> uint256:\n    if empty(address) in [_user, _asset]:\n        return 0\n\n    legoBook: address = _legoBook\n    if _legoBook == empty(address):\n        legoBook = addys._getLegoBookAddr()\n\n    numLegos: uint256 = staticcall Registry(legoBook).numAddrs()\n    if numLegos == 0:\n        return 0\n\n    totalDeposited: uint256 = 0\n    for i: uint256 in range(1, numLegos, bound=max_value(uint256)):\n        legoAddr: address = staticcall Registry(legoBook).getAddr(i)\n        if not staticcall LegoPartner(legoAddr).isYieldLego():\n            continue\n\n        legoVaultTokens: DynArray[address, MAX_VAULTS] = staticcall YieldLego(legoAddr).getAssetOpportunities(_asset)\n        if len(legoVaultTokens) == 0:\n            continue\n\n        for vaultToken: address in legoVaultTokens:\n            if vaultToken == empty(address):\n                continue\n            vaultTokenBal: uint256 = staticcall IERC20(vaultToken).balanceOf(_user)\n            if vaultTokenBal != 0:\n                totalDeposited += staticcall YieldLego(legoAddr).getUnderlyingAmount(vaultToken, vaultTokenBal)\n\n    return totalDeposited\n\n\n# get all vault tokens (given user and underlying asset)\n\n\n@view\n@external\ndef getVaultTokensForUser(_user: address, _asset: address, _legoBook: address = empty(address)) -> DynArray[VaultTokenInfo, MAX_VAULTS_FOR_USER]:\n    if empty(address) in [_user, _asset]:\n        return []\n\n    legoBook: address = _legoBook\n    if _legoBook == empty(address):\n        legoBook = addys._getLegoBookAddr()\n\n    numLegos: uint256 = staticcall Registry(legoBook).numAddrs()\n    if numLegos == 0:\n        return []\n\n    vaultTokens: DynArray[VaultTokenInfo, MAX_VAULTS_FOR_USER] = []\n    for i: uint256 in range(1, numLegos, bound=max_value(uint256)):\n        legoAddr: address = staticcall Registry(legoBook).getAddr(i)\n        if not staticcall LegoPartner(legoAddr).isYieldLego():\n            continue\n\n        legoVaultTokens: DynArray[address, MAX_VAULTS] = staticcall YieldLego(legoAddr).getAssetOpportunities(_asset)\n        if len(legoVaultTokens) == 0:\n            continue\n\n        for vaultToken: address in legoVaultTokens:\n            if vaultToken == empty(address):\n                continue\n            if staticcall IERC20(vaultToken).balanceOf(_user) != 0:\n                vaultTokens.append(VaultTokenInfo(\n                    legoId=i,\n                    vaultToken=vaultToken\n                ))\n\n    return vaultTokens\n\n\n# is vault token (given a vault token)\n\n\n@view\n@external\ndef isVaultToken(_vaultToken: address, _legoBook: address = empty(address)) -> bool:\n    if _vaultToken == empty(address):\n        return False\n\n    legoBook: address = _legoBook\n    if _legoBook == empty(address):\n        legoBook = addys._getLegoBookAddr()\n\n    numLegos: uint256 = staticcall Registry(legoBook).numAddrs()\n    if numLegos == 0:\n        return False\n\n    for i: uint256 in range(1, numLegos, bound=max_value(uint256)):\n        legoAddr: address = staticcall Registry(legoBook).getAddr(i)\n        if not staticcall LegoPartner(legoAddr).isYieldLego():\n            continue\n\n        if staticcall YieldLego(legoAddr).isLegoAsset(_vaultToken):\n            return True\n\n    return False\n\n\n# get vault token amount (given an underlying asset, underlying amount, and vault token)\n\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address, _legoBook: address = empty(address)) -> uint256:\n    if _assetAmount == 0 or _asset == empty(address) or _vaultToken == empty(address):\n        return 0\n\n    legoBook: address = _legoBook\n    if _legoBook == empty(address):\n        legoBook = addys._getLegoBookAddr()\n\n    numLegos: uint256 = staticcall Registry(legoBook).numAddrs()\n    if numLegos == 0:\n        return 0\n\n    for i: uint256 in range(1, numLegos, bound=max_value(uint256)):\n        legoAddr: address = staticcall Registry(legoBook).getAddr(i)\n        if not staticcall LegoPartner(legoAddr).isYieldLego():\n            continue\n\n        vaultTokenAmount: uint256 = staticcall YieldLego(legoAddr).getVaultTokenAmount(_asset, _assetAmount, _vaultToken)\n        if vaultTokenAmount != 0:\n            return vaultTokenAmount\n\n    return 0\n\n\n# get lego info (given a vault token)\n\n\n@view\n@external\ndef getLegoInfoFromVaultToken(_vaultToken: address, _legoBook: address = empty(address)) -> (uint256, address, String[64]):\n    if _vaultToken == empty(address):\n        return 0, empty(address), \"\"\n\n    legoBook: address = _legoBook\n    if _legoBook == empty(address):\n        legoBook = addys._getLegoBookAddr()\n\n    numLegos: uint256 = staticcall Registry(legoBook).numAddrs()\n    if numLegos == 0:\n        return 0, empty(address), \"\"\n\n    for i: uint256 in range(1, numLegos, bound=max_value(uint256)):\n        legoInfo: AddressInfo = staticcall Registry(legoBook).getAddrInfo(i)\n        if not staticcall LegoPartner(legoInfo.addr).isYieldLego():\n            continue\n\n        if staticcall YieldLego(legoInfo.addr).isLegoAsset(_vaultToken):\n            return i, legoInfo.addr, legoInfo.description\n\n    return 0, empty(address), \"\"\n\n\n# get underlying data (given an underlying asset, underlying amount)\n\n\n@view\n@external\ndef getUnderlyingData(_asset: address, _amount: uint256, _legoBook: address = empty(address)) -> UnderlyingData:\n    if _amount == 0 or _asset == empty(address):\n        return empty(UnderlyingData)\n\n    legoBook: address = _legoBook\n    if _legoBook == empty(address):\n        legoBook = addys._getLegoBookAddr()\n\n    numLegos: uint256 = staticcall Registry(legoBook).numAddrs()\n    if numLegos == 0:\n        return empty(UnderlyingData)\n\n    appraiser: address = addys._getAppraiserAddr()\n    for i: uint256 in range(1, numLegos, bound=max_value(uint256)):\n        legoInfo: AddressInfo = staticcall Registry(legoBook).getAddrInfo(i)\n        if not staticcall LegoPartner(legoInfo.addr).isYieldLego():\n            continue\n\n        asset: address = empty(address)\n        underlyingAmount: uint256 = 0\n        usdValue: uint256 = 0\n        asset, underlyingAmount, usdValue = staticcall YieldLego(legoInfo.addr).getUnderlyingData(_asset, _amount, appraiser)\n        if asset != empty(address):\n            return UnderlyingData(\n                asset = asset,\n                amount = underlyingAmount,\n                usdValue = usdValue,\n                legoId = i,\n                legoAddr = legoInfo.addr,\n                legoDesc = legoInfo.description,\n            )\n\n    # fallback to appraiser\n    return UnderlyingData(\n        asset = _asset,\n        amount = _amount,\n        usdValue = staticcall Appraiser(appraiser).getUsdValue(_asset, _amount),\n        legoId = 0,\n        legoAddr = empty(address),\n        legoDesc = \"\",\n    )\n\n\n###############\n# Dex Helpers #\n###############\n\n\n# get routes and swap instructions (amountIn as input)\n\n\n@external\ndef getRoutesAndSwapInstructionsAmountOut(\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n    _slippage: uint256,\n    _includeLegoIds: DynArray[uint256, MAX_LEGOS] = [],\n) -> DynArray[SwapInstruction, MAX_SWAP_INSTRUCTIONS]:\n    routes: DynArray[SwapRoute, MAX_ROUTES] = self._getBestSwapRoutesAmountOut(_tokenIn, _tokenOut, _amountIn, _includeLegoIds)\n    return self._prepareSwapInstructionsAmountOut(_slippage, routes)\n\n\n# get routes and swap instructions (amountOut as input)\n\n\n@external\ndef getRoutesAndSwapInstructionsAmountIn(\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountOut: uint256,\n    _amountInAvailable: uint256,\n    _slippage: uint256,\n    _includeLegoIds: DynArray[uint256, MAX_LEGOS] = [],\n) -> DynArray[SwapInstruction, MAX_SWAP_INSTRUCTIONS]:\n    routes: DynArray[SwapRoute, MAX_ROUTES] = self._getBestSwapRoutesAmountIn(_tokenIn, _tokenOut, _amountOut, _includeLegoIds)\n    if len(routes) == 0:\n        return []\n\n    # let's re-run the routes with amountIn as input (this is more accurate, for example, Aerodrome doesn't have getAmountIn for stable pools\n    amountIn: uint256 = min(_amountInAvailable, routes[0].amountIn)\n    routes = self._getBestSwapRoutesAmountOut(_tokenIn, _tokenOut, amountIn, _includeLegoIds)\n    return self._prepareSwapInstructionsAmountOut(_slippage, routes)\n\n\n########################\n# Dex: Swap Amount Out #\n########################\n\n\n# prepare swap instructions (amountIn as input)\n\n\n@external\ndef prepareSwapInstructionsAmountOut(_slippage: uint256, _routes: DynArray[SwapRoute, MAX_ROUTES]) -> DynArray[SwapInstruction, MAX_SWAP_INSTRUCTIONS]:\n    return self._prepareSwapInstructionsAmountOut(_slippage, _routes)\n\n\n@internal\ndef _prepareSwapInstructionsAmountOut(_slippage: uint256, _routes: DynArray[SwapRoute, MAX_ROUTES]) -> DynArray[SwapInstruction, MAX_SWAP_INSTRUCTIONS]:\n    if len(_routes) == 0:\n        return []\n\n    instructions: DynArray[SwapInstruction, MAX_SWAP_INSTRUCTIONS] = []\n\n    # start with first route\n    prevRoute: SwapRoute = _routes[0]\n    prevInstruction: SwapInstruction = self._createNewInstruction(prevRoute, _slippage)\n\n    # iterate thru swap routes, skip first\n    for i: uint256 in range(1, len(_routes), bound=MAX_ROUTES):\n        newRoute: SwapRoute = _routes[i]\n        assert prevRoute.tokenOut == newRoute.tokenIn # dev: invalid route\n\n        # add to previous instruction\n        if prevRoute.legoId == newRoute.legoId:\n            prevInstruction.minAmountOut = newRoute.amountOut * (HUNDRED_PERCENT - _slippage) // HUNDRED_PERCENT\n            prevInstruction.tokenPath.append(newRoute.tokenOut)\n            prevInstruction.poolPath.append(newRoute.pool)\n\n        # create new instruction\n        else:\n            instructions.append(prevInstruction)\n            prevInstruction = self._createNewInstruction(newRoute, _slippage)\n\n        # set previous item\n        prevRoute = newRoute\n\n    # add last instruction\n    instructions.append(prevInstruction)\n    return instructions\n\n\n@view\n@internal\ndef _createNewInstruction(_route: SwapRoute, _slippage: uint256) -> SwapInstruction:\n    return SwapInstruction(\n        legoId=_route.legoId,\n        amountIn=_route.amountIn,\n        minAmountOut=_route.amountOut * (HUNDRED_PERCENT - _slippage) // HUNDRED_PERCENT,\n        tokenPath=[_route.tokenIn, _route.tokenOut],\n        poolPath=[_route.pool],\n    )\n\n\n# best swap routes (amountIn as input)\n\n\n@external\ndef getBestSwapRoutesAmountOut(\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n    _includeLegoIds: DynArray[uint256, MAX_LEGOS] = [],\n) -> DynArray[SwapRoute, MAX_ROUTES]:\n    return self._getBestSwapRoutesAmountOut(_tokenIn, _tokenOut, _amountIn, _includeLegoIds)\n\n\n@internal\ndef _getBestSwapRoutesAmountOut(\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n    _includeLegoIds: DynArray[uint256, MAX_LEGOS],\n) -> DynArray[SwapRoute, MAX_ROUTES]:\n    if _tokenIn == _tokenOut or _amountIn == 0 or empty(address) in [_tokenIn, _tokenOut]:\n        return []\n\n    bestSwapRoutes: DynArray[SwapRoute, MAX_ROUTES] = []\n\n    # required data\n    legoBook: address = addys._getLegoBookAddr()\n    numLegos: uint256 = staticcall Registry(legoBook).numAddrs()\n    routerTokenA: address = ROUTER_TOKENA\n    routerTokenB: address = ROUTER_TOKENB\n\n    # direct swap route\n    directSwapRoute: SwapRoute = self._getBestSwapAmountOutSinglePool(_tokenIn, _tokenOut, _amountIn, numLegos, legoBook, _includeLegoIds)\n\n    # check with router pools\n    withRouterHopAmountOut: uint256 = 0\n    withHopRoutes: DynArray[SwapRoute, MAX_ROUTES] = []\n    withRouterHopAmountOut, withHopRoutes = self._getBestSwapAmountOutWithRouterPool(routerTokenA, routerTokenB, _tokenIn, _tokenOut, _amountIn, numLegos, legoBook, _includeLegoIds)\n\n    # compare direct swap route with hop routes\n    if directSwapRoute.amountOut > withRouterHopAmountOut:\n        bestSwapRoutes = [directSwapRoute]\n\n    # update router token pool (if possible)\n    elif withRouterHopAmountOut != 0:\n        bestSwapRoutes = withHopRoutes\n\n    return bestSwapRoutes\n\n\n# check various routes via core router pools\n\n\n@external\ndef getBestSwapAmountOutWithRouterPool(\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n    _includeLegoIds: DynArray[uint256, MAX_LEGOS] = [],\n) -> (uint256, DynArray[SwapRoute, MAX_ROUTES]):\n    legoBook: address = addys._getLegoBookAddr()\n    numLegos: uint256 = staticcall Registry(legoBook).numAddrs()\n    return self._getBestSwapAmountOutWithRouterPool(ROUTER_TOKENA, ROUTER_TOKENB, _tokenIn, _tokenOut, _amountIn, numLegos, legoBook, _includeLegoIds)\n\n\n@internal\ndef _getBestSwapAmountOutWithRouterPool(\n    _routerTokenA: address,\n    _routerTokenB: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n    _numLegos: uint256,\n    _legoRegistry: address,\n    _includeLegoIds: DynArray[uint256, MAX_LEGOS],\n) -> (uint256, DynArray[SwapRoute, MAX_ROUTES]):\n\n    # nothing to do, already have router pool to use\n    if self._isRouterPool(_tokenIn, _tokenOut, _routerTokenA, _routerTokenB):\n        return 0, []\n\n    isMultiHop: bool = False\n    finalAmountOut: uint256 = 0\n    bestSwapRoutes: DynArray[SwapRoute, MAX_ROUTES] = []\n    firstRoute: SwapRoute = empty(SwapRoute)\n    secondRoute: SwapRoute = empty(SwapRoute)\n\n    # usdc -> weth -> tokenOut\n    if _tokenIn == _routerTokenA:\n        firstRoute = self._getSwapAmountOutViaRouterPool(_routerTokenA, _routerTokenB, _amountIn, _numLegos, _legoRegistry, _includeLegoIds)\n        if firstRoute.amountOut != 0:\n            secondRoute = self._getBestSwapAmountOutSinglePool(_routerTokenB, _tokenOut, firstRoute.amountOut, _numLegos, _legoRegistry, _includeLegoIds)\n\n    # tokenIn -> weth -> usdc\n    elif _tokenOut == _routerTokenA:\n        firstRoute = self._getBestSwapAmountOutSinglePool(_tokenIn, _routerTokenB, _amountIn, _numLegos, _legoRegistry, _includeLegoIds)\n        if firstRoute.amountOut != 0:\n            secondRoute = self._getSwapAmountOutViaRouterPool(_routerTokenB, _routerTokenA, firstRoute.amountOut, _numLegos, _legoRegistry, _includeLegoIds)\n\n    # weth -> usdc -> tokenOut\n    elif _tokenIn == _routerTokenB:\n        firstRoute = self._getSwapAmountOutViaRouterPool(_routerTokenB, _routerTokenA, _amountIn, _numLegos, _legoRegistry, _includeLegoIds)\n        if firstRoute.amountOut != 0:\n            secondRoute = self._getBestSwapAmountOutSinglePool(_routerTokenA, _tokenOut, firstRoute.amountOut, _numLegos, _legoRegistry, _includeLegoIds)\n\n    # tokenIn -> usdc -> weth\n    elif _tokenOut == _routerTokenB:\n        firstRoute = self._getBestSwapAmountOutSinglePool(_tokenIn, _routerTokenA, _amountIn, _numLegos, _legoRegistry, _includeLegoIds)\n        if firstRoute.amountOut != 0:\n            secondRoute = self._getSwapAmountOutViaRouterPool(_routerTokenA, _routerTokenB, firstRoute.amountOut, _numLegos, _legoRegistry, _includeLegoIds)\n\n    # let's try multi hop routes\n    else:\n        isMultiHop = True\n\n        # router token A as starting point\n        viaRouterTokenAAmountOut: uint256 = 0\n        viaRouterTokenARoutes: DynArray[SwapRoute, MAX_ROUTES] = []\n        viaRouterTokenAAmountOut, viaRouterTokenARoutes = self._checkRouterPoolForMiddleSwapAmountOut(_routerTokenA, _routerTokenB, _tokenIn, _tokenOut, _amountIn, _numLegos, _legoRegistry, _includeLegoIds)\n\n        # router token B as starting point\n        viaRouterTokenBAmountOut: uint256 = 0\n        viaRouterTokenBRoutes: DynArray[SwapRoute, MAX_ROUTES] = []\n        viaRouterTokenBAmountOut, viaRouterTokenBRoutes = self._checkRouterPoolForMiddleSwapAmountOut(_routerTokenB, _routerTokenA, _tokenIn, _tokenOut, _amountIn, _numLegos, _legoRegistry, _includeLegoIds)\n\n        # compare\n        if viaRouterTokenAAmountOut > viaRouterTokenBAmountOut:\n            finalAmountOut = viaRouterTokenAAmountOut\n            bestSwapRoutes = viaRouterTokenARoutes\n        elif viaRouterTokenBAmountOut != 0:\n            finalAmountOut = viaRouterTokenBAmountOut\n            bestSwapRoutes = viaRouterTokenBRoutes\n\n    if not isMultiHop:\n        finalAmountOut = secondRoute.amountOut\n        bestSwapRoutes = [firstRoute, secondRoute]\n\n    return finalAmountOut, bestSwapRoutes\n\n\n@internal\ndef _checkRouterPoolForMiddleSwapAmountOut(\n    _firstRouterTokenHop: address,\n    _secondRouterTokenHop: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n    _numLegos: uint256,\n    _legoRegistry: address,\n    _includeLegoIds: DynArray[uint256, MAX_LEGOS],\n) -> (uint256, DynArray[SwapRoute, MAX_ROUTES]):\n    secondHopToTokenOut: SwapRoute = empty(SwapRoute)\n\n    # tokenIn -> first Router Token\n    tokenInToFirstHop: SwapRoute = self._getBestSwapAmountOutSinglePool(_tokenIn, _firstRouterTokenHop, _amountIn, _numLegos, _legoRegistry, _includeLegoIds)\n    if tokenInToFirstHop.amountOut == 0:\n        return 0, []\n\n    # first Router Token -> tokenOut\n    firstHopToTokenOut: SwapRoute = self._getBestSwapAmountOutSinglePool(_firstRouterTokenHop, _tokenOut, tokenInToFirstHop.amountOut, _numLegos, _legoRegistry, _includeLegoIds)\n\n    # first Router Token -> second Router Token -- this will always happen in router pools (i.e. usdc <-> weth)\n    firstHopToSecondHop: SwapRoute = self._getSwapAmountOutViaRouterPool(_firstRouterTokenHop, _secondRouterTokenHop, tokenInToFirstHop.amountOut, _numLegos, _legoRegistry, _includeLegoIds)\n\n    # second Router Token -> tokenOut\n    if firstHopToSecondHop.amountOut != 0:\n        secondHopToTokenOut = self._getBestSwapAmountOutSinglePool(_secondRouterTokenHop, _tokenOut, firstHopToSecondHop.amountOut, _numLegos, _legoRegistry, _includeLegoIds)\n\n    # compare routes\n    if firstHopToTokenOut.amountOut > secondHopToTokenOut.amountOut:\n        return firstHopToTokenOut.amountOut, [tokenInToFirstHop, firstHopToTokenOut]\n    elif secondHopToTokenOut.amountOut != 0:\n        return secondHopToTokenOut.amountOut, [tokenInToFirstHop, firstHopToSecondHop, secondHopToTokenOut]\n    return 0, []\n\n\n# single pool\n\n\n@external\ndef getBestSwapAmountOutSinglePool(\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n    _includeLegoIds: DynArray[uint256, MAX_LEGOS] = [],\n) -> SwapRoute:\n    legoBook: address = addys._getLegoBookAddr()\n    numLegos: uint256 = staticcall Registry(legoBook).numAddrs()\n    return self._getBestSwapAmountOutSinglePool(_tokenIn, _tokenOut, _amountIn, numLegos, legoBook, _includeLegoIds)\n\n\n@internal\ndef _getBestSwapAmountOutSinglePool(\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n    _numLegos: uint256,\n    _legoRegistry: address,\n    _includeLegoIds: DynArray[uint256, MAX_LEGOS],\n) -> SwapRoute:\n\n    bestRoute: SwapRoute = SwapRoute(\n        legoId=0,\n        pool=empty(address),\n        tokenIn=_tokenIn,\n        tokenOut=_tokenOut,\n        amountIn=_amountIn,\n        amountOut=0,\n    )\n\n    if _numLegos == 0:\n        return bestRoute\n\n    shouldCheckLegoIds: bool = len(_includeLegoIds) != 0\n    for i: uint256 in range(1, _numLegos, bound=max_value(uint256)):\n\n        # skip if we should check lego ids and it's not in the list\n        if shouldCheckLegoIds and i not in _includeLegoIds:\n            continue\n\n        # get lego addr\n        legoAddr: address = staticcall Registry(_legoRegistry).getAddr(i)\n        if not staticcall LegoPartner(legoAddr).isDexLego():\n            continue\n\n        pool: address = empty(address)\n        amountOut: uint256 = 0\n        if i in [UNISWAP_V3_ID, AERODROME_SLIPSTREAM_ID]:\n            pool, amountOut = extcall LegoDexNonStandard(legoAddr).getBestSwapAmountOut(_tokenIn, _tokenOut, _amountIn)\n        else:\n            pool, amountOut = staticcall DexLego(legoAddr).getBestSwapAmountOut(_tokenIn, _tokenOut, _amountIn)\n\n        # compare best\n        if pool != empty(address) and amountOut > bestRoute.amountOut:\n            bestRoute.pool = pool\n            bestRoute.amountOut = amountOut\n            bestRoute.legoId = i\n\n    return bestRoute\n\n\n# router pool only\n\n\n@external\ndef getSwapAmountOutViaRouterPool(\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n    _includeLegoIds: DynArray[uint256, MAX_LEGOS] = [],\n) -> SwapRoute:\n    legoBook: address = addys._getLegoBookAddr()\n    numLegos: uint256 = staticcall Registry(legoBook).numAddrs()\n    return self._getSwapAmountOutViaRouterPool(_tokenIn, _tokenOut, _amountIn, numLegos, legoBook, _includeLegoIds)\n\n\n@internal\ndef _getSwapAmountOutViaRouterPool(\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n    _numLegos: uint256,\n    _legoRegistry: address,\n    _includeLegoIds: DynArray[uint256, MAX_LEGOS],\n) -> SwapRoute:\n\n    # NOTE: _tokenIn and _tokenOut need to be ROUTER_TOKENA/ROUTER_TOKENB -- in the `getCoreRouterPool()` pool\n\n    bestRoute: SwapRoute = SwapRoute(\n        legoId=0,\n        pool=empty(address),\n        tokenIn=_tokenIn,\n        tokenOut=_tokenOut,\n        amountIn=_amountIn,\n        amountOut=0,\n    )\n\n    if _numLegos == 0:\n        return bestRoute\n\n    shouldCheckLegoIds: bool = len(_includeLegoIds) != 0\n    for i: uint256 in range(1, _numLegos, bound=max_value(uint256)):\n\n        # skip if we should check lego ids and it's not in the list\n        if shouldCheckLegoIds and i not in _includeLegoIds:\n            continue\n\n        # get lego addr\n        legoAddr: address = staticcall Registry(_legoRegistry).getAddr(i)\n        if not staticcall LegoPartner(legoAddr).isDexLego():\n            continue\n\n        pool: address = staticcall DexLego(legoAddr).getCoreRouterPool()\n        if pool == empty(address):\n            continue\n\n        amountOut: uint256 = 0\n        if i in [UNISWAP_V3_ID, AERODROME_SLIPSTREAM_ID]:\n            amountOut = extcall LegoDexNonStandard(legoAddr).getSwapAmountOut(pool, _tokenIn, _tokenOut, _amountIn)\n        else:\n            amountOut = staticcall DexLego(legoAddr).getSwapAmountOut(pool, _tokenIn, _tokenOut, _amountIn)\n\n        # compare best\n        if amountOut > bestRoute.amountOut:\n            bestRoute.pool = pool\n            bestRoute.amountOut = amountOut\n            bestRoute.legoId = i\n\n    return bestRoute\n\n\n#######################\n# Dex: Swap Amount In #\n#######################\n\n\n# best swap routes (amountOut as input)\n\n\n@external\ndef getBestSwapRoutesAmountIn(\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountOut: uint256,\n    _includeLegoIds: DynArray[uint256, MAX_LEGOS] = [],\n) -> DynArray[SwapRoute, MAX_ROUTES]:\n    return self._getBestSwapRoutesAmountIn(_tokenIn, _tokenOut, _amountOut, _includeLegoIds)\n\n\n@internal\ndef _getBestSwapRoutesAmountIn(\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountOut: uint256,\n    _includeLegoIds: DynArray[uint256, MAX_LEGOS],\n) -> DynArray[SwapRoute, MAX_ROUTES]:\n    if _tokenIn == _tokenOut or _amountOut == 0 or empty(address) in [_tokenIn, _tokenOut]:\n        return []\n\n    bestSwapRoutes: DynArray[SwapRoute, MAX_ROUTES] = []\n\n    # required data\n    legoBook: address = addys._getLegoBookAddr()\n    numLegos: uint256 = staticcall Registry(legoBook).numAddrs()\n    routerTokenA: address = ROUTER_TOKENA\n    routerTokenB: address = ROUTER_TOKENB\n\n    # direct swap route\n    directSwapRoute: SwapRoute = self._getBestSwapAmountInSinglePool(_tokenIn, _tokenOut, _amountOut, numLegos, legoBook, _includeLegoIds)\n\n    # check with router pools\n    withRouterHopAmountIn: uint256 = 0\n    withHopRoutes: DynArray[SwapRoute, MAX_ROUTES] = []\n    withRouterHopAmountIn, withHopRoutes = self._getBestSwapAmountInWithRouterPool(routerTokenA, routerTokenB, _tokenIn, _tokenOut, _amountOut, numLegos, legoBook, _includeLegoIds)\n\n    # compare direct swap route with hop routes\n    if directSwapRoute.amountIn < withRouterHopAmountIn:\n        bestSwapRoutes = [directSwapRoute]\n\n    # update router token pool (if possible)\n    elif withRouterHopAmountIn != max_value(uint256):\n        bestSwapRoutes = withHopRoutes\n\n    return bestSwapRoutes\n\n\n# check various routes via core router pools\n\n\n@external\ndef getBestSwapAmountInWithRouterPool(\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountOut: uint256,\n    _includeLegoIds: DynArray[uint256, MAX_LEGOS] = [],\n) -> (uint256, DynArray[SwapRoute, MAX_ROUTES]):\n    legoBook: address = addys._getLegoBookAddr()\n    numLegos: uint256 = staticcall Registry(legoBook).numAddrs()\n    return self._getBestSwapAmountInWithRouterPool(ROUTER_TOKENA, ROUTER_TOKENB, _tokenIn, _tokenOut, _amountOut, numLegos, legoBook, _includeLegoIds)\n\n\n@internal\ndef _getBestSwapAmountInWithRouterPool(\n    _routerTokenA: address,\n    _routerTokenB: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountOut: uint256,\n    _numLegos: uint256,\n    _legoRegistry: address,\n    _includeLegoIds: DynArray[uint256, MAX_LEGOS],\n) -> (uint256, DynArray[SwapRoute, MAX_ROUTES]):\n\n    # nothing to do, already have router pool to use\n    if self._isRouterPool(_tokenIn, _tokenOut, _routerTokenA, _routerTokenB):\n        return max_value(uint256), []\n\n    isMultiHop: bool = False\n    finalAmountIn: uint256 = max_value(uint256)\n    bestSwapRoutes: DynArray[SwapRoute, MAX_ROUTES] = []\n    firstRoute: SwapRoute = empty(SwapRoute)\n    secondRoute: SwapRoute = empty(SwapRoute)\n\n    # usdc -> weth -> tokenOut\n    if _tokenIn == _routerTokenA:\n        secondRoute = self._getBestSwapAmountInSinglePool(_routerTokenB, _tokenOut, _amountOut, _numLegos, _legoRegistry, _includeLegoIds)\n        if secondRoute.amountIn != max_value(uint256):\n            firstRoute = self._getSwapAmountInViaRouterPool(_routerTokenA, _routerTokenB, secondRoute.amountIn, _numLegos, _legoRegistry, _includeLegoIds)\n\n    # tokenIn -> weth -> usdc\n    elif _tokenOut == _routerTokenA:\n        secondRoute = self._getSwapAmountInViaRouterPool(_routerTokenB, _routerTokenA, _amountOut, _numLegos, _legoRegistry, _includeLegoIds)\n        if secondRoute.amountIn != max_value(uint256):\n            firstRoute = self._getBestSwapAmountInSinglePool(_tokenIn, _routerTokenB, secondRoute.amountIn, _numLegos, _legoRegistry, _includeLegoIds)\n\n    # weth -> usdc -> tokenOut\n    elif _tokenIn == _routerTokenB:\n        secondRoute = self._getBestSwapAmountInSinglePool(_routerTokenA, _tokenOut, _amountOut, _numLegos, _legoRegistry, _includeLegoIds)\n        if secondRoute.amountIn != max_value(uint256):\n            firstRoute = self._getSwapAmountInViaRouterPool(_routerTokenB, _routerTokenA, secondRoute.amountIn, _numLegos, _legoRegistry, _includeLegoIds)\n\n    # tokenIn -> usdc -> weth\n    elif _tokenOut == _routerTokenB:\n        secondRoute = self._getSwapAmountInViaRouterPool(_routerTokenA, _routerTokenB, _amountOut, _numLegos, _legoRegistry, _includeLegoIds)\n        if secondRoute.amountIn != max_value(uint256):\n            firstRoute = self._getBestSwapAmountInSinglePool(_tokenIn, _routerTokenA, secondRoute.amountIn, _numLegos, _legoRegistry, _includeLegoIds)\n\n    # let's try multi hop routes\n    else:\n        isMultiHop = True\n\n        # router token A as starting point\n        viaRouterTokenAAmountIn: uint256 = 0\n        viaRouterTokenARoutes: DynArray[SwapRoute, MAX_ROUTES] = []\n        viaRouterTokenAAmountIn, viaRouterTokenARoutes = self._checkRouterPoolForMiddleSwapAmountIn(_routerTokenA, _routerTokenB, _tokenIn, _tokenOut, _amountOut, _numLegos, _legoRegistry, _includeLegoIds)\n\n        # router token B as starting point\n        viaRouterTokenBAmountIn: uint256 = 0\n        viaRouterTokenBRoutes: DynArray[SwapRoute, MAX_ROUTES] = []\n        viaRouterTokenBAmountIn, viaRouterTokenBRoutes = self._checkRouterPoolForMiddleSwapAmountIn(_routerTokenB, _routerTokenA, _tokenIn, _tokenOut, _amountOut, _numLegos, _legoRegistry, _includeLegoIds)\n\n        # compare\n        if viaRouterTokenAAmountIn < viaRouterTokenBAmountIn:\n            finalAmountIn = viaRouterTokenAAmountIn\n            bestSwapRoutes = viaRouterTokenARoutes\n        elif viaRouterTokenBAmountIn != max_value(uint256):\n            finalAmountIn = viaRouterTokenBAmountIn\n            bestSwapRoutes = viaRouterTokenBRoutes\n\n    if not isMultiHop:\n        finalAmountIn = firstRoute.amountIn\n        bestSwapRoutes = [firstRoute, secondRoute]\n\n    return finalAmountIn, bestSwapRoutes\n\n\n@internal\ndef _checkRouterPoolForMiddleSwapAmountIn(\n    _firstRouterToken: address,\n    _secondRouterToken: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountOut: uint256,\n    _numLegos: uint256,\n    _legoRegistry: address,\n    _includeLegoIds: DynArray[uint256, MAX_LEGOS],\n) -> (uint256, DynArray[SwapRoute, MAX_ROUTES]):\n    tokenInToFirstHop: SwapRoute = empty(SwapRoute)\n    tokenInToFirstHop.amountIn = max_value(uint256)\n\n    # second Router Token -> tokenOut\n    secondHopToTokenOut: SwapRoute = self._getBestSwapAmountInSinglePool(_secondRouterToken, _tokenOut, _amountOut, _numLegos, _legoRegistry, _includeLegoIds)\n    if secondHopToTokenOut.amountIn == max_value(uint256):\n        return max_value(uint256), []\n\n    # tokenIn -> second Router Token\n    tokenInToSecondHop: SwapRoute = self._getBestSwapAmountInSinglePool(_tokenIn, _secondRouterToken, secondHopToTokenOut.amountIn, _numLegos, _legoRegistry, _includeLegoIds)\n\n    # first Router Token -> second Router Token -- this will always happen in router pools (i.e. usdc <-> weth)\n    firstHopToSecondHop: SwapRoute = self._getSwapAmountInViaRouterPool(_firstRouterToken, _secondRouterToken, secondHopToTokenOut.amountIn, _numLegos, _legoRegistry, _includeLegoIds)\n\n    # tokenIn -> first Router Token\n    if firstHopToSecondHop.amountIn != max_value(uint256):\n        tokenInToFirstHop = self._getBestSwapAmountInSinglePool(_tokenIn, _firstRouterToken, firstHopToSecondHop.amountIn, _numLegos, _legoRegistry, _includeLegoIds)\n\n    # compare routes\n    if tokenInToSecondHop.amountIn < tokenInToFirstHop.amountIn:\n        return tokenInToSecondHop.amountIn, [tokenInToSecondHop, secondHopToTokenOut]\n    elif tokenInToFirstHop.amountIn != max_value(uint256):\n        return tokenInToFirstHop.amountIn, [tokenInToFirstHop, firstHopToSecondHop, secondHopToTokenOut]\n    return max_value(uint256), []\n\n\n# single pool\n\n\n@external\ndef getBestSwapAmountInSinglePool(\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountOut: uint256,\n    _includeLegoIds: DynArray[uint256, MAX_LEGOS] = [],\n) -> SwapRoute:\n    legoBook: address = addys._getLegoBookAddr()\n    numLegos: uint256 = staticcall Registry(legoBook).numAddrs()\n    return self._getBestSwapAmountInSinglePool(_tokenIn, _tokenOut, _amountOut, numLegos, legoBook, _includeLegoIds)\n\n\n@internal\ndef _getBestSwapAmountInSinglePool(\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountOut: uint256,\n    _numLegos: uint256,\n    _legoRegistry: address,\n    _includeLegoIds: DynArray[uint256, MAX_LEGOS],\n) -> SwapRoute:\n\n    bestRoute: SwapRoute = SwapRoute(\n        legoId=0,\n        pool=empty(address),\n        tokenIn=_tokenIn,\n        tokenOut=_tokenOut,\n        amountIn=max_value(uint256),\n        amountOut=_amountOut,\n    )\n\n    if _numLegos == 0:\n        return bestRoute\n\n    shouldCheckLegoIds: bool = len(_includeLegoIds) != 0\n    for i: uint256 in range(1, _numLegos, bound=max_value(uint256)):\n\n        # skip if we should check lego ids and it's not in the list\n        if shouldCheckLegoIds and i not in _includeLegoIds:\n            continue\n\n        # get lego addr\n        legoAddr: address = staticcall Registry(_legoRegistry).getAddr(i)\n        if not staticcall LegoPartner(legoAddr).isDexLego():\n            continue\n\n        pool: address = empty(address)\n        amountIn: uint256 = max_value(uint256)\n        if i in [UNISWAP_V3_ID, AERODROME_SLIPSTREAM_ID]:\n            pool, amountIn = extcall LegoDexNonStandard(legoAddr).getBestSwapAmountIn(_tokenIn, _tokenOut, _amountOut)\n        else:\n            pool, amountIn = staticcall DexLego(legoAddr).getBestSwapAmountIn(_tokenIn, _tokenOut, _amountOut)\n\n        # compare best\n        if pool != empty(address) and amountIn != 0 and amountIn < bestRoute.amountIn:\n            bestRoute.pool = pool\n            bestRoute.amountIn = amountIn\n            bestRoute.legoId = i\n\n    return bestRoute\n\n\n# router pool only\n\n\n@external\ndef getSwapAmountInViaRouterPool(\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountOut: uint256,\n    _includeLegoIds: DynArray[uint256, MAX_LEGOS] = [],\n) -> SwapRoute:\n    legoBook: address = addys._getLegoBookAddr()\n    numLegos: uint256 = staticcall Registry(legoBook).numAddrs()\n    return self._getSwapAmountInViaRouterPool(_tokenIn, _tokenOut, _amountOut, numLegos, legoBook, _includeLegoIds)\n\n\n@internal\ndef _getSwapAmountInViaRouterPool(\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountOut: uint256,\n    _numLegos: uint256,\n    _legoRegistry: address,\n    _includeLegoIds: DynArray[uint256, MAX_LEGOS],\n) -> SwapRoute:\n\n    # NOTE: _tokenIn and _tokenOut need to be ROUTER_TOKENA/ROUTER_TOKENB -- in the `getCoreRouterPool()` pool\n\n    bestRoute: SwapRoute = SwapRoute(\n        legoId=0,\n        pool=empty(address),\n        tokenIn=_tokenIn,\n        tokenOut=_tokenOut,\n        amountIn=max_value(uint256),\n        amountOut=_amountOut,\n    )\n\n    if _numLegos == 0:\n        return bestRoute\n\n    shouldCheckLegoIds: bool = len(_includeLegoIds) != 0\n    for i: uint256 in range(1, _numLegos, bound=max_value(uint256)):\n\n        # skip if we should check lego ids and it's not in the list\n        if shouldCheckLegoIds and i not in _includeLegoIds:\n            continue\n\n        # get lego addr\n        legoAddr: address = staticcall Registry(_legoRegistry).getAddr(i)\n        if not staticcall LegoPartner(legoAddr).isDexLego():\n            continue\n\n        # get router pool\n        pool: address = staticcall DexLego(legoAddr).getCoreRouterPool()\n        if pool == empty(address):\n            continue\n\n        amountIn: uint256 = max_value(uint256)\n        if i in [UNISWAP_V3_ID, AERODROME_SLIPSTREAM_ID]:\n            amountIn = extcall LegoDexNonStandard(legoAddr).getSwapAmountIn(pool, _tokenIn, _tokenOut, _amountOut)\n        else:\n            amountIn = staticcall DexLego(legoAddr).getSwapAmountIn(pool, _tokenIn, _tokenOut, _amountOut)\n\n        # compare best\n        if amountIn != 0 and amountIn < bestRoute.amountIn:\n            bestRoute.pool = pool\n            bestRoute.amountIn = amountIn\n            bestRoute.legoId = i\n\n    return bestRoute\n\n\n@view\n@internal\ndef _isRouterPool(_tokenIn: address, _tokenOut: address, _routerTokenA: address, _routerTokenB: address) -> bool:\n    return _tokenIn in [_routerTokenA, _routerTokenB] and _tokenOut in [_routerTokenA, _routerTokenB]\n",
            "sha256sum": "49f5359ad3c6b58b85c23c6517b030e21e5418473dbcffeb103bf31addfbbb8e"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/legos/LegoTools.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.3+commit.bff19ea2",
        "integrity": "6c1dabb6e8a6550436b9d360c213da298581b1be3c9f5c0a32ecb177be0e2657"
      },
      "args": "00000000000000000000000044cf3c4f000dfd76a35d03298049d37be688d6f9000000000000000000000000833589fcd6edb6e08f4c7c32d4f71b54bda029130000000000000000000000004200000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000500000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000007000000000000000000000000000000000000000000000000000000000000000b000000000000000000000000000000000000000000000000000000000000000c00000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000009000000000000000000000000000000000000000000000000000000000000000a",
      "file": "contracts/legos/LegoTools.vy"
    }
  }
}