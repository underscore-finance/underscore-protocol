{
  "contracts": {
    "ConvertVaultToken": {
      "address": "0x127CaE778d6cD8B7B2F8fd7F7ea453C037128730",
      "abi": [
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "convertVaultToken",
          "inputs": [
            {
              "name": "_fromVaultToken",
              "type": "address"
            },
            {
              "name": "_toVaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "convertVaultToken",
          "inputs": [
            {
              "name": "_fromVaultToken",
              "type": "address"
            },
            {
              "name": "_toVaultToken",
              "type": "address"
            },
            {
              "name": "_fromAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/other/ConvertVaultToken.vy": {
            "content": "# @version 0.4.3\n\nfrom ethereum.ercs import IERC4626\nfrom ethereum.ercs import IERC20\n\n\n@internal\ndef _verifyAndReturnAmount(_token: address) -> bool:\n    amount: uint256 = staticcall IERC20(_token).balanceOf(self)\n    if amount != 0:\n        return extcall IERC20(_token).transfer(msg.sender, amount, default_return_value=True)\n    return True\n\n\n@external\ndef convertVaultToken(_fromVaultToken: address, _toVaultToken: address, _fromAmount: uint256 = max_value(uint256)) -> bool:\n    # valdate and get from vault token data\n    amount: uint256 = min(_fromAmount, staticcall IERC20(_fromVaultToken).balanceOf(msg.sender))\n    assert amount != 0 # dev: amount is 0\n\n    underlyingAsset: address = staticcall IERC4626(_fromVaultToken).asset()  # from vault token asset\n    assert underlyingAsset == staticcall IERC4626(_toVaultToken).asset() # dev: asset mismatch\n\n    # transfer from vault token to this contract and redeem\n    assert extcall IERC20(_fromVaultToken).transferFrom(msg.sender, self, amount, default_return_value=True) # dev: transfer failed\n    extcall IERC4626(_fromVaultToken).redeem(amount, self, self)\n\n    # deposit underlying asset to to vault token\n    underlyingAmount: uint256 = staticcall IERC20(underlyingAsset).balanceOf(self)\n    assert underlyingAmount != 0 # dev: no token amount\n\n    assert extcall IERC20(underlyingAsset).approve(_toVaultToken, underlyingAmount, default_return_value=True) # dev: approve failed\n    depositedAmount: uint256 = extcall IERC4626(_toVaultToken).deposit(underlyingAmount, msg.sender)\n\n    assert depositedAmount != 0 # dev: no vault tokens received\n\n    assert self._verifyAndReturnAmount(_fromVaultToken) \n    assert self._verifyAndReturnAmount(_toVaultToken)\n    assert self._verifyAndReturnAmount(underlyingAsset)\n\n    return True\n",
            "sha256sum": "ce866679261796796f46ec593f7d10d8062385ff0f9a25133d7bfa67fc24c626"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/other/ConvertVaultToken.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.3+commit.bff19ea2",
        "integrity": "74417aef2c462dc8338d2e28186b8e84617b9bb6e9e8a5ebf1301fc396c5f356"
      },
      "args": "",
      "file": "contracts/other/ConvertVaultToken.vy"
    }
  }
}