{
  "contracts": {
    "UserWallet": {
      "address": "0x5aB75ef37A30736f38F637a9129348AD327EfD08",
      "abi": [
        {
          "name": "WalletAction",
          "inputs": [
            {
              "name": "op",
              "type": "uint8",
              "indexed": false
            },
            {
              "name": "asset1",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset2",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount1",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "amount2",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "legoId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "signer",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "WalletActionExt",
          "inputs": [
            {
              "name": "op",
              "type": "uint8",
              "indexed": false
            },
            {
              "name": "asset1",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset2",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "amount1",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "amount2",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "extra",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "onERC721Received",
          "inputs": [
            {
              "name": "_operator",
              "type": "address"
            },
            {
              "name": "_owner",
              "type": "address"
            },
            {
              "name": "_tokenId",
              "type": "uint256"
            },
            {
              "name": "_data",
              "type": "bytes"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bytes4"
            }
          ]
        },
        {
          "stateMutability": "payable",
          "type": "fallback"
        },
        {
          "stateMutability": "pure",
          "type": "function",
          "name": "apiVersion",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "string"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "transferFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "transferFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "transferFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "transferFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_isCheque",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "transferFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_isCheque",
              "type": "bool"
            },
            {
              "name": "_isSpecialTx",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositForYield",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositForYield",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositForYield",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositForYield",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawFromYield",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawFromYield",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawFromYield",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawFromYield",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_isSpecialTx",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "rebalanceYieldPosition",
          "inputs": [
            {
              "name": "_fromLegoId",
              "type": "uint256"
            },
            {
              "name": "_fromVaultToken",
              "type": "address"
            },
            {
              "name": "_toLegoId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "rebalanceYieldPosition",
          "inputs": [
            {
              "name": "_fromLegoId",
              "type": "uint256"
            },
            {
              "name": "_fromVaultToken",
              "type": "address"
            },
            {
              "name": "_toLegoId",
              "type": "uint256"
            },
            {
              "name": "_toVaultAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "rebalanceYieldPosition",
          "inputs": [
            {
              "name": "_fromLegoId",
              "type": "uint256"
            },
            {
              "name": "_fromVaultToken",
              "type": "address"
            },
            {
              "name": "_toLegoId",
              "type": "uint256"
            },
            {
              "name": "_toVaultAddr",
              "type": "address"
            },
            {
              "name": "_fromVaultAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "rebalanceYieldPosition",
          "inputs": [
            {
              "name": "_fromLegoId",
              "type": "uint256"
            },
            {
              "name": "_fromVaultToken",
              "type": "address"
            },
            {
              "name": "_toLegoId",
              "type": "uint256"
            },
            {
              "name": "_toVaultAddr",
              "type": "address"
            },
            {
              "name": "_fromVaultAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_instructions",
              "type": "tuple[]",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "minAmountOut",
                  "type": "uint256"
                },
                {
                  "name": "tokenPath",
                  "type": "address[]"
                },
                {
                  "name": "poolPath",
                  "type": "address[]"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mintOrRedeemAsset",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mintOrRedeemAsset",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountIn",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mintOrRedeemAsset",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mintOrRedeemAsset",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmMintOrRedeemAsset",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmMintOrRedeemAsset",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addCollateral",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addCollateral",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addCollateral",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeCollateral",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeCollateral",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeCollateral",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_borrowAsset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_borrowAsset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_borrowAsset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_paymentAsset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_paymentAsset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_paymentAsset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "convertWethToEth",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "convertWethToEth",
          "inputs": [
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "payable",
          "type": "function",
          "name": "convertEthToWeth",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "payable",
          "type": "function",
          "name": "convertEthToWeth",
          "inputs": [
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidityConcentrated",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidityConcentrated",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidityConcentrated",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidityConcentrated",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidityConcentrated",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidityConcentrated",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidityConcentrated",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidityConcentrated",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidityConcentrated",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidityConcentrated",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidityConcentrated",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidityConcentrated",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidityConcentrated",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "updateAssetData",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_shouldCheckYield",
              "type": "bool"
            },
            {
              "name": "_prevTotalUsdValue",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "updateAssetData",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_shouldCheckYield",
              "type": "bool"
            },
            {
              "name": "_prevTotalUsdValue",
              "type": "uint256"
            },
            {
              "name": "_ad",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "hatchery",
                  "type": "address"
                },
                {
                  "name": "lootDistributor",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                },
                {
                  "name": "billing",
                  "type": "address"
                },
                {
                  "name": "wallet",
                  "type": "address"
                },
                {
                  "name": "walletConfig",
                  "type": "address"
                },
                {
                  "name": "walletOwner",
                  "type": "address"
                },
                {
                  "name": "inEjectMode",
                  "type": "bool"
                },
                {
                  "name": "isFrozen",
                  "type": "bool"
                },
                {
                  "name": "lastTotalUsdValue",
                  "type": "uint256"
                },
                {
                  "name": "signer",
                  "type": "address"
                },
                {
                  "name": "isManager",
                  "type": "bool"
                },
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "legoAddr",
                  "type": "address"
                },
                {
                  "name": "eth",
                  "type": "address"
                },
                {
                  "name": "weth",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "deregisterAsset",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverNft",
          "inputs": [
            {
              "name": "_collection",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setLegoAccessForAction",
          "inputs": [
            {
              "name": "_legoAddr",
              "type": "address"
            },
            {
              "name": "_action",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "walletConfig",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assetData",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "assetBalance",
                  "type": "uint256"
                },
                {
                  "name": "usdValue",
                  "type": "uint256"
                },
                {
                  "name": "isYieldAsset",
                  "type": "bool"
                },
                {
                  "name": "lastPricePerShare",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assets",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "WETH",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ETH",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_wethAddr",
              "type": "address"
            },
            {
              "name": "_ethAddr",
              "type": "address"
            },
            {
              "name": "_walletConfig",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "interfaces/Wallet.vyi": {
            "content": "# @version 0.4.3\n\nstruct SwapInstruction:\n    legoId: uint256\n    amountIn: uint256\n    minAmountOut: uint256\n    tokenPath: DynArray[address, MAX_TOKEN_PATH]\n    poolPath: DynArray[address, MAX_TOKEN_PATH - 1]\n\nMAX_SWAP_INSTRUCTIONS: constant(uint256) = 5\nMAX_TOKEN_PATH: constant(uint256) = 5\n\n\n@view\n@external\ndef onERC721Received(_operator: address, _owner: address, _tokenId: uint256, _data: Bytes[1024]) -> bytes4:\n    ...\n\n\n@pure\n@external\ndef apiVersion() -> String[28]:\n    ...\n\n##################\n# Transfer Funds #\n##################\n\n\n@external\ndef transferFunds(\n    _recipient: address,\n    _asset: address = empty(address),\n    _amount: uint256 = max_value(uint256),\n    _isCheque: bool = False,\n    _isTrustedTx: bool = False,\n) -> (uint256, uint256):\n    ...\n\n\n#########\n# Yield #\n#########\n\n\n# deposit\n\n\n@external\ndef depositForYield(\n    _legoId: uint256,\n    _asset: address,\n    _vaultAddr: address = empty(address),\n    _amount: uint256 = max_value(uint256),\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, address, uint256, uint256):\n    ...\n\n\n# withdraw\n\n\n@external\ndef withdrawFromYield(\n    _legoId: uint256,\n    _vaultToken: address,\n    _amount: uint256 = max_value(uint256),\n    _extraData: bytes32 = empty(bytes32),\n    _isTrustedTx: bool = False,\n) -> (uint256, address, uint256, uint256):\n    ...\n\n\n# rebalance position\n\n\n@external\ndef rebalanceYieldPosition(\n    _fromLegoId: uint256,\n    _fromVaultToken: address,\n    _toLegoId: uint256,\n    _toVaultAddr: address = empty(address),\n    _fromVaultAmount: uint256 = max_value(uint256),\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, address, uint256, uint256):\n    ...\n\n\n###################\n# Swap / Exchange #\n###################\n\n\n@external\ndef swapTokens(_instructions: DynArray[SwapInstruction, MAX_SWAP_INSTRUCTIONS]) -> (address, uint256, address, uint256, uint256):\n    ...\n\n\n# mint / redeem\n\n\n@external\ndef mintOrRedeemAsset(\n    _legoId: uint256,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256 = max_value(uint256),\n    _minAmountOut: uint256 = 0,\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, uint256, bool, uint256):\n    ...\n\n\n@external\ndef confirmMintOrRedeemAsset(\n    _legoId: uint256,\n    _tokenIn: address,\n    _tokenOut: address,\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, uint256):\n    ...\n\n\n###################\n# Debt Management #\n###################\n\n\n# add collateral\n\n\n@external\ndef addCollateral(\n    _legoId: uint256,\n    _asset: address,\n    _amount: uint256 = max_value(uint256),\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, uint256):\n    ...\n\n\n# remove collateral\n\n\n@external\ndef removeCollateral(\n    _legoId: uint256,\n    _asset: address,\n    _amount: uint256 = max_value(uint256),\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, uint256):\n    ...\n\n\n# borrow\n\n\n@external\ndef borrow(\n    _legoId: uint256,\n    _borrowAsset: address,\n    _amount: uint256 = max_value(uint256),\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, uint256):\n    ...\n\n\n# repay debt\n\n\n@external\ndef repayDebt(\n    _legoId: uint256,\n    _paymentAsset: address,\n    _paymentAmount: uint256 = max_value(uint256),\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, uint256):\n    ...\n\n\n#################\n# Claim Rewards #\n#################\n\n\n@external\ndef claimRewards(\n    _legoId: uint256,\n    _rewardToken: address = empty(address),\n    _rewardAmount: uint256 = max_value(uint256),\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, uint256):\n    ...\n\n\n################\n# Wrapped ETH #\n################\n\n\n# eth -> weth\n\n\n@payable\n@external\ndef convertEthToWeth(_amount: uint256 = max_value(uint256)) -> (uint256, uint256):\n    ...\n\n\n# weth -> eth\n\n\n@external\ndef convertWethToEth(_amount: uint256 = max_value(uint256)) -> (uint256, uint256):\n    ...\n\n\n#################\n# Add Liquidity #\n#################\n\n\n# add / remove liquidity (simple)\n\n\n@external\ndef addLiquidity(\n    _legoId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _amountA: uint256 = max_value(uint256),\n    _amountB: uint256 = max_value(uint256),\n    _minAmountA: uint256 = 0,\n    _minAmountB: uint256 = 0,\n    _minLpAmount: uint256 = 0,\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, uint256, uint256, uint256):\n    ...\n\n\n@external\ndef removeLiquidity(\n    _legoId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpToken: address,\n    _lpAmount: uint256 = max_value(uint256),\n    _minAmountA: uint256 = 0,\n    _minAmountB: uint256 = 0,\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, uint256, uint256, uint256):\n    ...\n\n\n# add / remove liquidity (concentrated)\n\n\n@external\ndef addLiquidityConcentrated(\n    _legoId: uint256,\n    _nftAddr: address,\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _amountA: uint256 = max_value(uint256),\n    _amountB: uint256 = max_value(uint256),\n    _tickLower: int24 = min_value(int24),\n    _tickUpper: int24 = max_value(int24),\n    _minAmountA: uint256 = 0,\n    _minAmountB: uint256 = 0,\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, uint256, uint256, uint256, uint256):\n    ...\n\n\n@external\ndef removeLiquidityConcentrated(\n    _legoId: uint256,\n    _nftAddr: address,\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _liqToRemove: uint256 = max_value(uint256),\n    _minAmountA: uint256 = 0,\n    _minAmountB: uint256 = 0,\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, uint256, uint256, uint256):\n    ...\n\n\n#############\n# Utilities #\n#############\n\n\n# recover nft\n\n\n@external\ndef recoverNft(_collection: address, _nftTokenId: uint256, _recipient: address):\n    ...\n",
            "sha256sum": "bc36343f2acf1bcd8ce0ae78be20898917cec4f6fa4a4e9fcfea42baa0f75c21"
          },
          "interfaces/WalletStructs.vyi": {
            "content": "# @version 0.4.3\n\nflag ActionType:\n    TRANSFER\n    EARN_DEPOSIT\n    EARN_WITHDRAW\n    EARN_REBALANCE\n    SWAP\n    MINT_REDEEM\n    CONFIRM_MINT_REDEEM\n    ADD_COLLATERAL\n    REMOVE_COLLATERAL\n    BORROW\n    REPAY_DEBT\n    REWARDS\n    ETH_TO_WETH\n    WETH_TO_ETH\n    ADD_LIQ\n    REMOVE_LIQ\n    ADD_LIQ_CONC\n    REMOVE_LIQ_CONC\n    PAY_CHEQUE\n\nstruct WalletAssetData:\n    assetBalance: uint256\n    usdValue: uint256\n    isYieldAsset: bool\n    lastPricePerShare: uint256\n\nstruct ActionData:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    billing: address\n    wallet: address\n    walletConfig: address\n    walletOwner: address\n    inEjectMode: bool\n    isFrozen: bool\n    lastTotalUsdValue: uint256\n    signer: address\n    isManager: bool\n    legoId: uint256\n    legoAddr: address\n    eth: address\n    weth: address\n\nstruct MiniAddys:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    appraiser: address",
            "sha256sum": "9a4b4f59b3a62043e51b425a665064aae419a3c0bd0514b6b29a9441ae364bb9"
          },
          "interfaces/LegoPartner.vyi": {
            "content": "# @version 0.4.3\n\nfrom interfaces import WalletStructs as ws\n\nMAX_TOKEN_PATH: constant(uint256) = 5\nMAX_RECOVER_ASSETS: constant(uint256) = 20\n\n@external\ndef addLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _tickLower: int24, _tickUpper: int24, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef addLiquidity(_pool: address, _tokenA: address, _tokenB: address, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _minLpAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (address, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef removeLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _liqToRemove: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef removeLiquidity(_pool: address, _tokenA: address, _tokenB: address, _lpToken: address, _lpAmount: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef mintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _tokenInAmount: uint256, _minAmountOut: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef swapTokens(_amountIn: uint256, _minAmountOut: uint256, _tokenPath: DynArray[address, MAX_TOKEN_PATH], _poolPath: DynArray[address, MAX_TOKEN_PATH - 1], _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256):\n    ...\n\n@external\ndef depositForYield(_asset: address, _amount: uint256, _vaultAddr: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef withdrawFromYield(_vaultToken: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef confirmMintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef borrow(_borrowAsset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef repayDebt(_paymentAsset: address, _paymentAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef claimRewards(_user: address, _rewardToken: address, _rewardAmount: uint256, _extraData: bytes32, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef removeCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef addCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@view\n@external\ndef getAccessForLego(_user: address, _action: ws.ActionType) -> (address, String[64], uint256):\n    ...\n\n@view\n@external\ndef hasCapability(_action: ws.ActionType) -> bool:\n    ...\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    ...\n\n@view\n@external\ndef isYieldLego() -> bool:\n    ...\n\n@view\n@external\ndef isDexLego() -> bool:\n    ...\n\n@view\n@external\ndef getPricePerShare(_asset: address, _decimals: uint256) -> uint256:\n    ...\n\n@view\n@external\ndef getPrice(_asset: address, _decimals: uint256) -> uint256:\n    ...\n\n\n# common\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "2513e379aa74d0a8120114a5078a4c1a0900165a1c3f24419bb811d173b56453"
          },
          "contracts/core/userWallet/UserWallet.vy": {
            "content": "#    \u2533\u2533     \n#    \u2503\u2503\u250f\u250f\u2513\u250f\u2513\n#    \u2517\u251b\u251b\u2517 \u251b \n#               .---.             ,--,    ,--,                 ___     \n#              /. ./|           ,--.'|  ,--.'|               ,--.'|_   \n#          .--'.  ' ;           |  | :  |  | :               |  | :,'  \n#         /__./ \\ : |           :  : '  :  : '               :  : ' :  \n#     .--'.  '   \\' .  ,--.--.  |  ' |  |  ' |      ,---.  .;__,'  /   \n#    /___/ \\ |    ' ' /       \\ '  | |  '  | |     /     \\ |  |   |    \n#    ;   \\  \\;      :.--.  .-. ||  | :  |  | :    /    /  |:__,'| :    \n#     \\   ;  `      | \\__\\/: . .'  : |__'  : |__ .    ' / |  '  : |__  \n#      .   \\    .\\  ; ,\" .--.; ||  | '.'|  | '.'|'   ;   /|  |  | '.'| \n#       \\   \\   ' \\ |/  /  ,.  |;  :    ;  :    ;'   |  / |  ;  :    ; \n#        :   '  |--\";  :   .'   \\  ,   /|  ,   / |   :    |  |  ,   /  \n#         \\   \\ ;   |  ,     .-./---`-'  ---`-'   \\   \\  /    ---`-'   \n#          '---\"     `--`---'                      `----'              \n#     \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n#     \u2551  ** User Wallet **                       \u2551\n#     \u2551  Handles all user wallet functionality   \u2551\n#     \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n#\n#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n# pragma optimize codesize\n\nimplements: wi\nfrom interfaces import Wallet as wi\nfrom interfaces import LegoPartner as Lego\nfrom interfaces import WalletStructs as ws\n\nfrom ethereum.ercs import IERC20\nfrom ethereum.ercs import IERC721\n\ninterface Appraiser:\n    def calculateYieldProfits(_asset: address, _currentBalance: uint256, _lastBalance: uint256, _lastPricePerShare: uint256, _missionControl: address, _legoBook: address) -> (uint256, uint256, uint256): nonpayable\n    def updatePriceAndGetUsdValueAndIsYieldAsset(_asset: address, _amount: uint256, _missionControl: address = empty(address), _legoBook: address = empty(address)) -> (uint256, bool): nonpayable\n    def updatePriceAndGetUsdValue(_asset: address, _amount: uint256, _missionControl: address = empty(address), _legoBook: address = empty(address)) -> uint256: nonpayable\n    def lastPricePerShare(_asset: address) -> uint256: view\n\ninterface WalletConfig:\n    def checkSignerPermissionsAndGetBundle(_signer: address, _action: ws.ActionType, _assets: DynArray[address, MAX_ASSETS] = [], _legoIds: DynArray[uint256, MAX_LEGOS] = [], _transferRecipient: address = empty(address)) -> ws.ActionData: view\n    def checkRecipientLimitsAndUpdateData(_recipient: address, _txUsdValue: uint256, _asset: address, _amount: uint256) -> bool: nonpayable\n    def validateCheque(_recipient: address, _asset: address, _amount: uint256, _txUsdValue: uint256, _signer: address) -> bool: nonpayable\n    def checkManagerUsdLimitsAndUpdateData(_manager: address, _txUsdValue: uint256) -> bool: nonpayable\n    def getActionDataBundle(_legoId: uint256, _signer: address) -> ws.ActionData: view\n\ninterface LootDistributor:\n    def addLootFromYieldProfit(_asset: address, _feeAmount: uint256, _yieldRealized: uint256, _missionControl: address = empty(address), _appraiser: address = empty(address), _legoBook: address = empty(address)): nonpayable\n    def addLootFromSwapOrRewards(_asset: address, _amount: uint256, _action: ws.ActionType, _missionControl: address = empty(address)): nonpayable\n    def getSwapFee(_user: address, _tokenIn: address, _tokenOut: address, _missionControl: address = empty(address)) -> uint256: view\n    def getRewardsFee(_user: address, _asset: address, _missionControl: address = empty(address)) -> uint256: view\n    def updateDepositPointsWithNewValue(_user: address, _newUsdValue: uint256): nonpayable\n\ninterface WethContract:\n    def withdraw(_amount: uint256): nonpayable\n    def deposit(): payable\n\ninterface Hatchery:\n    def doesWalletStillHaveTrialFundsWithAddys(_user: address, _walletConfig: address, _missionControl: address, _legoBook: address, _appraiser: address, _ledger: address) -> bool: view\n\ninterface Registry:\n    def getAddr(_regId: uint256) -> address: view\n\nevent WalletAction:\n    op: uint8 \n    asset1: indexed(address)\n    asset2: indexed(address)\n    amount1: uint256\n    amount2: uint256\n    usdValue: uint256\n    legoId: uint256\n    signer: indexed(address)\n\nevent WalletActionExt:\n    op: uint8\n    asset1: indexed(address)\n    asset2: indexed(address)\n    tokenId: uint256\n    amount1: uint256\n    amount2: uint256\n    usdValue: uint256\n    extra: uint256\n\n# data \nwalletConfig: public(address)\n\n# asset data\nassetData: public(HashMap[address, ws.WalletAssetData]) # asset -> data\nassets: public(HashMap[uint256, address]) # index -> asset\nindexOfAsset: public(HashMap[address, uint256]) # asset -> index\nnumAssets: public(uint256) # num assets\n\n# yield\ncheckedYield: transient(HashMap[address, bool]) # asset -> checked\n\n# constants\nHUNDRED_PERCENT: constant(uint256) = 100_00 # 100.00%\nMAX_SWAP_INSTRUCTIONS: constant(uint256) = 5\nMAX_TOKEN_PATH: constant(uint256) = 5\nMAX_ASSETS: constant(uint256) = 10\nMAX_LEGOS: constant(uint256) = 10\nERC721_RECEIVE_DATA: constant(Bytes[1024]) = b\"UE721\"\nAPI_VERSION: constant(String[28]) = \"0.1.0\"\n\nWETH: public(immutable(address))\nETH: public(immutable(address))\n\n\n@deploy\ndef __init__(\n    _wethAddr: address,\n    _ethAddr: address,\n    _walletConfig: address,\n):\n    assert empty(address) not in [_wethAddr, _ethAddr, _walletConfig] # dev: inv addr\n    self.walletConfig = _walletConfig\n    self.numAssets = 1\n\n    WETH = _wethAddr\n    ETH = _ethAddr\n\n\n@view\n@external\ndef onERC721Received(_operator: address, _owner: address, _tokenId: uint256, _data: Bytes[1024]) -> bytes4:\n    # must implement method for safe NFT transfers\n    return method_id(\"onERC721Received(address,address,uint256,bytes)\", output_type = bytes4)\n\n\n@payable\n@external\ndef __default__():\n    pass\n\n\n@pure\n@external\ndef apiVersion() -> String[28]:\n    return API_VERSION\n\n\n##################\n# Transfer Funds #\n##################\n\n\n@nonreentrant\n@external\ndef transferFunds(\n    _recipient: address,\n    _asset: address = empty(address),\n    _amount: uint256 = max_value(uint256),\n    _isCheque: bool = False,\n    _isSpecialTx: bool = False,\n) -> (uint256, uint256):\n    asset: address = empty(address)\n    ad: ws.ActionData = empty(ws.ActionData)\n    asset, ad = self._validateCanTransfer(msg.sender, _recipient, _asset, _isSpecialTx, _isCheque)\n\n    # finalize amount\n    amount: uint256 = 0\n    if asset == ad.eth:\n        amount = min(_amount, self.balance)\n    else:\n        amount = min(_amount, staticcall IERC20(asset).balanceOf(self))\n    assert amount != 0 # dev: no amt\n\n    # get usd value\n    txUsdValue: uint256 = self._updatePriceAndGetUsdValue(asset, amount, ad)\n\n    # make sure recipient can actually receive funds\n    if not _isSpecialTx:\n        if _isCheque:\n            assert extcall WalletConfig(ad.walletConfig).validateCheque(_recipient, asset, amount, txUsdValue, ad.signer) # dev: cheque invalid\n        else:\n            assert extcall WalletConfig(ad.walletConfig).checkRecipientLimitsAndUpdateData(_recipient, txUsdValue, asset, amount) # dev: recipient limits exceeded\n\n    # do actual transfer\n    if asset == ad.eth:\n        send(_recipient, amount)\n    else:\n        assert extcall IERC20(asset).transfer(_recipient, amount, default_return_value = True) # dev: xfer\n\n    self._performPostActionTasks([asset], txUsdValue, ad, _isSpecialTx)\n    log WalletAction(\n        op = 1,\n        asset1 = asset,\n        asset2 = _recipient,\n        amount1 = amount,\n        amount2 = 0,\n        usdValue = txUsdValue,\n        legoId = 0,\n        signer = ad.signer,\n    )\n    return amount, txUsdValue\n\n\n@internal\ndef _validateCanTransfer(\n    _signer: address,\n    _recipient: address,\n    _asset: address,\n    _isSpecialTx: bool,\n    _isCheque: bool,\n) -> (address, ws.ActionData):\n    ad: ws.ActionData = empty(ws.ActionData)\n    assert _recipient != empty(address) # dev: inv recipient\n\n    # finalize asset\n    asset: address = _asset\n    if asset == empty(address):\n        asset = ETH\n\n    # only wallet config can do trusted txs (migration, clawback trial funds)\n    if _isSpecialTx:\n        walletConfig: address = self.walletConfig\n        assert _signer == walletConfig # dev: perms\n        ad = staticcall WalletConfig(walletConfig).getActionDataBundle(0, _signer)\n        self._checkForYieldProfits(asset, ad)\n\n    # normal transaction\n    else:\n        action: ws.ActionType = ws.ActionType.TRANSFER\n        if _isCheque:\n            action = ws.ActionType.PAY_CHEQUE\n        ad = self._performPreActionTasks(_signer, action, False, [asset], [], _recipient)\n\n    return asset, ad\n\n\n#########\n# Yield #\n#########\n\n\n# deposit\n\n\n@nonreentrant\n@external\ndef depositForYield(\n    _legoId: uint256,\n    _asset: address,\n    _vaultAddr: address = empty(address),\n    _amount: uint256 = max_value(uint256),\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, address, uint256, uint256):\n    ad: ws.ActionData = self._performPreActionTasks(msg.sender, ws.ActionType.EARN_DEPOSIT, False, [_asset], [_legoId])\n    return self._depositForYield(_asset, _vaultAddr, _amount, _extraData, True, True, ad)\n\n\n@internal\ndef _depositForYield(\n    _asset: address,\n    _vaultAddr: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _shouldPerformPostActionTasks: bool,\n    _shouldGenerateEvent: bool,\n    _ad: ws.ActionData,\n) -> (uint256, address, uint256, uint256):\n    amount: uint256 = self._getAmountAndApprove(_asset, _amount, _ad.legoAddr) # doing approval here\n\n    # deposit for yield\n    assetAmount: uint256 = 0\n    vaultToken: address = empty(address)\n    vaultTokenAmountReceived: uint256 = 0\n    txUsdValue: uint256 = 0\n    assetAmount, vaultToken, vaultTokenAmountReceived, txUsdValue = extcall Lego(_ad.legoAddr).depositForYield(_asset, amount, _vaultAddr, _extraData, self, self._packMiniAddys(_ad.ledger, _ad.missionControl, _ad.legoBook, _ad.appraiser))\n    self._resetApproval(_asset, _ad.legoAddr)\n\n    # perform post action tasks\n    if _shouldPerformPostActionTasks:\n        self._performPostActionTasks([_asset, vaultToken], txUsdValue, _ad)\n\n    if _shouldGenerateEvent:\n        log WalletAction(\n            op = 10,\n            asset1 = _asset,\n            asset2 = vaultToken,\n            amount1 = assetAmount,\n            amount2 = vaultTokenAmountReceived,\n            usdValue = txUsdValue,\n            legoId = _ad.legoId,\n            signer = _ad.signer,\n        )\n    return assetAmount, vaultToken, vaultTokenAmountReceived, txUsdValue\n\n\n# withdraw\n\n\n@nonreentrant\n@external\ndef withdrawFromYield(\n    _legoId: uint256,\n    _vaultToken: address,\n    _amount: uint256 = max_value(uint256),\n    _extraData: bytes32 = empty(bytes32),\n    _isSpecialTx: bool = False,\n) -> (uint256, address, uint256, uint256):\n    ad: ws.ActionData = empty(ws.ActionData)\n\n    # prepares payment (might be clawback trial funds, or some other payment/transfer/cheque)\n    if _isSpecialTx:\n        walletConfig: address = self.walletConfig\n        assert msg.sender == walletConfig # dev: perms\n\n        ad = staticcall WalletConfig(walletConfig).getActionDataBundle(_legoId, msg.sender)\n        self._checkForYieldProfits(_vaultToken, ad)\n\n    # normal transaction\n    else:\n        ad = self._performPreActionTasks(msg.sender, ws.ActionType.EARN_WITHDRAW, False, [_vaultToken], [_legoId])\n\n    return self._withdrawFromYield(_vaultToken, _amount, _extraData, True, True, _isSpecialTx, ad)\n\n\n@internal\ndef _withdrawFromYield(\n    _vaultToken: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _shouldPerformPostActionTasks: bool,\n    _shouldGenerateEvent: bool,\n    _isSpecialTx: bool,\n    _ad: ws.ActionData,\n) -> (uint256, address, uint256, uint256):\n    amount: uint256 = _amount\n    if _vaultToken != empty(address):\n        amount = self._getAmountAndApprove(_vaultToken, _amount, empty(address)) # not approving here\n\n        # some vault tokens require max value approval (comp v3)\n        assert extcall IERC20(_vaultToken).approve(_ad.legoAddr, max_value(uint256), default_return_value = True) # dev: appr\n\n    # withdraw from yield\n    vaultTokenAmountBurned: uint256 = 0\n    underlyingAsset: address = empty(address)\n    underlyingAmount: uint256 = 0\n    txUsdValue: uint256 = 0\n    vaultTokenAmountBurned, underlyingAsset, underlyingAmount, txUsdValue = extcall Lego(_ad.legoAddr).withdrawFromYield(_vaultToken, amount, _extraData, self, self._packMiniAddys(_ad.ledger, _ad.missionControl, _ad.legoBook, _ad.appraiser))\n\n    if _vaultToken != empty(address):\n        self._resetApproval(_vaultToken, _ad.legoAddr)\n\n    # perform post action tasks\n    if _shouldPerformPostActionTasks:\n        self._performPostActionTasks([underlyingAsset, _vaultToken], txUsdValue, _ad, _isSpecialTx)\n\n    if _shouldGenerateEvent:\n        log WalletAction(\n            op = 11,\n            asset1 = _vaultToken,\n            asset2 = underlyingAsset,\n            amount1 = vaultTokenAmountBurned,\n            amount2 = underlyingAmount,\n            usdValue = txUsdValue,\n            legoId = _ad.legoId,\n            signer = _ad.signer,\n        )\n    return vaultTokenAmountBurned, underlyingAsset, underlyingAmount, txUsdValue\n\n\n# rebalance position\n\n\n@nonreentrant\n@external\ndef rebalanceYieldPosition(\n    _fromLegoId: uint256,\n    _fromVaultToken: address,\n    _toLegoId: uint256,\n    _toVaultAddr: address = empty(address),\n    _fromVaultAmount: uint256 = max_value(uint256),\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, address, uint256, uint256):\n    ad: ws.ActionData = self._performPreActionTasks(msg.sender, ws.ActionType.EARN_REBALANCE, False, [_fromVaultToken, _toVaultAddr], [_fromLegoId, _toLegoId])\n\n    # withdraw\n    vaultTokenAmountBurned: uint256 = 0\n    underlyingAsset: address = empty(address)\n    underlyingAmount: uint256 = 0\n    withdrawTxUsdValue: uint256 = 0\n    vaultTokenAmountBurned, underlyingAsset, underlyingAmount, withdrawTxUsdValue = self._withdrawFromYield(_fromVaultToken, _fromVaultAmount, _extraData, False, False, False, ad)\n\n    # deposit\n    toVaultToken: address = empty(address)\n    toVaultTokenAmountReceived: uint256 = 0\n    depositTxUsdValue: uint256 = 0\n    ad.legoId = _toLegoId\n    ad.legoAddr = staticcall Registry(ad.legoBook).getAddr(_toLegoId)\n    underlyingAmount, toVaultToken, toVaultTokenAmountReceived, depositTxUsdValue = self._depositForYield(underlyingAsset, _toVaultAddr, underlyingAmount, _extraData, False, False, ad)\n\n    maxUsdValue: uint256 = max(withdrawTxUsdValue, depositTxUsdValue)\n    self._performPostActionTasks([underlyingAsset, _fromVaultToken, toVaultToken], maxUsdValue, ad)\n    log WalletAction(\n        op = 12,\n        asset1 = _fromVaultToken,\n        asset2 = toVaultToken,\n        amount1 = vaultTokenAmountBurned,\n        amount2 = toVaultTokenAmountReceived,\n        usdValue = maxUsdValue,\n        legoId = ad.legoId,\n        signer = ad.signer,\n    )\n    return underlyingAmount, toVaultToken, toVaultTokenAmountReceived, maxUsdValue\n\n\n###################\n# Swap / Exchange #\n###################\n\n\n@nonreentrant\n@external\ndef swapTokens(_instructions: DynArray[wi.SwapInstruction, MAX_SWAP_INSTRUCTIONS]) -> (address, uint256, address, uint256, uint256):\n    tokenIn: address = empty(address)\n    tokenOut: address = empty(address)\n    legoIds: DynArray[uint256, MAX_LEGOS] = []\n    tokenIn, tokenOut, legoIds = self._validateAndGetSwapInfo(_instructions)\n\n    # action data bundle\n    ad: ws.ActionData = self._performPreActionTasks(msg.sender, ws.ActionType.SWAP, False, [tokenIn, tokenOut], legoIds)\n    origAmountIn: uint256 = self._getAmountAndApprove(tokenIn, _instructions[0].amountIn, empty(address)) # not approving here\n\n    amountIn: uint256 = origAmountIn\n    lastTokenOut: address = empty(address)\n    lastTokenOutAmount: uint256 = 0\n    maxTxUsdValue: uint256 = 0\n\n    # perform swaps\n    for i: wi.SwapInstruction in _instructions:\n        if lastTokenOut != empty(address):\n            newTokenIn: address = i.tokenPath[0]\n            assert lastTokenOut == newTokenIn # dev: path\n            amountIn = min(lastTokenOutAmount, staticcall IERC20(newTokenIn).balanceOf(self))\n\n        thisTxUsdValue: uint256 = 0\n        lastTokenOut, lastTokenOutAmount, thisTxUsdValue = self._performSwapInstruction(amountIn, i, ad)\n        maxTxUsdValue = max(maxTxUsdValue, thisTxUsdValue)\n\n    # handle swap fee\n    if lastTokenOut != empty(address):\n        swapFee: uint256 = staticcall LootDistributor(ad.lootDistributor).getSwapFee(self, tokenIn, lastTokenOut, ad.missionControl)\n        if swapFee != 0 and lastTokenOutAmount != 0:\n            swapFee = self._payTransactionFee(lastTokenOut, lastTokenOutAmount, min(swapFee, 5_00), ws.ActionType.SWAP, ad.lootDistributor, ad.missionControl)\n            lastTokenOutAmount -= swapFee\n\n    self._performPostActionTasks([tokenIn, lastTokenOut], maxTxUsdValue, ad)\n    log WalletAction(\n        op = 20,\n        asset1 = tokenIn,\n        asset2 = lastTokenOut,\n        amount1 = origAmountIn,\n        amount2 = lastTokenOutAmount,\n        usdValue = maxTxUsdValue,\n        legoId = ad.legoId, # using just the first lego used\n        signer = ad.signer,\n    )\n    return tokenIn, origAmountIn, lastTokenOut, lastTokenOutAmount, maxTxUsdValue\n\n\n@internal\ndef _performSwapInstruction(\n    _amountIn: uint256,\n    _i: wi.SwapInstruction,\n    _ad: ws.ActionData,\n) -> (address, uint256, uint256):\n    legoAddr: address = staticcall Registry(_ad.legoBook).getAddr(_i.legoId)\n    assert legoAddr != empty(address) # dev: lego\n\n    # tokens\n    tokenIn: address = _i.tokenPath[0]\n    tokenOut: address = _i.tokenPath[len(_i.tokenPath) - 1]\n    tokenInAmount: uint256 = 0\n    tokenOutAmount: uint256 = 0\n    txUsdValue: uint256 = 0\n\n    assert extcall IERC20(tokenIn).approve(legoAddr, _amountIn, default_return_value = True) # dev: appr\n    tokenInAmount, tokenOutAmount, txUsdValue = extcall Lego(legoAddr).swapTokens(_amountIn, _i.minAmountOut, _i.tokenPath, _i.poolPath, self, self._packMiniAddys(_ad.ledger, _ad.missionControl, _ad.legoBook, _ad.appraiser))\n    self._resetApproval(tokenIn, legoAddr)\n    return tokenOut, tokenOutAmount, txUsdValue\n\n\n@internal\ndef _validateAndGetSwapInfo(_instructions: DynArray[wi.SwapInstruction, MAX_SWAP_INSTRUCTIONS]) -> (address, address, DynArray[uint256, MAX_LEGOS]):\n    numSwapInstructions: uint256 = len(_instructions)\n    assert numSwapInstructions != 0 # dev: swaps\n\n    # lego ids, make sure token paths are valid\n    legoIds: DynArray[uint256, MAX_LEGOS] = []\n    for i: wi.SwapInstruction in _instructions:\n        assert len(i.tokenPath) >= 2 # dev: path\n        if i.legoId not in legoIds:\n            legoIds.append(i.legoId)\n\n    # finalize tokens\n    firstRoutePath: DynArray[address, MAX_TOKEN_PATH] = _instructions[0].tokenPath\n    tokenIn: address = firstRoutePath[0]\n    tokenOut: address = empty(address)\n\n    if numSwapInstructions == 1:\n        tokenOut = firstRoutePath[len(firstRoutePath) - 1]\n    else:\n        lastRoutePath: DynArray[address, MAX_TOKEN_PATH] = _instructions[numSwapInstructions - 1].tokenPath\n        tokenOut = lastRoutePath[len(lastRoutePath) - 1]\n\n    assert empty(address) not in [tokenIn, tokenOut] # dev: path\n    return tokenIn, tokenOut, legoIds\n\n\n# mint / redeem\n\n\n@nonreentrant\n@external\ndef mintOrRedeemAsset(\n    _legoId: uint256,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256 = max_value(uint256),\n    _minAmountOut: uint256 = 0,\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, uint256, bool, uint256):\n    ad: ws.ActionData = self._performPreActionTasks(msg.sender, ws.ActionType.MINT_REDEEM, False, [_tokenIn, _tokenOut], [_legoId])\n\n    # mint or redeem asset\n    tokenInAmount: uint256 = self._getAmountAndApprove(_tokenIn, _amountIn, ad.legoAddr) # doing approval here\n    tokenOutAmount: uint256 = 0\n    isPending: bool = False\n    txUsdValue: uint256 = 0\n    tokenInAmount, tokenOutAmount, isPending, txUsdValue = extcall Lego(ad.legoAddr).mintOrRedeemAsset(_tokenIn, _tokenOut, tokenInAmount, _minAmountOut, _extraData, self, self._packMiniAddys(ad.ledger, ad.missionControl, ad.legoBook, ad.appraiser))\n    self._resetApproval(_tokenIn, ad.legoAddr)\n\n    self._performPostActionTasks([_tokenIn, _tokenOut], txUsdValue, ad)\n    log WalletAction(\n        op = 21,\n        asset1 = _tokenIn,\n        asset2 = _tokenOut,\n        amount1 = tokenInAmount,\n        amount2 = tokenOutAmount,\n        usdValue = txUsdValue,\n        legoId = ad.legoId,\n        signer = ad.signer,\n    )\n    return tokenInAmount, tokenOutAmount, isPending, txUsdValue\n\n\n@nonreentrant\n@external\ndef confirmMintOrRedeemAsset(\n    _legoId: uint256,\n    _tokenIn: address,\n    _tokenOut: address,\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, uint256):\n    ad: ws.ActionData = self._performPreActionTasks(msg.sender, ws.ActionType.CONFIRM_MINT_REDEEM, False, [_tokenIn, _tokenOut], [_legoId])\n\n    # confirm mint or redeem asset (if there is a delay on action)\n    tokenOutAmount: uint256 = 0\n    txUsdValue: uint256 = 0\n    tokenOutAmount, txUsdValue = extcall Lego(ad.legoAddr).confirmMintOrRedeemAsset(_tokenIn, _tokenOut, _extraData, self, self._packMiniAddys(ad.ledger, ad.missionControl, ad.legoBook, ad.appraiser))\n\n    self._performPostActionTasks([_tokenIn, _tokenOut], txUsdValue, ad)\n    log WalletAction(\n        op = 22,\n        asset1 = _tokenIn,\n        asset2 = _tokenOut,\n        amount1 = 0,\n        amount2 = tokenOutAmount,\n        usdValue = txUsdValue,\n        legoId = ad.legoId,\n        signer = ad.signer,\n    )\n    return tokenOutAmount, txUsdValue\n\n\n###################\n# Debt Management #\n###################\n\n\n# NOTE: these functions assume there is no vault token involved (i.e. Ripe Protocol)\n# You can also use `depositIntoProtocol` and `withdrawFromProtocol` if a vault token is involved\n\n\n# add collateral\n\n\n@nonreentrant\n@external\ndef addCollateral(\n    _legoId: uint256,\n    _asset: address,\n    _amount: uint256 = max_value(uint256),\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, uint256):\n    ad: ws.ActionData = self._performPreActionTasks(msg.sender, ws.ActionType.ADD_COLLATERAL, True, [_asset], [_legoId])\n\n    # add collateral\n    amount: uint256 = self._getAmountAndApprove(_asset, _amount, ad.legoAddr) # doing approval here\n    amountDeposited: uint256 = 0\n    txUsdValue: uint256 = 0\n    amountDeposited, txUsdValue = extcall Lego(ad.legoAddr).addCollateral(_asset, amount, _extraData, self, self._packMiniAddys(ad.ledger, ad.missionControl, ad.legoBook, ad.appraiser))\n    self._resetApproval(_asset, ad.legoAddr)\n\n    self._performPostActionTasks([_asset], txUsdValue, ad)\n    log WalletAction(\n        op = 40,\n        asset1 = _asset,\n        asset2 = empty(address),\n        amount1 = amountDeposited,\n        amount2 = 0,\n        usdValue = txUsdValue,\n        legoId = ad.legoId,\n        signer = ad.signer,\n    )\n    return amountDeposited, txUsdValue\n\n\n# remove collateral\n\n\n@nonreentrant\n@external\ndef removeCollateral(\n    _legoId: uint256,\n    _asset: address,\n    _amount: uint256 = max_value(uint256),\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, uint256):\n    ad: ws.ActionData = self._performPreActionTasks(msg.sender, ws.ActionType.REMOVE_COLLATERAL, True, [_asset], [_legoId])\n\n    # remove collateral\n    amountRemoved: uint256 = 0\n    txUsdValue: uint256 = 0   \n    amountRemoved, txUsdValue = extcall Lego(ad.legoAddr).removeCollateral(_asset, _amount, _extraData, self, self._packMiniAddys(ad.ledger, ad.missionControl, ad.legoBook, ad.appraiser))\n\n    self._performPostActionTasks([_asset], txUsdValue, ad)\n    log WalletAction(\n        op = 41,\n        asset1 = _asset,\n        asset2 = empty(address),\n        amount1 = amountRemoved,\n        amount2 = 0,\n        usdValue = txUsdValue,\n        legoId = ad.legoId,\n        signer = ad.signer,\n    )\n    return amountRemoved, txUsdValue\n\n\n# borrow\n\n\n@nonreentrant\n@external\ndef borrow(\n    _legoId: uint256,\n    _borrowAsset: address,\n    _amount: uint256 = max_value(uint256),\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, uint256):\n    ad: ws.ActionData = self._performPreActionTasks(msg.sender, ws.ActionType.BORROW, True, [_borrowAsset], [_legoId])\n\n    # borrow\n    borrowAmount: uint256 = 0\n    txUsdValue: uint256 = 0\n    borrowAmount, txUsdValue = extcall Lego(ad.legoAddr).borrow(_borrowAsset, _amount, _extraData, self, self._packMiniAddys(ad.ledger, ad.missionControl, ad.legoBook, ad.appraiser))\n\n    self._performPostActionTasks([_borrowAsset], txUsdValue, ad)\n    log WalletAction(\n        op = 42,\n        asset1 = _borrowAsset,\n        asset2 = empty(address),\n        amount1 = borrowAmount,\n        amount2 = 0,\n        usdValue = txUsdValue,\n        legoId = ad.legoId,\n        signer = ad.signer,\n    )\n    return borrowAmount, txUsdValue\n\n\n# repay debt\n\n\n@nonreentrant\n@external\ndef repayDebt(\n    _legoId: uint256,\n    _paymentAsset: address,\n    _paymentAmount: uint256 = max_value(uint256),\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, uint256):\n    ad: ws.ActionData = self._performPreActionTasks(msg.sender, ws.ActionType.REPAY_DEBT, True, [_paymentAsset], [_legoId])\n\n    # repay debt\n    amount: uint256 = self._getAmountAndApprove(_paymentAsset, _paymentAmount, ad.legoAddr) # doing approval here\n    repaidAmount: uint256 = 0\n    txUsdValue: uint256 = 0\n    repaidAmount, txUsdValue = extcall Lego(ad.legoAddr).repayDebt(_paymentAsset, amount, _extraData, self, self._packMiniAddys(ad.ledger, ad.missionControl, ad.legoBook, ad.appraiser))\n    self._resetApproval(_paymentAsset, ad.legoAddr)\n\n    self._performPostActionTasks([_paymentAsset], txUsdValue, ad)\n    log WalletAction(\n        op = 43,\n        asset1 = _paymentAsset,\n        asset2 = empty(address),\n        amount1 = repaidAmount,\n        amount2 = 0,\n        usdValue = txUsdValue,\n        legoId = ad.legoId,\n        signer = ad.signer,\n    )\n    return repaidAmount, txUsdValue\n\n\n#################\n# Claim Rewards #\n#################\n\n\n@nonreentrant\n@external\ndef claimRewards(\n    _legoId: uint256,\n    _rewardToken: address = empty(address),\n    _rewardAmount: uint256 = max_value(uint256),\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, uint256):\n    ad: ws.ActionData = self._performPreActionTasks(msg.sender, ws.ActionType.REWARDS, True, [_rewardToken], [_legoId])\n\n    # claim rewards\n    rewardAmount: uint256 = 0\n    txUsdValue: uint256 = 0\n    rewardAmount, txUsdValue = extcall Lego(ad.legoAddr).claimRewards(self, _rewardToken, _rewardAmount, _extraData, self._packMiniAddys(ad.ledger, ad.missionControl, ad.legoBook, ad.appraiser))\n\n    # handle rewards fee\n    if _rewardToken != empty(address):\n        rewardsFee: uint256 = staticcall LootDistributor(ad.lootDistributor).getRewardsFee(self, _rewardToken, ad.missionControl)\n        if rewardsFee != 0 and rewardAmount != 0:\n            rewardsFee = self._payTransactionFee(_rewardToken, rewardAmount, min(rewardsFee, 25_00), ws.ActionType.REWARDS, ad.lootDistributor, ad.missionControl)\n            rewardAmount -= rewardsFee\n\n    self._performPostActionTasks([_rewardToken], txUsdValue, ad)\n    log WalletAction(\n        op = 50,\n        asset1 = _rewardToken,\n        asset2 = ad.legoAddr,\n        amount1 = rewardAmount,\n        amount2 = 0,\n        usdValue = txUsdValue,\n        legoId = ad.legoId,\n        signer = ad.signer,\n    )\n    return rewardAmount, txUsdValue\n\n\n###############\n# Wrapped ETH #\n###############\n\n\n# weth -> eth\n\n\n@nonreentrant\n@external\ndef convertWethToEth(_amount: uint256 = max_value(uint256)) -> (uint256, uint256):\n    weth: address = WETH\n    eth: address = ETH\n    ad: ws.ActionData = self._performPreActionTasks(msg.sender, ws.ActionType.WETH_TO_ETH, False, [weth, eth], [], empty(address))\n\n    # convert weth to eth\n    amount: uint256 = self._getAmountAndApprove(weth, _amount, empty(address)) # nothing to approve\n    extcall WethContract(weth).withdraw(amount)\n\n    txUsdValue: uint256 = self._updatePriceAndGetUsdValue(weth, amount, ad)\n    self._performPostActionTasks([weth, eth], txUsdValue, ad)\n    log WalletAction(\n        op = 2,\n        asset1 = weth,\n        asset2 = eth,\n        amount1 = amount,\n        amount2 = amount,\n        usdValue = txUsdValue,\n        legoId = 0,\n        signer = ad.signer,\n    )\n    return amount, txUsdValue\n\n\n# eth -> weth\n\n\n@nonreentrant\n@payable\n@external\ndef convertEthToWeth(_amount: uint256 = max_value(uint256)) -> (uint256, uint256):\n    eth: address = ETH\n    weth: address = WETH\n    ad: ws.ActionData = self._performPreActionTasks(msg.sender, ws.ActionType.ETH_TO_WETH, False, [eth, weth], [], empty(address))\n\n    # convert eth to weth\n    amount: uint256 = min(_amount, self.balance)\n    assert amount != 0 # dev: no amt\n    extcall WethContract(weth).deposit(value = amount)\n\n    txUsdValue: uint256 = self._updatePriceAndGetUsdValue(weth, amount, ad)\n    self._performPostActionTasks([eth, weth], txUsdValue, ad)\n    log WalletAction(\n        op = 3,\n        asset1 = eth,\n        asset2 = weth,\n        amount1 = msg.value,\n        amount2 = amount,\n        usdValue = txUsdValue,\n        legoId = 0,\n        signer = ad.signer,\n    )\n    return amount, txUsdValue\n\n\n#############\n# Liquidity #\n#############\n\n\n# add / remove liquidity (simple)\n\n\n@nonreentrant\n@external\ndef addLiquidity(\n    _legoId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _amountA: uint256 = max_value(uint256),\n    _amountB: uint256 = max_value(uint256),\n    _minAmountA: uint256 = 0,\n    _minAmountB: uint256 = 0,\n    _minLpAmount: uint256 = 0,\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, uint256, uint256, uint256):\n    ad: ws.ActionData = self._performPreActionTasks(msg.sender, ws.ActionType.ADD_LIQ, False, [_tokenA, _tokenB], [_legoId])\n\n    # token approvals\n    amountA: uint256 = 0\n    if _amountA != 0:\n        amountA = self._getAmountAndApprove(_tokenA, _amountA, ad.legoAddr)\n    amountB: uint256 = 0\n    if _amountB != 0:\n        amountB = self._getAmountAndApprove(_tokenB, _amountB, ad.legoAddr)\n\n    # add liquidity via lego partner\n    lpToken: address = empty(address)\n    lpAmountReceived: uint256 = 0\n    addedTokenA: uint256 = 0\n    addedTokenB: uint256 = 0\n    txUsdValue: uint256 = 0\n    lpToken, lpAmountReceived, addedTokenA, addedTokenB, txUsdValue = extcall Lego(ad.legoAddr).addLiquidity(_pool, _tokenA, _tokenB, amountA, amountB, _minAmountA, _minAmountB, _minLpAmount, _extraData, self, self._packMiniAddys(ad.ledger, ad.missionControl, ad.legoBook, ad.appraiser))\n\n    # remove approvals\n    if amountA != 0:\n        self._resetApproval(_tokenA, ad.legoAddr)\n    if amountB != 0:\n        self._resetApproval(_tokenB, ad.legoAddr)\n\n    self._performPostActionTasks([_tokenA, _tokenB, lpToken], txUsdValue, ad)\n    log WalletAction(\n        op = 30,\n        asset1 = _tokenA,\n        asset2 = _tokenB,\n        amount1 = addedTokenA,\n        amount2 = addedTokenB,\n        usdValue = txUsdValue,\n        legoId = ad.legoId,\n        signer = ad.signer,\n    )\n    return lpAmountReceived, addedTokenA, addedTokenB, txUsdValue\n\n\n@nonreentrant\n@external\ndef removeLiquidity(\n    _legoId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpToken: address,\n    _lpAmount: uint256 = max_value(uint256),\n    _minAmountA: uint256 = 0,\n    _minAmountB: uint256 = 0,\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, uint256, uint256, uint256):\n    ad: ws.ActionData = self._performPreActionTasks(msg.sender, ws.ActionType.REMOVE_LIQ, False, [_tokenA, _tokenB], [_legoId])\n\n    # remove liquidity via lego partner\n    amountAReceived: uint256 = 0\n    amountBReceived: uint256 = 0\n    lpAmountBurned: uint256 = 0\n    txUsdValue: uint256 = 0\n    lpAmount: uint256 = self._getAmountAndApprove(_lpToken, _lpAmount, ad.legoAddr)\n    amountAReceived, amountBReceived, lpAmountBurned, txUsdValue = extcall Lego(ad.legoAddr).removeLiquidity(_pool, _tokenA, _tokenB, _lpToken, lpAmount, _minAmountA, _minAmountB, _extraData, self, self._packMiniAddys(ad.ledger, ad.missionControl, ad.legoBook, ad.appraiser))\n    self._resetApproval(_lpToken, ad.legoAddr)\n\n    self._performPostActionTasks([_tokenA, _tokenB, _lpToken], txUsdValue, ad)\n    log WalletAction(\n        op = 31,\n        asset1 = _tokenA,\n        asset2 = _tokenB,\n        amount1 = amountAReceived,\n        amount2 = amountBReceived,\n        usdValue = txUsdValue,\n        legoId = ad.legoId,\n        signer = ad.signer,\n    )\n    return amountAReceived, amountBReceived, lpAmountBurned, txUsdValue\n\n\n# concentrated liquidity\n\n\n@nonreentrant\n@external\ndef addLiquidityConcentrated(\n    _legoId: uint256,\n    _nftAddr: address,\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _amountA: uint256 = max_value(uint256),\n    _amountB: uint256 = max_value(uint256),\n    _tickLower: int24 = min_value(int24),\n    _tickUpper: int24 = max_value(int24),\n    _minAmountA: uint256 = 0,\n    _minAmountB: uint256 = 0,\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, uint256, uint256, uint256, uint256):\n    ad: ws.ActionData = self._performPreActionTasks(msg.sender, ws.ActionType.ADD_LIQ_CONC, False, [_tokenA, _tokenB], [_legoId])\n\n    # token approvals\n    amountA: uint256 = 0\n    if _amountA != 0:\n        amountA = self._getAmountAndApprove(_tokenA, _amountA, ad.legoAddr)\n    amountB: uint256 = 0\n    if _amountB != 0:\n        amountB = self._getAmountAndApprove(_tokenB, _amountB, ad.legoAddr)\n\n    # transfer nft to lego (if applicable)\n    hasNftLiqPosition: bool = _nftAddr != empty(address) and _nftTokenId != 0\n    if hasNftLiqPosition:\n        extcall IERC721(_nftAddr).safeTransferFrom(self, ad.legoAddr, _nftTokenId, ERC721_RECEIVE_DATA)\n\n    # add liquidity via lego partner\n    liqAdded: uint256 = 0\n    addedTokenA: uint256 = 0\n    addedTokenB: uint256 = 0\n    nftTokenId: uint256 = 0\n    txUsdValue: uint256 = 0\n    liqAdded, addedTokenA, addedTokenB, nftTokenId, txUsdValue = extcall Lego(ad.legoAddr).addLiquidityConcentrated(_nftTokenId, _pool, _tokenA, _tokenB, _tickLower, _tickUpper, amountA, amountB, _minAmountA, _minAmountB, _extraData, self, self._packMiniAddys(ad.ledger, ad.missionControl, ad.legoBook, ad.appraiser))\n\n    # make sure nft is back\n    assert staticcall IERC721(_nftAddr).ownerOf(nftTokenId) == self # dev: nft not returned\n\n    # remove approvals\n    if amountA != 0:\n        self._resetApproval(_tokenA, ad.legoAddr)\n    if amountB != 0:\n        self._resetApproval(_tokenB, ad.legoAddr)\n\n    self._performPostActionTasks([_tokenA, _tokenB], txUsdValue, ad)\n    log WalletActionExt(\n        op = 32,\n        asset1 = _tokenA,\n        asset2 = _tokenB,\n        tokenId = nftTokenId,\n        amount1 = addedTokenA,\n        amount2 = addedTokenB,\n        usdValue = txUsdValue,\n        extra = liqAdded,\n    )\n    return liqAdded, addedTokenA, addedTokenB, nftTokenId, txUsdValue\n\n\n@nonreentrant\n@external\ndef removeLiquidityConcentrated(\n    _legoId: uint256,\n    _nftAddr: address,\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _liqToRemove: uint256 = max_value(uint256),\n    _minAmountA: uint256 = 0,\n    _minAmountB: uint256 = 0,\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, uint256, uint256, uint256):\n    ad: ws.ActionData = self._performPreActionTasks(msg.sender, ws.ActionType.REMOVE_LIQ_CONC, False, [_tokenA, _tokenB], [_legoId])\n\n    # must have nft liq position\n    assert _nftAddr != empty(address) # dev: invalid nft addr\n    assert _nftTokenId != 0 # dev: invalid nft token id\n    extcall IERC721(_nftAddr).safeTransferFrom(self, ad.legoAddr, _nftTokenId, ERC721_RECEIVE_DATA)\n\n    # remove liquidity via lego partner\n    amountAReceived: uint256 = 0\n    amountBReceived: uint256 = 0\n    liqRemoved: uint256 = 0\n    isDepleted: bool = False\n    txUsdValue: uint256 = 0\n    amountAReceived, amountBReceived, liqRemoved, isDepleted, txUsdValue = extcall Lego(ad.legoAddr).removeLiquidityConcentrated(_nftTokenId, _pool, _tokenA, _tokenB, _liqToRemove, _minAmountA, _minAmountB, _extraData, self, self._packMiniAddys(ad.ledger, ad.missionControl, ad.legoBook, ad.appraiser))\n\n    # validate the nft came back (if not depleted)\n    if not isDepleted:\n        assert staticcall IERC721(_nftAddr).ownerOf(_nftTokenId) == self # dev: nft not returned\n\n    self._performPostActionTasks([_tokenA, _tokenB], txUsdValue, ad)\n    log WalletActionExt(\n        op = 33,\n        asset1 = _tokenA,\n        asset2 = _tokenB,\n        tokenId = _nftTokenId,\n        amount1 = amountAReceived,\n        amount2 = amountBReceived,\n        usdValue = txUsdValue,\n        extra = liqRemoved,\n    )\n    return amountAReceived, amountBReceived, liqRemoved, txUsdValue\n\n\n#################\n# House Keeping #\n#################\n\n\n# pre action tasks\n\n\n@internal\ndef _performPreActionTasks(\n    _signer: address,\n    _action: ws.ActionType,\n    _shouldCheckAccess: bool,\n    _assets: DynArray[address, MAX_ASSETS],\n    _legoIds: DynArray[uint256, MAX_LEGOS] = [],\n    _transferRecipient: address = empty(address),\n) -> ws.ActionData:\n    legoId: uint256 = 0\n    if len(_legoIds) != 0:\n        legoId = _legoIds[0]\n    ad: ws.ActionData = staticcall WalletConfig(self.walletConfig).checkSignerPermissionsAndGetBundle(_signer, _action, _assets, _legoIds, _transferRecipient)\n\n    # cannot perform any actions if wallet is frozen\n    assert not ad.isFrozen # dev: frozen wallet\n\n    # eject mode can only do transfer and eth conversions\n    if ad.inEjectMode:\n        assert _action in (ws.ActionType.TRANSFER | ws.ActionType.ETH_TO_WETH | ws.ActionType.WETH_TO_ETH) # dev: invalid action in eject mode\n        return ad\n\n    # make sure lego can perform the action\n    if _shouldCheckAccess:\n        self._setLegoAccessForAction(ad.legoAddr, _action)\n\n    # check for yield to realize\n    checkedAssets: DynArray[address, MAX_ASSETS] = []\n    for a: address in _assets:\n        if a in checkedAssets:\n            continue\n        self._checkForYieldProfits(a, ad)\n        checkedAssets.append(a)\n\n    return ad\n\n\n# post action tasks\n\n\n@internal\ndef _performPostActionTasks(\n    _assets: DynArray[address, MAX_ASSETS],\n    _txUsdValue: uint256,\n    _ad: ws.ActionData,\n    _isSpecialTx: bool = False,\n):\n    # first, check and update manager caps\n    if not _isSpecialTx and _ad.signer != _ad.billing:\n        assert extcall WalletConfig(_ad.walletConfig).checkManagerUsdLimitsAndUpdateData(_ad.signer, _txUsdValue) # dev: manager limits not allowed\n\n    # can immediately deregister assets on zero balance\n    canDeregister: bool = True\n    if _isSpecialTx or _ad.signer == _ad.billing:\n        canDeregister = False\n\n    # update each asset that was touched\n    newTotalUsdValue: uint256 = _ad.lastTotalUsdValue\n    for a: address in _assets:\n        newTotalUsdValue = self._updateAssetData(a, newTotalUsdValue, canDeregister, _ad)\n\n    if not _ad.inEjectMode:\n        extcall LootDistributor(_ad.lootDistributor).updateDepositPointsWithNewValue(self, newTotalUsdValue)\n\n        # check if wallet still has trial funds\n        if not _isSpecialTx:\n            assert staticcall Hatchery(_ad.hatchery).doesWalletStillHaveTrialFundsWithAddys(self, _ad.walletConfig, _ad.missionControl, _ad.legoBook, _ad.appraiser, _ad.ledger) # dev: wallet has no trial funds\n\n\n##################\n# Yield Handling #\n##################\n\n\n@internal\ndef _checkForYieldProfits(_asset: address, _ad: ws.ActionData):\n    if _asset in [empty(address), _ad.eth, _ad.weth]:\n        return\n\n    # skip if already checked\n    if self.checkedYield[_asset]:\n        return\n\n    # nothing to do here (nothing saved, not a yield asset)\n    data: ws.WalletAssetData = self.assetData[_asset]\n    if data.assetBalance == 0 or not data.isYieldAsset:\n        return\n\n    # no balance, nothing to do here\n    currentBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    if currentBalance == 0:\n        return\n\n    # calculate yield profits\n    yieldRealized: uint256 = 0\n    feeRatio: uint256 = 0\n    data.lastPricePerShare, yieldRealized, feeRatio = extcall Appraiser(_ad.appraiser).calculateYieldProfits(_asset, currentBalance, data.assetBalance, data.lastPricePerShare, _ad.missionControl, _ad.legoBook)\n\n    # only save if appraiser returns a price per share (non-rebasing assets)\n    if data.lastPricePerShare != 0:\n        self.assetData[_asset] = data\n\n    # pay yield fee\n    self._payYieldFee(_asset, yieldRealized, feeRatio, _ad)\n\n    # mark as checked\n    self.checkedYield[_asset] = True\n\n\n##############\n# Asset Data #\n##############\n\n\n# from wallet config\n\n\n@external\ndef updateAssetData(\n    _legoId: uint256,\n    _asset: address,\n    _shouldCheckYield: bool,\n    _prevTotalUsdValue: uint256,\n    _ad: ws.ActionData = empty(ws.ActionData),\n) -> uint256:\n    walletConfig: address = self.walletConfig\n    assert msg.sender == walletConfig # dev: perms\n\n    ad: ws.ActionData = _ad\n    if ad.signer == empty(address):\n        ad = staticcall WalletConfig(walletConfig).getActionDataBundle(_legoId, walletConfig)\n\n    # check for yield\n    if _shouldCheckYield and not ad.inEjectMode:\n        self._checkForYieldProfits(_asset, ad)\n\n    # update asset data\n    return self._updateAssetData(_asset, _prevTotalUsdValue, False, ad)\n\n\n# update asset data\n\n\n@internal\ndef _updateAssetData(\n    _asset: address,\n    _prevTotalUsdValue: uint256,\n    _canDeregister: bool,\n    _ad: ws.ActionData,\n) -> uint256:\n    if _asset == empty(address):\n        return _prevTotalUsdValue\n\n    data: ws.WalletAssetData = self.assetData[_asset]\n    newTotalUsdValue: uint256 = _prevTotalUsdValue - min(data.usdValue, _prevTotalUsdValue)\n\n    # ETH / ERC20\n    currentBalance: uint256 = 0\n    if _asset == _ad.eth:\n        currentBalance = self.balance\n    else:\n        currentBalance = staticcall IERC20(_asset).balanceOf(self)\n\n    # no balance, deregister asset\n    if currentBalance == 0:\n        data.assetBalance = 0\n        data.usdValue = 0\n        self.assetData[_asset] = data\n\n        # in some cases (wallet migration, trial funds clawback, pulling payment, etc), we are iterating thru assets\n        # we cannot deregister here or it'll mess up the indexes/order/iteration\n        if _canDeregister:\n            self._deregisterAsset(_asset)\n\n        return newTotalUsdValue\n\n    # update usd value\n    data.usdValue = 0\n    data.isYieldAsset = False\n    if not _ad.inEjectMode:\n        data.usdValue, data.isYieldAsset = extcall Appraiser(_ad.appraiser).updatePriceAndGetUsdValueAndIsYieldAsset(_asset, currentBalance, _ad.missionControl, _ad.legoBook)\n        newTotalUsdValue += data.usdValue\n\n    # when receiving vault token for the first time, need to get price per share\n    if data.isYieldAsset and data.lastPricePerShare == 0:\n        data.lastPricePerShare = staticcall Appraiser(_ad.appraiser).lastPricePerShare(_asset)\n\n    # save data\n    data.assetBalance = currentBalance\n    self.assetData[_asset] = data\n\n    # register asset (if necessary)\n    if self.indexOfAsset[_asset] == 0:\n        self._registerAsset(_asset)\n\n    return newTotalUsdValue\n\n\n# register asset\n\n\n@internal\ndef _registerAsset(_asset: address):\n    aid: uint256 = self.numAssets\n    self.assets[aid] = _asset\n    self.indexOfAsset[_asset] = aid\n    self.numAssets = aid + 1\n\n\n# deregister asset\n\n\n@external\ndef deregisterAsset(_asset: address) -> bool:\n    assert msg.sender == self.walletConfig # dev: perms\n    return self._deregisterAsset(_asset)\n\n\n@internal\ndef _deregisterAsset(_asset: address) -> bool:\n    if staticcall IERC20(_asset).balanceOf(self) != 0:\n        return False\n\n    numAssets: uint256 = self.numAssets\n    if numAssets == 1:\n        return False\n\n    targetIndex: uint256 = self.indexOfAsset[_asset]\n    if targetIndex == 0:\n        return False\n\n    # update data\n    lastIndex: uint256 = numAssets - 1\n    self.numAssets = lastIndex\n    self.indexOfAsset[_asset] = 0\n\n    # get last item, replace the removed item\n    if targetIndex != lastIndex:\n        lastItem: address = self.assets[lastIndex]\n        self.assets[targetIndex] = lastItem\n        self.indexOfAsset[lastItem] = targetIndex\n\n    return True\n\n\n#############\n# Utilities #\n#############\n\n\n# pay fees\n\n\n@internal\ndef _payYieldFee(\n    _asset: address,\n    _yieldRealized: uint256,\n    _feeRatio: uint256,\n    _ad: ws.ActionData,\n):\n    if _ad.lootDistributor == empty(address):\n        return\n\n    feeAmount: uint256 = _yieldRealized * min(_feeRatio, 25_00) // HUNDRED_PERCENT\n    if feeAmount != 0:\n        assert extcall IERC20(_asset).transfer(_ad.lootDistributor, feeAmount, default_return_value = True) # dev: xfer\n\n    # notify loot distributor\n    if feeAmount != 0 or _yieldRealized != 0:\n        extcall LootDistributor(_ad.lootDistributor).addLootFromYieldProfit(_asset, feeAmount, _yieldRealized, _ad.missionControl, _ad.appraiser, _ad.legoBook)\n\n\n# pay transaction fees (swap / rewards)\n\n\n@internal\ndef _payTransactionFee(\n    _asset: address,\n    _transactionValue: uint256,\n    _feeRatio: uint256,\n    _action: ws.ActionType,\n    _lootDistributor: address,\n    _missionControl: address,\n) -> uint256:\n    feeAmount: uint256 = min(_transactionValue * _feeRatio // HUNDRED_PERCENT, staticcall IERC20(_asset).balanceOf(self))\n    if feeAmount == 0:\n        return 0\n    assert extcall IERC20(_asset).approve(_lootDistributor, feeAmount, default_return_value = True) # dev: appr\n    extcall LootDistributor(_lootDistributor).addLootFromSwapOrRewards(_asset, feeAmount, _action, _missionControl)\n    self._resetApproval(_asset, _lootDistributor)\n    return feeAmount\n\n\n# update price and get usd value\n\n\n@internal\ndef _updatePriceAndGetUsdValue(_asset: address, _amount: uint256, _ad: ws.ActionData) -> uint256:\n    if _ad.inEjectMode:\n        return 0\n    return extcall Appraiser(_ad.appraiser).updatePriceAndGetUsdValue(_asset, _amount, _ad.missionControl, _ad.legoBook)\n\n\n# approve\n\n\n@internal\ndef _getAmountAndApprove(_token: address, _amount: uint256, _legoAddr: address) -> uint256:\n    amount: uint256 = min(_amount, staticcall IERC20(_token).balanceOf(self))\n    assert amount != 0 # dev: no balance for _token\n    if _legoAddr != empty(address):\n        assert extcall IERC20(_token).approve(_legoAddr, amount, default_return_value = True) # dev: appr\n    return amount\n\n\n# reset approval\n\n\n@internal\ndef _resetApproval(_token: address, _legoAddr: address):\n    if _legoAddr != empty(address):\n        assert extcall IERC20(_token).approve(_legoAddr, 0, default_return_value = True) # dev: appr\n\n\n# recover nft\n\n\n@external\ndef recoverNft(_collection: address, _nftTokenId: uint256, _recipient: address):\n    assert msg.sender == self.walletConfig # dev: perms\n    extcall IERC721(_collection).safeTransferFrom(self, _recipient, _nftTokenId)\n\n\n# lego access\n\n\n@external\ndef setLegoAccessForAction(_legoAddr: address, _action: ws.ActionType) -> bool:\n    assert msg.sender == self.walletConfig # dev: perms\n    return self._setLegoAccessForAction(_legoAddr, _action)\n\n\n@internal\ndef _setLegoAccessForAction(_legoAddr: address, _action: ws.ActionType) -> bool:\n    if _legoAddr == empty(address):\n        return False\n\n    targetAddr: address = empty(address)\n    accessAbi: String[64] = empty(String[64])\n    numInputs: uint256 = 0\n    targetAddr, accessAbi, numInputs = staticcall Lego(_legoAddr).getAccessForLego(self, _action)\n\n    # nothing to do here\n    if targetAddr == empty(address):\n        return False\n\n    method_abi: bytes4 = convert(slice(keccak256(accessAbi), 0, 4), bytes4)\n    success: bool = False\n    response: Bytes[32] = b\"\"\n\n    # assumes input is: lego addr (operator)\n    if numInputs == 1:\n        success, response = raw_call(\n            targetAddr,\n            concat(\n                method_abi,\n                convert(_legoAddr, bytes32),\n            ),\n            revert_on_failure = False,\n            max_outsize = 32,\n        )\n\n    # assumes input (and order) is: user (self), lego addr (operator)\n    elif numInputs == 2:\n        success, response = raw_call(\n            targetAddr,\n            concat(\n                method_abi,\n                convert(self, bytes32),\n                convert(_legoAddr, bytes32),\n            ),\n            revert_on_failure = False,\n            max_outsize = 32,\n        )\n\n    # assumes input (and order) is: user (self), lego addr (operator), allowed bool\n    elif numInputs == 3:\n        success, response = raw_call(\n            targetAddr,\n            concat(\n                method_abi,\n                convert(self, bytes32),\n                convert(_legoAddr, bytes32),\n                convert(True, bytes32),\n            ),\n            revert_on_failure = False,\n            max_outsize = 32,\n        )\n\n    assert success # dev: failed to set operator\n    return True\n\n\n# mini addys\n\n\n@view\n@internal\ndef _packMiniAddys(\n    _ledger: address,\n    _missionControl: address,\n    _legoBook: address,\n    _appraiser: address,\n) -> ws.MiniAddys:\n    return ws.MiniAddys(\n        ledger = _ledger,\n        missionControl = _missionControl,\n        legoBook = _legoBook,\n        appraiser = _appraiser,\n    )",
            "sha256sum": "d3897392b6cc2ad395f299de8d5ed03f35a21030c5e8101a8cd601a03c354885"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/core/userWallet/UserWallet.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.3+commit.bff19ea2",
        "integrity": "dae6c5c56d01c5cbc1e484a71b39d42ea4d25351d964a101c105b3935fd1c38f"
      },
      "args": "",
      "file": "contracts/core/userWallet/UserWallet.vy"
    },
    "UserWalletConfig": {
      "address": "0x0E7064202c4F906Adc4D9F6D3C92470b62F624F1",
      "abi": [
        {
          "name": "EjectionModeSet",
          "inputs": [
            {
              "name": "inEjectMode",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "FrozenSet",
          "inputs": [
            {
              "name": "isFrozen",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "caller",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "NftRecovered",
          "inputs": [
            {
              "name": "collection",
              "type": "address",
              "indexed": true
            },
            {
              "name": "nftTokenId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "OwnershipChangeInitiated",
          "inputs": [
            {
              "name": "prevOwner",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newOwner",
              "type": "address",
              "indexed": true
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "OwnershipChangeConfirmed",
          "inputs": [
            {
              "name": "prevOwner",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newOwner",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "OwnershipChangeCancelled",
          "inputs": [
            {
              "name": "cancelledOwner",
              "type": "address",
              "indexed": true
            },
            {
              "name": "cancelledBy",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "OwnershipTimeLockSet",
          "inputs": [
            {
              "name": "numBlocks",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "changeOwnership",
          "inputs": [
            {
              "name": "_newOwner",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmOwnershipChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelOwnershipChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPendingOwnerChange",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setOwnershipTimeLock",
          "inputs": [
            {
              "name": "_numBlocks",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "owner",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ownershipTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingOwner",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "newOwner",
                  "type": "address"
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MIN_OWNERSHIP_TIMELOCK",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MAX_OWNERSHIP_TIMELOCK",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setWallet",
          "inputs": [
            {
              "name": "_wallet",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "pure",
          "type": "function",
          "name": "apiVersion",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "string"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "checkSignerPermissionsAndGetBundle",
          "inputs": [
            {
              "name": "_signer",
              "type": "address"
            },
            {
              "name": "_action",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "hatchery",
                  "type": "address"
                },
                {
                  "name": "lootDistributor",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                },
                {
                  "name": "billing",
                  "type": "address"
                },
                {
                  "name": "wallet",
                  "type": "address"
                },
                {
                  "name": "walletConfig",
                  "type": "address"
                },
                {
                  "name": "walletOwner",
                  "type": "address"
                },
                {
                  "name": "inEjectMode",
                  "type": "bool"
                },
                {
                  "name": "isFrozen",
                  "type": "bool"
                },
                {
                  "name": "lastTotalUsdValue",
                  "type": "uint256"
                },
                {
                  "name": "signer",
                  "type": "address"
                },
                {
                  "name": "isManager",
                  "type": "bool"
                },
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "legoAddr",
                  "type": "address"
                },
                {
                  "name": "eth",
                  "type": "address"
                },
                {
                  "name": "weth",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "checkSignerPermissionsAndGetBundle",
          "inputs": [
            {
              "name": "_signer",
              "type": "address"
            },
            {
              "name": "_action",
              "type": "uint256"
            },
            {
              "name": "_assets",
              "type": "address[]"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "hatchery",
                  "type": "address"
                },
                {
                  "name": "lootDistributor",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                },
                {
                  "name": "billing",
                  "type": "address"
                },
                {
                  "name": "wallet",
                  "type": "address"
                },
                {
                  "name": "walletConfig",
                  "type": "address"
                },
                {
                  "name": "walletOwner",
                  "type": "address"
                },
                {
                  "name": "inEjectMode",
                  "type": "bool"
                },
                {
                  "name": "isFrozen",
                  "type": "bool"
                },
                {
                  "name": "lastTotalUsdValue",
                  "type": "uint256"
                },
                {
                  "name": "signer",
                  "type": "address"
                },
                {
                  "name": "isManager",
                  "type": "bool"
                },
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "legoAddr",
                  "type": "address"
                },
                {
                  "name": "eth",
                  "type": "address"
                },
                {
                  "name": "weth",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "checkSignerPermissionsAndGetBundle",
          "inputs": [
            {
              "name": "_signer",
              "type": "address"
            },
            {
              "name": "_action",
              "type": "uint256"
            },
            {
              "name": "_assets",
              "type": "address[]"
            },
            {
              "name": "_legoIds",
              "type": "uint256[]"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "hatchery",
                  "type": "address"
                },
                {
                  "name": "lootDistributor",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                },
                {
                  "name": "billing",
                  "type": "address"
                },
                {
                  "name": "wallet",
                  "type": "address"
                },
                {
                  "name": "walletConfig",
                  "type": "address"
                },
                {
                  "name": "walletOwner",
                  "type": "address"
                },
                {
                  "name": "inEjectMode",
                  "type": "bool"
                },
                {
                  "name": "isFrozen",
                  "type": "bool"
                },
                {
                  "name": "lastTotalUsdValue",
                  "type": "uint256"
                },
                {
                  "name": "signer",
                  "type": "address"
                },
                {
                  "name": "isManager",
                  "type": "bool"
                },
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "legoAddr",
                  "type": "address"
                },
                {
                  "name": "eth",
                  "type": "address"
                },
                {
                  "name": "weth",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "checkSignerPermissionsAndGetBundle",
          "inputs": [
            {
              "name": "_signer",
              "type": "address"
            },
            {
              "name": "_action",
              "type": "uint256"
            },
            {
              "name": "_assets",
              "type": "address[]"
            },
            {
              "name": "_legoIds",
              "type": "uint256[]"
            },
            {
              "name": "_transferRecipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "hatchery",
                  "type": "address"
                },
                {
                  "name": "lootDistributor",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                },
                {
                  "name": "billing",
                  "type": "address"
                },
                {
                  "name": "wallet",
                  "type": "address"
                },
                {
                  "name": "walletConfig",
                  "type": "address"
                },
                {
                  "name": "walletOwner",
                  "type": "address"
                },
                {
                  "name": "inEjectMode",
                  "type": "bool"
                },
                {
                  "name": "isFrozen",
                  "type": "bool"
                },
                {
                  "name": "lastTotalUsdValue",
                  "type": "uint256"
                },
                {
                  "name": "signer",
                  "type": "address"
                },
                {
                  "name": "isManager",
                  "type": "bool"
                },
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "legoAddr",
                  "type": "address"
                },
                {
                  "name": "eth",
                  "type": "address"
                },
                {
                  "name": "weth",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "checkManagerUsdLimitsAndUpdateData",
          "inputs": [
            {
              "name": "_manager",
              "type": "address"
            },
            {
              "name": "_txUsdValue",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "checkRecipientLimitsAndUpdateData",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_txUsdValue",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "validateCheque",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_txUsdValue",
              "type": "uint256"
            },
            {
              "name": "_signer",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addPendingWhitelistAddr",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            },
            {
              "name": "_pending",
              "type": "tuple",
              "components": [
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                },
                {
                  "name": "currentOwner",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelPendingWhitelistAddr",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmWhitelistAddr",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addWhitelistAddrViaMigrator",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeWhitelistAddr",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addManager",
          "inputs": [
            {
              "name": "_manager",
              "type": "address"
            },
            {
              "name": "_config",
              "type": "tuple",
              "components": [
                {
                  "name": "startBlock",
                  "type": "uint256"
                },
                {
                  "name": "expiryBlock",
                  "type": "uint256"
                },
                {
                  "name": "limits",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "maxUsdValuePerTx",
                      "type": "uint256"
                    },
                    {
                      "name": "maxUsdValuePerPeriod",
                      "type": "uint256"
                    },
                    {
                      "name": "maxUsdValueLifetime",
                      "type": "uint256"
                    },
                    {
                      "name": "maxNumTxsPerPeriod",
                      "type": "uint256"
                    },
                    {
                      "name": "txCooldownBlocks",
                      "type": "uint256"
                    },
                    {
                      "name": "failOnZeroPrice",
                      "type": "bool"
                    }
                  ]
                },
                {
                  "name": "legoPerms",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "canManageYield",
                      "type": "bool"
                    },
                    {
                      "name": "canBuyAndSell",
                      "type": "bool"
                    },
                    {
                      "name": "canManageDebt",
                      "type": "bool"
                    },
                    {
                      "name": "canManageLiq",
                      "type": "bool"
                    },
                    {
                      "name": "canClaimRewards",
                      "type": "bool"
                    },
                    {
                      "name": "allowedLegos",
                      "type": "uint256[]"
                    }
                  ]
                },
                {
                  "name": "whitelistPerms",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "canAddPending",
                      "type": "bool"
                    },
                    {
                      "name": "canConfirm",
                      "type": "bool"
                    },
                    {
                      "name": "canCancel",
                      "type": "bool"
                    },
                    {
                      "name": "canRemove",
                      "type": "bool"
                    }
                  ]
                },
                {
                  "name": "transferPerms",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "canTransfer",
                      "type": "bool"
                    },
                    {
                      "name": "canCreateCheque",
                      "type": "bool"
                    },
                    {
                      "name": "canAddPendingPayee",
                      "type": "bool"
                    },
                    {
                      "name": "allowedPayees",
                      "type": "address[]"
                    }
                  ]
                },
                {
                  "name": "allowedAssets",
                  "type": "address[]"
                },
                {
                  "name": "canClaimLoot",
                  "type": "bool"
                }
              ]
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "updateManager",
          "inputs": [
            {
              "name": "_manager",
              "type": "address"
            },
            {
              "name": "_config",
              "type": "tuple",
              "components": [
                {
                  "name": "startBlock",
                  "type": "uint256"
                },
                {
                  "name": "expiryBlock",
                  "type": "uint256"
                },
                {
                  "name": "limits",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "maxUsdValuePerTx",
                      "type": "uint256"
                    },
                    {
                      "name": "maxUsdValuePerPeriod",
                      "type": "uint256"
                    },
                    {
                      "name": "maxUsdValueLifetime",
                      "type": "uint256"
                    },
                    {
                      "name": "maxNumTxsPerPeriod",
                      "type": "uint256"
                    },
                    {
                      "name": "txCooldownBlocks",
                      "type": "uint256"
                    },
                    {
                      "name": "failOnZeroPrice",
                      "type": "bool"
                    }
                  ]
                },
                {
                  "name": "legoPerms",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "canManageYield",
                      "type": "bool"
                    },
                    {
                      "name": "canBuyAndSell",
                      "type": "bool"
                    },
                    {
                      "name": "canManageDebt",
                      "type": "bool"
                    },
                    {
                      "name": "canManageLiq",
                      "type": "bool"
                    },
                    {
                      "name": "canClaimRewards",
                      "type": "bool"
                    },
                    {
                      "name": "allowedLegos",
                      "type": "uint256[]"
                    }
                  ]
                },
                {
                  "name": "whitelistPerms",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "canAddPending",
                      "type": "bool"
                    },
                    {
                      "name": "canConfirm",
                      "type": "bool"
                    },
                    {
                      "name": "canCancel",
                      "type": "bool"
                    },
                    {
                      "name": "canRemove",
                      "type": "bool"
                    }
                  ]
                },
                {
                  "name": "transferPerms",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "canTransfer",
                      "type": "bool"
                    },
                    {
                      "name": "canCreateCheque",
                      "type": "bool"
                    },
                    {
                      "name": "canAddPendingPayee",
                      "type": "bool"
                    },
                    {
                      "name": "allowedPayees",
                      "type": "address[]"
                    }
                  ]
                },
                {
                  "name": "allowedAssets",
                  "type": "address[]"
                },
                {
                  "name": "canClaimLoot",
                  "type": "bool"
                }
              ]
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeManager",
          "inputs": [
            {
              "name": "_manager",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setGlobalManagerSettings",
          "inputs": [
            {
              "name": "_config",
              "type": "tuple",
              "components": [
                {
                  "name": "managerPeriod",
                  "type": "uint256"
                },
                {
                  "name": "startDelay",
                  "type": "uint256"
                },
                {
                  "name": "activationLength",
                  "type": "uint256"
                },
                {
                  "name": "canOwnerManage",
                  "type": "bool"
                },
                {
                  "name": "limits",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "maxUsdValuePerTx",
                      "type": "uint256"
                    },
                    {
                      "name": "maxUsdValuePerPeriod",
                      "type": "uint256"
                    },
                    {
                      "name": "maxUsdValueLifetime",
                      "type": "uint256"
                    },
                    {
                      "name": "maxNumTxsPerPeriod",
                      "type": "uint256"
                    },
                    {
                      "name": "txCooldownBlocks",
                      "type": "uint256"
                    },
                    {
                      "name": "failOnZeroPrice",
                      "type": "bool"
                    }
                  ]
                },
                {
                  "name": "legoPerms",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "canManageYield",
                      "type": "bool"
                    },
                    {
                      "name": "canBuyAndSell",
                      "type": "bool"
                    },
                    {
                      "name": "canManageDebt",
                      "type": "bool"
                    },
                    {
                      "name": "canManageLiq",
                      "type": "bool"
                    },
                    {
                      "name": "canClaimRewards",
                      "type": "bool"
                    },
                    {
                      "name": "allowedLegos",
                      "type": "uint256[]"
                    }
                  ]
                },
                {
                  "name": "whitelistPerms",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "canAddPending",
                      "type": "bool"
                    },
                    {
                      "name": "canConfirm",
                      "type": "bool"
                    },
                    {
                      "name": "canCancel",
                      "type": "bool"
                    },
                    {
                      "name": "canRemove",
                      "type": "bool"
                    }
                  ]
                },
                {
                  "name": "transferPerms",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "canTransfer",
                      "type": "bool"
                    },
                    {
                      "name": "canCreateCheque",
                      "type": "bool"
                    },
                    {
                      "name": "canAddPendingPayee",
                      "type": "bool"
                    },
                    {
                      "name": "allowedPayees",
                      "type": "address[]"
                    }
                  ]
                },
                {
                  "name": "allowedAssets",
                  "type": "address[]"
                }
              ]
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addPayee",
          "inputs": [
            {
              "name": "_payee",
              "type": "address"
            },
            {
              "name": "_config",
              "type": "tuple",
              "components": [
                {
                  "name": "startBlock",
                  "type": "uint256"
                },
                {
                  "name": "expiryBlock",
                  "type": "uint256"
                },
                {
                  "name": "canPull",
                  "type": "bool"
                },
                {
                  "name": "periodLength",
                  "type": "uint256"
                },
                {
                  "name": "maxNumTxsPerPeriod",
                  "type": "uint256"
                },
                {
                  "name": "txCooldownBlocks",
                  "type": "uint256"
                },
                {
                  "name": "failOnZeroPrice",
                  "type": "bool"
                },
                {
                  "name": "primaryAsset",
                  "type": "address"
                },
                {
                  "name": "onlyPrimaryAsset",
                  "type": "bool"
                },
                {
                  "name": "unitLimits",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "perTxCap",
                      "type": "uint256"
                    },
                    {
                      "name": "perPeriodCap",
                      "type": "uint256"
                    },
                    {
                      "name": "lifetimeCap",
                      "type": "uint256"
                    }
                  ]
                },
                {
                  "name": "usdLimits",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "perTxCap",
                      "type": "uint256"
                    },
                    {
                      "name": "perPeriodCap",
                      "type": "uint256"
                    },
                    {
                      "name": "lifetimeCap",
                      "type": "uint256"
                    }
                  ]
                }
              ]
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "updatePayee",
          "inputs": [
            {
              "name": "_payee",
              "type": "address"
            },
            {
              "name": "_config",
              "type": "tuple",
              "components": [
                {
                  "name": "startBlock",
                  "type": "uint256"
                },
                {
                  "name": "expiryBlock",
                  "type": "uint256"
                },
                {
                  "name": "canPull",
                  "type": "bool"
                },
                {
                  "name": "periodLength",
                  "type": "uint256"
                },
                {
                  "name": "maxNumTxsPerPeriod",
                  "type": "uint256"
                },
                {
                  "name": "txCooldownBlocks",
                  "type": "uint256"
                },
                {
                  "name": "failOnZeroPrice",
                  "type": "bool"
                },
                {
                  "name": "primaryAsset",
                  "type": "address"
                },
                {
                  "name": "onlyPrimaryAsset",
                  "type": "bool"
                },
                {
                  "name": "unitLimits",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "perTxCap",
                      "type": "uint256"
                    },
                    {
                      "name": "perPeriodCap",
                      "type": "uint256"
                    },
                    {
                      "name": "lifetimeCap",
                      "type": "uint256"
                    }
                  ]
                },
                {
                  "name": "usdLimits",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "perTxCap",
                      "type": "uint256"
                    },
                    {
                      "name": "perPeriodCap",
                      "type": "uint256"
                    },
                    {
                      "name": "lifetimeCap",
                      "type": "uint256"
                    }
                  ]
                }
              ]
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removePayee",
          "inputs": [
            {
              "name": "_payee",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setGlobalPayeeSettings",
          "inputs": [
            {
              "name": "_config",
              "type": "tuple",
              "components": [
                {
                  "name": "defaultPeriodLength",
                  "type": "uint256"
                },
                {
                  "name": "startDelay",
                  "type": "uint256"
                },
                {
                  "name": "activationLength",
                  "type": "uint256"
                },
                {
                  "name": "maxNumTxsPerPeriod",
                  "type": "uint256"
                },
                {
                  "name": "txCooldownBlocks",
                  "type": "uint256"
                },
                {
                  "name": "failOnZeroPrice",
                  "type": "bool"
                },
                {
                  "name": "usdLimits",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "perTxCap",
                      "type": "uint256"
                    },
                    {
                      "name": "perPeriodCap",
                      "type": "uint256"
                    },
                    {
                      "name": "lifetimeCap",
                      "type": "uint256"
                    }
                  ]
                },
                {
                  "name": "canPayOwner",
                  "type": "bool"
                },
                {
                  "name": "canPull",
                  "type": "bool"
                }
              ]
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addPendingPayee",
          "inputs": [
            {
              "name": "_payee",
              "type": "address"
            },
            {
              "name": "_pending",
              "type": "tuple",
              "components": [
                {
                  "name": "settings",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "startBlock",
                      "type": "uint256"
                    },
                    {
                      "name": "expiryBlock",
                      "type": "uint256"
                    },
                    {
                      "name": "canPull",
                      "type": "bool"
                    },
                    {
                      "name": "periodLength",
                      "type": "uint256"
                    },
                    {
                      "name": "maxNumTxsPerPeriod",
                      "type": "uint256"
                    },
                    {
                      "name": "txCooldownBlocks",
                      "type": "uint256"
                    },
                    {
                      "name": "failOnZeroPrice",
                      "type": "bool"
                    },
                    {
                      "name": "primaryAsset",
                      "type": "address"
                    },
                    {
                      "name": "onlyPrimaryAsset",
                      "type": "bool"
                    },
                    {
                      "name": "unitLimits",
                      "type": "tuple",
                      "components": [
                        {
                          "name": "perTxCap",
                          "type": "uint256"
                        },
                        {
                          "name": "perPeriodCap",
                          "type": "uint256"
                        },
                        {
                          "name": "lifetimeCap",
                          "type": "uint256"
                        }
                      ]
                    },
                    {
                      "name": "usdLimits",
                      "type": "tuple",
                      "components": [
                        {
                          "name": "perTxCap",
                          "type": "uint256"
                        },
                        {
                          "name": "perPeriodCap",
                          "type": "uint256"
                        },
                        {
                          "name": "lifetimeCap",
                          "type": "uint256"
                        }
                      ]
                    }
                  ]
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                },
                {
                  "name": "currentOwner",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmPendingPayee",
          "inputs": [
            {
              "name": "_payee",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelPendingPayee",
          "inputs": [
            {
              "name": "_payee",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "createCheque",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_cheque",
              "type": "tuple",
              "components": [
                {
                  "name": "recipient",
                  "type": "address"
                },
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "amount",
                  "type": "uint256"
                },
                {
                  "name": "creationBlock",
                  "type": "uint256"
                },
                {
                  "name": "unlockBlock",
                  "type": "uint256"
                },
                {
                  "name": "expiryBlock",
                  "type": "uint256"
                },
                {
                  "name": "usdValueOnCreation",
                  "type": "uint256"
                },
                {
                  "name": "canManagerPay",
                  "type": "bool"
                },
                {
                  "name": "canBePulled",
                  "type": "bool"
                },
                {
                  "name": "creator",
                  "type": "address"
                },
                {
                  "name": "active",
                  "type": "bool"
                }
              ]
            },
            {
              "name": "_chequeData",
              "type": "tuple",
              "components": [
                {
                  "name": "numChequesPaidInPeriod",
                  "type": "uint256"
                },
                {
                  "name": "totalUsdValuePaidInPeriod",
                  "type": "uint256"
                },
                {
                  "name": "totalNumChequesPaid",
                  "type": "uint256"
                },
                {
                  "name": "totalUsdValuePaid",
                  "type": "uint256"
                },
                {
                  "name": "lastChequePaidBlock",
                  "type": "uint256"
                },
                {
                  "name": "numChequesCreatedInPeriod",
                  "type": "uint256"
                },
                {
                  "name": "totalUsdValueCreatedInPeriod",
                  "type": "uint256"
                },
                {
                  "name": "totalNumChequesCreated",
                  "type": "uint256"
                },
                {
                  "name": "totalUsdValueCreated",
                  "type": "uint256"
                },
                {
                  "name": "lastChequeCreatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "periodStartBlock",
                  "type": "uint256"
                }
              ]
            },
            {
              "name": "_isExistingCheque",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelCheque",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setChequeSettings",
          "inputs": [
            {
              "name": "_config",
              "type": "tuple",
              "components": [
                {
                  "name": "maxNumActiveCheques",
                  "type": "uint256"
                },
                {
                  "name": "maxChequeUsdValue",
                  "type": "uint256"
                },
                {
                  "name": "instantUsdThreshold",
                  "type": "uint256"
                },
                {
                  "name": "perPeriodPaidUsdCap",
                  "type": "uint256"
                },
                {
                  "name": "maxNumChequesPaidPerPeriod",
                  "type": "uint256"
                },
                {
                  "name": "payCooldownBlocks",
                  "type": "uint256"
                },
                {
                  "name": "perPeriodCreatedUsdCap",
                  "type": "uint256"
                },
                {
                  "name": "maxNumChequesCreatedPerPeriod",
                  "type": "uint256"
                },
                {
                  "name": "createCooldownBlocks",
                  "type": "uint256"
                },
                {
                  "name": "periodLength",
                  "type": "uint256"
                },
                {
                  "name": "expensiveDelayBlocks",
                  "type": "uint256"
                },
                {
                  "name": "defaultExpiryBlocks",
                  "type": "uint256"
                },
                {
                  "name": "allowedAssets",
                  "type": "address[]"
                },
                {
                  "name": "canManagersCreateCheques",
                  "type": "bool"
                },
                {
                  "name": "canManagerPay",
                  "type": "bool"
                },
                {
                  "name": "canBePulled",
                  "type": "bool"
                }
              ]
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "updateAssetData",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_shouldCheckYield",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "updateAllAssetData",
          "inputs": [
            {
              "name": "_shouldCheckYield",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeTrialFunds",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getTrialFundsInfo",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "migrateFunds",
          "inputs": [
            {
              "name": "_toWallet",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "preparePayment",
          "inputs": [
            {
              "name": "_targetAsset",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "preparePayment",
          "inputs": [
            {
              "name": "_targetAsset",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "deregisterAsset",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverNft",
          "inputs": [
            {
              "name": "_collection",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setFrozen",
          "inputs": [
            {
              "name": "_isFrozen",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setEjectionMode",
          "inputs": [
            {
              "name": "_shouldEject",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setLegoAccessForAction",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_action",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setKernel",
          "inputs": [
            {
              "name": "_kernel",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setSentinel",
          "inputs": [
            {
              "name": "_sentinel",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setHighCommand",
          "inputs": [
            {
              "name": "_highCommand",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setPaymaster",
          "inputs": [
            {
              "name": "_paymaster",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setChequeBook",
          "inputs": [
            {
              "name": "_chequeBook",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setMigrator",
          "inputs": [
            {
              "name": "_migrator",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getActionDataBundle",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_signer",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "hatchery",
                  "type": "address"
                },
                {
                  "name": "lootDistributor",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                },
                {
                  "name": "billing",
                  "type": "address"
                },
                {
                  "name": "wallet",
                  "type": "address"
                },
                {
                  "name": "walletConfig",
                  "type": "address"
                },
                {
                  "name": "walletOwner",
                  "type": "address"
                },
                {
                  "name": "inEjectMode",
                  "type": "bool"
                },
                {
                  "name": "isFrozen",
                  "type": "bool"
                },
                {
                  "name": "lastTotalUsdValue",
                  "type": "uint256"
                },
                {
                  "name": "signer",
                  "type": "address"
                },
                {
                  "name": "isManager",
                  "type": "bool"
                },
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "legoAddr",
                  "type": "address"
                },
                {
                  "name": "eth",
                  "type": "address"
                },
                {
                  "name": "weth",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "wallet",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "kernel",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "sentinel",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "highCommand",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "paymaster",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "chequeBook",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "migrator",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "trialFundsAsset",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "trialFundsAmount",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "managerSettings",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "startBlock",
                  "type": "uint256"
                },
                {
                  "name": "expiryBlock",
                  "type": "uint256"
                },
                {
                  "name": "limits",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "maxUsdValuePerTx",
                      "type": "uint256"
                    },
                    {
                      "name": "maxUsdValuePerPeriod",
                      "type": "uint256"
                    },
                    {
                      "name": "maxUsdValueLifetime",
                      "type": "uint256"
                    },
                    {
                      "name": "maxNumTxsPerPeriod",
                      "type": "uint256"
                    },
                    {
                      "name": "txCooldownBlocks",
                      "type": "uint256"
                    },
                    {
                      "name": "failOnZeroPrice",
                      "type": "bool"
                    }
                  ]
                },
                {
                  "name": "legoPerms",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "canManageYield",
                      "type": "bool"
                    },
                    {
                      "name": "canBuyAndSell",
                      "type": "bool"
                    },
                    {
                      "name": "canManageDebt",
                      "type": "bool"
                    },
                    {
                      "name": "canManageLiq",
                      "type": "bool"
                    },
                    {
                      "name": "canClaimRewards",
                      "type": "bool"
                    },
                    {
                      "name": "allowedLegos",
                      "type": "uint256[]"
                    }
                  ]
                },
                {
                  "name": "whitelistPerms",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "canAddPending",
                      "type": "bool"
                    },
                    {
                      "name": "canConfirm",
                      "type": "bool"
                    },
                    {
                      "name": "canCancel",
                      "type": "bool"
                    },
                    {
                      "name": "canRemove",
                      "type": "bool"
                    }
                  ]
                },
                {
                  "name": "transferPerms",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "canTransfer",
                      "type": "bool"
                    },
                    {
                      "name": "canCreateCheque",
                      "type": "bool"
                    },
                    {
                      "name": "canAddPendingPayee",
                      "type": "bool"
                    },
                    {
                      "name": "allowedPayees",
                      "type": "address[]"
                    }
                  ]
                },
                {
                  "name": "allowedAssets",
                  "type": "address[]"
                },
                {
                  "name": "canClaimLoot",
                  "type": "bool"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "managerPeriodData",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "numTxsInPeriod",
                  "type": "uint256"
                },
                {
                  "name": "totalUsdValueInPeriod",
                  "type": "uint256"
                },
                {
                  "name": "totalNumTxs",
                  "type": "uint256"
                },
                {
                  "name": "totalUsdValue",
                  "type": "uint256"
                },
                {
                  "name": "lastTxBlock",
                  "type": "uint256"
                },
                {
                  "name": "periodStartBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "managers",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfManager",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numManagers",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "payeeSettings",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "startBlock",
                  "type": "uint256"
                },
                {
                  "name": "expiryBlock",
                  "type": "uint256"
                },
                {
                  "name": "canPull",
                  "type": "bool"
                },
                {
                  "name": "periodLength",
                  "type": "uint256"
                },
                {
                  "name": "maxNumTxsPerPeriod",
                  "type": "uint256"
                },
                {
                  "name": "txCooldownBlocks",
                  "type": "uint256"
                },
                {
                  "name": "failOnZeroPrice",
                  "type": "bool"
                },
                {
                  "name": "primaryAsset",
                  "type": "address"
                },
                {
                  "name": "onlyPrimaryAsset",
                  "type": "bool"
                },
                {
                  "name": "unitLimits",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "perTxCap",
                      "type": "uint256"
                    },
                    {
                      "name": "perPeriodCap",
                      "type": "uint256"
                    },
                    {
                      "name": "lifetimeCap",
                      "type": "uint256"
                    }
                  ]
                },
                {
                  "name": "usdLimits",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "perTxCap",
                      "type": "uint256"
                    },
                    {
                      "name": "perPeriodCap",
                      "type": "uint256"
                    },
                    {
                      "name": "lifetimeCap",
                      "type": "uint256"
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "payeePeriodData",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "numTxsInPeriod",
                  "type": "uint256"
                },
                {
                  "name": "totalUnitsInPeriod",
                  "type": "uint256"
                },
                {
                  "name": "totalUsdValueInPeriod",
                  "type": "uint256"
                },
                {
                  "name": "totalNumTxs",
                  "type": "uint256"
                },
                {
                  "name": "totalUnits",
                  "type": "uint256"
                },
                {
                  "name": "totalUsdValue",
                  "type": "uint256"
                },
                {
                  "name": "lastTxBlock",
                  "type": "uint256"
                },
                {
                  "name": "periodStartBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "payees",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfPayee",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numPayees",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingPayees",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "settings",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "startBlock",
                      "type": "uint256"
                    },
                    {
                      "name": "expiryBlock",
                      "type": "uint256"
                    },
                    {
                      "name": "canPull",
                      "type": "bool"
                    },
                    {
                      "name": "periodLength",
                      "type": "uint256"
                    },
                    {
                      "name": "maxNumTxsPerPeriod",
                      "type": "uint256"
                    },
                    {
                      "name": "txCooldownBlocks",
                      "type": "uint256"
                    },
                    {
                      "name": "failOnZeroPrice",
                      "type": "bool"
                    },
                    {
                      "name": "primaryAsset",
                      "type": "address"
                    },
                    {
                      "name": "onlyPrimaryAsset",
                      "type": "bool"
                    },
                    {
                      "name": "unitLimits",
                      "type": "tuple",
                      "components": [
                        {
                          "name": "perTxCap",
                          "type": "uint256"
                        },
                        {
                          "name": "perPeriodCap",
                          "type": "uint256"
                        },
                        {
                          "name": "lifetimeCap",
                          "type": "uint256"
                        }
                      ]
                    },
                    {
                      "name": "usdLimits",
                      "type": "tuple",
                      "components": [
                        {
                          "name": "perTxCap",
                          "type": "uint256"
                        },
                        {
                          "name": "perPeriodCap",
                          "type": "uint256"
                        },
                        {
                          "name": "lifetimeCap",
                          "type": "uint256"
                        }
                      ]
                    }
                  ]
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                },
                {
                  "name": "currentOwner",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "whitelistAddr",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfWhitelist",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numWhitelisted",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingWhitelist",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                },
                {
                  "name": "currentOwner",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "cheques",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "recipient",
                  "type": "address"
                },
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "amount",
                  "type": "uint256"
                },
                {
                  "name": "creationBlock",
                  "type": "uint256"
                },
                {
                  "name": "unlockBlock",
                  "type": "uint256"
                },
                {
                  "name": "expiryBlock",
                  "type": "uint256"
                },
                {
                  "name": "usdValueOnCreation",
                  "type": "uint256"
                },
                {
                  "name": "canManagerPay",
                  "type": "bool"
                },
                {
                  "name": "canBePulled",
                  "type": "bool"
                },
                {
                  "name": "creator",
                  "type": "address"
                },
                {
                  "name": "active",
                  "type": "bool"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "chequeSettings",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "maxNumActiveCheques",
                  "type": "uint256"
                },
                {
                  "name": "maxChequeUsdValue",
                  "type": "uint256"
                },
                {
                  "name": "instantUsdThreshold",
                  "type": "uint256"
                },
                {
                  "name": "perPeriodPaidUsdCap",
                  "type": "uint256"
                },
                {
                  "name": "maxNumChequesPaidPerPeriod",
                  "type": "uint256"
                },
                {
                  "name": "payCooldownBlocks",
                  "type": "uint256"
                },
                {
                  "name": "perPeriodCreatedUsdCap",
                  "type": "uint256"
                },
                {
                  "name": "maxNumChequesCreatedPerPeriod",
                  "type": "uint256"
                },
                {
                  "name": "createCooldownBlocks",
                  "type": "uint256"
                },
                {
                  "name": "periodLength",
                  "type": "uint256"
                },
                {
                  "name": "expensiveDelayBlocks",
                  "type": "uint256"
                },
                {
                  "name": "defaultExpiryBlocks",
                  "type": "uint256"
                },
                {
                  "name": "allowedAssets",
                  "type": "address[]"
                },
                {
                  "name": "canManagersCreateCheques",
                  "type": "bool"
                },
                {
                  "name": "canManagerPay",
                  "type": "bool"
                },
                {
                  "name": "canBePulled",
                  "type": "bool"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "chequePeriodData",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "numChequesPaidInPeriod",
                  "type": "uint256"
                },
                {
                  "name": "totalUsdValuePaidInPeriod",
                  "type": "uint256"
                },
                {
                  "name": "totalNumChequesPaid",
                  "type": "uint256"
                },
                {
                  "name": "totalUsdValuePaid",
                  "type": "uint256"
                },
                {
                  "name": "lastChequePaidBlock",
                  "type": "uint256"
                },
                {
                  "name": "numChequesCreatedInPeriod",
                  "type": "uint256"
                },
                {
                  "name": "totalUsdValueCreatedInPeriod",
                  "type": "uint256"
                },
                {
                  "name": "totalNumChequesCreated",
                  "type": "uint256"
                },
                {
                  "name": "totalUsdValueCreated",
                  "type": "uint256"
                },
                {
                  "name": "lastChequeCreatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "periodStartBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numActiveCheques",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "globalManagerSettings",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "managerPeriod",
                  "type": "uint256"
                },
                {
                  "name": "startDelay",
                  "type": "uint256"
                },
                {
                  "name": "activationLength",
                  "type": "uint256"
                },
                {
                  "name": "canOwnerManage",
                  "type": "bool"
                },
                {
                  "name": "limits",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "maxUsdValuePerTx",
                      "type": "uint256"
                    },
                    {
                      "name": "maxUsdValuePerPeriod",
                      "type": "uint256"
                    },
                    {
                      "name": "maxUsdValueLifetime",
                      "type": "uint256"
                    },
                    {
                      "name": "maxNumTxsPerPeriod",
                      "type": "uint256"
                    },
                    {
                      "name": "txCooldownBlocks",
                      "type": "uint256"
                    },
                    {
                      "name": "failOnZeroPrice",
                      "type": "bool"
                    }
                  ]
                },
                {
                  "name": "legoPerms",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "canManageYield",
                      "type": "bool"
                    },
                    {
                      "name": "canBuyAndSell",
                      "type": "bool"
                    },
                    {
                      "name": "canManageDebt",
                      "type": "bool"
                    },
                    {
                      "name": "canManageLiq",
                      "type": "bool"
                    },
                    {
                      "name": "canClaimRewards",
                      "type": "bool"
                    },
                    {
                      "name": "allowedLegos",
                      "type": "uint256[]"
                    }
                  ]
                },
                {
                  "name": "whitelistPerms",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "canAddPending",
                      "type": "bool"
                    },
                    {
                      "name": "canConfirm",
                      "type": "bool"
                    },
                    {
                      "name": "canCancel",
                      "type": "bool"
                    },
                    {
                      "name": "canRemove",
                      "type": "bool"
                    }
                  ]
                },
                {
                  "name": "transferPerms",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "canTransfer",
                      "type": "bool"
                    },
                    {
                      "name": "canCreateCheque",
                      "type": "bool"
                    },
                    {
                      "name": "canAddPendingPayee",
                      "type": "bool"
                    },
                    {
                      "name": "allowedPayees",
                      "type": "address[]"
                    }
                  ]
                },
                {
                  "name": "allowedAssets",
                  "type": "address[]"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "globalPayeeSettings",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "defaultPeriodLength",
                  "type": "uint256"
                },
                {
                  "name": "startDelay",
                  "type": "uint256"
                },
                {
                  "name": "activationLength",
                  "type": "uint256"
                },
                {
                  "name": "maxNumTxsPerPeriod",
                  "type": "uint256"
                },
                {
                  "name": "txCooldownBlocks",
                  "type": "uint256"
                },
                {
                  "name": "failOnZeroPrice",
                  "type": "bool"
                },
                {
                  "name": "usdLimits",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "perTxCap",
                      "type": "uint256"
                    },
                    {
                      "name": "perPeriodCap",
                      "type": "uint256"
                    },
                    {
                      "name": "lifetimeCap",
                      "type": "uint256"
                    }
                  ]
                },
                {
                  "name": "canPayOwner",
                  "type": "bool"
                },
                {
                  "name": "canPull",
                  "type": "bool"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "timeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isFrozen",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "inEjectMode",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "groupId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "startingAgent",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "didSetWallet",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "UNDY_HQ",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "WETH",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ETH",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MIN_TIMELOCK",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MAX_TIMELOCK",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_undyHq",
              "type": "address"
            },
            {
              "name": "_owner",
              "type": "address"
            },
            {
              "name": "_groupId",
              "type": "uint256"
            },
            {
              "name": "_trialFundsAsset",
              "type": "address"
            },
            {
              "name": "_trialFundsAmount",
              "type": "uint256"
            },
            {
              "name": "_globalManagerSettings",
              "type": "tuple",
              "components": [
                {
                  "name": "managerPeriod",
                  "type": "uint256"
                },
                {
                  "name": "startDelay",
                  "type": "uint256"
                },
                {
                  "name": "activationLength",
                  "type": "uint256"
                },
                {
                  "name": "canOwnerManage",
                  "type": "bool"
                },
                {
                  "name": "limits",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "maxUsdValuePerTx",
                      "type": "uint256"
                    },
                    {
                      "name": "maxUsdValuePerPeriod",
                      "type": "uint256"
                    },
                    {
                      "name": "maxUsdValueLifetime",
                      "type": "uint256"
                    },
                    {
                      "name": "maxNumTxsPerPeriod",
                      "type": "uint256"
                    },
                    {
                      "name": "txCooldownBlocks",
                      "type": "uint256"
                    },
                    {
                      "name": "failOnZeroPrice",
                      "type": "bool"
                    }
                  ]
                },
                {
                  "name": "legoPerms",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "canManageYield",
                      "type": "bool"
                    },
                    {
                      "name": "canBuyAndSell",
                      "type": "bool"
                    },
                    {
                      "name": "canManageDebt",
                      "type": "bool"
                    },
                    {
                      "name": "canManageLiq",
                      "type": "bool"
                    },
                    {
                      "name": "canClaimRewards",
                      "type": "bool"
                    },
                    {
                      "name": "allowedLegos",
                      "type": "uint256[]"
                    }
                  ]
                },
                {
                  "name": "whitelistPerms",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "canAddPending",
                      "type": "bool"
                    },
                    {
                      "name": "canConfirm",
                      "type": "bool"
                    },
                    {
                      "name": "canCancel",
                      "type": "bool"
                    },
                    {
                      "name": "canRemove",
                      "type": "bool"
                    }
                  ]
                },
                {
                  "name": "transferPerms",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "canTransfer",
                      "type": "bool"
                    },
                    {
                      "name": "canCreateCheque",
                      "type": "bool"
                    },
                    {
                      "name": "canAddPendingPayee",
                      "type": "bool"
                    },
                    {
                      "name": "allowedPayees",
                      "type": "address[]"
                    }
                  ]
                },
                {
                  "name": "allowedAssets",
                  "type": "address[]"
                }
              ]
            },
            {
              "name": "_globalPayeeSettings",
              "type": "tuple",
              "components": [
                {
                  "name": "defaultPeriodLength",
                  "type": "uint256"
                },
                {
                  "name": "startDelay",
                  "type": "uint256"
                },
                {
                  "name": "activationLength",
                  "type": "uint256"
                },
                {
                  "name": "maxNumTxsPerPeriod",
                  "type": "uint256"
                },
                {
                  "name": "txCooldownBlocks",
                  "type": "uint256"
                },
                {
                  "name": "failOnZeroPrice",
                  "type": "bool"
                },
                {
                  "name": "usdLimits",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "perTxCap",
                      "type": "uint256"
                    },
                    {
                      "name": "perPeriodCap",
                      "type": "uint256"
                    },
                    {
                      "name": "lifetimeCap",
                      "type": "uint256"
                    }
                  ]
                },
                {
                  "name": "canPayOwner",
                  "type": "bool"
                },
                {
                  "name": "canPull",
                  "type": "bool"
                }
              ]
            },
            {
              "name": "_chequeSettings",
              "type": "tuple",
              "components": [
                {
                  "name": "maxNumActiveCheques",
                  "type": "uint256"
                },
                {
                  "name": "maxChequeUsdValue",
                  "type": "uint256"
                },
                {
                  "name": "instantUsdThreshold",
                  "type": "uint256"
                },
                {
                  "name": "perPeriodPaidUsdCap",
                  "type": "uint256"
                },
                {
                  "name": "maxNumChequesPaidPerPeriod",
                  "type": "uint256"
                },
                {
                  "name": "payCooldownBlocks",
                  "type": "uint256"
                },
                {
                  "name": "perPeriodCreatedUsdCap",
                  "type": "uint256"
                },
                {
                  "name": "maxNumChequesCreatedPerPeriod",
                  "type": "uint256"
                },
                {
                  "name": "createCooldownBlocks",
                  "type": "uint256"
                },
                {
                  "name": "periodLength",
                  "type": "uint256"
                },
                {
                  "name": "expensiveDelayBlocks",
                  "type": "uint256"
                },
                {
                  "name": "defaultExpiryBlocks",
                  "type": "uint256"
                },
                {
                  "name": "allowedAssets",
                  "type": "address[]"
                },
                {
                  "name": "canManagersCreateCheques",
                  "type": "bool"
                },
                {
                  "name": "canManagerPay",
                  "type": "bool"
                },
                {
                  "name": "canBePulled",
                  "type": "bool"
                }
              ]
            },
            {
              "name": "_startingAgent",
              "type": "address"
            },
            {
              "name": "_starterAgentSettings",
              "type": "tuple",
              "components": [
                {
                  "name": "startBlock",
                  "type": "uint256"
                },
                {
                  "name": "expiryBlock",
                  "type": "uint256"
                },
                {
                  "name": "limits",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "maxUsdValuePerTx",
                      "type": "uint256"
                    },
                    {
                      "name": "maxUsdValuePerPeriod",
                      "type": "uint256"
                    },
                    {
                      "name": "maxUsdValueLifetime",
                      "type": "uint256"
                    },
                    {
                      "name": "maxNumTxsPerPeriod",
                      "type": "uint256"
                    },
                    {
                      "name": "txCooldownBlocks",
                      "type": "uint256"
                    },
                    {
                      "name": "failOnZeroPrice",
                      "type": "bool"
                    }
                  ]
                },
                {
                  "name": "legoPerms",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "canManageYield",
                      "type": "bool"
                    },
                    {
                      "name": "canBuyAndSell",
                      "type": "bool"
                    },
                    {
                      "name": "canManageDebt",
                      "type": "bool"
                    },
                    {
                      "name": "canManageLiq",
                      "type": "bool"
                    },
                    {
                      "name": "canClaimRewards",
                      "type": "bool"
                    },
                    {
                      "name": "allowedLegos",
                      "type": "uint256[]"
                    }
                  ]
                },
                {
                  "name": "whitelistPerms",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "canAddPending",
                      "type": "bool"
                    },
                    {
                      "name": "canConfirm",
                      "type": "bool"
                    },
                    {
                      "name": "canCancel",
                      "type": "bool"
                    },
                    {
                      "name": "canRemove",
                      "type": "bool"
                    }
                  ]
                },
                {
                  "name": "transferPerms",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "canTransfer",
                      "type": "bool"
                    },
                    {
                      "name": "canCreateCheque",
                      "type": "bool"
                    },
                    {
                      "name": "canAddPendingPayee",
                      "type": "bool"
                    },
                    {
                      "name": "allowedPayees",
                      "type": "address[]"
                    }
                  ]
                },
                {
                  "name": "allowedAssets",
                  "type": "address[]"
                },
                {
                  "name": "canClaimLoot",
                  "type": "bool"
                }
              ]
            },
            {
              "name": "_kernel",
              "type": "address"
            },
            {
              "name": "_sentinel",
              "type": "address"
            },
            {
              "name": "_highCommand",
              "type": "address"
            },
            {
              "name": "_paymaster",
              "type": "address"
            },
            {
              "name": "_chequeBook",
              "type": "address"
            },
            {
              "name": "_migrator",
              "type": "address"
            },
            {
              "name": "_wethAddr",
              "type": "address"
            },
            {
              "name": "_ethAddr",
              "type": "address"
            },
            {
              "name": "_minTimeLock",
              "type": "uint256"
            },
            {
              "name": "_maxTimeLock",
              "type": "uint256"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/modules/Ownership.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\ninterface MissionControl:\n    def canPerformSecurityAction(_addr: address) -> bool: view\n\ninterface UndyHq:\n    def getAddr(_regId: uint256) -> address: view\n\nstruct PendingOwnerChange:\n    newOwner: address\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent OwnershipChangeInitiated:\n    prevOwner: indexed(address)\n    newOwner: indexed(address)\n    confirmBlock: uint256\n\nevent OwnershipChangeConfirmed:\n    prevOwner: indexed(address)\n    newOwner: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent OwnershipChangeCancelled:\n    cancelledOwner: indexed(address)\n    cancelledBy: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent OwnershipTimeLockSet:\n    numBlocks: uint256\n\n# core\nowner: public(address)\nownershipTimeLock: public(uint256)\n\n# pending owner change\npendingOwner: public(PendingOwnerChange)\n\nUNDY_HQ_FOR_OWNERSHIP: immutable(address)\nMIN_OWNERSHIP_TIMELOCK: public(immutable(uint256))\nMAX_OWNERSHIP_TIMELOCK: public(immutable(uint256))\nMISSION_CONTROL_ID: constant(uint256) = 2\n\n\n@deploy\ndef __init__(\n    _undyHq: address,\n    _owner: address,\n    _minTimeLock: uint256,\n    _maxTimeLock: uint256,\n):\n    assert empty(address) not in [_undyHq, _owner] # dev: invalid addrs\n    UNDY_HQ_FOR_OWNERSHIP = _undyHq\n\n    # initial ownership\n    self.owner = _owner\n\n    # timelock\n    assert _minTimeLock != 0 and _minTimeLock < _maxTimeLock # dev: invalid delay\n    MIN_OWNERSHIP_TIMELOCK = _minTimeLock\n    MAX_OWNERSHIP_TIMELOCK = _maxTimeLock\n\n    self.ownershipTimeLock = _minTimeLock\n\n\n#############\n# Ownership #\n#############\n\n\n# change ownership\n\n\n@external\ndef changeOwnership(_newOwner: address):\n    currentOwner: address = self.owner\n    assert msg.sender == currentOwner # dev: no perms\n    assert _newOwner not in [empty(address), currentOwner] # dev: invalid new owner\n\n    confirmBlock: uint256 = block.number + self.ownershipTimeLock\n    self.pendingOwner = PendingOwnerChange(\n        newOwner = _newOwner,\n        initiatedBlock = block.number,\n        confirmBlock = confirmBlock,\n    )\n    log OwnershipChangeInitiated(prevOwner = currentOwner, newOwner = _newOwner, confirmBlock = confirmBlock)\n\n\n# confirm ownership change\n\n\n@external\ndef confirmOwnershipChange():\n    data: PendingOwnerChange = self.pendingOwner\n    assert data.newOwner != empty(address) # dev: no pending owner\n    assert data.confirmBlock != 0 and block.number >= data.confirmBlock # dev: time delay not reached\n    assert msg.sender == data.newOwner # dev: only new owner can confirm\n\n    prevOwner: address = self.owner\n    self.owner = data.newOwner\n    self.pendingOwner = empty(PendingOwnerChange)\n    log OwnershipChangeConfirmed(prevOwner = prevOwner, newOwner = data.newOwner, initiatedBlock = data.initiatedBlock, confirmBlock = data.confirmBlock)\n\n\n# cancel ownership change\n\n\n@external\ndef cancelOwnershipChange():\n    if msg.sender != self.owner:\n        assert self._canPerformSecurityAction(msg.sender) # dev: no perms\n\n    data: PendingOwnerChange = self.pendingOwner\n    assert data.confirmBlock != 0 # dev: no pending change\n    self.pendingOwner = empty(PendingOwnerChange)\n    log OwnershipChangeCancelled(cancelledOwner = data.newOwner, cancelledBy = msg.sender, initiatedBlock = data.initiatedBlock, confirmBlock = data.confirmBlock)\n\n\n@view\n@internal\ndef _canPerformSecurityAction(_addr: address) -> bool:\n    missionControl: address = staticcall UndyHq(UNDY_HQ_FOR_OWNERSHIP).getAddr(MISSION_CONTROL_ID)\n    if missionControl == empty(address):\n        return False\n    return staticcall MissionControl(missionControl).canPerformSecurityAction(_addr)\n\n\n#############\n# Utilities #\n#############\n\n\n@view\n@external\ndef hasPendingOwnerChange() -> bool:\n    return self._hasPendingOwnerChange()\n\n\n@view\n@internal\ndef _hasPendingOwnerChange() -> bool:\n    return self.pendingOwner.confirmBlock != 0\n\n\n#############\n# Time Lock #\n#############\n\n\n@external\ndef setOwnershipTimeLock(_numBlocks: uint256):\n    assert msg.sender == self.owner # dev: no perms\n    assert _numBlocks >= MIN_OWNERSHIP_TIMELOCK and _numBlocks <= MAX_OWNERSHIP_TIMELOCK # dev: invalid delay\n    self.ownershipTimeLock = _numBlocks\n    log OwnershipTimeLockSet(numBlocks=_numBlocks)",
            "sha256sum": "8c3dfc35ec492193531cadc81744d81f92f28ec166f809d45f42bdece1c1d379"
          },
          "interfaces/WalletStructs.vyi": {
            "content": "# @version 0.4.3\n\nflag ActionType:\n    TRANSFER\n    EARN_DEPOSIT\n    EARN_WITHDRAW\n    EARN_REBALANCE\n    SWAP\n    MINT_REDEEM\n    CONFIRM_MINT_REDEEM\n    ADD_COLLATERAL\n    REMOVE_COLLATERAL\n    BORROW\n    REPAY_DEBT\n    REWARDS\n    ETH_TO_WETH\n    WETH_TO_ETH\n    ADD_LIQ\n    REMOVE_LIQ\n    ADD_LIQ_CONC\n    REMOVE_LIQ_CONC\n    PAY_CHEQUE\n\nstruct WalletAssetData:\n    assetBalance: uint256\n    usdValue: uint256\n    isYieldAsset: bool\n    lastPricePerShare: uint256\n\nstruct ActionData:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    billing: address\n    wallet: address\n    walletConfig: address\n    walletOwner: address\n    inEjectMode: bool\n    isFrozen: bool\n    lastTotalUsdValue: uint256\n    signer: address\n    isManager: bool\n    legoId: uint256\n    legoAddr: address\n    eth: address\n    weth: address\n\nstruct MiniAddys:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    appraiser: address",
            "sha256sum": "9a4b4f59b3a62043e51b425a665064aae419a3c0bd0514b6b29a9441ae364bb9"
          },
          "interfaces/WalletConfigStructs.vyi": {
            "content": "# @version 0.4.3\n\nMAX_CONFIG_ASSETS: constant(uint256) = 40\nMAX_CONFIG_LEGOS: constant(uint256) = 25\nMAX_ALLOWED_PAYEES: constant(uint256) = 40\n\nflag WhitelistAction:\n    ADD_PENDING\n    CONFIRM_WHITELIST\n    CANCEL_WHITELIST\n    REMOVE_WHITELIST\n\nflag BackpackType:\n    WALLET_KERNEL\n    WALLET_SENTINEL\n    WALLET_HIGH_COMMAND\n    WALLET_PAYMASTER\n    WALLET_CHEQUE_BOOK\n    WALLET_MIGRATOR\n\n# payees\n\nstruct PayeeData:\n    numTxsInPeriod: uint256\n    totalUnitsInPeriod: uint256\n    totalUsdValueInPeriod: uint256\n    totalNumTxs: uint256\n    totalUnits: uint256\n    totalUsdValue: uint256\n    lastTxBlock: uint256\n    periodStartBlock: uint256\n\nstruct PayeeSettings:\n    startBlock: uint256\n    expiryBlock: uint256\n    canPull: bool\n    periodLength: uint256\n    maxNumTxsPerPeriod: uint256\n    txCooldownBlocks: uint256\n    failOnZeroPrice: bool\n    primaryAsset: address\n    onlyPrimaryAsset: bool\n    unitLimits: PayeeLimits\n    usdLimits: PayeeLimits\n\nstruct GlobalPayeeSettings:\n    defaultPeriodLength: uint256\n    startDelay: uint256\n    activationLength: uint256\n    maxNumTxsPerPeriod: uint256\n    txCooldownBlocks: uint256\n    failOnZeroPrice: bool\n    usdLimits: PayeeLimits\n    canPayOwner: bool\n    canPull: bool\n\nstruct PayeeLimits:\n    perTxCap: uint256\n    perPeriodCap: uint256\n    lifetimeCap: uint256\n\nstruct PendingPayee:\n    settings: PayeeSettings\n    initiatedBlock: uint256\n    confirmBlock: uint256\n    currentOwner: address\n\nstruct PayeeManagementBundle:\n    owner: address\n    wallet: address\n    isRegisteredPayee: bool\n    isWhitelisted: bool\n    payeeSettings: PayeeSettings\n    globalPayeeSettings: GlobalPayeeSettings\n    timeLock: uint256\n    walletConfig: address\n\nstruct RecipientConfigBundle:\n    isWhitelisted: bool\n    isOwner: bool\n    isPayee: bool\n    config: PayeeSettings\n    globalConfig: GlobalPayeeSettings\n    data: PayeeData\n\nstruct WhitelistConfigBundle:\n    owner: address\n    wallet: address\n    isWhitelisted: bool\n    pendingWhitelist: PendingWhitelist\n    timeLock: uint256\n    walletConfig: address\n    isManager: bool\n    isOwner: bool\n    whitelistPerms: WhitelistPerms\n    globalWhitelistPerms: WhitelistPerms\n\nstruct PendingWhitelist:\n    initiatedBlock: uint256\n    confirmBlock: uint256\n    currentOwner: address\n\n# cheques\n\nstruct Cheque:\n    recipient: address\n    asset: address\n    amount: uint256\n    creationBlock: uint256\n    unlockBlock: uint256\n    expiryBlock: uint256\n    usdValueOnCreation: uint256\n    canManagerPay: bool\n    canBePulled: bool\n    creator: address\n    active: bool\n\nstruct ChequeSettings:\n    maxNumActiveCheques: uint256\n    maxChequeUsdValue: uint256\n    instantUsdThreshold: uint256\n    perPeriodPaidUsdCap: uint256\n    maxNumChequesPaidPerPeriod: uint256\n    payCooldownBlocks: uint256\n    perPeriodCreatedUsdCap: uint256\n    maxNumChequesCreatedPerPeriod: uint256\n    createCooldownBlocks: uint256\n    periodLength: uint256\n    expensiveDelayBlocks: uint256\n    defaultExpiryBlocks: uint256\n    allowedAssets: DynArray[address, MAX_CONFIG_ASSETS]\n    canManagersCreateCheques: bool\n    canManagerPay: bool\n    canBePulled: bool\n\nstruct ChequeData:\n    numChequesPaidInPeriod: uint256\n    totalUsdValuePaidInPeriod: uint256\n    totalNumChequesPaid: uint256\n    totalUsdValuePaid: uint256\n    lastChequePaidBlock: uint256\n    numChequesCreatedInPeriod: uint256\n    totalUsdValueCreatedInPeriod: uint256\n    totalNumChequesCreated: uint256\n    totalUsdValueCreated: uint256\n    lastChequeCreatedBlock: uint256\n    periodStartBlock: uint256\n\nstruct ChequeManagementBundle:\n    wallet: address\n    walletConfig: address\n    owner: address\n    isRecipientOnWhitelist: bool\n    isCreatorManager: bool\n    managerSettings: ManagerSettings\n    chequeSettings: ChequeSettings\n    chequeData: ChequeData\n    isExistingCheque: bool\n    numActiveCheques: uint256\n    timeLock: uint256\n\n# managers\n\nstruct ManagerData:\n    numTxsInPeriod: uint256\n    totalUsdValueInPeriod: uint256\n    totalNumTxs: uint256\n    totalUsdValue: uint256\n    lastTxBlock: uint256\n    periodStartBlock: uint256\n\nstruct ManagerSettings:\n    startBlock: uint256\n    expiryBlock: uint256\n    limits: ManagerLimits\n    legoPerms: LegoPerms\n    whitelistPerms: WhitelistPerms\n    transferPerms: TransferPerms\n    allowedAssets: DynArray[address, MAX_CONFIG_ASSETS]\n    canClaimLoot: bool\n\nstruct GlobalManagerSettings:\n    managerPeriod: uint256\n    startDelay: uint256\n    activationLength: uint256\n    canOwnerManage: bool\n    limits: ManagerLimits\n    legoPerms: LegoPerms\n    whitelistPerms: WhitelistPerms\n    transferPerms: TransferPerms\n    allowedAssets: DynArray[address, MAX_CONFIG_ASSETS]\n\nstruct ManagerLimits:\n    maxUsdValuePerTx: uint256\n    maxUsdValuePerPeriod: uint256\n    maxUsdValueLifetime: uint256\n    maxNumTxsPerPeriod: uint256\n    txCooldownBlocks: uint256\n    failOnZeroPrice: bool\n\nstruct LegoPerms:\n    canManageYield: bool\n    canBuyAndSell: bool\n    canManageDebt: bool\n    canManageLiq: bool\n    canClaimRewards: bool\n    allowedLegos: DynArray[uint256, MAX_CONFIG_LEGOS]\n\nstruct WhitelistPerms:\n    canAddPending: bool\n    canConfirm: bool\n    canCancel: bool\n    canRemove: bool\n\nstruct TransferPerms:\n    canTransfer: bool\n    canCreateCheque: bool\n    canAddPendingPayee: bool\n    allowedPayees: DynArray[address, MAX_ALLOWED_PAYEES]\n\nstruct ManagerConfigBundle:\n    isOwner: bool\n    isManager: bool\n    config: ManagerSettings\n    globalConfig: GlobalManagerSettings\n    data: ManagerData\n    payee: address\n\nstruct ManagerSettingsBundle:\n    owner: address\n    isManager: bool\n    timeLock: uint256\n    walletConfig: address\n    legoBook: address\n    globalManagerSettings: GlobalManagerSettings\n\n# migration\n\nstruct MigrationConfigBundle:\n    owner: address\n    isFrozen: bool\n    numPayees: uint256\n    numWhitelisted: uint256\n    numManagers: uint256\n    startingAgent: address\n    startingAgentIndex: uint256\n    hasPendingOwnerChange: bool\n    groupId: uint256\n",
            "sha256sum": "aadbecb8a18bcc1886a77c580870041e2ca071de3d9af6d31508f610bc715f9d"
          },
          "contracts/core/userWallet/UserWalletConfig.vy": {
            "content": "#    \u2513 \u250f  \u2513\u2513   \n#    \u2503\u2503\u2503\u250f\u2513\u2503\u2503\u250f\u2513\u254b\n#    \u2517\u253b\u251b\u2517\u253b\u2517\u2517\u2517 \u2517\n#      ,----..                                                   \n#     /   /   \\                        .--.,   ,--,              \n#    |   :     :  ,---.        ,---, ,--.'  \\,--.'|              \n#    .   |  ;. / '   ,'\\   ,-+-. /  ||  | /\\/|  |,     ,----._,. \n#    .   ; /--` /   /   | ,--.'|'   |:  : :  `--'_    /   /  ' / \n#    ;   | ;   .   ; ,. :|   |  ,\"' |:  | |-,,' ,'|  |   :     | \n#    |   : |   '   | |: :|   | /  | ||  : :/|'  | |  |   | .\\  . \n#    .   | '___'   | .; :|   | |  | ||  |  .'|  | :  .   ; ';  | \n#    '   ; : .'|   :    ||   | |  |/ '  : '  '  : |__'   .   . | \n#    '   | '/  :\\   \\  / |   | |--'  |  | |  |  | '.'|`---`-'| | \n#    |   :    /  `----'  |   |/      |  : \\  ;  :    ;.'__/\\_: | \n#     \\   \\ .'           '---'       |  |,'  |  ,   / |   :    : \n#      `---`                         `--'     ---`-'   \\   \\  /  \n#                                                       `--`-'   \n#     \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n#     \u2551  ** User Wallet Config **                      \u2551\n#     \u2551  Handles all user wallet config functionality  \u2551\n#     \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n#\n#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n# pragma optimize codesize\n\ninitializes: ownership\nexports: ownership.__interface__\nimport contracts.modules.Ownership as ownership\n\nfrom interfaces import WalletStructs as ws\nfrom interfaces import WalletConfigStructs as wcs\n\nfrom ethereum.ercs import IERC721\nfrom ethereum.ercs import IERC20\n\ninterface UserWallet:\n    def withdrawFromYield(_legoId: uint256, _vaultToken: address, _amount: uint256 = max_value(uint256), _extraData: bytes32 = empty(bytes32), _isSpecialTx: bool = False) -> (uint256, address, uint256, uint256): nonpayable\n    def transferFunds(_recipient: address, _asset: address = empty(address), _amount: uint256 = max_value(uint256), _isCheque: bool = False, _isSpecialTx: bool = False) -> (uint256, uint256): nonpayable\n    def updateAssetData(_legoId: uint256, _asset: address, _shouldCheckYield: bool, _totalUsdValue: uint256, _ad: ws.ActionData = empty(ws.ActionData)) -> uint256: nonpayable\n    def recoverNft(_collection: address, _nftTokenId: uint256, _recipient: address): nonpayable\n    def setLegoAccessForAction(_legoAddr: address, _action: ws.ActionType) -> bool: nonpayable\n    def assetData(_asset: address) -> ws.WalletAssetData: view\n    def deregisterAsset(_asset: address) -> bool: nonpayable\n    def assets(i: uint256) -> address: view\n    def walletConfig() -> address: view\n    def numAssets() -> uint256: view\n\ninterface Sentinel:\n    def canSignerPerformActionWithConfig(_isOwner: bool, _isManager: bool, _data: wcs.ManagerData, _config: wcs.ManagerSettings, _globalConfig: wcs.GlobalManagerSettings, _action: ws.ActionType, _assets: DynArray[address, MAX_ASSETS] = [], _legoIds: DynArray[uint256, MAX_LEGOS] = [], _payee: address = empty(address)) -> bool: view\n    def isValidPayeeAndGetData(_isWhitelisted: bool, _isOwner: bool, _isPayee: bool, _asset: address, _amount: uint256, _txUsdValue: uint256, _config: wcs.PayeeSettings, _globalConfig: wcs.GlobalPayeeSettings, _data: wcs.PayeeData) -> (bool, wcs.PayeeData): view\n    def isValidChequeAndGetData(_asset: address, _amount: uint256, _txUsdValue: uint256, _cheque: wcs.Cheque, _globalConfig: wcs.ChequeSettings, _chequeData: wcs.ChequeData, _isManager: bool) -> (bool, wcs.ChequeData): view\n    def checkManagerUsdLimitsAndUpdateData(_txUsdValue: uint256, _specificLimits: wcs.ManagerLimits, _globalLimits: wcs.ManagerLimits, _managerPeriod: uint256, _data: wcs.ManagerData) -> (bool, wcs.ManagerData): view\n\ninterface Ledger:\n    def isRegisteredBackpackItem(_addr: address) -> bool: view\n    def getLastTotalUsdValue(_user: address) -> uint256: view\n\ninterface MissionControl:\n    def canPerformSecurityAction(_addr: address) -> bool: view\n    def isLockedSigner(_signer: address) -> bool: view\n\ninterface Registry:\n    def isValidAddr(_addr: address) -> bool: view\n    def getAddr(_regId: uint256) -> address: view\n\ninterface LootDistributor:\n    def updateDepositPointsWithNewValue(_user: address, _newUsdValue: uint256): nonpayable\n\ninterface Switchboard:\n    def isSwitchboardAddr(_addr: address) -> bool: view\n\nevent EjectionModeSet:\n    inEjectMode: bool\n\nevent FrozenSet:\n    isFrozen: bool\n    caller: indexed(address)\n\nevent NftRecovered:\n    collection: indexed(address)\n    nftTokenId: uint256\n    recipient: indexed(address)\n\n# core\nwallet: public(address)\n\n# wallet backpack contracts\nkernel: public(address)\nsentinel: public(address)\nhighCommand: public(address)\npaymaster: public(address)\nchequeBook: public(address)\nmigrator: public(address)\n\n# trial funds info\ntrialFundsAsset: public(address)\ntrialFundsAmount: public(uint256)\n\n# managers\nmanagerSettings: public(HashMap[address, wcs.ManagerSettings])\nmanagerPeriodData: public(HashMap[address, wcs.ManagerData])\nmanagers: public(HashMap[uint256, address]) # index -> manager\nindexOfManager: public(HashMap[address, uint256]) # manager -> index\nnumManagers: public(uint256) # num managers\n\n# payees\npayeeSettings: public(HashMap[address, wcs.PayeeSettings])\npayeePeriodData: public(HashMap[address, wcs.PayeeData])\npayees: public(HashMap[uint256, address]) # index -> payee\nindexOfPayee: public(HashMap[address, uint256]) # payee -> index\nnumPayees: public(uint256) # num payees\npendingPayees: public(HashMap[address, wcs.PendingPayee])\n\n# whitelist\nwhitelistAddr: public(HashMap[uint256, address]) # index -> whitelist\nindexOfWhitelist: public(HashMap[address, uint256]) # whitelist -> index\nnumWhitelisted: public(uint256) # num whitelisted\npendingWhitelist: public(HashMap[address, wcs.PendingWhitelist]) # addr -> pending whitelist\n\n# cheques\ncheques: public(HashMap[address, wcs.Cheque]) # addr -> cheque\nchequeSettings: public(wcs.ChequeSettings)\nchequePeriodData: public(wcs.ChequeData)\nnumActiveCheques: public(uint256)\n\n# global config\nglobalManagerSettings: public(wcs.GlobalManagerSettings)\nglobalPayeeSettings: public(wcs.GlobalPayeeSettings)\n\n# config\ntimeLock: public(uint256)\nisFrozen: public(bool)\ninEjectMode: public(bool)\ngroupId: public(uint256)\nstartingAgent: public(address)\ndidSetWallet: public(bool)\n\nAPI_VERSION: constant(String[28]) = \"0.1.0\"\nMAX_ASSETS: constant(uint256) = 10\nMAX_LEGOS: constant(uint256) = 10\n\n# registry ids\nLEDGER_ID: constant(uint256) = 1\nMISSION_CONTROL_ID: constant(uint256) = 2\nLEGO_BOOK_ID: constant(uint256) = 3\nSWITCHBOARD_ID: constant(uint256) = 4\nHATCHERY_ID: constant(uint256) = 5\nLOOT_DISTRIBUTOR_ID: constant(uint256) = 6\nAPPRAISER_ID: constant(uint256) = 7\nBILLING_ID: constant(uint256) = 9\n\nUNDY_HQ: public(immutable(address))\nWETH: public(immutable(address))\nETH: public(immutable(address))\n\nMIN_TIMELOCK: public(immutable(uint256))\nMAX_TIMELOCK: public(immutable(uint256))\n\n\n@deploy\ndef __init__(\n    _undyHq: address,\n    _owner: address,\n    _groupId: uint256,\n    # trial funds\n    _trialFundsAsset: address,\n    _trialFundsAmount: uint256,\n    # manager / payee settings\n    _globalManagerSettings: wcs.GlobalManagerSettings,\n    _globalPayeeSettings: wcs.GlobalPayeeSettings,\n    _chequeSettings: wcs.ChequeSettings,\n    _startingAgent: address,\n    _starterAgentSettings: wcs.ManagerSettings,\n    # key contracts / addrs\n    _kernel: address,\n    _sentinel: address,\n    _highCommand: address,\n    _paymaster: address,\n    _chequeBook: address,\n    _migrator: address,\n    _wethAddr: address,\n    _ethAddr: address,\n    # timelock\n    _minTimeLock: uint256,\n    _maxTimeLock: uint256,\n):\n    # initialize ownership\n    ownership.__init__(_undyHq, _owner, _minTimeLock, _maxTimeLock)\n    UNDY_HQ = _undyHq\n\n    # wallet backpack addrs\n    assert empty(address) not in [_kernel, _sentinel, _highCommand, _paymaster, _chequeBook, _migrator, _wethAddr, _ethAddr] # dev: invalid addrs\n    self.kernel = _kernel\n    self.sentinel = _sentinel\n    self.highCommand = _highCommand\n    self.paymaster = _paymaster\n    self.chequeBook = _chequeBook\n    self.migrator = _migrator\n\n    # eth addrs\n    WETH = _wethAddr\n    ETH = _ethAddr\n\n    # not using 0 index\n    self.numManagers = 1\n    self.numPayees = 1\n    self.numWhitelisted = 1\n\n    # trial funds / group id\n    self.groupId = _groupId\n    self.trialFundsAsset = _trialFundsAsset\n    self.trialFundsAmount = _trialFundsAmount\n\n    # timelock\n    assert _minTimeLock != 0 and _minTimeLock < _maxTimeLock # dev: invalid delay\n    MIN_TIMELOCK = _minTimeLock\n    MAX_TIMELOCK = _maxTimeLock\n    self.timeLock = _minTimeLock\n\n    # manager / payee settings\n    self.globalManagerSettings = _globalManagerSettings\n    self.globalPayeeSettings = _globalPayeeSettings\n    self.chequeSettings = _chequeSettings\n\n    # initial agent\n    if _startingAgent != empty(address):\n        self.managerSettings[_startingAgent] = _starterAgentSettings\n        self.startingAgent = _startingAgent\n        self._registerManager(_startingAgent)\n\n\n@external\ndef setWallet(_wallet: address) -> bool:\n    assert not self.didSetWallet # dev: wallet already set\n    assert _wallet != empty(address) # dev: invalid wallet\n    assert msg.sender == staticcall Registry(UNDY_HQ).getAddr(HATCHERY_ID) # dev: no perms\n    self.wallet = _wallet\n    self.didSetWallet = True\n    return True\n\n\n@pure\n@external\ndef apiVersion() -> String[28]:\n    return API_VERSION\n\n\n#####################\n# Signer Validation #\n#####################\n\n\n# pre action\n\n\n@view\n@external\ndef checkSignerPermissionsAndGetBundle(\n    _signer: address,\n    _action: ws.ActionType,\n    _assets: DynArray[address, MAX_ASSETS] = [],\n    _legoIds: DynArray[uint256, MAX_LEGOS] = [],\n    _transferRecipient: address = empty(address),\n) -> ws.ActionData:\n    legoId: uint256 = 0\n    if len(_legoIds) != 0:\n        legoId = _legoIds[0]\n\n    # main data for this transaction\n    ad: ws.ActionData = self._getActionDataBundle(legoId, _signer)\n\n    # if the signer is the billing contract, no need to check signer\n    if ad.signer == ad.billing:\n        return ad\n\n    # make sure signer is not locked\n    assert not staticcall MissionControl(ad.missionControl).isLockedSigner(_signer) # dev: signer is locked\n\n    # if _transferRecipient is whitelisted, set to 0x0, will not check `allowedPayees` for manager\n    recipient: address = _transferRecipient\n    if _transferRecipient != empty(address) and self.indexOfWhitelist[_transferRecipient] != 0:\n        recipient = empty(address)\n\n    # main validation\n    hasPermission: bool = staticcall Sentinel(self.sentinel).canSignerPerformActionWithConfig(\n        _signer == ad.walletOwner,\n        self.indexOfManager[_signer] != 0,\n        self.managerPeriodData[_signer],\n        self.managerSettings[_signer],\n        self.globalManagerSettings,\n        _action,\n        _assets,\n        _legoIds,\n        recipient,\n    )\n\n    # IMPORTANT -- checks if the signer is allowed to perform the action\n    assert hasPermission # dev: no permission\n\n    return ad\n\n\n# post action (usd value limits)\n\n\n@external\ndef checkManagerUsdLimitsAndUpdateData(_manager: address, _txUsdValue: uint256) -> bool:\n    assert msg.sender == self.wallet # dev: no perms\n\n    # required data / config\n    config: wcs.ManagerSettings = self.managerSettings[_manager]\n    globalConfig: wcs.GlobalManagerSettings = self.globalManagerSettings\n    managerData: wcs.ManagerData = self.managerPeriodData[_manager]\n\n    # check usd value limits\n    canFinishTx: bool = False\n    canFinishTx, managerData = staticcall Sentinel(self.sentinel).checkManagerUsdLimitsAndUpdateData(\n        _txUsdValue,\n        config.limits,\n        globalConfig.limits,\n        globalConfig.managerPeriod,\n        managerData,\n    )\n\n    # IMPORTANT -- this checks manager limits (usd values)\n    assert canFinishTx # dev: usd value limit exceeded\n\n    self.managerPeriodData[_manager] = managerData\n    return True\n\n\n####################\n# Payee Validation #\n####################\n\n\n@external\ndef checkRecipientLimitsAndUpdateData(\n    _recipient: address,\n    _txUsdValue: uint256,\n    _asset: address,\n    _amount: uint256,\n) -> bool:\n    assert msg.sender == self.wallet # dev: no perms\n\n    # whitelisted\n    isWhitelisted: bool = self.indexOfWhitelist[_recipient] != 0\n\n    # only get the extra data if the recipient is not whitelisted\n    isOwner: bool = False\n    isPayee: bool = False\n    config: wcs.PayeeSettings = empty(wcs.PayeeSettings)\n    globalConfig: wcs.GlobalPayeeSettings = empty(wcs.GlobalPayeeSettings)\n    data: wcs.PayeeData = empty(wcs.PayeeData)\n    if not isWhitelisted:\n        isOwner = _recipient == ownership.owner\n        isPayee = self.indexOfPayee[_recipient] != 0\n        config = self.payeeSettings[_recipient]\n        globalConfig = self.globalPayeeSettings\n        data = self.payeePeriodData[_recipient]\n\n    # check if payee is valid\n    canPayRecipient: bool = False\n    canPayRecipient, data = staticcall Sentinel(self.sentinel).isValidPayeeAndGetData(\n        isWhitelisted,\n        isOwner,\n        isPayee,\n        _asset,\n        _amount,\n        _txUsdValue,\n        config,\n        globalConfig,\n        data,\n    )\n\n    # IMPORTANT -- make sure this recipient can receive funds\n    assert canPayRecipient # dev: invalid payee\n\n    # only save if data was updated  \n    if data.lastTxBlock != 0:\n        self.payeePeriodData[_recipient] = data\n\n    return True\n\n\n#####################\n# Cheque Validation #\n#####################\n\n\n@external\ndef validateCheque(\n    _recipient: address,\n    _asset: address,\n    _amount: uint256,\n    _txUsdValue: uint256,\n    _signer: address,\n) -> bool:\n    assert msg.sender == self.wallet # dev: no perms\n\n    # get required config / data\n    cheque: wcs.Cheque = self.cheques[_recipient]\n    globalConfig: wcs.ChequeSettings = self.chequeSettings\n    data: wcs.ChequeData = self.chequePeriodData\n\n    isManager: bool = False\n    if _signer != ownership.owner:\n        isManager = self.indexOfManager[_signer] != 0\n\n    # cheque validation\n    isValidCheque: bool = False\n    isValidCheque, data = staticcall Sentinel(self.sentinel).isValidChequeAndGetData(\n        _asset,\n        _amount,\n        _txUsdValue,\n        cheque,\n        globalConfig,\n        data,\n        isManager,\n    )\n\n    # IMPORTANT -- make sure this recipient has valid cheque\n    assert isValidCheque # dev: invalid cheque\n\n    # only save if data was updated  \n    if data.lastChequePaidBlock != 0:\n        self.chequePeriodData = data\n        self.numActiveCheques -= 1\n\n    return True\n\n\n#############\n# Whitelist #\n#############\n\n\n# add pending\n\n\n@external\ndef addPendingWhitelistAddr(_addr: address, _pending: wcs.PendingWhitelist):\n    assert msg.sender == self.kernel # dev: no perms\n    self.pendingWhitelist[_addr] = _pending\n\n\n# cancel pending\n\n\n@external\ndef cancelPendingWhitelistAddr(_addr: address):\n    assert msg.sender == self.kernel # dev: no perms\n    self.pendingWhitelist[_addr] = empty(wcs.PendingWhitelist)\n\n\n# confirm pending\n\n\n@external\ndef confirmWhitelistAddr(_addr: address):\n    assert msg.sender == self.kernel # dev: no perms\n    assert self.pendingWhitelist[_addr].confirmBlock <= block.number # dev: time delay not reached\n    self.pendingWhitelist[_addr] = empty(wcs.PendingWhitelist)\n    self._registerWhitelistAddr(_addr)\n\n\n# add via migrator\n\n\n@external\ndef addWhitelistAddrViaMigrator(_addr: address):\n    assert msg.sender == self.migrator # dev: no perms\n    self._registerWhitelistAddr(_addr)\n\n\n# register whitelist\n\n\n@internal\ndef _registerWhitelistAddr(_addr: address):\n    if self.indexOfWhitelist[_addr] != 0:\n        return\n    wid: uint256 = self.numWhitelisted\n    self.whitelistAddr[wid] = _addr\n    self.indexOfWhitelist[_addr] = wid\n    self.numWhitelisted = wid + 1\n\n\n# remove whitelist\n\n\n@external\ndef removeWhitelistAddr(_addr: address):\n    assert msg.sender == self.kernel # dev: no perms\n\n    numWhitelisted: uint256 = self.numWhitelisted\n    if numWhitelisted == 1:\n        return\n\n    targetIndex: uint256 = self.indexOfWhitelist[_addr]\n    if targetIndex == 0:\n        return\n\n    # update data\n    lastIndex: uint256 = numWhitelisted - 1\n    self.numWhitelisted = lastIndex\n    self.indexOfWhitelist[_addr] = 0\n\n    # get last item, replace the removed item\n    if targetIndex != lastIndex:\n        lastItem: address = self.whitelistAddr[lastIndex]\n        self.whitelistAddr[targetIndex] = lastItem\n        self.indexOfWhitelist[lastItem] = targetIndex\n\n\n####################\n# Manager Settings #\n####################\n\n\n# add manager\n\n\n@external\ndef addManager(_manager: address, _config: wcs.ManagerSettings):\n    assert msg.sender in [self.highCommand, self.migrator] # dev: no perms\n    self.managerSettings[_manager] = _config\n    self._registerManager(_manager)\n\n\n# update manager\n\n\n@external\ndef updateManager(_manager: address, _config: wcs.ManagerSettings):\n    assert msg.sender == self.highCommand # dev: no perms\n    self.managerSettings[_manager] = _config\n\n\n# register manager\n\n\n@internal\ndef _registerManager(_manager: address):\n    if self.indexOfManager[_manager] != 0:\n        return\n    mid: uint256 = self.numManagers\n    self.managers[mid] = _manager\n    self.indexOfManager[_manager] = mid\n    self.numManagers = mid + 1\n\n\n# remove manager\n\n\n@external\ndef removeManager(_manager: address):\n    assert msg.sender == self.highCommand # dev: no perms\n\n    numManagers: uint256 = self.numManagers\n    if numManagers == 1:\n        return\n\n    targetIndex: uint256 = self.indexOfManager[_manager]\n    if targetIndex == 0:\n        return\n\n    self.managerSettings[_manager] = empty(wcs.ManagerSettings)\n    self.managerPeriodData[_manager] = empty(wcs.ManagerData)\n\n    # update data\n    lastIndex: uint256 = numManagers - 1\n    self.numManagers = lastIndex\n    self.indexOfManager[_manager] = 0\n\n    # get last item, replace the removed item\n    if targetIndex != lastIndex:\n        lastItem: address = self.managers[lastIndex]\n        self.managers[targetIndex] = lastItem\n        self.indexOfManager[lastItem] = targetIndex\n\n\n# global manager settings\n\n\n@external\ndef setGlobalManagerSettings(_config: wcs.GlobalManagerSettings):\n    assert msg.sender in [self.highCommand, self.migrator] # dev: no perms\n    self.globalManagerSettings = _config\n\n\n##################\n# Payee Settings #\n##################\n\n\n# add payee\n\n\n@external\ndef addPayee(_payee: address, _config: wcs.PayeeSettings):\n    assert msg.sender in [self.paymaster, self.migrator] # dev: no perms\n    self.payeeSettings[_payee] = _config\n    self._registerPayee(_payee)\n\n\n# update payee\n\n\n@external\ndef updatePayee(_payee: address, _config: wcs.PayeeSettings):\n    assert msg.sender == self.paymaster # dev: no perms\n    self.payeeSettings[_payee] = _config\n\n\n# register payee\n\n\n@internal\ndef _registerPayee(_payee: address):\n    if self.indexOfPayee[_payee] != 0:\n        return\n    pid: uint256 = self.numPayees\n    self.payees[pid] = _payee\n    self.indexOfPayee[_payee] = pid\n    self.numPayees = pid + 1\n\n\n# remove payee\n\n\n@external\ndef removePayee(_payee: address):\n    assert msg.sender == self.paymaster # dev: no perms\n\n    numPayees: uint256 = self.numPayees\n    if numPayees == 1:\n        return\n\n    targetIndex: uint256 = self.indexOfPayee[_payee]\n    if targetIndex == 0:\n        return\n\n    self.payeeSettings[_payee] = empty(wcs.PayeeSettings)\n    self.payeePeriodData[_payee] = empty(wcs.PayeeData)\n\n    # update data\n    lastIndex: uint256 = numPayees - 1\n    self.numPayees = lastIndex\n    self.indexOfPayee[_payee] = 0\n\n    # get last item, replace the removed item\n    if targetIndex != lastIndex:\n        lastItem: address = self.payees[lastIndex]\n        self.payees[targetIndex] = lastItem\n        self.indexOfPayee[lastItem] = targetIndex\n\n\n# global payee settings\n\n\n@external\ndef setGlobalPayeeSettings(_config: wcs.GlobalPayeeSettings):\n    assert msg.sender in [self.paymaster, self.migrator] # dev: no perms\n    self.globalPayeeSettings = _config\n\n\n# pending payees (when managers add payees)\n\n\n@external\ndef addPendingPayee(_payee: address, _pending: wcs.PendingPayee):\n    assert msg.sender == self.paymaster # dev: no perms\n    self.pendingPayees[_payee] = _pending\n\n\n@external\ndef confirmPendingPayee(_payee: address):\n    assert msg.sender == self.paymaster # dev: no perms\n    pending: wcs.PendingPayee = self.pendingPayees[_payee]\n    assert pending.confirmBlock != 0 and pending.confirmBlock <= block.number # dev: time delay not reached\n    self.payeeSettings[_payee] = pending.settings\n    self.pendingPayees[_payee] = empty(wcs.PendingPayee)\n    self._registerPayee(_payee)\n\n\n@external\ndef cancelPendingPayee(_payee: address):\n    assert msg.sender == self.paymaster # dev: no perms\n    self.pendingPayees[_payee] = empty(wcs.PendingPayee)\n\n\n###################\n# Cheque Settings #\n###################\n\n\n# create cheque\n\n\n@external\ndef createCheque(\n    _recipient: address,\n    _cheque: wcs.Cheque,\n    _chequeData: wcs.ChequeData,\n    _isExistingCheque: bool,\n):\n    assert msg.sender == self.chequeBook # dev: no perms\n    self.cheques[_recipient] = _cheque\n    self.chequePeriodData = _chequeData\n    if not _isExistingCheque:\n        self.numActiveCheques += 1\n\n\n# cancel cheque\n\n\n@external\ndef cancelCheque(_recipient: address):\n    assert msg.sender == self.chequeBook # dev: no perms\n    self.cheques[_recipient] = empty(wcs.Cheque)\n    self.numActiveCheques -= 1\n\n\n# global cheque settings\n\n\n@external\ndef setChequeSettings(_config: wcs.ChequeSettings):\n    assert msg.sender == self.chequeBook # dev: no perms\n    self.chequeSettings = _config\n\n\n################\n# Wallet Tools #\n################\n\n\n# update asset data\n\n\n@external\ndef updateAssetData(_legoId: uint256, _asset: address, _shouldCheckYield: bool) -> uint256:\n    ad: ws.ActionData = self._getActionDataBundle(_legoId, msg.sender)\n    if not self._isSwitchboardAddr(msg.sender):\n        assert self._canPerformSecurityAction(msg.sender) # dev: no perms\n    newTotalUsdValue: uint256 = extcall UserWallet(ad.wallet).updateAssetData(_legoId, _asset, _shouldCheckYield, ad.lastTotalUsdValue, ad)\n    extcall LootDistributor(ad.lootDistributor).updateDepositPointsWithNewValue(ad.wallet, newTotalUsdValue)\n    return newTotalUsdValue\n\n\n@external\ndef updateAllAssetData(_shouldCheckYield: bool) -> uint256:\n    ad: ws.ActionData = self._getActionDataBundle(0, msg.sender)\n    if not self._isSwitchboardAddr(msg.sender):\n        assert self._canPerformSecurityAction(msg.sender) # dev: no perms\n\n    numAssets: uint256 = staticcall UserWallet(ad.wallet).numAssets()\n    if numAssets == 0:\n        return ad.lastTotalUsdValue\n\n    newTotalUsdValue: uint256 = ad.lastTotalUsdValue\n    for i: uint256 in range(1, numAssets, bound=max_value(uint256)):           \n        asset: address = staticcall UserWallet(ad.wallet).assets(i)\n        if asset != empty(address):\n            newTotalUsdValue = extcall UserWallet(ad.wallet).updateAssetData(0, asset, _shouldCheckYield, newTotalUsdValue, ad)\n\n    extcall LootDistributor(ad.lootDistributor).updateDepositPointsWithNewValue(ad.wallet, newTotalUsdValue)\n    return newTotalUsdValue\n\n\n# remove trial funds\n\n\n@external\ndef removeTrialFunds() -> uint256:\n    hatchery: address = staticcall Registry(UNDY_HQ).getAddr(HATCHERY_ID)\n    assert msg.sender == hatchery # dev: no perms\n\n    # trial funds info\n    trialFundsAmount: uint256 = self.trialFundsAmount\n    trialFundsAsset: address = self.trialFundsAsset\n    assert trialFundsAsset != empty(address) and trialFundsAmount != 0 # dev: no trial funds\n\n    # transfer assets\n    amount: uint256 = 0\n    na: uint256 = 0\n    amount, na = extcall UserWallet(self.wallet).transferFunds(hatchery, trialFundsAsset, trialFundsAmount, False, True)\n\n    # update trial funds info\n    remainingAmount: uint256 = trialFundsAmount - min(trialFundsAmount, amount)\n    self.trialFundsAmount = remainingAmount\n    if remainingAmount == 0:\n        self.trialFundsAsset = empty(address)\n\n    return amount\n\n\n@view\n@external\ndef getTrialFundsInfo() -> (address, uint256):\n    return self.trialFundsAsset, self.trialFundsAmount\n\n\n# migrate funds\n\n\n@external\ndef migrateFunds(_toWallet: address, _asset: address) -> uint256:\n    assert msg.sender == self.migrator # dev: no perms\n    amount: uint256 = 0\n    na: uint256 = 0\n    amount, na = extcall UserWallet(self.wallet).transferFunds(_toWallet, _asset, max_value(uint256), False, True)\n    return amount\n\n\n# prepare payment\n\n\n@external\ndef preparePayment(\n    _targetAsset: address,\n    _legoId: uint256,\n    _vaultToken: address,\n    _vaultAmount: uint256 = max_value(uint256),\n) -> (uint256, uint256):\n    assert staticcall Registry(UNDY_HQ).isValidAddr(msg.sender) # dev: no perms\n\n    # withdraw from yield position\n    na: uint256 = 0\n    underlyingAsset: address = empty(address)\n    underlyingAmount: uint256 = 0\n    txUsdValue: uint256 = 0\n    na, underlyingAsset, underlyingAmount, txUsdValue = extcall UserWallet(self.wallet).withdrawFromYield(_legoId, _vaultToken, _vaultAmount, empty(bytes32), True)\n    assert underlyingAsset == _targetAsset # dev: invalid target asset\n\n    return underlyingAmount, txUsdValue\n\n\n# deregister asset\n\n\n@external\ndef deregisterAsset(_asset: address) -> bool:\n    if msg.sender != self.migrator:\n        assert staticcall Registry(UNDY_HQ).isValidAddr(msg.sender) # dev: no perms\n    return extcall UserWallet(self.wallet).deregisterAsset(_asset)\n\n\n# recover nft\n\n\n@external\ndef recoverNft(_collection: address, _nftTokenId: uint256, _recipient: address):\n    if msg.sender != ownership.owner:\n        assert self._isSwitchboardAddr(msg.sender) # dev: no perms\n\n    assert _recipient != empty(address) # dev: invalid recipient\n    wallet: address = self.wallet\n    assert staticcall IERC721(_collection).ownerOf(_nftTokenId) == wallet # dev: not owner\n    extcall UserWallet(wallet).recoverNft(_collection, _nftTokenId, _recipient)\n    log NftRecovered(collection = _collection, nftTokenId = _nftTokenId, recipient = _recipient)\n\n\n# freeze wallet\n\n\n@external\ndef setFrozen(_isFrozen: bool):\n    if msg.sender != ownership.owner:\n        assert self._canPerformSecurityAction(msg.sender) # dev: no perms\n    assert _isFrozen != self.isFrozen # dev: nothing to change\n    self.isFrozen = _isFrozen\n    log FrozenSet(isFrozen=_isFrozen, caller=msg.sender)\n\n\n# ejection mode\n\n\n@external\ndef setEjectionMode(_shouldEject: bool):\n    # NOTE: this needs to be triggered from Switchboard, as it has other side effects / reactions\n    assert self._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert self.trialFundsAmount == 0 # dev: has trial funds\n\n    assert _shouldEject != self.inEjectMode # dev: nothing to change\n    self.inEjectMode = _shouldEject\n    log EjectionModeSet(inEjectMode = _shouldEject)\n\n\n# lego access\n\n\n@external\ndef setLegoAccessForAction(_legoId: uint256, _action: ws.ActionType) -> bool:\n    ad: ws.ActionData = self._getActionDataBundle(_legoId, msg.sender)\n    if msg.sender != ad.walletOwner:\n        assert staticcall Registry(UNDY_HQ).isValidAddr(msg.sender) # dev: no perms\n    return extcall UserWallet(ad.wallet).setLegoAccessForAction(ad.legoAddr, _action)\n\n\n# is signer switchboard\n\n\n\n@view\n@internal\ndef _isSwitchboardAddr(_signer: address) -> bool:\n    switchboard: address = staticcall Registry(UNDY_HQ).getAddr(SWITCHBOARD_ID)\n    if switchboard == empty(address):\n        return False\n    return staticcall Switchboard(switchboard).isSwitchboardAddr(_signer)\n\n\n# can perform security action\n\n\n@view\n@internal\ndef _canPerformSecurityAction(_addr: address) -> bool:\n    missionControl: address = staticcall Registry(UNDY_HQ).getAddr(MISSION_CONTROL_ID)\n    if missionControl == empty(address):\n        return False\n    return staticcall MissionControl(missionControl).canPerformSecurityAction(_addr)\n\n\n###################\n# Wallet Backpack #\n###################\n\n\n@external\ndef setKernel(_kernel: address):\n    assert self._canSetBackpackItem(_kernel, msg.sender) # dev: no perms\n    self.kernel = _kernel\n\n\n@external\ndef setSentinel(_sentinel: address):\n    assert self._canSetBackpackItem(_sentinel, msg.sender) # dev: no perms\n    self.sentinel = _sentinel\n\n\n@external\ndef setHighCommand(_highCommand: address):\n    assert self._canSetBackpackItem(_highCommand, msg.sender) # dev: no perms\n    self.highCommand = _highCommand\n\n\n@external\ndef setPaymaster(_paymaster: address):\n    assert self._canSetBackpackItem(_paymaster, msg.sender) # dev: no perms\n    self.paymaster = _paymaster\n\n\n@external\ndef setChequeBook(_chequeBook: address):\n    assert self._canSetBackpackItem(_chequeBook, msg.sender) # dev: no perms\n    self.chequeBook = _chequeBook\n\n\n@external\ndef setMigrator(_migrator: address):\n    assert self._canSetBackpackItem(_migrator, msg.sender) # dev: no perms\n    self.migrator = _migrator\n\n\n# validation\n\n\n@view\n@internal\ndef _canSetBackpackItem(_newBackpackAddr: address, _caller: address) -> bool:\n    if _caller != ownership.owner:\n        return False\n    ledger: address = staticcall Registry(UNDY_HQ).getAddr(LEDGER_ID)\n    if ledger == empty(address):\n        return False\n    return staticcall Ledger(ledger).isRegisteredBackpackItem(_newBackpackAddr)\n\n\n######################\n# Action Data Bundle #\n######################\n\n\n@view\n@external\ndef getActionDataBundle(_legoId: uint256, _signer: address) -> ws.ActionData:\n    return self._getActionDataBundle(_legoId, _signer)\n\n\n@view\n@internal\ndef _getActionDataBundle(_legoId: uint256, _signer: address) -> ws.ActionData:\n    wallet: address = self.wallet\n    owner: address = ownership.owner\n    hq: address = UNDY_HQ\n\n    # lego details\n    legoBook: address = staticcall Registry(hq).getAddr(LEGO_BOOK_ID)\n    legoAddr: address = empty(address)\n    if _legoId != 0 and legoBook != empty(address):\n        legoAddr = staticcall Registry(legoBook).getAddr(_legoId)\n\n    ledger: address = staticcall Registry(hq).getAddr(LEDGER_ID)\n    return ws.ActionData(\n        ledger = ledger,\n        missionControl = staticcall Registry(hq).getAddr(MISSION_CONTROL_ID),\n        legoBook = legoBook,\n        hatchery = staticcall Registry(hq).getAddr(HATCHERY_ID),\n        lootDistributor = staticcall Registry(hq).getAddr(LOOT_DISTRIBUTOR_ID),\n        appraiser = staticcall Registry(hq).getAddr(APPRAISER_ID),\n        billing = staticcall Registry(hq).getAddr(BILLING_ID),\n        wallet = wallet,\n        walletConfig = self,\n        walletOwner = owner,\n        inEjectMode = self.inEjectMode,\n        isFrozen = self.isFrozen,\n        lastTotalUsdValue = staticcall Ledger(ledger).getLastTotalUsdValue(wallet),\n        signer = _signer,\n        isManager = _signer != owner,\n        legoId = _legoId,\n        legoAddr = legoAddr,\n        eth = ETH,\n        weth = WETH,\n    )\n",
            "sha256sum": "8e94589e314542bda9a183b083c8f8645f3f16c975e3141caf990695a0d628f1"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/core/userWallet/UserWalletConfig.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.3+commit.bff19ea2",
        "integrity": "8ff2e8a8c4e66fcdbbb71bb198ac1094db314ee29d3fdcd655965375aed4c183"
      },
      "args": "",
      "file": "contracts/core/userWallet/UserWalletConfig.vy"
    },
    "AgentWrapper": {
      "address": "0x55eeA103abA26FA85fb1359E2D2e1961d1B46218",
      "abi": [
        {
          "name": "NonceIncremented",
          "inputs": [
            {
              "name": "oldNonce",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "newNonce",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "OwnershipChangeInitiated",
          "inputs": [
            {
              "name": "prevOwner",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newOwner",
              "type": "address",
              "indexed": true
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "OwnershipChangeConfirmed",
          "inputs": [
            {
              "name": "prevOwner",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newOwner",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "OwnershipChangeCancelled",
          "inputs": [
            {
              "name": "cancelledOwner",
              "type": "address",
              "indexed": true
            },
            {
              "name": "cancelledBy",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "OwnershipTimeLockSet",
          "inputs": [
            {
              "name": "numBlocks",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "changeOwnership",
          "inputs": [
            {
              "name": "_newOwner",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmOwnershipChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelOwnershipChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPendingOwnerChange",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setOwnershipTimeLock",
          "inputs": [
            {
              "name": "_numBlocks",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "owner",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ownershipTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingOwner",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "newOwner",
                  "type": "address"
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MIN_OWNERSHIP_TIMELOCK",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MAX_OWNERSHIP_TIMELOCK",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "transferFunds",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "transferFunds",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "transferFunds",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "transferFunds",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_isCheque",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "transferFunds",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_isCheque",
              "type": "bool"
            },
            {
              "name": "_sig",
              "type": "tuple",
              "components": [
                {
                  "name": "signature",
                  "type": "bytes"
                },
                {
                  "name": "nonce",
                  "type": "uint256"
                },
                {
                  "name": "expiration",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositForYield",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositForYield",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositForYield",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositForYield",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositForYield",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_sig",
              "type": "tuple",
              "components": [
                {
                  "name": "signature",
                  "type": "bytes"
                },
                {
                  "name": "nonce",
                  "type": "uint256"
                },
                {
                  "name": "expiration",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawFromYield",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawFromYield",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawFromYield",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawFromYield",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_sig",
              "type": "tuple",
              "components": [
                {
                  "name": "signature",
                  "type": "bytes"
                },
                {
                  "name": "nonce",
                  "type": "uint256"
                },
                {
                  "name": "expiration",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "rebalanceYieldPosition",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_fromLegoId",
              "type": "uint256"
            },
            {
              "name": "_fromVaultToken",
              "type": "address"
            },
            {
              "name": "_toLegoId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "rebalanceYieldPosition",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_fromLegoId",
              "type": "uint256"
            },
            {
              "name": "_fromVaultToken",
              "type": "address"
            },
            {
              "name": "_toLegoId",
              "type": "uint256"
            },
            {
              "name": "_toVaultAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "rebalanceYieldPosition",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_fromLegoId",
              "type": "uint256"
            },
            {
              "name": "_fromVaultToken",
              "type": "address"
            },
            {
              "name": "_toLegoId",
              "type": "uint256"
            },
            {
              "name": "_toVaultAddr",
              "type": "address"
            },
            {
              "name": "_fromVaultAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "rebalanceYieldPosition",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_fromLegoId",
              "type": "uint256"
            },
            {
              "name": "_fromVaultToken",
              "type": "address"
            },
            {
              "name": "_toLegoId",
              "type": "uint256"
            },
            {
              "name": "_toVaultAddr",
              "type": "address"
            },
            {
              "name": "_fromVaultAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "rebalanceYieldPosition",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_fromLegoId",
              "type": "uint256"
            },
            {
              "name": "_fromVaultToken",
              "type": "address"
            },
            {
              "name": "_toLegoId",
              "type": "uint256"
            },
            {
              "name": "_toVaultAddr",
              "type": "address"
            },
            {
              "name": "_fromVaultAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_sig",
              "type": "tuple",
              "components": [
                {
                  "name": "signature",
                  "type": "bytes"
                },
                {
                  "name": "nonce",
                  "type": "uint256"
                },
                {
                  "name": "expiration",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_swapInstructions",
              "type": "tuple[]",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "minAmountOut",
                  "type": "uint256"
                },
                {
                  "name": "tokenPath",
                  "type": "address[]"
                },
                {
                  "name": "poolPath",
                  "type": "address[]"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_swapInstructions",
              "type": "tuple[]",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "minAmountOut",
                  "type": "uint256"
                },
                {
                  "name": "tokenPath",
                  "type": "address[]"
                },
                {
                  "name": "poolPath",
                  "type": "address[]"
                }
              ]
            },
            {
              "name": "_sig",
              "type": "tuple",
              "components": [
                {
                  "name": "signature",
                  "type": "bytes"
                },
                {
                  "name": "nonce",
                  "type": "uint256"
                },
                {
                  "name": "expiration",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mintOrRedeemAsset",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mintOrRedeemAsset",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountIn",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mintOrRedeemAsset",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mintOrRedeemAsset",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mintOrRedeemAsset",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_sig",
              "type": "tuple",
              "components": [
                {
                  "name": "signature",
                  "type": "bytes"
                },
                {
                  "name": "nonce",
                  "type": "uint256"
                },
                {
                  "name": "expiration",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmMintOrRedeemAsset",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmMintOrRedeemAsset",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmMintOrRedeemAsset",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_sig",
              "type": "tuple",
              "components": [
                {
                  "name": "signature",
                  "type": "bytes"
                },
                {
                  "name": "nonce",
                  "type": "uint256"
                },
                {
                  "name": "expiration",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addCollateral",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addCollateral",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addCollateral",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addCollateral",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_sig",
              "type": "tuple",
              "components": [
                {
                  "name": "signature",
                  "type": "bytes"
                },
                {
                  "name": "nonce",
                  "type": "uint256"
                },
                {
                  "name": "expiration",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeCollateral",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeCollateral",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeCollateral",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeCollateral",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_sig",
              "type": "tuple",
              "components": [
                {
                  "name": "signature",
                  "type": "bytes"
                },
                {
                  "name": "nonce",
                  "type": "uint256"
                },
                {
                  "name": "expiration",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_borrowAsset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_borrowAsset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_borrowAsset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_borrowAsset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_sig",
              "type": "tuple",
              "components": [
                {
                  "name": "signature",
                  "type": "bytes"
                },
                {
                  "name": "nonce",
                  "type": "uint256"
                },
                {
                  "name": "expiration",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_paymentAsset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_paymentAsset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_paymentAsset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_paymentAsset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_sig",
              "type": "tuple",
              "components": [
                {
                  "name": "signature",
                  "type": "bytes"
                },
                {
                  "name": "nonce",
                  "type": "uint256"
                },
                {
                  "name": "expiration",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_sig",
              "type": "tuple",
              "components": [
                {
                  "name": "signature",
                  "type": "bytes"
                },
                {
                  "name": "nonce",
                  "type": "uint256"
                },
                {
                  "name": "expiration",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "convertWethToEth",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "convertWethToEth",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "convertWethToEth",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_sig",
              "type": "tuple",
              "components": [
                {
                  "name": "signature",
                  "type": "bytes"
                },
                {
                  "name": "nonce",
                  "type": "uint256"
                },
                {
                  "name": "expiration",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "convertEthToWeth",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "convertEthToWeth",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "convertEthToWeth",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_sig",
              "type": "tuple",
              "components": [
                {
                  "name": "signature",
                  "type": "bytes"
                },
                {
                  "name": "nonce",
                  "type": "uint256"
                },
                {
                  "name": "expiration",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_sig",
              "type": "tuple",
              "components": [
                {
                  "name": "signature",
                  "type": "bytes"
                },
                {
                  "name": "nonce",
                  "type": "uint256"
                },
                {
                  "name": "expiration",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_sig",
              "type": "tuple",
              "components": [
                {
                  "name": "signature",
                  "type": "bytes"
                },
                {
                  "name": "nonce",
                  "type": "uint256"
                },
                {
                  "name": "expiration",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidityConcentrated",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidityConcentrated",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidityConcentrated",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidityConcentrated",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidityConcentrated",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidityConcentrated",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidityConcentrated",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidityConcentrated",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidityConcentrated",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_sig",
              "type": "tuple",
              "components": [
                {
                  "name": "signature",
                  "type": "bytes"
                },
                {
                  "name": "nonce",
                  "type": "uint256"
                },
                {
                  "name": "expiration",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidityConcentrated",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidityConcentrated",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidityConcentrated",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidityConcentrated",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidityConcentrated",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidityConcentrated",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_sig",
              "type": "tuple",
              "components": [
                {
                  "name": "signature",
                  "type": "bytes"
                },
                {
                  "name": "nonce",
                  "type": "uint256"
                },
                {
                  "name": "expiration",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "performBatchActions",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_instructions",
              "type": "tuple[]",
              "components": [
                {
                  "name": "usePrevAmountOut",
                  "type": "bool"
                },
                {
                  "name": "action",
                  "type": "uint8"
                },
                {
                  "name": "legoId",
                  "type": "uint16"
                },
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "target",
                  "type": "address"
                },
                {
                  "name": "amount",
                  "type": "uint256"
                },
                {
                  "name": "asset2",
                  "type": "address"
                },
                {
                  "name": "amount2",
                  "type": "uint256"
                },
                {
                  "name": "minOut1",
                  "type": "uint256"
                },
                {
                  "name": "minOut2",
                  "type": "uint256"
                },
                {
                  "name": "tickLower",
                  "type": "int24"
                },
                {
                  "name": "tickUpper",
                  "type": "int24"
                },
                {
                  "name": "extraData",
                  "type": "bytes32"
                },
                {
                  "name": "auxData",
                  "type": "bytes32"
                },
                {
                  "name": "swapInstructions",
                  "type": "tuple[]",
                  "components": [
                    {
                      "name": "legoId",
                      "type": "uint256"
                    },
                    {
                      "name": "amountIn",
                      "type": "uint256"
                    },
                    {
                      "name": "minAmountOut",
                      "type": "uint256"
                    },
                    {
                      "name": "tokenPath",
                      "type": "address[]"
                    },
                    {
                      "name": "poolPath",
                      "type": "address[]"
                    }
                  ]
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "performBatchActions",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_instructions",
              "type": "tuple[]",
              "components": [
                {
                  "name": "usePrevAmountOut",
                  "type": "bool"
                },
                {
                  "name": "action",
                  "type": "uint8"
                },
                {
                  "name": "legoId",
                  "type": "uint16"
                },
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "target",
                  "type": "address"
                },
                {
                  "name": "amount",
                  "type": "uint256"
                },
                {
                  "name": "asset2",
                  "type": "address"
                },
                {
                  "name": "amount2",
                  "type": "uint256"
                },
                {
                  "name": "minOut1",
                  "type": "uint256"
                },
                {
                  "name": "minOut2",
                  "type": "uint256"
                },
                {
                  "name": "tickLower",
                  "type": "int24"
                },
                {
                  "name": "tickUpper",
                  "type": "int24"
                },
                {
                  "name": "extraData",
                  "type": "bytes32"
                },
                {
                  "name": "auxData",
                  "type": "bytes32"
                },
                {
                  "name": "swapInstructions",
                  "type": "tuple[]",
                  "components": [
                    {
                      "name": "legoId",
                      "type": "uint256"
                    },
                    {
                      "name": "amountIn",
                      "type": "uint256"
                    },
                    {
                      "name": "minAmountOut",
                      "type": "uint256"
                    },
                    {
                      "name": "tokenPath",
                      "type": "address[]"
                    },
                    {
                      "name": "poolPath",
                      "type": "address[]"
                    }
                  ]
                }
              ]
            },
            {
              "name": "_sig",
              "type": "tuple",
              "components": [
                {
                  "name": "signature",
                  "type": "bytes"
                },
                {
                  "name": "nonce",
                  "type": "uint256"
                },
                {
                  "name": "expiration",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "incrementNonce",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getNonce",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "groupId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "currentNonce",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_undyHq",
              "type": "address"
            },
            {
              "name": "_owner",
              "type": "address"
            },
            {
              "name": "_groupId",
              "type": "uint256"
            },
            {
              "name": "_minTimeLock",
              "type": "uint256"
            },
            {
              "name": "_maxTimeLock",
              "type": "uint256"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/modules/Ownership.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\ninterface MissionControl:\n    def canPerformSecurityAction(_addr: address) -> bool: view\n\ninterface UndyHq:\n    def getAddr(_regId: uint256) -> address: view\n\nstruct PendingOwnerChange:\n    newOwner: address\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent OwnershipChangeInitiated:\n    prevOwner: indexed(address)\n    newOwner: indexed(address)\n    confirmBlock: uint256\n\nevent OwnershipChangeConfirmed:\n    prevOwner: indexed(address)\n    newOwner: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent OwnershipChangeCancelled:\n    cancelledOwner: indexed(address)\n    cancelledBy: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent OwnershipTimeLockSet:\n    numBlocks: uint256\n\n# core\nowner: public(address)\nownershipTimeLock: public(uint256)\n\n# pending owner change\npendingOwner: public(PendingOwnerChange)\n\nUNDY_HQ_FOR_OWNERSHIP: immutable(address)\nMIN_OWNERSHIP_TIMELOCK: public(immutable(uint256))\nMAX_OWNERSHIP_TIMELOCK: public(immutable(uint256))\nMISSION_CONTROL_ID: constant(uint256) = 2\n\n\n@deploy\ndef __init__(\n    _undyHq: address,\n    _owner: address,\n    _minTimeLock: uint256,\n    _maxTimeLock: uint256,\n):\n    assert empty(address) not in [_undyHq, _owner] # dev: invalid addrs\n    UNDY_HQ_FOR_OWNERSHIP = _undyHq\n\n    # initial ownership\n    self.owner = _owner\n\n    # timelock\n    assert _minTimeLock != 0 and _minTimeLock < _maxTimeLock # dev: invalid delay\n    MIN_OWNERSHIP_TIMELOCK = _minTimeLock\n    MAX_OWNERSHIP_TIMELOCK = _maxTimeLock\n\n    self.ownershipTimeLock = _minTimeLock\n\n\n#############\n# Ownership #\n#############\n\n\n# change ownership\n\n\n@external\ndef changeOwnership(_newOwner: address):\n    currentOwner: address = self.owner\n    assert msg.sender == currentOwner # dev: no perms\n    assert _newOwner not in [empty(address), currentOwner] # dev: invalid new owner\n\n    confirmBlock: uint256 = block.number + self.ownershipTimeLock\n    self.pendingOwner = PendingOwnerChange(\n        newOwner = _newOwner,\n        initiatedBlock = block.number,\n        confirmBlock = confirmBlock,\n    )\n    log OwnershipChangeInitiated(prevOwner = currentOwner, newOwner = _newOwner, confirmBlock = confirmBlock)\n\n\n# confirm ownership change\n\n\n@external\ndef confirmOwnershipChange():\n    data: PendingOwnerChange = self.pendingOwner\n    assert data.newOwner != empty(address) # dev: no pending owner\n    assert data.confirmBlock != 0 and block.number >= data.confirmBlock # dev: time delay not reached\n    assert msg.sender == data.newOwner # dev: only new owner can confirm\n\n    prevOwner: address = self.owner\n    self.owner = data.newOwner\n    self.pendingOwner = empty(PendingOwnerChange)\n    log OwnershipChangeConfirmed(prevOwner = prevOwner, newOwner = data.newOwner, initiatedBlock = data.initiatedBlock, confirmBlock = data.confirmBlock)\n\n\n# cancel ownership change\n\n\n@external\ndef cancelOwnershipChange():\n    if msg.sender != self.owner:\n        assert self._canPerformSecurityAction(msg.sender) # dev: no perms\n\n    data: PendingOwnerChange = self.pendingOwner\n    assert data.confirmBlock != 0 # dev: no pending change\n    self.pendingOwner = empty(PendingOwnerChange)\n    log OwnershipChangeCancelled(cancelledOwner = data.newOwner, cancelledBy = msg.sender, initiatedBlock = data.initiatedBlock, confirmBlock = data.confirmBlock)\n\n\n@view\n@internal\ndef _canPerformSecurityAction(_addr: address) -> bool:\n    missionControl: address = staticcall UndyHq(UNDY_HQ_FOR_OWNERSHIP).getAddr(MISSION_CONTROL_ID)\n    if missionControl == empty(address):\n        return False\n    return staticcall MissionControl(missionControl).canPerformSecurityAction(_addr)\n\n\n#############\n# Utilities #\n#############\n\n\n@view\n@external\ndef hasPendingOwnerChange() -> bool:\n    return self._hasPendingOwnerChange()\n\n\n@view\n@internal\ndef _hasPendingOwnerChange() -> bool:\n    return self.pendingOwner.confirmBlock != 0\n\n\n#############\n# Time Lock #\n#############\n\n\n@external\ndef setOwnershipTimeLock(_numBlocks: uint256):\n    assert msg.sender == self.owner # dev: no perms\n    assert _numBlocks >= MIN_OWNERSHIP_TIMELOCK and _numBlocks <= MAX_OWNERSHIP_TIMELOCK # dev: invalid delay\n    self.ownershipTimeLock = _numBlocks\n    log OwnershipTimeLockSet(numBlocks=_numBlocks)",
            "sha256sum": "8c3dfc35ec492193531cadc81744d81f92f28ec166f809d45f42bdece1c1d379"
          },
          "interfaces/Wallet.vyi": {
            "content": "# @version 0.4.3\n\nstruct SwapInstruction:\n    legoId: uint256\n    amountIn: uint256\n    minAmountOut: uint256\n    tokenPath: DynArray[address, MAX_TOKEN_PATH]\n    poolPath: DynArray[address, MAX_TOKEN_PATH - 1]\n\nMAX_SWAP_INSTRUCTIONS: constant(uint256) = 5\nMAX_TOKEN_PATH: constant(uint256) = 5\n\n\n@view\n@external\ndef onERC721Received(_operator: address, _owner: address, _tokenId: uint256, _data: Bytes[1024]) -> bytes4:\n    ...\n\n\n@pure\n@external\ndef apiVersion() -> String[28]:\n    ...\n\n##################\n# Transfer Funds #\n##################\n\n\n@external\ndef transferFunds(\n    _recipient: address,\n    _asset: address = empty(address),\n    _amount: uint256 = max_value(uint256),\n    _isCheque: bool = False,\n    _isTrustedTx: bool = False,\n) -> (uint256, uint256):\n    ...\n\n\n#########\n# Yield #\n#########\n\n\n# deposit\n\n\n@external\ndef depositForYield(\n    _legoId: uint256,\n    _asset: address,\n    _vaultAddr: address = empty(address),\n    _amount: uint256 = max_value(uint256),\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, address, uint256, uint256):\n    ...\n\n\n# withdraw\n\n\n@external\ndef withdrawFromYield(\n    _legoId: uint256,\n    _vaultToken: address,\n    _amount: uint256 = max_value(uint256),\n    _extraData: bytes32 = empty(bytes32),\n    _isTrustedTx: bool = False,\n) -> (uint256, address, uint256, uint256):\n    ...\n\n\n# rebalance position\n\n\n@external\ndef rebalanceYieldPosition(\n    _fromLegoId: uint256,\n    _fromVaultToken: address,\n    _toLegoId: uint256,\n    _toVaultAddr: address = empty(address),\n    _fromVaultAmount: uint256 = max_value(uint256),\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, address, uint256, uint256):\n    ...\n\n\n###################\n# Swap / Exchange #\n###################\n\n\n@external\ndef swapTokens(_instructions: DynArray[SwapInstruction, MAX_SWAP_INSTRUCTIONS]) -> (address, uint256, address, uint256, uint256):\n    ...\n\n\n# mint / redeem\n\n\n@external\ndef mintOrRedeemAsset(\n    _legoId: uint256,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256 = max_value(uint256),\n    _minAmountOut: uint256 = 0,\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, uint256, bool, uint256):\n    ...\n\n\n@external\ndef confirmMintOrRedeemAsset(\n    _legoId: uint256,\n    _tokenIn: address,\n    _tokenOut: address,\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, uint256):\n    ...\n\n\n###################\n# Debt Management #\n###################\n\n\n# add collateral\n\n\n@external\ndef addCollateral(\n    _legoId: uint256,\n    _asset: address,\n    _amount: uint256 = max_value(uint256),\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, uint256):\n    ...\n\n\n# remove collateral\n\n\n@external\ndef removeCollateral(\n    _legoId: uint256,\n    _asset: address,\n    _amount: uint256 = max_value(uint256),\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, uint256):\n    ...\n\n\n# borrow\n\n\n@external\ndef borrow(\n    _legoId: uint256,\n    _borrowAsset: address,\n    _amount: uint256 = max_value(uint256),\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, uint256):\n    ...\n\n\n# repay debt\n\n\n@external\ndef repayDebt(\n    _legoId: uint256,\n    _paymentAsset: address,\n    _paymentAmount: uint256 = max_value(uint256),\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, uint256):\n    ...\n\n\n#################\n# Claim Rewards #\n#################\n\n\n@external\ndef claimRewards(\n    _legoId: uint256,\n    _rewardToken: address = empty(address),\n    _rewardAmount: uint256 = max_value(uint256),\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, uint256):\n    ...\n\n\n################\n# Wrapped ETH #\n################\n\n\n# eth -> weth\n\n\n@payable\n@external\ndef convertEthToWeth(_amount: uint256 = max_value(uint256)) -> (uint256, uint256):\n    ...\n\n\n# weth -> eth\n\n\n@external\ndef convertWethToEth(_amount: uint256 = max_value(uint256)) -> (uint256, uint256):\n    ...\n\n\n#################\n# Add Liquidity #\n#################\n\n\n# add / remove liquidity (simple)\n\n\n@external\ndef addLiquidity(\n    _legoId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _amountA: uint256 = max_value(uint256),\n    _amountB: uint256 = max_value(uint256),\n    _minAmountA: uint256 = 0,\n    _minAmountB: uint256 = 0,\n    _minLpAmount: uint256 = 0,\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, uint256, uint256, uint256):\n    ...\n\n\n@external\ndef removeLiquidity(\n    _legoId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpToken: address,\n    _lpAmount: uint256 = max_value(uint256),\n    _minAmountA: uint256 = 0,\n    _minAmountB: uint256 = 0,\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, uint256, uint256, uint256):\n    ...\n\n\n# add / remove liquidity (concentrated)\n\n\n@external\ndef addLiquidityConcentrated(\n    _legoId: uint256,\n    _nftAddr: address,\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _amountA: uint256 = max_value(uint256),\n    _amountB: uint256 = max_value(uint256),\n    _tickLower: int24 = min_value(int24),\n    _tickUpper: int24 = max_value(int24),\n    _minAmountA: uint256 = 0,\n    _minAmountB: uint256 = 0,\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, uint256, uint256, uint256, uint256):\n    ...\n\n\n@external\ndef removeLiquidityConcentrated(\n    _legoId: uint256,\n    _nftAddr: address,\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _liqToRemove: uint256 = max_value(uint256),\n    _minAmountA: uint256 = 0,\n    _minAmountB: uint256 = 0,\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, uint256, uint256, uint256):\n    ...\n\n\n#############\n# Utilities #\n#############\n\n\n# recover nft\n\n\n@external\ndef recoverNft(_collection: address, _nftTokenId: uint256, _recipient: address):\n    ...\n",
            "sha256sum": "bc36343f2acf1bcd8ce0ae78be20898917cec4f6fa4a4e9fcfea42baa0f75c21"
          },
          "contracts/core/agent/AgentWrapper.vy": {
            "content": "#             _                   _                 _               _                 _       \n#            / /\\                /\\ \\              /\\ \\            /\\ \\     _        /\\ \\     \n#           / /  \\              /  \\ \\            /  \\ \\          /  \\ \\   /\\_\\      \\_\\ \\    \n#          / / /\\ \\            / /\\ \\_\\          / /\\ \\ \\        / /\\ \\ \\_/ / /      /\\__ \\   \n#         / / /\\ \\ \\          / / /\\/_/         / / /\\ \\_\\      / / /\\ \\___/ /      / /_ \\ \\  \n#        / / /  \\ \\ \\        / / / ______      / /_/_ \\/_/     / / /  \\/____/      / / /\\ \\ \\ \n#       / / /___/ /\\ \\      / / / /\\_____\\    / /____/\\       / / /    / / /      / / /  \\/_/ \n#      / / /_____/ /\\ \\    / / /  \\/____ /   / /\\____\\/      / / /    / / /      / / /        \n#     / /_________/\\ \\ \\  / / /_____/ / /   / / /______     / / /    / / /      / / /         \n#    / / /_       __\\ \\_\\/ / /______\\/ /   / / /_______\\   / / /    / / /      /_/ /          \n#    \\_\\___\\     /____/_/\\/___________/    \\/__________/   \\/_/     \\/_/       \\_\\/           \n#                                                                                         \n#     \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n#     \u2551  ** Agent Wrapper **                                                           \u2551\n#     \u2551  Handles all agent wrapper functionality                                       \u2551\n#     \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n#\n#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n# pragma optimize codesize\n\ninitializes: ownership\nexports: ownership.__interface__\nimport contracts.modules.Ownership as ownership\n\nfrom interfaces import Wallet\n\nstruct Signature:\n    signature: Bytes[65]\n    nonce: uint256\n    expiration: uint256\n\nstruct ActionInstruction:\n    usePrevAmountOut: bool     # Use output from previous instruction as amount\n    action: uint8              # Action type: 1=transfer, 2=weth2eth, 3=eth2weth, 10=depositYield, 11=withdrawYield, 12=rebalanceYield, 20=swap, 21=mint/redeem, 22=confirmMint/redeem, 30=addLiq, 31=removeLiq, 32=addLiqConc, 33=removeLiqConc, 40=addCollateral, 41=removeCollateral, 42=borrow, 43=repay, 50=claimRewards\n    legoId: uint16             # Protocol/Lego ID (use amount2 for toLegoId in rebalance)\n    asset: address             # Primary asset/token (or vaultToken for withdrawals)\n    target: address            # Varies: recipient/vaultAddr/tokenOut/pool based on action\n    amount: uint256            # Primary amount (or max_value for \"all\")\n    asset2: address            # Secondary asset (tokenB for liquidity ops)\n    amount2: uint256           # Varies: amountB for liquidity, toLegoId for rebalance\n    minOut1: uint256           # Min output for primary asset (or minAmountOut)\n    minOut2: uint256           # Min output for secondary asset (liquidity ops)\n    tickLower: int24           # For concentrated liquidity positions\n    tickUpper: int24           # For concentrated liquidity positions\n    extraData: bytes32         # Protocol-specific extra data (LSB used for isCheque in transfers)\n    auxData: bytes32           # Packed data: lpToken addr (action 15) or pool+nftId (16-17)\n    swapInstructions: DynArray[Wallet.SwapInstruction, MAX_SWAP_INSTRUCTIONS]\n\nevent NonceIncremented:\n    oldNonce: uint256\n    newNonce: uint256\n\ngroupId: public(uint256)\ncurrentNonce: public(uint256)\n\nMAX_INSTRUCTIONS: constant(uint256) = 15\nMAX_SWAP_INSTRUCTIONS: constant(uint256) = 5\nMAX_TOKEN_PATH: constant(uint256) = 5\n\n# unified signature validation\nECRECOVER_PRECOMPILE: constant(address) = 0x0000000000000000000000000000000000000001\nSIG_PREFIX: constant(bytes32) = 0x1901000000000000000000000000000000000000000000000000000000000000\n\n\n@deploy\ndef __init__(\n    _undyHq: address,\n    _owner: address,\n    _groupId: uint256,\n    _minTimeLock: uint256,\n    _maxTimeLock: uint256,\n):\n    ownership.__init__(_undyHq, _owner, _minTimeLock, _maxTimeLock)\n    self.groupId = _groupId\n\n\n##################\n# Transfer Funds #\n##################\n\n\n@nonreentrant\n@external\ndef transferFunds(\n    _userWallet: address,\n    _recipient: address,\n    _asset: address = empty(address),\n    _amount: uint256 = max_value(uint256),\n    _isCheque: bool = False,\n    _sig: Signature = empty(Signature),\n) -> (uint256, uint256):\n    self._authenticateAccess(keccak256(abi_encode(convert(1, uint8), _userWallet, _recipient, _asset, _amount, _sig.nonce, _sig.expiration)), _sig)\n    return extcall Wallet(_userWallet).transferFunds(_recipient, _asset, _amount, _isCheque, False)\n\n\n#########\n# Yield #\n#########\n\n\n@nonreentrant\n@external\ndef depositForYield(\n    _userWallet: address,\n    _legoId: uint256,\n    _asset: address,\n    _vaultAddr: address = empty(address),\n    _amount: uint256 = max_value(uint256),\n    _extraData: bytes32 = empty(bytes32),\n    _sig: Signature = empty(Signature),\n) -> (uint256, address, uint256, uint256):\n    self._authenticateAccess(keccak256(abi_encode(convert(10, uint8), _userWallet, _legoId, _asset, _vaultAddr, _amount, _extraData, _sig.nonce, _sig.expiration)), _sig)\n    return extcall Wallet(_userWallet).depositForYield(_legoId, _asset, _vaultAddr, _amount, _extraData)\n\n\n@nonreentrant\n@external\ndef withdrawFromYield(\n    _userWallet: address,\n    _legoId: uint256,\n    _vaultToken: address,\n    _amount: uint256 = max_value(uint256),\n    _extraData: bytes32 = empty(bytes32),\n    _sig: Signature = empty(Signature),\n) -> (uint256, address, uint256, uint256):\n    self._authenticateAccess(keccak256(abi_encode(convert(11, uint8), _userWallet, _legoId, _vaultToken, _amount, _extraData, _sig.nonce, _sig.expiration)), _sig)\n    return extcall Wallet(_userWallet).withdrawFromYield(_legoId, _vaultToken, _amount, _extraData, False)\n\n\n@nonreentrant\n@external\ndef rebalanceYieldPosition(\n    _userWallet: address,\n    _fromLegoId: uint256,\n    _fromVaultToken: address,\n    _toLegoId: uint256,\n    _toVaultAddr: address = empty(address),\n    _fromVaultAmount: uint256 = max_value(uint256),\n    _extraData: bytes32 = empty(bytes32),\n    _sig: Signature = empty(Signature),\n) -> (uint256, address, uint256, uint256):\n    self._authenticateAccess(keccak256(abi_encode(convert(12, uint8), _userWallet, _fromLegoId, _fromVaultToken, _toLegoId, _toVaultAddr, _fromVaultAmount, _extraData, _sig.nonce, _sig.expiration)), _sig)\n    return extcall Wallet(_userWallet).rebalanceYieldPosition(_fromLegoId, _fromVaultToken, _toLegoId, _toVaultAddr, _fromVaultAmount, _extraData)\n\n\n###################\n# Swap / Exchange #\n###################\n\n\n@nonreentrant\n@external\ndef swapTokens(\n    _userWallet: address,\n    _swapInstructions: DynArray[Wallet.SwapInstruction, MAX_SWAP_INSTRUCTIONS],\n    _sig: Signature = empty(Signature),\n) -> (address, uint256, address, uint256, uint256):\n    self._authenticateAccess(keccak256(abi_encode(convert(20, uint8), _userWallet, _swapInstructions, _sig.nonce, _sig.expiration)), _sig)\n    return extcall Wallet(_userWallet).swapTokens(_swapInstructions)\n\n\n@nonreentrant\n@external\ndef mintOrRedeemAsset(\n    _userWallet: address,\n    _legoId: uint256,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256 = max_value(uint256),\n    _minAmountOut: uint256 = 0,\n    _extraData: bytes32 = empty(bytes32),\n    _sig: Signature = empty(Signature),\n) -> (uint256, uint256, bool, uint256):\n    self._authenticateAccess(keccak256(abi_encode(convert(21, uint8), _userWallet, _legoId, _tokenIn, _tokenOut, _amountIn, _minAmountOut, _extraData, _sig.nonce, _sig.expiration)), _sig)\n    return extcall Wallet(_userWallet).mintOrRedeemAsset(_legoId, _tokenIn, _tokenOut, _amountIn, _minAmountOut, _extraData)\n\n\n@nonreentrant\n@external\ndef confirmMintOrRedeemAsset(\n    _userWallet: address,\n    _legoId: uint256,\n    _tokenIn: address,\n    _tokenOut: address,\n    _extraData: bytes32 = empty(bytes32),\n    _sig: Signature = empty(Signature),\n) -> (uint256, uint256):\n    self._authenticateAccess(keccak256(abi_encode(convert(22, uint8), _userWallet, _legoId, _tokenIn, _tokenOut, _extraData, _sig.nonce, _sig.expiration)), _sig)\n    return extcall Wallet(_userWallet).confirmMintOrRedeemAsset(_legoId, _tokenIn, _tokenOut, _extraData)\n\n\n###################\n# Debt Management #\n###################\n\n\n@nonreentrant\n@external\ndef addCollateral(\n    _userWallet: address,\n    _legoId: uint256,\n    _asset: address,\n    _amount: uint256 = max_value(uint256),\n    _extraData: bytes32 = empty(bytes32),\n    _sig: Signature = empty(Signature),\n) -> (uint256, uint256):\n    self._authenticateAccess(keccak256(abi_encode(convert(40, uint8), _userWallet, _legoId, _asset, _amount, _extraData, _sig.nonce, _sig.expiration)), _sig)\n    return extcall Wallet(_userWallet).addCollateral(_legoId, _asset, _amount, _extraData)\n\n\n@nonreentrant\n@external\ndef removeCollateral(\n    _userWallet: address,\n    _legoId: uint256,\n    _asset: address,\n    _amount: uint256 = max_value(uint256),\n    _extraData: bytes32 = empty(bytes32),\n    _sig: Signature = empty(Signature),\n) -> (uint256, uint256):\n    self._authenticateAccess(keccak256(abi_encode(convert(41, uint8), _userWallet, _legoId, _asset, _amount, _extraData, _sig.nonce, _sig.expiration)), _sig)\n    return extcall Wallet(_userWallet).removeCollateral(_legoId, _asset, _amount, _extraData)\n\n\n@nonreentrant\n@external\ndef borrow(\n    _userWallet: address,\n    _legoId: uint256,\n    _borrowAsset: address,\n    _amount: uint256 = max_value(uint256),\n    _extraData: bytes32 = empty(bytes32),\n    _sig: Signature = empty(Signature),\n) -> (uint256, uint256):\n    self._authenticateAccess(keccak256(abi_encode(convert(42, uint8), _userWallet, _legoId, _borrowAsset, _amount, _extraData, _sig.nonce, _sig.expiration)), _sig)\n    return extcall Wallet(_userWallet).borrow(_legoId, _borrowAsset, _amount, _extraData)\n\n\n@nonreentrant\n@external\ndef repayDebt(\n    _userWallet: address,\n    _legoId: uint256,\n    _paymentAsset: address,\n    _paymentAmount: uint256 = max_value(uint256),\n    _extraData: bytes32 = empty(bytes32),\n    _sig: Signature = empty(Signature),\n) -> (uint256, uint256):\n    self._authenticateAccess(keccak256(abi_encode(convert(43, uint8), _userWallet, _legoId, _paymentAsset, _paymentAmount, _extraData, _sig.nonce, _sig.expiration)), _sig)\n    return extcall Wallet(_userWallet).repayDebt(_legoId, _paymentAsset, _paymentAmount, _extraData)\n\n\n#################\n# Claim Rewards #\n#################\n\n\n@nonreentrant\n@external\ndef claimRewards(\n    _userWallet: address,\n    _legoId: uint256,\n    _rewardToken: address = empty(address),\n    _rewardAmount: uint256 = max_value(uint256),\n    _extraData: bytes32 = empty(bytes32),\n    _sig: Signature = empty(Signature),\n) -> (uint256, uint256):\n    self._authenticateAccess(keccak256(abi_encode(convert(50, uint8), _userWallet, _legoId, _rewardToken, _rewardAmount, _extraData, _sig.nonce, _sig.expiration)), _sig)\n    return extcall Wallet(_userWallet).claimRewards(_legoId, _rewardToken, _rewardAmount, _extraData)\n\n\n###############\n# Wrapped ETH #\n###############\n\n\n@nonreentrant\n@external\ndef convertWethToEth(_userWallet: address, _amount: uint256 = max_value(uint256), _sig: Signature = empty(Signature)) -> (uint256, uint256):\n    self._authenticateAccess(keccak256(abi_encode(convert(2, uint8), _userWallet, _amount, _sig.nonce, _sig.expiration)), _sig)\n    return extcall Wallet(_userWallet).convertWethToEth(_amount)\n\n\n@nonreentrant\n@external\ndef convertEthToWeth(_userWallet: address, _amount: uint256 = max_value(uint256), _sig: Signature = empty(Signature)) -> (uint256, uint256):\n    self._authenticateAccess(keccak256(abi_encode(convert(3, uint8), _userWallet, _amount, _sig.nonce, _sig.expiration)), _sig)\n    return extcall Wallet(_userWallet).convertEthToWeth(_amount)\n\n\n#############\n# Liquidity #\n#############\n\n\n@nonreentrant\n@external\ndef addLiquidity(\n    _userWallet: address,\n    _legoId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _amountA: uint256 = max_value(uint256),\n    _amountB: uint256 = max_value(uint256),\n    _minAmountA: uint256 = 0,\n    _minAmountB: uint256 = 0,\n    _minLpAmount: uint256 = 0,\n    _extraData: bytes32 = empty(bytes32),\n    _sig: Signature = empty(Signature),\n) -> (uint256, uint256, uint256, uint256):\n    self._authenticateAccess(keccak256(abi_encode(convert(30, uint8), _userWallet, _legoId, _pool, _tokenA, _tokenB, _amountA, _amountB, _minAmountA, _minAmountB, _minLpAmount, _extraData, _sig.nonce, _sig.expiration)), _sig)\n    return extcall Wallet(_userWallet).addLiquidity(_legoId, _pool, _tokenA, _tokenB, _amountA, _amountB, _minAmountA, _minAmountB, _minLpAmount, _extraData)\n\n\n@nonreentrant\n@external\ndef removeLiquidity(\n    _userWallet: address,\n    _legoId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpToken: address,\n    _lpAmount: uint256 = max_value(uint256),\n    _minAmountA: uint256 = 0,\n    _minAmountB: uint256 = 0,\n    _extraData: bytes32 = empty(bytes32),\n    _sig: Signature = empty(Signature),\n) -> (uint256, uint256, uint256, uint256):\n    self._authenticateAccess(keccak256(abi_encode(convert(31, uint8), _userWallet, _legoId, _pool, _tokenA, _tokenB, _lpToken, _lpAmount, _minAmountA, _minAmountB, _extraData, _sig.nonce, _sig.expiration)), _sig)\n    return extcall Wallet(_userWallet).removeLiquidity(_legoId, _pool, _tokenA, _tokenB, _lpToken, _lpAmount, _minAmountA, _minAmountB, _extraData)\n\n\n@nonreentrant\n@external\ndef addLiquidityConcentrated(\n    _userWallet: address,\n    _legoId: uint256,\n    _nftAddr: address,\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _amountA: uint256 = max_value(uint256),\n    _amountB: uint256 = max_value(uint256),\n    _tickLower: int24 = min_value(int24),\n    _tickUpper: int24 = max_value(int24),\n    _minAmountA: uint256 = 0,\n    _minAmountB: uint256 = 0,\n    _extraData: bytes32 = empty(bytes32),\n    _sig: Signature = empty(Signature),\n) -> (uint256, uint256, uint256, uint256, uint256):\n    self._authenticateAccess(keccak256(abi_encode(convert(32, uint8), _userWallet, _legoId, _nftAddr, _nftTokenId, _pool, _tokenA, _tokenB, _amountA, _amountB, _tickLower, _tickUpper, _minAmountA, _minAmountB, _extraData, _sig.nonce, _sig.expiration)), _sig)\n    return extcall Wallet(_userWallet).addLiquidityConcentrated(_legoId, _nftAddr, _nftTokenId, _pool, _tokenA, _tokenB, _amountA, _amountB, _tickLower, _tickUpper, _minAmountA, _minAmountB, _extraData)\n\n\n@nonreentrant\n@external\ndef removeLiquidityConcentrated(\n    _userWallet: address,\n    _legoId: uint256,\n    _nftAddr: address,\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _liqToRemove: uint256 = max_value(uint256),\n    _minAmountA: uint256 = 0,\n    _minAmountB: uint256 = 0,\n    _extraData: bytes32 = empty(bytes32),\n    _sig: Signature = empty(Signature),\n) -> (uint256, uint256, uint256, uint256):\n    self._authenticateAccess(keccak256(abi_encode(convert(33, uint8), _userWallet, _legoId, _nftAddr, _nftTokenId, _pool, _tokenA, _tokenB, _liqToRemove, _minAmountA, _minAmountB, _extraData, _sig.nonce, _sig.expiration)), _sig)\n    return extcall Wallet(_userWallet).removeLiquidityConcentrated(_legoId, _nftAddr, _nftTokenId, _pool, _tokenA, _tokenB, _liqToRemove, _minAmountA, _minAmountB, _extraData)\n\n\n#################\n# Batch Actions #\n#################\n\n\n@nonreentrant\n@external\ndef performBatchActions(\n    _userWallet: address,\n    _instructions: DynArray[ActionInstruction, MAX_INSTRUCTIONS],\n    _sig: Signature = empty(Signature),\n) -> bool:\n    assert len(_instructions) > 0 # dev: no instructions\n    messageHash: bytes32 = keccak256(abi_encode(_userWallet, _instructions, _sig.nonce, _sig.expiration))\n    self._authenticateAccess(messageHash, _sig)   \n\n    prevAmountReceived: uint256 = 0\n    for instruction: ActionInstruction in _instructions:\n        prevAmountReceived = self._executeAction(_userWallet, instruction, prevAmountReceived)\n\n    return True\n\n\n@internal\ndef _executeAction(_userWallet: address, instruction: ActionInstruction, _prevAmount: uint256) -> uint256:\n    nextAmount: uint256 = instruction.amount\n    if instruction.usePrevAmountOut and _prevAmount != 0:\n        nextAmount = _prevAmount\n\n    txUsdValue: uint256 = 0\n\n    # transfer funds\n    if instruction.action == 1:\n        # Extract isCheque from the least significant bit of extraData\n        isCheque: bool = convert(convert(instruction.extraData, uint256) & 1, bool)\n        nextAmount, txUsdValue = extcall Wallet(_userWallet).transferFunds(instruction.target, instruction.asset, nextAmount, isCheque, False)\n        return nextAmount\n\n    # convert weth to eth\n    elif instruction.action == 2:\n        nextAmount, txUsdValue = extcall Wallet(_userWallet).convertWethToEth(nextAmount)\n        return nextAmount\n\n    # convert eth to weth\n    elif instruction.action == 3:\n        nextAmount, txUsdValue = extcall Wallet(_userWallet).convertEthToWeth(nextAmount)\n        return nextAmount\n\n    # deposit for yield\n    elif instruction.action == 10:\n        assetAmount: uint256 = 0\n        vaultToken: address = empty(address)\n        assetAmount, vaultToken, nextAmount, txUsdValue = extcall Wallet(_userWallet).depositForYield(convert(instruction.legoId, uint256), instruction.asset, instruction.target, nextAmount, instruction.extraData)\n        return nextAmount\n\n    # withdraw from yield\n    elif instruction.action == 11:\n        underlyingAmount: uint256 = 0\n        underlyingToken: address = empty(address)\n        underlyingAmount, underlyingToken, nextAmount, txUsdValue = extcall Wallet(_userWallet).withdrawFromYield(convert(instruction.legoId, uint256), instruction.asset, nextAmount, instruction.extraData)\n        return nextAmount\n\n    # rebalance yield position (not a UserWallet op code, but valid AgentWrapper action)\n    elif instruction.action == 12:\n        underlyingAmount: uint256 = 0\n        underlyingToken: address = empty(address)\n        # NOTE: amount2 is used as toLegoId (not an amount!)\n        # Params: fromLegoId, fromVaultToken, toLegoId (amount2), toVaultAddr (target), fromVaultAmount\n        underlyingAmount, underlyingToken, nextAmount, txUsdValue = extcall Wallet(_userWallet).rebalanceYieldPosition(convert(instruction.legoId, uint256), instruction.asset, instruction.amount2, instruction.target, nextAmount, instruction.extraData)\n        return nextAmount\n\n    # swap tokens\n    elif instruction.action == 20:\n        if instruction.usePrevAmountOut and _prevAmount != 0:\n            instruction.swapInstructions[0].amountIn = _prevAmount\n        tokenIn: address = empty(address)\n        amountIn: uint256 = 0\n        tokenOut: address = empty(address)\n        tokenIn, amountIn, tokenOut, nextAmount, txUsdValue = extcall Wallet(_userWallet).swapTokens(instruction.swapInstructions)\n        return nextAmount\n\n    # mint or redeem asset\n    elif instruction.action == 21:\n        assetTokenAmount: uint256 = 0\n        isPending: bool = False\n        assetTokenAmount, nextAmount, isPending, txUsdValue = extcall Wallet(_userWallet).mintOrRedeemAsset(convert(instruction.legoId, uint256), instruction.asset, instruction.target, nextAmount, instruction.minOut1, instruction.extraData)\n        return nextAmount\n\n    # confirm mint or redeem asset\n    elif instruction.action == 22:\n        nextAmount, txUsdValue = extcall Wallet(_userWallet).confirmMintOrRedeemAsset(convert(instruction.legoId, uint256), instruction.asset, instruction.target, instruction.extraData)\n        return nextAmount\n\n    # add collateral\n    elif instruction.action == 40:\n        nextAmount, txUsdValue = extcall Wallet(_userWallet).addCollateral(convert(instruction.legoId, uint256), instruction.asset, nextAmount, instruction.extraData)\n        return nextAmount\n\n    # remove collateral\n    elif instruction.action == 41:\n        nextAmount, txUsdValue = extcall Wallet(_userWallet).removeCollateral(convert(instruction.legoId, uint256), instruction.asset, nextAmount, instruction.extraData)\n        return nextAmount\n\n    # borrow\n    elif instruction.action == 42:\n        nextAmount, txUsdValue = extcall Wallet(_userWallet).borrow(convert(instruction.legoId, uint256), instruction.asset, nextAmount, instruction.extraData)\n        return nextAmount\n\n    # repay debt\n    elif instruction.action == 43:\n        nextAmount, txUsdValue = extcall Wallet(_userWallet).repayDebt(convert(instruction.legoId, uint256), instruction.asset, nextAmount, instruction.extraData)\n        return nextAmount\n\n    # claim rewards\n    elif instruction.action == 50:\n        nextAmount, txUsdValue = extcall Wallet(_userWallet).claimRewards(convert(instruction.legoId, uint256), instruction.asset, nextAmount, instruction.extraData)\n        return nextAmount\n\n    # add liquidity\n    elif instruction.action == 30:\n        amountA: uint256 = 0\n        amountB: uint256 = 0\n        nextAmount, amountA, amountB, txUsdValue = extcall Wallet(_userWallet).addLiquidity(convert(instruction.legoId, uint256), instruction.target, instruction.asset, instruction.asset2, nextAmount, instruction.amount2, instruction.minOut1, instruction.minOut2, convert(instruction.auxData, uint256), instruction.extraData)\n        return nextAmount\n\n    # remove liquidity\n    elif instruction.action == 31:\n        # Extract lpToken address from auxData (lower 160 bits)\n        lpToken: address = convert(convert(instruction.auxData, uint256) & convert(max_value(uint160), uint256), address)\n        amountB: uint256 = 0\n        lpAmountBurned: uint256 = 0\n        # Params: legoId, pool (target), tokenA, tokenB, lpToken, lpAmount, minAmountA (minOut1), minAmountB (minOut2)\n        # NOTE: Returns (amountA, amountB, lpBurned) - we pass forward amountA only\n        nextAmount, amountB, lpAmountBurned, txUsdValue = extcall Wallet(_userWallet).removeLiquidity(convert(instruction.legoId, uint256), instruction.target, instruction.asset, instruction.asset2, lpToken, nextAmount, instruction.minOut1, instruction.minOut2, instruction.extraData)\n        return nextAmount\n\n    # add liquidity concentrated\n    elif instruction.action == 32:\n        # Extract pool address (upper 160 bits) and nftId (lower 96 bits) from auxData\n        pool: address = convert(convert(instruction.auxData, uint256) >> 96, address)\n        nftId: uint256 = convert(instruction.auxData, uint256) & convert(max_value(uint96), uint256)\n        # Params: legoId, nftAddr (target), nftId, pool, tokenA, tokenB, amountA, amountB (amount2)\n        extcall Wallet(_userWallet).addLiquidityConcentrated(convert(instruction.legoId, uint256), instruction.target, nftId, pool, instruction.asset, instruction.asset2, nextAmount, instruction.amount2, instruction.tickLower, instruction.tickUpper, instruction.minOut1, instruction.minOut2, instruction.extraData)\n        return 0\n\n    # remove liquidity concentrated\n    elif instruction.action == 33:\n        # Extract pool address (upper 160 bits) and nftId (lower 96 bits) from auxData\n        pool: address = convert(convert(instruction.auxData, uint256) >> 96, address)\n        nftId: uint256 = convert(instruction.auxData, uint256) & convert(max_value(uint96), uint256)\n        amountA: uint256 = 0\n        amountB: uint256 = 0\n        # Params: legoId, nftAddr (target), nftId, pool, tokenA, tokenB, liqToRemove, minAmountA (minOut1), minAmountB (minOut2)\n        # NOTE: Returns (amountA, amountB, liquidity) - we pass forward amountA only\n        nextAmount, amountA, amountB, txUsdValue = extcall Wallet(_userWallet).removeLiquidityConcentrated(convert(instruction.legoId, uint256), instruction.target, nftId, pool, instruction.asset, instruction.asset2, nextAmount, instruction.minOut1, instruction.minOut2, instruction.extraData)\n        return nextAmount\n\n    else:\n        raise \"Invalid action\"\n\n\n##################\n# Authentication #\n##################\n\n\n@internal\ndef _authenticateAccess(_messageHash: bytes32, _sig: Signature):\n    owner: address = ownership.owner\n    if msg.sender != owner:\n        # check expiration first to prevent DoS\n        assert _sig.expiration >= block.timestamp # dev: signature expired\n\n        # check nonce is valid\n        assert _sig.nonce == self.currentNonce # dev: invalid nonce\n\n        # verify signature and check it's from owner\n        signer: address = self._verify(_messageHash, _sig)\n        assert signer == owner # dev: invalid signer\n\n        # increment nonce for next use\n        self.currentNonce += 1\n\n\n@view\n@internal\ndef _verify(_messageHash: bytes32, _sig: Signature) -> address:\n    # extract signature components\n    r: bytes32 = convert(slice(_sig.signature, 0, 32), bytes32)\n    s: bytes32 = convert(slice(_sig.signature, 32, 32), bytes32)\n    v: uint8 = convert(slice(_sig.signature, 64, 1), uint8)\n\n    # validate v parameter (27 or 28)\n    if v < 27:\n        v = v + 27\n    assert v == 27 or v == 28 # dev: invalid v parameter\n\n    # prevent signature malleability by ensuring s is in lower half of curve order\n    s_uint: uint256 = convert(s, uint256)\n    assert s_uint != 0 # dev: invalid s value (zero)\n    assert s_uint <= convert(0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, uint256) # dev: invalid s value\n\n    # create digest with EIP-712\n    digest: bytes32 = keccak256(concat(SIG_PREFIX, self._domainSeparator(), _messageHash))\n\n    # call ecrecover precompile\n    result: Bytes[32] = raw_call(\n        ECRECOVER_PRECOMPILE,\n        abi_encode(digest, v, r, s),\n        max_outsize=32,\n        is_static_call=True\n    )\n\n    # return recovered address or empty if failed\n    if len(result) != 32:\n        return empty(address)\n\n    recovered: address = abi_decode(result, address)\n    assert recovered != empty(address) # dev: signature recovery failed\n    return recovered\n\n\n@view\n@internal\ndef _domainSeparator() -> bytes32:\n    return keccak256(abi_encode(\n        keccak256('EIP712Domain(string name,uint256 chainId,address verifyingContract)'),\n        keccak256('UnderscoreAgent'),\n        chain.id,\n        self\n    ))\n\n\n@external\ndef incrementNonce():\n    assert msg.sender == ownership.owner # dev: no perms\n    oldNonce: uint256 = self.currentNonce\n    self.currentNonce += 1\n    log NonceIncremented(oldNonce=oldNonce, newNonce=self.currentNonce)\n\n\n@view\n@external\ndef getNonce() -> uint256:\n    return self.currentNonce\n",
            "sha256sum": "0576370247035426c484a53d1b202f1a13ad2536a17e6fba5ec91d36ace23a26"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/core/agent/AgentWrapper.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.3+commit.bff19ea2",
        "integrity": "449a716408d4d624532fd015e47935b3bb52b699a43a487d39f9e64c02c91964"
      },
      "args": "",
      "file": "contracts/core/agent/AgentWrapper.vy"
    },
    "DefaultsBase": {
      "address": "0x33DF7433cAa93277F06561b8A3ceE1Fa324FbDe6",
      "abi": [
        {
          "stateMutability": "view",
          "type": "function",
          "name": "userWalletConfig",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "walletTemplate",
                  "type": "address"
                },
                {
                  "name": "configTemplate",
                  "type": "address"
                },
                {
                  "name": "trialAsset",
                  "type": "address"
                },
                {
                  "name": "trialAmount",
                  "type": "uint256"
                },
                {
                  "name": "numUserWalletsAllowed",
                  "type": "uint256"
                },
                {
                  "name": "enforceCreatorWhitelist",
                  "type": "bool"
                },
                {
                  "name": "minKeyActionTimeLock",
                  "type": "uint256"
                },
                {
                  "name": "maxKeyActionTimeLock",
                  "type": "uint256"
                },
                {
                  "name": "defaultStaleBlocks",
                  "type": "uint256"
                },
                {
                  "name": "depositRewardsAsset",
                  "type": "address"
                },
                {
                  "name": "txFees",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "swapFee",
                      "type": "uint256"
                    },
                    {
                      "name": "stableSwapFee",
                      "type": "uint256"
                    },
                    {
                      "name": "rewardsFee",
                      "type": "uint256"
                    }
                  ]
                },
                {
                  "name": "ambassadorRevShare",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "swapRatio",
                      "type": "uint256"
                    },
                    {
                      "name": "rewardsRatio",
                      "type": "uint256"
                    },
                    {
                      "name": "yieldRatio",
                      "type": "uint256"
                    }
                  ]
                },
                {
                  "name": "defaultYieldMaxIncrease",
                  "type": "uint256"
                },
                {
                  "name": "defaultYieldPerformanceFee",
                  "type": "uint256"
                },
                {
                  "name": "defaultYieldAmbassadorBonusRatio",
                  "type": "uint256"
                },
                {
                  "name": "defaultYieldBonusRatio",
                  "type": "uint256"
                },
                {
                  "name": "defaultYieldAltBonusAsset",
                  "type": "address"
                },
                {
                  "name": "lootClaimCoolOffPeriod",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "agentConfig",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "agentTemplate",
                  "type": "address"
                },
                {
                  "name": "numAgentsAllowed",
                  "type": "uint256"
                },
                {
                  "name": "enforceCreatorWhitelist",
                  "type": "bool"
                },
                {
                  "name": "startingAgent",
                  "type": "address"
                },
                {
                  "name": "startingAgentActivationLength",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "managerConfig",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "managerPeriod",
                  "type": "uint256"
                },
                {
                  "name": "managerActivationLength",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "payeeConfig",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "payeePeriod",
                  "type": "uint256"
                },
                {
                  "name": "payeeActivationLength",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "chequeConfig",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "maxNumActiveCheques",
                  "type": "uint256"
                },
                {
                  "name": "instantUsdThreshold",
                  "type": "uint256"
                },
                {
                  "name": "periodLength",
                  "type": "uint256"
                },
                {
                  "name": "expensiveDelayBlocks",
                  "type": "uint256"
                },
                {
                  "name": "defaultExpiryBlocks",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_walletTemplate",
              "type": "address"
            },
            {
              "name": "_configTemplate",
              "type": "address"
            },
            {
              "name": "_agentTemplate",
              "type": "address"
            },
            {
              "name": "_startingAgent",
              "type": "address"
            },
            {
              "name": "_trialAsset",
              "type": "address"
            },
            {
              "name": "_trialAmount",
              "type": "uint256"
            },
            {
              "name": "_rewardsAsset",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "interfaces/ConfigStructs.vyi": {
            "content": "# @version 0.4.3\n\nstruct UserWalletConfig:\n    walletTemplate: address\n    configTemplate: address\n    trialAsset: address\n    trialAmount: uint256\n    numUserWalletsAllowed: uint256\n    enforceCreatorWhitelist: bool\n    minKeyActionTimeLock: uint256\n    maxKeyActionTimeLock: uint256\n    defaultStaleBlocks: uint256\n    depositRewardsAsset: address\n    txFees: TxFees\n    ambassadorRevShare: AmbassadorRevShare\n    defaultYieldMaxIncrease: uint256\n    defaultYieldPerformanceFee: uint256\n    defaultYieldAmbassadorBonusRatio: uint256\n    defaultYieldBonusRatio: uint256\n    defaultYieldAltBonusAsset: address\n    lootClaimCoolOffPeriod: uint256\n\nstruct AssetConfig:\n    legoId: uint256\n    decimals: uint256\n    staleBlocks: uint256\n    txFees: TxFees\n    ambassadorRevShare: AmbassadorRevShare\n    yieldConfig: YieldConfig\n\nstruct TxFees:\n    swapFee: uint256\n    stableSwapFee: uint256\n    rewardsFee: uint256\n\nstruct AmbassadorRevShare:\n    swapRatio: uint256\n    rewardsRatio: uint256\n    yieldRatio: uint256\n\nstruct YieldConfig:\n    isYieldAsset: bool\n    isRebasing: bool\n    underlyingAsset: address\n    maxYieldIncrease: uint256\n    performanceFee: uint256\n    ambassadorBonusRatio: uint256\n    bonusRatio: uint256\n    altBonusAsset: address\n\nstruct AgentConfig:\n    agentTemplate: address\n    numAgentsAllowed: uint256\n    enforceCreatorWhitelist: bool\n    startingAgent: address\n    startingAgentActivationLength: uint256\n\nstruct ManagerConfig:\n    managerPeriod: uint256\n    managerActivationLength: uint256\n\nstruct PayeeConfig:\n    payeePeriod: uint256\n    payeeActivationLength: uint256\n\nstruct ChequeConfig:\n    maxNumActiveCheques: uint256\n    instantUsdThreshold: uint256\n    periodLength: uint256\n    expensiveDelayBlocks: uint256\n    defaultExpiryBlocks: uint256",
            "sha256sum": "5398a73269f73f958f8d644802e65a65f335cf33c46938d0e05eabad7bc8d45f"
          },
          "interfaces/Defaults.vyi": {
            "content": "# @version 0.4.3\n\nimport interfaces.ConfigStructs as cs\n\n\n@view\n@external\ndef userWalletConfig() -> cs.UserWalletConfig:\n    ...\n\n\n@view\n@external\ndef agentConfig() -> cs.AgentConfig:\n    ...\n\n\n@view\n@external\ndef managerConfig() -> cs.ManagerConfig:\n    ...\n\n\n@view\n@external\ndef payeeConfig() -> cs.PayeeConfig:\n    ...\n\n\n\n@view\n@external\ndef chequeConfig() -> cs.ChequeConfig:\n    ...",
            "sha256sum": "af8933730bc1e37f081fc6e575d68b86b6aba7307f7370677e68047fefcb7b23"
          },
          "contracts/config/DefaultsBase.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nimplements: Defaults\nfrom interfaces import Defaults\nimport interfaces.ConfigStructs as cs\n\nEIGHTEEN_DECIMALS: constant(uint256) = 10 ** 18\n\n# blocks\nDAY_IN_BLOCKS: constant(uint256) = 43_200\nWEEK_IN_BLOCKS: constant(uint256) = 7 * DAY_IN_BLOCKS\nMONTH_IN_BLOCKS: constant(uint256) = 30 * DAY_IN_BLOCKS\nYEAR_IN_BLOCKS: constant(uint256) = 365 * DAY_IN_BLOCKS\n\n# user wallet templates\nUSER_WALLET_TEMPLATE: immutable(address)\nUSER_WALLET_CONFIG_TEMPLATE: immutable(address)\n\n# agent template\nAGENT_TEMPLATE: immutable(address)\nSTARTING_AGENT: immutable(address)\n\n# trial funds and rewards\nTRIAL_ASSET: immutable(address)\nTRIAL_AMOUNT: immutable(uint256)\nREWARDS_ASSET: immutable(address)\n\n\n@deploy\ndef __init__(\n    _walletTemplate: address,\n    _configTemplate: address,\n    _agentTemplate: address,\n    _startingAgent: address,\n    _trialAsset: address,\n    _trialAmount: uint256,\n    _rewardsAsset: address,\n):\n    USER_WALLET_TEMPLATE = _walletTemplate\n    USER_WALLET_CONFIG_TEMPLATE = _configTemplate\n    AGENT_TEMPLATE = _agentTemplate\n    STARTING_AGENT = _startingAgent\n\n    TRIAL_ASSET = _trialAsset\n    TRIAL_AMOUNT = _trialAmount\n    REWARDS_ASSET = _rewardsAsset\n\n\n# general configs\n\n\n@view\n@external\ndef userWalletConfig() -> cs.UserWalletConfig:\n    return cs.UserWalletConfig(\n        walletTemplate = USER_WALLET_TEMPLATE,\n        configTemplate = USER_WALLET_CONFIG_TEMPLATE,\n        trialAsset = TRIAL_ASSET,\n        trialAmount = TRIAL_AMOUNT,\n        numUserWalletsAllowed = 25,\n        enforceCreatorWhitelist = True,\n        minKeyActionTimeLock = DAY_IN_BLOCKS // 2,\n        maxKeyActionTimeLock = 7 * DAY_IN_BLOCKS,\n        defaultStaleBlocks = DAY_IN_BLOCKS // 12,\n        depositRewardsAsset = REWARDS_ASSET,\n        txFees = cs.TxFees(\n            swapFee = 0,\n            stableSwapFee = 0,\n            rewardsFee = 0,\n        ),\n        ambassadorRevShare = cs.AmbassadorRevShare(\n            swapRatio = 0,\n            rewardsRatio = 0,\n            yieldRatio = 0,\n        ),\n        defaultYieldMaxIncrease = 5_00,\n        defaultYieldPerformanceFee = 20_00,\n        defaultYieldAmbassadorBonusRatio = 0,\n        defaultYieldBonusRatio = 0,\n        defaultYieldAltBonusAsset = empty(address),\n        lootClaimCoolOffPeriod = 0,\n    )\n\n\n@view\n@external\ndef agentConfig() -> cs.AgentConfig:\n    return cs.AgentConfig(\n        agentTemplate = AGENT_TEMPLATE,\n        numAgentsAllowed = 25,\n        enforceCreatorWhitelist = False,\n        startingAgent = STARTING_AGENT,\n        startingAgentActivationLength = 2 * YEAR_IN_BLOCKS,\n    )\n\n\n@view\n@external\ndef managerConfig() -> cs.ManagerConfig:\n    return cs.ManagerConfig(\n        managerPeriod = DAY_IN_BLOCKS,\n        managerActivationLength = MONTH_IN_BLOCKS,\n    )\n\n\n@view\n@external\ndef payeeConfig() -> cs.PayeeConfig:\n    return cs.PayeeConfig(\n        payeePeriod = MONTH_IN_BLOCKS,\n        payeeActivationLength = YEAR_IN_BLOCKS,\n    )\n\n\n@view\n@external\ndef chequeConfig() -> cs.ChequeConfig:\n    return cs.ChequeConfig(\n        maxNumActiveCheques = 3,\n        instantUsdThreshold = 100 * EIGHTEEN_DECIMALS,\n        periodLength = DAY_IN_BLOCKS,\n        expensiveDelayBlocks = DAY_IN_BLOCKS,\n        defaultExpiryBlocks = 2 * DAY_IN_BLOCKS,\n    )",
            "sha256sum": "30418a5fe0a0bcf088b4a139fd1a27e4ec342b8d3a0789b5fff5c49325eb7a48"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/config/DefaultsBase.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.3+commit.bff19ea2",
        "integrity": "8d98afbc2c66318288e4bbed252b2061dbe7cd32820ca77f4be055a96ebabbc3"
      },
      "args": "0000000000000000000000005ab75ef37a30736f38f637a9129348ad327efd080000000000000000000000000e7064202c4f906adc4d9f6d3c92470b62f624f100000000000000000000000055eea103aba26fa85fb1359e2d2e1961d1b462180000000000000000000000000000000000000000000000000000000000000000000000000000000000000000833589fcd6edb6e08f4c7c32d4f71b54bda0291300000000000000000000000000000000000000000000000000000000009896800000000000000000000000002a0a59d6b975828e781ecac125dba40d7ee5ddc0",
      "file": "contracts/config/DefaultsBase.vy"
    },
    "UndyHq": {
      "address": "0x44Cf3c4f000DFD76a35d03298049D37bE688D6F9",
      "abi": [
        {
          "name": "HqConfigChangeInitiated",
          "inputs": [
            {
              "name": "regId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "canMintUndy",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "canSetTokenBlacklist",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "HqConfigChangeConfirmed",
          "inputs": [
            {
              "name": "regId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "canMintUndy",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "canSetTokenBlacklist",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "HqConfigChangeCancelled",
          "inputs": [
            {
              "name": "regId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "canMintUndy",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "canSetTokenBlacklist",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UndyHqFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "balance",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UndyTokenSet",
          "inputs": [
            {
              "name": "token",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "MintingEnabled",
          "inputs": [
            {
              "name": "isEnabled",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeTimeLockModified",
          "inputs": [
            {
              "name": "prevTimeLock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "newTimeLock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "RegistryTimeLockModified",
          "inputs": [
            {
              "name": "newTimeLock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "prevTimeLock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeStarted",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeConfirmed",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeCancelled",
          "inputs": [
            {
              "name": "cancelledGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovRelinquished",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UndyHqSetupFinished",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "timeLock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "NewAddressPending",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "NewAddressConfirmed",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "regId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "NewAddressCancelled",
          "inputs": [
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddressUpdatePending",
          "inputs": [
            {
              "name": "regId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "newAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "prevAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "version",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddressUpdateConfirmed",
          "inputs": [
            {
              "name": "regId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "newAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "prevAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "version",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddressUpdateCancelled",
          "inputs": [
            {
              "name": "regId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "newAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "prevAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddressDisablePending",
          "inputs": [
            {
              "name": "regId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "version",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddressDisableConfirmed",
          "inputs": [
            {
              "name": "regId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "version",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddressDisableCancelled",
          "inputs": [
            {
              "name": "regId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUndyHqFromGov",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canGovern",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getGovernors",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPendingGovChange",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "startGovernanceChange",
          "inputs": [
            {
              "name": "_newGov",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "relinquishGov",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setGovTimeLock",
          "inputs": [
            {
              "name": "_numBlocks",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidGovTimeLock",
          "inputs": [
            {
              "name": "_newTimeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "minGovChangeTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "maxGovChangeTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "finishUndyHqSetup",
          "inputs": [
            {
              "name": "_newGov",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "finishUndyHqSetup",
          "inputs": [
            {
              "name": "_newGov",
              "type": "address"
            },
            {
              "name": "_timeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "governance",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingGov",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "newGov",
                  "type": "address"
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numGovChanges",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "govChangeTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRegistryDescription",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "string"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidNewAddress",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidAddressUpdate",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            },
            {
              "name": "_newAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidAddressDisable",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setRegistryTimeLock",
          "inputs": [
            {
              "name": "_numBlocks",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidRegistryTimeLock",
          "inputs": [
            {
              "name": "_numBlocks",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setRegistryTimeLockAfterSetup",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setRegistryTimeLockAfterSetup",
          "inputs": [
            {
              "name": "_numBlocks",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "minRegistryTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "maxRegistryTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidAddr",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidRegId",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRegId",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddr",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddrInfo",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "addr",
                  "type": "address"
                },
                {
                  "name": "version",
                  "type": "uint256"
                },
                {
                  "name": "lastModified",
                  "type": "uint256"
                },
                {
                  "name": "description",
                  "type": "string"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddrDescription",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "string"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getNumAddrs",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLastAddr",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLastRegId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "registryChangeTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "addrInfo",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "addr",
                  "type": "address"
                },
                {
                  "name": "version",
                  "type": "uint256"
                },
                {
                  "name": "lastModified",
                  "type": "uint256"
                },
                {
                  "name": "description",
                  "type": "string"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "addrToRegId",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAddrs",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingNewAddr",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "description",
                  "type": "string"
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingAddrUpdate",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "newAddr",
                  "type": "address"
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingAddrDisable",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "startAddNewAddressToRegistry",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            },
            {
              "name": "_description",
              "type": "string"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmNewAddressToRegistry",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelNewAddressToRegistry",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "startAddressUpdateToRegistry",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            },
            {
              "name": "_newAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmAddressUpdateToRegistry",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelAddressUpdateToRegistry",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "startAddressDisableInRegistry",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmAddressDisableInRegistry",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelAddressDisableInRegistry",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPendingHqConfigChange",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "initiateHqConfigChange",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            },
            {
              "name": "_canMintUndy",
              "type": "bool"
            },
            {
              "name": "_canSetTokenBlacklist",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmHqConfigChange",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelHqConfigChange",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidHqConfig",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            },
            {
              "name": "_canMintUndy",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setUndyToken",
          "inputs": [
            {
              "name": "_token",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canMintUndy",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setMintingEnabled",
          "inputs": [
            {
              "name": "_shouldEnable",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canSetTokenBlacklist",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFundsMany",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_assets",
              "type": "address[]"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "undyToken",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "mintEnabled",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hqConfig",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "description",
                  "type": "string"
                },
                {
                  "name": "canMintUndy",
                  "type": "bool"
                },
                {
                  "name": "canSetTokenBlacklist",
                  "type": "bool"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingHqConfig",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "newHqConfig",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "description",
                      "type": "string"
                    },
                    {
                      "name": "canMintUndy",
                      "type": "bool"
                    },
                    {
                      "name": "canSetTokenBlacklist",
                      "type": "bool"
                    }
                  ]
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_initialGov",
              "type": "address"
            },
            {
              "name": "_minGovTimeLock",
              "type": "uint256"
            },
            {
              "name": "_maxGovTimeLock",
              "type": "uint256"
            },
            {
              "name": "_minRegistryTimeLock",
              "type": "uint256"
            },
            {
              "name": "_maxRegistryTimeLock",
              "type": "uint256"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/modules/LocalGov.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\ninterface UndyHq:\n    def minGovChangeTimeLock() -> uint256: view\n    def maxGovChangeTimeLock() -> uint256: view\n    def governance() -> address: view\n\nstruct PendingGovernance:\n    newGov: address\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeStarted:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    confirmBlock: uint256\n\nevent GovChangeConfirmed:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeCancelled:\n    cancelledGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovRelinquished:\n    prevGov: indexed(address)\n\nevent GovChangeTimeLockModified:\n    prevTimeLock: uint256\n    newTimeLock: uint256\n\nevent UndyHqSetupFinished:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    timeLock: uint256\n\n# governance\ngovernance: public(address)\npendingGov: public(PendingGovernance)\nnumGovChanges: public(uint256)\n\n# time lock\ngovChangeTimeLock: public(uint256)\n\n# config\nUNDY_HQ_FOR_GOV: immutable(address)\nMIN_GOV_TIME_LOCK: immutable(uint256)\nMAX_GOV_TIME_LOCK: immutable(uint256)\n\n\n@deploy\ndef __init__(\n    _undyHq: address,\n    _initialGov: address,\n    _minTimeLock: uint256,\n    _maxTimeLock: uint256,\n    _initialTimeLock: uint256,\n):\n    UNDY_HQ_FOR_GOV = _undyHq\n    self.governance = _initialGov\n\n    # undy hq\n    if _undyHq == empty(address):\n        assert _initialGov != empty(address) # dev: undy hq must have gov\n\n    # local gov (department, other smart contracts)\n    else:\n        hqGov: address = staticcall UndyHq(_undyHq).governance()\n        assert hqGov != empty(address) # dev: undy hq must have gov\n        assert _initialGov != hqGov # dev: undy hq cannot set same gov\n\n    # time locks\n    minTimeLock: uint256 = _minTimeLock\n    maxTimeLock: uint256 = _maxTimeLock\n    if minTimeLock == 0 or maxTimeLock == 0:\n        assert _undyHq != empty(address) # dev: need undy hq if no time locks\n        minTimeLock = staticcall UndyHq(_undyHq).minGovChangeTimeLock()\n        maxTimeLock = staticcall UndyHq(_undyHq).maxGovChangeTimeLock()\n\n    # set min and max time locks\n    assert minTimeLock < maxTimeLock # dev: invalid time lock\n    assert minTimeLock != 0 and maxTimeLock != max_value(uint256) # dev: invalid time lock\n    MIN_GOV_TIME_LOCK = minTimeLock\n    MAX_GOV_TIME_LOCK = maxTimeLock\n\n    # this contract is top level governance from Undy HQ -- not setting initial time lock during setup\n    if _undyHq == empty(address):\n        return\n\n    # set initial time lock (for local gov)\n    initialTimeLock: uint256 = max(minTimeLock, _initialTimeLock)\n    assert self._setGovTimeLock(initialTimeLock) # dev: invalid time lock\n\n\n@view\n@external\ndef getUndyHqFromGov() -> address:\n    return self._getUndyHqFromGov()\n\n\n@view\n@internal\ndef _getUndyHqFromGov() -> address:\n    return UNDY_HQ_FOR_GOV\n\n\n##############\n# Gov Access #\n##############\n\n\n@view\n@external\ndef canGovern(_addr: address) -> bool:\n    return self._canGovern(_addr)\n\n\n@view\n@internal\ndef _canGovern(_addr: address) -> bool:\n    if _addr == empty(address):\n        return False\n    return _addr in self._getGovernors()\n\n\n@view\n@external\ndef getGovernors() -> DynArray[address, 2]:\n    return self._getGovernors()\n\n\n@view\n@internal\ndef _getGovernors() -> DynArray[address, 2]:\n    governors: DynArray[address, 2] = []\n\n    # local governance\n    localGov: address = self.governance\n    if localGov != empty(address):\n        governors.append(localGov)\n\n    # undy hq governance\n    undyHq: address = UNDY_HQ_FOR_GOV\n    if undyHq == empty(address):\n        return governors\n\n    hqGov: address = staticcall UndyHq(undyHq).governance()\n    if hqGov != empty(address):\n        governors.append(hqGov)\n\n    return governors\n\n\n######################\n# Governance Changes #\n######################\n\n\n@view\n@external\ndef hasPendingGovChange() -> bool:\n    return self.pendingGov.confirmBlock != 0\n\n\n@view\n@internal\ndef _isUndyHq() -> bool:\n    return UNDY_HQ_FOR_GOV == empty(address)\n\n\n# start gov change\n\n\n@external\ndef startGovernanceChange(_newGov: address):\n    governors: DynArray[address, 2] = self._getGovernors()\n    assert msg.sender in governors # dev: no perms\n\n    # validation\n    if _newGov != empty(address):\n        assert _newGov not in governors # dev: invalid _newGov\n        assert _newGov.is_contract # dev: _newGov must be a contract\n    else:\n        assert not self._isUndyHq() # dev: undy hq cannot set 0x0\n\n    confirmBlock: uint256 = block.number + self.govChangeTimeLock\n    self.pendingGov = PendingGovernance(\n        newGov= _newGov,\n        initiatedBlock= block.number,\n        confirmBlock= confirmBlock,\n    )\n    log GovChangeStarted(prevGov=self.governance, newGov=_newGov, confirmBlock=confirmBlock)\n\n\n# confirm gov change\n\n\n@external\ndef confirmGovernanceChange():\n    data: PendingGovernance = self.pendingGov\n    assert data.confirmBlock != 0 and block.number >= data.confirmBlock # dev: time lock not reached\n\n    # check permissions\n    if data.newGov != empty(address):\n        assert msg.sender == data.newGov # dev: only new gov can confirm\n    else:\n        assert self._canGovern(msg.sender) # dev: no perms\n        assert not self._isUndyHq() # dev: undy hq cannot set 0x0\n\n    # set new governance\n    prevGov: address = self.governance\n    self.governance = data.newGov\n    self.numGovChanges += 1\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeConfirmed(prevGov=prevGov, newGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n# cancel gov change\n\n\n@external\ndef cancelGovernanceChange():\n    assert self._canGovern(msg.sender) # dev: no perms\n    data: PendingGovernance = self.pendingGov\n    assert data.confirmBlock != 0 # dev: no pending change\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeCancelled(cancelledGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n# relinquish gov (only for local gov)\n\n\n@external\ndef relinquishGov():\n    assert msg.sender == self.governance # dev: no perms\n    assert not self._isUndyHq() # dev: undy hq cannot relinquish gov\n\n    self.governance = empty(address)\n    self.numGovChanges += 1\n    log GovRelinquished(prevGov=msg.sender)\n\n\n####################\n# Time Lock Config #\n####################\n\n\n# set time lock\n\n\n@external\ndef setGovTimeLock(_numBlocks: uint256) -> bool:\n    assert self._canGovern(msg.sender) # dev: no perms\n    return self._setGovTimeLock(_numBlocks)\n\n\n@internal\ndef _setGovTimeLock(_numBlocks: uint256) -> bool:\n    prevTimeLock: uint256 = self.govChangeTimeLock\n    assert self._isValidGovTimeLock(_numBlocks, prevTimeLock) # dev: invalid time lock\n    self.govChangeTimeLock = _numBlocks\n    log GovChangeTimeLockModified(prevTimeLock=prevTimeLock, newTimeLock=_numBlocks)\n    return True\n\n\n# validation\n\n\n@view\n@external\ndef isValidGovTimeLock(_newTimeLock: uint256) -> bool:\n    return self._isValidGovTimeLock(_newTimeLock, self.govChangeTimeLock)\n\n\n@view\n@internal\ndef _isValidGovTimeLock(_newTimeLock: uint256, _prevTimeLock: uint256) -> bool:\n    if _newTimeLock == _prevTimeLock:\n        return False # no change\n    if self.pendingGov.confirmBlock != 0:\n        return False # cannot change while pending gov change\n    return _newTimeLock >= MIN_GOV_TIME_LOCK and _newTimeLock <= MAX_GOV_TIME_LOCK\n\n\n# utils\n\n\n@view\n@external\ndef minGovChangeTimeLock() -> uint256:\n    return MIN_GOV_TIME_LOCK\n\n\n@view\n@external\ndef maxGovChangeTimeLock() -> uint256:\n    return MAX_GOV_TIME_LOCK\n\n\n#################\n# Undy Hq Setup #\n#################\n\n\n@external\ndef finishUndyHqSetup(_newGov: address, _timeLock: uint256 = 0) -> bool:\n    assert self._isUndyHq() # dev: only undy hq\n    assert msg.sender == self.governance # dev: no perms\n    assert self.numGovChanges == 0 # dev: already changed gov\n\n    # validation\n    assert _newGov != empty(address) and _newGov.is_contract # dev: invalid _newGov\n    prevGov: address = self.governance\n\n    # set new gov\n    self.governance = _newGov\n    self.numGovChanges += 1\n\n    # set time lock\n    timeLock: uint256 = _timeLock\n    if timeLock == 0:\n        timeLock = MIN_GOV_TIME_LOCK\n    assert self._setGovTimeLock(timeLock) # dev: invalid time lock\n\n    log UndyHqSetupFinished(prevGov=prevGov, newGov=_newGov, timeLock=timeLock)\n    return True",
            "sha256sum": "c41aa3e0d0d96b512171813377ea277e2c7da690c3cd9b4662733b3f11f705b0"
          },
          "contracts/modules/AddressRegistry.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nuses: gov\nimport contracts.modules.LocalGov as gov\n\nstruct AddressInfo:\n    addr: address\n    version: uint256\n    lastModified: uint256\n    description: String[64]\n\nstruct PendingNewAddress:\n    description: String[64]\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nstruct PendingAddressUpdate:\n    newAddr: address\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nstruct PendingAddressDisable:\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent NewAddressPending:\n    addr: indexed(address)\n    description: String[64]\n    confirmBlock: uint256\n    registry: String[28]\n\nevent NewAddressConfirmed:\n    addr: indexed(address)\n    regId: uint256\n    description: String[64]\n    registry: String[28]\n\nevent NewAddressCancelled:\n    description: String[64]\n    addr: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n    registry: String[28]\n\nevent AddressUpdatePending:\n    regId: uint256\n    description: String[64]\n    newAddr: indexed(address)\n    prevAddr: indexed(address)\n    version: uint256\n    confirmBlock: uint256\n    registry: String[28]\n\nevent AddressUpdateConfirmed:\n    regId: uint256\n    description: String[64]\n    newAddr: indexed(address)\n    prevAddr: indexed(address)\n    version: uint256\n    registry: String[28]\n\nevent AddressUpdateCancelled:\n    regId: uint256\n    description: String[64]\n    newAddr: indexed(address)\n    prevAddr: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n    registry: String[28]\n\nevent AddressDisablePending:\n    regId: uint256\n    description: String[64]\n    addr: indexed(address)\n    version: uint256\n    confirmBlock: uint256\n    registry: String[28]\n\nevent AddressDisableConfirmed:\n    regId: uint256\n    description: String[64]\n    addr: indexed(address)\n    version: uint256\n    registry: String[28]\n\nevent AddressDisableCancelled:\n    regId: uint256\n    description: String[64]\n    addr: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n    registry: String[28]\n\nevent RegistryTimeLockModified:\n    newTimeLock: uint256\n    prevTimeLock: uint256\n    registry: String[28]\n\n# time lock\nregistryChangeTimeLock: public(uint256)\n\n# core data (address registry)\naddrInfo: public(HashMap[uint256, AddressInfo]) # regId -> address info\naddrToRegId: public(HashMap[address, uint256]) # addr -> regId\nnumAddrs: public(uint256) # number of addrs in registry\n\n# pending changes\npendingNewAddr: public(HashMap[address, PendingNewAddress]) # addr -> pending new addr\npendingAddrUpdate: public(HashMap[uint256, PendingAddressUpdate]) # regId -> pending addr update\npendingAddrDisable: public(HashMap[uint256, PendingAddressDisable]) # regId -> pending addr disable\n\nREGISTRY_STR: immutable(String[28])\nMIN_REG_TIME_LOCK: immutable(uint256)\nMAX_REG_TIME_LOCK: immutable(uint256)\n\n\n@deploy\ndef __init__(\n    _minTimeLock: uint256,\n    _maxTimeLock: uint256,\n    _initialTimeLock: uint256,\n    _registryStr: String[28],\n):\n    REGISTRY_STR = _registryStr\n\n    assert _minTimeLock < _maxTimeLock # dev: invalid time lock\n    assert _minTimeLock != 0 and _maxTimeLock != max_value(uint256) # dev: invalid time lock\n    MIN_REG_TIME_LOCK = _minTimeLock\n    MAX_REG_TIME_LOCK = _maxTimeLock\n\n    # set initial time lock -- this may be zero during inital setup of registry\n    if _initialTimeLock != 0:\n        assert self._setRegistryTimeLock(_initialTimeLock) # dev: invalid time lock\n\n    # start at 1 index\n    self.numAddrs = 1\n\n\n@view\n@external\ndef getRegistryDescription() -> String[28]:\n    return REGISTRY_STR\n\n\n###############\n# New Address #\n###############\n\n\n# register new address\n\n\n@internal\ndef _startAddNewAddressToRegistry(_addr: address, _description: String[64]) -> bool:\n    assert self._isValidNewAddress(_addr) # dev: invalid addy\n\n    confirmBlock: uint256 = block.number + self.registryChangeTimeLock\n    self.pendingNewAddr[_addr] = PendingNewAddress(\n        description=_description,\n        initiatedBlock=block.number,\n        confirmBlock=confirmBlock,\n    )\n\n    log NewAddressPending(addr=_addr, description=_description, confirmBlock=confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n# confirm new address\n\n\n@internal\ndef _confirmNewAddressToRegistry(_addr: address) -> uint256:\n    data: PendingNewAddress = self.pendingNewAddr[_addr]\n    assert data.confirmBlock != 0 and block.number >= data.confirmBlock # dev: time lock not reached\n\n    if not self._isValidNewAddress(_addr):\n        self.pendingNewAddr[_addr] = empty(PendingNewAddress) # clear pending\n        return 0\n\n    # register new addy\n    regId: uint256 = self.numAddrs\n    self.addrToRegId[_addr] = regId\n    self.numAddrs = regId + 1\n    self.addrInfo[regId] = AddressInfo(\n        addr=_addr,\n        version=1,\n        lastModified=block.timestamp,\n        description=data.description,\n    )\n\n    # clear pending\n    self.pendingNewAddr[_addr] = empty(PendingNewAddress)\n\n    log NewAddressConfirmed(addr=_addr, regId=regId, description=data.description, registry=REGISTRY_STR)\n    return regId\n\n\n# cancel new address\n\n\n@internal\ndef _cancelNewAddressToRegistry(_addr: address) -> bool:\n    data: PendingNewAddress = self.pendingNewAddr[_addr]\n    assert data.confirmBlock != 0 # dev: no pending\n\n    self.pendingNewAddr[_addr] = empty(PendingNewAddress)\n    log NewAddressCancelled(description=data.description, addr=_addr, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n# validation\n\n\n@view\n@external\ndef isValidNewAddress(_addr: address) -> bool:\n    return self._isValidNewAddress(_addr)\n\n\n@view\n@internal\ndef _isValidNewAddress(_addr: address) -> bool:\n    if _addr == empty(address) or not _addr.is_contract:\n        return False\n    return self.addrToRegId[_addr] == 0\n\n\n###################\n# Address Updates #\n###################\n\n\n# update address\n\n\n@internal\ndef _startAddressUpdateToRegistry(_regId: uint256, _newAddr: address) -> bool:\n    data: AddressInfo = self.addrInfo[_regId]\n    assert self._isValidAddressUpdate(_regId, _newAddr, data.addr) # dev: invalid update\n\n    # set pending\n    confirmBlock: uint256 = block.number + self.registryChangeTimeLock\n    self.pendingAddrUpdate[_regId] = PendingAddressUpdate(\n        newAddr=_newAddr,\n        initiatedBlock=block.number,\n        confirmBlock=confirmBlock,\n    )\n\n    log AddressUpdatePending(regId=_regId, description=data.description, newAddr=_newAddr, prevAddr=data.addr, version=data.version, confirmBlock=confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n# confirm update address\n\n\n@internal\ndef _confirmAddressUpdateToRegistry(_regId: uint256) -> bool:\n    newData: PendingAddressUpdate = self.pendingAddrUpdate[_regId]\n    assert newData.confirmBlock != 0 and block.number >= newData.confirmBlock # dev: time lock not reached\n\n    data: AddressInfo = self.addrInfo[_regId]\n    prevAddr: address = data.addr # needed for later\n    if not self._isValidAddressUpdate(_regId, newData.newAddr, prevAddr):\n        self.pendingAddrUpdate[_regId] = empty(PendingAddressUpdate) # clear pending\n        return False\n\n    # update addy data\n    data.addr = newData.newAddr\n    data.lastModified = block.timestamp\n    data.version += 1\n    self.addrInfo[_regId] = data\n    self.addrToRegId[newData.newAddr] = _regId\n\n    # handle previous addr\n    if prevAddr != empty(address):\n        self.addrToRegId[prevAddr] = 0\n\n    # clear pending\n    self.pendingAddrUpdate[_regId] = empty(PendingAddressUpdate)\n\n    log AddressUpdateConfirmed(regId=_regId, description=data.description, newAddr=newData.newAddr, prevAddr=prevAddr, version=data.version, registry=REGISTRY_STR)\n    return True\n\n\n# cancel update address\n\n\n@internal\ndef _cancelAddressUpdateToRegistry(_regId: uint256) -> bool:\n    data: PendingAddressUpdate = self.pendingAddrUpdate[_regId]\n    assert data.confirmBlock != 0 # dev: no pending\n\n    self.pendingAddrUpdate[_regId] = empty(PendingAddressUpdate)\n    prevData: AddressInfo = self.addrInfo[_regId]\n    log AddressUpdateCancelled(regId=_regId, description=prevData.description, newAddr=data.newAddr, prevAddr=prevData.addr, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n# validation\n\n\n@view\n@external\ndef isValidAddressUpdate(_regId: uint256, _newAddr: address) -> bool:\n    return self._isValidAddressUpdate(_regId, _newAddr, self.addrInfo[_regId].addr)\n\n\n@view\n@internal\ndef _isValidAddressUpdate(_regId: uint256, _newAddr: address, _prevAddr: address) -> bool:\n    if not self._isValidRegId(_regId):\n        return False\n    if not self._isValidNewAddress(_newAddr):\n        return False\n    return _newAddr != _prevAddr\n\n\n###################\n# Disable Address #\n###################\n\n\n# start disable address\n\n\n@internal\ndef _startAddressDisableInRegistry(_regId: uint256) -> bool:\n    data: AddressInfo = self.addrInfo[_regId]\n    assert self._isValidAddressDisable(_regId, data.addr) # dev: invalid disable\n\n    # set pending\n    confirmBlock: uint256 = block.number + self.registryChangeTimeLock\n    self.pendingAddrDisable[_regId] = PendingAddressDisable(\n        initiatedBlock=block.number,\n        confirmBlock=confirmBlock,\n    )\n\n    log AddressDisablePending(regId=_regId, description=data.description, addr=data.addr, version=data.version, confirmBlock=confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n# confirm disable address\n\n\n@internal\ndef _confirmAddressDisableInRegistry(_regId: uint256) -> bool:\n    newData: PendingAddressDisable = self.pendingAddrDisable[_regId]\n    assert newData.confirmBlock != 0 and block.number >= newData.confirmBlock # dev: time lock not reached\n\n    data: AddressInfo = self.addrInfo[_regId]\n    prevAddr: address = data.addr # needed for later\n    if not self._isValidAddressDisable(_regId, prevAddr):\n        self.pendingAddrDisable[_regId] = empty(PendingAddressDisable) # clear pending\n        return False\n\n    # disable addy\n    data.addr = empty(address)\n    data.lastModified = block.timestamp\n    data.version += 1\n    self.addrInfo[_regId] = data\n    self.addrToRegId[prevAddr] = 0\n\n    # clear pending\n    self.pendingAddrDisable[_regId] = empty(PendingAddressDisable)\n\n    log AddressDisableConfirmed(regId=_regId, description=data.description, addr=prevAddr, version=data.version, registry=REGISTRY_STR)\n    return True\n\n\n# cancel disable address\n\n\n@internal\ndef _cancelAddressDisableInRegistry(_regId: uint256) -> bool:\n    data: PendingAddressDisable = self.pendingAddrDisable[_regId]\n    assert data.confirmBlock != 0 # dev: no pending\n\n    self.pendingAddrDisable[_regId] = empty(PendingAddressDisable)\n    prevData: AddressInfo = self.addrInfo[_regId]\n    log AddressDisableCancelled(regId=_regId, description=prevData.description, addr=prevData.addr, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n# validation\n\n\n@view\n@external\ndef isValidAddressDisable(_regId: uint256) -> bool:\n    return self._isValidAddressDisable(_regId, self.addrInfo[_regId].addr)\n\n\n@view\n@internal\ndef _isValidAddressDisable(_regId: uint256, _prevAddr: address) -> bool:\n    if not self._isValidRegId(_regId):\n        return False\n    return _prevAddr != empty(address)\n\n\n####################\n# Time Lock Config #\n####################\n\n\n@external\ndef setRegistryTimeLock(_numBlocks: uint256) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return self._setRegistryTimeLock(_numBlocks)\n\n\n@internal\ndef _setRegistryTimeLock(_numBlocks: uint256) -> bool:\n    prevTimeLock: uint256 = self.registryChangeTimeLock\n    assert self._isValidRegistryTimeLock(_numBlocks, prevTimeLock) # dev: invalid time lock\n    self.registryChangeTimeLock = _numBlocks\n    log RegistryTimeLockModified(newTimeLock=_numBlocks, prevTimeLock=prevTimeLock, registry=REGISTRY_STR)\n    return True\n\n\n# validation\n\n\n@view\n@external\ndef isValidRegistryTimeLock(_numBlocks: uint256) -> bool:\n    return self._isValidRegistryTimeLock(_numBlocks, self.registryChangeTimeLock)\n\n\n@view\n@internal\ndef _isValidRegistryTimeLock(_newTimeLock: uint256, _prevTimeLock: uint256) -> bool:\n    if _newTimeLock == _prevTimeLock:\n        return False\n    return _newTimeLock >= MIN_REG_TIME_LOCK and _newTimeLock <= MAX_REG_TIME_LOCK\n\n\n# finish setup\n\n\n@external\ndef setRegistryTimeLockAfterSetup(_numBlocks: uint256 = 0) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert self.registryChangeTimeLock == 0 # dev: already set\n\n    timeLock: uint256 = _numBlocks\n    if timeLock == 0:\n        timeLock = MIN_REG_TIME_LOCK\n    return self._setRegistryTimeLock(timeLock)\n\n\n# utils\n\n\n@view\n@external\ndef minRegistryTimeLock() -> uint256:\n    return MIN_REG_TIME_LOCK\n\n\n@view\n@external\ndef maxRegistryTimeLock() -> uint256:\n    return MAX_REG_TIME_LOCK\n\n\n#################\n# Views / Utils #\n#################\n\n\n# is valid addr\n\n\n@view\n@external\ndef isValidAddr(_addr: address) -> bool:\n    return self._isValidAddr(_addr)\n\n\n@view\n@internal\ndef _isValidAddr(_addr: address) -> bool:\n    return self.addrToRegId[_addr] != 0\n\n\n# is valid addr id\n\n\n@view\n@external\ndef isValidRegId(_regId: uint256) -> bool:\n    return self._isValidRegId(_regId)\n\n\n@view\n@internal\ndef _isValidRegId(_regId: uint256) -> bool:\n    return _regId != 0 and _regId < self.numAddrs\n\n\n# get reg id\n\n\n@view\n@external\ndef getRegId(_addr: address) -> uint256:\n    return self._getRegId(_addr)\n\n\n@view\n@internal\ndef _getRegId(_addr: address) -> uint256:\n    return self.addrToRegId[_addr]\n\n\n# get addr\n\n\n@view\n@external\ndef getAddr(_regId: uint256) -> address:\n    return self._getAddr(_regId)\n\n\n@view\n@internal\ndef _getAddr(_regId: uint256) -> address:\n    return self.addrInfo[_regId].addr\n\n\n# get addr info\n\n\n@view\n@external\ndef getAddrInfo(_regId: uint256) -> AddressInfo:\n    return self._getAddrInfo(_regId)\n\n\n@view\n@internal\ndef _getAddrInfo(_regId: uint256) -> AddressInfo:\n    return self.addrInfo[_regId]\n\n\n# get addr description\n\n\n@view\n@external\ndef getAddrDescription(_regId: uint256) -> String[64]:\n    return self._getAddrDescription(_regId)\n\n\n@view\n@internal\ndef _getAddrDescription(_regId: uint256) -> String[64]:\n    return self.addrInfo[_regId].description\n\n\n# get num addrs\n\n\n@view\n@external\ndef getNumAddrs() -> uint256:\n    return self._getNumAddrs()\n\n\n@view\n@internal\ndef _getNumAddrs() -> uint256:\n    return self.numAddrs - 1\n\n\n# get last addr\n\n\n@view\n@external\ndef getLastAddr() -> address:\n    return self._getLastAddr()\n\n\n@view\n@internal\ndef _getLastAddr() -> address:\n    lastRegId: uint256 = self.numAddrs - 1\n    return self.addrInfo[lastRegId].addr\n\n\n# get last reg id\n\n\n@view\n@external\ndef getLastRegId() -> uint256:\n    return self._getLastRegId()\n\n\n@view\n@internal\ndef _getLastRegId() -> uint256:\n    return self.numAddrs - 1\n",
            "sha256sum": "b88f6fc85ae3cd815c5a476c620b2fb5494b4dec5f1ce738878eded11c46396b"
          },
          "interfaces/Department.vyi": {
            "content": "# @version 0.4.3\n\n\n###########\n# Minting #\n###########\n\n\n@view\n@external\ndef canMintUndy() -> bool:\n    # used in UndyHq.vy\n    ...\n\n\n########\n# Undy #\n########\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "53e48da591c4ee36045a8950c9d3a01458456b471b797df536e9a9f54404e721"
          },
          "contracts/registries/UndyHq.vy": {
            "content": "#          ___           ___           ___                                  ___           ___     \n#         /  /\\         /  /\\         /  /\\          __                    /  /\\         /  /\\    \n#        /  /:/        /  /::|       /  /::\\        |  |\\                 /  /:/        /  /::\\   \n#       /  /:/        /  /:|:|      /  /:/\\:\\       |  |:|               /  /:/        /__/:/\\:\\  \n#      /  /:/        /  /:/|:|__   /  /:/  \\:\\      |  |:|              /  /::\\ ___    \\  \\:\\ \\:\\ \n#     /__/:/     /\\ /__/:/ |:| /\\ /__/:/ \\__\\:|     |__|:|__           /__/:/\\:\\  /\\    \\  \\:\\ \\:\\\n#     \\  \\:\\    /:/ \\__\\/  |:|/:/ \\  \\:\\ /  /:/     /  /::::\\          \\__\\/  \\:\\/:/     \\  \\:\\/:/\n#      \\  \\:\\  /:/      |  |:/:/   \\  \\:\\  /:/     /  /:/~~~~               \\__\\::/       \\__\\::/ \n#       \\  \\:\\/:/       |__|::/     \\  \\:\\/:/     /__/:/                    /  /:/        /  /:/  \n#        \\  \\::/        /__/:/       \\__\\::/      \\__\\/                    /__/:/        /__/:/   \n#         \\__\\/         \\__\\/            ~~                                \\__\\/         \\__\\/    \n#\n#     \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n#     \u2551  ** Undy Hq **                                   \u2551\n#     \u2551  Main address registry for Underscore protocol.  \u2551\n#     \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n#\n#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nexports: gov.__interface__\nexports: registry.__interface__\n\ninitializes: gov\ninitializes: registry[gov := gov]\n\nimport contracts.modules.LocalGov as gov\nimport contracts.modules.AddressRegistry as registry\n\nfrom interfaces import Department\nfrom ethereum.ercs import IERC20\n\nstruct HqConfig:\n    description: String[64]\n    canMintUndy: bool\n    canSetTokenBlacklist: bool\n\nstruct PendingHqConfig:\n    newHqConfig: HqConfig\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent HqConfigChangeInitiated:\n    regId: uint256\n    description: String[64]\n    canMintUndy: bool\n    canSetTokenBlacklist: bool\n    confirmBlock: uint256\n\nevent HqConfigChangeConfirmed:\n    regId: uint256\n    description: String[64]\n    canMintUndy: bool\n    canSetTokenBlacklist: bool\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent HqConfigChangeCancelled:\n    regId: uint256\n    description: String[64]\n    canMintUndy: bool\n    canSetTokenBlacklist: bool\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent UndyHqFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    balance: uint256\n\nevent UndyTokenSet:\n    token: indexed(address)\n\nevent MintingEnabled:\n    isEnabled: bool\n\n# token\nundyToken: public(address)\nmintEnabled: public(bool)\n\n# hq config\nhqConfig: public(HashMap[uint256, HqConfig]) # reg id -> hq config\npendingHqConfig: public(HashMap[uint256, PendingHqConfig]) # reg id -> pending hq config\n\nMAX_RECOVER_ASSETS: constant(uint256) = 20\n\n\n@deploy\ndef __init__(\n    _initialGov: address,\n    _minGovTimeLock: uint256,\n    _maxGovTimeLock: uint256,\n    _minRegistryTimeLock: uint256,\n    _maxRegistryTimeLock: uint256,\n):\n    gov.__init__(empty(address), _initialGov, _minGovTimeLock, _maxGovTimeLock, 0)\n    registry.__init__(_minRegistryTimeLock, _maxRegistryTimeLock, 0, \"UndyHq.vy\")\n\n\n############\n# Registry #\n############\n\n\n# new address\n\n\n@external\ndef startAddNewAddressToRegistry(_addr: address, _description: String[64]) -> bool:\n    assert msg.sender == gov.governance # dev: no perms\n    return registry._startAddNewAddressToRegistry(_addr, _description)\n\n\n@external\ndef confirmNewAddressToRegistry(_addr: address) -> uint256:\n    assert msg.sender == gov.governance # dev: no perms\n    return registry._confirmNewAddressToRegistry(_addr)\n\n\n@external\ndef cancelNewAddressToRegistry(_addr: address) -> bool:\n    assert msg.sender == gov.governance # dev: no perms\n    return registry._cancelNewAddressToRegistry(_addr)\n\n\n# address update\n\n\n@external\ndef startAddressUpdateToRegistry(_regId: uint256, _newAddr: address) -> bool:\n    assert msg.sender == gov.governance # dev: no perms\n    return registry._startAddressUpdateToRegistry(_regId, _newAddr)\n\n\n@external\ndef confirmAddressUpdateToRegistry(_regId: uint256) -> bool:\n    assert msg.sender == gov.governance # dev: no perms\n    return registry._confirmAddressUpdateToRegistry(_regId)\n\n\n@external\ndef cancelAddressUpdateToRegistry(_regId: uint256) -> bool:\n    assert msg.sender == gov.governance # dev: no perms\n    return registry._cancelAddressUpdateToRegistry(_regId)\n\n\n# address disable\n\n\n@external\ndef startAddressDisableInRegistry(_regId: uint256) -> bool:\n    assert msg.sender == gov.governance # dev: no perms\n    return registry._startAddressDisableInRegistry(_regId)\n\n\n@external\ndef confirmAddressDisableInRegistry(_regId: uint256) -> bool:\n    assert msg.sender == gov.governance # dev: no perms\n    return registry._confirmAddressDisableInRegistry(_regId)\n\n\n@external\ndef cancelAddressDisableInRegistry(_regId: uint256) -> bool:\n    assert msg.sender == gov.governance # dev: no perms\n    return registry._cancelAddressDisableInRegistry(_regId)\n\n\n#############\n# Hq Config #\n#############\n\n\n@view\n@external\ndef hasPendingHqConfigChange(_regId: uint256) -> bool:\n    return self.pendingHqConfig[_regId].confirmBlock != 0\n\n\n# start hq config change\n\n\n@external\ndef initiateHqConfigChange(\n    _regId: uint256,\n    _canMintUndy: bool,\n    _canSetTokenBlacklist: bool,\n):\n    assert msg.sender == gov.governance # dev: no perms\n\n    assert self._isValidHqConfig(_regId, _canMintUndy) # dev: invalid hq config\n    hqConfig: HqConfig = HqConfig(\n        description= registry._getAddrDescription(_regId),\n        canMintUndy= _canMintUndy,\n        canSetTokenBlacklist= _canSetTokenBlacklist,\n    )\n\n    # set pending hq config\n    confirmBlock: uint256 = block.number + registry.registryChangeTimeLock\n    self.pendingHqConfig[_regId] = PendingHqConfig(\n        newHqConfig= hqConfig,\n        initiatedBlock= block.number,\n        confirmBlock= confirmBlock,\n    )\n    log HqConfigChangeInitiated(\n        regId=_regId,\n        description=hqConfig.description,\n        canMintUndy=_canMintUndy,\n        canSetTokenBlacklist=_canSetTokenBlacklist,\n        confirmBlock=confirmBlock,\n    )\n\n\n# confirm hq config change\n\n\n@external\ndef confirmHqConfigChange(_regId: uint256) -> bool:\n    assert msg.sender == gov.governance # dev: no perms\n\n    data: PendingHqConfig = self.pendingHqConfig[_regId]\n    assert data.confirmBlock != 0 and block.number >= data.confirmBlock # dev: time lock not reached\n\n    # invalid hq config\n    newConfig: HqConfig = data.newHqConfig\n    if not self._isValidHqConfig(_regId, newConfig.canMintUndy):\n        self.pendingHqConfig[_regId] = empty(PendingHqConfig)\n        return False\n\n    # set hq config\n    self.hqConfig[_regId] = newConfig\n    self.pendingHqConfig[_regId] = empty(PendingHqConfig)\n\n    log HqConfigChangeConfirmed(\n        regId=_regId,\n        description=newConfig.description,\n        canMintUndy=newConfig.canMintUndy,\n        canSetTokenBlacklist=newConfig.canSetTokenBlacklist,\n        initiatedBlock=data.initiatedBlock,\n        confirmBlock=data.confirmBlock,\n    )\n    return True\n\n\n# cancel hq config change\n\n\n@external\ndef cancelHqConfigChange(_regId: uint256) -> bool:\n    assert msg.sender == gov.governance # dev: no perms\n\n    data: PendingHqConfig = self.pendingHqConfig[_regId]\n    assert data.confirmBlock != 0 # dev: no pending change\n\n    self.pendingHqConfig[_regId] = empty(PendingHqConfig)\n    log HqConfigChangeCancelled(\n        regId=_regId,\n        description=data.newHqConfig.description,\n        canMintUndy=data.newHqConfig.canMintUndy,\n        canSetTokenBlacklist=data.newHqConfig.canSetTokenBlacklist,\n        initiatedBlock=data.initiatedBlock,\n        confirmBlock=data.confirmBlock\n    )\n    return True\n\n\n# validation\n\n\n@view\n@external\ndef isValidHqConfig(_regId: uint256, _canMintUndy: bool) -> bool:\n    return self._isValidHqConfig(_regId, _canMintUndy)\n\n\n@view\n@internal\ndef _isValidHqConfig(_regId: uint256, _canMintUndy: bool) -> bool:\n\n    # invalid reg id\n    if not registry._isValidRegId(_regId):\n        return False\n\n    # no addr\n    addr: address = registry._getAddr(_regId)\n    if addr == empty(address):\n        return False\n\n    if _canMintUndy and not staticcall Department(addr).canMintUndy():\n        return False\n\n    return True\n\n\n##########\n# Tokens #\n##########\n\n\n# setting token\n\n\n@external\ndef setUndyToken(_token: address):\n    assert msg.sender == gov.governance # dev: no perms\n    assert _token != empty(address) and _token.is_contract # dev: invalid token\n    assert registry._getRegId(_token) == 0 # dev: already registered\n    assert self.undyToken == empty(address) # dev: already set\n    self.undyToken = _token\n    log UndyTokenSet(token=_token)\n\n\n# permission to mint\n\n\n@view\n@external\ndef canMintUndy(_addr: address) -> bool:\n    if not self.mintEnabled:\n        return False\n    if _addr == empty(address):\n        return False\n    regId: uint256 = registry._getRegId(_addr)\n    if regId == 0 or not self.hqConfig[regId].canMintUndy:\n        return False\n    return staticcall Department(_addr).canMintUndy()\n\n\n# minting circuit breaker\n\n\n@external\ndef setMintingEnabled(_shouldEnable: bool):\n    assert msg.sender == gov.governance # dev: no perms\n    assert self.mintEnabled != _shouldEnable # dev: already set\n\n    self.mintEnabled = _shouldEnable\n    log MintingEnabled(isEnabled=_shouldEnable)\n\n\n# token blacklist\n\n\n@view\n@external\ndef canSetTokenBlacklist(_addr: address) -> bool:\n    if _addr == empty(address):\n        return False\n    regId: uint256 = registry._getRegId(_addr)\n    if regId == 0:\n        return False\n    return self.hqConfig[regId].canSetTokenBlacklist\n\n\n############\n# Recovery #\n############\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    assert msg.sender == gov.governance # dev: no perms\n    self._recoverFunds(_recipient, _asset)\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, MAX_RECOVER_ASSETS]):\n    assert msg.sender == gov.governance # dev: no perms\n    for a: address in _assets:\n        self._recoverFunds(_recipient, a)\n\n\n@internal\ndef _recoverFunds(_recipient: address, _asset: address):\n    assert empty(address) not in [_recipient, _asset] # dev: invalid recipient or asset\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    assert balance != 0 # dev: nothing to recover\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log UndyHqFundsRecovered(asset=_asset, recipient=_recipient, balance=balance)",
            "sha256sum": "fc38c69a296234b2815d848f5a2e151eb2cd0bcdae8915eae589a8c4de7058d4"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/registries/UndyHq.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.3+commit.bff19ea2",
        "integrity": "18c96fbd374bdcc13df37126af3c8c47e3f67084e403b83b98cd3f4fc4e5b154"
      },
      "args": "00000000000000000000000014051a647c2b647363739ccfd4b008afeeb8fd8e000000000000000000000000000000000000000000000000000000000000a8c0000000000000000000000000000000000000000000000000000000000013c6800000000000000000000000000000000000000000000000000000000000005460000000000000000000000000000000000000000000000000000000000013c680",
      "file": "contracts/registries/UndyHq.vy"
    },
    "Ledger": {
      "address": "0x9e97A2e527890E690c7FA978696A88EFA868c5D0",
      "abi": [
        {
          "name": "DepartmentPauseModified",
          "inputs": [
            {
              "name": "isPaused",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "DepartmentFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "balance",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddys",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "undyToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "hatchery",
                  "type": "address"
                },
                {
                  "name": "lootDistributor",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                },
                {
                  "name": "walletBackpack",
                  "type": "address"
                },
                {
                  "name": "billing",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUndyHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canMintUndy",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pause",
          "inputs": [
            {
              "name": "_shouldPause",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFundsMany",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_assets",
              "type": "address[]"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isPaused",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "createUserWallet",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_ambassador",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getNumUserWallets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isUserWallet",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setUserPoints",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_data",
              "type": "tuple",
              "components": [
                {
                  "name": "usdValue",
                  "type": "uint256"
                },
                {
                  "name": "depositPoints",
                  "type": "uint256"
                },
                {
                  "name": "lastUpdate",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setGlobalPoints",
          "inputs": [
            {
              "name": "_data",
              "type": "tuple",
              "components": [
                {
                  "name": "usdValue",
                  "type": "uint256"
                },
                {
                  "name": "depositPoints",
                  "type": "uint256"
                },
                {
                  "name": "lastUpdate",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setUserAndGlobalPoints",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_userData",
              "type": "tuple",
              "components": [
                {
                  "name": "usdValue",
                  "type": "uint256"
                },
                {
                  "name": "depositPoints",
                  "type": "uint256"
                },
                {
                  "name": "lastUpdate",
                  "type": "uint256"
                }
              ]
            },
            {
              "name": "_globalData",
              "type": "tuple",
              "components": [
                {
                  "name": "usdValue",
                  "type": "uint256"
                },
                {
                  "name": "depositPoints",
                  "type": "uint256"
                },
                {
                  "name": "lastUpdate",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLastTotalUsdValue",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUserAndGlobalPoints",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "usdValue",
                  "type": "uint256"
                },
                {
                  "name": "depositPoints",
                  "type": "uint256"
                },
                {
                  "name": "lastUpdate",
                  "type": "uint256"
                }
              ]
            },
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "usdValue",
                  "type": "uint256"
                },
                {
                  "name": "depositPoints",
                  "type": "uint256"
                },
                {
                  "name": "lastUpdate",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isRegisteredVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_underlyingAsset",
              "type": "address"
            },
            {
              "name": "_decimals",
              "type": "uint256"
            },
            {
              "name": "_isRebasing",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "registerBackpackItem",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "createAgent",
          "inputs": [
            {
              "name": "_agent",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getNumAgents",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isAgent",
          "inputs": [
            {
              "name": "_agent",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "userPoints",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "usdValue",
                  "type": "uint256"
                },
                {
                  "name": "depositPoints",
                  "type": "uint256"
                },
                {
                  "name": "lastUpdate",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "globalPoints",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "usdValue",
                  "type": "uint256"
                },
                {
                  "name": "depositPoints",
                  "type": "uint256"
                },
                {
                  "name": "lastUpdate",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "userWallets",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfUserWallet",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numUserWallets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ambassadors",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "agents",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAgent",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAgents",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "vaultTokens",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "underlyingAsset",
                  "type": "address"
                },
                {
                  "name": "decimals",
                  "type": "uint256"
                },
                {
                  "name": "isRebasing",
                  "type": "bool"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isRegisteredBackpackItem",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_undyHq",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/modules/Addys.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\ninterface UndyHq:\n    def isValidAddr(_addr: address) -> bool: view\n    def getAddr(_regId: uint256) -> address: view\n    def undyToken() -> address: view\n\ninterface Switchboard:\n    def isSwitchboardAddr(_addr: address) -> bool: view\n\ninterface LegoBook:\n    def isLegoAddr(_addr: address) -> bool: view\n\nstruct Addys:\n    hq: address\n    undyToken: address\n    ledger: address\n    missionControl: address\n    legoBook: address\n    switchboard: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    walletBackpack: address\n    billing: address\n\n# hq\nUNDY_HQ_FOR_ADDYS: immutable(address)\n\n# core addys\nLEDGER_ID: constant(uint256) = 1\nMISSION_CONTROL_ID: constant(uint256) = 2\nLEGO_BOOK_ID: constant(uint256) = 3\nSWITCHBOARD_ID: constant(uint256) = 4\nHATCHERY_ID: constant(uint256) = 5\nLOOT_DISTRIBUTOR_ID: constant(uint256) = 6\nAPPRAISER_ID: constant(uint256) = 7\nWALLET_BACKPACK_ID: constant(uint256) = 8\nBILLING_ID: constant(uint256) = 9\n\n\n@deploy\ndef __init__(_undyHq: address):\n    assert _undyHq != empty(address) # dev: invalid undy hq\n    UNDY_HQ_FOR_ADDYS = _undyHq\n\n\n########\n# Core #\n########\n\n\n@view\n@external\ndef getAddys() -> Addys:\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _getAddys(_addys: Addys = empty(Addys)) -> Addys:\n    if _addys.hq != empty(address):\n        return _addys\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _generateAddys() -> Addys:\n    hq: address = UNDY_HQ_FOR_ADDYS\n    return Addys(\n        hq = hq,\n        undyToken = staticcall UndyHq(hq).undyToken(),\n        ledger = staticcall UndyHq(hq).getAddr(LEDGER_ID),\n        missionControl = staticcall UndyHq(hq).getAddr(MISSION_CONTROL_ID),\n        legoBook = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID),\n        switchboard = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID),\n        hatchery = staticcall UndyHq(hq).getAddr(HATCHERY_ID),\n        lootDistributor = staticcall UndyHq(hq).getAddr(LOOT_DISTRIBUTOR_ID),\n        appraiser = staticcall UndyHq(hq).getAddr(APPRAISER_ID),\n        walletBackpack = staticcall UndyHq(hq).getAddr(WALLET_BACKPACK_ID),\n        billing = staticcall UndyHq(hq).getAddr(BILLING_ID),\n    )\n\n\n##########\n# Tokens #\n##########\n\n\n@view\n@internal\ndef _getUndyToken() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).undyToken()\n\n\n###########\n# Helpers #\n###########\n\n\n# undy hq\n\n\n@view\n@external\ndef getUndyHq() -> address:\n    return self._getUndyHq()\n\n\n@view\n@internal\ndef _getUndyHq() -> address:\n    return UNDY_HQ_FOR_ADDYS\n\n\n# utils\n\n\n@view\n@internal\ndef _isValidUndyAddr(_addr: address, _hq: address = empty(address)) -> bool:\n    hq: address = _hq\n    if _hq == empty(address):\n        hq = UNDY_HQ_FOR_ADDYS\n    \n    # core departments\n    if staticcall UndyHq(hq).isValidAddr(_addr):\n        return True\n\n    # lego book\n    legoBook: address = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID)\n    if legoBook != empty(address) and staticcall LegoBook(legoBook).isLegoAddr(_addr):\n        return True\n\n    # switchboard config\n    switchboard: address = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID)\n    if switchboard != empty(address) and staticcall Switchboard(switchboard).isSwitchboardAddr(_addr):\n        return True\n\n    return False\n\n\n@view\n@internal\ndef _isSwitchboardAddr(_addr: address) -> bool:\n    switchboard: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n    if switchboard == empty(address):\n        return False\n    return staticcall Switchboard(switchboard).isSwitchboardAddr(_addr)\n\n\n@view\n@internal\ndef _isLegoBookAddr(_addr: address) -> bool:\n    legoBook: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n    if legoBook == empty(address):\n        return False\n    return staticcall LegoBook(legoBook).isLegoAddr(_addr)\n\n\n###############\n# Departments #\n###############\n\n\n# ledger\n\n\n@view\n@internal\ndef _getLedgerId() -> uint256:\n    return LEDGER_ID\n\n\n@view\n@internal\ndef _getLedgerAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEDGER_ID)\n\n\n# mission control\n\n\n@view\n@internal\ndef _getMissionControlId() -> uint256:\n    return MISSION_CONTROL_ID\n\n\n@view\n@internal\ndef _getMissionControlAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(MISSION_CONTROL_ID)\n\n\n# lego book\n\n\n@view\n@internal\ndef _getLegoBookId() -> uint256:\n    return LEGO_BOOK_ID\n\n\n@view\n@internal\ndef _getLegoBookAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n\n\n# switchboard\n\n\n@view\n@internal\ndef _getSwitchboardId() -> uint256:\n    return SWITCHBOARD_ID\n\n\n@view\n@internal\ndef _getSwitchboardAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n\n\n# hatchery\n\n\n@view\n@internal\ndef _getHatcheryId() -> uint256:\n    return HATCHERY_ID\n\n\n@view\n@internal\ndef _getHatcheryAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(HATCHERY_ID)\n\n\n# loot distributor\n\n\n@view\n@internal\ndef _getLootDistributorId() -> uint256:\n    return LOOT_DISTRIBUTOR_ID\n\n\n@view\n@internal\ndef _getLootDistributorAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LOOT_DISTRIBUTOR_ID)\n\n\n# appraiser\n\n\n@view\n@internal\ndef _getAppraiserId() -> uint256:\n    return APPRAISER_ID\n\n\n@view\n@internal\ndef _getAppraiserAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(APPRAISER_ID)\n\n\n# wallet backpack\n\n\n@view\n@internal\ndef _getWalletBackpackId() -> uint256:\n    return WALLET_BACKPACK_ID\n\n\n@view\n@internal\ndef _getWalletBackpackAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(WALLET_BACKPACK_ID)\n\n\n# billing\n\n\n@view\n@internal\ndef _getBillingId() -> uint256:\n    return BILLING_ID\n\n\n@view\n@internal\ndef _getBillingAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(BILLING_ID)",
            "sha256sum": "78b58f0b2acb2eaafa4d21adf9135a1cd0e1d53897f7a1fa70a83a04a7738ad3"
          },
          "interfaces/Department.vyi": {
            "content": "# @version 0.4.3\n\n\n###########\n# Minting #\n###########\n\n\n@view\n@external\ndef canMintUndy() -> bool:\n    # used in UndyHq.vy\n    ...\n\n\n########\n# Undy #\n########\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "53e48da591c4ee36045a8950c9d3a01458456b471b797df536e9a9f54404e721"
          },
          "contracts/modules/DeptBasics.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nuses: addys\nimplements: dept\n\nimport contracts.modules.Addys as addys\nimport interfaces.Department as dept\nfrom ethereum.ercs import IERC20\n\nevent DepartmentPauseModified:\n    isPaused: bool\n\nevent DepartmentFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    balance: uint256\n\nisPaused: public(bool)\n\nCAN_MINT_UNDY: immutable(bool)\nMAX_RECOVER_ASSETS: constant(uint256) = 20\n\n\n@deploy\ndef __init__(_shouldPause: bool, _canMintUndy: bool):\n    self.isPaused = _shouldPause\n    CAN_MINT_UNDY = _canMintUndy\n\n\n###########\n# Minting #\n###########\n\n\n@view\n@external\ndef canMintUndy() -> bool:\n    return CAN_MINT_UNDY\n\n\n########\n# Undy #\n########\n\n\n# activate\n\n\n@external\ndef pause(_shouldPause: bool):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert _shouldPause != self.isPaused # dev: no change\n    self.isPaused = _shouldPause\n    log DepartmentPauseModified(isPaused=_shouldPause)\n\n\n# recover funds\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    self._recoverFunds(_recipient, _asset)\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, MAX_RECOVER_ASSETS]):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    for a: address in _assets:\n        self._recoverFunds(_recipient, a)\n\n\n@internal\ndef _recoverFunds(_recipient: address, _asset: address):\n    assert empty(address) not in [_recipient, _asset] # dev: invalid recipient or asset\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    assert balance != 0 # dev: nothing to recover\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log DepartmentFundsRecovered(asset=_asset, recipient=_recipient, balance=balance)\n",
            "sha256sum": "976a50a3807bcf71f3f1c57de5cd7a59fe4e8f27b4d4560e774073962f44d1ac"
          },
          "contracts/data/Ledger.vy": {
            "content": "#          ___       ___           ___           ___           ___           ___     \n#         /\\__\\     /\\  \\         /\\  \\         /\\  \\         /\\  \\         /\\  \\    \n#        /:/  /    /::\\  \\       /::\\  \\       /::\\  \\       /::\\  \\       /::\\  \\   \n#       /:/  /    /:/\\:\\  \\     /:/\\:\\  \\     /:/\\:\\  \\     /:/\\:\\  \\     /:/\\:\\  \\  \n#      /:/  /    /::\\~\\:\\  \\   /:/  \\:\\__\\   /:/  \\:\\  \\   /::\\~\\:\\  \\   /::\\~\\:\\  \\ \n#     /:/__/    /:/\\:\\ \\:\\__\\ /:/__/ \\:|__| /:/__/_\\:\\__\\ /:/\\:\\ \\:\\__\\ /:/\\:\\ \\:\\__\\\n#     \\:\\  \\    \\:\\~\\:\\ \\/__/ \\:\\  \\ /:/  / \\:\\  /\\ \\/__/ \\:\\~\\:\\ \\/__/ \\/_|::\\/:/  /\n#      \\:\\  \\    \\:\\ \\:\\__\\    \\:\\  /:/  /   \\:\\ \\:\\__\\    \\:\\ \\:\\__\\      |:|::/  / \n#       \\:\\  \\    \\:\\ \\/__/     \\:\\/:/  /     \\:\\/:/  /     \\:\\ \\/__/      |:|\\/__/  \n#        \\:\\__\\    \\:\\__\\        \\::/__/       \\::/  /       \\:\\__\\        |:|  |    \n#         \\/__/     \\/__/         ~~            \\/__/         \\/__/         \\|__|    \n#                                                                                \n#     \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n#     \u2551  ** Ledger **                                \u2551\n#     \u2551  Handles all data storage for the protocol   \u2551\n#     \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n#\n#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nimplements: Department\n\nexports: addys.__interface__\nexports: deptBasics.__interface__\n\ninitializes: addys\ninitializes: deptBasics[addys := addys]\n\nimport contracts.modules.Addys as addys\nimport contracts.modules.DeptBasics as deptBasics\nfrom interfaces import Department\n\nstruct PointsData:\n    usdValue: uint256\n    depositPoints: uint256\n    lastUpdate: uint256\n\nstruct VaultToken:\n    legoId: uint256\n    underlyingAsset: address\n    decimals: uint256\n    isRebasing: bool\n\n# points\nuserPoints: public(HashMap[address, PointsData]) # user -> points\nglobalPoints: public(PointsData)\n\n# user wallets (iterable)\nuserWallets: public(HashMap[uint256, address]) # index -> user wallet\nindexOfUserWallet: public(HashMap[address, uint256]) # user wallet -> index\nnumUserWallets: public(uint256) # num userWallets\n\n# ambassadors\nambassadors: public(HashMap[address, address]) # user -> ambassador\n\n# agents (iterable)\nagents: public(HashMap[uint256, address]) # index -> agent\nindexOfAgent: public(HashMap[address, uint256]) # agent -> index\nnumAgents: public(uint256) # num agents\n\n# vault tokens\nvaultTokens: public(HashMap[address, VaultToken]) # vault token -> data\n\n# backpack items\nisRegisteredBackpackItem: public(HashMap[address, bool]) # asset -> is registered\n\n\n@deploy\ndef __init__(_undyHq: address):\n    addys.__init__(_undyHq)\n    deptBasics.__init__(False, False) # no minting\n\n    self.numUserWallets = 1\n    self.numAgents = 1\n\n\n################\n# User Wallets #\n################\n\n\n@external\ndef createUserWallet(_user: address, _ambassador: address):\n    assert msg.sender == addys._getHatcheryAddr() # dev: only hatchery allowed\n    assert not deptBasics.isPaused # dev: not activated\n\n    wid: uint256 = self.numUserWallets\n    self.userWallets[wid] = _user\n    self.indexOfUserWallet[_user] = wid\n    self.numUserWallets = wid + 1\n\n    # set ambassador\n    if _ambassador != empty(address):\n        self.ambassadors[_user] = _ambassador\n\n\n# utils\n\n\n@view\n@external\ndef getNumUserWallets() -> uint256:\n    return self._getNumUserWallets()\n\n\n@view\n@internal\ndef _getNumUserWallets() -> uint256:\n    return self.numUserWallets - 1\n\n\n@view\n@external\ndef isUserWallet(_user: address) -> bool:\n    return self.indexOfUserWallet[_user] != 0\n\n\n##################\n# Deposit Points #\n##################\n\n\n# set points\n\n\n@external\ndef setUserPoints(_user: address, _data: PointsData):\n    assert msg.sender == addys._getLootDistributorAddr() # dev: only loot distributor allowed\n    assert not deptBasics.isPaused # dev: not activated\n    self.userPoints[_user] = _data\n\n\n@external\ndef setGlobalPoints(_data: PointsData):\n    assert msg.sender == addys._getLootDistributorAddr() # dev: only loot distributor allowed\n    assert not deptBasics.isPaused # dev: not activated\n    self.globalPoints = _data\n\n\n@external\ndef setUserAndGlobalPoints(_user: address, _userData: PointsData, _globalData: PointsData):\n    assert msg.sender == addys._getLootDistributorAddr() # dev: only loot distributor allowed\n    assert not deptBasics.isPaused # dev: not activated\n    self.userPoints[_user] = _userData\n    self.globalPoints = _globalData\n\n\n# utils\n\n\n@view\n@external\ndef getLastTotalUsdValue(_user: address) -> uint256:\n    return self.userPoints[_user].usdValue\n\n\n@view\n@external\ndef getUserAndGlobalPoints(_user: address) -> (PointsData, PointsData):\n    return self.userPoints[_user], self.globalPoints\n\n\n################\n# Vault Tokens #\n################\n\n\n@view\n@external\ndef isRegisteredVaultToken(_vaultToken: address) -> bool:\n    return self.vaultTokens[_vaultToken].underlyingAsset != empty(address)\n\n\n@external\ndef setVaultToken(\n    _vaultToken: address,\n    _legoId: uint256,\n    _underlyingAsset: address,\n    _decimals: uint256,\n    _isRebasing: bool,\n):\n    assert addys._isLegoBookAddr(msg.sender) # dev: no perms\n    assert not deptBasics.isPaused # dev: not activated\n    self.vaultTokens[_vaultToken] = VaultToken(\n        legoId = _legoId,\n        underlyingAsset = _underlyingAsset,\n        decimals = _decimals,\n        isRebasing = _isRebasing,\n    )\n\n\n##################\n# Backpack Items #\n##################\n\n\n@external\ndef registerBackpackItem(_addr: address):\n    assert msg.sender == addys._getWalletBackpackAddr() # dev: no perms\n    assert not deptBasics.isPaused # dev: not activated\n    self.isRegisteredBackpackItem[_addr] = True\n\n\n##########\n# Agents #\n##########\n\n\n@external\ndef createAgent(_agent: address):\n    assert msg.sender == addys._getHatcheryAddr() # dev: only hatchery allowed\n    assert not deptBasics.isPaused # dev: not activated\n\n    aid: uint256 = self.numAgents\n    self.agents[aid] = _agent\n    self.indexOfAgent[_agent] = aid\n    self.numAgents = aid + 1\n\n\n# utils\n\n\n@view\n@external\ndef getNumAgents() -> uint256:\n    return self._getNumAgents()\n\n\n@view\n@internal\ndef _getNumAgents() -> uint256:\n    return self.numAgents - 1\n\n\n@view\n@external\ndef isAgent(_agent: address) -> bool:\n    return self.indexOfAgent[_agent] != 0\n",
            "sha256sum": "c5204796b3a04e76307007c8b854aa5415c8c9ca657978bdfca3dd171e5d109e"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/data/Ledger.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.3+commit.bff19ea2",
        "integrity": "da59170ce75ab98ddc13ec00da37ea58d31884e0716113735a320674cf278793"
      },
      "args": "00000000000000000000000044cf3c4f000dfd76a35d03298049d37be688d6f9",
      "file": "contracts/data/Ledger.vy"
    },
    "MissionControl": {
      "address": "0x910FE9484540fa21B092eE04a478A30A6B342006",
      "abi": [
        {
          "name": "DepartmentPauseModified",
          "inputs": [
            {
              "name": "isPaused",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "DepartmentFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "balance",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddys",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "undyToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "hatchery",
                  "type": "address"
                },
                {
                  "name": "lootDistributor",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                },
                {
                  "name": "walletBackpack",
                  "type": "address"
                },
                {
                  "name": "billing",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUndyHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canMintUndy",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pause",
          "inputs": [
            {
              "name": "_shouldPause",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFundsMany",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_assets",
              "type": "address[]"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isPaused",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setUserWalletConfig",
          "inputs": [
            {
              "name": "_config",
              "type": "tuple",
              "components": [
                {
                  "name": "walletTemplate",
                  "type": "address"
                },
                {
                  "name": "configTemplate",
                  "type": "address"
                },
                {
                  "name": "trialAsset",
                  "type": "address"
                },
                {
                  "name": "trialAmount",
                  "type": "uint256"
                },
                {
                  "name": "numUserWalletsAllowed",
                  "type": "uint256"
                },
                {
                  "name": "enforceCreatorWhitelist",
                  "type": "bool"
                },
                {
                  "name": "minKeyActionTimeLock",
                  "type": "uint256"
                },
                {
                  "name": "maxKeyActionTimeLock",
                  "type": "uint256"
                },
                {
                  "name": "defaultStaleBlocks",
                  "type": "uint256"
                },
                {
                  "name": "depositRewardsAsset",
                  "type": "address"
                },
                {
                  "name": "txFees",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "swapFee",
                      "type": "uint256"
                    },
                    {
                      "name": "stableSwapFee",
                      "type": "uint256"
                    },
                    {
                      "name": "rewardsFee",
                      "type": "uint256"
                    }
                  ]
                },
                {
                  "name": "ambassadorRevShare",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "swapRatio",
                      "type": "uint256"
                    },
                    {
                      "name": "rewardsRatio",
                      "type": "uint256"
                    },
                    {
                      "name": "yieldRatio",
                      "type": "uint256"
                    }
                  ]
                },
                {
                  "name": "defaultYieldMaxIncrease",
                  "type": "uint256"
                },
                {
                  "name": "defaultYieldPerformanceFee",
                  "type": "uint256"
                },
                {
                  "name": "defaultYieldAmbassadorBonusRatio",
                  "type": "uint256"
                },
                {
                  "name": "defaultYieldBonusRatio",
                  "type": "uint256"
                },
                {
                  "name": "defaultYieldAltBonusAsset",
                  "type": "address"
                },
                {
                  "name": "lootClaimCoolOffPeriod",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setManagerConfig",
          "inputs": [
            {
              "name": "_config",
              "type": "tuple",
              "components": [
                {
                  "name": "managerPeriod",
                  "type": "uint256"
                },
                {
                  "name": "managerActivationLength",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setPayeeConfig",
          "inputs": [
            {
              "name": "_config",
              "type": "tuple",
              "components": [
                {
                  "name": "payeePeriod",
                  "type": "uint256"
                },
                {
                  "name": "payeeActivationLength",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setChequeConfig",
          "inputs": [
            {
              "name": "_config",
              "type": "tuple",
              "components": [
                {
                  "name": "maxNumActiveCheques",
                  "type": "uint256"
                },
                {
                  "name": "instantUsdThreshold",
                  "type": "uint256"
                },
                {
                  "name": "periodLength",
                  "type": "uint256"
                },
                {
                  "name": "expensiveDelayBlocks",
                  "type": "uint256"
                },
                {
                  "name": "defaultExpiryBlocks",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUserWalletCreationConfig",
          "inputs": [
            {
              "name": "_creator",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "numUserWalletsAllowed",
                  "type": "uint256"
                },
                {
                  "name": "isCreatorAllowed",
                  "type": "bool"
                },
                {
                  "name": "walletTemplate",
                  "type": "address"
                },
                {
                  "name": "configTemplate",
                  "type": "address"
                },
                {
                  "name": "startingAgent",
                  "type": "address"
                },
                {
                  "name": "startingAgentActivationLength",
                  "type": "uint256"
                },
                {
                  "name": "managerPeriod",
                  "type": "uint256"
                },
                {
                  "name": "managerActivationLength",
                  "type": "uint256"
                },
                {
                  "name": "payeePeriod",
                  "type": "uint256"
                },
                {
                  "name": "payeeActivationLength",
                  "type": "uint256"
                },
                {
                  "name": "chequeMaxNumActiveCheques",
                  "type": "uint256"
                },
                {
                  "name": "chequeInstantUsdThreshold",
                  "type": "uint256"
                },
                {
                  "name": "chequePeriodLength",
                  "type": "uint256"
                },
                {
                  "name": "chequeExpensiveDelayBlocks",
                  "type": "uint256"
                },
                {
                  "name": "chequeDefaultExpiryBlocks",
                  "type": "uint256"
                },
                {
                  "name": "trialAsset",
                  "type": "address"
                },
                {
                  "name": "trialAmount",
                  "type": "uint256"
                },
                {
                  "name": "minKeyActionTimeLock",
                  "type": "uint256"
                },
                {
                  "name": "maxKeyActionTimeLock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLootDistroConfig",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "ambassador",
                  "type": "address"
                },
                {
                  "name": "ambassadorRevShare",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "swapRatio",
                      "type": "uint256"
                    },
                    {
                      "name": "rewardsRatio",
                      "type": "uint256"
                    },
                    {
                      "name": "yieldRatio",
                      "type": "uint256"
                    }
                  ]
                },
                {
                  "name": "ambassadorBonusRatio",
                  "type": "uint256"
                },
                {
                  "name": "bonusRatio",
                  "type": "uint256"
                },
                {
                  "name": "altBonusAsset",
                  "type": "address"
                },
                {
                  "name": "underlyingAsset",
                  "type": "address"
                },
                {
                  "name": "decimals",
                  "type": "uint256"
                },
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "legoAddr",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getDepositRewardsAsset",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLootClaimCoolOffPeriod",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setAgentConfig",
          "inputs": [
            {
              "name": "_config",
              "type": "tuple",
              "components": [
                {
                  "name": "agentTemplate",
                  "type": "address"
                },
                {
                  "name": "numAgentsAllowed",
                  "type": "uint256"
                },
                {
                  "name": "enforceCreatorWhitelist",
                  "type": "bool"
                },
                {
                  "name": "startingAgent",
                  "type": "address"
                },
                {
                  "name": "startingAgentActivationLength",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setStarterAgent",
          "inputs": [
            {
              "name": "_agent",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAgentCreationConfig",
          "inputs": [
            {
              "name": "_creator",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "agentTemplate",
                  "type": "address"
                },
                {
                  "name": "numAgentsAllowed",
                  "type": "uint256"
                },
                {
                  "name": "isCreatorAllowed",
                  "type": "bool"
                },
                {
                  "name": "minTimeLock",
                  "type": "uint256"
                },
                {
                  "name": "maxTimeLock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setAssetConfig",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_config",
              "type": "tuple",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "decimals",
                  "type": "uint256"
                },
                {
                  "name": "staleBlocks",
                  "type": "uint256"
                },
                {
                  "name": "txFees",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "swapFee",
                      "type": "uint256"
                    },
                    {
                      "name": "stableSwapFee",
                      "type": "uint256"
                    },
                    {
                      "name": "rewardsFee",
                      "type": "uint256"
                    }
                  ]
                },
                {
                  "name": "ambassadorRevShare",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "swapRatio",
                      "type": "uint256"
                    },
                    {
                      "name": "rewardsRatio",
                      "type": "uint256"
                    },
                    {
                      "name": "yieldRatio",
                      "type": "uint256"
                    }
                  ]
                },
                {
                  "name": "yieldConfig",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "isYieldAsset",
                      "type": "bool"
                    },
                    {
                      "name": "isRebasing",
                      "type": "bool"
                    },
                    {
                      "name": "underlyingAsset",
                      "type": "address"
                    },
                    {
                      "name": "maxYieldIncrease",
                      "type": "uint256"
                    },
                    {
                      "name": "performanceFee",
                      "type": "uint256"
                    },
                    {
                      "name": "ambassadorBonusRatio",
                      "type": "uint256"
                    },
                    {
                      "name": "bonusRatio",
                      "type": "uint256"
                    },
                    {
                      "name": "altBonusAsset",
                      "type": "address"
                    }
                  ]
                }
              ]
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setIsStablecoin",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_isStablecoin",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getProfitCalcConfig",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "legoAddr",
                  "type": "address"
                },
                {
                  "name": "decimals",
                  "type": "uint256"
                },
                {
                  "name": "staleBlocks",
                  "type": "uint256"
                },
                {
                  "name": "isYieldAsset",
                  "type": "bool"
                },
                {
                  "name": "isRebasing",
                  "type": "bool"
                },
                {
                  "name": "underlyingAsset",
                  "type": "address"
                },
                {
                  "name": "maxYieldIncrease",
                  "type": "uint256"
                },
                {
                  "name": "performanceFee",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssetUsdValueConfig",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "legoAddr",
                  "type": "address"
                },
                {
                  "name": "decimals",
                  "type": "uint256"
                },
                {
                  "name": "staleBlocks",
                  "type": "uint256"
                },
                {
                  "name": "isYieldAsset",
                  "type": "bool"
                },
                {
                  "name": "underlyingAsset",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getSwapFee",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRewardsFee",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setCanPerformSecurityAction",
          "inputs": [
            {
              "name": "_signer",
              "type": "address"
            },
            {
              "name": "_canPerform",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setCreatorWhitelist",
          "inputs": [
            {
              "name": "_creator",
              "type": "address"
            },
            {
              "name": "_isWhitelisted",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setLockedSigner",
          "inputs": [
            {
              "name": "_signer",
              "type": "address"
            },
            {
              "name": "_isLocked",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "userWalletConfig",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "walletTemplate",
                  "type": "address"
                },
                {
                  "name": "configTemplate",
                  "type": "address"
                },
                {
                  "name": "trialAsset",
                  "type": "address"
                },
                {
                  "name": "trialAmount",
                  "type": "uint256"
                },
                {
                  "name": "numUserWalletsAllowed",
                  "type": "uint256"
                },
                {
                  "name": "enforceCreatorWhitelist",
                  "type": "bool"
                },
                {
                  "name": "minKeyActionTimeLock",
                  "type": "uint256"
                },
                {
                  "name": "maxKeyActionTimeLock",
                  "type": "uint256"
                },
                {
                  "name": "defaultStaleBlocks",
                  "type": "uint256"
                },
                {
                  "name": "depositRewardsAsset",
                  "type": "address"
                },
                {
                  "name": "txFees",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "swapFee",
                      "type": "uint256"
                    },
                    {
                      "name": "stableSwapFee",
                      "type": "uint256"
                    },
                    {
                      "name": "rewardsFee",
                      "type": "uint256"
                    }
                  ]
                },
                {
                  "name": "ambassadorRevShare",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "swapRatio",
                      "type": "uint256"
                    },
                    {
                      "name": "rewardsRatio",
                      "type": "uint256"
                    },
                    {
                      "name": "yieldRatio",
                      "type": "uint256"
                    }
                  ]
                },
                {
                  "name": "defaultYieldMaxIncrease",
                  "type": "uint256"
                },
                {
                  "name": "defaultYieldPerformanceFee",
                  "type": "uint256"
                },
                {
                  "name": "defaultYieldAmbassadorBonusRatio",
                  "type": "uint256"
                },
                {
                  "name": "defaultYieldBonusRatio",
                  "type": "uint256"
                },
                {
                  "name": "defaultYieldAltBonusAsset",
                  "type": "address"
                },
                {
                  "name": "lootClaimCoolOffPeriod",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "agentConfig",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "agentTemplate",
                  "type": "address"
                },
                {
                  "name": "numAgentsAllowed",
                  "type": "uint256"
                },
                {
                  "name": "enforceCreatorWhitelist",
                  "type": "bool"
                },
                {
                  "name": "startingAgent",
                  "type": "address"
                },
                {
                  "name": "startingAgentActivationLength",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "managerConfig",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "managerPeriod",
                  "type": "uint256"
                },
                {
                  "name": "managerActivationLength",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "payeeConfig",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "payeePeriod",
                  "type": "uint256"
                },
                {
                  "name": "payeeActivationLength",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "chequeConfig",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "maxNumActiveCheques",
                  "type": "uint256"
                },
                {
                  "name": "instantUsdThreshold",
                  "type": "uint256"
                },
                {
                  "name": "periodLength",
                  "type": "uint256"
                },
                {
                  "name": "expensiveDelayBlocks",
                  "type": "uint256"
                },
                {
                  "name": "defaultExpiryBlocks",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assetConfig",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "decimals",
                  "type": "uint256"
                },
                {
                  "name": "staleBlocks",
                  "type": "uint256"
                },
                {
                  "name": "txFees",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "swapFee",
                      "type": "uint256"
                    },
                    {
                      "name": "stableSwapFee",
                      "type": "uint256"
                    },
                    {
                      "name": "rewardsFee",
                      "type": "uint256"
                    }
                  ]
                },
                {
                  "name": "ambassadorRevShare",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "swapRatio",
                      "type": "uint256"
                    },
                    {
                      "name": "rewardsRatio",
                      "type": "uint256"
                    },
                    {
                      "name": "yieldRatio",
                      "type": "uint256"
                    }
                  ]
                },
                {
                  "name": "yieldConfig",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "isYieldAsset",
                      "type": "bool"
                    },
                    {
                      "name": "isRebasing",
                      "type": "bool"
                    },
                    {
                      "name": "underlyingAsset",
                      "type": "address"
                    },
                    {
                      "name": "maxYieldIncrease",
                      "type": "uint256"
                    },
                    {
                      "name": "performanceFee",
                      "type": "uint256"
                    },
                    {
                      "name": "ambassadorBonusRatio",
                      "type": "uint256"
                    },
                    {
                      "name": "bonusRatio",
                      "type": "uint256"
                    },
                    {
                      "name": "altBonusAsset",
                      "type": "address"
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isStablecoin",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "creatorWhitelist",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canPerformSecurityAction",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isLockedSigner",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_undyHq",
              "type": "address"
            },
            {
              "name": "_defaults",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/modules/Addys.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\ninterface UndyHq:\n    def isValidAddr(_addr: address) -> bool: view\n    def getAddr(_regId: uint256) -> address: view\n    def undyToken() -> address: view\n\ninterface Switchboard:\n    def isSwitchboardAddr(_addr: address) -> bool: view\n\ninterface LegoBook:\n    def isLegoAddr(_addr: address) -> bool: view\n\nstruct Addys:\n    hq: address\n    undyToken: address\n    ledger: address\n    missionControl: address\n    legoBook: address\n    switchboard: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    walletBackpack: address\n    billing: address\n\n# hq\nUNDY_HQ_FOR_ADDYS: immutable(address)\n\n# core addys\nLEDGER_ID: constant(uint256) = 1\nMISSION_CONTROL_ID: constant(uint256) = 2\nLEGO_BOOK_ID: constant(uint256) = 3\nSWITCHBOARD_ID: constant(uint256) = 4\nHATCHERY_ID: constant(uint256) = 5\nLOOT_DISTRIBUTOR_ID: constant(uint256) = 6\nAPPRAISER_ID: constant(uint256) = 7\nWALLET_BACKPACK_ID: constant(uint256) = 8\nBILLING_ID: constant(uint256) = 9\n\n\n@deploy\ndef __init__(_undyHq: address):\n    assert _undyHq != empty(address) # dev: invalid undy hq\n    UNDY_HQ_FOR_ADDYS = _undyHq\n\n\n########\n# Core #\n########\n\n\n@view\n@external\ndef getAddys() -> Addys:\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _getAddys(_addys: Addys = empty(Addys)) -> Addys:\n    if _addys.hq != empty(address):\n        return _addys\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _generateAddys() -> Addys:\n    hq: address = UNDY_HQ_FOR_ADDYS\n    return Addys(\n        hq = hq,\n        undyToken = staticcall UndyHq(hq).undyToken(),\n        ledger = staticcall UndyHq(hq).getAddr(LEDGER_ID),\n        missionControl = staticcall UndyHq(hq).getAddr(MISSION_CONTROL_ID),\n        legoBook = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID),\n        switchboard = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID),\n        hatchery = staticcall UndyHq(hq).getAddr(HATCHERY_ID),\n        lootDistributor = staticcall UndyHq(hq).getAddr(LOOT_DISTRIBUTOR_ID),\n        appraiser = staticcall UndyHq(hq).getAddr(APPRAISER_ID),\n        walletBackpack = staticcall UndyHq(hq).getAddr(WALLET_BACKPACK_ID),\n        billing = staticcall UndyHq(hq).getAddr(BILLING_ID),\n    )\n\n\n##########\n# Tokens #\n##########\n\n\n@view\n@internal\ndef _getUndyToken() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).undyToken()\n\n\n###########\n# Helpers #\n###########\n\n\n# undy hq\n\n\n@view\n@external\ndef getUndyHq() -> address:\n    return self._getUndyHq()\n\n\n@view\n@internal\ndef _getUndyHq() -> address:\n    return UNDY_HQ_FOR_ADDYS\n\n\n# utils\n\n\n@view\n@internal\ndef _isValidUndyAddr(_addr: address, _hq: address = empty(address)) -> bool:\n    hq: address = _hq\n    if _hq == empty(address):\n        hq = UNDY_HQ_FOR_ADDYS\n    \n    # core departments\n    if staticcall UndyHq(hq).isValidAddr(_addr):\n        return True\n\n    # lego book\n    legoBook: address = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID)\n    if legoBook != empty(address) and staticcall LegoBook(legoBook).isLegoAddr(_addr):\n        return True\n\n    # switchboard config\n    switchboard: address = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID)\n    if switchboard != empty(address) and staticcall Switchboard(switchboard).isSwitchboardAddr(_addr):\n        return True\n\n    return False\n\n\n@view\n@internal\ndef _isSwitchboardAddr(_addr: address) -> bool:\n    switchboard: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n    if switchboard == empty(address):\n        return False\n    return staticcall Switchboard(switchboard).isSwitchboardAddr(_addr)\n\n\n@view\n@internal\ndef _isLegoBookAddr(_addr: address) -> bool:\n    legoBook: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n    if legoBook == empty(address):\n        return False\n    return staticcall LegoBook(legoBook).isLegoAddr(_addr)\n\n\n###############\n# Departments #\n###############\n\n\n# ledger\n\n\n@view\n@internal\ndef _getLedgerId() -> uint256:\n    return LEDGER_ID\n\n\n@view\n@internal\ndef _getLedgerAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEDGER_ID)\n\n\n# mission control\n\n\n@view\n@internal\ndef _getMissionControlId() -> uint256:\n    return MISSION_CONTROL_ID\n\n\n@view\n@internal\ndef _getMissionControlAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(MISSION_CONTROL_ID)\n\n\n# lego book\n\n\n@view\n@internal\ndef _getLegoBookId() -> uint256:\n    return LEGO_BOOK_ID\n\n\n@view\n@internal\ndef _getLegoBookAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n\n\n# switchboard\n\n\n@view\n@internal\ndef _getSwitchboardId() -> uint256:\n    return SWITCHBOARD_ID\n\n\n@view\n@internal\ndef _getSwitchboardAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n\n\n# hatchery\n\n\n@view\n@internal\ndef _getHatcheryId() -> uint256:\n    return HATCHERY_ID\n\n\n@view\n@internal\ndef _getHatcheryAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(HATCHERY_ID)\n\n\n# loot distributor\n\n\n@view\n@internal\ndef _getLootDistributorId() -> uint256:\n    return LOOT_DISTRIBUTOR_ID\n\n\n@view\n@internal\ndef _getLootDistributorAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LOOT_DISTRIBUTOR_ID)\n\n\n# appraiser\n\n\n@view\n@internal\ndef _getAppraiserId() -> uint256:\n    return APPRAISER_ID\n\n\n@view\n@internal\ndef _getAppraiserAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(APPRAISER_ID)\n\n\n# wallet backpack\n\n\n@view\n@internal\ndef _getWalletBackpackId() -> uint256:\n    return WALLET_BACKPACK_ID\n\n\n@view\n@internal\ndef _getWalletBackpackAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(WALLET_BACKPACK_ID)\n\n\n# billing\n\n\n@view\n@internal\ndef _getBillingId() -> uint256:\n    return BILLING_ID\n\n\n@view\n@internal\ndef _getBillingAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(BILLING_ID)",
            "sha256sum": "78b58f0b2acb2eaafa4d21adf9135a1cd0e1d53897f7a1fa70a83a04a7738ad3"
          },
          "interfaces/Department.vyi": {
            "content": "# @version 0.4.3\n\n\n###########\n# Minting #\n###########\n\n\n@view\n@external\ndef canMintUndy() -> bool:\n    # used in UndyHq.vy\n    ...\n\n\n########\n# Undy #\n########\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "53e48da591c4ee36045a8950c9d3a01458456b471b797df536e9a9f54404e721"
          },
          "contracts/modules/DeptBasics.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nuses: addys\nimplements: dept\n\nimport contracts.modules.Addys as addys\nimport interfaces.Department as dept\nfrom ethereum.ercs import IERC20\n\nevent DepartmentPauseModified:\n    isPaused: bool\n\nevent DepartmentFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    balance: uint256\n\nisPaused: public(bool)\n\nCAN_MINT_UNDY: immutable(bool)\nMAX_RECOVER_ASSETS: constant(uint256) = 20\n\n\n@deploy\ndef __init__(_shouldPause: bool, _canMintUndy: bool):\n    self.isPaused = _shouldPause\n    CAN_MINT_UNDY = _canMintUndy\n\n\n###########\n# Minting #\n###########\n\n\n@view\n@external\ndef canMintUndy() -> bool:\n    return CAN_MINT_UNDY\n\n\n########\n# Undy #\n########\n\n\n# activate\n\n\n@external\ndef pause(_shouldPause: bool):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert _shouldPause != self.isPaused # dev: no change\n    self.isPaused = _shouldPause\n    log DepartmentPauseModified(isPaused=_shouldPause)\n\n\n# recover funds\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    self._recoverFunds(_recipient, _asset)\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, MAX_RECOVER_ASSETS]):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    for a: address in _assets:\n        self._recoverFunds(_recipient, a)\n\n\n@internal\ndef _recoverFunds(_recipient: address, _asset: address):\n    assert empty(address) not in [_recipient, _asset] # dev: invalid recipient or asset\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    assert balance != 0 # dev: nothing to recover\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log DepartmentFundsRecovered(asset=_asset, recipient=_recipient, balance=balance)\n",
            "sha256sum": "976a50a3807bcf71f3f1c57de5cd7a59fe4e8f27b4d4560e774073962f44d1ac"
          },
          "interfaces/ConfigStructs.vyi": {
            "content": "# @version 0.4.3\n\nstruct UserWalletConfig:\n    walletTemplate: address\n    configTemplate: address\n    trialAsset: address\n    trialAmount: uint256\n    numUserWalletsAllowed: uint256\n    enforceCreatorWhitelist: bool\n    minKeyActionTimeLock: uint256\n    maxKeyActionTimeLock: uint256\n    defaultStaleBlocks: uint256\n    depositRewardsAsset: address\n    txFees: TxFees\n    ambassadorRevShare: AmbassadorRevShare\n    defaultYieldMaxIncrease: uint256\n    defaultYieldPerformanceFee: uint256\n    defaultYieldAmbassadorBonusRatio: uint256\n    defaultYieldBonusRatio: uint256\n    defaultYieldAltBonusAsset: address\n    lootClaimCoolOffPeriod: uint256\n\nstruct AssetConfig:\n    legoId: uint256\n    decimals: uint256\n    staleBlocks: uint256\n    txFees: TxFees\n    ambassadorRevShare: AmbassadorRevShare\n    yieldConfig: YieldConfig\n\nstruct TxFees:\n    swapFee: uint256\n    stableSwapFee: uint256\n    rewardsFee: uint256\n\nstruct AmbassadorRevShare:\n    swapRatio: uint256\n    rewardsRatio: uint256\n    yieldRatio: uint256\n\nstruct YieldConfig:\n    isYieldAsset: bool\n    isRebasing: bool\n    underlyingAsset: address\n    maxYieldIncrease: uint256\n    performanceFee: uint256\n    ambassadorBonusRatio: uint256\n    bonusRatio: uint256\n    altBonusAsset: address\n\nstruct AgentConfig:\n    agentTemplate: address\n    numAgentsAllowed: uint256\n    enforceCreatorWhitelist: bool\n    startingAgent: address\n    startingAgentActivationLength: uint256\n\nstruct ManagerConfig:\n    managerPeriod: uint256\n    managerActivationLength: uint256\n\nstruct PayeeConfig:\n    payeePeriod: uint256\n    payeeActivationLength: uint256\n\nstruct ChequeConfig:\n    maxNumActiveCheques: uint256\n    instantUsdThreshold: uint256\n    periodLength: uint256\n    expensiveDelayBlocks: uint256\n    defaultExpiryBlocks: uint256",
            "sha256sum": "5398a73269f73f958f8d644802e65a65f335cf33c46938d0e05eabad7bc8d45f"
          },
          "interfaces/Defaults.vyi": {
            "content": "# @version 0.4.3\n\nimport interfaces.ConfigStructs as cs\n\n\n@view\n@external\ndef userWalletConfig() -> cs.UserWalletConfig:\n    ...\n\n\n@view\n@external\ndef agentConfig() -> cs.AgentConfig:\n    ...\n\n\n@view\n@external\ndef managerConfig() -> cs.ManagerConfig:\n    ...\n\n\n@view\n@external\ndef payeeConfig() -> cs.PayeeConfig:\n    ...\n\n\n\n@view\n@external\ndef chequeConfig() -> cs.ChequeConfig:\n    ...",
            "sha256sum": "af8933730bc1e37f081fc6e575d68b86b6aba7307f7370677e68047fefcb7b23"
          },
          "contracts/data/MissionControl.vy": {
            "content": "#     _     _  __  __  _  ___  _         __   ___  _   ________  ___  _    \n#    | |\\/|| |( (`( (`| |/ / \\| |\\ |    / /` / / \\| |\\ || || |_)/ / \\| |   \n#    |_|  ||_|_)_)_)_)|_|\\_\\_/|_| \\|    \\_\\_,\\_\\_/|_| \\||_||_| \\\\_\\_/|_|__ \n#\n#     \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n#     \u2551  ** Mission Control **                             \u2551\n#     \u2551  Stores all configuration data for Underscore      \u2551\n#     \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n#\n#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nimplements: Department\n\nexports: addys.__interface__\nexports: deptBasics.__interface__\n\ninitializes: addys\ninitializes: deptBasics[addys := addys]\n\nimport contracts.modules.Addys as addys\nimport contracts.modules.DeptBasics as deptBasics\n\nfrom interfaces import Department\nimport interfaces.ConfigStructs as cs\nfrom interfaces import Defaults\n\n# helpers\n\nstruct UserWalletCreationConfig:\n    numUserWalletsAllowed: uint256\n    isCreatorAllowed: bool\n    walletTemplate: address\n    configTemplate: address\n    startingAgent: address\n    startingAgentActivationLength: uint256\n    managerPeriod: uint256\n    managerActivationLength: uint256\n    payeePeriod: uint256\n    payeeActivationLength: uint256\n    chequeMaxNumActiveCheques: uint256\n    chequeInstantUsdThreshold: uint256\n    chequePeriodLength: uint256\n    chequeExpensiveDelayBlocks: uint256\n    chequeDefaultExpiryBlocks: uint256\n    trialAsset: address\n    trialAmount: uint256\n    minKeyActionTimeLock: uint256\n    maxKeyActionTimeLock: uint256\n\nstruct AgentCreationConfig:\n    agentTemplate: address\n    numAgentsAllowed: uint256\n    isCreatorAllowed: bool\n    minTimeLock: uint256\n    maxTimeLock: uint256\n\nstruct AssetUsdValueConfig:\n    legoId: uint256\n    legoAddr: address\n    decimals: uint256\n    staleBlocks: uint256\n    isYieldAsset: bool\n    underlyingAsset: address\n\nstruct ProfitCalcConfig:\n    legoId: uint256\n    legoAddr: address\n    decimals: uint256\n    staleBlocks: uint256\n    isYieldAsset: bool\n    isRebasing: bool\n    underlyingAsset: address\n    maxYieldIncrease: uint256\n    performanceFee: uint256\n\nstruct LootDistroConfig:\n    ambassador: address\n    ambassadorRevShare: cs.AmbassadorRevShare\n    ambassadorBonusRatio: uint256\n    bonusRatio: uint256\n    altBonusAsset: address\n    underlyingAsset: address\n    decimals: uint256\n    legoId: uint256\n    legoAddr: address\n\n# global configs\nuserWalletConfig: public(cs.UserWalletConfig)\nagentConfig: public(cs.AgentConfig)\nmanagerConfig: public(cs.ManagerConfig)\npayeeConfig: public(cs.PayeeConfig)\nchequeConfig: public(cs.ChequeConfig)\n\n# asset config\nassetConfig: public(HashMap[address, cs.AssetConfig])\nisStablecoin: public(HashMap[address, bool])\n\n# security / limits\ncreatorWhitelist: public(HashMap[address, bool]) # creator -> is whitelisted\ncanPerformSecurityAction: public(HashMap[address, bool]) # signer -> can perform security action\nisLockedSigner: public(HashMap[address, bool]) # signer -> is locked\n\n\n@deploy\ndef __init__(_undyHq: address, _defaults: address):\n    addys.__init__(_undyHq)\n    deptBasics.__init__(False, False) # no minting\n\n    if _defaults != empty(address):\n        self.userWalletConfig = staticcall Defaults(_defaults).userWalletConfig()\n        self.agentConfig = staticcall Defaults(_defaults).agentConfig()\n        self.managerConfig = staticcall Defaults(_defaults).managerConfig()\n        self.payeeConfig = staticcall Defaults(_defaults).payeeConfig()\n        self.chequeConfig = staticcall Defaults(_defaults).chequeConfig()\n\n\n######################\n# User Wallet Config #\n######################\n\n\n@external\ndef setUserWalletConfig(_config: cs.UserWalletConfig):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert not deptBasics.isPaused # dev: not activated\n    self.userWalletConfig = _config\n\n\n@external\ndef setManagerConfig(_config: cs.ManagerConfig):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert not deptBasics.isPaused # dev: not activated\n    self.managerConfig = _config\n\n\n@external\ndef setPayeeConfig(_config: cs.PayeeConfig):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert not deptBasics.isPaused # dev: not activated\n    self.payeeConfig = _config\n\n\n@external\ndef setChequeConfig(_config: cs.ChequeConfig):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert not deptBasics.isPaused # dev: not activated\n    self.chequeConfig = _config\n\n\n# helper\n\n\n@view\n@external\ndef getUserWalletCreationConfig(_creator: address) -> UserWalletCreationConfig:\n    config: cs.UserWalletConfig = self.userWalletConfig\n    managerConfig: cs.ManagerConfig = self.managerConfig\n    payeeConfig: cs.PayeeConfig = self.payeeConfig\n    agentConfig: cs.AgentConfig = self.agentConfig\n    chequeConfig: cs.ChequeConfig = self.chequeConfig\n    return UserWalletCreationConfig(\n        numUserWalletsAllowed = config.numUserWalletsAllowed,\n        isCreatorAllowed = self._isCreatorAllowed(config.enforceCreatorWhitelist, _creator),\n        walletTemplate = config.walletTemplate,\n        configTemplate = config.configTemplate,\n        startingAgent = agentConfig.startingAgent,\n        startingAgentActivationLength = agentConfig.startingAgentActivationLength,\n        managerPeriod = managerConfig.managerPeriod,\n        managerActivationLength = managerConfig.managerActivationLength,\n        payeePeriod = payeeConfig.payeePeriod,\n        payeeActivationLength = payeeConfig.payeeActivationLength,\n        chequeMaxNumActiveCheques = chequeConfig.maxNumActiveCheques,\n        chequeInstantUsdThreshold = chequeConfig.instantUsdThreshold,\n        chequePeriodLength = chequeConfig.periodLength,\n        chequeExpensiveDelayBlocks = chequeConfig.expensiveDelayBlocks,\n        chequeDefaultExpiryBlocks = chequeConfig.defaultExpiryBlocks,\n        trialAsset = config.trialAsset,\n        trialAmount = config.trialAmount,\n        minKeyActionTimeLock = config.minKeyActionTimeLock,\n        maxKeyActionTimeLock = config.maxKeyActionTimeLock,\n    )\n\n\n@view\n@external\ndef getLootDistroConfig(_asset: address) -> LootDistroConfig:\n    assetConfig: cs.AssetConfig = self.assetConfig[_asset]\n\n    ambassadorRevShare: cs.AmbassadorRevShare = assetConfig.ambassadorRevShare\n    ambassadorBonusRatio: uint256 = assetConfig.yieldConfig.ambassadorBonusRatio\n    bonusRatio: uint256 = assetConfig.yieldConfig.bonusRatio\n    altBonusAsset: address = assetConfig.yieldConfig.altBonusAsset\n    if assetConfig.decimals == 0:\n        walletConfig: cs.UserWalletConfig = self.userWalletConfig\n        ambassadorRevShare = walletConfig.ambassadorRevShare\n        ambassadorBonusRatio = walletConfig.defaultYieldAmbassadorBonusRatio\n        bonusRatio = walletConfig.defaultYieldBonusRatio\n        altBonusAsset = walletConfig.defaultYieldAltBonusAsset\n\n    return LootDistroConfig(\n        ambassador = empty(address),\n        ambassadorRevShare = ambassadorRevShare,\n        ambassadorBonusRatio = ambassadorBonusRatio,\n        bonusRatio = bonusRatio,\n        altBonusAsset = altBonusAsset,\n        underlyingAsset = assetConfig.yieldConfig.underlyingAsset,\n        decimals = assetConfig.decimals,\n        legoId = assetConfig.legoId,\n        legoAddr = empty(address),\n    )\n\n\n@view\n@external\ndef getDepositRewardsAsset() -> address:\n    return self.userWalletConfig.depositRewardsAsset\n\n\n@view\n@external\ndef getLootClaimCoolOffPeriod() -> uint256:\n    return self.userWalletConfig.lootClaimCoolOffPeriod\n\n\n################\n# Agent Config #\n################\n\n\n@external\ndef setAgentConfig(_config: cs.AgentConfig):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert not deptBasics.isPaused # dev: not activated\n    self.agentConfig = _config\n\n\n@external\ndef setStarterAgent(_agent: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert not deptBasics.isPaused # dev: not activated\n    self.agentConfig.startingAgent = _agent\n\n\n# helper\n\n\n@view\n@external\ndef getAgentCreationConfig(_creator: address) -> AgentCreationConfig:\n    config: cs.AgentConfig = self.agentConfig\n    userConfig: cs.UserWalletConfig = self.userWalletConfig\n    return AgentCreationConfig(\n        agentTemplate = config.agentTemplate,\n        numAgentsAllowed = config.numAgentsAllowed,\n        isCreatorAllowed = self._isCreatorAllowed(config.enforceCreatorWhitelist, _creator),\n        minTimeLock = userConfig.minKeyActionTimeLock,\n        maxTimeLock = userConfig.maxKeyActionTimeLock,\n    )\n\n\n########################\n# Asset / Yield Config #\n########################\n\n\n@external\ndef setAssetConfig(_asset: address, _config: cs.AssetConfig):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert not deptBasics.isPaused # dev: not activated\n    self.assetConfig[_asset] = _config\n\n\n@external\ndef setIsStablecoin(_asset: address, _isStablecoin: bool):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert not deptBasics.isPaused # dev: not activated\n    self.isStablecoin[_asset] = _isStablecoin\n\n\n# helpers\n\n\n@view\n@external\ndef getProfitCalcConfig(_asset: address) -> ProfitCalcConfig:\n    assetConfig: cs.AssetConfig = self.assetConfig[_asset]\n\n    staleBlocks: uint256 = assetConfig.staleBlocks\n    maxYieldIncrease: uint256 = assetConfig.yieldConfig.maxYieldIncrease\n    performanceFee: uint256 = assetConfig.yieldConfig.performanceFee\n    if assetConfig.decimals == 0:\n        walletConfig: cs.UserWalletConfig = self.userWalletConfig\n        staleBlocks = walletConfig.defaultStaleBlocks\n        maxYieldIncrease = walletConfig.defaultYieldMaxIncrease\n        performanceFee = walletConfig.defaultYieldPerformanceFee\n\n    return ProfitCalcConfig(\n        legoId = assetConfig.legoId,\n        legoAddr = empty(address),\n        decimals = assetConfig.decimals,\n        staleBlocks = staleBlocks,\n        isYieldAsset = assetConfig.yieldConfig.isYieldAsset,\n        isRebasing = assetConfig.yieldConfig.isRebasing,\n        underlyingAsset = assetConfig.yieldConfig.underlyingAsset,\n        maxYieldIncrease = maxYieldIncrease,\n        performanceFee = performanceFee,\n    )\n\n\n@view\n@external\ndef getAssetUsdValueConfig(_asset: address) -> AssetUsdValueConfig:\n    assetConfig: cs.AssetConfig = self.assetConfig[_asset]\n\n    staleBlocks: uint256 = assetConfig.staleBlocks\n    if assetConfig.decimals == 0:\n        staleBlocks = self.userWalletConfig.defaultStaleBlocks\n\n    return AssetUsdValueConfig(\n        legoId = assetConfig.legoId,\n        legoAddr = empty(address),\n        decimals = assetConfig.decimals,\n        staleBlocks = staleBlocks,\n        isYieldAsset = assetConfig.yieldConfig.isYieldAsset,\n        underlyingAsset = assetConfig.yieldConfig.underlyingAsset,\n    )\n\n\n@view\n@external\ndef getSwapFee(_tokenIn: address, _tokenOut: address) -> uint256:\n\n    # stable swap fee\n    if self.isStablecoin[_tokenIn] and self.isStablecoin[_tokenOut]:\n        return self.userWalletConfig.txFees.stableSwapFee\n\n    # asset swap fee takes precedence over global swap fee\n    outConfig: cs.AssetConfig = self.assetConfig[_tokenOut]\n    if outConfig.decimals != 0:\n        return outConfig.txFees.swapFee\n\n    return self.userWalletConfig.txFees.swapFee\n\n\n@view\n@external\ndef getRewardsFee(_asset: address) -> uint256:\n    config: cs.AssetConfig = self.assetConfig[_asset]\n    if config.decimals != 0:\n        return config.txFees.rewardsFee\n    return self.userWalletConfig.txFees.rewardsFee\n\n\n#########\n# Other #\n#########\n\n\n# can perform security action\n\n\n@external\ndef setCanPerformSecurityAction(_signer: address, _canPerform: bool):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert not deptBasics.isPaused # dev: not activated\n    self.canPerformSecurityAction[_signer] = _canPerform\n\n\n# creator whitelist\n\n\n@external\ndef setCreatorWhitelist(_creator: address, _isWhitelisted: bool):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert not deptBasics.isPaused # dev: not activated\n    self.creatorWhitelist[_creator] = _isWhitelisted\n\n\n# locked signer\n\n\n@external\ndef setLockedSigner(_signer: address, _isLocked: bool):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert not deptBasics.isPaused # dev: not activated\n    self.isLockedSigner[_signer] = _isLocked\n\n\n#########\n# Utils #\n#########\n\n\n@view\n@internal\ndef _isCreatorAllowed(_shouldEnforceWhitelist: bool, _creator: address) -> bool:\n    if _shouldEnforceWhitelist:\n        return self.creatorWhitelist[_creator]\n    return True",
            "sha256sum": "41cb8059eedd4818bd601abdf0f1d7aba6372ff9c515f8ea1c03b270b3e7730f"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/data/MissionControl.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.3+commit.bff19ea2",
        "integrity": "cb25e787b1e221ae86833e62047ef8a51c92ef5452374a923c723109fd6ddbde"
      },
      "args": "00000000000000000000000044cf3c4f000dfd76a35d03298049d37be688d6f900000000000000000000000033df7433caa93277f06561b8a3cee1fa324fbde6",
      "file": "contracts/data/MissionControl.vy"
    },
    "LegoBook": {
      "address": "0xEaf30ef8a98055981a67222E9088b4dE90B0924A",
      "abi": [
        {
          "name": "LegoToolsSet",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeTimeLockModified",
          "inputs": [
            {
              "name": "prevTimeLock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "newTimeLock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "RegistryTimeLockModified",
          "inputs": [
            {
              "name": "newTimeLock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "prevTimeLock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeStarted",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeConfirmed",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeCancelled",
          "inputs": [
            {
              "name": "cancelledGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovRelinquished",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UndyHqSetupFinished",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "timeLock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "DepartmentPauseModified",
          "inputs": [
            {
              "name": "isPaused",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "DepartmentFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "balance",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "NewAddressPending",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "NewAddressConfirmed",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "regId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "NewAddressCancelled",
          "inputs": [
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddressUpdatePending",
          "inputs": [
            {
              "name": "regId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "newAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "prevAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "version",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddressUpdateConfirmed",
          "inputs": [
            {
              "name": "regId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "newAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "prevAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "version",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddressUpdateCancelled",
          "inputs": [
            {
              "name": "regId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "newAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "prevAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddressDisablePending",
          "inputs": [
            {
              "name": "regId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "version",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddressDisableConfirmed",
          "inputs": [
            {
              "name": "regId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "version",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddressDisableCancelled",
          "inputs": [
            {
              "name": "regId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUndyHqFromGov",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canGovern",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getGovernors",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPendingGovChange",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "startGovernanceChange",
          "inputs": [
            {
              "name": "_newGov",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "relinquishGov",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setGovTimeLock",
          "inputs": [
            {
              "name": "_numBlocks",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidGovTimeLock",
          "inputs": [
            {
              "name": "_newTimeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "minGovChangeTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "maxGovChangeTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "finishUndyHqSetup",
          "inputs": [
            {
              "name": "_newGov",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "finishUndyHqSetup",
          "inputs": [
            {
              "name": "_newGov",
              "type": "address"
            },
            {
              "name": "_timeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "governance",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingGov",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "newGov",
                  "type": "address"
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numGovChanges",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "govChangeTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRegistryDescription",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "string"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidNewAddress",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidAddressUpdate",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            },
            {
              "name": "_newAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidAddressDisable",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setRegistryTimeLock",
          "inputs": [
            {
              "name": "_numBlocks",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidRegistryTimeLock",
          "inputs": [
            {
              "name": "_numBlocks",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setRegistryTimeLockAfterSetup",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setRegistryTimeLockAfterSetup",
          "inputs": [
            {
              "name": "_numBlocks",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "minRegistryTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "maxRegistryTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidAddr",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidRegId",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRegId",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddr",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddrInfo",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "addr",
                  "type": "address"
                },
                {
                  "name": "version",
                  "type": "uint256"
                },
                {
                  "name": "lastModified",
                  "type": "uint256"
                },
                {
                  "name": "description",
                  "type": "string"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddrDescription",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "string"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getNumAddrs",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLastAddr",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLastRegId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "registryChangeTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "addrInfo",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "addr",
                  "type": "address"
                },
                {
                  "name": "version",
                  "type": "uint256"
                },
                {
                  "name": "lastModified",
                  "type": "uint256"
                },
                {
                  "name": "description",
                  "type": "string"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "addrToRegId",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAddrs",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingNewAddr",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "description",
                  "type": "string"
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingAddrUpdate",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "newAddr",
                  "type": "address"
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingAddrDisable",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddys",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "undyToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "hatchery",
                  "type": "address"
                },
                {
                  "name": "lootDistributor",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                },
                {
                  "name": "walletBackpack",
                  "type": "address"
                },
                {
                  "name": "billing",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUndyHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canMintUndy",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pause",
          "inputs": [
            {
              "name": "_shouldPause",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFundsMany",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_assets",
              "type": "address[]"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isPaused",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isLegoAddr",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "startAddNewAddressToRegistry",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            },
            {
              "name": "_description",
              "type": "string"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmNewAddressToRegistry",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelNewAddressToRegistry",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "startAddressUpdateToRegistry",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            },
            {
              "name": "_newAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmAddressUpdateToRegistry",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelAddressUpdateToRegistry",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "startAddressDisableInRegistry",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmAddressDisableInRegistry",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelAddressDisableInRegistry",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setLegoTools",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidLegoTools",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "legoTools",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_undyHq",
              "type": "address"
            },
            {
              "name": "_minRegistryTimeLock",
              "type": "uint256"
            },
            {
              "name": "_maxRegistryTimeLock",
              "type": "uint256"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/modules/LocalGov.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\ninterface UndyHq:\n    def minGovChangeTimeLock() -> uint256: view\n    def maxGovChangeTimeLock() -> uint256: view\n    def governance() -> address: view\n\nstruct PendingGovernance:\n    newGov: address\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeStarted:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    confirmBlock: uint256\n\nevent GovChangeConfirmed:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeCancelled:\n    cancelledGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovRelinquished:\n    prevGov: indexed(address)\n\nevent GovChangeTimeLockModified:\n    prevTimeLock: uint256\n    newTimeLock: uint256\n\nevent UndyHqSetupFinished:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    timeLock: uint256\n\n# governance\ngovernance: public(address)\npendingGov: public(PendingGovernance)\nnumGovChanges: public(uint256)\n\n# time lock\ngovChangeTimeLock: public(uint256)\n\n# config\nUNDY_HQ_FOR_GOV: immutable(address)\nMIN_GOV_TIME_LOCK: immutable(uint256)\nMAX_GOV_TIME_LOCK: immutable(uint256)\n\n\n@deploy\ndef __init__(\n    _undyHq: address,\n    _initialGov: address,\n    _minTimeLock: uint256,\n    _maxTimeLock: uint256,\n    _initialTimeLock: uint256,\n):\n    UNDY_HQ_FOR_GOV = _undyHq\n    self.governance = _initialGov\n\n    # undy hq\n    if _undyHq == empty(address):\n        assert _initialGov != empty(address) # dev: undy hq must have gov\n\n    # local gov (department, other smart contracts)\n    else:\n        hqGov: address = staticcall UndyHq(_undyHq).governance()\n        assert hqGov != empty(address) # dev: undy hq must have gov\n        assert _initialGov != hqGov # dev: undy hq cannot set same gov\n\n    # time locks\n    minTimeLock: uint256 = _minTimeLock\n    maxTimeLock: uint256 = _maxTimeLock\n    if minTimeLock == 0 or maxTimeLock == 0:\n        assert _undyHq != empty(address) # dev: need undy hq if no time locks\n        minTimeLock = staticcall UndyHq(_undyHq).minGovChangeTimeLock()\n        maxTimeLock = staticcall UndyHq(_undyHq).maxGovChangeTimeLock()\n\n    # set min and max time locks\n    assert minTimeLock < maxTimeLock # dev: invalid time lock\n    assert minTimeLock != 0 and maxTimeLock != max_value(uint256) # dev: invalid time lock\n    MIN_GOV_TIME_LOCK = minTimeLock\n    MAX_GOV_TIME_LOCK = maxTimeLock\n\n    # this contract is top level governance from Undy HQ -- not setting initial time lock during setup\n    if _undyHq == empty(address):\n        return\n\n    # set initial time lock (for local gov)\n    initialTimeLock: uint256 = max(minTimeLock, _initialTimeLock)\n    assert self._setGovTimeLock(initialTimeLock) # dev: invalid time lock\n\n\n@view\n@external\ndef getUndyHqFromGov() -> address:\n    return self._getUndyHqFromGov()\n\n\n@view\n@internal\ndef _getUndyHqFromGov() -> address:\n    return UNDY_HQ_FOR_GOV\n\n\n##############\n# Gov Access #\n##############\n\n\n@view\n@external\ndef canGovern(_addr: address) -> bool:\n    return self._canGovern(_addr)\n\n\n@view\n@internal\ndef _canGovern(_addr: address) -> bool:\n    if _addr == empty(address):\n        return False\n    return _addr in self._getGovernors()\n\n\n@view\n@external\ndef getGovernors() -> DynArray[address, 2]:\n    return self._getGovernors()\n\n\n@view\n@internal\ndef _getGovernors() -> DynArray[address, 2]:\n    governors: DynArray[address, 2] = []\n\n    # local governance\n    localGov: address = self.governance\n    if localGov != empty(address):\n        governors.append(localGov)\n\n    # undy hq governance\n    undyHq: address = UNDY_HQ_FOR_GOV\n    if undyHq == empty(address):\n        return governors\n\n    hqGov: address = staticcall UndyHq(undyHq).governance()\n    if hqGov != empty(address):\n        governors.append(hqGov)\n\n    return governors\n\n\n######################\n# Governance Changes #\n######################\n\n\n@view\n@external\ndef hasPendingGovChange() -> bool:\n    return self.pendingGov.confirmBlock != 0\n\n\n@view\n@internal\ndef _isUndyHq() -> bool:\n    return UNDY_HQ_FOR_GOV == empty(address)\n\n\n# start gov change\n\n\n@external\ndef startGovernanceChange(_newGov: address):\n    governors: DynArray[address, 2] = self._getGovernors()\n    assert msg.sender in governors # dev: no perms\n\n    # validation\n    if _newGov != empty(address):\n        assert _newGov not in governors # dev: invalid _newGov\n        assert _newGov.is_contract # dev: _newGov must be a contract\n    else:\n        assert not self._isUndyHq() # dev: undy hq cannot set 0x0\n\n    confirmBlock: uint256 = block.number + self.govChangeTimeLock\n    self.pendingGov = PendingGovernance(\n        newGov= _newGov,\n        initiatedBlock= block.number,\n        confirmBlock= confirmBlock,\n    )\n    log GovChangeStarted(prevGov=self.governance, newGov=_newGov, confirmBlock=confirmBlock)\n\n\n# confirm gov change\n\n\n@external\ndef confirmGovernanceChange():\n    data: PendingGovernance = self.pendingGov\n    assert data.confirmBlock != 0 and block.number >= data.confirmBlock # dev: time lock not reached\n\n    # check permissions\n    if data.newGov != empty(address):\n        assert msg.sender == data.newGov # dev: only new gov can confirm\n    else:\n        assert self._canGovern(msg.sender) # dev: no perms\n        assert not self._isUndyHq() # dev: undy hq cannot set 0x0\n\n    # set new governance\n    prevGov: address = self.governance\n    self.governance = data.newGov\n    self.numGovChanges += 1\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeConfirmed(prevGov=prevGov, newGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n# cancel gov change\n\n\n@external\ndef cancelGovernanceChange():\n    assert self._canGovern(msg.sender) # dev: no perms\n    data: PendingGovernance = self.pendingGov\n    assert data.confirmBlock != 0 # dev: no pending change\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeCancelled(cancelledGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n# relinquish gov (only for local gov)\n\n\n@external\ndef relinquishGov():\n    assert msg.sender == self.governance # dev: no perms\n    assert not self._isUndyHq() # dev: undy hq cannot relinquish gov\n\n    self.governance = empty(address)\n    self.numGovChanges += 1\n    log GovRelinquished(prevGov=msg.sender)\n\n\n####################\n# Time Lock Config #\n####################\n\n\n# set time lock\n\n\n@external\ndef setGovTimeLock(_numBlocks: uint256) -> bool:\n    assert self._canGovern(msg.sender) # dev: no perms\n    return self._setGovTimeLock(_numBlocks)\n\n\n@internal\ndef _setGovTimeLock(_numBlocks: uint256) -> bool:\n    prevTimeLock: uint256 = self.govChangeTimeLock\n    assert self._isValidGovTimeLock(_numBlocks, prevTimeLock) # dev: invalid time lock\n    self.govChangeTimeLock = _numBlocks\n    log GovChangeTimeLockModified(prevTimeLock=prevTimeLock, newTimeLock=_numBlocks)\n    return True\n\n\n# validation\n\n\n@view\n@external\ndef isValidGovTimeLock(_newTimeLock: uint256) -> bool:\n    return self._isValidGovTimeLock(_newTimeLock, self.govChangeTimeLock)\n\n\n@view\n@internal\ndef _isValidGovTimeLock(_newTimeLock: uint256, _prevTimeLock: uint256) -> bool:\n    if _newTimeLock == _prevTimeLock:\n        return False # no change\n    if self.pendingGov.confirmBlock != 0:\n        return False # cannot change while pending gov change\n    return _newTimeLock >= MIN_GOV_TIME_LOCK and _newTimeLock <= MAX_GOV_TIME_LOCK\n\n\n# utils\n\n\n@view\n@external\ndef minGovChangeTimeLock() -> uint256:\n    return MIN_GOV_TIME_LOCK\n\n\n@view\n@external\ndef maxGovChangeTimeLock() -> uint256:\n    return MAX_GOV_TIME_LOCK\n\n\n#################\n# Undy Hq Setup #\n#################\n\n\n@external\ndef finishUndyHqSetup(_newGov: address, _timeLock: uint256 = 0) -> bool:\n    assert self._isUndyHq() # dev: only undy hq\n    assert msg.sender == self.governance # dev: no perms\n    assert self.numGovChanges == 0 # dev: already changed gov\n\n    # validation\n    assert _newGov != empty(address) and _newGov.is_contract # dev: invalid _newGov\n    prevGov: address = self.governance\n\n    # set new gov\n    self.governance = _newGov\n    self.numGovChanges += 1\n\n    # set time lock\n    timeLock: uint256 = _timeLock\n    if timeLock == 0:\n        timeLock = MIN_GOV_TIME_LOCK\n    assert self._setGovTimeLock(timeLock) # dev: invalid time lock\n\n    log UndyHqSetupFinished(prevGov=prevGov, newGov=_newGov, timeLock=timeLock)\n    return True",
            "sha256sum": "c41aa3e0d0d96b512171813377ea277e2c7da690c3cd9b4662733b3f11f705b0"
          },
          "contracts/modules/AddressRegistry.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nuses: gov\nimport contracts.modules.LocalGov as gov\n\nstruct AddressInfo:\n    addr: address\n    version: uint256\n    lastModified: uint256\n    description: String[64]\n\nstruct PendingNewAddress:\n    description: String[64]\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nstruct PendingAddressUpdate:\n    newAddr: address\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nstruct PendingAddressDisable:\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent NewAddressPending:\n    addr: indexed(address)\n    description: String[64]\n    confirmBlock: uint256\n    registry: String[28]\n\nevent NewAddressConfirmed:\n    addr: indexed(address)\n    regId: uint256\n    description: String[64]\n    registry: String[28]\n\nevent NewAddressCancelled:\n    description: String[64]\n    addr: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n    registry: String[28]\n\nevent AddressUpdatePending:\n    regId: uint256\n    description: String[64]\n    newAddr: indexed(address)\n    prevAddr: indexed(address)\n    version: uint256\n    confirmBlock: uint256\n    registry: String[28]\n\nevent AddressUpdateConfirmed:\n    regId: uint256\n    description: String[64]\n    newAddr: indexed(address)\n    prevAddr: indexed(address)\n    version: uint256\n    registry: String[28]\n\nevent AddressUpdateCancelled:\n    regId: uint256\n    description: String[64]\n    newAddr: indexed(address)\n    prevAddr: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n    registry: String[28]\n\nevent AddressDisablePending:\n    regId: uint256\n    description: String[64]\n    addr: indexed(address)\n    version: uint256\n    confirmBlock: uint256\n    registry: String[28]\n\nevent AddressDisableConfirmed:\n    regId: uint256\n    description: String[64]\n    addr: indexed(address)\n    version: uint256\n    registry: String[28]\n\nevent AddressDisableCancelled:\n    regId: uint256\n    description: String[64]\n    addr: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n    registry: String[28]\n\nevent RegistryTimeLockModified:\n    newTimeLock: uint256\n    prevTimeLock: uint256\n    registry: String[28]\n\n# time lock\nregistryChangeTimeLock: public(uint256)\n\n# core data (address registry)\naddrInfo: public(HashMap[uint256, AddressInfo]) # regId -> address info\naddrToRegId: public(HashMap[address, uint256]) # addr -> regId\nnumAddrs: public(uint256) # number of addrs in registry\n\n# pending changes\npendingNewAddr: public(HashMap[address, PendingNewAddress]) # addr -> pending new addr\npendingAddrUpdate: public(HashMap[uint256, PendingAddressUpdate]) # regId -> pending addr update\npendingAddrDisable: public(HashMap[uint256, PendingAddressDisable]) # regId -> pending addr disable\n\nREGISTRY_STR: immutable(String[28])\nMIN_REG_TIME_LOCK: immutable(uint256)\nMAX_REG_TIME_LOCK: immutable(uint256)\n\n\n@deploy\ndef __init__(\n    _minTimeLock: uint256,\n    _maxTimeLock: uint256,\n    _initialTimeLock: uint256,\n    _registryStr: String[28],\n):\n    REGISTRY_STR = _registryStr\n\n    assert _minTimeLock < _maxTimeLock # dev: invalid time lock\n    assert _minTimeLock != 0 and _maxTimeLock != max_value(uint256) # dev: invalid time lock\n    MIN_REG_TIME_LOCK = _minTimeLock\n    MAX_REG_TIME_LOCK = _maxTimeLock\n\n    # set initial time lock -- this may be zero during inital setup of registry\n    if _initialTimeLock != 0:\n        assert self._setRegistryTimeLock(_initialTimeLock) # dev: invalid time lock\n\n    # start at 1 index\n    self.numAddrs = 1\n\n\n@view\n@external\ndef getRegistryDescription() -> String[28]:\n    return REGISTRY_STR\n\n\n###############\n# New Address #\n###############\n\n\n# register new address\n\n\n@internal\ndef _startAddNewAddressToRegistry(_addr: address, _description: String[64]) -> bool:\n    assert self._isValidNewAddress(_addr) # dev: invalid addy\n\n    confirmBlock: uint256 = block.number + self.registryChangeTimeLock\n    self.pendingNewAddr[_addr] = PendingNewAddress(\n        description=_description,\n        initiatedBlock=block.number,\n        confirmBlock=confirmBlock,\n    )\n\n    log NewAddressPending(addr=_addr, description=_description, confirmBlock=confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n# confirm new address\n\n\n@internal\ndef _confirmNewAddressToRegistry(_addr: address) -> uint256:\n    data: PendingNewAddress = self.pendingNewAddr[_addr]\n    assert data.confirmBlock != 0 and block.number >= data.confirmBlock # dev: time lock not reached\n\n    if not self._isValidNewAddress(_addr):\n        self.pendingNewAddr[_addr] = empty(PendingNewAddress) # clear pending\n        return 0\n\n    # register new addy\n    regId: uint256 = self.numAddrs\n    self.addrToRegId[_addr] = regId\n    self.numAddrs = regId + 1\n    self.addrInfo[regId] = AddressInfo(\n        addr=_addr,\n        version=1,\n        lastModified=block.timestamp,\n        description=data.description,\n    )\n\n    # clear pending\n    self.pendingNewAddr[_addr] = empty(PendingNewAddress)\n\n    log NewAddressConfirmed(addr=_addr, regId=regId, description=data.description, registry=REGISTRY_STR)\n    return regId\n\n\n# cancel new address\n\n\n@internal\ndef _cancelNewAddressToRegistry(_addr: address) -> bool:\n    data: PendingNewAddress = self.pendingNewAddr[_addr]\n    assert data.confirmBlock != 0 # dev: no pending\n\n    self.pendingNewAddr[_addr] = empty(PendingNewAddress)\n    log NewAddressCancelled(description=data.description, addr=_addr, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n# validation\n\n\n@view\n@external\ndef isValidNewAddress(_addr: address) -> bool:\n    return self._isValidNewAddress(_addr)\n\n\n@view\n@internal\ndef _isValidNewAddress(_addr: address) -> bool:\n    if _addr == empty(address) or not _addr.is_contract:\n        return False\n    return self.addrToRegId[_addr] == 0\n\n\n###################\n# Address Updates #\n###################\n\n\n# update address\n\n\n@internal\ndef _startAddressUpdateToRegistry(_regId: uint256, _newAddr: address) -> bool:\n    data: AddressInfo = self.addrInfo[_regId]\n    assert self._isValidAddressUpdate(_regId, _newAddr, data.addr) # dev: invalid update\n\n    # set pending\n    confirmBlock: uint256 = block.number + self.registryChangeTimeLock\n    self.pendingAddrUpdate[_regId] = PendingAddressUpdate(\n        newAddr=_newAddr,\n        initiatedBlock=block.number,\n        confirmBlock=confirmBlock,\n    )\n\n    log AddressUpdatePending(regId=_regId, description=data.description, newAddr=_newAddr, prevAddr=data.addr, version=data.version, confirmBlock=confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n# confirm update address\n\n\n@internal\ndef _confirmAddressUpdateToRegistry(_regId: uint256) -> bool:\n    newData: PendingAddressUpdate = self.pendingAddrUpdate[_regId]\n    assert newData.confirmBlock != 0 and block.number >= newData.confirmBlock # dev: time lock not reached\n\n    data: AddressInfo = self.addrInfo[_regId]\n    prevAddr: address = data.addr # needed for later\n    if not self._isValidAddressUpdate(_regId, newData.newAddr, prevAddr):\n        self.pendingAddrUpdate[_regId] = empty(PendingAddressUpdate) # clear pending\n        return False\n\n    # update addy data\n    data.addr = newData.newAddr\n    data.lastModified = block.timestamp\n    data.version += 1\n    self.addrInfo[_regId] = data\n    self.addrToRegId[newData.newAddr] = _regId\n\n    # handle previous addr\n    if prevAddr != empty(address):\n        self.addrToRegId[prevAddr] = 0\n\n    # clear pending\n    self.pendingAddrUpdate[_regId] = empty(PendingAddressUpdate)\n\n    log AddressUpdateConfirmed(regId=_regId, description=data.description, newAddr=newData.newAddr, prevAddr=prevAddr, version=data.version, registry=REGISTRY_STR)\n    return True\n\n\n# cancel update address\n\n\n@internal\ndef _cancelAddressUpdateToRegistry(_regId: uint256) -> bool:\n    data: PendingAddressUpdate = self.pendingAddrUpdate[_regId]\n    assert data.confirmBlock != 0 # dev: no pending\n\n    self.pendingAddrUpdate[_regId] = empty(PendingAddressUpdate)\n    prevData: AddressInfo = self.addrInfo[_regId]\n    log AddressUpdateCancelled(regId=_regId, description=prevData.description, newAddr=data.newAddr, prevAddr=prevData.addr, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n# validation\n\n\n@view\n@external\ndef isValidAddressUpdate(_regId: uint256, _newAddr: address) -> bool:\n    return self._isValidAddressUpdate(_regId, _newAddr, self.addrInfo[_regId].addr)\n\n\n@view\n@internal\ndef _isValidAddressUpdate(_regId: uint256, _newAddr: address, _prevAddr: address) -> bool:\n    if not self._isValidRegId(_regId):\n        return False\n    if not self._isValidNewAddress(_newAddr):\n        return False\n    return _newAddr != _prevAddr\n\n\n###################\n# Disable Address #\n###################\n\n\n# start disable address\n\n\n@internal\ndef _startAddressDisableInRegistry(_regId: uint256) -> bool:\n    data: AddressInfo = self.addrInfo[_regId]\n    assert self._isValidAddressDisable(_regId, data.addr) # dev: invalid disable\n\n    # set pending\n    confirmBlock: uint256 = block.number + self.registryChangeTimeLock\n    self.pendingAddrDisable[_regId] = PendingAddressDisable(\n        initiatedBlock=block.number,\n        confirmBlock=confirmBlock,\n    )\n\n    log AddressDisablePending(regId=_regId, description=data.description, addr=data.addr, version=data.version, confirmBlock=confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n# confirm disable address\n\n\n@internal\ndef _confirmAddressDisableInRegistry(_regId: uint256) -> bool:\n    newData: PendingAddressDisable = self.pendingAddrDisable[_regId]\n    assert newData.confirmBlock != 0 and block.number >= newData.confirmBlock # dev: time lock not reached\n\n    data: AddressInfo = self.addrInfo[_regId]\n    prevAddr: address = data.addr # needed for later\n    if not self._isValidAddressDisable(_regId, prevAddr):\n        self.pendingAddrDisable[_regId] = empty(PendingAddressDisable) # clear pending\n        return False\n\n    # disable addy\n    data.addr = empty(address)\n    data.lastModified = block.timestamp\n    data.version += 1\n    self.addrInfo[_regId] = data\n    self.addrToRegId[prevAddr] = 0\n\n    # clear pending\n    self.pendingAddrDisable[_regId] = empty(PendingAddressDisable)\n\n    log AddressDisableConfirmed(regId=_regId, description=data.description, addr=prevAddr, version=data.version, registry=REGISTRY_STR)\n    return True\n\n\n# cancel disable address\n\n\n@internal\ndef _cancelAddressDisableInRegistry(_regId: uint256) -> bool:\n    data: PendingAddressDisable = self.pendingAddrDisable[_regId]\n    assert data.confirmBlock != 0 # dev: no pending\n\n    self.pendingAddrDisable[_regId] = empty(PendingAddressDisable)\n    prevData: AddressInfo = self.addrInfo[_regId]\n    log AddressDisableCancelled(regId=_regId, description=prevData.description, addr=prevData.addr, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n# validation\n\n\n@view\n@external\ndef isValidAddressDisable(_regId: uint256) -> bool:\n    return self._isValidAddressDisable(_regId, self.addrInfo[_regId].addr)\n\n\n@view\n@internal\ndef _isValidAddressDisable(_regId: uint256, _prevAddr: address) -> bool:\n    if not self._isValidRegId(_regId):\n        return False\n    return _prevAddr != empty(address)\n\n\n####################\n# Time Lock Config #\n####################\n\n\n@external\ndef setRegistryTimeLock(_numBlocks: uint256) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return self._setRegistryTimeLock(_numBlocks)\n\n\n@internal\ndef _setRegistryTimeLock(_numBlocks: uint256) -> bool:\n    prevTimeLock: uint256 = self.registryChangeTimeLock\n    assert self._isValidRegistryTimeLock(_numBlocks, prevTimeLock) # dev: invalid time lock\n    self.registryChangeTimeLock = _numBlocks\n    log RegistryTimeLockModified(newTimeLock=_numBlocks, prevTimeLock=prevTimeLock, registry=REGISTRY_STR)\n    return True\n\n\n# validation\n\n\n@view\n@external\ndef isValidRegistryTimeLock(_numBlocks: uint256) -> bool:\n    return self._isValidRegistryTimeLock(_numBlocks, self.registryChangeTimeLock)\n\n\n@view\n@internal\ndef _isValidRegistryTimeLock(_newTimeLock: uint256, _prevTimeLock: uint256) -> bool:\n    if _newTimeLock == _prevTimeLock:\n        return False\n    return _newTimeLock >= MIN_REG_TIME_LOCK and _newTimeLock <= MAX_REG_TIME_LOCK\n\n\n# finish setup\n\n\n@external\ndef setRegistryTimeLockAfterSetup(_numBlocks: uint256 = 0) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert self.registryChangeTimeLock == 0 # dev: already set\n\n    timeLock: uint256 = _numBlocks\n    if timeLock == 0:\n        timeLock = MIN_REG_TIME_LOCK\n    return self._setRegistryTimeLock(timeLock)\n\n\n# utils\n\n\n@view\n@external\ndef minRegistryTimeLock() -> uint256:\n    return MIN_REG_TIME_LOCK\n\n\n@view\n@external\ndef maxRegistryTimeLock() -> uint256:\n    return MAX_REG_TIME_LOCK\n\n\n#################\n# Views / Utils #\n#################\n\n\n# is valid addr\n\n\n@view\n@external\ndef isValidAddr(_addr: address) -> bool:\n    return self._isValidAddr(_addr)\n\n\n@view\n@internal\ndef _isValidAddr(_addr: address) -> bool:\n    return self.addrToRegId[_addr] != 0\n\n\n# is valid addr id\n\n\n@view\n@external\ndef isValidRegId(_regId: uint256) -> bool:\n    return self._isValidRegId(_regId)\n\n\n@view\n@internal\ndef _isValidRegId(_regId: uint256) -> bool:\n    return _regId != 0 and _regId < self.numAddrs\n\n\n# get reg id\n\n\n@view\n@external\ndef getRegId(_addr: address) -> uint256:\n    return self._getRegId(_addr)\n\n\n@view\n@internal\ndef _getRegId(_addr: address) -> uint256:\n    return self.addrToRegId[_addr]\n\n\n# get addr\n\n\n@view\n@external\ndef getAddr(_regId: uint256) -> address:\n    return self._getAddr(_regId)\n\n\n@view\n@internal\ndef _getAddr(_regId: uint256) -> address:\n    return self.addrInfo[_regId].addr\n\n\n# get addr info\n\n\n@view\n@external\ndef getAddrInfo(_regId: uint256) -> AddressInfo:\n    return self._getAddrInfo(_regId)\n\n\n@view\n@internal\ndef _getAddrInfo(_regId: uint256) -> AddressInfo:\n    return self.addrInfo[_regId]\n\n\n# get addr description\n\n\n@view\n@external\ndef getAddrDescription(_regId: uint256) -> String[64]:\n    return self._getAddrDescription(_regId)\n\n\n@view\n@internal\ndef _getAddrDescription(_regId: uint256) -> String[64]:\n    return self.addrInfo[_regId].description\n\n\n# get num addrs\n\n\n@view\n@external\ndef getNumAddrs() -> uint256:\n    return self._getNumAddrs()\n\n\n@view\n@internal\ndef _getNumAddrs() -> uint256:\n    return self.numAddrs - 1\n\n\n# get last addr\n\n\n@view\n@external\ndef getLastAddr() -> address:\n    return self._getLastAddr()\n\n\n@view\n@internal\ndef _getLastAddr() -> address:\n    lastRegId: uint256 = self.numAddrs - 1\n    return self.addrInfo[lastRegId].addr\n\n\n# get last reg id\n\n\n@view\n@external\ndef getLastRegId() -> uint256:\n    return self._getLastRegId()\n\n\n@view\n@internal\ndef _getLastRegId() -> uint256:\n    return self.numAddrs - 1\n",
            "sha256sum": "b88f6fc85ae3cd815c5a476c620b2fb5494b4dec5f1ce738878eded11c46396b"
          },
          "contracts/modules/Addys.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\ninterface UndyHq:\n    def isValidAddr(_addr: address) -> bool: view\n    def getAddr(_regId: uint256) -> address: view\n    def undyToken() -> address: view\n\ninterface Switchboard:\n    def isSwitchboardAddr(_addr: address) -> bool: view\n\ninterface LegoBook:\n    def isLegoAddr(_addr: address) -> bool: view\n\nstruct Addys:\n    hq: address\n    undyToken: address\n    ledger: address\n    missionControl: address\n    legoBook: address\n    switchboard: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    walletBackpack: address\n    billing: address\n\n# hq\nUNDY_HQ_FOR_ADDYS: immutable(address)\n\n# core addys\nLEDGER_ID: constant(uint256) = 1\nMISSION_CONTROL_ID: constant(uint256) = 2\nLEGO_BOOK_ID: constant(uint256) = 3\nSWITCHBOARD_ID: constant(uint256) = 4\nHATCHERY_ID: constant(uint256) = 5\nLOOT_DISTRIBUTOR_ID: constant(uint256) = 6\nAPPRAISER_ID: constant(uint256) = 7\nWALLET_BACKPACK_ID: constant(uint256) = 8\nBILLING_ID: constant(uint256) = 9\n\n\n@deploy\ndef __init__(_undyHq: address):\n    assert _undyHq != empty(address) # dev: invalid undy hq\n    UNDY_HQ_FOR_ADDYS = _undyHq\n\n\n########\n# Core #\n########\n\n\n@view\n@external\ndef getAddys() -> Addys:\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _getAddys(_addys: Addys = empty(Addys)) -> Addys:\n    if _addys.hq != empty(address):\n        return _addys\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _generateAddys() -> Addys:\n    hq: address = UNDY_HQ_FOR_ADDYS\n    return Addys(\n        hq = hq,\n        undyToken = staticcall UndyHq(hq).undyToken(),\n        ledger = staticcall UndyHq(hq).getAddr(LEDGER_ID),\n        missionControl = staticcall UndyHq(hq).getAddr(MISSION_CONTROL_ID),\n        legoBook = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID),\n        switchboard = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID),\n        hatchery = staticcall UndyHq(hq).getAddr(HATCHERY_ID),\n        lootDistributor = staticcall UndyHq(hq).getAddr(LOOT_DISTRIBUTOR_ID),\n        appraiser = staticcall UndyHq(hq).getAddr(APPRAISER_ID),\n        walletBackpack = staticcall UndyHq(hq).getAddr(WALLET_BACKPACK_ID),\n        billing = staticcall UndyHq(hq).getAddr(BILLING_ID),\n    )\n\n\n##########\n# Tokens #\n##########\n\n\n@view\n@internal\ndef _getUndyToken() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).undyToken()\n\n\n###########\n# Helpers #\n###########\n\n\n# undy hq\n\n\n@view\n@external\ndef getUndyHq() -> address:\n    return self._getUndyHq()\n\n\n@view\n@internal\ndef _getUndyHq() -> address:\n    return UNDY_HQ_FOR_ADDYS\n\n\n# utils\n\n\n@view\n@internal\ndef _isValidUndyAddr(_addr: address, _hq: address = empty(address)) -> bool:\n    hq: address = _hq\n    if _hq == empty(address):\n        hq = UNDY_HQ_FOR_ADDYS\n    \n    # core departments\n    if staticcall UndyHq(hq).isValidAddr(_addr):\n        return True\n\n    # lego book\n    legoBook: address = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID)\n    if legoBook != empty(address) and staticcall LegoBook(legoBook).isLegoAddr(_addr):\n        return True\n\n    # switchboard config\n    switchboard: address = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID)\n    if switchboard != empty(address) and staticcall Switchboard(switchboard).isSwitchboardAddr(_addr):\n        return True\n\n    return False\n\n\n@view\n@internal\ndef _isSwitchboardAddr(_addr: address) -> bool:\n    switchboard: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n    if switchboard == empty(address):\n        return False\n    return staticcall Switchboard(switchboard).isSwitchboardAddr(_addr)\n\n\n@view\n@internal\ndef _isLegoBookAddr(_addr: address) -> bool:\n    legoBook: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n    if legoBook == empty(address):\n        return False\n    return staticcall LegoBook(legoBook).isLegoAddr(_addr)\n\n\n###############\n# Departments #\n###############\n\n\n# ledger\n\n\n@view\n@internal\ndef _getLedgerId() -> uint256:\n    return LEDGER_ID\n\n\n@view\n@internal\ndef _getLedgerAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEDGER_ID)\n\n\n# mission control\n\n\n@view\n@internal\ndef _getMissionControlId() -> uint256:\n    return MISSION_CONTROL_ID\n\n\n@view\n@internal\ndef _getMissionControlAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(MISSION_CONTROL_ID)\n\n\n# lego book\n\n\n@view\n@internal\ndef _getLegoBookId() -> uint256:\n    return LEGO_BOOK_ID\n\n\n@view\n@internal\ndef _getLegoBookAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n\n\n# switchboard\n\n\n@view\n@internal\ndef _getSwitchboardId() -> uint256:\n    return SWITCHBOARD_ID\n\n\n@view\n@internal\ndef _getSwitchboardAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n\n\n# hatchery\n\n\n@view\n@internal\ndef _getHatcheryId() -> uint256:\n    return HATCHERY_ID\n\n\n@view\n@internal\ndef _getHatcheryAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(HATCHERY_ID)\n\n\n# loot distributor\n\n\n@view\n@internal\ndef _getLootDistributorId() -> uint256:\n    return LOOT_DISTRIBUTOR_ID\n\n\n@view\n@internal\ndef _getLootDistributorAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LOOT_DISTRIBUTOR_ID)\n\n\n# appraiser\n\n\n@view\n@internal\ndef _getAppraiserId() -> uint256:\n    return APPRAISER_ID\n\n\n@view\n@internal\ndef _getAppraiserAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(APPRAISER_ID)\n\n\n# wallet backpack\n\n\n@view\n@internal\ndef _getWalletBackpackId() -> uint256:\n    return WALLET_BACKPACK_ID\n\n\n@view\n@internal\ndef _getWalletBackpackAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(WALLET_BACKPACK_ID)\n\n\n# billing\n\n\n@view\n@internal\ndef _getBillingId() -> uint256:\n    return BILLING_ID\n\n\n@view\n@internal\ndef _getBillingAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(BILLING_ID)",
            "sha256sum": "78b58f0b2acb2eaafa4d21adf9135a1cd0e1d53897f7a1fa70a83a04a7738ad3"
          },
          "interfaces/Department.vyi": {
            "content": "# @version 0.4.3\n\n\n###########\n# Minting #\n###########\n\n\n@view\n@external\ndef canMintUndy() -> bool:\n    # used in UndyHq.vy\n    ...\n\n\n########\n# Undy #\n########\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "53e48da591c4ee36045a8950c9d3a01458456b471b797df536e9a9f54404e721"
          },
          "contracts/modules/DeptBasics.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nuses: addys\nimplements: dept\n\nimport contracts.modules.Addys as addys\nimport interfaces.Department as dept\nfrom ethereum.ercs import IERC20\n\nevent DepartmentPauseModified:\n    isPaused: bool\n\nevent DepartmentFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    balance: uint256\n\nisPaused: public(bool)\n\nCAN_MINT_UNDY: immutable(bool)\nMAX_RECOVER_ASSETS: constant(uint256) = 20\n\n\n@deploy\ndef __init__(_shouldPause: bool, _canMintUndy: bool):\n    self.isPaused = _shouldPause\n    CAN_MINT_UNDY = _canMintUndy\n\n\n###########\n# Minting #\n###########\n\n\n@view\n@external\ndef canMintUndy() -> bool:\n    return CAN_MINT_UNDY\n\n\n########\n# Undy #\n########\n\n\n# activate\n\n\n@external\ndef pause(_shouldPause: bool):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert _shouldPause != self.isPaused # dev: no change\n    self.isPaused = _shouldPause\n    log DepartmentPauseModified(isPaused=_shouldPause)\n\n\n# recover funds\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    self._recoverFunds(_recipient, _asset)\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, MAX_RECOVER_ASSETS]):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    for a: address in _assets:\n        self._recoverFunds(_recipient, a)\n\n\n@internal\ndef _recoverFunds(_recipient: address, _asset: address):\n    assert empty(address) not in [_recipient, _asset] # dev: invalid recipient or asset\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    assert balance != 0 # dev: nothing to recover\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log DepartmentFundsRecovered(asset=_asset, recipient=_recipient, balance=balance)\n",
            "sha256sum": "976a50a3807bcf71f3f1c57de5cd7a59fe4e8f27b4d4560e774073962f44d1ac"
          },
          "interfaces/WalletStructs.vyi": {
            "content": "# @version 0.4.3\n\nflag ActionType:\n    TRANSFER\n    EARN_DEPOSIT\n    EARN_WITHDRAW\n    EARN_REBALANCE\n    SWAP\n    MINT_REDEEM\n    CONFIRM_MINT_REDEEM\n    ADD_COLLATERAL\n    REMOVE_COLLATERAL\n    BORROW\n    REPAY_DEBT\n    REWARDS\n    ETH_TO_WETH\n    WETH_TO_ETH\n    ADD_LIQ\n    REMOVE_LIQ\n    ADD_LIQ_CONC\n    REMOVE_LIQ_CONC\n    PAY_CHEQUE\n\nstruct WalletAssetData:\n    assetBalance: uint256\n    usdValue: uint256\n    isYieldAsset: bool\n    lastPricePerShare: uint256\n\nstruct ActionData:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    billing: address\n    wallet: address\n    walletConfig: address\n    walletOwner: address\n    inEjectMode: bool\n    isFrozen: bool\n    lastTotalUsdValue: uint256\n    signer: address\n    isManager: bool\n    legoId: uint256\n    legoAddr: address\n    eth: address\n    weth: address\n\nstruct MiniAddys:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    appraiser: address",
            "sha256sum": "9a4b4f59b3a62043e51b425a665064aae419a3c0bd0514b6b29a9441ae364bb9"
          },
          "interfaces/LegoPartner.vyi": {
            "content": "# @version 0.4.3\n\nfrom interfaces import WalletStructs as ws\n\nMAX_TOKEN_PATH: constant(uint256) = 5\nMAX_RECOVER_ASSETS: constant(uint256) = 20\n\n@external\ndef addLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _tickLower: int24, _tickUpper: int24, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef addLiquidity(_pool: address, _tokenA: address, _tokenB: address, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _minLpAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (address, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef removeLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _liqToRemove: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef removeLiquidity(_pool: address, _tokenA: address, _tokenB: address, _lpToken: address, _lpAmount: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef mintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _tokenInAmount: uint256, _minAmountOut: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef swapTokens(_amountIn: uint256, _minAmountOut: uint256, _tokenPath: DynArray[address, MAX_TOKEN_PATH], _poolPath: DynArray[address, MAX_TOKEN_PATH - 1], _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256):\n    ...\n\n@external\ndef depositForYield(_asset: address, _amount: uint256, _vaultAddr: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef withdrawFromYield(_vaultToken: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef confirmMintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef borrow(_borrowAsset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef repayDebt(_paymentAsset: address, _paymentAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef claimRewards(_user: address, _rewardToken: address, _rewardAmount: uint256, _extraData: bytes32, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef removeCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef addCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@view\n@external\ndef getAccessForLego(_user: address, _action: ws.ActionType) -> (address, String[64], uint256):\n    ...\n\n@view\n@external\ndef hasCapability(_action: ws.ActionType) -> bool:\n    ...\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    ...\n\n@view\n@external\ndef isYieldLego() -> bool:\n    ...\n\n@view\n@external\ndef isDexLego() -> bool:\n    ...\n\n@view\n@external\ndef getPricePerShare(_asset: address, _decimals: uint256) -> uint256:\n    ...\n\n@view\n@external\ndef getPrice(_asset: address, _decimals: uint256) -> uint256:\n    ...\n\n\n# common\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "2513e379aa74d0a8120114a5078a4c1a0900165a1c3f24419bb811d173b56453"
          },
          "contracts/registries/LegoBook.vy": {
            "content": "#          ___       ___           ___           ___                ___           ___           ___           ___     \n#         /\\__\\     /\\  \\         /\\  \\         /\\  \\              /\\  \\         /\\  \\         /\\  \\         /\\__\\    \n#        /:/  /    /::\\  \\       /::\\  \\       /::\\  \\            /::\\  \\       /::\\  \\       /::\\  \\       /:/  /    \n#       /:/  /    /:/\\:\\  \\     /:/\\:\\  \\     /:/\\:\\  \\          /:/\\:\\  \\     /:/\\:\\  \\     /:/\\:\\  \\     /:/__/     \n#      /:/  /    /::\\~\\:\\  \\   /:/  \\:\\  \\   /:/  \\:\\  \\        /::\\~\\:\\__\\   /:/  \\:\\  \\   /:/  \\:\\  \\   /::\\__\\____ \n#     /:/__/    /:/\\:\\ \\:\\__\\ /:/__/_\\:\\__\\ /:/__/ \\:\\__\\      /:/\\:\\ \\:|__| /:/__/ \\:\\__\\ /:/__/ \\:\\__\\ /:/\\:::::\\__\\\n#     \\:\\  \\    \\:\\~\\:\\ \\/__/ \\:\\  /\\ \\/__/ \\:\\  \\ /:/  /      \\:\\~\\:\\/:/  / \\:\\  \\ /:/  / \\:\\  \\ /:/  / \\/_|:|~~|~   \n#      \\:\\  \\    \\:\\ \\:\\__\\    \\:\\ \\:\\__\\    \\:\\  /:/  /        \\:\\ \\::/  /   \\:\\  /:/  /   \\:\\  /:/  /     |:|  |    \n#       \\:\\  \\    \\:\\ \\/__/     \\:\\/:/  /     \\:\\/:/  /          \\:\\/:/  /     \\:\\/:/  /     \\:\\/:/  /      |:|  |    \n#        \\:\\__\\    \\:\\__\\        \\::/  /       \\::/  /            \\::/__/       \\::/  /       \\::/  /       |:|  |    \n#         \\/__/     \\/__/         \\/__/         \\/__/              ~~            \\/__/         \\/__/         \\|__|    \n#\n#     \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n#     \u2551  ** Lego Book **                                                               \u2551\n#     \u2551  Address registry for Legos (DeFi integrations -- yield protocols, DEXs, etc). \u2551\n#     \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n#\n#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nimplements: Department\n\nexports: gov.__interface__\nexports: registry.__interface__\nexports: addys.__interface__\nexports: deptBasics.__interface__\n\ninitializes: gov\ninitializes: registry[gov := gov]\ninitializes: addys\ninitializes: deptBasics[addys := addys]\n\nimport contracts.modules.LocalGov as gov\nimport contracts.modules.AddressRegistry as registry\nimport contracts.modules.Addys as addys\nimport contracts.modules.DeptBasics as deptBasics\n\nfrom interfaces import LegoPartner as Lego\nfrom interfaces import Department\n\nevent LegoToolsSet:\n    addr: indexed(address)\n\nlegoTools: public(address)\n\n\n@deploy\ndef __init__(\n    _undyHq: address,\n    _minRegistryTimeLock: uint256,\n    _maxRegistryTimeLock: uint256,\n):\n    gov.__init__(_undyHq, empty(address), 0, 0, 0)\n    registry.__init__(_minRegistryTimeLock, _maxRegistryTimeLock, 0, \"LegoBook.vy\")\n    addys.__init__(_undyHq)\n    deptBasics.__init__(False, False)\n\n\n@view\n@external\ndef isLegoAddr(_addr: address) -> bool:\n    return registry._isValidAddr(_addr)\n\n\n############\n# Registry #\n############\n\n\n# new address\n\n\n@external\ndef startAddNewAddressToRegistry(_addr: address, _description: String[64]) -> bool:\n    assert self._canPerformAction(msg.sender) # dev: no perms\n    return registry._startAddNewAddressToRegistry(_addr, _description)\n\n\n@external\ndef confirmNewAddressToRegistry(_addr: address) -> uint256:\n    assert self._canPerformAction(msg.sender) # dev: no perms\n    return registry._confirmNewAddressToRegistry(_addr)\n\n\n@external\ndef cancelNewAddressToRegistry(_addr: address) -> bool:\n    assert self._canPerformAction(msg.sender) # dev: no perms\n    return registry._cancelNewAddressToRegistry(_addr)\n\n\n# address update\n\n\n@external\ndef startAddressUpdateToRegistry(_regId: uint256, _newAddr: address) -> bool:\n    assert self._canPerformAction(msg.sender) # dev: no perms\n    return registry._startAddressUpdateToRegistry(_regId, _newAddr)\n\n\n@external\ndef confirmAddressUpdateToRegistry(_regId: uint256) -> bool:\n    assert self._canPerformAction(msg.sender) # dev: no perms\n    return registry._confirmAddressUpdateToRegistry(_regId)\n\n\n@external\ndef cancelAddressUpdateToRegistry(_regId: uint256) -> bool:\n    assert self._canPerformAction(msg.sender) # dev: no perms\n    return registry._cancelAddressUpdateToRegistry(_regId)\n\n\n# address disable\n\n\n@external\ndef startAddressDisableInRegistry(_regId: uint256) -> bool:\n    assert self._canPerformAction(msg.sender) # dev: no perms\n    return registry._startAddressDisableInRegistry(_regId)\n\n\n@external\ndef confirmAddressDisableInRegistry(_regId: uint256) -> bool:\n    assert self._canPerformAction(msg.sender) # dev: no perms\n    return registry._confirmAddressDisableInRegistry(_regId)\n\n\n@external\ndef cancelAddressDisableInRegistry(_regId: uint256) -> bool:\n    assert self._canPerformAction(msg.sender) # dev: no perms\n    return registry._cancelAddressDisableInRegistry(_regId)\n\n\n##############\n# Lego Tools #\n##############\n\n\n@external\ndef setLegoTools(_addr: address) -> bool:\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    if not self._isValidLegoTools(_addr):\n        return False\n    self.legoTools = _addr\n    log LegoToolsSet(addr = _addr)\n    return True\n\n\n@view\n@external \ndef isValidLegoTools(_addr: address) -> bool:\n    return self._isValidLegoTools(_addr)\n\n\n@view\n@internal \ndef _isValidLegoTools(_addr: address) -> bool:\n    if not _addr.is_contract or _addr == empty(address):\n        return False\n    return _addr != self.legoTools\n\n\n#############\n# Utilities #\n#############\n\n\n@view\n@internal\ndef _canPerformAction(_caller: address) -> bool:\n    return gov._canGovern(_caller) and not deptBasics.isPaused",
            "sha256sum": "e7b6852f86ce7da65c9be05fb757b6cedef4996a8a18523ee9309e50b0d139c7"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/registries/LegoBook.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.3+commit.bff19ea2",
        "integrity": "d74aeb94f6990b6f4fd3301a204011b814dcc1350387fc2af354c3df6f681f51"
      },
      "args": "00000000000000000000000044cf3c4f000dfd76a35d03298049d37be688d6f90000000000000000000000000000000000000000000000000000000000005460000000000000000000000000000000000000000000000000000000000013c680",
      "file": "contracts/registries/LegoBook.vy"
    },
    "RipeLego": {
      "address": "0xF3F436491e9a0d50F67eBED70D2cE5586F098fB4",
      "abi": [
        {
          "name": "RipeCollateralDeposit",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountDeposited",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "RipeCollateralWithdrawal",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "RipeBorrow",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountBorrowed",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "RipeRepay",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountRepaid",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "RipeClaimRewards",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "ripeClaimed",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "RipeSavingsGreenDeposit",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountDeposited",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultTokenAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "RipeSavingsGreenWithdrawal",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultTokenAmountBurned",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LegoPauseModified",
          "inputs": [
            {
              "name": "isPaused",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LegoFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "balance",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetOpportunityAdded",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultAddr",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddys",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "undyToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "hatchery",
                  "type": "address"
                },
                {
                  "name": "lootDistributor",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                },
                {
                  "name": "walletBackpack",
                  "type": "address"
                },
                {
                  "name": "billing",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUndyHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isLegoAsset",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssetOpportunities",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isAssetOpportunity",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getNumLegoAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pause",
          "inputs": [
            {
              "name": "_shouldPause",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFundsMany",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_assets",
              "type": "address[]"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isPaused",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assetOpportunities",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAssetOpportunity",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssetOpportunities",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "vaultToAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assets",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasCapability",
          "inputs": [
            {
              "name": "_action",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRegistries",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAccessForLego",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_action",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "string"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isYieldLego",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isDexLego",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_borrowAsset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_borrowAsset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_paymentAsset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_paymentAsset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositForYield",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositForYield",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawFromYield",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawFromYield",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isRebasing",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isEligibleVaultForTrialFunds",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_underlyingAsset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isEligibleForYieldBonus",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAsset",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAmount",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getVaultTokenAmount",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_assetAmount",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValueOfVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValueOfVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            },
            {
              "name": "_appraiser",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingData",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingData",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            },
            {
              "name": "_appraiser",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalAssets",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalBorrows",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPricePerShare",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_decimals",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addAssetOpportunity",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeAssetOpportunity",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_tokenPath",
              "type": "address[]"
            },
            {
              "name": "_poolPath",
              "type": "address[]"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_tokenPath",
              "type": "address[]"
            },
            {
              "name": "_poolPath",
              "type": "address[]"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_tokenInAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_tokenInAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmMintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmMintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPrice",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_decimals",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "RIPE_REGISTRY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "RIPE_GREEN_TOKEN",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "RIPE_SAVINGS_GREEN",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "RIPE_TOKEN",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_undyHq",
              "type": "address"
            },
            {
              "name": "_ripeRegistry",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "interfaces/WalletStructs.vyi": {
            "content": "# @version 0.4.3\n\nflag ActionType:\n    TRANSFER\n    EARN_DEPOSIT\n    EARN_WITHDRAW\n    EARN_REBALANCE\n    SWAP\n    MINT_REDEEM\n    CONFIRM_MINT_REDEEM\n    ADD_COLLATERAL\n    REMOVE_COLLATERAL\n    BORROW\n    REPAY_DEBT\n    REWARDS\n    ETH_TO_WETH\n    WETH_TO_ETH\n    ADD_LIQ\n    REMOVE_LIQ\n    ADD_LIQ_CONC\n    REMOVE_LIQ_CONC\n    PAY_CHEQUE\n\nstruct WalletAssetData:\n    assetBalance: uint256\n    usdValue: uint256\n    isYieldAsset: bool\n    lastPricePerShare: uint256\n\nstruct ActionData:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    billing: address\n    wallet: address\n    walletConfig: address\n    walletOwner: address\n    inEjectMode: bool\n    isFrozen: bool\n    lastTotalUsdValue: uint256\n    signer: address\n    isManager: bool\n    legoId: uint256\n    legoAddr: address\n    eth: address\n    weth: address\n\nstruct MiniAddys:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    appraiser: address",
            "sha256sum": "9a4b4f59b3a62043e51b425a665064aae419a3c0bd0514b6b29a9441ae364bb9"
          },
          "interfaces/LegoPartner.vyi": {
            "content": "# @version 0.4.3\n\nfrom interfaces import WalletStructs as ws\n\nMAX_TOKEN_PATH: constant(uint256) = 5\nMAX_RECOVER_ASSETS: constant(uint256) = 20\n\n@external\ndef addLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _tickLower: int24, _tickUpper: int24, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef addLiquidity(_pool: address, _tokenA: address, _tokenB: address, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _minLpAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (address, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef removeLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _liqToRemove: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef removeLiquidity(_pool: address, _tokenA: address, _tokenB: address, _lpToken: address, _lpAmount: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef mintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _tokenInAmount: uint256, _minAmountOut: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef swapTokens(_amountIn: uint256, _minAmountOut: uint256, _tokenPath: DynArray[address, MAX_TOKEN_PATH], _poolPath: DynArray[address, MAX_TOKEN_PATH - 1], _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256):\n    ...\n\n@external\ndef depositForYield(_asset: address, _amount: uint256, _vaultAddr: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef withdrawFromYield(_vaultToken: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef confirmMintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef borrow(_borrowAsset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef repayDebt(_paymentAsset: address, _paymentAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef claimRewards(_user: address, _rewardToken: address, _rewardAmount: uint256, _extraData: bytes32, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef removeCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef addCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@view\n@external\ndef getAccessForLego(_user: address, _action: ws.ActionType) -> (address, String[64], uint256):\n    ...\n\n@view\n@external\ndef hasCapability(_action: ws.ActionType) -> bool:\n    ...\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    ...\n\n@view\n@external\ndef isYieldLego() -> bool:\n    ...\n\n@view\n@external\ndef isDexLego() -> bool:\n    ...\n\n@view\n@external\ndef getPricePerShare(_asset: address, _decimals: uint256) -> uint256:\n    ...\n\n@view\n@external\ndef getPrice(_asset: address, _decimals: uint256) -> uint256:\n    ...\n\n\n# common\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "2513e379aa74d0a8120114a5078a4c1a0900165a1c3f24419bb811d173b56453"
          },
          "interfaces/YieldLego.vyi": {
            "content": "# @version 0.4.3\n\n@view\n@external\ndef isRebasing() -> bool:\n    ...\n\n\n@view\n@external\ndef isEligibleForYieldBonus(_asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef isEligibleVaultForTrialFunds(_vaultToken: address, _underlyingAsset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    ...\n\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    ...\n\n\n@view\n@external\ndef isVaultToken(_vaultToken: address) -> bool:\n    ...\n\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> uint256:\n    ...\n\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> (address, uint256, uint256):\n    ...\n\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    ...\n\n\n@external\ndef addAssetOpportunity(_asset: address, _vaultAddr: address):\n    ...\n\n\n@external\ndef removeAssetOpportunity(_asset: address, _vaultAddr: address):\n    ...\n\n\n# YieldLegoData.vy module\n\n\n@view\n@external\ndef assetOpportunities(_asset: address, _index: uint256) -> address:\n    ...\n\n\n@view\n@external\ndef indexOfAssetOpportunity(_asset: address, _vaultAddr: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef numAssetOpportunities(_asset: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef vaultToAsset(_vaultAddr: address) -> address:\n    ...\n\n\n@view\n@external\ndef assets(_index: uint256) -> address:\n    ...\n\n\n@view\n@external\ndef indexOfAsset(_asset: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef numAssets() -> uint256:\n    ...\n\n\n@view\n@external\ndef isLegoAsset(_asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, 40]:\n    ...\n\n\n@view\n@external\ndef getAssets() -> DynArray[address, 20]:\n    ...\n\n\n@view\n@external\ndef isAssetOpportunity(_asset: address, _vaultAddr: address) -> bool:\n    ...\n\n\n@view\n@external\ndef getNumLegoAssets() -> uint256:\n    ...\n",
            "sha256sum": "3337ce5f78b0df6f86d1144b07505512bb1044304f67add97be6c3816b3c0b42"
          },
          "contracts/modules/Addys.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\ninterface UndyHq:\n    def isValidAddr(_addr: address) -> bool: view\n    def getAddr(_regId: uint256) -> address: view\n    def undyToken() -> address: view\n\ninterface Switchboard:\n    def isSwitchboardAddr(_addr: address) -> bool: view\n\ninterface LegoBook:\n    def isLegoAddr(_addr: address) -> bool: view\n\nstruct Addys:\n    hq: address\n    undyToken: address\n    ledger: address\n    missionControl: address\n    legoBook: address\n    switchboard: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    walletBackpack: address\n    billing: address\n\n# hq\nUNDY_HQ_FOR_ADDYS: immutable(address)\n\n# core addys\nLEDGER_ID: constant(uint256) = 1\nMISSION_CONTROL_ID: constant(uint256) = 2\nLEGO_BOOK_ID: constant(uint256) = 3\nSWITCHBOARD_ID: constant(uint256) = 4\nHATCHERY_ID: constant(uint256) = 5\nLOOT_DISTRIBUTOR_ID: constant(uint256) = 6\nAPPRAISER_ID: constant(uint256) = 7\nWALLET_BACKPACK_ID: constant(uint256) = 8\nBILLING_ID: constant(uint256) = 9\n\n\n@deploy\ndef __init__(_undyHq: address):\n    assert _undyHq != empty(address) # dev: invalid undy hq\n    UNDY_HQ_FOR_ADDYS = _undyHq\n\n\n########\n# Core #\n########\n\n\n@view\n@external\ndef getAddys() -> Addys:\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _getAddys(_addys: Addys = empty(Addys)) -> Addys:\n    if _addys.hq != empty(address):\n        return _addys\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _generateAddys() -> Addys:\n    hq: address = UNDY_HQ_FOR_ADDYS\n    return Addys(\n        hq = hq,\n        undyToken = staticcall UndyHq(hq).undyToken(),\n        ledger = staticcall UndyHq(hq).getAddr(LEDGER_ID),\n        missionControl = staticcall UndyHq(hq).getAddr(MISSION_CONTROL_ID),\n        legoBook = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID),\n        switchboard = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID),\n        hatchery = staticcall UndyHq(hq).getAddr(HATCHERY_ID),\n        lootDistributor = staticcall UndyHq(hq).getAddr(LOOT_DISTRIBUTOR_ID),\n        appraiser = staticcall UndyHq(hq).getAddr(APPRAISER_ID),\n        walletBackpack = staticcall UndyHq(hq).getAddr(WALLET_BACKPACK_ID),\n        billing = staticcall UndyHq(hq).getAddr(BILLING_ID),\n    )\n\n\n##########\n# Tokens #\n##########\n\n\n@view\n@internal\ndef _getUndyToken() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).undyToken()\n\n\n###########\n# Helpers #\n###########\n\n\n# undy hq\n\n\n@view\n@external\ndef getUndyHq() -> address:\n    return self._getUndyHq()\n\n\n@view\n@internal\ndef _getUndyHq() -> address:\n    return UNDY_HQ_FOR_ADDYS\n\n\n# utils\n\n\n@view\n@internal\ndef _isValidUndyAddr(_addr: address, _hq: address = empty(address)) -> bool:\n    hq: address = _hq\n    if _hq == empty(address):\n        hq = UNDY_HQ_FOR_ADDYS\n    \n    # core departments\n    if staticcall UndyHq(hq).isValidAddr(_addr):\n        return True\n\n    # lego book\n    legoBook: address = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID)\n    if legoBook != empty(address) and staticcall LegoBook(legoBook).isLegoAddr(_addr):\n        return True\n\n    # switchboard config\n    switchboard: address = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID)\n    if switchboard != empty(address) and staticcall Switchboard(switchboard).isSwitchboardAddr(_addr):\n        return True\n\n    return False\n\n\n@view\n@internal\ndef _isSwitchboardAddr(_addr: address) -> bool:\n    switchboard: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n    if switchboard == empty(address):\n        return False\n    return staticcall Switchboard(switchboard).isSwitchboardAddr(_addr)\n\n\n@view\n@internal\ndef _isLegoBookAddr(_addr: address) -> bool:\n    legoBook: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n    if legoBook == empty(address):\n        return False\n    return staticcall LegoBook(legoBook).isLegoAddr(_addr)\n\n\n###############\n# Departments #\n###############\n\n\n# ledger\n\n\n@view\n@internal\ndef _getLedgerId() -> uint256:\n    return LEDGER_ID\n\n\n@view\n@internal\ndef _getLedgerAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEDGER_ID)\n\n\n# mission control\n\n\n@view\n@internal\ndef _getMissionControlId() -> uint256:\n    return MISSION_CONTROL_ID\n\n\n@view\n@internal\ndef _getMissionControlAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(MISSION_CONTROL_ID)\n\n\n# lego book\n\n\n@view\n@internal\ndef _getLegoBookId() -> uint256:\n    return LEGO_BOOK_ID\n\n\n@view\n@internal\ndef _getLegoBookAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n\n\n# switchboard\n\n\n@view\n@internal\ndef _getSwitchboardId() -> uint256:\n    return SWITCHBOARD_ID\n\n\n@view\n@internal\ndef _getSwitchboardAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n\n\n# hatchery\n\n\n@view\n@internal\ndef _getHatcheryId() -> uint256:\n    return HATCHERY_ID\n\n\n@view\n@internal\ndef _getHatcheryAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(HATCHERY_ID)\n\n\n# loot distributor\n\n\n@view\n@internal\ndef _getLootDistributorId() -> uint256:\n    return LOOT_DISTRIBUTOR_ID\n\n\n@view\n@internal\ndef _getLootDistributorAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LOOT_DISTRIBUTOR_ID)\n\n\n# appraiser\n\n\n@view\n@internal\ndef _getAppraiserId() -> uint256:\n    return APPRAISER_ID\n\n\n@view\n@internal\ndef _getAppraiserAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(APPRAISER_ID)\n\n\n# wallet backpack\n\n\n@view\n@internal\ndef _getWalletBackpackId() -> uint256:\n    return WALLET_BACKPACK_ID\n\n\n@view\n@internal\ndef _getWalletBackpackAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(WALLET_BACKPACK_ID)\n\n\n# billing\n\n\n@view\n@internal\ndef _getBillingId() -> uint256:\n    return BILLING_ID\n\n\n@view\n@internal\ndef _getBillingAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(BILLING_ID)",
            "sha256sum": "78b58f0b2acb2eaafa4d21adf9135a1cd0e1d53897f7a1fa70a83a04a7738ad3"
          },
          "contracts/modules/YieldLegoData.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nuses: addys\n\nimport contracts.modules.Addys as addys\n\nfrom interfaces import WalletStructs as ws\nfrom ethereum.ercs import IERC20\n\nevent AssetOpportunityAdded:\n    asset: indexed(address)\n    vaultAddr: indexed(address)\n\nevent AssetOpportunityRemoved:\n    asset: indexed(address)\n    vaultAddr: indexed(address)\n\nevent LegoPauseModified:\n    isPaused: bool\n\nevent LegoFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    balance: uint256\n\n# config\nisPaused: public(bool)\n\n# asset opportunities\nassetOpportunities: public(HashMap[address, HashMap[uint256, address]]) # asset -> index -> vault addr\nindexOfAssetOpportunity: public(HashMap[address, HashMap[address, uint256]]) # asset -> vault addr -> index\nnumAssetOpportunities: public(HashMap[address, uint256]) # asset -> number of opportunities\n\n# mapping\nvaultToAsset: public(HashMap[address, address]) # vault addr -> underlying asset\n\n# lego assets (iterable)\nassets: public(HashMap[uint256, address]) # index -> asset\nindexOfAsset: public(HashMap[address, uint256]) # asset -> index\nnumAssets: public(uint256) # num assets\n\nMAX_VAULTS: constant(uint256) = 40\nMAX_ASSETS: constant(uint256) = 20\nMAX_RECOVER_ASSETS: constant(uint256) = 20\n\n\n@deploy\ndef __init__(_shouldPause: bool):\n    self.isPaused = _shouldPause\n    self.numAssets = 1 # not using 0 index\n\n\n#########\n# Views #\n#########\n\n\n# is lego asset\n\n\n@view\n@external\ndef isLegoAsset(_asset: address) -> bool:\n    return self._isLegoAsset(_asset)\n\n\n@view\n@internal\ndef _isLegoAsset(_asset: address) -> bool:\n    return self.indexOfAsset[_asset] != 0\n\n\n# vault opportunities\n\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, MAX_VAULTS]:\n    numOpportunities: uint256 = self.numAssetOpportunities[_asset]\n    if numOpportunities == 0:\n        return []\n    opportunities: DynArray[address, MAX_VAULTS] = []\n    for i: uint256 in range(1, numOpportunities, bound=MAX_VAULTS):\n        opportunities.append(self.assetOpportunities[_asset][i])\n    return opportunities\n\n\n# all assets registered\n\n\n@view\n@external\ndef getAssets() -> DynArray[address, MAX_ASSETS]:\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return []\n    assets: DynArray[address, MAX_ASSETS] = []\n    for i: uint256 in range(1, numAssets, bound=MAX_ASSETS):\n        assets.append(self.assets[i])\n    return assets\n\n\n################\n# Registration #\n################\n\n\n@view\n@external\ndef isAssetOpportunity(_asset: address, _vaultAddr: address) -> bool:\n    return self._isAssetOpportunity(_asset, _vaultAddr)\n\n\n@view\n@internal\ndef _isAssetOpportunity(_asset: address, _vaultAddr: address) -> bool:\n    return self.indexOfAssetOpportunity[_asset][_vaultAddr] != 0\n\n\n# add asset opportunity\n\n\n@internal\ndef _addAssetOpportunity(_asset: address, _vaultAddr: address):\n    if self.indexOfAssetOpportunity[_asset][_vaultAddr] != 0:\n        return\n    if empty(address) in [_asset, _vaultAddr]:\n        return\n\n    # add asset opportunity\n    aid: uint256 = self.numAssetOpportunities[_asset]\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.assetOpportunities[_asset][aid] = _vaultAddr\n    self.indexOfAssetOpportunity[_asset][_vaultAddr] = aid\n    self.numAssetOpportunities[_asset] = aid + 1\n\n    # add mapping\n    self.vaultToAsset[_vaultAddr] = _asset\n\n    # add asset\n    self._addAsset(_asset)\n\n    log AssetOpportunityAdded(asset=_asset, vaultAddr=_vaultAddr)\n\n\n# remove asset opportunity\n\n\n@internal\ndef _removeAssetOpportunity(_asset: address, _vaultAddr: address):\n    numOpportunities: uint256 = self.numAssetOpportunities[_asset]\n    if numOpportunities == 0:\n        return\n\n    targetIndex: uint256 = self.indexOfAssetOpportunity[_asset][_vaultAddr]\n    if targetIndex == 0:\n        return\n\n    # update data\n    lastIndex: uint256 = numOpportunities - 1\n    self.numAssetOpportunities[_asset] = lastIndex\n    self.indexOfAssetOpportunity[_asset][_vaultAddr] = 0\n\n    self.vaultToAsset[_vaultAddr] = empty(address)\n\n    # shift to replace the removed one\n    if targetIndex != lastIndex:\n        lastVaultAddr: address = self.assetOpportunities[_asset][lastIndex]\n        self.assetOpportunities[_asset][targetIndex] = lastVaultAddr\n        self.indexOfAssetOpportunity[_asset][lastVaultAddr] = targetIndex\n\n    # remove asset\n    if lastIndex <= 1:\n        self._removeAsset(_asset)\n\n    log AssetOpportunityRemoved(asset=_asset, vaultAddr=_vaultAddr)\n\n\n# add asset\n\n\n@internal\ndef _addAsset(_asset: address):\n    if self.indexOfAsset[_asset] != 0:\n        return\n\n    aid: uint256 = self.numAssets\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.assets[aid] = _asset\n    self.indexOfAsset[_asset] = aid\n    self.numAssets = aid + 1\n\n\n# remove asset\n\n\n@internal\ndef _removeAsset(_asset: address):\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return\n\n    targetIndex: uint256 = self.indexOfAsset[_asset]\n    if targetIndex == 0:\n        return\n\n    # update data\n    lastIndex: uint256 = numAssets - 1\n    self.numAssets = lastIndex\n    self.indexOfAsset[_asset] = 0\n\n    # shift to replace the removed one\n    if targetIndex != lastIndex:\n        lastAsset: address = self.assets[lastIndex]\n        self.assets[targetIndex] = lastAsset\n        self.indexOfAsset[lastAsset] = targetIndex\n\n\n# num lego assets (true number, use `numAssets` for iteration)\n\n\n@view\n@external\ndef getNumLegoAssets() -> uint256:\n    return self._getNumLegoAssets()\n\n\n@view\n@internal\ndef _getNumLegoAssets() -> uint256:\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return 0\n    return numAssets - 1\n\n\n###########\n# General #\n###########\n\n\n# fill mini addys\n\n\n@view\n@internal\ndef _getMiniAddys(_miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> ws.MiniAddys:\n    if _miniAddys.ledger != empty(address):\n        return _miniAddys\n    return ws.MiniAddys(\n        ledger = addys._getLedgerAddr(),\n        missionControl = addys._getMissionControlAddr(),\n        legoBook = addys._getLegoBookAddr(),\n        appraiser = addys._getAppraiserAddr(),\n    )\n\n\n# activate\n\n\n@external\ndef pause(_shouldPause: bool):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert _shouldPause != self.isPaused # dev: no change\n    self.isPaused = _shouldPause\n    log LegoPauseModified(isPaused=_shouldPause)\n\n\n# recover funds\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    self._recoverFunds(_recipient, _asset)\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, MAX_RECOVER_ASSETS]):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    for a: address in _assets:\n        self._recoverFunds(_recipient, a)\n\n\n@internal\ndef _recoverFunds(_recipient: address, _asset: address):\n    assert empty(address) not in [_recipient, _asset] # dev: invalid recipient or asset\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    assert balance != 0 # dev: nothing to recover\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log LegoFundsRecovered(asset=_asset, recipient=_recipient, balance=balance)",
            "sha256sum": "bcbae5ce139758ce8a77c03858ec8d438dea0437d5f3a20fed8267f4d2f15b66"
          },
          "contracts/legos/RipeLego.vy": {
            "content": "#         _____   ____     _____       ______          ____            ______        _____           _____    \n#     ___|\\    \\ |    |___|\\    \\  ___|\\     \\        |    |       ___|\\     \\   ___|\\    \\     ____|\\    \\   \n#    |    |\\    \\|    |    |\\    \\|     \\     \\       |    |      |     \\     \\ /    /\\    \\   /     /\\    \\  \n#    |    | |    |    |    | |    |     ,_____/|      |    |      |     ,_____/|    |  |____| /     /  \\    \\ \n#    |    |/____/|    |    |/____/|     \\--'\\_|/      |    |  ____|     \\--'\\_|/    |    ____|     |    |    |\n#    |    |\\    \\|    |    ||    ||     /___/|        |    | |    |     /___/| |    |   |    |     |    |    |\n#    |    | |    |    |    ||____|/     \\____|\\       |    | |    |     \\____|\\|    |   |_,  |\\     \\  /    /|\n#    |____| |____|____|____|      |____ '     /|      |____|/____/|____ '     /|\\ ___\\___/  /| \\_____\\/____/ |\n#    |    | |    |    |    |      |    /_____/ |      |    |     ||    /_____/ | |   /____ / |\\ |    ||    | /\n#    |____| |____|____|____|      |____|     | /      |____|_____|/____|     | /\\|___|    | /  \\|____||____|/ \n#      \\(     )/   \\(   \\(          \\( |_____|/         \\(    )/    \\( |_____|/   \\( |____|/      \\(    )/    \n#       '     '     '    '           '    )/             '    '      '    )/       '   )/          '    '     \n#                                         '                               '            '                      \n#     \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n#     \u2551  ** Ripe Lego **                        \u2551\n#     \u2551  Integration with Ripe Protocol.        \u2551\n#     \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n#\n#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nimplements: Lego\nimplements: YieldLego\n\nexports: addys.__interface__\nexports: yld.__interface__\n\ninitializes: addys\ninitializes: yld[addys := addys]\n\nfrom interfaces import LegoPartner as Lego\nfrom interfaces import YieldLego as YieldLego\nfrom interfaces import WalletStructs as ws\n\nimport contracts.modules.Addys as addys\nimport contracts.modules.YieldLegoData as yld\n\nfrom ethereum.ercs import IERC20Detailed\nfrom ethereum.ercs import IERC20\nfrom ethereum.ercs import IERC4626\n\ninterface RipeTeller:\n    def repay(_paymentAmount: uint256 = max_value(uint256), _user: address = msg.sender, _isPaymentSavingsGreen: bool = False, _shouldRefundSavingsGreen: bool = True) -> bool: nonpayable\n    def withdraw(_asset: address, _amount: uint256 = max_value(uint256), _user: address = msg.sender, _vaultAddr: address = empty(address), _vaultId: uint256 = 0) -> uint256: nonpayable\n    def deposit(_asset: address, _amount: uint256 = max_value(uint256), _user: address = msg.sender, _vaultAddr: address = empty(address), _vaultId: uint256 = 0) -> uint256: nonpayable\n    def borrow(_greenAmount: uint256 = max_value(uint256), _user: address = msg.sender, _wantsSavingsGreen: bool = True, _shouldEnterStabPool: bool = False) -> uint256: nonpayable\n    def claimLoot(_user: address = msg.sender, _shouldStake: bool = True) -> uint256: nonpayable\n\ninterface RipeRegistry:\n    def getAddr(_regId: uint256) -> address: view\n    def savingsGreen() -> address: view\n    def greenToken() -> address: view\n    def ripeToken() -> address: view\n\ninterface Ledger:\n    def setVaultToken(_vaultToken: address, _legoId: uint256, _underlyingAsset: address, _decimals: uint256, _isRebasing: bool): nonpayable\n    def isRegisteredVaultToken(_vaultToken: address) -> bool: view\n    def isUserWallet(_user: address) -> bool: view\n\ninterface Appraiser:\n    def getUsdValue(_asset: address, _amount: uint256, _missionControl: address = empty(address), _legoBook: address = empty(address), _ledger: address = empty(address)) -> uint256: view\n    def updatePriceAndGetUsdValue(_asset: address, _amount: uint256, _missionControl: address = empty(address), _legoBook: address = empty(address)) -> uint256: nonpayable\n\ninterface RipeMissionControl:\n    def doesUndyLegoHaveAccess(_wallet: address, _legoAddr: address) -> bool: view\n\ninterface UndyRegistry:\n    def getRegId(_addr: address) -> uint256: view\n\nevent RipeCollateralDeposit:\n    sender: indexed(address)\n    asset: indexed(address)\n    assetAmountDeposited: uint256\n    vaultId: uint256\n    usdValue: uint256\n    recipient: address\n\nevent RipeCollateralWithdrawal:\n    sender: indexed(address)\n    asset: indexed(address)\n    assetAmountReceived: uint256\n    vaultId: uint256\n    usdValue: uint256\n    recipient: address\n\nevent RipeBorrow:\n    sender: indexed(address)\n    asset: indexed(address)\n    assetAmountBorrowed: uint256\n    usdValue: uint256\n    recipient: address\n\nevent RipeRepay:\n    sender: indexed(address)\n    asset: indexed(address)\n    assetAmountRepaid: uint256\n    usdValue: uint256\n    recipient: address\n\nevent RipeClaimRewards:\n    sender: indexed(address)\n    asset: indexed(address)\n    ripeClaimed: uint256\n    usdValue: uint256\n    recipient: address\n\nevent RipeSavingsGreenDeposit:\n    sender: indexed(address)\n    asset: indexed(address)\n    vaultToken: indexed(address)\n    assetAmountDeposited: uint256\n    usdValue: uint256\n    vaultTokenAmountReceived: uint256\n    recipient: address\n\nevent RipeSavingsGreenWithdrawal:\n    sender: indexed(address)\n    asset: indexed(address)\n    vaultToken: indexed(address)\n    assetAmountReceived: uint256\n    usdValue: uint256\n    vaultTokenAmountBurned: uint256\n    recipient: address\n\n# ripe addrs\nRIPE_REGISTRY: public(immutable(address))\nRIPE_GREEN_TOKEN: public(immutable(address))\nRIPE_SAVINGS_GREEN: public(immutable(address))\nRIPE_TOKEN: public(immutable(address))\n\nRIPE_MISSION_CONTROL_ID: constant(uint256) = 5\nRIPE_LOOTBOX_ID: constant(uint256) = 16\nRIPE_TELLER_ID: constant(uint256) = 17\n\nLEGO_ACCESS_ABI: constant(String[64]) = \"setUndyLegoAccess(address)\"\nMAX_TOKEN_PATH: constant(uint256) = 5\n\n\n@deploy\ndef __init__(\n    _undyHq: address,\n    _ripeRegistry: address,\n):\n    addys.__init__(_undyHq)\n    yld.__init__(False)\n\n    assert _ripeRegistry != empty(address) # dev: invalid ripe registry\n    RIPE_REGISTRY = _ripeRegistry\n    RIPE_GREEN_TOKEN = staticcall RipeRegistry(RIPE_REGISTRY).greenToken()\n    RIPE_SAVINGS_GREEN = staticcall RipeRegistry(RIPE_REGISTRY).savingsGreen()\n    RIPE_TOKEN = staticcall RipeRegistry(RIPE_REGISTRY).ripeToken()\n\n\n@view\n@external\ndef hasCapability(_action: ws.ActionType) -> bool:\n    return _action in (\n        ws.ActionType.EARN_DEPOSIT | \n        ws.ActionType.EARN_WITHDRAW |\n        ws.ActionType.ADD_COLLATERAL |\n        ws.ActionType.REMOVE_COLLATERAL |\n        ws.ActionType.BORROW |\n        ws.ActionType.REPAY_DEBT |\n        ws.ActionType.REWARDS\n    )\n\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    return [RIPE_REGISTRY]\n\n\n@view\n@external\ndef getAccessForLego(_user: address, _action: ws.ActionType) -> (address, String[64], uint256):\n    ripeHq: address = RIPE_REGISTRY\n\n    mc: address = staticcall RipeRegistry(ripeHq).getAddr(RIPE_MISSION_CONTROL_ID)\n    if staticcall RipeMissionControl(mc).doesUndyLegoHaveAccess(_user, self):\n        return empty(address), empty(String[64]), 0\n\n    else:\n        teller: address = staticcall RipeRegistry(ripeHq).getAddr(RIPE_TELLER_ID)\n        return teller, LEGO_ACCESS_ABI, 1\n\n\n@view\n@external\ndef isYieldLego() -> bool:\n    return True # Savings Green\n\n\n@view\n@external\ndef isDexLego() -> bool:\n    return False\n\n\n###################\n# Debt Management #\n###################\n\n\n# add collateral on Ripe\n\n\n@external\ndef addCollateral(\n    _asset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    assert not yld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = yld._getMiniAddys(_miniAddys)\n\n    # only allowing user wallets to do this\n    assert self._isUserWallet(msg.sender) # dev: not a user wallet\n    assert msg.sender == _recipient # dev: recipient must be caller\n\n    # pre balances\n    preLegoBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n\n    # transfer deposit asset to this contract\n    depositAmount: uint256 = min(_amount, staticcall IERC20(_asset).balanceOf(msg.sender))\n    assert depositAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_asset).transferFrom(msg.sender, self, depositAmount, default_return_value=True) # dev: transfer failed\n\n    vaultId: uint256 = 0\n    if _extraData != empty(bytes32):\n        vaultId = convert(_extraData, uint256)\n\n    # deposit into Ripe Protocol\n    teller: address = self._getRipeTellerAndApprove(_asset, depositAmount)\n    depositAmount = extcall RipeTeller(teller).deposit(_asset, depositAmount, _recipient, empty(address), vaultId)\n    self._resetTellerApproval(_asset, teller)\n\n    # refund if full deposit didn't get through\n    currentLegoBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    refundAssetAmount: uint256 = 0\n    if currentLegoBalance > preLegoBalance:\n        refundAssetAmount = currentLegoBalance - preLegoBalance\n        assert extcall IERC20(_asset).transfer(msg.sender, refundAssetAmount, default_return_value=True) # dev: transfer failed\n\n    usdValue: uint256 = extcall Appraiser(miniAddys.appraiser).updatePriceAndGetUsdValue(_asset, depositAmount, miniAddys.missionControl, miniAddys.legoBook)\n    log RipeCollateralDeposit(\n        sender = msg.sender,\n        asset = _asset,\n        assetAmountDeposited = depositAmount,\n        vaultId = vaultId,\n        usdValue = usdValue,\n        recipient = _recipient,\n    )\n    return depositAmount, usdValue\n\n\n# remove collateral on ripe\n\n\n@external\ndef removeCollateral(\n    _asset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    assert not yld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = yld._getMiniAddys(_miniAddys)\n\n    # only allowing user wallets to do this\n    assert self._isUserWallet(msg.sender) # dev: not a user wallet\n    assert msg.sender == _recipient # dev: recipient must be caller\n\n    vaultId: uint256 = 0\n    if _extraData != empty(bytes32):\n        vaultId = convert(_extraData, uint256)\n\n    # withdraw from Ripe Protocol\n    teller: address = staticcall RipeRegistry(RIPE_REGISTRY).getAddr(RIPE_TELLER_ID)\n    amountRemoved: uint256 = extcall RipeTeller(teller).withdraw(_asset, _amount, _recipient, empty(address), vaultId)\n    assert amountRemoved != 0 # dev: no asset amount received\n\n    usdValue: uint256 = extcall Appraiser(miniAddys.appraiser).updatePriceAndGetUsdValue(_asset, amountRemoved, miniAddys.missionControl, miniAddys.legoBook)\n    log RipeCollateralWithdrawal(\n        sender = msg.sender,\n        asset = _asset,\n        assetAmountReceived = amountRemoved,\n        vaultId = vaultId,\n        usdValue = usdValue,\n        recipient = _recipient,\n    )\n    return amountRemoved, usdValue\n\n\n# borrow\n\n\n@external\ndef borrow(\n    _borrowAsset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    assert not yld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = yld._getMiniAddys(_miniAddys)\n\n    # only allowing user wallets to do this\n    assert self._isUserWallet(msg.sender) # dev: not a user wallet\n    assert msg.sender == _recipient # dev: recipient must be caller\n\n    assert _borrowAsset in [RIPE_GREEN_TOKEN, RIPE_SAVINGS_GREEN] # dev: invalid borrow asset\n    wantsSavingsGreen: bool = _borrowAsset == RIPE_SAVINGS_GREEN\n\n    # borrow from Ripe\n    teller: address = staticcall RipeRegistry(RIPE_REGISTRY).getAddr(RIPE_TELLER_ID)\n    borrowAmount: uint256 = extcall RipeTeller(teller).borrow(_amount, _recipient, wantsSavingsGreen, False)\n    assert borrowAmount != 0 # dev: no borrow amount received\n\n    usdValue: uint256 = extcall Appraiser(miniAddys.appraiser).updatePriceAndGetUsdValue(_borrowAsset, borrowAmount, miniAddys.missionControl, miniAddys.legoBook)\n    log RipeBorrow(\n        sender = msg.sender,\n        asset = _borrowAsset,\n        assetAmountBorrowed = borrowAmount,\n        usdValue = usdValue,\n        recipient = _recipient,\n    )\n    return borrowAmount, usdValue\n\n\n# repay debt\n\n\n@external\ndef repayDebt(\n    _paymentAsset: address,\n    _paymentAmount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    assert not yld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = yld._getMiniAddys(_miniAddys)\n\n    # only allowing user wallets to do this\n    assert self._isUserWallet(msg.sender) # dev: not a user wallet\n    assert msg.sender == _recipient # dev: recipient must be caller\n\n    assert _paymentAsset in [RIPE_GREEN_TOKEN, RIPE_SAVINGS_GREEN] # dev: invalid payment asset\n    isPaymentSavingsGreen: bool = _paymentAsset == RIPE_SAVINGS_GREEN\n\n    # pre balances\n    preLegoBalance: uint256 = staticcall IERC20(_paymentAsset).balanceOf(self)\n\n    # transfer deposit asset to this contract\n    paymentAmount: uint256 = min(_paymentAmount, staticcall IERC20(_paymentAsset).balanceOf(msg.sender))\n    assert paymentAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_paymentAsset).transferFrom(msg.sender, self, paymentAmount, default_return_value=True) # dev: transfer failed\n\n    # deposit into Ripe Protocol\n    teller: address = self._getRipeTellerAndApprove(_paymentAsset, paymentAmount)\n    extcall RipeTeller(teller).repay(paymentAmount, _recipient, isPaymentSavingsGreen, True)\n    self._resetTellerApproval(_paymentAsset, teller)\n\n    # refund if full deposit didn't get through\n    currentLegoBalance: uint256 = staticcall IERC20(_paymentAsset).balanceOf(self)\n    refundAssetAmount: uint256 = 0\n    if currentLegoBalance > preLegoBalance:\n        refundAssetAmount = currentLegoBalance - preLegoBalance\n        assert extcall IERC20(_paymentAsset).transfer(msg.sender, refundAssetAmount, default_return_value=True) # dev: transfer failed\n\n    usdValue: uint256 = extcall Appraiser(miniAddys.appraiser).updatePriceAndGetUsdValue(_paymentAsset, paymentAmount, miniAddys.missionControl, miniAddys.legoBook)\n    log RipeRepay(\n        sender = msg.sender,\n        asset = _paymentAsset,\n        assetAmountRepaid = paymentAmount,\n        usdValue = usdValue,\n        recipient = _recipient,\n    )\n    return paymentAmount, usdValue\n\n\n# shared utils\n\n\n@internal\ndef _getRipeTellerAndApprove(_asset: address, _amount: uint256) -> address:\n    teller: address = staticcall RipeRegistry(RIPE_REGISTRY).getAddr(RIPE_TELLER_ID)\n    assert extcall IERC20(_asset).approve(teller, _amount, default_return_value=True) # dev: approval failed\n    return teller\n\n\n@internal\ndef _resetTellerApproval(_asset: address, _teller: address):\n    if _teller != empty(address):\n        assert extcall IERC20(_asset).approve(_teller, 0, default_return_value = True) # dev: approval failed\n\n\n@view\n@internal\ndef _isUserWallet(_user: address) -> bool:\n    return staticcall Ledger(addys._getLedgerAddr()).isUserWallet(_user)\n\n\n#################\n# Claim Rewards #\n#################\n\n\n@external\ndef claimRewards(\n    _user: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _extraData: bytes32,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    assert not yld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = yld._getMiniAddys(_miniAddys)\n\n    # NOTE: not checking isUserWallet -- Ripe's Endaoment needs to be able to call this\n    assert msg.sender == _user # dev: recipient must be caller\n\n    assert _rewardToken == RIPE_TOKEN # dev: invalid reward token\n\n    teller: address = staticcall RipeRegistry(RIPE_REGISTRY).getAddr(RIPE_TELLER_ID)\n    totalRipe: uint256 = extcall RipeTeller(teller).claimLoot(_user, True)\n    assert totalRipe != 0 # dev: no ripe tokens received\n\n    usdValue: uint256 = extcall Appraiser(miniAddys.appraiser).updatePriceAndGetUsdValue(_rewardToken, totalRipe, miniAddys.missionControl, miniAddys.legoBook)\n    log RipeClaimRewards(\n        sender = msg.sender,\n        asset = _rewardToken,\n        ripeClaimed = totalRipe,\n        usdValue = usdValue,\n        recipient = _user,\n    )\n    return totalRipe, usdValue\n\n\n#################\n# Savings Green #\n#################\n\n\n# deposit\n\n\n@external\ndef depositForYield(\n    _asset: address,\n    _amount: uint256,\n    _vaultAddr: address,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, address, uint256, uint256):\n    assert not yld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = yld._getMiniAddys(_miniAddys)\n\n    # verify vault token (register if necessary)\n    vaultToken: address = self._getVaultTokenOnDeposit(_asset, _vaultAddr, miniAddys.ledger, miniAddys.legoBook)\n\n    # pre balances\n    preLegoBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n\n    # transfer deposit asset to this contract\n    depositAmount: uint256 = min(_amount, staticcall IERC20(_asset).balanceOf(msg.sender))\n    assert depositAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_asset).transferFrom(msg.sender, self, depositAmount, default_return_value=True) # dev: transfer failed\n\n    # deposit assets into lego partner\n    vaultTokenAmountReceived: uint256 = extcall IERC4626(vaultToken).deposit(depositAmount, _recipient)\n    assert vaultTokenAmountReceived != 0 # dev: no vault tokens received\n\n    # refund if full deposit didn't get through\n    currentLegoBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    refundAssetAmount: uint256 = 0\n    if currentLegoBalance > preLegoBalance:\n        refundAssetAmount = currentLegoBalance - preLegoBalance\n        assert extcall IERC20(_asset).transfer(msg.sender, refundAssetAmount, default_return_value=True) # dev: transfer failed\n        depositAmount -= refundAssetAmount\n\n    usdValue: uint256 = extcall Appraiser(miniAddys.appraiser).updatePriceAndGetUsdValue(_asset, depositAmount, miniAddys.missionControl, miniAddys.legoBook)\n    log RipeSavingsGreenDeposit(\n        sender = msg.sender,\n        asset = _asset,\n        vaultToken = vaultToken,\n        assetAmountDeposited = depositAmount,\n        usdValue = usdValue,\n        vaultTokenAmountReceived = vaultTokenAmountReceived,\n        recipient = _recipient,\n    )\n    return depositAmount, vaultToken, vaultTokenAmountReceived, usdValue\n\n\n# validate green / sgreen tokens\n\n\n@internal\ndef _getVaultTokenOnDeposit(_asset: address, _vaultAddr: address, _ledger: address, _legoBook: address) -> address:\n    assert _vaultAddr == RIPE_SAVINGS_GREEN # dev: must be savings green\n    assert _asset == RIPE_GREEN_TOKEN # dev: must be green token\n\n    # register if necessary\n    if yld.vaultToAsset[_vaultAddr] == empty(address):\n        self._registerAsset(_asset, _vaultAddr)\n        self._updateLedgerVaultToken(_asset, _vaultAddr, _ledger, _legoBook)\n\n    return _vaultAddr\n\n\n# withdraw\n\n\n@external\ndef withdrawFromYield(\n    _vaultToken: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, address, uint256, uint256):\n    assert not yld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = yld._getMiniAddys(_miniAddys)\n\n    # verify asset (register if necessary)\n    asset: address = self._getAssetOnWithdraw(_vaultToken, miniAddys.ledger, miniAddys.legoBook)\n\n    # pre balances\n    preLegoVaultBalance: uint256 = staticcall IERC20(_vaultToken).balanceOf(self)\n\n    # transfer vaults tokens to this contract\n    vaultTokenAmount: uint256 = min(_amount, staticcall IERC20(_vaultToken).balanceOf(msg.sender))\n    assert vaultTokenAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_vaultToken).transferFrom(msg.sender, self, vaultTokenAmount, default_return_value=True) # dev: transfer failed\n\n    # withdraw assets from lego partner\n    assetAmountReceived: uint256 = extcall IERC4626(_vaultToken).redeem(vaultTokenAmount, _recipient, self)\n    assert assetAmountReceived != 0 # dev: no asset amount received\n\n    # refund if full withdrawal didn't happen\n    currentLegoVaultBalance: uint256 = staticcall IERC20(_vaultToken).balanceOf(self)\n    refundVaultTokenAmount: uint256 = 0\n    if currentLegoVaultBalance > preLegoVaultBalance:\n        refundVaultTokenAmount = currentLegoVaultBalance - preLegoVaultBalance\n        assert extcall IERC20(_vaultToken).transfer(msg.sender, refundVaultTokenAmount, default_return_value=True) # dev: transfer failed\n        vaultTokenAmount -= refundVaultTokenAmount\n\n    usdValue: uint256 = extcall Appraiser(miniAddys.appraiser).updatePriceAndGetUsdValue(asset, assetAmountReceived, miniAddys.missionControl, miniAddys.legoBook)\n    log RipeSavingsGreenWithdrawal(\n        sender = msg.sender,\n        asset = asset,\n        vaultToken = _vaultToken,\n        assetAmountReceived = assetAmountReceived,\n        usdValue = usdValue,\n        vaultTokenAmountBurned = vaultTokenAmount,\n        recipient = _recipient,\n    )\n    return vaultTokenAmount, asset, assetAmountReceived, usdValue\n\n\n# vault token verification\n\n\n@internal\ndef _getAssetOnWithdraw(_vaultToken: address, _ledger: address, _legoBook: address) -> address:\n    assert _vaultToken == RIPE_SAVINGS_GREEN # dev: must be savings green\n    asset: address = RIPE_GREEN_TOKEN\n\n    # register if necessary\n    if yld.vaultToAsset[_vaultToken] == empty(address):\n        self._registerAsset(asset, _vaultToken)\n        self._updateLedgerVaultToken(asset, _vaultToken, _ledger, _legoBook)\n\n    return asset\n\n\n#######################\n# Savings Green Utils #\n#######################\n\n\n@view\n@external\ndef isRebasing() -> bool:\n    return self._isRebasing()\n\n\n@view\n@internal\ndef _isRebasing() -> bool:\n    return False\n\n\n@view\n@external\ndef isEligibleVaultForTrialFunds(_vaultToken: address, _underlyingAsset: address) -> bool:\n    return False\n\n\n@view\n@external\ndef isEligibleForYieldBonus(_asset: address) -> bool:\n    # likely already giving away RIPE tokens, not allowing sGREEN to have bonus\n    return False\n\n\n# underlying asset\n\n\n@view\n@external\ndef isVaultToken(_vaultToken: address) -> bool:\n    return self._isVaultToken(_vaultToken)\n\n\n@view\n@internal\ndef _isVaultToken(_vaultToken: address) -> bool:\n    return _vaultToken == RIPE_SAVINGS_GREEN\n\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    return self._getUnderlyingAsset(_vaultToken)\n\n\n@view\n@internal\ndef _getUnderlyingAsset(_vaultToken: address) -> address:\n    if _vaultToken != RIPE_SAVINGS_GREEN:\n        return empty(address)\n    return RIPE_GREEN_TOKEN\n\n\n# underlying amount\n\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    if not self._isVaultToken(_vaultToken) or _vaultTokenAmount == 0:\n        return 0 # invalid vault token or amount\n    return self._getUnderlyingAmount(_vaultToken, _vaultTokenAmount)\n\n\n@view\n@internal\ndef _getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    return staticcall IERC4626(_vaultToken).convertToAssets(_vaultTokenAmount)\n\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    if empty(address) in [_asset, _vaultToken] or _assetAmount == 0:\n        return 0 # bad inputs\n    if self._getUnderlyingAsset(_vaultToken) != _asset:\n        return 0 # invalid vault token or asset\n    return staticcall IERC4626(_vaultToken).convertToShares(_assetAmount)\n\n\n# usd value\n\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> uint256:\n    return self._getUsdValueOfVaultToken(_vaultToken, _vaultTokenAmount, _appraiser)\n\n\n@view\n@internal\ndef _getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address) -> uint256:\n    asset: address = empty(address)\n    underlyingAmount: uint256 = 0\n    usdValue: uint256 = 0\n    asset, underlyingAmount, usdValue = self._getUnderlyingData(_vaultToken, _vaultTokenAmount, _appraiser)\n    return usdValue\n\n\n# all underlying data together\n\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> (address, uint256, uint256):\n    return self._getUnderlyingData(_vaultToken, _vaultTokenAmount, _appraiser)\n\n\n@view\n@internal\ndef _getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address) -> (address, uint256, uint256):\n    if _vaultTokenAmount == 0 or _vaultToken == empty(address):\n        return empty(address), 0, 0 # bad inputs\n    asset: address = self._getUnderlyingAsset(_vaultToken)\n    if asset == empty(address):\n        return empty(address), 0, 0 # invalid vault token\n    underlyingAmount: uint256 = self._getUnderlyingAmount(_vaultToken, _vaultTokenAmount)\n    usdValue: uint256 = self._getUsdValue(asset, underlyingAmount, _appraiser)\n    return asset, underlyingAmount, usdValue\n\n\n@view\n@internal\ndef _getUsdValue(_asset: address, _amount: uint256, _appraiser: address) -> uint256:\n    appraiser: address = _appraiser\n    if _appraiser == empty(address):\n        appraiser = addys._getAppraiserAddr()\n    return staticcall Appraiser(appraiser).getUsdValue(_asset, _amount)\n\n\n# other\n\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    if not self._isVaultToken(_vaultToken):\n        return 0 # invalid vault token\n    return staticcall IERC4626(_vaultToken).totalAssets()\n\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    return 0 # TODO\n\n\n# price per share\n\n\n@view\n@external\ndef getPricePerShare(_asset: address, _decimals: uint256) -> uint256:\n    return staticcall IERC4626(_asset).convertToAssets(10 ** _decimals)\n\n\n################\n# Registration #\n################\n\n\n@external\ndef addAssetOpportunity(_asset: address, _vaultAddr: address):\n    pass\n\n\n@external\ndef removeAssetOpportunity(_asset: address, _vaultAddr: address):\n    pass\n\n\n@internal\ndef _registerAsset(_asset: address, _vaultAddr: address):\n    assert extcall IERC20(_asset).approve(_vaultAddr, max_value(uint256), default_return_value=True) # dev: max approval failed\n    yld._addAssetOpportunity(_asset, _vaultAddr)\n\n\n# update ledger registration\n\n\n@internal\ndef _updateLedgerVaultToken(\n    _underlyingAsset: address,\n    _vaultToken: address,\n    _ledger: address,\n    _legoBook: address,\n):\n    if empty(address) in [_underlyingAsset, _vaultToken]:\n        return\n\n    if not staticcall Ledger(_ledger).isRegisteredVaultToken(_vaultToken):\n        legoId: uint256 = staticcall UndyRegistry(_legoBook).getRegId(self)\n        decimals: uint256 = convert(staticcall IERC20Detailed(_vaultToken).decimals(), uint256)\n        extcall Ledger(_ledger).setVaultToken(_vaultToken, legoId, _underlyingAsset, decimals, self._isRebasing())\n\n\n#########\n# Other #\n#########\n\n\n@external\ndef swapTokens(\n    _amountIn: uint256,\n    _minAmountOut: uint256,\n    _tokenPath: DynArray[address, MAX_TOKEN_PATH],\n    _poolPath: DynArray[address, MAX_TOKEN_PATH - 1],\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256):\n    return 0, 0, 0\n\n\n@external\ndef mintOrRedeemAsset(\n    _tokenIn: address,\n    _tokenOut: address,\n    _tokenInAmount: uint256,\n    _minAmountOut: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, bool, uint256):\n    return 0, 0, False, 0\n\n\n@external\ndef confirmMintOrRedeemAsset(\n    _tokenIn: address,\n    _tokenOut: address,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef addLiquidity(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _amountA: uint256,\n    _amountB: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _minLpAmount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (address, uint256, uint256, uint256, uint256):\n    return empty(address), 0, 0, 0, 0\n\n\n@external\ndef removeLiquidity(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpToken: address,\n    _lpAmount: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, uint256):\n    return 0, 0, 0, 0\n\n\n@external\ndef addLiquidityConcentrated(\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _tickLower: int24,\n    _tickUpper: int24,\n    _amountA: uint256,\n    _amountB: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, uint256, uint256):\n    return 0, 0, 0, 0, 0\n\n\n@external\ndef removeLiquidityConcentrated(\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _liqToRemove: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, bool, uint256):\n    return 0, 0, 0, False, 0\n\n\n@view\n@external\ndef getPrice(_asset: address, _decimals: uint256) -> uint256:\n    return 0\n",
            "sha256sum": "d3de27fa02d0ed5e8ede51fa0297a0f8ae4553d86e69682892240055cc5b999c"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/legos/RipeLego.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.3+commit.bff19ea2",
        "integrity": "746f913663ec44675c289ea1ff5b9b007d7c43e162c91f879f9419966006442c"
      },
      "args": "00000000000000000000000044cf3c4f000dfd76a35d03298049d37be688d6f90000000000000000000000006162df1b329e157479f8f1407e888260e0ec3d2b",
      "file": "contracts/legos/RipeLego.vy"
    },
    "AaveV3": {
      "address": "0xb7401d91f1586474164B6c6Df328E3C3A5f24649",
      "abi": [
        {
          "name": "AaveV3Deposit",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountDeposited",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultTokenAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AaveV3Withdrawal",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultTokenAmountBurned",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LegoPauseModified",
          "inputs": [
            {
              "name": "isPaused",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LegoFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "balance",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetOpportunityAdded",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultAddr",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetOpportunityRemoved",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultAddr",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddys",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "undyToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "hatchery",
                  "type": "address"
                },
                {
                  "name": "lootDistributor",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                },
                {
                  "name": "walletBackpack",
                  "type": "address"
                },
                {
                  "name": "billing",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUndyHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isLegoAsset",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssetOpportunities",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isAssetOpportunity",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getNumLegoAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pause",
          "inputs": [
            {
              "name": "_shouldPause",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFundsMany",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_assets",
              "type": "address[]"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isPaused",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assetOpportunities",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAssetOpportunity",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssetOpportunities",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "vaultToAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assets",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasCapability",
          "inputs": [
            {
              "name": "_action",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRegistries",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isYieldLego",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isDexLego",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isEligibleVaultForTrialFunds",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_underlyingAsset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isEligibleForYieldBonus",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isRebasing",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositForYield",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositForYield",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawFromYield",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawFromYield",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAsset",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAmount",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getVaultTokenAmount",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_assetAmount",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValueOfVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValueOfVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            },
            {
              "name": "_appraiser",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingData",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingData",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            },
            {
              "name": "_appraiser",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalAssets",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalBorrows",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPricePerShare",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_decimals",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addAssetOpportunity",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeAssetOpportunity",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_tokenPath",
              "type": "address[]"
            },
            {
              "name": "_poolPath",
              "type": "address[]"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_tokenPath",
              "type": "address[]"
            },
            {
              "name": "_poolPath",
              "type": "address[]"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_tokenInAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_tokenInAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmMintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmMintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_borrowAsset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_borrowAsset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_paymentAsset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_paymentAsset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAccessForLego",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_action",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "string"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPrice",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_decimals",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "AAVE_V3_POOL",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "AAVE_V3_ADDRESS_PROVIDER",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_undyHq",
              "type": "address"
            },
            {
              "name": "_aaveV3",
              "type": "address"
            },
            {
              "name": "_addressProvider",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "interfaces/WalletStructs.vyi": {
            "content": "# @version 0.4.3\n\nflag ActionType:\n    TRANSFER\n    EARN_DEPOSIT\n    EARN_WITHDRAW\n    EARN_REBALANCE\n    SWAP\n    MINT_REDEEM\n    CONFIRM_MINT_REDEEM\n    ADD_COLLATERAL\n    REMOVE_COLLATERAL\n    BORROW\n    REPAY_DEBT\n    REWARDS\n    ETH_TO_WETH\n    WETH_TO_ETH\n    ADD_LIQ\n    REMOVE_LIQ\n    ADD_LIQ_CONC\n    REMOVE_LIQ_CONC\n    PAY_CHEQUE\n\nstruct WalletAssetData:\n    assetBalance: uint256\n    usdValue: uint256\n    isYieldAsset: bool\n    lastPricePerShare: uint256\n\nstruct ActionData:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    billing: address\n    wallet: address\n    walletConfig: address\n    walletOwner: address\n    inEjectMode: bool\n    isFrozen: bool\n    lastTotalUsdValue: uint256\n    signer: address\n    isManager: bool\n    legoId: uint256\n    legoAddr: address\n    eth: address\n    weth: address\n\nstruct MiniAddys:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    appraiser: address",
            "sha256sum": "9a4b4f59b3a62043e51b425a665064aae419a3c0bd0514b6b29a9441ae364bb9"
          },
          "interfaces/LegoPartner.vyi": {
            "content": "# @version 0.4.3\n\nfrom interfaces import WalletStructs as ws\n\nMAX_TOKEN_PATH: constant(uint256) = 5\nMAX_RECOVER_ASSETS: constant(uint256) = 20\n\n@external\ndef addLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _tickLower: int24, _tickUpper: int24, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef addLiquidity(_pool: address, _tokenA: address, _tokenB: address, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _minLpAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (address, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef removeLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _liqToRemove: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef removeLiquidity(_pool: address, _tokenA: address, _tokenB: address, _lpToken: address, _lpAmount: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef mintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _tokenInAmount: uint256, _minAmountOut: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef swapTokens(_amountIn: uint256, _minAmountOut: uint256, _tokenPath: DynArray[address, MAX_TOKEN_PATH], _poolPath: DynArray[address, MAX_TOKEN_PATH - 1], _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256):\n    ...\n\n@external\ndef depositForYield(_asset: address, _amount: uint256, _vaultAddr: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef withdrawFromYield(_vaultToken: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef confirmMintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef borrow(_borrowAsset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef repayDebt(_paymentAsset: address, _paymentAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef claimRewards(_user: address, _rewardToken: address, _rewardAmount: uint256, _extraData: bytes32, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef removeCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef addCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@view\n@external\ndef getAccessForLego(_user: address, _action: ws.ActionType) -> (address, String[64], uint256):\n    ...\n\n@view\n@external\ndef hasCapability(_action: ws.ActionType) -> bool:\n    ...\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    ...\n\n@view\n@external\ndef isYieldLego() -> bool:\n    ...\n\n@view\n@external\ndef isDexLego() -> bool:\n    ...\n\n@view\n@external\ndef getPricePerShare(_asset: address, _decimals: uint256) -> uint256:\n    ...\n\n@view\n@external\ndef getPrice(_asset: address, _decimals: uint256) -> uint256:\n    ...\n\n\n# common\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "2513e379aa74d0a8120114a5078a4c1a0900165a1c3f24419bb811d173b56453"
          },
          "interfaces/YieldLego.vyi": {
            "content": "# @version 0.4.3\n\n@view\n@external\ndef isRebasing() -> bool:\n    ...\n\n\n@view\n@external\ndef isEligibleForYieldBonus(_asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef isEligibleVaultForTrialFunds(_vaultToken: address, _underlyingAsset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    ...\n\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    ...\n\n\n@view\n@external\ndef isVaultToken(_vaultToken: address) -> bool:\n    ...\n\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> uint256:\n    ...\n\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> (address, uint256, uint256):\n    ...\n\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    ...\n\n\n@external\ndef addAssetOpportunity(_asset: address, _vaultAddr: address):\n    ...\n\n\n@external\ndef removeAssetOpportunity(_asset: address, _vaultAddr: address):\n    ...\n\n\n# YieldLegoData.vy module\n\n\n@view\n@external\ndef assetOpportunities(_asset: address, _index: uint256) -> address:\n    ...\n\n\n@view\n@external\ndef indexOfAssetOpportunity(_asset: address, _vaultAddr: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef numAssetOpportunities(_asset: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef vaultToAsset(_vaultAddr: address) -> address:\n    ...\n\n\n@view\n@external\ndef assets(_index: uint256) -> address:\n    ...\n\n\n@view\n@external\ndef indexOfAsset(_asset: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef numAssets() -> uint256:\n    ...\n\n\n@view\n@external\ndef isLegoAsset(_asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, 40]:\n    ...\n\n\n@view\n@external\ndef getAssets() -> DynArray[address, 20]:\n    ...\n\n\n@view\n@external\ndef isAssetOpportunity(_asset: address, _vaultAddr: address) -> bool:\n    ...\n\n\n@view\n@external\ndef getNumLegoAssets() -> uint256:\n    ...\n",
            "sha256sum": "3337ce5f78b0df6f86d1144b07505512bb1044304f67add97be6c3816b3c0b42"
          },
          "contracts/modules/Addys.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\ninterface UndyHq:\n    def isValidAddr(_addr: address) -> bool: view\n    def getAddr(_regId: uint256) -> address: view\n    def undyToken() -> address: view\n\ninterface Switchboard:\n    def isSwitchboardAddr(_addr: address) -> bool: view\n\ninterface LegoBook:\n    def isLegoAddr(_addr: address) -> bool: view\n\nstruct Addys:\n    hq: address\n    undyToken: address\n    ledger: address\n    missionControl: address\n    legoBook: address\n    switchboard: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    walletBackpack: address\n    billing: address\n\n# hq\nUNDY_HQ_FOR_ADDYS: immutable(address)\n\n# core addys\nLEDGER_ID: constant(uint256) = 1\nMISSION_CONTROL_ID: constant(uint256) = 2\nLEGO_BOOK_ID: constant(uint256) = 3\nSWITCHBOARD_ID: constant(uint256) = 4\nHATCHERY_ID: constant(uint256) = 5\nLOOT_DISTRIBUTOR_ID: constant(uint256) = 6\nAPPRAISER_ID: constant(uint256) = 7\nWALLET_BACKPACK_ID: constant(uint256) = 8\nBILLING_ID: constant(uint256) = 9\n\n\n@deploy\ndef __init__(_undyHq: address):\n    assert _undyHq != empty(address) # dev: invalid undy hq\n    UNDY_HQ_FOR_ADDYS = _undyHq\n\n\n########\n# Core #\n########\n\n\n@view\n@external\ndef getAddys() -> Addys:\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _getAddys(_addys: Addys = empty(Addys)) -> Addys:\n    if _addys.hq != empty(address):\n        return _addys\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _generateAddys() -> Addys:\n    hq: address = UNDY_HQ_FOR_ADDYS\n    return Addys(\n        hq = hq,\n        undyToken = staticcall UndyHq(hq).undyToken(),\n        ledger = staticcall UndyHq(hq).getAddr(LEDGER_ID),\n        missionControl = staticcall UndyHq(hq).getAddr(MISSION_CONTROL_ID),\n        legoBook = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID),\n        switchboard = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID),\n        hatchery = staticcall UndyHq(hq).getAddr(HATCHERY_ID),\n        lootDistributor = staticcall UndyHq(hq).getAddr(LOOT_DISTRIBUTOR_ID),\n        appraiser = staticcall UndyHq(hq).getAddr(APPRAISER_ID),\n        walletBackpack = staticcall UndyHq(hq).getAddr(WALLET_BACKPACK_ID),\n        billing = staticcall UndyHq(hq).getAddr(BILLING_ID),\n    )\n\n\n##########\n# Tokens #\n##########\n\n\n@view\n@internal\ndef _getUndyToken() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).undyToken()\n\n\n###########\n# Helpers #\n###########\n\n\n# undy hq\n\n\n@view\n@external\ndef getUndyHq() -> address:\n    return self._getUndyHq()\n\n\n@view\n@internal\ndef _getUndyHq() -> address:\n    return UNDY_HQ_FOR_ADDYS\n\n\n# utils\n\n\n@view\n@internal\ndef _isValidUndyAddr(_addr: address, _hq: address = empty(address)) -> bool:\n    hq: address = _hq\n    if _hq == empty(address):\n        hq = UNDY_HQ_FOR_ADDYS\n    \n    # core departments\n    if staticcall UndyHq(hq).isValidAddr(_addr):\n        return True\n\n    # lego book\n    legoBook: address = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID)\n    if legoBook != empty(address) and staticcall LegoBook(legoBook).isLegoAddr(_addr):\n        return True\n\n    # switchboard config\n    switchboard: address = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID)\n    if switchboard != empty(address) and staticcall Switchboard(switchboard).isSwitchboardAddr(_addr):\n        return True\n\n    return False\n\n\n@view\n@internal\ndef _isSwitchboardAddr(_addr: address) -> bool:\n    switchboard: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n    if switchboard == empty(address):\n        return False\n    return staticcall Switchboard(switchboard).isSwitchboardAddr(_addr)\n\n\n@view\n@internal\ndef _isLegoBookAddr(_addr: address) -> bool:\n    legoBook: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n    if legoBook == empty(address):\n        return False\n    return staticcall LegoBook(legoBook).isLegoAddr(_addr)\n\n\n###############\n# Departments #\n###############\n\n\n# ledger\n\n\n@view\n@internal\ndef _getLedgerId() -> uint256:\n    return LEDGER_ID\n\n\n@view\n@internal\ndef _getLedgerAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEDGER_ID)\n\n\n# mission control\n\n\n@view\n@internal\ndef _getMissionControlId() -> uint256:\n    return MISSION_CONTROL_ID\n\n\n@view\n@internal\ndef _getMissionControlAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(MISSION_CONTROL_ID)\n\n\n# lego book\n\n\n@view\n@internal\ndef _getLegoBookId() -> uint256:\n    return LEGO_BOOK_ID\n\n\n@view\n@internal\ndef _getLegoBookAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n\n\n# switchboard\n\n\n@view\n@internal\ndef _getSwitchboardId() -> uint256:\n    return SWITCHBOARD_ID\n\n\n@view\n@internal\ndef _getSwitchboardAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n\n\n# hatchery\n\n\n@view\n@internal\ndef _getHatcheryId() -> uint256:\n    return HATCHERY_ID\n\n\n@view\n@internal\ndef _getHatcheryAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(HATCHERY_ID)\n\n\n# loot distributor\n\n\n@view\n@internal\ndef _getLootDistributorId() -> uint256:\n    return LOOT_DISTRIBUTOR_ID\n\n\n@view\n@internal\ndef _getLootDistributorAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LOOT_DISTRIBUTOR_ID)\n\n\n# appraiser\n\n\n@view\n@internal\ndef _getAppraiserId() -> uint256:\n    return APPRAISER_ID\n\n\n@view\n@internal\ndef _getAppraiserAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(APPRAISER_ID)\n\n\n# wallet backpack\n\n\n@view\n@internal\ndef _getWalletBackpackId() -> uint256:\n    return WALLET_BACKPACK_ID\n\n\n@view\n@internal\ndef _getWalletBackpackAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(WALLET_BACKPACK_ID)\n\n\n# billing\n\n\n@view\n@internal\ndef _getBillingId() -> uint256:\n    return BILLING_ID\n\n\n@view\n@internal\ndef _getBillingAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(BILLING_ID)",
            "sha256sum": "78b58f0b2acb2eaafa4d21adf9135a1cd0e1d53897f7a1fa70a83a04a7738ad3"
          },
          "contracts/modules/YieldLegoData.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nuses: addys\n\nimport contracts.modules.Addys as addys\n\nfrom interfaces import WalletStructs as ws\nfrom ethereum.ercs import IERC20\n\nevent AssetOpportunityAdded:\n    asset: indexed(address)\n    vaultAddr: indexed(address)\n\nevent AssetOpportunityRemoved:\n    asset: indexed(address)\n    vaultAddr: indexed(address)\n\nevent LegoPauseModified:\n    isPaused: bool\n\nevent LegoFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    balance: uint256\n\n# config\nisPaused: public(bool)\n\n# asset opportunities\nassetOpportunities: public(HashMap[address, HashMap[uint256, address]]) # asset -> index -> vault addr\nindexOfAssetOpportunity: public(HashMap[address, HashMap[address, uint256]]) # asset -> vault addr -> index\nnumAssetOpportunities: public(HashMap[address, uint256]) # asset -> number of opportunities\n\n# mapping\nvaultToAsset: public(HashMap[address, address]) # vault addr -> underlying asset\n\n# lego assets (iterable)\nassets: public(HashMap[uint256, address]) # index -> asset\nindexOfAsset: public(HashMap[address, uint256]) # asset -> index\nnumAssets: public(uint256) # num assets\n\nMAX_VAULTS: constant(uint256) = 40\nMAX_ASSETS: constant(uint256) = 20\nMAX_RECOVER_ASSETS: constant(uint256) = 20\n\n\n@deploy\ndef __init__(_shouldPause: bool):\n    self.isPaused = _shouldPause\n    self.numAssets = 1 # not using 0 index\n\n\n#########\n# Views #\n#########\n\n\n# is lego asset\n\n\n@view\n@external\ndef isLegoAsset(_asset: address) -> bool:\n    return self._isLegoAsset(_asset)\n\n\n@view\n@internal\ndef _isLegoAsset(_asset: address) -> bool:\n    return self.indexOfAsset[_asset] != 0\n\n\n# vault opportunities\n\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, MAX_VAULTS]:\n    numOpportunities: uint256 = self.numAssetOpportunities[_asset]\n    if numOpportunities == 0:\n        return []\n    opportunities: DynArray[address, MAX_VAULTS] = []\n    for i: uint256 in range(1, numOpportunities, bound=MAX_VAULTS):\n        opportunities.append(self.assetOpportunities[_asset][i])\n    return opportunities\n\n\n# all assets registered\n\n\n@view\n@external\ndef getAssets() -> DynArray[address, MAX_ASSETS]:\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return []\n    assets: DynArray[address, MAX_ASSETS] = []\n    for i: uint256 in range(1, numAssets, bound=MAX_ASSETS):\n        assets.append(self.assets[i])\n    return assets\n\n\n################\n# Registration #\n################\n\n\n@view\n@external\ndef isAssetOpportunity(_asset: address, _vaultAddr: address) -> bool:\n    return self._isAssetOpportunity(_asset, _vaultAddr)\n\n\n@view\n@internal\ndef _isAssetOpportunity(_asset: address, _vaultAddr: address) -> bool:\n    return self.indexOfAssetOpportunity[_asset][_vaultAddr] != 0\n\n\n# add asset opportunity\n\n\n@internal\ndef _addAssetOpportunity(_asset: address, _vaultAddr: address):\n    if self.indexOfAssetOpportunity[_asset][_vaultAddr] != 0:\n        return\n    if empty(address) in [_asset, _vaultAddr]:\n        return\n\n    # add asset opportunity\n    aid: uint256 = self.numAssetOpportunities[_asset]\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.assetOpportunities[_asset][aid] = _vaultAddr\n    self.indexOfAssetOpportunity[_asset][_vaultAddr] = aid\n    self.numAssetOpportunities[_asset] = aid + 1\n\n    # add mapping\n    self.vaultToAsset[_vaultAddr] = _asset\n\n    # add asset\n    self._addAsset(_asset)\n\n    log AssetOpportunityAdded(asset=_asset, vaultAddr=_vaultAddr)\n\n\n# remove asset opportunity\n\n\n@internal\ndef _removeAssetOpportunity(_asset: address, _vaultAddr: address):\n    numOpportunities: uint256 = self.numAssetOpportunities[_asset]\n    if numOpportunities == 0:\n        return\n\n    targetIndex: uint256 = self.indexOfAssetOpportunity[_asset][_vaultAddr]\n    if targetIndex == 0:\n        return\n\n    # update data\n    lastIndex: uint256 = numOpportunities - 1\n    self.numAssetOpportunities[_asset] = lastIndex\n    self.indexOfAssetOpportunity[_asset][_vaultAddr] = 0\n\n    self.vaultToAsset[_vaultAddr] = empty(address)\n\n    # shift to replace the removed one\n    if targetIndex != lastIndex:\n        lastVaultAddr: address = self.assetOpportunities[_asset][lastIndex]\n        self.assetOpportunities[_asset][targetIndex] = lastVaultAddr\n        self.indexOfAssetOpportunity[_asset][lastVaultAddr] = targetIndex\n\n    # remove asset\n    if lastIndex <= 1:\n        self._removeAsset(_asset)\n\n    log AssetOpportunityRemoved(asset=_asset, vaultAddr=_vaultAddr)\n\n\n# add asset\n\n\n@internal\ndef _addAsset(_asset: address):\n    if self.indexOfAsset[_asset] != 0:\n        return\n\n    aid: uint256 = self.numAssets\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.assets[aid] = _asset\n    self.indexOfAsset[_asset] = aid\n    self.numAssets = aid + 1\n\n\n# remove asset\n\n\n@internal\ndef _removeAsset(_asset: address):\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return\n\n    targetIndex: uint256 = self.indexOfAsset[_asset]\n    if targetIndex == 0:\n        return\n\n    # update data\n    lastIndex: uint256 = numAssets - 1\n    self.numAssets = lastIndex\n    self.indexOfAsset[_asset] = 0\n\n    # shift to replace the removed one\n    if targetIndex != lastIndex:\n        lastAsset: address = self.assets[lastIndex]\n        self.assets[targetIndex] = lastAsset\n        self.indexOfAsset[lastAsset] = targetIndex\n\n\n# num lego assets (true number, use `numAssets` for iteration)\n\n\n@view\n@external\ndef getNumLegoAssets() -> uint256:\n    return self._getNumLegoAssets()\n\n\n@view\n@internal\ndef _getNumLegoAssets() -> uint256:\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return 0\n    return numAssets - 1\n\n\n###########\n# General #\n###########\n\n\n# fill mini addys\n\n\n@view\n@internal\ndef _getMiniAddys(_miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> ws.MiniAddys:\n    if _miniAddys.ledger != empty(address):\n        return _miniAddys\n    return ws.MiniAddys(\n        ledger = addys._getLedgerAddr(),\n        missionControl = addys._getMissionControlAddr(),\n        legoBook = addys._getLegoBookAddr(),\n        appraiser = addys._getAppraiserAddr(),\n    )\n\n\n# activate\n\n\n@external\ndef pause(_shouldPause: bool):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert _shouldPause != self.isPaused # dev: no change\n    self.isPaused = _shouldPause\n    log LegoPauseModified(isPaused=_shouldPause)\n\n\n# recover funds\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    self._recoverFunds(_recipient, _asset)\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, MAX_RECOVER_ASSETS]):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    for a: address in _assets:\n        self._recoverFunds(_recipient, a)\n\n\n@internal\ndef _recoverFunds(_recipient: address, _asset: address):\n    assert empty(address) not in [_recipient, _asset] # dev: invalid recipient or asset\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    assert balance != 0 # dev: nothing to recover\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log LegoFundsRecovered(asset=_asset, recipient=_recipient, balance=balance)",
            "sha256sum": "bcbae5ce139758ce8a77c03858ec8d438dea0437d5f3a20fed8267f4d2f15b66"
          },
          "contracts/legos/yield/AaveV3.vy": {
            "content": "#     __   __ ___ _______ ___     ______       ___     _______ _______ _______ \n#    |  | |  |   |       |   |   |      |     |   |   |       |       |       |\n#    |  |_|  |   |    ___|   |   |  _    |    |   |   |    ___|    ___|   _   |\n#    |       |   |   |___|   |   | | |   |    |   |   |   |___|   | __|  | |  |\n#    |_     _|   |    ___|   |___| |_|   |    |   |___|    ___|   ||  |  |_|  |\n#      |   | |   |   |___|       |       |    |       |   |___|   |_| |       |\n#      |___| |___|_______|_______|______|     |_______|_______|_______|_______|\n#                                                                       \n#     \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n#     \u2551  ** Aave V3 Lego **                    \u2551\n#     \u2551  Integration with Aave Protocol (v3)   \u2551\n#     \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n#\n#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nimplements: Lego\nimplements: YieldLego\n\nexports: addys.__interface__\nexports: yld.__interface__\n\ninitializes: addys\ninitializes: yld[addys := addys]\n\nfrom interfaces import LegoPartner as Lego\nfrom interfaces import YieldLego as YieldLego\nfrom interfaces import WalletStructs as ws\n\nimport contracts.modules.Addys as addys\nimport contracts.modules.YieldLegoData as yld\n\nfrom ethereum.ercs import IERC20\nfrom ethereum.ercs import IERC20Detailed\n\ninterface AaveProtocolDataProvider:\n    def getReserveTokensAddresses(_asset: address) -> (address, address, address): view\n    def getAllATokens() -> DynArray[TokenData, MAX_ATOKENS]: view\n    def getTotalDebt(_asset: address) -> uint256: view\n\ninterface Appraiser:\n    def getUsdValue(_asset: address, _amount: uint256, _missionControl: address = empty(address), _legoBook: address = empty(address), _ledger: address = empty(address)) -> uint256: view\n    def updatePriceAndGetUsdValue(_asset: address, _amount: uint256, _missionControl: address = empty(address), _legoBook: address = empty(address)) -> uint256: nonpayable\n\ninterface Ledger:\n    def setVaultToken(_vaultToken: address, _legoId: uint256, _underlyingAsset: address, _decimals: uint256, _isRebasing: bool): nonpayable\n    def isRegisteredVaultToken(_vaultToken: address) -> bool: view\n\ninterface AaveV3Pool:\n    def supply(_asset: address, _amount: uint256, _onBehalfOf: address, _referralCode: uint16): nonpayable\n    def withdraw(_asset: address, _amount: uint256, _to: address): nonpayable\n\ninterface AToken:\n    def UNDERLYING_ASSET_ADDRESS() -> address: view\n    def totalSupply() -> uint256: view\n\ninterface Registry:\n    def getRegId(_addr: address) -> uint256: view\n\ninterface AaveV3AddressProvider:\n    def getPoolDataProvider() -> address: view\n\nstruct TokenData:\n    symbol: String[32]\n    tokenAddress: address\n\nevent AaveV3Deposit:\n    sender: indexed(address)\n    asset: indexed(address)\n    vaultToken: indexed(address)\n    assetAmountDeposited: uint256\n    usdValue: uint256\n    vaultTokenAmountReceived: uint256\n    recipient: address\n\nevent AaveV3Withdrawal:\n    sender: indexed(address)\n    asset: indexed(address)\n    vaultToken: indexed(address)\n    assetAmountReceived: uint256\n    usdValue: uint256\n    vaultTokenAmountBurned: uint256\n    recipient: address\n\n# aave v3\nAAVE_V3_POOL: public(immutable(address))\nAAVE_V3_ADDRESS_PROVIDER: public(immutable(address))\n\nMAX_ATOKENS: constant(uint256) = 40\nMAX_TOKEN_PATH: constant(uint256) = 5\n\n\n@deploy\ndef __init__(\n    _undyHq: address,\n    _aaveV3: address,\n    _addressProvider: address,\n):\n    addys.__init__(_undyHq)\n    yld.__init__(False)\n\n    assert empty(address) not in [_aaveV3, _addressProvider] # dev: invalid addrs\n    AAVE_V3_POOL = _aaveV3\n    AAVE_V3_ADDRESS_PROVIDER = _addressProvider\n\n\n@view\n@external\ndef hasCapability(_action: ws.ActionType) -> bool:\n    return _action in (\n        ws.ActionType.EARN_DEPOSIT | \n        ws.ActionType.EARN_WITHDRAW\n    )\n\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    return [AAVE_V3_POOL, AAVE_V3_ADDRESS_PROVIDER]\n\n\n@view\n@external\ndef isYieldLego() -> bool:\n    return True\n\n\n@view\n@external\ndef isDexLego() -> bool:\n    return False\n\n\n@view\n@external\ndef isEligibleVaultForTrialFunds(_vaultToken: address, _underlyingAsset: address) -> bool:\n    return yld.vaultToAsset[_vaultToken] == _underlyingAsset\n\n\n@view\n@external\ndef isEligibleForYieldBonus(_asset: address) -> bool:\n    return False # not allowing rebasing assets to get yield bonus\n\n\n@view\n@external\ndef isRebasing() -> bool:\n    return self._isRebasing()\n\n\n@view\n@internal\ndef _isRebasing() -> bool:\n    return True\n\n\n#########\n# Yield #\n#########\n\n\n# deposit\n\n\n@external\ndef depositForYield(\n    _asset: address,\n    _amount: uint256,\n    _vaultAddr: address,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, address, uint256, uint256):\n    assert not yld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = yld._getMiniAddys(_miniAddys)\n\n    # verify vault token (register if necessary)\n    vaultToken: address = self._getVaultTokenOnDeposit(_asset, _vaultAddr, miniAddys.ledger, miniAddys.legoBook)\n\n    # pre balances\n    preLegoBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    preRecipientVaultBalance: uint256 = staticcall IERC20(vaultToken).balanceOf(_recipient)\n\n    # transfer deposit asset to this contract\n    depositAmount: uint256 = min(_amount, staticcall IERC20(_asset).balanceOf(msg.sender))\n    assert depositAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_asset).transferFrom(msg.sender, self, depositAmount, default_return_value=True) # dev: transfer failed\n\n    # deposit assets into lego partner\n    extcall AaveV3Pool(AAVE_V3_POOL).supply(_asset, depositAmount, _recipient, 0)\n\n    # validate vault token transfer\n    vaultTokenAmountReceived: uint256 = staticcall IERC20(vaultToken).balanceOf(_recipient) - preRecipientVaultBalance\n    assert vaultTokenAmountReceived != 0 # dev: no vault tokens received\n\n    # refund if full deposit didn't get through\n    currentLegoBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    refundAssetAmount: uint256 = 0\n    if currentLegoBalance > preLegoBalance:\n        refundAssetAmount = currentLegoBalance - preLegoBalance\n        assert extcall IERC20(_asset).transfer(msg.sender, refundAssetAmount, default_return_value=True) # dev: transfer failed\n        depositAmount -= refundAssetAmount\n\n    usdValue: uint256 = extcall Appraiser(miniAddys.appraiser).updatePriceAndGetUsdValue(_asset, depositAmount, miniAddys.missionControl, miniAddys.legoBook)\n    log AaveV3Deposit(\n        sender = msg.sender,\n        asset = _asset,\n        vaultToken = vaultToken,\n        assetAmountDeposited = depositAmount,\n        usdValue = usdValue,\n        vaultTokenAmountReceived = vaultTokenAmountReceived,\n        recipient = _recipient,\n    )\n    return depositAmount, vaultToken, vaultTokenAmountReceived, usdValue\n\n\n# asset verification\n\n\n@internal\ndef _getVaultTokenOnDeposit(_asset: address, _vaultAddr: address, _ledger: address, _legoBook: address) -> address:\n    vaultToken: address = yld.assetOpportunities[_asset][1] # aave v3 only has one opportunity\n    isRegistered: bool = True\n\n    # not yet registered, call aave directly to get vault token\n    if vaultToken == empty(address):\n        vaultToken = self._getAaveVaultToken(_asset, self._getPoolDataProvider())\n        isRegistered = False\n\n    assert vaultToken != empty(address) # dev: invalid vault token\n\n    # make sure input matches\n    if _vaultAddr != empty(address):\n        assert vaultToken == _vaultAddr # dev: vault token mismatch\n\n    # register if necessary\n    if not isRegistered:\n        self._registerAsset(_asset, vaultToken)\n        self._updateLedgerVaultToken(_asset, vaultToken, _ledger, _legoBook)\n\n    return vaultToken\n\n\n# withdraw\n\n\n@external\ndef withdrawFromYield(\n    _vaultToken: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, address, uint256, uint256):\n    assert not yld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = yld._getMiniAddys(_miniAddys)\n\n    # verify asset (register if necessary)\n    asset: address = self._getAssetOnWithdraw(_vaultToken, miniAddys.ledger, miniAddys.legoBook)\n\n    # pre balances\n    preLegoVaultBalance: uint256 = staticcall IERC20(_vaultToken).balanceOf(self)\n    preRecipientAssetBalance: uint256 = staticcall IERC20(asset).balanceOf(_recipient)\n\n    # transfer vaults tokens to this contract\n    vaultTokenAmount: uint256 = min(_amount, staticcall IERC20(_vaultToken).balanceOf(msg.sender))\n    assert vaultTokenAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_vaultToken).transferFrom(msg.sender, self, vaultTokenAmount, default_return_value=True) # dev: transfer failed\n\n    # withdraw assets from lego partner\n    extcall AaveV3Pool(AAVE_V3_POOL).withdraw(asset, max_value(uint256), _recipient)\n\n    # validate asset transfer\n    postRecipientAssetBalance: uint256 = staticcall IERC20(asset).balanceOf(_recipient)\n    assetAmountReceived: uint256 = postRecipientAssetBalance - preRecipientAssetBalance\n    assert assetAmountReceived != 0 # dev: no asset amount received\n\n    # refund if full withdrawal didn't happen\n    currentLegoVaultBalance: uint256 = staticcall IERC20(_vaultToken).balanceOf(self)\n    refundVaultTokenAmount: uint256 = 0\n    if currentLegoVaultBalance > preLegoVaultBalance:\n        refundVaultTokenAmount = currentLegoVaultBalance - preLegoVaultBalance\n        assert extcall IERC20(_vaultToken).transfer(msg.sender, refundVaultTokenAmount, default_return_value=True) # dev: transfer failed\n        vaultTokenAmount -= refundVaultTokenAmount\n\n    usdValue: uint256 = extcall Appraiser(miniAddys.appraiser).updatePriceAndGetUsdValue(asset, assetAmountReceived, miniAddys.missionControl, miniAddys.legoBook)\n    log AaveV3Withdrawal(\n        sender = msg.sender,\n        asset = asset,\n        vaultToken = _vaultToken,\n        assetAmountReceived = assetAmountReceived,\n        usdValue = usdValue,\n        vaultTokenAmountBurned = vaultTokenAmount,\n        recipient = _recipient,\n    )\n    return vaultTokenAmount, asset, assetAmountReceived, usdValue\n\n\n# vault token verification\n\n\n@internal\ndef _getAssetOnWithdraw(_vaultToken: address, _ledger: address, _legoBook: address) -> address:\n    asset: address = yld.vaultToAsset[_vaultToken]\n    isRegistered: bool = True\n\n    # not yet registered, call aave directly to get data\n    if asset == empty(address):\n        dataProvider: address = self._getPoolDataProvider()\n        if self._isValidAToken(_vaultToken, dataProvider):\n            asset = staticcall AToken(_vaultToken).UNDERLYING_ASSET_ADDRESS()\n            isRegistered = False\n\n            # double check it matches\n            assert _vaultToken == self._getAaveVaultToken(asset, dataProvider) # dev: vault token mismatch\n\n    assert asset != empty(address) # dev: invalid vault token\n\n    # register if necessary\n    if not isRegistered:\n        self._registerAsset(asset, _vaultToken)\n        self._updateLedgerVaultToken(asset, _vaultToken, _ledger, _legoBook)\n\n    return asset\n\n\n#############\n# Utilities #\n#############\n\n\n# underlying asset\n\n\n@view\n@external\ndef isVaultToken(_vaultToken: address) -> bool:\n    return self._isVaultToken(_vaultToken)\n\n\n@view\n@internal\ndef _isVaultToken(_vaultToken: address) -> bool:\n    if yld.vaultToAsset[_vaultToken] != empty(address):\n        return True\n    return self._isValidAToken(_vaultToken, self._getPoolDataProvider())\n\n\n@view\n@internal\ndef _isValidAToken(_aToken: address, _dataProvider: address) -> bool:\n    aTokens: DynArray[TokenData, MAX_ATOKENS] = staticcall AaveProtocolDataProvider(_dataProvider).getAllATokens()\n    for i: uint256 in range(len(aTokens), bound=MAX_ATOKENS):\n        if aTokens[i].tokenAddress == _aToken:\n            return True\n    return False\n\n\n@view\n@internal\ndef _getAaveVaultToken(_asset: address, _dataProvider: address) -> address:\n    return (staticcall AaveProtocolDataProvider(_dataProvider).getReserveTokensAddresses(_asset))[0]\n\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    return self._getUnderlyingAsset(_vaultToken)\n\n\n@view\n@internal\ndef _getUnderlyingAsset(_vaultToken: address, _dataProvider: address = empty(address)) -> address:\n    asset: address = yld.vaultToAsset[_vaultToken]\n    if asset != empty(address):\n        return asset\n\n    dataProvider: address = _dataProvider\n    if _dataProvider == empty(address):\n        dataProvider = self._getPoolDataProvider()\n    if self._isValidAToken(_vaultToken, dataProvider):\n        asset = staticcall AToken(_vaultToken).UNDERLYING_ASSET_ADDRESS()\n    return asset\n\n\n# underlying amount\n\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    if not self._isVaultToken(_vaultToken) or _vaultTokenAmount == 0:\n        return 0 # invalid vault token or amount\n    return self._getUnderlyingAmount(_vaultToken, _vaultTokenAmount)\n\n\n@view\n@internal\ndef _getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    # treated as 1:1\n    return _vaultTokenAmount\n\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    if empty(address) in [_asset, _vaultToken] or _assetAmount == 0:\n        return 0 # bad inputs\n    if self._getUnderlyingAsset(_vaultToken) != _asset:\n        return 0 # invalid vault token or asset\n    # treated as 1:1\n    return _assetAmount\n\n\n# usd value\n\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> uint256:\n    return self._getUsdValueOfVaultToken(_vaultToken, _vaultTokenAmount, _appraiser)\n\n\n@view\n@internal\ndef _getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address) -> uint256:\n    asset: address = empty(address)\n    underlyingAmount: uint256 = 0\n    usdValue: uint256 = 0\n    asset, underlyingAmount, usdValue = self._getUnderlyingData(_vaultToken, _vaultTokenAmount, _appraiser)\n    return usdValue\n\n\n# all underlying data together\n\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> (address, uint256, uint256):\n    return self._getUnderlyingData(_vaultToken, _vaultTokenAmount, _appraiser)\n\n\n@view\n@internal\ndef _getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address) -> (address, uint256, uint256):\n    if _vaultTokenAmount == 0 or _vaultToken == empty(address):\n        return empty(address), 0, 0 # bad inputs\n    asset: address = self._getUnderlyingAsset(_vaultToken)\n    if asset == empty(address):\n        return empty(address), 0, 0 # invalid vault token\n    underlyingAmount: uint256 = self._getUnderlyingAmount(_vaultToken, _vaultTokenAmount)\n    usdValue: uint256 = self._getUsdValue(asset, underlyingAmount, _appraiser)\n    return asset, underlyingAmount, usdValue\n\n\n@view\n@internal\ndef _getUsdValue(_asset: address, _amount: uint256, _appraiser: address) -> uint256:\n    appraiser: address = _appraiser\n    if _appraiser == empty(address):\n        appraiser = addys._getAppraiserAddr()\n    return staticcall Appraiser(appraiser).getUsdValue(_asset, _amount)\n\n\n# other\n\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    if not self._isVaultToken(_vaultToken):\n        return 0 # invalid vault token\n    return staticcall AToken(_vaultToken).totalSupply()\n\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    dataProvider: address = self._getPoolDataProvider()\n    asset: address = self._getUnderlyingAsset(_vaultToken, dataProvider)\n    if asset == empty(address):\n        return 0 # invalid vault token\n    return staticcall AaveProtocolDataProvider(dataProvider).getTotalDebt(asset)\n\n\n@view\n@internal\ndef _getPoolDataProvider() -> address:\n    return staticcall AaveV3AddressProvider(AAVE_V3_ADDRESS_PROVIDER).getPoolDataProvider()\n\n\n# price per share\n\n\n@view\n@external\ndef getPricePerShare(_asset: address, _decimals: uint256) -> uint256:\n    return 10 ** _decimals # 1:1\n\n\n################\n# Registration #\n################\n\n\n@external\ndef addAssetOpportunity(_asset: address, _vaultAddr: address):\n    # can ignore `_vaultAddr` for aave v3\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert self._isValidAssetOpportunity(_asset, _vaultAddr) # dev: invalid asset or vault\n    assert not yld._isAssetOpportunity(_asset, _vaultAddr) # dev: already registered\n    self._registerAsset(_asset, _vaultAddr)\n\n\n@internal\ndef _registerAsset(_asset: address, _vaultAddr: address):\n    assert extcall IERC20(_asset).approve(AAVE_V3_POOL, max_value(uint256), default_return_value=True) # dev: max approval failed\n    yld._addAssetOpportunity(_asset, _vaultAddr)\n\n\n@external\ndef removeAssetOpportunity(_asset: address, _vaultAddr: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert extcall IERC20(_asset).approve(AAVE_V3_POOL, 0, default_return_value=True) # dev: max approval failed\n    yld._removeAssetOpportunity(_asset, _vaultAddr)\n\n\n# validation\n\n\n@view\n@internal\ndef isValidAssetOpportunity(_asset: address, _vaultAddr: address) -> bool:\n    return self._isValidAssetOpportunity(_asset, _vaultAddr)\n\n\n@view\n@internal\ndef _isValidAssetOpportunity(_asset: address, _vaultAddr: address) -> bool:\n    vaultToken: address = self._getAaveVaultToken(_asset, self._getPoolDataProvider())\n    if vaultToken == empty(address):\n        return False\n    return _vaultAddr == vaultToken\n\n\n# update ledger registration\n\n\n@internal\ndef _updateLedgerVaultToken(\n    _underlyingAsset: address,\n    _vaultToken: address,\n    _ledger: address,\n    _legoBook: address,\n):\n    if empty(address) in [_underlyingAsset, _vaultToken]:\n        return\n\n    if not staticcall Ledger(_ledger).isRegisteredVaultToken(_vaultToken):\n        legoId: uint256 = staticcall Registry(_legoBook).getRegId(self)\n        decimals: uint256 = convert(staticcall IERC20Detailed(_vaultToken).decimals(), uint256)\n        extcall Ledger(_ledger).setVaultToken(_vaultToken, legoId, _underlyingAsset, decimals, self._isRebasing())\n\n\n\n#########\n# Other #\n#########\n\n\n@external\ndef swapTokens(\n    _amountIn: uint256,\n    _minAmountOut: uint256,\n    _tokenPath: DynArray[address, MAX_TOKEN_PATH],\n    _poolPath: DynArray[address, MAX_TOKEN_PATH - 1],\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256):\n    return 0, 0, 0\n\n\n@external\ndef mintOrRedeemAsset(\n    _tokenIn: address,\n    _tokenOut: address,\n    _tokenInAmount: uint256,\n    _minAmountOut: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, bool, uint256):\n    return 0, 0, False, 0\n\n\n@external\ndef confirmMintOrRedeemAsset(\n    _tokenIn: address,\n    _tokenOut: address,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef addCollateral(\n    _asset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef removeCollateral(\n    _asset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef borrow(\n    _borrowAsset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef repayDebt(\n    _paymentAsset: address,\n    _paymentAmount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef claimRewards(\n    _user: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _extraData: bytes32,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef addLiquidity(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _amountA: uint256,\n    _amountB: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _minLpAmount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (address, uint256, uint256, uint256, uint256):\n    return empty(address), 0, 0, 0, 0\n\n\n@external\ndef removeLiquidity(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpToken: address,\n    _lpAmount: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, uint256):\n    return 0, 0, 0, 0\n\n\n@external\ndef addLiquidityConcentrated(\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _tickLower: int24,\n    _tickUpper: int24,\n    _amountA: uint256,\n    _amountB: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, uint256, uint256):\n    return 0, 0, 0, 0, 0\n\n\n@external\ndef removeLiquidityConcentrated(\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _liqToRemove: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, bool, uint256):\n    return 0, 0, 0, False, 0\n\n\n@view\n@external\ndef getAccessForLego(_user: address, _action: ws.ActionType) -> (address, String[64], uint256):\n    return empty(address), empty(String[64]), 0\n\n\n@view\n@external\ndef getPrice(_asset: address, _decimals: uint256) -> uint256:\n    return 0\n",
            "sha256sum": "a08d472e998c0c98040306122e4f22dea4eae785f316e11d359bfa4135e933d0"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/legos/yield/AaveV3.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.3+commit.bff19ea2",
        "integrity": "e9c69c74814f2ab8e3b153b68d30b8d6aea0f411deaa6c8be9fca6bb3b0358d6"
      },
      "args": "00000000000000000000000044cf3c4f000dfd76a35d03298049d37be688d6f9000000000000000000000000a238dd80c259a72e81d7e4664a9801593f98d1c5000000000000000000000000e20fcbdbffc4dd138ce8b2e6fbb6cb49777ad64d",
      "file": "contracts/legos/yield/AaveV3.vy"
    },
    "CompoundV3": {
      "address": "0x5Dec90961280605Dd9f3BA19dB0ad57459a86A61",
      "abi": [
        {
          "name": "CompoundV3Deposit",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountDeposited",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultTokenAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "CompoundV3Withdrawal",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultTokenAmountBurned",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "CompoundV3RewardsAddrSet",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LegoPauseModified",
          "inputs": [
            {
              "name": "isPaused",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LegoFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "balance",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetOpportunityAdded",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultAddr",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetOpportunityRemoved",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultAddr",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddys",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "undyToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "hatchery",
                  "type": "address"
                },
                {
                  "name": "lootDistributor",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                },
                {
                  "name": "walletBackpack",
                  "type": "address"
                },
                {
                  "name": "billing",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUndyHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isLegoAsset",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssetOpportunities",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isAssetOpportunity",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getNumLegoAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pause",
          "inputs": [
            {
              "name": "_shouldPause",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFundsMany",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_assets",
              "type": "address[]"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isPaused",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assetOpportunities",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAssetOpportunity",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssetOpportunities",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "vaultToAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assets",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasCapability",
          "inputs": [
            {
              "name": "_action",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRegistries",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isYieldLego",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isDexLego",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isEligibleVaultForTrialFunds",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_underlyingAsset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isEligibleForYieldBonus",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isRebasing",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositForYield",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositForYield",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawFromYield",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawFromYield",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "hasClaimableRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setCompRewardsAddr",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAsset",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAmount",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getVaultTokenAmount",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_assetAmount",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValueOfVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValueOfVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            },
            {
              "name": "_appraiser",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingData",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingData",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            },
            {
              "name": "_appraiser",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalAssets",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalBorrows",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPricePerShare",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_decimals",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addAssetOpportunity",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeAssetOpportunity",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_tokenPath",
              "type": "address[]"
            },
            {
              "name": "_poolPath",
              "type": "address[]"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_tokenPath",
              "type": "address[]"
            },
            {
              "name": "_poolPath",
              "type": "address[]"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_tokenInAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_tokenInAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmMintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmMintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_borrowAsset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_borrowAsset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_paymentAsset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_paymentAsset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAccessForLego",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_action",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "string"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPrice",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_decimals",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "compoundRewards",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "COMPOUND_V3_CONFIGURATOR",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_undyHq",
              "type": "address"
            },
            {
              "name": "_configurator",
              "type": "address"
            },
            {
              "name": "_compRewards",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "interfaces/WalletStructs.vyi": {
            "content": "# @version 0.4.3\n\nflag ActionType:\n    TRANSFER\n    EARN_DEPOSIT\n    EARN_WITHDRAW\n    EARN_REBALANCE\n    SWAP\n    MINT_REDEEM\n    CONFIRM_MINT_REDEEM\n    ADD_COLLATERAL\n    REMOVE_COLLATERAL\n    BORROW\n    REPAY_DEBT\n    REWARDS\n    ETH_TO_WETH\n    WETH_TO_ETH\n    ADD_LIQ\n    REMOVE_LIQ\n    ADD_LIQ_CONC\n    REMOVE_LIQ_CONC\n    PAY_CHEQUE\n\nstruct WalletAssetData:\n    assetBalance: uint256\n    usdValue: uint256\n    isYieldAsset: bool\n    lastPricePerShare: uint256\n\nstruct ActionData:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    billing: address\n    wallet: address\n    walletConfig: address\n    walletOwner: address\n    inEjectMode: bool\n    isFrozen: bool\n    lastTotalUsdValue: uint256\n    signer: address\n    isManager: bool\n    legoId: uint256\n    legoAddr: address\n    eth: address\n    weth: address\n\nstruct MiniAddys:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    appraiser: address",
            "sha256sum": "9a4b4f59b3a62043e51b425a665064aae419a3c0bd0514b6b29a9441ae364bb9"
          },
          "interfaces/LegoPartner.vyi": {
            "content": "# @version 0.4.3\n\nfrom interfaces import WalletStructs as ws\n\nMAX_TOKEN_PATH: constant(uint256) = 5\nMAX_RECOVER_ASSETS: constant(uint256) = 20\n\n@external\ndef addLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _tickLower: int24, _tickUpper: int24, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef addLiquidity(_pool: address, _tokenA: address, _tokenB: address, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _minLpAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (address, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef removeLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _liqToRemove: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef removeLiquidity(_pool: address, _tokenA: address, _tokenB: address, _lpToken: address, _lpAmount: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef mintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _tokenInAmount: uint256, _minAmountOut: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef swapTokens(_amountIn: uint256, _minAmountOut: uint256, _tokenPath: DynArray[address, MAX_TOKEN_PATH], _poolPath: DynArray[address, MAX_TOKEN_PATH - 1], _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256):\n    ...\n\n@external\ndef depositForYield(_asset: address, _amount: uint256, _vaultAddr: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef withdrawFromYield(_vaultToken: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef confirmMintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef borrow(_borrowAsset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef repayDebt(_paymentAsset: address, _paymentAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef claimRewards(_user: address, _rewardToken: address, _rewardAmount: uint256, _extraData: bytes32, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef removeCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef addCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@view\n@external\ndef getAccessForLego(_user: address, _action: ws.ActionType) -> (address, String[64], uint256):\n    ...\n\n@view\n@external\ndef hasCapability(_action: ws.ActionType) -> bool:\n    ...\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    ...\n\n@view\n@external\ndef isYieldLego() -> bool:\n    ...\n\n@view\n@external\ndef isDexLego() -> bool:\n    ...\n\n@view\n@external\ndef getPricePerShare(_asset: address, _decimals: uint256) -> uint256:\n    ...\n\n@view\n@external\ndef getPrice(_asset: address, _decimals: uint256) -> uint256:\n    ...\n\n\n# common\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "2513e379aa74d0a8120114a5078a4c1a0900165a1c3f24419bb811d173b56453"
          },
          "interfaces/YieldLego.vyi": {
            "content": "# @version 0.4.3\n\n@view\n@external\ndef isRebasing() -> bool:\n    ...\n\n\n@view\n@external\ndef isEligibleForYieldBonus(_asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef isEligibleVaultForTrialFunds(_vaultToken: address, _underlyingAsset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    ...\n\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    ...\n\n\n@view\n@external\ndef isVaultToken(_vaultToken: address) -> bool:\n    ...\n\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> uint256:\n    ...\n\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> (address, uint256, uint256):\n    ...\n\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    ...\n\n\n@external\ndef addAssetOpportunity(_asset: address, _vaultAddr: address):\n    ...\n\n\n@external\ndef removeAssetOpportunity(_asset: address, _vaultAddr: address):\n    ...\n\n\n# YieldLegoData.vy module\n\n\n@view\n@external\ndef assetOpportunities(_asset: address, _index: uint256) -> address:\n    ...\n\n\n@view\n@external\ndef indexOfAssetOpportunity(_asset: address, _vaultAddr: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef numAssetOpportunities(_asset: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef vaultToAsset(_vaultAddr: address) -> address:\n    ...\n\n\n@view\n@external\ndef assets(_index: uint256) -> address:\n    ...\n\n\n@view\n@external\ndef indexOfAsset(_asset: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef numAssets() -> uint256:\n    ...\n\n\n@view\n@external\ndef isLegoAsset(_asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, 40]:\n    ...\n\n\n@view\n@external\ndef getAssets() -> DynArray[address, 20]:\n    ...\n\n\n@view\n@external\ndef isAssetOpportunity(_asset: address, _vaultAddr: address) -> bool:\n    ...\n\n\n@view\n@external\ndef getNumLegoAssets() -> uint256:\n    ...\n",
            "sha256sum": "3337ce5f78b0df6f86d1144b07505512bb1044304f67add97be6c3816b3c0b42"
          },
          "contracts/modules/Addys.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\ninterface UndyHq:\n    def isValidAddr(_addr: address) -> bool: view\n    def getAddr(_regId: uint256) -> address: view\n    def undyToken() -> address: view\n\ninterface Switchboard:\n    def isSwitchboardAddr(_addr: address) -> bool: view\n\ninterface LegoBook:\n    def isLegoAddr(_addr: address) -> bool: view\n\nstruct Addys:\n    hq: address\n    undyToken: address\n    ledger: address\n    missionControl: address\n    legoBook: address\n    switchboard: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    walletBackpack: address\n    billing: address\n\n# hq\nUNDY_HQ_FOR_ADDYS: immutable(address)\n\n# core addys\nLEDGER_ID: constant(uint256) = 1\nMISSION_CONTROL_ID: constant(uint256) = 2\nLEGO_BOOK_ID: constant(uint256) = 3\nSWITCHBOARD_ID: constant(uint256) = 4\nHATCHERY_ID: constant(uint256) = 5\nLOOT_DISTRIBUTOR_ID: constant(uint256) = 6\nAPPRAISER_ID: constant(uint256) = 7\nWALLET_BACKPACK_ID: constant(uint256) = 8\nBILLING_ID: constant(uint256) = 9\n\n\n@deploy\ndef __init__(_undyHq: address):\n    assert _undyHq != empty(address) # dev: invalid undy hq\n    UNDY_HQ_FOR_ADDYS = _undyHq\n\n\n########\n# Core #\n########\n\n\n@view\n@external\ndef getAddys() -> Addys:\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _getAddys(_addys: Addys = empty(Addys)) -> Addys:\n    if _addys.hq != empty(address):\n        return _addys\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _generateAddys() -> Addys:\n    hq: address = UNDY_HQ_FOR_ADDYS\n    return Addys(\n        hq = hq,\n        undyToken = staticcall UndyHq(hq).undyToken(),\n        ledger = staticcall UndyHq(hq).getAddr(LEDGER_ID),\n        missionControl = staticcall UndyHq(hq).getAddr(MISSION_CONTROL_ID),\n        legoBook = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID),\n        switchboard = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID),\n        hatchery = staticcall UndyHq(hq).getAddr(HATCHERY_ID),\n        lootDistributor = staticcall UndyHq(hq).getAddr(LOOT_DISTRIBUTOR_ID),\n        appraiser = staticcall UndyHq(hq).getAddr(APPRAISER_ID),\n        walletBackpack = staticcall UndyHq(hq).getAddr(WALLET_BACKPACK_ID),\n        billing = staticcall UndyHq(hq).getAddr(BILLING_ID),\n    )\n\n\n##########\n# Tokens #\n##########\n\n\n@view\n@internal\ndef _getUndyToken() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).undyToken()\n\n\n###########\n# Helpers #\n###########\n\n\n# undy hq\n\n\n@view\n@external\ndef getUndyHq() -> address:\n    return self._getUndyHq()\n\n\n@view\n@internal\ndef _getUndyHq() -> address:\n    return UNDY_HQ_FOR_ADDYS\n\n\n# utils\n\n\n@view\n@internal\ndef _isValidUndyAddr(_addr: address, _hq: address = empty(address)) -> bool:\n    hq: address = _hq\n    if _hq == empty(address):\n        hq = UNDY_HQ_FOR_ADDYS\n    \n    # core departments\n    if staticcall UndyHq(hq).isValidAddr(_addr):\n        return True\n\n    # lego book\n    legoBook: address = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID)\n    if legoBook != empty(address) and staticcall LegoBook(legoBook).isLegoAddr(_addr):\n        return True\n\n    # switchboard config\n    switchboard: address = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID)\n    if switchboard != empty(address) and staticcall Switchboard(switchboard).isSwitchboardAddr(_addr):\n        return True\n\n    return False\n\n\n@view\n@internal\ndef _isSwitchboardAddr(_addr: address) -> bool:\n    switchboard: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n    if switchboard == empty(address):\n        return False\n    return staticcall Switchboard(switchboard).isSwitchboardAddr(_addr)\n\n\n@view\n@internal\ndef _isLegoBookAddr(_addr: address) -> bool:\n    legoBook: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n    if legoBook == empty(address):\n        return False\n    return staticcall LegoBook(legoBook).isLegoAddr(_addr)\n\n\n###############\n# Departments #\n###############\n\n\n# ledger\n\n\n@view\n@internal\ndef _getLedgerId() -> uint256:\n    return LEDGER_ID\n\n\n@view\n@internal\ndef _getLedgerAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEDGER_ID)\n\n\n# mission control\n\n\n@view\n@internal\ndef _getMissionControlId() -> uint256:\n    return MISSION_CONTROL_ID\n\n\n@view\n@internal\ndef _getMissionControlAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(MISSION_CONTROL_ID)\n\n\n# lego book\n\n\n@view\n@internal\ndef _getLegoBookId() -> uint256:\n    return LEGO_BOOK_ID\n\n\n@view\n@internal\ndef _getLegoBookAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n\n\n# switchboard\n\n\n@view\n@internal\ndef _getSwitchboardId() -> uint256:\n    return SWITCHBOARD_ID\n\n\n@view\n@internal\ndef _getSwitchboardAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n\n\n# hatchery\n\n\n@view\n@internal\ndef _getHatcheryId() -> uint256:\n    return HATCHERY_ID\n\n\n@view\n@internal\ndef _getHatcheryAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(HATCHERY_ID)\n\n\n# loot distributor\n\n\n@view\n@internal\ndef _getLootDistributorId() -> uint256:\n    return LOOT_DISTRIBUTOR_ID\n\n\n@view\n@internal\ndef _getLootDistributorAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LOOT_DISTRIBUTOR_ID)\n\n\n# appraiser\n\n\n@view\n@internal\ndef _getAppraiserId() -> uint256:\n    return APPRAISER_ID\n\n\n@view\n@internal\ndef _getAppraiserAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(APPRAISER_ID)\n\n\n# wallet backpack\n\n\n@view\n@internal\ndef _getWalletBackpackId() -> uint256:\n    return WALLET_BACKPACK_ID\n\n\n@view\n@internal\ndef _getWalletBackpackAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(WALLET_BACKPACK_ID)\n\n\n# billing\n\n\n@view\n@internal\ndef _getBillingId() -> uint256:\n    return BILLING_ID\n\n\n@view\n@internal\ndef _getBillingAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(BILLING_ID)",
            "sha256sum": "78b58f0b2acb2eaafa4d21adf9135a1cd0e1d53897f7a1fa70a83a04a7738ad3"
          },
          "contracts/modules/YieldLegoData.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nuses: addys\n\nimport contracts.modules.Addys as addys\n\nfrom interfaces import WalletStructs as ws\nfrom ethereum.ercs import IERC20\n\nevent AssetOpportunityAdded:\n    asset: indexed(address)\n    vaultAddr: indexed(address)\n\nevent AssetOpportunityRemoved:\n    asset: indexed(address)\n    vaultAddr: indexed(address)\n\nevent LegoPauseModified:\n    isPaused: bool\n\nevent LegoFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    balance: uint256\n\n# config\nisPaused: public(bool)\n\n# asset opportunities\nassetOpportunities: public(HashMap[address, HashMap[uint256, address]]) # asset -> index -> vault addr\nindexOfAssetOpportunity: public(HashMap[address, HashMap[address, uint256]]) # asset -> vault addr -> index\nnumAssetOpportunities: public(HashMap[address, uint256]) # asset -> number of opportunities\n\n# mapping\nvaultToAsset: public(HashMap[address, address]) # vault addr -> underlying asset\n\n# lego assets (iterable)\nassets: public(HashMap[uint256, address]) # index -> asset\nindexOfAsset: public(HashMap[address, uint256]) # asset -> index\nnumAssets: public(uint256) # num assets\n\nMAX_VAULTS: constant(uint256) = 40\nMAX_ASSETS: constant(uint256) = 20\nMAX_RECOVER_ASSETS: constant(uint256) = 20\n\n\n@deploy\ndef __init__(_shouldPause: bool):\n    self.isPaused = _shouldPause\n    self.numAssets = 1 # not using 0 index\n\n\n#########\n# Views #\n#########\n\n\n# is lego asset\n\n\n@view\n@external\ndef isLegoAsset(_asset: address) -> bool:\n    return self._isLegoAsset(_asset)\n\n\n@view\n@internal\ndef _isLegoAsset(_asset: address) -> bool:\n    return self.indexOfAsset[_asset] != 0\n\n\n# vault opportunities\n\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, MAX_VAULTS]:\n    numOpportunities: uint256 = self.numAssetOpportunities[_asset]\n    if numOpportunities == 0:\n        return []\n    opportunities: DynArray[address, MAX_VAULTS] = []\n    for i: uint256 in range(1, numOpportunities, bound=MAX_VAULTS):\n        opportunities.append(self.assetOpportunities[_asset][i])\n    return opportunities\n\n\n# all assets registered\n\n\n@view\n@external\ndef getAssets() -> DynArray[address, MAX_ASSETS]:\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return []\n    assets: DynArray[address, MAX_ASSETS] = []\n    for i: uint256 in range(1, numAssets, bound=MAX_ASSETS):\n        assets.append(self.assets[i])\n    return assets\n\n\n################\n# Registration #\n################\n\n\n@view\n@external\ndef isAssetOpportunity(_asset: address, _vaultAddr: address) -> bool:\n    return self._isAssetOpportunity(_asset, _vaultAddr)\n\n\n@view\n@internal\ndef _isAssetOpportunity(_asset: address, _vaultAddr: address) -> bool:\n    return self.indexOfAssetOpportunity[_asset][_vaultAddr] != 0\n\n\n# add asset opportunity\n\n\n@internal\ndef _addAssetOpportunity(_asset: address, _vaultAddr: address):\n    if self.indexOfAssetOpportunity[_asset][_vaultAddr] != 0:\n        return\n    if empty(address) in [_asset, _vaultAddr]:\n        return\n\n    # add asset opportunity\n    aid: uint256 = self.numAssetOpportunities[_asset]\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.assetOpportunities[_asset][aid] = _vaultAddr\n    self.indexOfAssetOpportunity[_asset][_vaultAddr] = aid\n    self.numAssetOpportunities[_asset] = aid + 1\n\n    # add mapping\n    self.vaultToAsset[_vaultAddr] = _asset\n\n    # add asset\n    self._addAsset(_asset)\n\n    log AssetOpportunityAdded(asset=_asset, vaultAddr=_vaultAddr)\n\n\n# remove asset opportunity\n\n\n@internal\ndef _removeAssetOpportunity(_asset: address, _vaultAddr: address):\n    numOpportunities: uint256 = self.numAssetOpportunities[_asset]\n    if numOpportunities == 0:\n        return\n\n    targetIndex: uint256 = self.indexOfAssetOpportunity[_asset][_vaultAddr]\n    if targetIndex == 0:\n        return\n\n    # update data\n    lastIndex: uint256 = numOpportunities - 1\n    self.numAssetOpportunities[_asset] = lastIndex\n    self.indexOfAssetOpportunity[_asset][_vaultAddr] = 0\n\n    self.vaultToAsset[_vaultAddr] = empty(address)\n\n    # shift to replace the removed one\n    if targetIndex != lastIndex:\n        lastVaultAddr: address = self.assetOpportunities[_asset][lastIndex]\n        self.assetOpportunities[_asset][targetIndex] = lastVaultAddr\n        self.indexOfAssetOpportunity[_asset][lastVaultAddr] = targetIndex\n\n    # remove asset\n    if lastIndex <= 1:\n        self._removeAsset(_asset)\n\n    log AssetOpportunityRemoved(asset=_asset, vaultAddr=_vaultAddr)\n\n\n# add asset\n\n\n@internal\ndef _addAsset(_asset: address):\n    if self.indexOfAsset[_asset] != 0:\n        return\n\n    aid: uint256 = self.numAssets\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.assets[aid] = _asset\n    self.indexOfAsset[_asset] = aid\n    self.numAssets = aid + 1\n\n\n# remove asset\n\n\n@internal\ndef _removeAsset(_asset: address):\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return\n\n    targetIndex: uint256 = self.indexOfAsset[_asset]\n    if targetIndex == 0:\n        return\n\n    # update data\n    lastIndex: uint256 = numAssets - 1\n    self.numAssets = lastIndex\n    self.indexOfAsset[_asset] = 0\n\n    # shift to replace the removed one\n    if targetIndex != lastIndex:\n        lastAsset: address = self.assets[lastIndex]\n        self.assets[targetIndex] = lastAsset\n        self.indexOfAsset[lastAsset] = targetIndex\n\n\n# num lego assets (true number, use `numAssets` for iteration)\n\n\n@view\n@external\ndef getNumLegoAssets() -> uint256:\n    return self._getNumLegoAssets()\n\n\n@view\n@internal\ndef _getNumLegoAssets() -> uint256:\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return 0\n    return numAssets - 1\n\n\n###########\n# General #\n###########\n\n\n# fill mini addys\n\n\n@view\n@internal\ndef _getMiniAddys(_miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> ws.MiniAddys:\n    if _miniAddys.ledger != empty(address):\n        return _miniAddys\n    return ws.MiniAddys(\n        ledger = addys._getLedgerAddr(),\n        missionControl = addys._getMissionControlAddr(),\n        legoBook = addys._getLegoBookAddr(),\n        appraiser = addys._getAppraiserAddr(),\n    )\n\n\n# activate\n\n\n@external\ndef pause(_shouldPause: bool):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert _shouldPause != self.isPaused # dev: no change\n    self.isPaused = _shouldPause\n    log LegoPauseModified(isPaused=_shouldPause)\n\n\n# recover funds\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    self._recoverFunds(_recipient, _asset)\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, MAX_RECOVER_ASSETS]):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    for a: address in _assets:\n        self._recoverFunds(_recipient, a)\n\n\n@internal\ndef _recoverFunds(_recipient: address, _asset: address):\n    assert empty(address) not in [_recipient, _asset] # dev: invalid recipient or asset\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    assert balance != 0 # dev: nothing to recover\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log LegoFundsRecovered(asset=_asset, recipient=_recipient, balance=balance)",
            "sha256sum": "bcbae5ce139758ce8a77c03858ec8d438dea0437d5f3a20fed8267f4d2f15b66"
          },
          "contracts/legos/yield/CompoundV3.vy": {
            "content": "#     __   __ ___ _______ ___     ______       ___     _______ _______ _______ \n#    |  | |  |   |       |   |   |      |     |   |   |       |       |       |\n#    |  |_|  |   |    ___|   |   |  _    |    |   |   |    ___|    ___|   _   |\n#    |       |   |   |___|   |   | | |   |    |   |   |   |___|   | __|  | |  |\n#    |_     _|   |    ___|   |___| |_|   |    |   |___|    ___|   ||  |  |_|  |\n#      |   | |   |   |___|       |       |    |       |   |___|   |_| |       |\n#      |___| |___|_______|_______|______|     |_______|_______|_______|_______|\n#                                                                       \n#     \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n#     \u2551  ** Compound V3 Lego **                   \u2551\n#     \u2551  Integration with Compound Protocol (v3)  \u2551\n#     \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n#\n#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nimplements: Lego\nimplements: YieldLego\n\nexports: addys.__interface__\nexports: yld.__interface__\n\ninitializes: addys\ninitializes: yld[addys := addys]\n\nfrom interfaces import LegoPartner as Lego\nfrom interfaces import YieldLego as YieldLego\nfrom interfaces import WalletStructs as ws\n\nimport contracts.modules.Addys as addys\nimport contracts.modules.YieldLegoData as yld\n\nfrom ethereum.ercs import IERC20\nfrom ethereum.ercs import IERC20Detailed\n\ninterface CompoundV3:\n    def withdrawTo(_recipient: address, _asset: address, _amount: uint256): nonpayable\n    def supplyTo(_recipient: address, _asset: address, _amount: uint256): nonpayable\n    def totalSupply() -> uint256: view\n    def totalBorrow() -> uint256: view\n    def baseToken() -> address: view\n\ninterface Appraiser:\n    def getUsdValue(_asset: address, _amount: uint256, _missionControl: address = empty(address), _legoBook: address = empty(address), _ledger: address = empty(address)) -> uint256: view\n    def updatePriceAndGetUsdValue(_asset: address, _amount: uint256, _missionControl: address = empty(address), _legoBook: address = empty(address)) -> uint256: nonpayable\n\ninterface Ledger:\n    def setVaultToken(_vaultToken: address, _legoId: uint256, _underlyingAsset: address, _decimals: uint256, _isRebasing: bool): nonpayable\n    def isRegisteredVaultToken(_vaultToken: address) -> bool: view\n\ninterface CompoundV3Rewards:\n    def getRewardOwed(_comet: address, _user: address) -> RewardOwed: nonpayable\n    def claim(_comet: address, _user: address, _shouldAccrue: bool): nonpayable\n\ninterface CompoundV3Configurator:\n    def factory(_cometAsset: address) -> address: view\n\ninterface Registry:\n    def getRegId(_addr: address) -> uint256: view\n\nstruct RewardOwed:\n    token: address\n    owed: uint256\n\nevent CompoundV3Deposit:\n    sender: indexed(address)\n    asset: indexed(address)\n    vaultToken: indexed(address)\n    assetAmountDeposited: uint256\n    usdValue: uint256\n    vaultTokenAmountReceived: uint256\n    recipient: address\n\nevent CompoundV3Withdrawal:\n    sender: indexed(address)\n    asset: indexed(address)\n    vaultToken: indexed(address)\n    assetAmountReceived: uint256\n    usdValue: uint256\n    vaultTokenAmountBurned: uint256\n    recipient: address\n\nevent CompoundV3RewardsAddrSet:\n    addr: address\n\n# rewards contract\ncompoundRewards: public(address)\n\n# compound v3\nCOMPOUND_V3_CONFIGURATOR: public(immutable(address))\n\nMAX_TOKEN_PATH: constant(uint256) = 5\n\n\n@deploy\ndef __init__(\n    _undyHq: address,\n    _configurator: address,\n    _compRewards: address,\n):\n    addys.__init__(_undyHq)\n    yld.__init__(False)\n\n    assert _configurator != empty(address) # dev: invalid configurator\n    COMPOUND_V3_CONFIGURATOR = _configurator\n    self.compoundRewards = _compRewards\n\n\n@view\n@external\ndef hasCapability(_action: ws.ActionType) -> bool:\n    return _action in (\n        ws.ActionType.EARN_DEPOSIT | \n        ws.ActionType.EARN_WITHDRAW\n    )\n\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    return [COMPOUND_V3_CONFIGURATOR]\n\n\n@view\n@external\ndef isYieldLego() -> bool:\n    return True\n\n\n@view\n@external\ndef isDexLego() -> bool:\n    return False\n\n\n@view\n@external\ndef isEligibleVaultForTrialFunds(_vaultToken: address, _underlyingAsset: address) -> bool:\n    return yld.vaultToAsset[_vaultToken] == _underlyingAsset\n\n\n@view\n@external\ndef isEligibleForYieldBonus(_asset: address) -> bool:\n    return False # not allowing rebasing assets to get yield bonus\n\n\n@view\n@external\ndef isRebasing() -> bool:\n    return self._isRebasing()\n\n\n@view\n@internal\ndef _isRebasing() -> bool:\n    return True\n\n\n#########\n# Yield #\n#########\n\n\n# deposit\n\n\n@external\ndef depositForYield(\n    _asset: address,\n    _amount: uint256,\n    _vaultAddr: address,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, address, uint256, uint256):\n    assert not yld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = yld._getMiniAddys(_miniAddys)\n\n    # verify vault token (register if necessary)\n    vaultToken: address = self._getVaultTokenOnDeposit(_asset, _vaultAddr, miniAddys.ledger, miniAddys.legoBook)\n\n    # pre balances\n    preLegoBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    preRecipientVaultBalance: uint256 = staticcall IERC20(vaultToken).balanceOf(_recipient)\n\n    # transfer deposit asset to this contract\n    depositAmount: uint256 = min(_amount, staticcall IERC20(_asset).balanceOf(msg.sender))\n    assert depositAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_asset).transferFrom(msg.sender, self, depositAmount, default_return_value=True) # dev: transfer failed\n\n    # deposit assets into lego partner\n    extcall CompoundV3(vaultToken).supplyTo(_recipient, _asset, depositAmount) # dev: could not deposit into compound v3\n\n    # validate vault token transfer\n    vaultTokenAmountReceived: uint256 = staticcall IERC20(vaultToken).balanceOf(_recipient) - preRecipientVaultBalance\n    assert vaultTokenAmountReceived != 0 # dev: no vault tokens received\n\n    # refund if full deposit didn't get through\n    currentLegoBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    refundAssetAmount: uint256 = 0\n    if currentLegoBalance > preLegoBalance:\n        refundAssetAmount = currentLegoBalance - preLegoBalance\n        assert extcall IERC20(_asset).transfer(msg.sender, refundAssetAmount, default_return_value=True) # dev: transfer failed\n        depositAmount -= refundAssetAmount\n\n    usdValue: uint256 = extcall Appraiser(miniAddys.appraiser).updatePriceAndGetUsdValue(_asset, depositAmount, miniAddys.missionControl, miniAddys.legoBook)\n    log CompoundV3Deposit(\n        sender = msg.sender,\n        asset = _asset,\n        vaultToken = vaultToken,\n        assetAmountDeposited = depositAmount,\n        usdValue = usdValue,\n        vaultTokenAmountReceived = vaultTokenAmountReceived,\n        recipient = _recipient,\n    )\n    return depositAmount, vaultToken, vaultTokenAmountReceived, usdValue\n\n\n# asset verification\n\n\n@internal\ndef _getVaultTokenOnDeposit(_asset: address, _vaultAddr: address, _ledger: address, _legoBook: address) -> address:\n    asset: address = yld.vaultToAsset[_vaultAddr]\n    isRegistered: bool = True\n\n    # not yet registered, call compound directly to get asset\n    if asset == empty(address) and self._isValidCometAddr(_vaultAddr):\n        asset = staticcall CompoundV3(_vaultAddr).baseToken()\n        isRegistered = False\n\n    assert asset != empty(address) # dev: invalid asset\n    assert asset == _asset # dev: asset mismatch\n\n    # register if necessary\n    if not isRegistered:\n        self._registerAsset(asset, _vaultAddr)\n        self._updateLedgerVaultToken(asset, _vaultAddr, _ledger, _legoBook)\n\n    return _vaultAddr\n\n\n# withdraw\n\n\n@external\ndef withdrawFromYield(\n    _vaultToken: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, address, uint256, uint256):\n    assert not yld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = yld._getMiniAddys(_miniAddys)\n\n    # verify asset (register if necessary)\n    asset: address = self._getAssetOnWithdraw(_vaultToken, miniAddys.ledger, miniAddys.legoBook)\n\n    # pre balances\n    preRecipientBalance: uint256 = staticcall IERC20(asset).balanceOf(_recipient)\n    preLegoVaultBalance: uint256 = staticcall IERC20(_vaultToken).balanceOf(self)\n\n    # transfer vaults tokens to this contract\n    vaultTokenAmount: uint256 = min(_amount, staticcall IERC20(_vaultToken).balanceOf(msg.sender))\n    assert vaultTokenAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_vaultToken).transferFrom(msg.sender, self, vaultTokenAmount, default_return_value=True) # dev: transfer failed\n\n    # withdraw assets from lego partner\n    extcall CompoundV3(_vaultToken).withdrawTo(_recipient, asset, max_value(uint256)) # dev: could not withdraw from compound v3\n\n    # validate received asset, transfer back to user\n    assetAmountReceived: uint256 = staticcall IERC20(asset).balanceOf(_recipient) - preRecipientBalance\n    assert assetAmountReceived != 0 # dev: no asset amount received\n\n    # refund if full withdrawal didn't happen\n    currentLegoVaultBalance: uint256 = staticcall IERC20(_vaultToken).balanceOf(self)\n    refundVaultTokenAmount: uint256 = 0\n    if currentLegoVaultBalance > preLegoVaultBalance:\n        refundVaultTokenAmount = currentLegoVaultBalance - preLegoVaultBalance\n        assert extcall IERC20(_vaultToken).transfer(msg.sender, refundVaultTokenAmount, default_return_value=True) # dev: transfer failed\n        vaultTokenAmount -= refundVaultTokenAmount\n\n    usdValue: uint256 = extcall Appraiser(miniAddys.appraiser).updatePriceAndGetUsdValue(asset, assetAmountReceived, miniAddys.missionControl, miniAddys.legoBook)\n    log CompoundV3Withdrawal(\n        sender = msg.sender,\n        asset = asset,\n        vaultToken = _vaultToken,\n        assetAmountReceived = assetAmountReceived,\n        usdValue = usdValue,\n        vaultTokenAmountBurned = vaultTokenAmount,\n        recipient = _recipient,\n    )\n    return vaultTokenAmount, asset, assetAmountReceived, usdValue\n\n\n# vault token verification\n\n\n@internal\ndef _getAssetOnWithdraw(_vaultToken: address, _ledger: address, _legoBook: address) -> address:\n    asset: address = yld.vaultToAsset[_vaultToken]\n    isRegistered: bool = True\n\n    # not yet registered, call compound directly to get asset\n    if asset == empty(address) and self._isValidCometAddr(_vaultToken):\n        asset = staticcall CompoundV3(_vaultToken).baseToken()\n        isRegistered = False\n\n    assert asset != empty(address) # dev: invalid asset\n\n    # register if necessary\n    if not isRegistered:\n        self._registerAsset(asset, _vaultToken)\n        self._updateLedgerVaultToken(asset, _vaultToken, _ledger, _legoBook)\n\n    return asset\n\n\n#################\n# Claim Rewards #\n#################\n\n\n@external\ndef claimRewards(\n    _user: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _extraData: bytes32,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    assert not yld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = yld._getMiniAddys(_miniAddys)\n\n    assert msg.sender == _user # dev: recipient must be caller\n    preBalance: uint256 = staticcall IERC20(_rewardToken).balanceOf(_user)\n\n    market: address = empty(address)\n    if _extraData != empty(bytes32):\n        market = convert(_extraData, address)\n\n    compRewards: address = self.compoundRewards\n    assert compRewards != empty(address) # dev: no comp rewards addr set\n    if market != empty(address):\n        extcall CompoundV3Rewards(compRewards).claim(market, _user, True)\n    else:\n        self._hasClaimableOrShouldClaim(_user, True, compRewards)\n\n    rewardAmount: uint256 = staticcall IERC20(_rewardToken).balanceOf(_user) - preBalance\n    assert rewardAmount != 0 # dev: no rewards received\n    usdValue: uint256 = extcall Appraiser(miniAddys.appraiser).updatePriceAndGetUsdValue(_rewardToken, rewardAmount, miniAddys.missionControl, miniAddys.legoBook)\n    return rewardAmount, usdValue\n\n\n# sadly, this is not a view function because of `getRewardOwed()`\n@external\ndef hasClaimableRewards(_user: address) -> bool:\n    return self._hasClaimableOrShouldClaim(_user, False, self.compoundRewards)\n\n\n@internal\ndef _hasClaimableOrShouldClaim(_user: address, _shouldClaim: bool, _compRewardsAddr: address) -> bool:\n    numAssets: uint256 = yld.numAssets\n    if numAssets == 0:\n        return False\n\n    for i: uint256 in range(1, numAssets, bound=max_value(uint256)):\n        asset: address = yld.assets[i]\n        comet: address = yld.assetOpportunities[asset][1] # only a single \"vault token\" (comet) per asset\n\n        rewardOwed: RewardOwed = extcall CompoundV3Rewards(_compRewardsAddr).getRewardOwed(comet, _user)\n        if rewardOwed.owed != 0:\n            if _shouldClaim:\n                extcall CompoundV3Rewards(_compRewardsAddr).claim(comet, _user, True)\n            else:\n                return True\n\n    return False\n\n\n# set rewards addr\n\n\n@external\ndef setCompRewardsAddr(_addr: address) -> bool:\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert _addr != empty(address) # dev: invalid addr\n    self.compoundRewards = _addr\n    log CompoundV3RewardsAddrSet(addr=_addr)\n    return True\n\n\n#############\n# Utilities #\n#############\n\n\n# underlying asset\n\n\n@view\n@external\ndef isVaultToken(_vaultToken: address) -> bool:\n    return self._isVaultToken(_vaultToken)\n\n\n@view\n@internal\ndef _isVaultToken(_vaultToken: address) -> bool:\n    if yld.vaultToAsset[_vaultToken] != empty(address):\n        return True\n    return self._isValidCometAddr(_vaultToken)\n\n\n@view\n@internal\ndef _isValidCometAddr(_cometAddr: address) -> bool:\n    return staticcall CompoundV3Configurator(COMPOUND_V3_CONFIGURATOR).factory(_cometAddr) != empty(address)\n\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    return self._getUnderlyingAsset(_vaultToken)\n\n\n@view\n@internal\ndef _getUnderlyingAsset(_vaultToken: address) -> address:\n    asset: address = yld.vaultToAsset[_vaultToken]\n    if asset == empty(address) and self._isValidCometAddr(_vaultToken):\n        asset = staticcall CompoundV3(_vaultToken).baseToken()\n    return asset\n\n\n# underlying amount\n\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    if not self._isVaultToken(_vaultToken) or _vaultTokenAmount == 0:\n        return 0 # invalid vault token or amount\n    return self._getUnderlyingAmount(_vaultToken, _vaultTokenAmount)\n\n\n@view\n@internal\ndef _getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    # treated as 1:1\n    return _vaultTokenAmount\n\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    if empty(address) in [_asset, _vaultToken] or _assetAmount == 0:\n        return 0 # bad inputs\n    if self._getUnderlyingAsset(_vaultToken) != _asset:\n        return 0 # invalid vault token or asset\n    # treated as 1:1\n    return _assetAmount\n\n\n# usd value\n\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> uint256:\n    return self._getUsdValueOfVaultToken(_vaultToken, _vaultTokenAmount, _appraiser)\n\n\n@view\n@internal\ndef _getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address) -> uint256:\n    asset: address = empty(address)\n    underlyingAmount: uint256 = 0\n    usdValue: uint256 = 0\n    asset, underlyingAmount, usdValue = self._getUnderlyingData(_vaultToken, _vaultTokenAmount, _appraiser)\n    return usdValue\n\n\n# all underlying data together\n\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> (address, uint256, uint256):\n    return self._getUnderlyingData(_vaultToken, _vaultTokenAmount, _appraiser)\n\n\n@view\n@internal\ndef _getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address) -> (address, uint256, uint256):\n    if _vaultTokenAmount == 0 or _vaultToken == empty(address):\n        return empty(address), 0, 0 # bad inputs\n    asset: address = self._getUnderlyingAsset(_vaultToken)\n    if asset == empty(address):\n        return empty(address), 0, 0 # invalid vault token\n    underlyingAmount: uint256 = self._getUnderlyingAmount(_vaultToken, _vaultTokenAmount)\n    usdValue: uint256 = self._getUsdValue(asset, underlyingAmount, _appraiser)\n    return asset, underlyingAmount, usdValue\n\n\n@view\n@internal\ndef _getUsdValue(_asset: address, _amount: uint256, _appraiser: address) -> uint256:\n    appraiser: address = _appraiser\n    if _appraiser == empty(address):\n        appraiser = addys._getAppraiserAddr()\n    return staticcall Appraiser(appraiser).getUsdValue(_asset, _amount)\n\n\n# other\n\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    if not self._isVaultToken(_vaultToken):\n        return 0 # invalid vault token\n    return staticcall CompoundV3(_vaultToken).totalSupply()\n\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    if not self._isVaultToken(_vaultToken):\n        return 0 # invalid vault token\n    return staticcall CompoundV3(_vaultToken).totalBorrow()\n\n\n# price per share\n\n\n@view\n@external\ndef getPricePerShare(_asset: address, _decimals: uint256) -> uint256:\n    return 10 ** _decimals # 1:1\n\n\n################\n# Registration #\n################\n\n\n@external\ndef addAssetOpportunity(_asset: address, _vaultAddr: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert self._isValidAssetOpportunity(_asset, _vaultAddr) # dev: invalid asset or vault\n    assert not yld._isAssetOpportunity(_asset, _vaultAddr) # dev: already registered\n    self._registerAsset(_asset, _vaultAddr)\n\n\n@internal\ndef _registerAsset(_asset: address, _vaultAddr: address):\n    assert extcall IERC20(_asset).approve(_vaultAddr, max_value(uint256), default_return_value=True) # dev: max approval failed\n    yld._addAssetOpportunity(_asset, _vaultAddr)\n\n\n@external\ndef removeAssetOpportunity(_asset: address, _vaultAddr: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert extcall IERC20(_asset).approve(_vaultAddr, 0, default_return_value=True) # dev: max approval failed\n    yld._removeAssetOpportunity(_asset, _vaultAddr)\n\n\n# validation\n\n\n@view\n@internal\ndef isValidAssetOpportunity(_asset: address, _vaultAddr: address) -> bool:\n    return self._isValidAssetOpportunity(_asset, _vaultAddr)\n\n\n@view\n@internal\ndef _isValidAssetOpportunity(_asset: address, _vaultAddr: address) -> bool:\n    return self._isValidCometAddr(_vaultAddr) and staticcall CompoundV3(_vaultAddr).baseToken() == _asset\n\n\n# update ledger registration\n\n\n@internal\ndef _updateLedgerVaultToken(\n    _underlyingAsset: address,\n    _vaultToken: address,\n    _ledger: address,\n    _legoBook: address,\n):\n    if empty(address) in [_underlyingAsset, _vaultToken]:\n        return\n\n    if not staticcall Ledger(_ledger).isRegisteredVaultToken(_vaultToken):\n        legoId: uint256 = staticcall Registry(_legoBook).getRegId(self)\n        decimals: uint256 = convert(staticcall IERC20Detailed(_vaultToken).decimals(), uint256)\n        extcall Ledger(_ledger).setVaultToken(_vaultToken, legoId, _underlyingAsset, decimals, self._isRebasing())\n\n\n#########\n# Other #\n#########\n\n\n@external\ndef swapTokens(\n    _amountIn: uint256,\n    _minAmountOut: uint256,\n    _tokenPath: DynArray[address, MAX_TOKEN_PATH],\n    _poolPath: DynArray[address, MAX_TOKEN_PATH - 1],\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256):\n    return 0, 0, 0\n\n\n@external\ndef mintOrRedeemAsset(\n    _tokenIn: address,\n    _tokenOut: address,\n    _tokenInAmount: uint256,\n    _minAmountOut: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, bool, uint256):\n    return 0, 0, False, 0\n\n\n@external\ndef confirmMintOrRedeemAsset(\n    _tokenIn: address,\n    _tokenOut: address,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef addCollateral(\n    _asset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef removeCollateral(\n    _asset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef borrow(\n    _borrowAsset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef repayDebt(\n    _paymentAsset: address,\n    _paymentAmount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef addLiquidity(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _amountA: uint256,\n    _amountB: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _minLpAmount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (address, uint256, uint256, uint256, uint256):\n    return empty(address), 0, 0, 0, 0\n\n\n@external\ndef removeLiquidity(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpToken: address,\n    _lpAmount: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, uint256):\n    return 0, 0, 0, 0\n\n\n@external\ndef addLiquidityConcentrated(\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _tickLower: int24,\n    _tickUpper: int24,\n    _amountA: uint256,\n    _amountB: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, uint256, uint256):\n    return 0, 0, 0, 0, 0\n\n\n@external\ndef removeLiquidityConcentrated(\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _liqToRemove: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, bool, uint256):\n    return 0, 0, 0, False, 0\n\n\n@view\n@external\ndef getAccessForLego(_user: address, _action: ws.ActionType) -> (address, String[64], uint256):\n    return empty(address), empty(String[64]), 0\n\n\n@view\n@external\ndef getPrice(_asset: address, _decimals: uint256) -> uint256:\n    return 0\n",
            "sha256sum": "8cff20df546fa957e9744d06ba47899d3fa453a1889456fcfc45365527d4a51d"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/legos/yield/CompoundV3.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.3+commit.bff19ea2",
        "integrity": "f764e9fc6fd6df4974ef750aa041d7e034960ab3b9d801bd324dd225d36c0db7"
      },
      "args": "00000000000000000000000044cf3c4f000dfd76a35d03298049d37be688d6f900000000000000000000000045939657d1ca34a8fa39a924b71d28fe8431e581000000000000000000000000123964802e6ababbe1bc9547d72ef1b69b00a6b1",
      "file": "contracts/legos/yield/CompoundV3.vy"
    },
    "Euler": {
      "address": "0x22D16D820c20492597caDb6e36db976Ca16c4156",
      "abi": [
        {
          "name": "EulerDeposit",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountDeposited",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultTokenAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "EulerWithdrawal",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultTokenAmountBurned",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "EulerRewardsAddrSet",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LegoPauseModified",
          "inputs": [
            {
              "name": "isPaused",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LegoFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "balance",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetOpportunityAdded",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultAddr",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetOpportunityRemoved",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultAddr",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddys",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "undyToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "hatchery",
                  "type": "address"
                },
                {
                  "name": "lootDistributor",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                },
                {
                  "name": "walletBackpack",
                  "type": "address"
                },
                {
                  "name": "billing",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUndyHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isLegoAsset",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssetOpportunities",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isAssetOpportunity",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getNumLegoAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pause",
          "inputs": [
            {
              "name": "_shouldPause",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFundsMany",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_assets",
              "type": "address[]"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isPaused",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assetOpportunities",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAssetOpportunity",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssetOpportunities",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "vaultToAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assets",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasCapability",
          "inputs": [
            {
              "name": "_action",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRegistries",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAccessForLego",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_action",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "string"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isYieldLego",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isDexLego",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isRebasing",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isEligibleVaultForTrialFunds",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_underlyingAsset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isEligibleForYieldBonus",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositForYield",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositForYield",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawFromYield",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawFromYield",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasClaimableRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setEulerRewardsAddr",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAsset",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAmount",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getVaultTokenAmount",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_assetAmount",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValueOfVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValueOfVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            },
            {
              "name": "_appraiser",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingData",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingData",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            },
            {
              "name": "_appraiser",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalAssets",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalBorrows",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPricePerShare",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_decimals",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addAssetOpportunity",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeAssetOpportunity",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_tokenPath",
              "type": "address[]"
            },
            {
              "name": "_poolPath",
              "type": "address[]"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_tokenPath",
              "type": "address[]"
            },
            {
              "name": "_poolPath",
              "type": "address[]"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_tokenInAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_tokenInAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmMintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmMintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_borrowAsset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_borrowAsset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_paymentAsset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_paymentAsset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPrice",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_decimals",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "eulerRewards",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "EULER_EVAULT_FACTORY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "EULER_EARN_FACTORY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_undyHq",
              "type": "address"
            },
            {
              "name": "_evaultFactory",
              "type": "address"
            },
            {
              "name": "_earnFactory",
              "type": "address"
            },
            {
              "name": "_eulerRewardsAddr",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "interfaces/WalletStructs.vyi": {
            "content": "# @version 0.4.3\n\nflag ActionType:\n    TRANSFER\n    EARN_DEPOSIT\n    EARN_WITHDRAW\n    EARN_REBALANCE\n    SWAP\n    MINT_REDEEM\n    CONFIRM_MINT_REDEEM\n    ADD_COLLATERAL\n    REMOVE_COLLATERAL\n    BORROW\n    REPAY_DEBT\n    REWARDS\n    ETH_TO_WETH\n    WETH_TO_ETH\n    ADD_LIQ\n    REMOVE_LIQ\n    ADD_LIQ_CONC\n    REMOVE_LIQ_CONC\n    PAY_CHEQUE\n\nstruct WalletAssetData:\n    assetBalance: uint256\n    usdValue: uint256\n    isYieldAsset: bool\n    lastPricePerShare: uint256\n\nstruct ActionData:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    billing: address\n    wallet: address\n    walletConfig: address\n    walletOwner: address\n    inEjectMode: bool\n    isFrozen: bool\n    lastTotalUsdValue: uint256\n    signer: address\n    isManager: bool\n    legoId: uint256\n    legoAddr: address\n    eth: address\n    weth: address\n\nstruct MiniAddys:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    appraiser: address",
            "sha256sum": "9a4b4f59b3a62043e51b425a665064aae419a3c0bd0514b6b29a9441ae364bb9"
          },
          "interfaces/LegoPartner.vyi": {
            "content": "# @version 0.4.3\n\nfrom interfaces import WalletStructs as ws\n\nMAX_TOKEN_PATH: constant(uint256) = 5\nMAX_RECOVER_ASSETS: constant(uint256) = 20\n\n@external\ndef addLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _tickLower: int24, _tickUpper: int24, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef addLiquidity(_pool: address, _tokenA: address, _tokenB: address, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _minLpAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (address, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef removeLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _liqToRemove: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef removeLiquidity(_pool: address, _tokenA: address, _tokenB: address, _lpToken: address, _lpAmount: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef mintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _tokenInAmount: uint256, _minAmountOut: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef swapTokens(_amountIn: uint256, _minAmountOut: uint256, _tokenPath: DynArray[address, MAX_TOKEN_PATH], _poolPath: DynArray[address, MAX_TOKEN_PATH - 1], _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256):\n    ...\n\n@external\ndef depositForYield(_asset: address, _amount: uint256, _vaultAddr: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef withdrawFromYield(_vaultToken: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef confirmMintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef borrow(_borrowAsset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef repayDebt(_paymentAsset: address, _paymentAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef claimRewards(_user: address, _rewardToken: address, _rewardAmount: uint256, _extraData: bytes32, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef removeCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef addCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@view\n@external\ndef getAccessForLego(_user: address, _action: ws.ActionType) -> (address, String[64], uint256):\n    ...\n\n@view\n@external\ndef hasCapability(_action: ws.ActionType) -> bool:\n    ...\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    ...\n\n@view\n@external\ndef isYieldLego() -> bool:\n    ...\n\n@view\n@external\ndef isDexLego() -> bool:\n    ...\n\n@view\n@external\ndef getPricePerShare(_asset: address, _decimals: uint256) -> uint256:\n    ...\n\n@view\n@external\ndef getPrice(_asset: address, _decimals: uint256) -> uint256:\n    ...\n\n\n# common\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "2513e379aa74d0a8120114a5078a4c1a0900165a1c3f24419bb811d173b56453"
          },
          "interfaces/YieldLego.vyi": {
            "content": "# @version 0.4.3\n\n@view\n@external\ndef isRebasing() -> bool:\n    ...\n\n\n@view\n@external\ndef isEligibleForYieldBonus(_asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef isEligibleVaultForTrialFunds(_vaultToken: address, _underlyingAsset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    ...\n\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    ...\n\n\n@view\n@external\ndef isVaultToken(_vaultToken: address) -> bool:\n    ...\n\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> uint256:\n    ...\n\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> (address, uint256, uint256):\n    ...\n\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    ...\n\n\n@external\ndef addAssetOpportunity(_asset: address, _vaultAddr: address):\n    ...\n\n\n@external\ndef removeAssetOpportunity(_asset: address, _vaultAddr: address):\n    ...\n\n\n# YieldLegoData.vy module\n\n\n@view\n@external\ndef assetOpportunities(_asset: address, _index: uint256) -> address:\n    ...\n\n\n@view\n@external\ndef indexOfAssetOpportunity(_asset: address, _vaultAddr: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef numAssetOpportunities(_asset: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef vaultToAsset(_vaultAddr: address) -> address:\n    ...\n\n\n@view\n@external\ndef assets(_index: uint256) -> address:\n    ...\n\n\n@view\n@external\ndef indexOfAsset(_asset: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef numAssets() -> uint256:\n    ...\n\n\n@view\n@external\ndef isLegoAsset(_asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, 40]:\n    ...\n\n\n@view\n@external\ndef getAssets() -> DynArray[address, 20]:\n    ...\n\n\n@view\n@external\ndef isAssetOpportunity(_asset: address, _vaultAddr: address) -> bool:\n    ...\n\n\n@view\n@external\ndef getNumLegoAssets() -> uint256:\n    ...\n",
            "sha256sum": "3337ce5f78b0df6f86d1144b07505512bb1044304f67add97be6c3816b3c0b42"
          },
          "contracts/modules/Addys.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\ninterface UndyHq:\n    def isValidAddr(_addr: address) -> bool: view\n    def getAddr(_regId: uint256) -> address: view\n    def undyToken() -> address: view\n\ninterface Switchboard:\n    def isSwitchboardAddr(_addr: address) -> bool: view\n\ninterface LegoBook:\n    def isLegoAddr(_addr: address) -> bool: view\n\nstruct Addys:\n    hq: address\n    undyToken: address\n    ledger: address\n    missionControl: address\n    legoBook: address\n    switchboard: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    walletBackpack: address\n    billing: address\n\n# hq\nUNDY_HQ_FOR_ADDYS: immutable(address)\n\n# core addys\nLEDGER_ID: constant(uint256) = 1\nMISSION_CONTROL_ID: constant(uint256) = 2\nLEGO_BOOK_ID: constant(uint256) = 3\nSWITCHBOARD_ID: constant(uint256) = 4\nHATCHERY_ID: constant(uint256) = 5\nLOOT_DISTRIBUTOR_ID: constant(uint256) = 6\nAPPRAISER_ID: constant(uint256) = 7\nWALLET_BACKPACK_ID: constant(uint256) = 8\nBILLING_ID: constant(uint256) = 9\n\n\n@deploy\ndef __init__(_undyHq: address):\n    assert _undyHq != empty(address) # dev: invalid undy hq\n    UNDY_HQ_FOR_ADDYS = _undyHq\n\n\n########\n# Core #\n########\n\n\n@view\n@external\ndef getAddys() -> Addys:\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _getAddys(_addys: Addys = empty(Addys)) -> Addys:\n    if _addys.hq != empty(address):\n        return _addys\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _generateAddys() -> Addys:\n    hq: address = UNDY_HQ_FOR_ADDYS\n    return Addys(\n        hq = hq,\n        undyToken = staticcall UndyHq(hq).undyToken(),\n        ledger = staticcall UndyHq(hq).getAddr(LEDGER_ID),\n        missionControl = staticcall UndyHq(hq).getAddr(MISSION_CONTROL_ID),\n        legoBook = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID),\n        switchboard = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID),\n        hatchery = staticcall UndyHq(hq).getAddr(HATCHERY_ID),\n        lootDistributor = staticcall UndyHq(hq).getAddr(LOOT_DISTRIBUTOR_ID),\n        appraiser = staticcall UndyHq(hq).getAddr(APPRAISER_ID),\n        walletBackpack = staticcall UndyHq(hq).getAddr(WALLET_BACKPACK_ID),\n        billing = staticcall UndyHq(hq).getAddr(BILLING_ID),\n    )\n\n\n##########\n# Tokens #\n##########\n\n\n@view\n@internal\ndef _getUndyToken() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).undyToken()\n\n\n###########\n# Helpers #\n###########\n\n\n# undy hq\n\n\n@view\n@external\ndef getUndyHq() -> address:\n    return self._getUndyHq()\n\n\n@view\n@internal\ndef _getUndyHq() -> address:\n    return UNDY_HQ_FOR_ADDYS\n\n\n# utils\n\n\n@view\n@internal\ndef _isValidUndyAddr(_addr: address, _hq: address = empty(address)) -> bool:\n    hq: address = _hq\n    if _hq == empty(address):\n        hq = UNDY_HQ_FOR_ADDYS\n    \n    # core departments\n    if staticcall UndyHq(hq).isValidAddr(_addr):\n        return True\n\n    # lego book\n    legoBook: address = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID)\n    if legoBook != empty(address) and staticcall LegoBook(legoBook).isLegoAddr(_addr):\n        return True\n\n    # switchboard config\n    switchboard: address = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID)\n    if switchboard != empty(address) and staticcall Switchboard(switchboard).isSwitchboardAddr(_addr):\n        return True\n\n    return False\n\n\n@view\n@internal\ndef _isSwitchboardAddr(_addr: address) -> bool:\n    switchboard: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n    if switchboard == empty(address):\n        return False\n    return staticcall Switchboard(switchboard).isSwitchboardAddr(_addr)\n\n\n@view\n@internal\ndef _isLegoBookAddr(_addr: address) -> bool:\n    legoBook: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n    if legoBook == empty(address):\n        return False\n    return staticcall LegoBook(legoBook).isLegoAddr(_addr)\n\n\n###############\n# Departments #\n###############\n\n\n# ledger\n\n\n@view\n@internal\ndef _getLedgerId() -> uint256:\n    return LEDGER_ID\n\n\n@view\n@internal\ndef _getLedgerAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEDGER_ID)\n\n\n# mission control\n\n\n@view\n@internal\ndef _getMissionControlId() -> uint256:\n    return MISSION_CONTROL_ID\n\n\n@view\n@internal\ndef _getMissionControlAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(MISSION_CONTROL_ID)\n\n\n# lego book\n\n\n@view\n@internal\ndef _getLegoBookId() -> uint256:\n    return LEGO_BOOK_ID\n\n\n@view\n@internal\ndef _getLegoBookAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n\n\n# switchboard\n\n\n@view\n@internal\ndef _getSwitchboardId() -> uint256:\n    return SWITCHBOARD_ID\n\n\n@view\n@internal\ndef _getSwitchboardAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n\n\n# hatchery\n\n\n@view\n@internal\ndef _getHatcheryId() -> uint256:\n    return HATCHERY_ID\n\n\n@view\n@internal\ndef _getHatcheryAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(HATCHERY_ID)\n\n\n# loot distributor\n\n\n@view\n@internal\ndef _getLootDistributorId() -> uint256:\n    return LOOT_DISTRIBUTOR_ID\n\n\n@view\n@internal\ndef _getLootDistributorAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LOOT_DISTRIBUTOR_ID)\n\n\n# appraiser\n\n\n@view\n@internal\ndef _getAppraiserId() -> uint256:\n    return APPRAISER_ID\n\n\n@view\n@internal\ndef _getAppraiserAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(APPRAISER_ID)\n\n\n# wallet backpack\n\n\n@view\n@internal\ndef _getWalletBackpackId() -> uint256:\n    return WALLET_BACKPACK_ID\n\n\n@view\n@internal\ndef _getWalletBackpackAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(WALLET_BACKPACK_ID)\n\n\n# billing\n\n\n@view\n@internal\ndef _getBillingId() -> uint256:\n    return BILLING_ID\n\n\n@view\n@internal\ndef _getBillingAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(BILLING_ID)",
            "sha256sum": "78b58f0b2acb2eaafa4d21adf9135a1cd0e1d53897f7a1fa70a83a04a7738ad3"
          },
          "contracts/modules/YieldLegoData.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nuses: addys\n\nimport contracts.modules.Addys as addys\n\nfrom interfaces import WalletStructs as ws\nfrom ethereum.ercs import IERC20\n\nevent AssetOpportunityAdded:\n    asset: indexed(address)\n    vaultAddr: indexed(address)\n\nevent AssetOpportunityRemoved:\n    asset: indexed(address)\n    vaultAddr: indexed(address)\n\nevent LegoPauseModified:\n    isPaused: bool\n\nevent LegoFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    balance: uint256\n\n# config\nisPaused: public(bool)\n\n# asset opportunities\nassetOpportunities: public(HashMap[address, HashMap[uint256, address]]) # asset -> index -> vault addr\nindexOfAssetOpportunity: public(HashMap[address, HashMap[address, uint256]]) # asset -> vault addr -> index\nnumAssetOpportunities: public(HashMap[address, uint256]) # asset -> number of opportunities\n\n# mapping\nvaultToAsset: public(HashMap[address, address]) # vault addr -> underlying asset\n\n# lego assets (iterable)\nassets: public(HashMap[uint256, address]) # index -> asset\nindexOfAsset: public(HashMap[address, uint256]) # asset -> index\nnumAssets: public(uint256) # num assets\n\nMAX_VAULTS: constant(uint256) = 40\nMAX_ASSETS: constant(uint256) = 20\nMAX_RECOVER_ASSETS: constant(uint256) = 20\n\n\n@deploy\ndef __init__(_shouldPause: bool):\n    self.isPaused = _shouldPause\n    self.numAssets = 1 # not using 0 index\n\n\n#########\n# Views #\n#########\n\n\n# is lego asset\n\n\n@view\n@external\ndef isLegoAsset(_asset: address) -> bool:\n    return self._isLegoAsset(_asset)\n\n\n@view\n@internal\ndef _isLegoAsset(_asset: address) -> bool:\n    return self.indexOfAsset[_asset] != 0\n\n\n# vault opportunities\n\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, MAX_VAULTS]:\n    numOpportunities: uint256 = self.numAssetOpportunities[_asset]\n    if numOpportunities == 0:\n        return []\n    opportunities: DynArray[address, MAX_VAULTS] = []\n    for i: uint256 in range(1, numOpportunities, bound=MAX_VAULTS):\n        opportunities.append(self.assetOpportunities[_asset][i])\n    return opportunities\n\n\n# all assets registered\n\n\n@view\n@external\ndef getAssets() -> DynArray[address, MAX_ASSETS]:\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return []\n    assets: DynArray[address, MAX_ASSETS] = []\n    for i: uint256 in range(1, numAssets, bound=MAX_ASSETS):\n        assets.append(self.assets[i])\n    return assets\n\n\n################\n# Registration #\n################\n\n\n@view\n@external\ndef isAssetOpportunity(_asset: address, _vaultAddr: address) -> bool:\n    return self._isAssetOpportunity(_asset, _vaultAddr)\n\n\n@view\n@internal\ndef _isAssetOpportunity(_asset: address, _vaultAddr: address) -> bool:\n    return self.indexOfAssetOpportunity[_asset][_vaultAddr] != 0\n\n\n# add asset opportunity\n\n\n@internal\ndef _addAssetOpportunity(_asset: address, _vaultAddr: address):\n    if self.indexOfAssetOpportunity[_asset][_vaultAddr] != 0:\n        return\n    if empty(address) in [_asset, _vaultAddr]:\n        return\n\n    # add asset opportunity\n    aid: uint256 = self.numAssetOpportunities[_asset]\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.assetOpportunities[_asset][aid] = _vaultAddr\n    self.indexOfAssetOpportunity[_asset][_vaultAddr] = aid\n    self.numAssetOpportunities[_asset] = aid + 1\n\n    # add mapping\n    self.vaultToAsset[_vaultAddr] = _asset\n\n    # add asset\n    self._addAsset(_asset)\n\n    log AssetOpportunityAdded(asset=_asset, vaultAddr=_vaultAddr)\n\n\n# remove asset opportunity\n\n\n@internal\ndef _removeAssetOpportunity(_asset: address, _vaultAddr: address):\n    numOpportunities: uint256 = self.numAssetOpportunities[_asset]\n    if numOpportunities == 0:\n        return\n\n    targetIndex: uint256 = self.indexOfAssetOpportunity[_asset][_vaultAddr]\n    if targetIndex == 0:\n        return\n\n    # update data\n    lastIndex: uint256 = numOpportunities - 1\n    self.numAssetOpportunities[_asset] = lastIndex\n    self.indexOfAssetOpportunity[_asset][_vaultAddr] = 0\n\n    self.vaultToAsset[_vaultAddr] = empty(address)\n\n    # shift to replace the removed one\n    if targetIndex != lastIndex:\n        lastVaultAddr: address = self.assetOpportunities[_asset][lastIndex]\n        self.assetOpportunities[_asset][targetIndex] = lastVaultAddr\n        self.indexOfAssetOpportunity[_asset][lastVaultAddr] = targetIndex\n\n    # remove asset\n    if lastIndex <= 1:\n        self._removeAsset(_asset)\n\n    log AssetOpportunityRemoved(asset=_asset, vaultAddr=_vaultAddr)\n\n\n# add asset\n\n\n@internal\ndef _addAsset(_asset: address):\n    if self.indexOfAsset[_asset] != 0:\n        return\n\n    aid: uint256 = self.numAssets\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.assets[aid] = _asset\n    self.indexOfAsset[_asset] = aid\n    self.numAssets = aid + 1\n\n\n# remove asset\n\n\n@internal\ndef _removeAsset(_asset: address):\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return\n\n    targetIndex: uint256 = self.indexOfAsset[_asset]\n    if targetIndex == 0:\n        return\n\n    # update data\n    lastIndex: uint256 = numAssets - 1\n    self.numAssets = lastIndex\n    self.indexOfAsset[_asset] = 0\n\n    # shift to replace the removed one\n    if targetIndex != lastIndex:\n        lastAsset: address = self.assets[lastIndex]\n        self.assets[targetIndex] = lastAsset\n        self.indexOfAsset[lastAsset] = targetIndex\n\n\n# num lego assets (true number, use `numAssets` for iteration)\n\n\n@view\n@external\ndef getNumLegoAssets() -> uint256:\n    return self._getNumLegoAssets()\n\n\n@view\n@internal\ndef _getNumLegoAssets() -> uint256:\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return 0\n    return numAssets - 1\n\n\n###########\n# General #\n###########\n\n\n# fill mini addys\n\n\n@view\n@internal\ndef _getMiniAddys(_miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> ws.MiniAddys:\n    if _miniAddys.ledger != empty(address):\n        return _miniAddys\n    return ws.MiniAddys(\n        ledger = addys._getLedgerAddr(),\n        missionControl = addys._getMissionControlAddr(),\n        legoBook = addys._getLegoBookAddr(),\n        appraiser = addys._getAppraiserAddr(),\n    )\n\n\n# activate\n\n\n@external\ndef pause(_shouldPause: bool):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert _shouldPause != self.isPaused # dev: no change\n    self.isPaused = _shouldPause\n    log LegoPauseModified(isPaused=_shouldPause)\n\n\n# recover funds\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    self._recoverFunds(_recipient, _asset)\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, MAX_RECOVER_ASSETS]):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    for a: address in _assets:\n        self._recoverFunds(_recipient, a)\n\n\n@internal\ndef _recoverFunds(_recipient: address, _asset: address):\n    assert empty(address) not in [_recipient, _asset] # dev: invalid recipient or asset\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    assert balance != 0 # dev: nothing to recover\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log LegoFundsRecovered(asset=_asset, recipient=_recipient, balance=balance)",
            "sha256sum": "bcbae5ce139758ce8a77c03858ec8d438dea0437d5f3a20fed8267f4d2f15b66"
          },
          "contracts/legos/yield/Euler.vy": {
            "content": "#     __   __ ___ _______ ___     ______       ___     _______ _______ _______ \n#    |  | |  |   |       |   |   |      |     |   |   |       |       |       |\n#    |  |_|  |   |    ___|   |   |  _    |    |   |   |    ___|    ___|   _   |\n#    |       |   |   |___|   |   | | |   |    |   |   |   |___|   | __|  | |  |\n#    |_     _|   |    ___|   |___| |_|   |    |   |___|    ___|   ||  |  |_|  |\n#      |   | |   |   |___|       |       |    |       |   |___|   |_| |       |\n#      |___| |___|_______|_______|______|     |_______|_______|_______|_______|\n#                                                                       \n#     \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n#     \u2551  ** Euler Lego **                       \u2551\n#     \u2551  Integration with Euler Protocol.       \u2551\n#     \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n#\n#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nimplements: Lego\nimplements: YieldLego\n\nexports: addys.__interface__\nexports: yld.__interface__\n\ninitializes: addys\ninitializes: yld[addys := addys]\n\nfrom interfaces import LegoPartner as Lego\nfrom interfaces import YieldLego as YieldLego\nfrom interfaces import WalletStructs as ws\n\nimport contracts.modules.Addys as addys\nimport contracts.modules.YieldLegoData as yld\n\nfrom ethereum.ercs import IERC20\nfrom ethereum.ercs import IERC4626\nfrom ethereum.ercs import IERC20Detailed\n\ninterface Appraiser:\n    def getUsdValue(_asset: address, _amount: uint256, _missionControl: address = empty(address), _legoBook: address = empty(address), _ledger: address = empty(address)) -> uint256: view\n    def updatePriceAndGetUsdValue(_asset: address, _amount: uint256, _missionControl: address = empty(address), _legoBook: address = empty(address)) -> uint256: nonpayable\n\ninterface Ledger:\n    def setVaultToken(_vaultToken: address, _legoId: uint256, _underlyingAsset: address, _decimals: uint256, _isRebasing: bool): nonpayable\n    def isRegisteredVaultToken(_vaultToken: address) -> bool: view\n\ninterface EulerRewardsDistributor:\n    def claim(_users: DynArray[address, 10], _rewardTokens: DynArray[address, 10], _claimAmounts: DynArray[uint256, 10], _proofs: DynArray[bytes32, 10]): nonpayable\n    def operators(_user: address, _operator: address) -> bool: view\n\ninterface EulerEarnFactory:\n    def isValidDeployment(_vault: address) -> bool: view\n\ninterface EulerEvaultFactory:\n    def isProxy(_vault: address) -> bool: view\n\ninterface Registry:\n    def getRegId(_addr: address) -> uint256: view\n\ninterface EulerVault:\n    def totalBorrows() -> uint256: view\n\nevent EulerDeposit:\n    sender: indexed(address)\n    asset: indexed(address)\n    vaultToken: indexed(address)\n    assetAmountDeposited: uint256\n    usdValue: uint256\n    vaultTokenAmountReceived: uint256\n    recipient: address\n\nevent EulerWithdrawal:\n    sender: indexed(address)\n    asset: indexed(address)\n    vaultToken: indexed(address)\n    assetAmountReceived: uint256\n    usdValue: uint256\n    vaultTokenAmountBurned: uint256\n    recipient: address\n\nevent EulerRewardsAddrSet:\n    addr: address\n\n# rewards contract\neulerRewards: public(address)\n\n# euler\nEULER_EVAULT_FACTORY: public(immutable(address))\nEULER_EARN_FACTORY: public(immutable(address))\n\nMAX_TOKEN_PATH: constant(uint256) = 5\nLEGO_ACCESS_ABI: constant(String[64]) = \"toggleOperator(address,address)\"\n\n\n@deploy\ndef __init__(\n    _undyHq: address,\n    _evaultFactory: address,\n    _earnFactory: address,\n    _eulerRewardsAddr: address,\n):\n    addys.__init__(_undyHq)\n    yld.__init__(False)\n\n    assert empty(address) not in [_evaultFactory, _earnFactory] # dev: invalid addrs\n    EULER_EVAULT_FACTORY = _evaultFactory\n    EULER_EARN_FACTORY = _earnFactory\n    self.eulerRewards = _eulerRewardsAddr\n\n\n@view\n@external\ndef hasCapability(_action: ws.ActionType) -> bool:\n    return _action in (\n        ws.ActionType.EARN_DEPOSIT | \n        ws.ActionType.EARN_WITHDRAW\n    )\n\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    return [EULER_EVAULT_FACTORY, EULER_EARN_FACTORY]\n\n\n@view\n@external\ndef getAccessForLego(_user: address, _action: ws.ActionType) -> (address, String[64], uint256):\n    if _action != ws.ActionType.REWARDS:\n        return empty(address), empty(String[64]), 0\n\n    eulerRewards: address = self.eulerRewards\n    if staticcall EulerRewardsDistributor(eulerRewards).operators(_user, self):\n        return empty(address), empty(String[64]), 0\n    else:\n        return eulerRewards, LEGO_ACCESS_ABI, 2\n\n\n@view\n@external\ndef isYieldLego() -> bool:\n    return True\n\n\n@view\n@external\ndef isDexLego() -> bool:\n    return False\n\n\n@view\n@external\ndef isRebasing() -> bool:\n    return self._isRebasing()\n\n\n@view\n@internal\ndef _isRebasing() -> bool:\n    return False\n\n\n@view\n@external\ndef isEligibleVaultForTrialFunds(_vaultToken: address, _underlyingAsset: address) -> bool:\n    asset: address = yld.vaultToAsset[_vaultToken]\n    if asset != _underlyingAsset:\n        return False\n    return self._hasSufficientAssets(_vaultToken, _underlyingAsset)\n\n\n@view\n@external\ndef isEligibleForYieldBonus(_asset: address) -> bool:\n    underlyingAsset: address = yld.vaultToAsset[_asset]\n    if underlyingAsset == empty(address):\n        return False\n    return self._hasSufficientAssets(_asset, underlyingAsset)\n\n\n# check if vault has sufficient assets\n\n\n@view\n@internal\ndef _hasSufficientAssets(_vaultToken: address, _underlyingAsset: address) -> bool:\n    # vault must have at least $100k in assets\n    decimals: uint256 = convert(staticcall IERC20Detailed(_underlyingAsset).decimals(), uint256)\n    return staticcall IERC4626(_vaultToken).totalAssets() > 100_000 * (10 ** decimals)\n\n\n#########\n# Yield #\n#########\n\n\n# deposit\n\n\n@external\ndef depositForYield(\n    _asset: address,\n    _amount: uint256,\n    _vaultAddr: address,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, address, uint256, uint256):\n    assert not yld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = yld._getMiniAddys(_miniAddys)\n\n    # verify vault token (register if necessary)\n    vaultToken: address = self._getVaultTokenOnDeposit(_asset, _vaultAddr, miniAddys.ledger, miniAddys.legoBook)\n\n    # pre balances\n    preLegoBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n\n    # transfer deposit asset to this contract\n    depositAmount: uint256 = min(_amount, staticcall IERC20(_asset).balanceOf(msg.sender))\n    assert depositAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_asset).transferFrom(msg.sender, self, depositAmount, default_return_value=True) # dev: transfer failed\n\n    # deposit assets into lego partner\n    vaultTokenAmountReceived: uint256 = extcall IERC4626(vaultToken).deposit(depositAmount, _recipient)\n    assert vaultTokenAmountReceived != 0 # dev: no vault tokens received\n\n    # refund if full deposit didn't get through\n    currentLegoBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    refundAssetAmount: uint256 = 0\n    if currentLegoBalance > preLegoBalance:\n        refundAssetAmount = currentLegoBalance - preLegoBalance\n        assert extcall IERC20(_asset).transfer(msg.sender, refundAssetAmount, default_return_value=True) # dev: transfer failed\n        depositAmount -= refundAssetAmount\n\n    usdValue: uint256 = extcall Appraiser(miniAddys.appraiser).updatePriceAndGetUsdValue(_asset, depositAmount, miniAddys.missionControl, miniAddys.legoBook)\n    log EulerDeposit(\n        sender = msg.sender,\n        asset = _asset,\n        vaultToken = vaultToken,\n        assetAmountDeposited = depositAmount,\n        usdValue = usdValue,\n        vaultTokenAmountReceived = vaultTokenAmountReceived,\n        recipient = _recipient,\n    )\n    return depositAmount, vaultToken, vaultTokenAmountReceived, usdValue\n\n\n# asset verification\n\n\n@internal\ndef _getVaultTokenOnDeposit(_asset: address, _vaultAddr: address, _ledger: address, _legoBook: address) -> address:\n    asset: address = yld.vaultToAsset[_vaultAddr]\n    isRegistered: bool = True\n\n    # not yet registered, call euler directly to get asset\n    if asset == empty(address) and self._isValidEulerVault(_vaultAddr):\n        asset = staticcall IERC4626(_vaultAddr).asset()\n        isRegistered = False\n\n    assert asset != empty(address) # dev: invalid asset\n    assert asset == _asset # dev: asset mismatch\n\n    # register if necessary\n    if not isRegistered:\n        self._registerAsset(asset, _vaultAddr)\n        self._updateLedgerVaultToken(asset, _vaultAddr, _ledger, _legoBook)\n\n    return _vaultAddr\n\n\n# withdraw\n\n\n@external\ndef withdrawFromYield(\n    _vaultToken: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, address, uint256, uint256):\n    assert not yld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = yld._getMiniAddys(_miniAddys)\n\n    # verify asset (register if necessary)\n    asset: address = self._getAssetOnWithdraw(_vaultToken, miniAddys.ledger, miniAddys.legoBook)\n\n    # pre balances\n    preLegoVaultBalance: uint256 = staticcall IERC20(_vaultToken).balanceOf(self)\n\n    # transfer vaults tokens to this contract\n    vaultTokenAmount: uint256 = min(_amount, staticcall IERC20(_vaultToken).balanceOf(msg.sender))\n    assert vaultTokenAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_vaultToken).transferFrom(msg.sender, self, vaultTokenAmount, default_return_value=True) # dev: transfer failed\n\n    # withdraw assets from lego partner\n    assetAmountReceived: uint256 = extcall IERC4626(_vaultToken).redeem(vaultTokenAmount, _recipient, self)\n    assert assetAmountReceived != 0 # dev: no asset amount received\n\n    # refund if full withdrawal didn't happen\n    currentLegoVaultBalance: uint256 = staticcall IERC20(_vaultToken).balanceOf(self)\n    refundVaultTokenAmount: uint256 = 0\n    if currentLegoVaultBalance > preLegoVaultBalance:\n        refundVaultTokenAmount = currentLegoVaultBalance - preLegoVaultBalance\n        assert extcall IERC20(_vaultToken).transfer(msg.sender, refundVaultTokenAmount, default_return_value=True) # dev: transfer failed\n        vaultTokenAmount -= refundVaultTokenAmount\n\n    usdValue: uint256 = extcall Appraiser(miniAddys.appraiser).updatePriceAndGetUsdValue(asset, assetAmountReceived, miniAddys.missionControl, miniAddys.legoBook)\n    log EulerWithdrawal(\n        sender = msg.sender,\n        asset = asset,\n        vaultToken = _vaultToken,\n        assetAmountReceived = assetAmountReceived,\n        usdValue = usdValue,\n        vaultTokenAmountBurned = vaultTokenAmount,\n        recipient = _recipient,\n    )\n    return vaultTokenAmount, asset, assetAmountReceived, usdValue\n\n\n# vault token verification\n\n\n@internal\ndef _getAssetOnWithdraw(_vaultToken: address, _ledger: address, _legoBook: address) -> address:\n    asset: address = yld.vaultToAsset[_vaultToken]\n    isRegistered: bool = True\n\n    # not yet registered, call euler directly to get asset\n    if asset == empty(address) and self._isValidEulerVault(_vaultToken):\n        asset = staticcall IERC4626(_vaultToken).asset()\n        isRegistered = False\n\n    assert asset != empty(address) # dev: invalid asset\n\n    # register if necessary\n    if not isRegistered:\n        self._registerAsset(asset, _vaultToken)\n        self._updateLedgerVaultToken(asset, _vaultToken, _ledger, _legoBook)\n\n    return asset\n\n\n#################\n# Claim Rewards #\n#################\n\n\n@external\ndef claimRewards(\n    _user: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _extraData: bytes32,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    assert not yld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = yld._getMiniAddys(_miniAddys)\n\n    assert msg.sender == _user # dev: recipient must be caller\n    preBalance: uint256 = staticcall IERC20(_rewardToken).balanceOf(_user)\n\n    eulerRewards: address = self.eulerRewards\n    assert eulerRewards != empty(address) # dev: no eulerRewards rewards addr set\n    extcall EulerRewardsDistributor(eulerRewards).claim([_user], [_rewardToken], [_rewardAmount], [_extraData])\n    rewardAmount: uint256 = staticcall IERC20(_rewardToken).balanceOf(_user) - preBalance\n    assert rewardAmount != 0 # dev: no rewards received\n\n    usdValue: uint256 = extcall Appraiser(miniAddys.appraiser).updatePriceAndGetUsdValue(_rewardToken, rewardAmount, miniAddys.missionControl, miniAddys.legoBook)\n    return rewardAmount, usdValue\n\n\n@view\n@external\ndef hasClaimableRewards(_user: address) -> bool:\n    # as far as we can tell, this must be done offchain\n    return False\n\n\n# set rewards addr\n\n\n@external\ndef setEulerRewardsAddr(_addr: address) -> bool:\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert _addr != empty(address) # dev: invalid addr\n    self.eulerRewards = _addr\n    log EulerRewardsAddrSet(addr=_addr)\n    return True\n\n\n#############\n# Utilities #\n#############\n\n\n# underlying asset\n\n\n@view\n@external\ndef isVaultToken(_vaultToken: address) -> bool:\n    return self._isVaultToken(_vaultToken)\n\n\n@view\n@internal\ndef _isVaultToken(_vaultToken: address) -> bool:\n    if yld.vaultToAsset[_vaultToken] != empty(address):\n        return True\n    return self._isValidEulerVault(_vaultToken)\n\n\n@view\n@internal\ndef _isValidEulerVault(_vaultToken: address) -> bool:\n    return staticcall EulerEvaultFactory(EULER_EVAULT_FACTORY).isProxy(_vaultToken) or staticcall EulerEarnFactory(EULER_EARN_FACTORY).isValidDeployment(_vaultToken)\n\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    return self._getUnderlyingAsset(_vaultToken)\n\n\n@view\n@internal\ndef _getUnderlyingAsset(_vaultToken: address) -> address:\n    asset: address = yld.vaultToAsset[_vaultToken]\n    if asset == empty(address) and self._isValidEulerVault(_vaultToken):\n        asset = staticcall IERC4626(_vaultToken).asset()\n    return asset\n\n\n# underlying amount\n\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    if not self._isVaultToken(_vaultToken) or _vaultTokenAmount == 0:\n        return 0 # invalid vault token or amount\n    return self._getUnderlyingAmount(_vaultToken, _vaultTokenAmount)\n\n\n@view\n@internal\ndef _getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    return staticcall IERC4626(_vaultToken).convertToAssets(_vaultTokenAmount)\n\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    if empty(address) in [_asset, _vaultToken] or _assetAmount == 0:\n        return 0 # bad inputs\n    if self._getUnderlyingAsset(_vaultToken) != _asset:\n        return 0 # invalid vault token or asset\n    return staticcall IERC4626(_vaultToken).convertToShares(_assetAmount)\n\n\n# usd value\n\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> uint256:\n    return self._getUsdValueOfVaultToken(_vaultToken, _vaultTokenAmount, _appraiser)\n\n\n@view\n@internal\ndef _getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address) -> uint256:\n    asset: address = empty(address)\n    underlyingAmount: uint256 = 0\n    usdValue: uint256 = 0\n    asset, underlyingAmount, usdValue = self._getUnderlyingData(_vaultToken, _vaultTokenAmount, _appraiser)\n    return usdValue\n\n\n# all underlying data together\n\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> (address, uint256, uint256):\n    return self._getUnderlyingData(_vaultToken, _vaultTokenAmount, _appraiser)\n\n\n@view\n@internal\ndef _getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address) -> (address, uint256, uint256):\n    if _vaultTokenAmount == 0 or _vaultToken == empty(address):\n        return empty(address), 0, 0 # bad inputs\n    asset: address = self._getUnderlyingAsset(_vaultToken)\n    if asset == empty(address):\n        return empty(address), 0, 0 # invalid vault token\n    underlyingAmount: uint256 = self._getUnderlyingAmount(_vaultToken, _vaultTokenAmount)\n    usdValue: uint256 = self._getUsdValue(asset, underlyingAmount, _appraiser)\n    return asset, underlyingAmount, usdValue\n\n\n@view\n@internal\ndef _getUsdValue(_asset: address, _amount: uint256, _appraiser: address) -> uint256:\n    appraiser: address = _appraiser\n    if _appraiser == empty(address):\n        appraiser = addys._getAppraiserAddr()\n    return staticcall Appraiser(appraiser).getUsdValue(_asset, _amount)\n\n\n# other\n\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    if not self._isVaultToken(_vaultToken):\n        return 0 # invalid vault token\n    return staticcall IERC4626(_vaultToken).totalAssets()\n\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    if not self._isVaultToken(_vaultToken):\n        return 0 # invalid vault token\n    return staticcall EulerVault(_vaultToken).totalBorrows()\n\n\n# price per share\n\n\n@view\n@external\ndef getPricePerShare(_asset: address, _decimals: uint256) -> uint256:\n    return staticcall IERC4626(_asset).convertToAssets(10 ** _decimals)\n\n\n################\n# Registration #\n################\n\n\n@external\ndef addAssetOpportunity(_asset: address, _vaultAddr: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert self._isValidAssetOpportunity(_asset, _vaultAddr) # dev: invalid asset or vault\n    assert not yld._isAssetOpportunity(_asset, _vaultAddr) # dev: already registered\n    self._registerAsset(_asset, _vaultAddr)\n\n\n@internal\ndef _registerAsset(_asset: address, _vaultAddr: address):\n    assert extcall IERC20(_asset).approve(_vaultAddr, max_value(uint256), default_return_value=True) # dev: max approval failed\n    yld._addAssetOpportunity(_asset, _vaultAddr)\n\n\n@external\ndef removeAssetOpportunity(_asset: address, _vaultAddr: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert extcall IERC20(_asset).approve(_vaultAddr, 0, default_return_value=True) # dev: max approval failed\n    yld._removeAssetOpportunity(_asset, _vaultAddr)\n\n\n# validation\n\n\n@view\n@internal\ndef isValidAssetOpportunity(_asset: address, _vaultAddr: address) -> bool:\n    return self._isValidAssetOpportunity(_asset, _vaultAddr)\n\n\n@view\n@internal\ndef _isValidAssetOpportunity(_asset: address, _vaultAddr: address) -> bool:\n    return self._isValidEulerVault(_vaultAddr) and staticcall IERC4626(_vaultAddr).asset() == _asset\n\n\n# update ledger registration\n\n\n@internal\ndef _updateLedgerVaultToken(\n    _underlyingAsset: address,\n    _vaultToken: address,\n    _ledger: address,\n    _legoBook: address,\n):\n    if empty(address) in [_underlyingAsset, _vaultToken]:\n        return\n\n    if not staticcall Ledger(_ledger).isRegisteredVaultToken(_vaultToken):\n        legoId: uint256 = staticcall Registry(_legoBook).getRegId(self)\n        decimals: uint256 = convert(staticcall IERC20Detailed(_vaultToken).decimals(), uint256)\n        extcall Ledger(_ledger).setVaultToken(_vaultToken, legoId, _underlyingAsset, decimals, self._isRebasing())\n\n\n#########\n# Other #\n#########\n\n\n@external\ndef swapTokens(\n    _amountIn: uint256,\n    _minAmountOut: uint256,\n    _tokenPath: DynArray[address, MAX_TOKEN_PATH],\n    _poolPath: DynArray[address, MAX_TOKEN_PATH - 1],\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256):\n    return 0, 0, 0\n\n\n@external\ndef mintOrRedeemAsset(\n    _tokenIn: address,\n    _tokenOut: address,\n    _tokenInAmount: uint256,\n    _minAmountOut: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, bool, uint256):\n    return 0, 0, False, 0\n\n\n@external\ndef confirmMintOrRedeemAsset(\n    _tokenIn: address,\n    _tokenOut: address,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef addCollateral(\n    _asset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef removeCollateral(\n    _asset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef borrow(\n    _borrowAsset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef repayDebt(\n    _paymentAsset: address,\n    _paymentAmount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef addLiquidity(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _amountA: uint256,\n    _amountB: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _minLpAmount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (address, uint256, uint256, uint256, uint256):\n    return empty(address), 0, 0, 0, 0\n\n\n@external\ndef removeLiquidity(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpToken: address,\n    _lpAmount: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, uint256):\n    return 0, 0, 0, 0\n\n\n@external\ndef addLiquidityConcentrated(\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _tickLower: int24,\n    _tickUpper: int24,\n    _amountA: uint256,\n    _amountB: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, uint256, uint256):\n    return 0, 0, 0, 0, 0\n\n\n@external\ndef removeLiquidityConcentrated(\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _liqToRemove: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, bool, uint256):\n    return 0, 0, 0, False, 0\n\n\n@view\n@external\ndef getPrice(_asset: address, _decimals: uint256) -> uint256:\n    return 0\n",
            "sha256sum": "53c0ea81ff252863a4e05a3790e2e50b1f1698e84505c95eebced2418bff39d9"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/legos/yield/Euler.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.3+commit.bff19ea2",
        "integrity": "16061a6c551daf48cc698e46def1980b6dc5bec04779870e3cba34cf0f26fbb4"
      },
      "args": "00000000000000000000000044cf3c4f000dfd76a35d03298049d37be688d6f90000000000000000000000007f321498a801a191a93c840750ed637149ddf8d000000000000000000000000072bbdb652f2aec9056115644efccdd1986f51f150000000000000000000000003ef3d8ba38ebe18db133cec108f4d14ce00dd9ae",
      "file": "contracts/legos/yield/Euler.vy"
    },
    "Fluid": {
      "address": "0x4719731fC7c8A3e17CB3e1EadD4412692432B404",
      "abi": [
        {
          "name": "FluidDeposit",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountDeposited",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultTokenAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "FluidWithdrawal",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultTokenAmountBurned",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LegoPauseModified",
          "inputs": [
            {
              "name": "isPaused",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LegoFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "balance",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetOpportunityAdded",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultAddr",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetOpportunityRemoved",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultAddr",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddys",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "undyToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "hatchery",
                  "type": "address"
                },
                {
                  "name": "lootDistributor",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                },
                {
                  "name": "walletBackpack",
                  "type": "address"
                },
                {
                  "name": "billing",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUndyHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isLegoAsset",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssetOpportunities",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isAssetOpportunity",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getNumLegoAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pause",
          "inputs": [
            {
              "name": "_shouldPause",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFundsMany",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_assets",
              "type": "address[]"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isPaused",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assetOpportunities",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAssetOpportunity",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssetOpportunities",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "vaultToAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assets",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasCapability",
          "inputs": [
            {
              "name": "_action",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRegistries",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isYieldLego",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isDexLego",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isEligibleVaultForTrialFunds",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_underlyingAsset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isEligibleForYieldBonus",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isRebasing",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositForYield",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositForYield",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawFromYield",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawFromYield",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAsset",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAmount",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getVaultTokenAmount",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_assetAmount",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValueOfVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValueOfVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            },
            {
              "name": "_appraiser",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingData",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingData",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            },
            {
              "name": "_appraiser",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalAssets",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalBorrows",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPricePerShare",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_decimals",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addAssetOpportunity",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeAssetOpportunity",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_tokenPath",
              "type": "address[]"
            },
            {
              "name": "_poolPath",
              "type": "address[]"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_tokenPath",
              "type": "address[]"
            },
            {
              "name": "_poolPath",
              "type": "address[]"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_tokenInAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_tokenInAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmMintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmMintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_borrowAsset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_borrowAsset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_paymentAsset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_paymentAsset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAccessForLego",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_action",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "string"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPrice",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_decimals",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "FLUID_RESOLVER",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_undyHq",
              "type": "address"
            },
            {
              "name": "_fluidResolver",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "interfaces/WalletStructs.vyi": {
            "content": "# @version 0.4.3\n\nflag ActionType:\n    TRANSFER\n    EARN_DEPOSIT\n    EARN_WITHDRAW\n    EARN_REBALANCE\n    SWAP\n    MINT_REDEEM\n    CONFIRM_MINT_REDEEM\n    ADD_COLLATERAL\n    REMOVE_COLLATERAL\n    BORROW\n    REPAY_DEBT\n    REWARDS\n    ETH_TO_WETH\n    WETH_TO_ETH\n    ADD_LIQ\n    REMOVE_LIQ\n    ADD_LIQ_CONC\n    REMOVE_LIQ_CONC\n    PAY_CHEQUE\n\nstruct WalletAssetData:\n    assetBalance: uint256\n    usdValue: uint256\n    isYieldAsset: bool\n    lastPricePerShare: uint256\n\nstruct ActionData:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    billing: address\n    wallet: address\n    walletConfig: address\n    walletOwner: address\n    inEjectMode: bool\n    isFrozen: bool\n    lastTotalUsdValue: uint256\n    signer: address\n    isManager: bool\n    legoId: uint256\n    legoAddr: address\n    eth: address\n    weth: address\n\nstruct MiniAddys:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    appraiser: address",
            "sha256sum": "9a4b4f59b3a62043e51b425a665064aae419a3c0bd0514b6b29a9441ae364bb9"
          },
          "interfaces/LegoPartner.vyi": {
            "content": "# @version 0.4.3\n\nfrom interfaces import WalletStructs as ws\n\nMAX_TOKEN_PATH: constant(uint256) = 5\nMAX_RECOVER_ASSETS: constant(uint256) = 20\n\n@external\ndef addLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _tickLower: int24, _tickUpper: int24, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef addLiquidity(_pool: address, _tokenA: address, _tokenB: address, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _minLpAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (address, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef removeLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _liqToRemove: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef removeLiquidity(_pool: address, _tokenA: address, _tokenB: address, _lpToken: address, _lpAmount: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef mintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _tokenInAmount: uint256, _minAmountOut: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef swapTokens(_amountIn: uint256, _minAmountOut: uint256, _tokenPath: DynArray[address, MAX_TOKEN_PATH], _poolPath: DynArray[address, MAX_TOKEN_PATH - 1], _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256):\n    ...\n\n@external\ndef depositForYield(_asset: address, _amount: uint256, _vaultAddr: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef withdrawFromYield(_vaultToken: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef confirmMintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef borrow(_borrowAsset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef repayDebt(_paymentAsset: address, _paymentAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef claimRewards(_user: address, _rewardToken: address, _rewardAmount: uint256, _extraData: bytes32, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef removeCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef addCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@view\n@external\ndef getAccessForLego(_user: address, _action: ws.ActionType) -> (address, String[64], uint256):\n    ...\n\n@view\n@external\ndef hasCapability(_action: ws.ActionType) -> bool:\n    ...\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    ...\n\n@view\n@external\ndef isYieldLego() -> bool:\n    ...\n\n@view\n@external\ndef isDexLego() -> bool:\n    ...\n\n@view\n@external\ndef getPricePerShare(_asset: address, _decimals: uint256) -> uint256:\n    ...\n\n@view\n@external\ndef getPrice(_asset: address, _decimals: uint256) -> uint256:\n    ...\n\n\n# common\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "2513e379aa74d0a8120114a5078a4c1a0900165a1c3f24419bb811d173b56453"
          },
          "interfaces/YieldLego.vyi": {
            "content": "# @version 0.4.3\n\n@view\n@external\ndef isRebasing() -> bool:\n    ...\n\n\n@view\n@external\ndef isEligibleForYieldBonus(_asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef isEligibleVaultForTrialFunds(_vaultToken: address, _underlyingAsset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    ...\n\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    ...\n\n\n@view\n@external\ndef isVaultToken(_vaultToken: address) -> bool:\n    ...\n\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> uint256:\n    ...\n\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> (address, uint256, uint256):\n    ...\n\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    ...\n\n\n@external\ndef addAssetOpportunity(_asset: address, _vaultAddr: address):\n    ...\n\n\n@external\ndef removeAssetOpportunity(_asset: address, _vaultAddr: address):\n    ...\n\n\n# YieldLegoData.vy module\n\n\n@view\n@external\ndef assetOpportunities(_asset: address, _index: uint256) -> address:\n    ...\n\n\n@view\n@external\ndef indexOfAssetOpportunity(_asset: address, _vaultAddr: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef numAssetOpportunities(_asset: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef vaultToAsset(_vaultAddr: address) -> address:\n    ...\n\n\n@view\n@external\ndef assets(_index: uint256) -> address:\n    ...\n\n\n@view\n@external\ndef indexOfAsset(_asset: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef numAssets() -> uint256:\n    ...\n\n\n@view\n@external\ndef isLegoAsset(_asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, 40]:\n    ...\n\n\n@view\n@external\ndef getAssets() -> DynArray[address, 20]:\n    ...\n\n\n@view\n@external\ndef isAssetOpportunity(_asset: address, _vaultAddr: address) -> bool:\n    ...\n\n\n@view\n@external\ndef getNumLegoAssets() -> uint256:\n    ...\n",
            "sha256sum": "3337ce5f78b0df6f86d1144b07505512bb1044304f67add97be6c3816b3c0b42"
          },
          "contracts/modules/Addys.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\ninterface UndyHq:\n    def isValidAddr(_addr: address) -> bool: view\n    def getAddr(_regId: uint256) -> address: view\n    def undyToken() -> address: view\n\ninterface Switchboard:\n    def isSwitchboardAddr(_addr: address) -> bool: view\n\ninterface LegoBook:\n    def isLegoAddr(_addr: address) -> bool: view\n\nstruct Addys:\n    hq: address\n    undyToken: address\n    ledger: address\n    missionControl: address\n    legoBook: address\n    switchboard: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    walletBackpack: address\n    billing: address\n\n# hq\nUNDY_HQ_FOR_ADDYS: immutable(address)\n\n# core addys\nLEDGER_ID: constant(uint256) = 1\nMISSION_CONTROL_ID: constant(uint256) = 2\nLEGO_BOOK_ID: constant(uint256) = 3\nSWITCHBOARD_ID: constant(uint256) = 4\nHATCHERY_ID: constant(uint256) = 5\nLOOT_DISTRIBUTOR_ID: constant(uint256) = 6\nAPPRAISER_ID: constant(uint256) = 7\nWALLET_BACKPACK_ID: constant(uint256) = 8\nBILLING_ID: constant(uint256) = 9\n\n\n@deploy\ndef __init__(_undyHq: address):\n    assert _undyHq != empty(address) # dev: invalid undy hq\n    UNDY_HQ_FOR_ADDYS = _undyHq\n\n\n########\n# Core #\n########\n\n\n@view\n@external\ndef getAddys() -> Addys:\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _getAddys(_addys: Addys = empty(Addys)) -> Addys:\n    if _addys.hq != empty(address):\n        return _addys\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _generateAddys() -> Addys:\n    hq: address = UNDY_HQ_FOR_ADDYS\n    return Addys(\n        hq = hq,\n        undyToken = staticcall UndyHq(hq).undyToken(),\n        ledger = staticcall UndyHq(hq).getAddr(LEDGER_ID),\n        missionControl = staticcall UndyHq(hq).getAddr(MISSION_CONTROL_ID),\n        legoBook = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID),\n        switchboard = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID),\n        hatchery = staticcall UndyHq(hq).getAddr(HATCHERY_ID),\n        lootDistributor = staticcall UndyHq(hq).getAddr(LOOT_DISTRIBUTOR_ID),\n        appraiser = staticcall UndyHq(hq).getAddr(APPRAISER_ID),\n        walletBackpack = staticcall UndyHq(hq).getAddr(WALLET_BACKPACK_ID),\n        billing = staticcall UndyHq(hq).getAddr(BILLING_ID),\n    )\n\n\n##########\n# Tokens #\n##########\n\n\n@view\n@internal\ndef _getUndyToken() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).undyToken()\n\n\n###########\n# Helpers #\n###########\n\n\n# undy hq\n\n\n@view\n@external\ndef getUndyHq() -> address:\n    return self._getUndyHq()\n\n\n@view\n@internal\ndef _getUndyHq() -> address:\n    return UNDY_HQ_FOR_ADDYS\n\n\n# utils\n\n\n@view\n@internal\ndef _isValidUndyAddr(_addr: address, _hq: address = empty(address)) -> bool:\n    hq: address = _hq\n    if _hq == empty(address):\n        hq = UNDY_HQ_FOR_ADDYS\n    \n    # core departments\n    if staticcall UndyHq(hq).isValidAddr(_addr):\n        return True\n\n    # lego book\n    legoBook: address = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID)\n    if legoBook != empty(address) and staticcall LegoBook(legoBook).isLegoAddr(_addr):\n        return True\n\n    # switchboard config\n    switchboard: address = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID)\n    if switchboard != empty(address) and staticcall Switchboard(switchboard).isSwitchboardAddr(_addr):\n        return True\n\n    return False\n\n\n@view\n@internal\ndef _isSwitchboardAddr(_addr: address) -> bool:\n    switchboard: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n    if switchboard == empty(address):\n        return False\n    return staticcall Switchboard(switchboard).isSwitchboardAddr(_addr)\n\n\n@view\n@internal\ndef _isLegoBookAddr(_addr: address) -> bool:\n    legoBook: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n    if legoBook == empty(address):\n        return False\n    return staticcall LegoBook(legoBook).isLegoAddr(_addr)\n\n\n###############\n# Departments #\n###############\n\n\n# ledger\n\n\n@view\n@internal\ndef _getLedgerId() -> uint256:\n    return LEDGER_ID\n\n\n@view\n@internal\ndef _getLedgerAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEDGER_ID)\n\n\n# mission control\n\n\n@view\n@internal\ndef _getMissionControlId() -> uint256:\n    return MISSION_CONTROL_ID\n\n\n@view\n@internal\ndef _getMissionControlAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(MISSION_CONTROL_ID)\n\n\n# lego book\n\n\n@view\n@internal\ndef _getLegoBookId() -> uint256:\n    return LEGO_BOOK_ID\n\n\n@view\n@internal\ndef _getLegoBookAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n\n\n# switchboard\n\n\n@view\n@internal\ndef _getSwitchboardId() -> uint256:\n    return SWITCHBOARD_ID\n\n\n@view\n@internal\ndef _getSwitchboardAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n\n\n# hatchery\n\n\n@view\n@internal\ndef _getHatcheryId() -> uint256:\n    return HATCHERY_ID\n\n\n@view\n@internal\ndef _getHatcheryAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(HATCHERY_ID)\n\n\n# loot distributor\n\n\n@view\n@internal\ndef _getLootDistributorId() -> uint256:\n    return LOOT_DISTRIBUTOR_ID\n\n\n@view\n@internal\ndef _getLootDistributorAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LOOT_DISTRIBUTOR_ID)\n\n\n# appraiser\n\n\n@view\n@internal\ndef _getAppraiserId() -> uint256:\n    return APPRAISER_ID\n\n\n@view\n@internal\ndef _getAppraiserAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(APPRAISER_ID)\n\n\n# wallet backpack\n\n\n@view\n@internal\ndef _getWalletBackpackId() -> uint256:\n    return WALLET_BACKPACK_ID\n\n\n@view\n@internal\ndef _getWalletBackpackAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(WALLET_BACKPACK_ID)\n\n\n# billing\n\n\n@view\n@internal\ndef _getBillingId() -> uint256:\n    return BILLING_ID\n\n\n@view\n@internal\ndef _getBillingAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(BILLING_ID)",
            "sha256sum": "78b58f0b2acb2eaafa4d21adf9135a1cd0e1d53897f7a1fa70a83a04a7738ad3"
          },
          "contracts/modules/YieldLegoData.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nuses: addys\n\nimport contracts.modules.Addys as addys\n\nfrom interfaces import WalletStructs as ws\nfrom ethereum.ercs import IERC20\n\nevent AssetOpportunityAdded:\n    asset: indexed(address)\n    vaultAddr: indexed(address)\n\nevent AssetOpportunityRemoved:\n    asset: indexed(address)\n    vaultAddr: indexed(address)\n\nevent LegoPauseModified:\n    isPaused: bool\n\nevent LegoFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    balance: uint256\n\n# config\nisPaused: public(bool)\n\n# asset opportunities\nassetOpportunities: public(HashMap[address, HashMap[uint256, address]]) # asset -> index -> vault addr\nindexOfAssetOpportunity: public(HashMap[address, HashMap[address, uint256]]) # asset -> vault addr -> index\nnumAssetOpportunities: public(HashMap[address, uint256]) # asset -> number of opportunities\n\n# mapping\nvaultToAsset: public(HashMap[address, address]) # vault addr -> underlying asset\n\n# lego assets (iterable)\nassets: public(HashMap[uint256, address]) # index -> asset\nindexOfAsset: public(HashMap[address, uint256]) # asset -> index\nnumAssets: public(uint256) # num assets\n\nMAX_VAULTS: constant(uint256) = 40\nMAX_ASSETS: constant(uint256) = 20\nMAX_RECOVER_ASSETS: constant(uint256) = 20\n\n\n@deploy\ndef __init__(_shouldPause: bool):\n    self.isPaused = _shouldPause\n    self.numAssets = 1 # not using 0 index\n\n\n#########\n# Views #\n#########\n\n\n# is lego asset\n\n\n@view\n@external\ndef isLegoAsset(_asset: address) -> bool:\n    return self._isLegoAsset(_asset)\n\n\n@view\n@internal\ndef _isLegoAsset(_asset: address) -> bool:\n    return self.indexOfAsset[_asset] != 0\n\n\n# vault opportunities\n\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, MAX_VAULTS]:\n    numOpportunities: uint256 = self.numAssetOpportunities[_asset]\n    if numOpportunities == 0:\n        return []\n    opportunities: DynArray[address, MAX_VAULTS] = []\n    for i: uint256 in range(1, numOpportunities, bound=MAX_VAULTS):\n        opportunities.append(self.assetOpportunities[_asset][i])\n    return opportunities\n\n\n# all assets registered\n\n\n@view\n@external\ndef getAssets() -> DynArray[address, MAX_ASSETS]:\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return []\n    assets: DynArray[address, MAX_ASSETS] = []\n    for i: uint256 in range(1, numAssets, bound=MAX_ASSETS):\n        assets.append(self.assets[i])\n    return assets\n\n\n################\n# Registration #\n################\n\n\n@view\n@external\ndef isAssetOpportunity(_asset: address, _vaultAddr: address) -> bool:\n    return self._isAssetOpportunity(_asset, _vaultAddr)\n\n\n@view\n@internal\ndef _isAssetOpportunity(_asset: address, _vaultAddr: address) -> bool:\n    return self.indexOfAssetOpportunity[_asset][_vaultAddr] != 0\n\n\n# add asset opportunity\n\n\n@internal\ndef _addAssetOpportunity(_asset: address, _vaultAddr: address):\n    if self.indexOfAssetOpportunity[_asset][_vaultAddr] != 0:\n        return\n    if empty(address) in [_asset, _vaultAddr]:\n        return\n\n    # add asset opportunity\n    aid: uint256 = self.numAssetOpportunities[_asset]\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.assetOpportunities[_asset][aid] = _vaultAddr\n    self.indexOfAssetOpportunity[_asset][_vaultAddr] = aid\n    self.numAssetOpportunities[_asset] = aid + 1\n\n    # add mapping\n    self.vaultToAsset[_vaultAddr] = _asset\n\n    # add asset\n    self._addAsset(_asset)\n\n    log AssetOpportunityAdded(asset=_asset, vaultAddr=_vaultAddr)\n\n\n# remove asset opportunity\n\n\n@internal\ndef _removeAssetOpportunity(_asset: address, _vaultAddr: address):\n    numOpportunities: uint256 = self.numAssetOpportunities[_asset]\n    if numOpportunities == 0:\n        return\n\n    targetIndex: uint256 = self.indexOfAssetOpportunity[_asset][_vaultAddr]\n    if targetIndex == 0:\n        return\n\n    # update data\n    lastIndex: uint256 = numOpportunities - 1\n    self.numAssetOpportunities[_asset] = lastIndex\n    self.indexOfAssetOpportunity[_asset][_vaultAddr] = 0\n\n    self.vaultToAsset[_vaultAddr] = empty(address)\n\n    # shift to replace the removed one\n    if targetIndex != lastIndex:\n        lastVaultAddr: address = self.assetOpportunities[_asset][lastIndex]\n        self.assetOpportunities[_asset][targetIndex] = lastVaultAddr\n        self.indexOfAssetOpportunity[_asset][lastVaultAddr] = targetIndex\n\n    # remove asset\n    if lastIndex <= 1:\n        self._removeAsset(_asset)\n\n    log AssetOpportunityRemoved(asset=_asset, vaultAddr=_vaultAddr)\n\n\n# add asset\n\n\n@internal\ndef _addAsset(_asset: address):\n    if self.indexOfAsset[_asset] != 0:\n        return\n\n    aid: uint256 = self.numAssets\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.assets[aid] = _asset\n    self.indexOfAsset[_asset] = aid\n    self.numAssets = aid + 1\n\n\n# remove asset\n\n\n@internal\ndef _removeAsset(_asset: address):\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return\n\n    targetIndex: uint256 = self.indexOfAsset[_asset]\n    if targetIndex == 0:\n        return\n\n    # update data\n    lastIndex: uint256 = numAssets - 1\n    self.numAssets = lastIndex\n    self.indexOfAsset[_asset] = 0\n\n    # shift to replace the removed one\n    if targetIndex != lastIndex:\n        lastAsset: address = self.assets[lastIndex]\n        self.assets[targetIndex] = lastAsset\n        self.indexOfAsset[lastAsset] = targetIndex\n\n\n# num lego assets (true number, use `numAssets` for iteration)\n\n\n@view\n@external\ndef getNumLegoAssets() -> uint256:\n    return self._getNumLegoAssets()\n\n\n@view\n@internal\ndef _getNumLegoAssets() -> uint256:\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return 0\n    return numAssets - 1\n\n\n###########\n# General #\n###########\n\n\n# fill mini addys\n\n\n@view\n@internal\ndef _getMiniAddys(_miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> ws.MiniAddys:\n    if _miniAddys.ledger != empty(address):\n        return _miniAddys\n    return ws.MiniAddys(\n        ledger = addys._getLedgerAddr(),\n        missionControl = addys._getMissionControlAddr(),\n        legoBook = addys._getLegoBookAddr(),\n        appraiser = addys._getAppraiserAddr(),\n    )\n\n\n# activate\n\n\n@external\ndef pause(_shouldPause: bool):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert _shouldPause != self.isPaused # dev: no change\n    self.isPaused = _shouldPause\n    log LegoPauseModified(isPaused=_shouldPause)\n\n\n# recover funds\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    self._recoverFunds(_recipient, _asset)\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, MAX_RECOVER_ASSETS]):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    for a: address in _assets:\n        self._recoverFunds(_recipient, a)\n\n\n@internal\ndef _recoverFunds(_recipient: address, _asset: address):\n    assert empty(address) not in [_recipient, _asset] # dev: invalid recipient or asset\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    assert balance != 0 # dev: nothing to recover\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log LegoFundsRecovered(asset=_asset, recipient=_recipient, balance=balance)",
            "sha256sum": "bcbae5ce139758ce8a77c03858ec8d438dea0437d5f3a20fed8267f4d2f15b66"
          },
          "contracts/legos/yield/Fluid.vy": {
            "content": "#     __   __ ___ _______ ___     ______       ___     _______ _______ _______ \n#    |  | |  |   |       |   |   |      |     |   |   |       |       |       |\n#    |  |_|  |   |    ___|   |   |  _    |    |   |   |    ___|    ___|   _   |\n#    |       |   |   |___|   |   | | |   |    |   |   |   |___|   | __|  | |  |\n#    |_     _|   |    ___|   |___| |_|   |    |   |___|    ___|   ||  |  |_|  |\n#      |   | |   |   |___|       |       |    |       |   |___|   |_| |       |\n#      |___| |___|_______|_______|______|     |_______|_______|_______|_______|\n#                                                                       \n#     \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n#     \u2551  ** Fluid Lego **                       \u2551\n#     \u2551  Integration with Fluid Protocol.       \u2551\n#     \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n#\n#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nimplements: Lego\nimplements: YieldLego\n\nexports: addys.__interface__\nexports: yld.__interface__\n\ninitializes: addys\ninitializes: yld[addys := addys]\n\nfrom interfaces import LegoPartner as Lego\nfrom interfaces import YieldLego as YieldLego\nfrom interfaces import WalletStructs as ws\n\nimport contracts.modules.Addys as addys\nimport contracts.modules.YieldLegoData as yld\n\nfrom ethereum.ercs import IERC20Detailed\nfrom ethereum.ercs import IERC20\nfrom ethereum.ercs import IERC4626\n\ninterface Appraiser:\n    def getUsdValue(_asset: address, _amount: uint256, _missionControl: address = empty(address), _legoBook: address = empty(address), _ledger: address = empty(address)) -> uint256: view\n    def updatePriceAndGetUsdValue(_asset: address, _amount: uint256, _missionControl: address = empty(address), _legoBook: address = empty(address)) -> uint256: nonpayable\n\ninterface Ledger:\n    def setVaultToken(_vaultToken: address, _legoId: uint256, _underlyingAsset: address, _decimals: uint256, _isRebasing: bool): nonpayable\n    def isRegisteredVaultToken(_vaultToken: address) -> bool: view\n\ninterface FluidLendingResolver:\n    def getAllFTokens() -> DynArray[address, MAX_FTOKENS]: view\n\ninterface Registry:\n    def getRegId(_addr: address) -> uint256: view\n\nevent FluidDeposit:\n    sender: indexed(address)\n    asset: indexed(address)\n    vaultToken: indexed(address)\n    assetAmountDeposited: uint256\n    usdValue: uint256\n    vaultTokenAmountReceived: uint256\n    recipient: address\n\nevent FluidWithdrawal:\n    sender: indexed(address)\n    asset: indexed(address)\n    vaultToken: indexed(address)\n    assetAmountReceived: uint256\n    usdValue: uint256\n    vaultTokenAmountBurned: uint256\n    recipient: address\n\n# fluid\nFLUID_RESOLVER: public(immutable(address))\n\nMAX_FTOKENS: constant(uint256) = 50\nMAX_TOKEN_PATH: constant(uint256) = 5\n\n\n@deploy\ndef __init__(\n    _undyHq: address,\n    _fluidResolver: address,\n):\n    addys.__init__(_undyHq)\n    yld.__init__(False)\n\n    assert _fluidResolver != empty(address) # dev: invalid addrs\n    FLUID_RESOLVER = _fluidResolver\n\n\n@view\n@external\ndef hasCapability(_action: ws.ActionType) -> bool:\n    return _action in (\n        ws.ActionType.EARN_DEPOSIT | \n        ws.ActionType.EARN_WITHDRAW\n    )\n\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    return [FLUID_RESOLVER]\n\n\n@view\n@external\ndef isYieldLego() -> bool:\n    return True\n\n\n@view\n@external\ndef isDexLego() -> bool:\n    return False\n\n\n@view\n@external\ndef isEligibleVaultForTrialFunds(_vaultToken: address, _underlyingAsset: address) -> bool:\n    return yld.vaultToAsset[_vaultToken] == _underlyingAsset\n\n\n@view\n@external\ndef isEligibleForYieldBonus(_asset: address) -> bool:\n    return yld.vaultToAsset[_asset] != empty(address)\n\n\n@view\n@external\ndef isRebasing() -> bool:\n    return self._isRebasing()\n\n\n@view\n@internal\ndef _isRebasing() -> bool:\n    return False\n\n\n#########\n# Yield #\n#########\n\n\n# deposit\n\n\n@external\ndef depositForYield(\n    _asset: address,\n    _amount: uint256,\n    _vaultAddr: address,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, address, uint256, uint256):\n    assert not yld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = yld._getMiniAddys(_miniAddys)\n\n    # verify vault token (register if necessary)\n    vaultToken: address = self._getVaultTokenOnDeposit(_asset, _vaultAddr, miniAddys.ledger, miniAddys.legoBook)\n\n    # pre balances\n    preLegoBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n\n    # transfer deposit asset to this contract\n    depositAmount: uint256 = min(_amount, staticcall IERC20(_asset).balanceOf(msg.sender))\n    assert depositAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_asset).transferFrom(msg.sender, self, depositAmount, default_return_value=True) # dev: transfer failed\n\n    # deposit assets into lego partner\n    vaultTokenAmountReceived: uint256 = extcall IERC4626(vaultToken).deposit(depositAmount, _recipient)\n    assert vaultTokenAmountReceived != 0 # dev: no vault tokens received\n\n    # refund if full deposit didn't get through\n    currentLegoBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    refundAssetAmount: uint256 = 0\n    if currentLegoBalance > preLegoBalance:\n        refundAssetAmount = currentLegoBalance - preLegoBalance\n        assert extcall IERC20(_asset).transfer(msg.sender, refundAssetAmount, default_return_value=True) # dev: transfer failed\n        depositAmount -= refundAssetAmount\n\n    usdValue: uint256 = extcall Appraiser(miniAddys.appraiser).updatePriceAndGetUsdValue(_asset, depositAmount, miniAddys.missionControl, miniAddys.legoBook)\n    log FluidDeposit(\n        sender = msg.sender,\n        asset = _asset,\n        vaultToken = vaultToken,\n        assetAmountDeposited = depositAmount,\n        usdValue = usdValue,\n        vaultTokenAmountReceived = vaultTokenAmountReceived,\n        recipient = _recipient,\n    )\n    return depositAmount, vaultToken, vaultTokenAmountReceived, usdValue\n\n\n# asset verification\n\n\n@internal\ndef _getVaultTokenOnDeposit(_asset: address, _vaultAddr: address, _ledger: address, _legoBook: address) -> address:\n    asset: address = yld.vaultToAsset[_vaultAddr]\n    isRegistered: bool = True\n\n    # not yet registered, call fluid directly to get asset\n    if asset == empty(address) and self._isValidFToken(_vaultAddr):\n        asset = staticcall IERC4626(_vaultAddr).asset()\n        isRegistered = False\n\n    assert asset != empty(address) # dev: invalid asset\n    assert asset == _asset # dev: asset mismatch\n\n    # register if necessary\n    if not isRegistered:\n        self._registerAsset(asset, _vaultAddr)\n        self._updateLedgerVaultToken(asset, _vaultAddr, _ledger, _legoBook)\n\n    return _vaultAddr\n\n\n# withdraw\n\n\n@external\ndef withdrawFromYield(\n    _vaultToken: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, address, uint256, uint256):\n    assert not yld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = yld._getMiniAddys(_miniAddys)\n\n    # verify asset (register if necessary)\n    asset: address = self._getAssetOnWithdraw(_vaultToken, miniAddys.ledger, miniAddys.legoBook)\n\n    # pre balances\n    preLegoVaultBalance: uint256 = staticcall IERC20(_vaultToken).balanceOf(self)\n\n    # transfer vaults tokens to this contract\n    vaultTokenAmount: uint256 = min(_amount, staticcall IERC20(_vaultToken).balanceOf(msg.sender))\n    assert vaultTokenAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_vaultToken).transferFrom(msg.sender, self, vaultTokenAmount, default_return_value=True) # dev: transfer failed\n\n    # withdraw assets from lego partner\n    assetAmountReceived: uint256 = extcall IERC4626(_vaultToken).redeem(vaultTokenAmount, _recipient, self)\n    assert assetAmountReceived != 0 # dev: no asset amount received\n\n    # refund if full withdrawal didn't happen\n    currentLegoVaultBalance: uint256 = staticcall IERC20(_vaultToken).balanceOf(self)\n    refundVaultTokenAmount: uint256 = 0\n    if currentLegoVaultBalance > preLegoVaultBalance:\n        refundVaultTokenAmount = currentLegoVaultBalance - preLegoVaultBalance\n        assert extcall IERC20(_vaultToken).transfer(msg.sender, refundVaultTokenAmount, default_return_value=True) # dev: transfer failed\n        vaultTokenAmount -= refundVaultTokenAmount\n\n    usdValue: uint256 = extcall Appraiser(miniAddys.appraiser).updatePriceAndGetUsdValue(asset, assetAmountReceived, miniAddys.missionControl, miniAddys.legoBook)\n    log FluidWithdrawal(\n        sender = msg.sender,\n        asset = asset,\n        vaultToken = _vaultToken,\n        assetAmountReceived = assetAmountReceived,\n        usdValue = usdValue,\n        vaultTokenAmountBurned = vaultTokenAmount,\n        recipient = _recipient,\n    )\n    return vaultTokenAmount, asset, assetAmountReceived, usdValue\n\n\n# vault token verification\n\n\n@internal\ndef _getAssetOnWithdraw(_vaultToken: address, _ledger: address, _legoBook: address) -> address:\n    asset: address = yld.vaultToAsset[_vaultToken]\n    isRegistered: bool = True\n\n    # not yet registered, call fluid directly to get asset\n    if asset == empty(address) and self._isValidFToken(_vaultToken):\n        asset = staticcall IERC4626(_vaultToken).asset()\n        isRegistered = False\n\n    assert asset != empty(address) # dev: invalid asset\n\n    # register if necessary\n    if not isRegistered:\n        self._registerAsset(asset, _vaultToken)\n        self._updateLedgerVaultToken(asset, _vaultToken, _ledger, _legoBook)\n\n    return asset\n\n\n#############\n# Utilities #\n#############\n\n\n\n# underlying asset\n\n\n@view\n@external\ndef isVaultToken(_vaultToken: address) -> bool:\n    return self._isVaultToken(_vaultToken)\n\n\n@view\n@internal\ndef _isVaultToken(_vaultToken: address) -> bool:\n    if yld.vaultToAsset[_vaultToken] != empty(address):\n        return True\n    return self._isValidFToken(_vaultToken)\n\n\n@view\n@internal\ndef _isValidFToken(_fToken: address) -> bool:\n    fTokens: DynArray[address, MAX_FTOKENS] = staticcall FluidLendingResolver(FLUID_RESOLVER).getAllFTokens()\n    return _fToken in fTokens\n\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    return self._getUnderlyingAsset(_vaultToken)\n\n\n@view\n@internal\ndef _getUnderlyingAsset(_vaultToken: address) -> address:\n    asset: address = yld.vaultToAsset[_vaultToken]\n    if asset == empty(address) and self._isValidFToken(_vaultToken):\n        asset = staticcall IERC4626(_vaultToken).asset()\n    return asset\n\n\n# underlying amount\n\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    if not self._isVaultToken(_vaultToken) or _vaultTokenAmount == 0:\n        return 0 # invalid vault token or amount\n    return self._getUnderlyingAmount(_vaultToken, _vaultTokenAmount)\n\n\n@view\n@internal\ndef _getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    return staticcall IERC4626(_vaultToken).convertToAssets(_vaultTokenAmount)\n\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    if empty(address) in [_asset, _vaultToken] or _assetAmount == 0:\n        return 0 # bad inputs\n    if self._getUnderlyingAsset(_vaultToken) != _asset:\n        return 0 # invalid vault token or asset\n    return staticcall IERC4626(_vaultToken).convertToShares(_assetAmount)\n\n\n# usd value\n\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> uint256:\n    return self._getUsdValueOfVaultToken(_vaultToken, _vaultTokenAmount, _appraiser)\n\n\n@view\n@internal\ndef _getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address) -> uint256:\n    asset: address = empty(address)\n    underlyingAmount: uint256 = 0\n    usdValue: uint256 = 0\n    asset, underlyingAmount, usdValue = self._getUnderlyingData(_vaultToken, _vaultTokenAmount, _appraiser)\n    return usdValue\n\n\n# all underlying data together\n\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> (address, uint256, uint256):\n    return self._getUnderlyingData(_vaultToken, _vaultTokenAmount, _appraiser)\n\n\n@view\n@internal\ndef _getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address) -> (address, uint256, uint256):\n    if _vaultTokenAmount == 0 or _vaultToken == empty(address):\n        return empty(address), 0, 0 # bad inputs\n    asset: address = self._getUnderlyingAsset(_vaultToken)\n    if asset == empty(address):\n        return empty(address), 0, 0 # invalid vault token\n    underlyingAmount: uint256 = self._getUnderlyingAmount(_vaultToken, _vaultTokenAmount)\n    usdValue: uint256 = self._getUsdValue(asset, underlyingAmount, _appraiser)\n    return asset, underlyingAmount, usdValue\n\n\n@view\n@internal\ndef _getUsdValue(_asset: address, _amount: uint256, _appraiser: address) -> uint256:\n    appraiser: address = _appraiser\n    if _appraiser == empty(address):\n        appraiser = addys._getAppraiserAddr()\n    return staticcall Appraiser(appraiser).getUsdValue(_asset, _amount)\n\n\n# other\n\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    if not self._isVaultToken(_vaultToken):\n        return 0 # invalid vault token\n    return staticcall IERC4626(_vaultToken).totalAssets()\n\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    return 0 # TODO\n\n\n# price per share\n\n\n@view\n@external\ndef getPricePerShare(_asset: address, _decimals: uint256) -> uint256:\n    return staticcall IERC4626(_asset).convertToAssets(10 ** _decimals)\n\n\n################\n# Registration #\n################\n\n\n@external\ndef addAssetOpportunity(_asset: address, _vaultAddr: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert self._isValidAssetOpportunity(_asset, _vaultAddr) # dev: invalid asset or vault\n    assert not yld._isAssetOpportunity(_asset, _vaultAddr) # dev: already registered\n    self._registerAsset(_asset, _vaultAddr)\n\n\n@internal\ndef _registerAsset(_asset: address, _vaultAddr: address):\n    assert extcall IERC20(_asset).approve(_vaultAddr, max_value(uint256), default_return_value=True) # dev: max approval failed\n    yld._addAssetOpportunity(_asset, _vaultAddr)\n\n\n@external\ndef removeAssetOpportunity(_asset: address, _vaultAddr: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert extcall IERC20(_asset).approve(_vaultAddr, 0, default_return_value=True) # dev: max approval failed\n    yld._removeAssetOpportunity(_asset, _vaultAddr)\n\n\n# validation\n\n\n@view\n@internal\ndef isValidAssetOpportunity(_asset: address, _vaultAddr: address) -> bool:\n    return self._isValidAssetOpportunity(_asset, _vaultAddr)\n\n\n@view\n@internal\ndef _isValidAssetOpportunity(_asset: address, _vaultAddr: address) -> bool:\n    return self._isValidFToken(_vaultAddr) and staticcall IERC4626(_vaultAddr).asset() == _asset\n\n\n# update ledger registration\n\n\n@internal\ndef _updateLedgerVaultToken(\n    _underlyingAsset: address,\n    _vaultToken: address,\n    _ledger: address,\n    _legoBook: address,\n):\n    if empty(address) in [_underlyingAsset, _vaultToken]:\n        return\n\n    if not staticcall Ledger(_ledger).isRegisteredVaultToken(_vaultToken):\n        legoId: uint256 = staticcall Registry(_legoBook).getRegId(self)\n        decimals: uint256 = convert(staticcall IERC20Detailed(_vaultToken).decimals(), uint256)\n        extcall Ledger(_ledger).setVaultToken(_vaultToken, legoId, _underlyingAsset, decimals, self._isRebasing())\n\n\n#########\n# Other #\n#########\n\n\n@external\ndef swapTokens(\n    _amountIn: uint256,\n    _minAmountOut: uint256,\n    _tokenPath: DynArray[address, MAX_TOKEN_PATH],\n    _poolPath: DynArray[address, MAX_TOKEN_PATH - 1],\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256):\n    return 0, 0, 0\n\n\n@external\ndef mintOrRedeemAsset(\n    _tokenIn: address,\n    _tokenOut: address,\n    _tokenInAmount: uint256,\n    _minAmountOut: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, bool, uint256):\n    return 0, 0, False, 0\n\n\n@external\ndef confirmMintOrRedeemAsset(\n    _tokenIn: address,\n    _tokenOut: address,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef addCollateral(\n    _asset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef removeCollateral(\n    _asset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef borrow(\n    _borrowAsset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef repayDebt(\n    _paymentAsset: address,\n    _paymentAmount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef claimRewards(\n    _user: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _extraData: bytes32,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef addLiquidity(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _amountA: uint256,\n    _amountB: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _minLpAmount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (address, uint256, uint256, uint256, uint256):\n    return empty(address), 0, 0, 0, 0\n\n\n@external\ndef removeLiquidity(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpToken: address,\n    _lpAmount: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, uint256):\n    return 0, 0, 0, 0\n\n\n@external\ndef addLiquidityConcentrated(\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _tickLower: int24,\n    _tickUpper: int24,\n    _amountA: uint256,\n    _amountB: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, uint256, uint256):\n    return 0, 0, 0, 0, 0\n\n\n@external\ndef removeLiquidityConcentrated(\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _liqToRemove: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, bool, uint256):\n    return 0, 0, 0, False, 0\n\n\n@view\n@external\ndef getAccessForLego(_user: address, _action: ws.ActionType) -> (address, String[64], uint256):\n    return empty(address), empty(String[64]), 0\n\n\n@view\n@external\ndef getPrice(_asset: address, _decimals: uint256) -> uint256:\n    return 0\n",
            "sha256sum": "6c856f61d52af1ddeba8a3410da806db0e1dd4c5e3362ce337f159d94b7916bf"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/legos/yield/Fluid.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.3+commit.bff19ea2",
        "integrity": "3a2f277e5076fe36c33e88a67f909dd00786dcfa991433c0248fb455746b216c"
      },
      "args": "00000000000000000000000044cf3c4f000dfd76a35d03298049d37be688d6f90000000000000000000000003af6fbec4a2fe517f56e402c65e3f4c3e18c1d86",
      "file": "contracts/legos/yield/Fluid.vy"
    },
    "Moonwell": {
      "address": "0x9CdE6b17b88432734f64E760B5Dfbba372b4975F",
      "abi": [
        {
          "name": "MoonwellDeposit",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountDeposited",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultTokenAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "MoonwellWithdrawal",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultTokenAmountBurned",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LegoPauseModified",
          "inputs": [
            {
              "name": "isPaused",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LegoFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "balance",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetOpportunityAdded",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultAddr",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetOpportunityRemoved",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultAddr",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddys",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "undyToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "hatchery",
                  "type": "address"
                },
                {
                  "name": "lootDistributor",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                },
                {
                  "name": "walletBackpack",
                  "type": "address"
                },
                {
                  "name": "billing",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUndyHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isLegoAsset",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssetOpportunities",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isAssetOpportunity",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getNumLegoAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pause",
          "inputs": [
            {
              "name": "_shouldPause",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFundsMany",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_assets",
              "type": "address[]"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isPaused",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assetOpportunities",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAssetOpportunity",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssetOpportunities",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "vaultToAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assets",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "payable",
          "type": "fallback"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasCapability",
          "inputs": [
            {
              "name": "_action",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRegistries",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isYieldLego",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isDexLego",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isEligibleVaultForTrialFunds",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_underlyingAsset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isEligibleForYieldBonus",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isRebasing",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositForYield",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositForYield",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawFromYield",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawFromYield",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasClaimableRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAsset",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAmount",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getVaultTokenAmount",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_assetAmount",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValueOfVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValueOfVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            },
            {
              "name": "_appraiser",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingData",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingData",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            },
            {
              "name": "_appraiser",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalAssets",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalBorrows",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPricePerShare",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_decimals",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addAssetOpportunity",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeAssetOpportunity",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_tokenPath",
              "type": "address[]"
            },
            {
              "name": "_poolPath",
              "type": "address[]"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_tokenPath",
              "type": "address[]"
            },
            {
              "name": "_poolPath",
              "type": "address[]"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_tokenInAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_tokenInAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmMintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmMintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_borrowAsset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_borrowAsset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_paymentAsset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_paymentAsset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAccessForLego",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_action",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "string"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPrice",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_decimals",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MOONWELL_COMPTROLLER",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "WETH",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_undyHq",
              "type": "address"
            },
            {
              "name": "_moonwellComptroller",
              "type": "address"
            },
            {
              "name": "_weth",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "interfaces/WalletStructs.vyi": {
            "content": "# @version 0.4.3\n\nflag ActionType:\n    TRANSFER\n    EARN_DEPOSIT\n    EARN_WITHDRAW\n    EARN_REBALANCE\n    SWAP\n    MINT_REDEEM\n    CONFIRM_MINT_REDEEM\n    ADD_COLLATERAL\n    REMOVE_COLLATERAL\n    BORROW\n    REPAY_DEBT\n    REWARDS\n    ETH_TO_WETH\n    WETH_TO_ETH\n    ADD_LIQ\n    REMOVE_LIQ\n    ADD_LIQ_CONC\n    REMOVE_LIQ_CONC\n    PAY_CHEQUE\n\nstruct WalletAssetData:\n    assetBalance: uint256\n    usdValue: uint256\n    isYieldAsset: bool\n    lastPricePerShare: uint256\n\nstruct ActionData:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    billing: address\n    wallet: address\n    walletConfig: address\n    walletOwner: address\n    inEjectMode: bool\n    isFrozen: bool\n    lastTotalUsdValue: uint256\n    signer: address\n    isManager: bool\n    legoId: uint256\n    legoAddr: address\n    eth: address\n    weth: address\n\nstruct MiniAddys:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    appraiser: address",
            "sha256sum": "9a4b4f59b3a62043e51b425a665064aae419a3c0bd0514b6b29a9441ae364bb9"
          },
          "interfaces/LegoPartner.vyi": {
            "content": "# @version 0.4.3\n\nfrom interfaces import WalletStructs as ws\n\nMAX_TOKEN_PATH: constant(uint256) = 5\nMAX_RECOVER_ASSETS: constant(uint256) = 20\n\n@external\ndef addLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _tickLower: int24, _tickUpper: int24, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef addLiquidity(_pool: address, _tokenA: address, _tokenB: address, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _minLpAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (address, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef removeLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _liqToRemove: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef removeLiquidity(_pool: address, _tokenA: address, _tokenB: address, _lpToken: address, _lpAmount: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef mintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _tokenInAmount: uint256, _minAmountOut: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef swapTokens(_amountIn: uint256, _minAmountOut: uint256, _tokenPath: DynArray[address, MAX_TOKEN_PATH], _poolPath: DynArray[address, MAX_TOKEN_PATH - 1], _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256):\n    ...\n\n@external\ndef depositForYield(_asset: address, _amount: uint256, _vaultAddr: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef withdrawFromYield(_vaultToken: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef confirmMintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef borrow(_borrowAsset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef repayDebt(_paymentAsset: address, _paymentAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef claimRewards(_user: address, _rewardToken: address, _rewardAmount: uint256, _extraData: bytes32, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef removeCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef addCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@view\n@external\ndef getAccessForLego(_user: address, _action: ws.ActionType) -> (address, String[64], uint256):\n    ...\n\n@view\n@external\ndef hasCapability(_action: ws.ActionType) -> bool:\n    ...\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    ...\n\n@view\n@external\ndef isYieldLego() -> bool:\n    ...\n\n@view\n@external\ndef isDexLego() -> bool:\n    ...\n\n@view\n@external\ndef getPricePerShare(_asset: address, _decimals: uint256) -> uint256:\n    ...\n\n@view\n@external\ndef getPrice(_asset: address, _decimals: uint256) -> uint256:\n    ...\n\n\n# common\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "2513e379aa74d0a8120114a5078a4c1a0900165a1c3f24419bb811d173b56453"
          },
          "interfaces/YieldLego.vyi": {
            "content": "# @version 0.4.3\n\n@view\n@external\ndef isRebasing() -> bool:\n    ...\n\n\n@view\n@external\ndef isEligibleForYieldBonus(_asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef isEligibleVaultForTrialFunds(_vaultToken: address, _underlyingAsset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    ...\n\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    ...\n\n\n@view\n@external\ndef isVaultToken(_vaultToken: address) -> bool:\n    ...\n\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> uint256:\n    ...\n\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> (address, uint256, uint256):\n    ...\n\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    ...\n\n\n@external\ndef addAssetOpportunity(_asset: address, _vaultAddr: address):\n    ...\n\n\n@external\ndef removeAssetOpportunity(_asset: address, _vaultAddr: address):\n    ...\n\n\n# YieldLegoData.vy module\n\n\n@view\n@external\ndef assetOpportunities(_asset: address, _index: uint256) -> address:\n    ...\n\n\n@view\n@external\ndef indexOfAssetOpportunity(_asset: address, _vaultAddr: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef numAssetOpportunities(_asset: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef vaultToAsset(_vaultAddr: address) -> address:\n    ...\n\n\n@view\n@external\ndef assets(_index: uint256) -> address:\n    ...\n\n\n@view\n@external\ndef indexOfAsset(_asset: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef numAssets() -> uint256:\n    ...\n\n\n@view\n@external\ndef isLegoAsset(_asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, 40]:\n    ...\n\n\n@view\n@external\ndef getAssets() -> DynArray[address, 20]:\n    ...\n\n\n@view\n@external\ndef isAssetOpportunity(_asset: address, _vaultAddr: address) -> bool:\n    ...\n\n\n@view\n@external\ndef getNumLegoAssets() -> uint256:\n    ...\n",
            "sha256sum": "3337ce5f78b0df6f86d1144b07505512bb1044304f67add97be6c3816b3c0b42"
          },
          "contracts/modules/Addys.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\ninterface UndyHq:\n    def isValidAddr(_addr: address) -> bool: view\n    def getAddr(_regId: uint256) -> address: view\n    def undyToken() -> address: view\n\ninterface Switchboard:\n    def isSwitchboardAddr(_addr: address) -> bool: view\n\ninterface LegoBook:\n    def isLegoAddr(_addr: address) -> bool: view\n\nstruct Addys:\n    hq: address\n    undyToken: address\n    ledger: address\n    missionControl: address\n    legoBook: address\n    switchboard: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    walletBackpack: address\n    billing: address\n\n# hq\nUNDY_HQ_FOR_ADDYS: immutable(address)\n\n# core addys\nLEDGER_ID: constant(uint256) = 1\nMISSION_CONTROL_ID: constant(uint256) = 2\nLEGO_BOOK_ID: constant(uint256) = 3\nSWITCHBOARD_ID: constant(uint256) = 4\nHATCHERY_ID: constant(uint256) = 5\nLOOT_DISTRIBUTOR_ID: constant(uint256) = 6\nAPPRAISER_ID: constant(uint256) = 7\nWALLET_BACKPACK_ID: constant(uint256) = 8\nBILLING_ID: constant(uint256) = 9\n\n\n@deploy\ndef __init__(_undyHq: address):\n    assert _undyHq != empty(address) # dev: invalid undy hq\n    UNDY_HQ_FOR_ADDYS = _undyHq\n\n\n########\n# Core #\n########\n\n\n@view\n@external\ndef getAddys() -> Addys:\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _getAddys(_addys: Addys = empty(Addys)) -> Addys:\n    if _addys.hq != empty(address):\n        return _addys\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _generateAddys() -> Addys:\n    hq: address = UNDY_HQ_FOR_ADDYS\n    return Addys(\n        hq = hq,\n        undyToken = staticcall UndyHq(hq).undyToken(),\n        ledger = staticcall UndyHq(hq).getAddr(LEDGER_ID),\n        missionControl = staticcall UndyHq(hq).getAddr(MISSION_CONTROL_ID),\n        legoBook = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID),\n        switchboard = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID),\n        hatchery = staticcall UndyHq(hq).getAddr(HATCHERY_ID),\n        lootDistributor = staticcall UndyHq(hq).getAddr(LOOT_DISTRIBUTOR_ID),\n        appraiser = staticcall UndyHq(hq).getAddr(APPRAISER_ID),\n        walletBackpack = staticcall UndyHq(hq).getAddr(WALLET_BACKPACK_ID),\n        billing = staticcall UndyHq(hq).getAddr(BILLING_ID),\n    )\n\n\n##########\n# Tokens #\n##########\n\n\n@view\n@internal\ndef _getUndyToken() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).undyToken()\n\n\n###########\n# Helpers #\n###########\n\n\n# undy hq\n\n\n@view\n@external\ndef getUndyHq() -> address:\n    return self._getUndyHq()\n\n\n@view\n@internal\ndef _getUndyHq() -> address:\n    return UNDY_HQ_FOR_ADDYS\n\n\n# utils\n\n\n@view\n@internal\ndef _isValidUndyAddr(_addr: address, _hq: address = empty(address)) -> bool:\n    hq: address = _hq\n    if _hq == empty(address):\n        hq = UNDY_HQ_FOR_ADDYS\n    \n    # core departments\n    if staticcall UndyHq(hq).isValidAddr(_addr):\n        return True\n\n    # lego book\n    legoBook: address = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID)\n    if legoBook != empty(address) and staticcall LegoBook(legoBook).isLegoAddr(_addr):\n        return True\n\n    # switchboard config\n    switchboard: address = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID)\n    if switchboard != empty(address) and staticcall Switchboard(switchboard).isSwitchboardAddr(_addr):\n        return True\n\n    return False\n\n\n@view\n@internal\ndef _isSwitchboardAddr(_addr: address) -> bool:\n    switchboard: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n    if switchboard == empty(address):\n        return False\n    return staticcall Switchboard(switchboard).isSwitchboardAddr(_addr)\n\n\n@view\n@internal\ndef _isLegoBookAddr(_addr: address) -> bool:\n    legoBook: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n    if legoBook == empty(address):\n        return False\n    return staticcall LegoBook(legoBook).isLegoAddr(_addr)\n\n\n###############\n# Departments #\n###############\n\n\n# ledger\n\n\n@view\n@internal\ndef _getLedgerId() -> uint256:\n    return LEDGER_ID\n\n\n@view\n@internal\ndef _getLedgerAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEDGER_ID)\n\n\n# mission control\n\n\n@view\n@internal\ndef _getMissionControlId() -> uint256:\n    return MISSION_CONTROL_ID\n\n\n@view\n@internal\ndef _getMissionControlAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(MISSION_CONTROL_ID)\n\n\n# lego book\n\n\n@view\n@internal\ndef _getLegoBookId() -> uint256:\n    return LEGO_BOOK_ID\n\n\n@view\n@internal\ndef _getLegoBookAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n\n\n# switchboard\n\n\n@view\n@internal\ndef _getSwitchboardId() -> uint256:\n    return SWITCHBOARD_ID\n\n\n@view\n@internal\ndef _getSwitchboardAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n\n\n# hatchery\n\n\n@view\n@internal\ndef _getHatcheryId() -> uint256:\n    return HATCHERY_ID\n\n\n@view\n@internal\ndef _getHatcheryAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(HATCHERY_ID)\n\n\n# loot distributor\n\n\n@view\n@internal\ndef _getLootDistributorId() -> uint256:\n    return LOOT_DISTRIBUTOR_ID\n\n\n@view\n@internal\ndef _getLootDistributorAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LOOT_DISTRIBUTOR_ID)\n\n\n# appraiser\n\n\n@view\n@internal\ndef _getAppraiserId() -> uint256:\n    return APPRAISER_ID\n\n\n@view\n@internal\ndef _getAppraiserAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(APPRAISER_ID)\n\n\n# wallet backpack\n\n\n@view\n@internal\ndef _getWalletBackpackId() -> uint256:\n    return WALLET_BACKPACK_ID\n\n\n@view\n@internal\ndef _getWalletBackpackAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(WALLET_BACKPACK_ID)\n\n\n# billing\n\n\n@view\n@internal\ndef _getBillingId() -> uint256:\n    return BILLING_ID\n\n\n@view\n@internal\ndef _getBillingAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(BILLING_ID)",
            "sha256sum": "78b58f0b2acb2eaafa4d21adf9135a1cd0e1d53897f7a1fa70a83a04a7738ad3"
          },
          "contracts/modules/YieldLegoData.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nuses: addys\n\nimport contracts.modules.Addys as addys\n\nfrom interfaces import WalletStructs as ws\nfrom ethereum.ercs import IERC20\n\nevent AssetOpportunityAdded:\n    asset: indexed(address)\n    vaultAddr: indexed(address)\n\nevent AssetOpportunityRemoved:\n    asset: indexed(address)\n    vaultAddr: indexed(address)\n\nevent LegoPauseModified:\n    isPaused: bool\n\nevent LegoFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    balance: uint256\n\n# config\nisPaused: public(bool)\n\n# asset opportunities\nassetOpportunities: public(HashMap[address, HashMap[uint256, address]]) # asset -> index -> vault addr\nindexOfAssetOpportunity: public(HashMap[address, HashMap[address, uint256]]) # asset -> vault addr -> index\nnumAssetOpportunities: public(HashMap[address, uint256]) # asset -> number of opportunities\n\n# mapping\nvaultToAsset: public(HashMap[address, address]) # vault addr -> underlying asset\n\n# lego assets (iterable)\nassets: public(HashMap[uint256, address]) # index -> asset\nindexOfAsset: public(HashMap[address, uint256]) # asset -> index\nnumAssets: public(uint256) # num assets\n\nMAX_VAULTS: constant(uint256) = 40\nMAX_ASSETS: constant(uint256) = 20\nMAX_RECOVER_ASSETS: constant(uint256) = 20\n\n\n@deploy\ndef __init__(_shouldPause: bool):\n    self.isPaused = _shouldPause\n    self.numAssets = 1 # not using 0 index\n\n\n#########\n# Views #\n#########\n\n\n# is lego asset\n\n\n@view\n@external\ndef isLegoAsset(_asset: address) -> bool:\n    return self._isLegoAsset(_asset)\n\n\n@view\n@internal\ndef _isLegoAsset(_asset: address) -> bool:\n    return self.indexOfAsset[_asset] != 0\n\n\n# vault opportunities\n\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, MAX_VAULTS]:\n    numOpportunities: uint256 = self.numAssetOpportunities[_asset]\n    if numOpportunities == 0:\n        return []\n    opportunities: DynArray[address, MAX_VAULTS] = []\n    for i: uint256 in range(1, numOpportunities, bound=MAX_VAULTS):\n        opportunities.append(self.assetOpportunities[_asset][i])\n    return opportunities\n\n\n# all assets registered\n\n\n@view\n@external\ndef getAssets() -> DynArray[address, MAX_ASSETS]:\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return []\n    assets: DynArray[address, MAX_ASSETS] = []\n    for i: uint256 in range(1, numAssets, bound=MAX_ASSETS):\n        assets.append(self.assets[i])\n    return assets\n\n\n################\n# Registration #\n################\n\n\n@view\n@external\ndef isAssetOpportunity(_asset: address, _vaultAddr: address) -> bool:\n    return self._isAssetOpportunity(_asset, _vaultAddr)\n\n\n@view\n@internal\ndef _isAssetOpportunity(_asset: address, _vaultAddr: address) -> bool:\n    return self.indexOfAssetOpportunity[_asset][_vaultAddr] != 0\n\n\n# add asset opportunity\n\n\n@internal\ndef _addAssetOpportunity(_asset: address, _vaultAddr: address):\n    if self.indexOfAssetOpportunity[_asset][_vaultAddr] != 0:\n        return\n    if empty(address) in [_asset, _vaultAddr]:\n        return\n\n    # add asset opportunity\n    aid: uint256 = self.numAssetOpportunities[_asset]\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.assetOpportunities[_asset][aid] = _vaultAddr\n    self.indexOfAssetOpportunity[_asset][_vaultAddr] = aid\n    self.numAssetOpportunities[_asset] = aid + 1\n\n    # add mapping\n    self.vaultToAsset[_vaultAddr] = _asset\n\n    # add asset\n    self._addAsset(_asset)\n\n    log AssetOpportunityAdded(asset=_asset, vaultAddr=_vaultAddr)\n\n\n# remove asset opportunity\n\n\n@internal\ndef _removeAssetOpportunity(_asset: address, _vaultAddr: address):\n    numOpportunities: uint256 = self.numAssetOpportunities[_asset]\n    if numOpportunities == 0:\n        return\n\n    targetIndex: uint256 = self.indexOfAssetOpportunity[_asset][_vaultAddr]\n    if targetIndex == 0:\n        return\n\n    # update data\n    lastIndex: uint256 = numOpportunities - 1\n    self.numAssetOpportunities[_asset] = lastIndex\n    self.indexOfAssetOpportunity[_asset][_vaultAddr] = 0\n\n    self.vaultToAsset[_vaultAddr] = empty(address)\n\n    # shift to replace the removed one\n    if targetIndex != lastIndex:\n        lastVaultAddr: address = self.assetOpportunities[_asset][lastIndex]\n        self.assetOpportunities[_asset][targetIndex] = lastVaultAddr\n        self.indexOfAssetOpportunity[_asset][lastVaultAddr] = targetIndex\n\n    # remove asset\n    if lastIndex <= 1:\n        self._removeAsset(_asset)\n\n    log AssetOpportunityRemoved(asset=_asset, vaultAddr=_vaultAddr)\n\n\n# add asset\n\n\n@internal\ndef _addAsset(_asset: address):\n    if self.indexOfAsset[_asset] != 0:\n        return\n\n    aid: uint256 = self.numAssets\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.assets[aid] = _asset\n    self.indexOfAsset[_asset] = aid\n    self.numAssets = aid + 1\n\n\n# remove asset\n\n\n@internal\ndef _removeAsset(_asset: address):\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return\n\n    targetIndex: uint256 = self.indexOfAsset[_asset]\n    if targetIndex == 0:\n        return\n\n    # update data\n    lastIndex: uint256 = numAssets - 1\n    self.numAssets = lastIndex\n    self.indexOfAsset[_asset] = 0\n\n    # shift to replace the removed one\n    if targetIndex != lastIndex:\n        lastAsset: address = self.assets[lastIndex]\n        self.assets[targetIndex] = lastAsset\n        self.indexOfAsset[lastAsset] = targetIndex\n\n\n# num lego assets (true number, use `numAssets` for iteration)\n\n\n@view\n@external\ndef getNumLegoAssets() -> uint256:\n    return self._getNumLegoAssets()\n\n\n@view\n@internal\ndef _getNumLegoAssets() -> uint256:\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return 0\n    return numAssets - 1\n\n\n###########\n# General #\n###########\n\n\n# fill mini addys\n\n\n@view\n@internal\ndef _getMiniAddys(_miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> ws.MiniAddys:\n    if _miniAddys.ledger != empty(address):\n        return _miniAddys\n    return ws.MiniAddys(\n        ledger = addys._getLedgerAddr(),\n        missionControl = addys._getMissionControlAddr(),\n        legoBook = addys._getLegoBookAddr(),\n        appraiser = addys._getAppraiserAddr(),\n    )\n\n\n# activate\n\n\n@external\ndef pause(_shouldPause: bool):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert _shouldPause != self.isPaused # dev: no change\n    self.isPaused = _shouldPause\n    log LegoPauseModified(isPaused=_shouldPause)\n\n\n# recover funds\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    self._recoverFunds(_recipient, _asset)\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, MAX_RECOVER_ASSETS]):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    for a: address in _assets:\n        self._recoverFunds(_recipient, a)\n\n\n@internal\ndef _recoverFunds(_recipient: address, _asset: address):\n    assert empty(address) not in [_recipient, _asset] # dev: invalid recipient or asset\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    assert balance != 0 # dev: nothing to recover\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log LegoFundsRecovered(asset=_asset, recipient=_recipient, balance=balance)",
            "sha256sum": "bcbae5ce139758ce8a77c03858ec8d438dea0437d5f3a20fed8267f4d2f15b66"
          },
          "contracts/legos/yield/Moonwell.vy": {
            "content": "#     __   __ ___ _______ ___     ______       ___     _______ _______ _______ \n#    |  | |  |   |       |   |   |      |     |   |   |       |       |       |\n#    |  |_|  |   |    ___|   |   |  _    |    |   |   |    ___|    ___|   _   |\n#    |       |   |   |___|   |   | | |   |    |   |   |   |___|   | __|  | |  |\n#    |_     _|   |    ___|   |___| |_|   |    |   |___|    ___|   ||  |  |_|  |\n#      |   | |   |   |___|       |       |    |       |   |___|   |_| |       |\n#      |___| |___|_______|_______|______|     |_______|_______|_______|_______|\n#                                                                       \n#     \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n#     \u2551  ** Moonwell Lego **                    \u2551\n#     \u2551  Integration with Moonwell Protocol.    \u2551\n#     \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n#\n#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nimplements: Lego\nimplements: YieldLego\n\nexports: addys.__interface__\nexports: yld.__interface__\n\ninitializes: addys\ninitializes: yld[addys := addys]\n\nfrom interfaces import LegoPartner as Lego\nfrom interfaces import YieldLego as YieldLego\nfrom interfaces import WalletStructs as ws\n\nimport contracts.modules.Addys as addys\nimport contracts.modules.YieldLegoData as yld\n\nfrom ethereum.ercs import IERC20Detailed\nfrom ethereum.ercs import IERC20\n\ninterface CompoundV2:\n    def redeem(_ctokenAmount: uint256) -> uint256: nonpayable\n    def mint(_amount: uint256) -> uint256: nonpayable\n    def exchangeRateStored() -> uint256: view\n    def totalBorrows() -> uint256: view\n    def totalSupply() -> uint256: view\n    def underlying() -> address: view\n\ninterface MoonwellComptroller:\n    def getAllMarkets() -> DynArray[address, MAX_MARKETS]: view\n    def claimReward(_holder: address): nonpayable\n    def rewardDistributor() -> address: view\n\ninterface Appraiser:\n    def getUsdValue(_asset: address, _amount: uint256, _missionControl: address = empty(address), _legoBook: address = empty(address), _ledger: address = empty(address)) -> uint256: view\n    def updatePriceAndGetUsdValue(_asset: address, _amount: uint256, _missionControl: address = empty(address), _legoBook: address = empty(address)) -> uint256: nonpayable\n\ninterface Ledger:\n    def setVaultToken(_vaultToken: address, _legoId: uint256, _underlyingAsset: address, _decimals: uint256, _isRebasing: bool): nonpayable\n    def isRegisteredVaultToken(_vaultToken: address) -> bool: view\n\ninterface MoonwellRewardDistributor:\n    def getOutstandingRewardsForUser(_user: address) -> DynArray[RewardWithMToken, MAX_MARKETS]: view\n\ninterface Registry:\n    def getRegId(_addr: address) -> uint256: view\n\ninterface WethContract:\n    def deposit(): payable\n\nstruct RewardWithMToken:\n    mToken: address\n    rewards: DynArray[RewardInfo, MAX_ASSETS]\n\nstruct RewardInfo:\n    emissionToken: address\n    totalAmount: uint256\n    supplySide: uint256\n    borrowSide: uint256\n\nevent MoonwellDeposit:\n    sender: indexed(address)\n    asset: indexed(address)\n    vaultToken: indexed(address)\n    assetAmountDeposited: uint256\n    usdValue: uint256\n    vaultTokenAmountReceived: uint256\n    recipient: address\n\nevent MoonwellWithdrawal:\n    sender: indexed(address)\n    asset: indexed(address)\n    vaultToken: indexed(address)\n    assetAmountReceived: uint256\n    usdValue: uint256\n    vaultTokenAmountBurned: uint256\n    recipient: address\n\n# moonwell\nMOONWELL_COMPTROLLER: public(immutable(address))\nWETH: public(immutable(address))\n\nMAX_MARKETS: constant(uint256) = 50\nMAX_ASSETS: constant(uint256) = 25\nMAX_TOKEN_PATH: constant(uint256) = 5\n\n\n@deploy\ndef __init__(\n    _undyHq: address,\n    _moonwellComptroller: address,\n    _weth: address,\n):\n    addys.__init__(_undyHq)\n    yld.__init__(False)\n\n    assert empty(address) not in [_moonwellComptroller, _weth] # dev: invalid addrs\n    MOONWELL_COMPTROLLER = _moonwellComptroller\n    WETH = _weth\n\n\n@payable\n@external\ndef __default__():\n    pass\n\n\n@view\n@external\ndef hasCapability(_action: ws.ActionType) -> bool:\n    return _action in (\n        ws.ActionType.EARN_DEPOSIT | \n        ws.ActionType.EARN_WITHDRAW\n    )\n\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    return [MOONWELL_COMPTROLLER]\n\n\n@view\n@external\ndef isYieldLego() -> bool:\n    return True\n\n\n@view\n@external\ndef isDexLego() -> bool:\n    return False\n\n\n@view\n@external\ndef isEligibleVaultForTrialFunds(_vaultToken: address, _underlyingAsset: address) -> bool:\n    return yld.vaultToAsset[_vaultToken] == _underlyingAsset\n\n\n@view\n@external\ndef isEligibleForYieldBonus(_asset: address) -> bool:\n    return yld.vaultToAsset[_asset] != empty(address)\n\n\n@view\n@external\ndef isRebasing() -> bool:\n    return self._isRebasing()\n\n\n@view\n@internal\ndef _isRebasing() -> bool:\n    return False\n\n\n#########\n# Yield #\n#########\n\n\n# deposit\n\n\n@external\ndef depositForYield(\n    _asset: address,\n    _amount: uint256,\n    _vaultAddr: address,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, address, uint256, uint256):\n    assert not yld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = yld._getMiniAddys(_miniAddys)\n\n    # verify vault token (register if necessary)\n    vaultToken: address = self._getVaultTokenOnDeposit(_asset, _vaultAddr, miniAddys.ledger, miniAddys.legoBook)\n\n    # pre balances\n    preLegoBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    preLegoVaultBalance: uint256 = staticcall IERC20(vaultToken).balanceOf(self)\n\n    # transfer deposit asset to this contract\n    depositAmount: uint256 = min(_amount, staticcall IERC20(_asset).balanceOf(msg.sender))\n    assert depositAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_asset).transferFrom(msg.sender, self, depositAmount, default_return_value=True) # dev: transfer failed\n\n    # deposit assets into lego partner\n    assert extcall CompoundV2(vaultToken).mint(depositAmount) == 0 # dev: could not deposit into moonwell\n\n    # validate received vault tokens, transfer back to user\n    vaultTokenAmountReceived: uint256 = staticcall IERC20(vaultToken).balanceOf(self) - preLegoVaultBalance\n    assert vaultTokenAmountReceived != 0 # dev: no vault tokens received\n    assert extcall IERC20(vaultToken).transfer(_recipient, vaultTokenAmountReceived, default_return_value=True) # dev: transfer failed\n\n    # refund if full deposit didn't get through\n    currentLegoBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    refundAssetAmount: uint256 = 0\n    if currentLegoBalance > preLegoBalance:\n        refundAssetAmount = currentLegoBalance - preLegoBalance\n        assert extcall IERC20(_asset).transfer(msg.sender, refundAssetAmount, default_return_value=True) # dev: transfer failed\n        depositAmount -= refundAssetAmount\n\n    usdValue: uint256 = extcall Appraiser(miniAddys.appraiser).updatePriceAndGetUsdValue(_asset, depositAmount, miniAddys.missionControl, miniAddys.legoBook)\n    log MoonwellDeposit(\n        sender = msg.sender,\n        asset = _asset,\n        vaultToken = vaultToken,\n        assetAmountDeposited = depositAmount,\n        usdValue = usdValue,\n        vaultTokenAmountReceived = vaultTokenAmountReceived,\n        recipient = _recipient,\n    )\n    return depositAmount, vaultToken, vaultTokenAmountReceived, usdValue\n\n\n# asset verification\n\n\n@internal\ndef _getVaultTokenOnDeposit(_asset: address, _vaultAddr: address, _ledger: address, _legoBook: address) -> address:\n    asset: address = yld.vaultToAsset[_vaultAddr]\n    isRegistered: bool = True\n\n    # not yet registered, call moonwell directly to get asset\n    if asset == empty(address) and self._isValidCToken(_vaultAddr):\n        asset = staticcall CompoundV2(_vaultAddr).underlying()\n        isRegistered = False\n\n    assert asset != empty(address) # dev: invalid asset\n    assert asset == _asset # dev: asset mismatch\n\n    # register if necessary\n    if not isRegistered:\n        self._registerAsset(asset, _vaultAddr)\n        self._updateLedgerVaultToken(asset, _vaultAddr, _ledger, _legoBook)\n\n    return _vaultAddr\n\n\n# withdraw\n\n\n@external\ndef withdrawFromYield(\n    _vaultToken: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, address, uint256, uint256):\n    assert not yld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = yld._getMiniAddys(_miniAddys)\n\n    # verify asset (register if necessary)\n    asset: address = self._getAssetOnWithdraw(_vaultToken, miniAddys.ledger, miniAddys.legoBook)\n\n    # pre balances\n    preLegoBalance: uint256 = staticcall IERC20(asset).balanceOf(self)\n    preLegoVaultBalance: uint256 = staticcall IERC20(_vaultToken).balanceOf(self)\n\n    # transfer vaults tokens to this contract\n    vaultTokenAmount: uint256 = min(_amount, staticcall IERC20(_vaultToken).balanceOf(msg.sender))\n    assert vaultTokenAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_vaultToken).transferFrom(msg.sender, self, vaultTokenAmount, default_return_value=True) # dev: transfer failed\n\n    # withdraw assets from lego partner\n    assert extcall CompoundV2(_vaultToken).redeem(max_value(uint256)) == 0 # dev: could not withdraw from moonwell\n\n    # when withdrawing weth, they give eth\n    if asset == WETH:\n        extcall WethContract(WETH).deposit(value=self.balance)\n\n    # validate received asset , transfer back to user\n    assetAmountReceived: uint256 = staticcall IERC20(asset).balanceOf(self) - preLegoBalance\n    assert assetAmountReceived != 0 # dev: no asset amount received\n    assert extcall IERC20(asset).transfer(_recipient, assetAmountReceived, default_return_value=True) # dev: transfer failed\n\n    # refund if full withdrawal didn't happen\n    currentLegoVaultBalance: uint256 = staticcall IERC20(_vaultToken).balanceOf(self)\n    refundVaultTokenAmount: uint256 = 0\n    if currentLegoVaultBalance > preLegoVaultBalance:\n        refundVaultTokenAmount = currentLegoVaultBalance - preLegoVaultBalance\n        assert extcall IERC20(_vaultToken).transfer(msg.sender, refundVaultTokenAmount, default_return_value=True) # dev: transfer failed\n        vaultTokenAmount -= refundVaultTokenAmount\n\n    usdValue: uint256 = extcall Appraiser(miniAddys.appraiser).updatePriceAndGetUsdValue(asset, assetAmountReceived, miniAddys.missionControl, miniAddys.legoBook)\n    log MoonwellWithdrawal(\n        sender = msg.sender,\n        asset = asset,\n        vaultToken = _vaultToken,\n        assetAmountReceived = assetAmountReceived,\n        usdValue = usdValue,\n        vaultTokenAmountBurned = vaultTokenAmount,\n        recipient = _recipient,\n    )\n    return vaultTokenAmount, asset, assetAmountReceived, usdValue\n\n\n# vault token verification\n\n\n@internal\ndef _getAssetOnWithdraw(_vaultToken: address, _ledger: address, _legoBook: address) -> address:\n    asset: address = yld.vaultToAsset[_vaultToken]\n    isRegistered: bool = True\n\n    # not yet registered, call moonwell directly to get asset\n    if asset == empty(address) and self._isValidCToken(_vaultToken):\n        asset = staticcall CompoundV2(_vaultToken).underlying()\n        isRegistered = False\n\n    assert asset != empty(address) # dev: invalid asset\n\n    # register if necessary\n    if not isRegistered:\n        self._registerAsset(asset, _vaultToken)\n        self._updateLedgerVaultToken(asset, _vaultToken, _ledger, _legoBook)\n\n    return asset\n\n\n#################\n# Claim Rewards #\n#################\n\n\n@external\ndef claimRewards(\n    _user: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _extraData: bytes32,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    assert not yld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = yld._getMiniAddys(_miniAddys)\n\n    assert msg.sender == _user # dev: recipient must be caller\n    preBalance: uint256 = staticcall IERC20(_rewardToken).balanceOf(_user)\n\n    # claim rewards\n    extcall MoonwellComptroller(MOONWELL_COMPTROLLER).claimReward(_user)\n    rewardAmount: uint256 = staticcall IERC20(_rewardToken).balanceOf(_user) - preBalance\n    assert rewardAmount != 0 # dev: no rewards received\n\n    usdValue: uint256 = extcall Appraiser(miniAddys.appraiser).updatePriceAndGetUsdValue(_rewardToken, rewardAmount, miniAddys.missionControl, miniAddys.legoBook)\n    return rewardAmount, usdValue\n\n\n@view\n@external\ndef hasClaimableRewards(_user: address) -> bool:\n    rewardDistributor: address = staticcall MoonwellComptroller(MOONWELL_COMPTROLLER).rewardDistributor()\n    rewardsWithMToken: DynArray[RewardWithMToken, MAX_MARKETS] = staticcall MoonwellRewardDistributor(rewardDistributor).getOutstandingRewardsForUser(_user)\n    for i: uint256 in range(len(rewardsWithMToken), bound=MAX_MARKETS):\n        rewardsInfo: DynArray[RewardInfo, MAX_ASSETS] = rewardsWithMToken[i].rewards\n        for j: uint256 in range(len(rewardsInfo), bound=MAX_ASSETS):\n            if rewardsInfo[j].totalAmount > 0:\n                return True\n    return False\n\n\n#############\n# Utilities #\n#############\n\n\n# underlying asset\n\n\n@view\n@external\ndef isVaultToken(_vaultToken: address) -> bool:\n    return self._isVaultToken(_vaultToken)\n\n\n@view\n@internal\ndef _isVaultToken(_vaultToken: address) -> bool:\n    if yld.vaultToAsset[_vaultToken] != empty(address):\n        return True\n    return self._isValidCToken(_vaultToken)\n\n\n@view\n@internal\ndef _isValidCToken(_cToken: address) -> bool:\n    compMarkets: DynArray[address, MAX_MARKETS] = staticcall MoonwellComptroller(MOONWELL_COMPTROLLER).getAllMarkets()\n    return _cToken in compMarkets\n\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    return self._getUnderlyingAsset(_vaultToken)\n\n\n@view\n@internal\ndef _getUnderlyingAsset(_vaultToken: address) -> address:\n    asset: address = yld.vaultToAsset[_vaultToken]\n    if asset == empty(address) and self._isValidCToken(_vaultToken):\n        asset = staticcall CompoundV2(_vaultToken).underlying()\n    return asset\n\n\n# underlying amount\n\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    if not self._isVaultToken(_vaultToken) or _vaultTokenAmount == 0:\n        return 0 # invalid vault token or amount\n    return self._getUnderlyingAmount(_vaultToken, _vaultTokenAmount)\n\n\n@view\n@internal\ndef _getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    return _vaultTokenAmount * staticcall CompoundV2(_vaultToken).exchangeRateStored() // (10 ** 18)\n\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    if empty(address) in [_asset, _vaultToken] or _assetAmount == 0:\n        return 0 # bad inputs\n    if self._getUnderlyingAsset(_vaultToken) != _asset:\n        return 0 # invalid vault token or asset\n    return _assetAmount * (10 ** 18) // staticcall CompoundV2(_vaultToken).exchangeRateStored()\n\n\n# usd value\n\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> uint256:\n    return self._getUsdValueOfVaultToken(_vaultToken, _vaultTokenAmount, _appraiser)\n\n\n@view\n@internal\ndef _getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address) -> uint256:\n    asset: address = empty(address)\n    underlyingAmount: uint256 = 0\n    usdValue: uint256 = 0\n    asset, underlyingAmount, usdValue = self._getUnderlyingData(_vaultToken, _vaultTokenAmount, _appraiser)\n    return usdValue\n\n\n# all underlying data together\n\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> (address, uint256, uint256):\n    return self._getUnderlyingData(_vaultToken, _vaultTokenAmount, _appraiser)\n\n\n@view\n@internal\ndef _getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address) -> (address, uint256, uint256):\n    if _vaultTokenAmount == 0 or _vaultToken == empty(address):\n        return empty(address), 0, 0 # bad inputs\n    asset: address = self._getUnderlyingAsset(_vaultToken)\n    if asset == empty(address):\n        return empty(address), 0, 0 # invalid vault token\n    underlyingAmount: uint256 = self._getUnderlyingAmount(_vaultToken, _vaultTokenAmount)\n    usdValue: uint256 = self._getUsdValue(asset, underlyingAmount, _appraiser)\n    return asset, underlyingAmount, usdValue\n\n\n@view\n@internal\ndef _getUsdValue(_asset: address, _amount: uint256, _appraiser: address) -> uint256:\n    appraiser: address = _appraiser\n    if _appraiser == empty(address):\n        appraiser = addys._getAppraiserAddr()\n    return staticcall Appraiser(appraiser).getUsdValue(_asset, _amount)\n\n\n# other\n\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    if not self._isVaultToken(_vaultToken):\n        return 0 # invalid vault token\n    return staticcall CompoundV2(_vaultToken).totalSupply() * staticcall CompoundV2(_vaultToken).exchangeRateStored() // (10 ** 18)\n\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    if not self._isVaultToken(_vaultToken):\n        return 0 # invalid vault token\n    return staticcall CompoundV2(_vaultToken).totalBorrows()\n\n\n# price per share\n\n\n@view\n@external\ndef getPricePerShare(_asset: address, _decimals: uint256) -> uint256:\n    return staticcall CompoundV2(_asset).exchangeRateStored() * (10 ** _decimals) // (10 ** 18)\n\n\n################\n# Registration #\n################\n\n\n@external\ndef addAssetOpportunity(_asset: address, _vaultAddr: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert self._isValidAssetOpportunity(_asset, _vaultAddr) # dev: invalid asset or vault\n    assert not yld._isAssetOpportunity(_asset, _vaultAddr) # dev: already registered\n    self._registerAsset(_asset, _vaultAddr)\n\n\n@internal\ndef _registerAsset(_asset: address, _vaultAddr: address):\n    assert extcall IERC20(_asset).approve(_vaultAddr, max_value(uint256), default_return_value=True) # dev: max approval failed\n    yld._addAssetOpportunity(_asset, _vaultAddr)\n\n\n@external\ndef removeAssetOpportunity(_asset: address, _vaultAddr: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert extcall IERC20(_asset).approve(_vaultAddr, 0, default_return_value=True) # dev: max approval failed\n    yld._removeAssetOpportunity(_asset, _vaultAddr)\n\n\n# validation\n\n\n@view\n@internal\ndef isValidAssetOpportunity(_asset: address, _vaultAddr: address) -> bool:\n    return self._isValidAssetOpportunity(_asset, _vaultAddr)\n\n\n@view\n@internal\ndef _isValidAssetOpportunity(_asset: address, _vaultAddr: address) -> bool:\n    return self._isValidCToken(_vaultAddr) and staticcall CompoundV2(_vaultAddr).underlying() == _asset\n\n\n# update ledger registration\n\n\n@internal\ndef _updateLedgerVaultToken(\n    _underlyingAsset: address,\n    _vaultToken: address,\n    _ledger: address,\n    _legoBook: address,\n):\n    if empty(address) in [_underlyingAsset, _vaultToken]:\n        return\n\n    if not staticcall Ledger(_ledger).isRegisteredVaultToken(_vaultToken):\n        legoId: uint256 = staticcall Registry(_legoBook).getRegId(self)\n        decimals: uint256 = convert(staticcall IERC20Detailed(_vaultToken).decimals(), uint256)\n        extcall Ledger(_ledger).setVaultToken(_vaultToken, legoId, _underlyingAsset, decimals, self._isRebasing())\n\n\n#########\n# Other #\n#########\n\n\n@external\ndef swapTokens(\n    _amountIn: uint256,\n    _minAmountOut: uint256,\n    _tokenPath: DynArray[address, MAX_TOKEN_PATH],\n    _poolPath: DynArray[address, MAX_TOKEN_PATH - 1],\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256):\n    return 0, 0, 0\n\n\n@external\ndef mintOrRedeemAsset(\n    _tokenIn: address,\n    _tokenOut: address,\n    _tokenInAmount: uint256,\n    _minAmountOut: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, bool, uint256):\n    return 0, 0, False, 0\n\n\n@external\ndef confirmMintOrRedeemAsset(\n    _tokenIn: address,\n    _tokenOut: address,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef addCollateral(\n    _asset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef removeCollateral(\n    _asset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef borrow(\n    _borrowAsset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef repayDebt(\n    _paymentAsset: address,\n    _paymentAmount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef addLiquidity(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _amountA: uint256,\n    _amountB: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _minLpAmount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (address, uint256, uint256, uint256, uint256):\n    return empty(address), 0, 0, 0, 0\n\n\n@external\ndef removeLiquidity(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpToken: address,\n    _lpAmount: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, uint256):\n    return 0, 0, 0, 0\n\n\n@external\ndef addLiquidityConcentrated(\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _tickLower: int24,\n    _tickUpper: int24,\n    _amountA: uint256,\n    _amountB: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, uint256, uint256):\n    return 0, 0, 0, 0, 0\n\n\n@external\ndef removeLiquidityConcentrated(\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _liqToRemove: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, bool, uint256):\n    return 0, 0, 0, False, 0\n\n\n@view\n@external\ndef getAccessForLego(_user: address, _action: ws.ActionType) -> (address, String[64], uint256):\n    return empty(address), empty(String[64]), 0\n\n\n@view\n@external\ndef getPrice(_asset: address, _decimals: uint256) -> uint256:\n    return 0\n",
            "sha256sum": "09a5c1a943d89528cb7475afcfcf0131d4349aca79f9f34a9ac776bbe3056a32"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/legos/yield/Moonwell.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.3+commit.bff19ea2",
        "integrity": "0b679c982bdf6d971f7c0f1226e8e40fb75aabe90d8b65ea1f7722c8fd5f6d83"
      },
      "args": "00000000000000000000000044cf3c4f000dfd76a35d03298049d37be688d6f9000000000000000000000000fbb21d0380bee3312b33c4353c8936a0f13ef26c0000000000000000000000004200000000000000000000000000000000000006",
      "file": "contracts/legos/yield/Moonwell.vy"
    },
    "Morpho": {
      "address": "0xd7a412C42c7430802e2A60F8145c36A4c6d0bA84",
      "abi": [
        {
          "name": "MorphoDeposit",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountDeposited",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultTokenAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "MorphoWithdrawal",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultTokenAmountBurned",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "MorphoRewardsAddrSet",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LegoPauseModified",
          "inputs": [
            {
              "name": "isPaused",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LegoFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "balance",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetOpportunityAdded",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultAddr",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetOpportunityRemoved",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultAddr",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddys",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "undyToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "hatchery",
                  "type": "address"
                },
                {
                  "name": "lootDistributor",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                },
                {
                  "name": "walletBackpack",
                  "type": "address"
                },
                {
                  "name": "billing",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUndyHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isLegoAsset",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssetOpportunities",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isAssetOpportunity",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getNumLegoAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pause",
          "inputs": [
            {
              "name": "_shouldPause",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFundsMany",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_assets",
              "type": "address[]"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isPaused",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assetOpportunities",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAssetOpportunity",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssetOpportunities",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "vaultToAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assets",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasCapability",
          "inputs": [
            {
              "name": "_action",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRegistries",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isYieldLego",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isDexLego",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isRebasing",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isEligibleVaultForTrialFunds",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_underlyingAsset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isEligibleForYieldBonus",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositForYield",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositForYield",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawFromYield",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawFromYield",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasClaimableRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setMorphoRewardsAddr",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAsset",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAmount",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getVaultTokenAmount",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_assetAmount",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValueOfVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValueOfVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            },
            {
              "name": "_appraiser",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingData",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingData",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            },
            {
              "name": "_appraiser",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalAssets",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalBorrows",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPricePerShare",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_decimals",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addAssetOpportunity",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeAssetOpportunity",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_tokenPath",
              "type": "address[]"
            },
            {
              "name": "_poolPath",
              "type": "address[]"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_tokenPath",
              "type": "address[]"
            },
            {
              "name": "_poolPath",
              "type": "address[]"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_tokenInAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_tokenInAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmMintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmMintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_borrowAsset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_borrowAsset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_paymentAsset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_paymentAsset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAccessForLego",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_action",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "string"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPrice",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_decimals",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "morphoRewards",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MORPHO_FACTORY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MORPHO_FACTORY_LEGACY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_undyHq",
              "type": "address"
            },
            {
              "name": "_morphoFactory",
              "type": "address"
            },
            {
              "name": "_morphoFactoryLegacy",
              "type": "address"
            },
            {
              "name": "_morphoRewardsAddr",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "interfaces/WalletStructs.vyi": {
            "content": "# @version 0.4.3\n\nflag ActionType:\n    TRANSFER\n    EARN_DEPOSIT\n    EARN_WITHDRAW\n    EARN_REBALANCE\n    SWAP\n    MINT_REDEEM\n    CONFIRM_MINT_REDEEM\n    ADD_COLLATERAL\n    REMOVE_COLLATERAL\n    BORROW\n    REPAY_DEBT\n    REWARDS\n    ETH_TO_WETH\n    WETH_TO_ETH\n    ADD_LIQ\n    REMOVE_LIQ\n    ADD_LIQ_CONC\n    REMOVE_LIQ_CONC\n    PAY_CHEQUE\n\nstruct WalletAssetData:\n    assetBalance: uint256\n    usdValue: uint256\n    isYieldAsset: bool\n    lastPricePerShare: uint256\n\nstruct ActionData:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    billing: address\n    wallet: address\n    walletConfig: address\n    walletOwner: address\n    inEjectMode: bool\n    isFrozen: bool\n    lastTotalUsdValue: uint256\n    signer: address\n    isManager: bool\n    legoId: uint256\n    legoAddr: address\n    eth: address\n    weth: address\n\nstruct MiniAddys:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    appraiser: address",
            "sha256sum": "9a4b4f59b3a62043e51b425a665064aae419a3c0bd0514b6b29a9441ae364bb9"
          },
          "interfaces/LegoPartner.vyi": {
            "content": "# @version 0.4.3\n\nfrom interfaces import WalletStructs as ws\n\nMAX_TOKEN_PATH: constant(uint256) = 5\nMAX_RECOVER_ASSETS: constant(uint256) = 20\n\n@external\ndef addLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _tickLower: int24, _tickUpper: int24, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef addLiquidity(_pool: address, _tokenA: address, _tokenB: address, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _minLpAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (address, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef removeLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _liqToRemove: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef removeLiquidity(_pool: address, _tokenA: address, _tokenB: address, _lpToken: address, _lpAmount: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef mintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _tokenInAmount: uint256, _minAmountOut: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef swapTokens(_amountIn: uint256, _minAmountOut: uint256, _tokenPath: DynArray[address, MAX_TOKEN_PATH], _poolPath: DynArray[address, MAX_TOKEN_PATH - 1], _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256):\n    ...\n\n@external\ndef depositForYield(_asset: address, _amount: uint256, _vaultAddr: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef withdrawFromYield(_vaultToken: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef confirmMintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef borrow(_borrowAsset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef repayDebt(_paymentAsset: address, _paymentAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef claimRewards(_user: address, _rewardToken: address, _rewardAmount: uint256, _extraData: bytes32, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef removeCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef addCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@view\n@external\ndef getAccessForLego(_user: address, _action: ws.ActionType) -> (address, String[64], uint256):\n    ...\n\n@view\n@external\ndef hasCapability(_action: ws.ActionType) -> bool:\n    ...\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    ...\n\n@view\n@external\ndef isYieldLego() -> bool:\n    ...\n\n@view\n@external\ndef isDexLego() -> bool:\n    ...\n\n@view\n@external\ndef getPricePerShare(_asset: address, _decimals: uint256) -> uint256:\n    ...\n\n@view\n@external\ndef getPrice(_asset: address, _decimals: uint256) -> uint256:\n    ...\n\n\n# common\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "2513e379aa74d0a8120114a5078a4c1a0900165a1c3f24419bb811d173b56453"
          },
          "interfaces/YieldLego.vyi": {
            "content": "# @version 0.4.3\n\n@view\n@external\ndef isRebasing() -> bool:\n    ...\n\n\n@view\n@external\ndef isEligibleForYieldBonus(_asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef isEligibleVaultForTrialFunds(_vaultToken: address, _underlyingAsset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    ...\n\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    ...\n\n\n@view\n@external\ndef isVaultToken(_vaultToken: address) -> bool:\n    ...\n\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> uint256:\n    ...\n\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> (address, uint256, uint256):\n    ...\n\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    ...\n\n\n@external\ndef addAssetOpportunity(_asset: address, _vaultAddr: address):\n    ...\n\n\n@external\ndef removeAssetOpportunity(_asset: address, _vaultAddr: address):\n    ...\n\n\n# YieldLegoData.vy module\n\n\n@view\n@external\ndef assetOpportunities(_asset: address, _index: uint256) -> address:\n    ...\n\n\n@view\n@external\ndef indexOfAssetOpportunity(_asset: address, _vaultAddr: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef numAssetOpportunities(_asset: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef vaultToAsset(_vaultAddr: address) -> address:\n    ...\n\n\n@view\n@external\ndef assets(_index: uint256) -> address:\n    ...\n\n\n@view\n@external\ndef indexOfAsset(_asset: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef numAssets() -> uint256:\n    ...\n\n\n@view\n@external\ndef isLegoAsset(_asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, 40]:\n    ...\n\n\n@view\n@external\ndef getAssets() -> DynArray[address, 20]:\n    ...\n\n\n@view\n@external\ndef isAssetOpportunity(_asset: address, _vaultAddr: address) -> bool:\n    ...\n\n\n@view\n@external\ndef getNumLegoAssets() -> uint256:\n    ...\n",
            "sha256sum": "3337ce5f78b0df6f86d1144b07505512bb1044304f67add97be6c3816b3c0b42"
          },
          "contracts/modules/Addys.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\ninterface UndyHq:\n    def isValidAddr(_addr: address) -> bool: view\n    def getAddr(_regId: uint256) -> address: view\n    def undyToken() -> address: view\n\ninterface Switchboard:\n    def isSwitchboardAddr(_addr: address) -> bool: view\n\ninterface LegoBook:\n    def isLegoAddr(_addr: address) -> bool: view\n\nstruct Addys:\n    hq: address\n    undyToken: address\n    ledger: address\n    missionControl: address\n    legoBook: address\n    switchboard: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    walletBackpack: address\n    billing: address\n\n# hq\nUNDY_HQ_FOR_ADDYS: immutable(address)\n\n# core addys\nLEDGER_ID: constant(uint256) = 1\nMISSION_CONTROL_ID: constant(uint256) = 2\nLEGO_BOOK_ID: constant(uint256) = 3\nSWITCHBOARD_ID: constant(uint256) = 4\nHATCHERY_ID: constant(uint256) = 5\nLOOT_DISTRIBUTOR_ID: constant(uint256) = 6\nAPPRAISER_ID: constant(uint256) = 7\nWALLET_BACKPACK_ID: constant(uint256) = 8\nBILLING_ID: constant(uint256) = 9\n\n\n@deploy\ndef __init__(_undyHq: address):\n    assert _undyHq != empty(address) # dev: invalid undy hq\n    UNDY_HQ_FOR_ADDYS = _undyHq\n\n\n########\n# Core #\n########\n\n\n@view\n@external\ndef getAddys() -> Addys:\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _getAddys(_addys: Addys = empty(Addys)) -> Addys:\n    if _addys.hq != empty(address):\n        return _addys\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _generateAddys() -> Addys:\n    hq: address = UNDY_HQ_FOR_ADDYS\n    return Addys(\n        hq = hq,\n        undyToken = staticcall UndyHq(hq).undyToken(),\n        ledger = staticcall UndyHq(hq).getAddr(LEDGER_ID),\n        missionControl = staticcall UndyHq(hq).getAddr(MISSION_CONTROL_ID),\n        legoBook = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID),\n        switchboard = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID),\n        hatchery = staticcall UndyHq(hq).getAddr(HATCHERY_ID),\n        lootDistributor = staticcall UndyHq(hq).getAddr(LOOT_DISTRIBUTOR_ID),\n        appraiser = staticcall UndyHq(hq).getAddr(APPRAISER_ID),\n        walletBackpack = staticcall UndyHq(hq).getAddr(WALLET_BACKPACK_ID),\n        billing = staticcall UndyHq(hq).getAddr(BILLING_ID),\n    )\n\n\n##########\n# Tokens #\n##########\n\n\n@view\n@internal\ndef _getUndyToken() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).undyToken()\n\n\n###########\n# Helpers #\n###########\n\n\n# undy hq\n\n\n@view\n@external\ndef getUndyHq() -> address:\n    return self._getUndyHq()\n\n\n@view\n@internal\ndef _getUndyHq() -> address:\n    return UNDY_HQ_FOR_ADDYS\n\n\n# utils\n\n\n@view\n@internal\ndef _isValidUndyAddr(_addr: address, _hq: address = empty(address)) -> bool:\n    hq: address = _hq\n    if _hq == empty(address):\n        hq = UNDY_HQ_FOR_ADDYS\n    \n    # core departments\n    if staticcall UndyHq(hq).isValidAddr(_addr):\n        return True\n\n    # lego book\n    legoBook: address = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID)\n    if legoBook != empty(address) and staticcall LegoBook(legoBook).isLegoAddr(_addr):\n        return True\n\n    # switchboard config\n    switchboard: address = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID)\n    if switchboard != empty(address) and staticcall Switchboard(switchboard).isSwitchboardAddr(_addr):\n        return True\n\n    return False\n\n\n@view\n@internal\ndef _isSwitchboardAddr(_addr: address) -> bool:\n    switchboard: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n    if switchboard == empty(address):\n        return False\n    return staticcall Switchboard(switchboard).isSwitchboardAddr(_addr)\n\n\n@view\n@internal\ndef _isLegoBookAddr(_addr: address) -> bool:\n    legoBook: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n    if legoBook == empty(address):\n        return False\n    return staticcall LegoBook(legoBook).isLegoAddr(_addr)\n\n\n###############\n# Departments #\n###############\n\n\n# ledger\n\n\n@view\n@internal\ndef _getLedgerId() -> uint256:\n    return LEDGER_ID\n\n\n@view\n@internal\ndef _getLedgerAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEDGER_ID)\n\n\n# mission control\n\n\n@view\n@internal\ndef _getMissionControlId() -> uint256:\n    return MISSION_CONTROL_ID\n\n\n@view\n@internal\ndef _getMissionControlAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(MISSION_CONTROL_ID)\n\n\n# lego book\n\n\n@view\n@internal\ndef _getLegoBookId() -> uint256:\n    return LEGO_BOOK_ID\n\n\n@view\n@internal\ndef _getLegoBookAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n\n\n# switchboard\n\n\n@view\n@internal\ndef _getSwitchboardId() -> uint256:\n    return SWITCHBOARD_ID\n\n\n@view\n@internal\ndef _getSwitchboardAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n\n\n# hatchery\n\n\n@view\n@internal\ndef _getHatcheryId() -> uint256:\n    return HATCHERY_ID\n\n\n@view\n@internal\ndef _getHatcheryAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(HATCHERY_ID)\n\n\n# loot distributor\n\n\n@view\n@internal\ndef _getLootDistributorId() -> uint256:\n    return LOOT_DISTRIBUTOR_ID\n\n\n@view\n@internal\ndef _getLootDistributorAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LOOT_DISTRIBUTOR_ID)\n\n\n# appraiser\n\n\n@view\n@internal\ndef _getAppraiserId() -> uint256:\n    return APPRAISER_ID\n\n\n@view\n@internal\ndef _getAppraiserAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(APPRAISER_ID)\n\n\n# wallet backpack\n\n\n@view\n@internal\ndef _getWalletBackpackId() -> uint256:\n    return WALLET_BACKPACK_ID\n\n\n@view\n@internal\ndef _getWalletBackpackAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(WALLET_BACKPACK_ID)\n\n\n# billing\n\n\n@view\n@internal\ndef _getBillingId() -> uint256:\n    return BILLING_ID\n\n\n@view\n@internal\ndef _getBillingAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(BILLING_ID)",
            "sha256sum": "78b58f0b2acb2eaafa4d21adf9135a1cd0e1d53897f7a1fa70a83a04a7738ad3"
          },
          "contracts/modules/YieldLegoData.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nuses: addys\n\nimport contracts.modules.Addys as addys\n\nfrom interfaces import WalletStructs as ws\nfrom ethereum.ercs import IERC20\n\nevent AssetOpportunityAdded:\n    asset: indexed(address)\n    vaultAddr: indexed(address)\n\nevent AssetOpportunityRemoved:\n    asset: indexed(address)\n    vaultAddr: indexed(address)\n\nevent LegoPauseModified:\n    isPaused: bool\n\nevent LegoFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    balance: uint256\n\n# config\nisPaused: public(bool)\n\n# asset opportunities\nassetOpportunities: public(HashMap[address, HashMap[uint256, address]]) # asset -> index -> vault addr\nindexOfAssetOpportunity: public(HashMap[address, HashMap[address, uint256]]) # asset -> vault addr -> index\nnumAssetOpportunities: public(HashMap[address, uint256]) # asset -> number of opportunities\n\n# mapping\nvaultToAsset: public(HashMap[address, address]) # vault addr -> underlying asset\n\n# lego assets (iterable)\nassets: public(HashMap[uint256, address]) # index -> asset\nindexOfAsset: public(HashMap[address, uint256]) # asset -> index\nnumAssets: public(uint256) # num assets\n\nMAX_VAULTS: constant(uint256) = 40\nMAX_ASSETS: constant(uint256) = 20\nMAX_RECOVER_ASSETS: constant(uint256) = 20\n\n\n@deploy\ndef __init__(_shouldPause: bool):\n    self.isPaused = _shouldPause\n    self.numAssets = 1 # not using 0 index\n\n\n#########\n# Views #\n#########\n\n\n# is lego asset\n\n\n@view\n@external\ndef isLegoAsset(_asset: address) -> bool:\n    return self._isLegoAsset(_asset)\n\n\n@view\n@internal\ndef _isLegoAsset(_asset: address) -> bool:\n    return self.indexOfAsset[_asset] != 0\n\n\n# vault opportunities\n\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, MAX_VAULTS]:\n    numOpportunities: uint256 = self.numAssetOpportunities[_asset]\n    if numOpportunities == 0:\n        return []\n    opportunities: DynArray[address, MAX_VAULTS] = []\n    for i: uint256 in range(1, numOpportunities, bound=MAX_VAULTS):\n        opportunities.append(self.assetOpportunities[_asset][i])\n    return opportunities\n\n\n# all assets registered\n\n\n@view\n@external\ndef getAssets() -> DynArray[address, MAX_ASSETS]:\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return []\n    assets: DynArray[address, MAX_ASSETS] = []\n    for i: uint256 in range(1, numAssets, bound=MAX_ASSETS):\n        assets.append(self.assets[i])\n    return assets\n\n\n################\n# Registration #\n################\n\n\n@view\n@external\ndef isAssetOpportunity(_asset: address, _vaultAddr: address) -> bool:\n    return self._isAssetOpportunity(_asset, _vaultAddr)\n\n\n@view\n@internal\ndef _isAssetOpportunity(_asset: address, _vaultAddr: address) -> bool:\n    return self.indexOfAssetOpportunity[_asset][_vaultAddr] != 0\n\n\n# add asset opportunity\n\n\n@internal\ndef _addAssetOpportunity(_asset: address, _vaultAddr: address):\n    if self.indexOfAssetOpportunity[_asset][_vaultAddr] != 0:\n        return\n    if empty(address) in [_asset, _vaultAddr]:\n        return\n\n    # add asset opportunity\n    aid: uint256 = self.numAssetOpportunities[_asset]\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.assetOpportunities[_asset][aid] = _vaultAddr\n    self.indexOfAssetOpportunity[_asset][_vaultAddr] = aid\n    self.numAssetOpportunities[_asset] = aid + 1\n\n    # add mapping\n    self.vaultToAsset[_vaultAddr] = _asset\n\n    # add asset\n    self._addAsset(_asset)\n\n    log AssetOpportunityAdded(asset=_asset, vaultAddr=_vaultAddr)\n\n\n# remove asset opportunity\n\n\n@internal\ndef _removeAssetOpportunity(_asset: address, _vaultAddr: address):\n    numOpportunities: uint256 = self.numAssetOpportunities[_asset]\n    if numOpportunities == 0:\n        return\n\n    targetIndex: uint256 = self.indexOfAssetOpportunity[_asset][_vaultAddr]\n    if targetIndex == 0:\n        return\n\n    # update data\n    lastIndex: uint256 = numOpportunities - 1\n    self.numAssetOpportunities[_asset] = lastIndex\n    self.indexOfAssetOpportunity[_asset][_vaultAddr] = 0\n\n    self.vaultToAsset[_vaultAddr] = empty(address)\n\n    # shift to replace the removed one\n    if targetIndex != lastIndex:\n        lastVaultAddr: address = self.assetOpportunities[_asset][lastIndex]\n        self.assetOpportunities[_asset][targetIndex] = lastVaultAddr\n        self.indexOfAssetOpportunity[_asset][lastVaultAddr] = targetIndex\n\n    # remove asset\n    if lastIndex <= 1:\n        self._removeAsset(_asset)\n\n    log AssetOpportunityRemoved(asset=_asset, vaultAddr=_vaultAddr)\n\n\n# add asset\n\n\n@internal\ndef _addAsset(_asset: address):\n    if self.indexOfAsset[_asset] != 0:\n        return\n\n    aid: uint256 = self.numAssets\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.assets[aid] = _asset\n    self.indexOfAsset[_asset] = aid\n    self.numAssets = aid + 1\n\n\n# remove asset\n\n\n@internal\ndef _removeAsset(_asset: address):\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return\n\n    targetIndex: uint256 = self.indexOfAsset[_asset]\n    if targetIndex == 0:\n        return\n\n    # update data\n    lastIndex: uint256 = numAssets - 1\n    self.numAssets = lastIndex\n    self.indexOfAsset[_asset] = 0\n\n    # shift to replace the removed one\n    if targetIndex != lastIndex:\n        lastAsset: address = self.assets[lastIndex]\n        self.assets[targetIndex] = lastAsset\n        self.indexOfAsset[lastAsset] = targetIndex\n\n\n# num lego assets (true number, use `numAssets` for iteration)\n\n\n@view\n@external\ndef getNumLegoAssets() -> uint256:\n    return self._getNumLegoAssets()\n\n\n@view\n@internal\ndef _getNumLegoAssets() -> uint256:\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return 0\n    return numAssets - 1\n\n\n###########\n# General #\n###########\n\n\n# fill mini addys\n\n\n@view\n@internal\ndef _getMiniAddys(_miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> ws.MiniAddys:\n    if _miniAddys.ledger != empty(address):\n        return _miniAddys\n    return ws.MiniAddys(\n        ledger = addys._getLedgerAddr(),\n        missionControl = addys._getMissionControlAddr(),\n        legoBook = addys._getLegoBookAddr(),\n        appraiser = addys._getAppraiserAddr(),\n    )\n\n\n# activate\n\n\n@external\ndef pause(_shouldPause: bool):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert _shouldPause != self.isPaused # dev: no change\n    self.isPaused = _shouldPause\n    log LegoPauseModified(isPaused=_shouldPause)\n\n\n# recover funds\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    self._recoverFunds(_recipient, _asset)\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, MAX_RECOVER_ASSETS]):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    for a: address in _assets:\n        self._recoverFunds(_recipient, a)\n\n\n@internal\ndef _recoverFunds(_recipient: address, _asset: address):\n    assert empty(address) not in [_recipient, _asset] # dev: invalid recipient or asset\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    assert balance != 0 # dev: nothing to recover\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log LegoFundsRecovered(asset=_asset, recipient=_recipient, balance=balance)",
            "sha256sum": "bcbae5ce139758ce8a77c03858ec8d438dea0437d5f3a20fed8267f4d2f15b66"
          },
          "contracts/legos/yield/Morpho.vy": {
            "content": "#     __   __ ___ _______ ___     ______       ___     _______ _______ _______ \n#    |  | |  |   |       |   |   |      |     |   |   |       |       |       |\n#    |  |_|  |   |    ___|   |   |  _    |    |   |   |    ___|    ___|   _   |\n#    |       |   |   |___|   |   | | |   |    |   |   |   |___|   | __|  | |  |\n#    |_     _|   |    ___|   |___| |_|   |    |   |___|    ___|   ||  |  |_|  |\n#      |   | |   |   |___|       |       |    |       |   |___|   |_| |       |\n#      |___| |___|_______|_______|______|     |_______|_______|_______|_______|\n#                                                                       \n#     \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n#     \u2551  ** Morpho Lego **                      \u2551\n#     \u2551  Integration with Morpho Protocol.      \u2551\n#     \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n#\n#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nimplements: Lego\nimplements: YieldLego\n\nexports: addys.__interface__\nexports: yld.__interface__\n\ninitializes: addys\ninitializes: yld[addys := addys]\n\nfrom interfaces import LegoPartner as Lego\nfrom interfaces import YieldLego as YieldLego\nfrom interfaces import WalletStructs as ws\n\nimport contracts.modules.Addys as addys\nimport contracts.modules.YieldLegoData as yld\n\nfrom ethereum.ercs import IERC20Detailed\nfrom ethereum.ercs import IERC20\nfrom ethereum.ercs import IERC4626\n\ninterface Appraiser:\n    def getUsdValue(_asset: address, _amount: uint256, _missionControl: address = empty(address), _legoBook: address = empty(address), _ledger: address = empty(address)) -> uint256: view\n    def updatePriceAndGetUsdValue(_asset: address, _amount: uint256, _missionControl: address = empty(address), _legoBook: address = empty(address)) -> uint256: nonpayable\n\ninterface Ledger:\n    def setVaultToken(_vaultToken: address, _legoId: uint256, _underlyingAsset: address, _decimals: uint256, _isRebasing: bool): nonpayable\n    def isRegisteredVaultToken(_vaultToken: address) -> bool: view\n\ninterface MorphoRewardsDistributor:\n    def claim(_user: address, _rewardToken: address, _claimable: uint256, _proof: bytes32) -> uint256: nonpayable\n\ninterface MetaMorphoFactory:\n    def isMetaMorpho(_vault: address) -> bool: view\n\ninterface Registry:\n    def getRegId(_addr: address) -> uint256: view\n\nevent MorphoDeposit:\n    sender: indexed(address)\n    asset: indexed(address)\n    vaultToken: indexed(address)\n    assetAmountDeposited: uint256\n    usdValue: uint256\n    vaultTokenAmountReceived: uint256\n    recipient: address\n\nevent MorphoWithdrawal:\n    sender: indexed(address)\n    asset: indexed(address)\n    vaultToken: indexed(address)\n    assetAmountReceived: uint256\n    usdValue: uint256\n    vaultTokenAmountBurned: uint256\n    recipient: address\n\nevent MorphoRewardsAddrSet:\n    addr: address\n\n# rewards contract\nmorphoRewards: public(address)\n\n# morpho\nMORPHO_FACTORY: public(immutable(address))\nMORPHO_FACTORY_LEGACY: public(immutable(address))\n\nMAX_TOKEN_PATH: constant(uint256) = 5\n\n\n@deploy\ndef __init__(\n    _undyHq: address,\n    _morphoFactory: address,\n    _morphoFactoryLegacy: address,\n    _morphoRewardsAddr: address,\n):\n    addys.__init__(_undyHq)\n    yld.__init__(False)\n\n    assert empty(address) not in [_morphoFactory, _morphoFactoryLegacy] # dev: invalid addrs\n    MORPHO_FACTORY = _morphoFactory\n    MORPHO_FACTORY_LEGACY = _morphoFactoryLegacy\n    self.morphoRewards = _morphoRewardsAddr\n\n\n@view\n@external\ndef hasCapability(_action: ws.ActionType) -> bool:\n    return _action in (\n        ws.ActionType.EARN_DEPOSIT | \n        ws.ActionType.EARN_WITHDRAW\n    )\n\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    return [MORPHO_FACTORY, MORPHO_FACTORY_LEGACY]\n\n\n@view\n@external\ndef isYieldLego() -> bool:\n    return True\n\n\n@view\n@external\ndef isDexLego() -> bool:\n    return False\n\n\n@view\n@external\ndef isRebasing() -> bool:\n    return self._isRebasing()\n\n\n@view\n@internal\ndef _isRebasing() -> bool:\n    return False\n\n\n@view\n@external\ndef isEligibleVaultForTrialFunds(_vaultToken: address, _underlyingAsset: address) -> bool:\n    asset: address = yld.vaultToAsset[_vaultToken]\n    if asset != _underlyingAsset:\n        return False\n    return self._hasSufficientAssets(_vaultToken, _underlyingAsset)\n\n\n@view\n@external\ndef isEligibleForYieldBonus(_asset: address) -> bool:\n    underlyingAsset: address = yld.vaultToAsset[_asset]\n    if underlyingAsset == empty(address):\n        return False\n    return self._hasSufficientAssets(_asset, underlyingAsset)\n\n\n# check if vault has sufficient assets\n\n\n@view\n@internal\ndef _hasSufficientAssets(_vaultToken: address, _underlyingAsset: address) -> bool:\n    # vault must have at least $100k in assets\n    decimals: uint256 = convert(staticcall IERC20Detailed(_underlyingAsset).decimals(), uint256)\n    return staticcall IERC4626(_vaultToken).totalAssets() > 100_000 * (10 ** decimals)\n\n\n#########\n# Yield #\n#########\n\n\n# deposit\n\n\n@external\ndef depositForYield(\n    _asset: address,\n    _amount: uint256,\n    _vaultAddr: address,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, address, uint256, uint256):\n    assert not yld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = yld._getMiniAddys(_miniAddys)\n\n    # verify vault token (register if necessary)\n    vaultToken: address = self._getVaultTokenOnDeposit(_asset, _vaultAddr, miniAddys.ledger, miniAddys.legoBook)\n\n    # pre balances\n    preLegoBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n\n    # transfer deposit asset to this contract\n    depositAmount: uint256 = min(_amount, staticcall IERC20(_asset).balanceOf(msg.sender))\n    assert depositAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_asset).transferFrom(msg.sender, self, depositAmount, default_return_value=True) # dev: transfer failed\n\n    # deposit assets into lego partner\n    vaultTokenAmountReceived: uint256 = extcall IERC4626(vaultToken).deposit(depositAmount, _recipient)\n    assert vaultTokenAmountReceived != 0 # dev: no vault tokens received\n\n    # refund if full deposit didn't get through\n    currentLegoBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    refundAssetAmount: uint256 = 0\n    if currentLegoBalance > preLegoBalance:\n        refundAssetAmount = currentLegoBalance - preLegoBalance\n        assert extcall IERC20(_asset).transfer(msg.sender, refundAssetAmount, default_return_value=True) # dev: transfer failed\n        depositAmount -= refundAssetAmount\n\n    usdValue: uint256 = extcall Appraiser(miniAddys.appraiser).updatePriceAndGetUsdValue(_asset, depositAmount, miniAddys.missionControl, miniAddys.legoBook)\n    log MorphoDeposit(\n        sender = msg.sender,\n        asset = _asset,\n        vaultToken = vaultToken,\n        assetAmountDeposited = depositAmount,\n        usdValue = usdValue,\n        vaultTokenAmountReceived = vaultTokenAmountReceived,\n        recipient = _recipient,\n    )\n    return depositAmount, vaultToken, vaultTokenAmountReceived, usdValue\n\n\n# asset verification\n\n\n@internal\ndef _getVaultTokenOnDeposit(_asset: address, _vaultAddr: address, _ledger: address, _legoBook: address) -> address:\n    asset: address = yld.vaultToAsset[_vaultAddr]\n    isRegistered: bool = True\n\n    # not yet registered, call morpho directly to get asset\n    if asset == empty(address) and self._isValidMorphoVault(_vaultAddr):\n        asset = staticcall IERC4626(_vaultAddr).asset()\n        isRegistered = False\n\n    assert asset != empty(address) # dev: invalid asset\n    assert asset == _asset # dev: asset mismatch\n\n    # register if necessary\n    if not isRegistered:\n        self._registerAsset(asset, _vaultAddr)\n        self._updateLedgerVaultToken(asset, _vaultAddr, _ledger, _legoBook)\n\n    return _vaultAddr\n\n\n# withdraw\n\n\n@external\ndef withdrawFromYield(\n    _vaultToken: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, address, uint256, uint256):\n    assert not yld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = yld._getMiniAddys(_miniAddys)\n\n    # verify asset (register if necessary)\n    asset: address = self._getAssetOnWithdraw(_vaultToken, miniAddys.ledger, miniAddys.legoBook)\n\n    # pre balances\n    preLegoVaultBalance: uint256 = staticcall IERC20(_vaultToken).balanceOf(self)\n\n    # transfer vaults tokens to this contract\n    vaultTokenAmount: uint256 = min(_amount, staticcall IERC20(_vaultToken).balanceOf(msg.sender))\n    assert vaultTokenAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_vaultToken).transferFrom(msg.sender, self, vaultTokenAmount, default_return_value=True) # dev: transfer failed\n\n    # withdraw assets from lego partner\n    assetAmountReceived: uint256 = extcall IERC4626(_vaultToken).redeem(vaultTokenAmount, _recipient, self)\n    assert assetAmountReceived != 0 # dev: no asset amount received\n\n    # refund if full withdrawal didn't happen\n    currentLegoVaultBalance: uint256 = staticcall IERC20(_vaultToken).balanceOf(self)\n    refundVaultTokenAmount: uint256 = 0\n    if currentLegoVaultBalance > preLegoVaultBalance:\n        refundVaultTokenAmount = currentLegoVaultBalance - preLegoVaultBalance\n        assert extcall IERC20(_vaultToken).transfer(msg.sender, refundVaultTokenAmount, default_return_value=True) # dev: transfer failed\n        vaultTokenAmount -= refundVaultTokenAmount\n\n    usdValue: uint256 = extcall Appraiser(miniAddys.appraiser).updatePriceAndGetUsdValue(asset, assetAmountReceived, miniAddys.missionControl, miniAddys.legoBook)\n    log MorphoWithdrawal(\n        sender = msg.sender,\n        asset = asset,\n        vaultToken = _vaultToken,\n        assetAmountReceived = assetAmountReceived,\n        usdValue = usdValue,\n        vaultTokenAmountBurned = vaultTokenAmount,\n        recipient = _recipient,\n    )\n    return vaultTokenAmount, asset, assetAmountReceived, usdValue\n\n\n# vault token verification\n\n\n@internal\ndef _getAssetOnWithdraw(_vaultToken: address, _ledger: address, _legoBook: address) -> address:\n    asset: address = yld.vaultToAsset[_vaultToken]\n    isRegistered: bool = True\n\n    # not yet registered, call morpho directly to get asset\n    if asset == empty(address) and self._isValidMorphoVault(_vaultToken):\n        asset = staticcall IERC4626(_vaultToken).asset()\n        isRegistered = False\n\n    assert asset != empty(address) # dev: invalid asset\n\n    # register if necessary\n    if not isRegistered:\n        self._registerAsset(asset, _vaultToken)\n        self._updateLedgerVaultToken(asset, _vaultToken, _ledger, _legoBook)\n\n    return asset\n\n\n#################\n# Claim Rewards #\n#################\n\n\n@external\ndef claimRewards(\n    _user: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _extraData: bytes32,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    assert not yld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = yld._getMiniAddys(_miniAddys)\n\n    assert msg.sender == _user # dev: recipient must be caller\n    morphoRewards: address = self.morphoRewards\n    assert morphoRewards != empty(address) # dev: no morpho rewards addr set\n\n    rewardAmount: uint256 = extcall MorphoRewardsDistributor(morphoRewards).claim(_user, _rewardToken, _rewardAmount, _extraData)\n    usdValue: uint256 = extcall Appraiser(miniAddys.appraiser).updatePriceAndGetUsdValue(_rewardToken, rewardAmount, miniAddys.missionControl, miniAddys.legoBook)\n    return rewardAmount, usdValue\n\n\n@view\n@external\ndef hasClaimableRewards(_user: address) -> bool:\n    # as far as we can tell, this must be done offchain\n    return False\n\n\n# set rewards addr\n\n\n@external\ndef setMorphoRewardsAddr(_addr: address) -> bool:\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert _addr != empty(address) # dev: invalid addr\n    self.morphoRewards = _addr\n    log MorphoRewardsAddrSet(addr=_addr)\n    return True\n\n\n#############\n# Utilities #\n#############\n\n\n# underlying asset\n\n\n@view\n@external\ndef isVaultToken(_vaultToken: address) -> bool:\n    return self._isVaultToken(_vaultToken)\n\n\n@view\n@internal\ndef _isVaultToken(_vaultToken: address) -> bool:\n    if yld.vaultToAsset[_vaultToken] != empty(address):\n        return True\n    return self._isValidMorphoVault(_vaultToken)\n\n\n@view\n@internal\ndef _isValidMorphoVault(_vaultToken: address) -> bool:\n    return staticcall MetaMorphoFactory(MORPHO_FACTORY).isMetaMorpho(_vaultToken) or staticcall MetaMorphoFactory(MORPHO_FACTORY_LEGACY).isMetaMorpho(_vaultToken)\n\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    return self._getUnderlyingAsset(_vaultToken)\n\n\n@view\n@internal\ndef _getUnderlyingAsset(_vaultToken: address) -> address:\n    asset: address = yld.vaultToAsset[_vaultToken]\n    if asset == empty(address) and self._isValidMorphoVault(_vaultToken):\n        asset = staticcall IERC4626(_vaultToken).asset()\n    return asset\n\n\n# underlying amount\n\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    if not self._isVaultToken(_vaultToken) or _vaultTokenAmount == 0:\n        return 0 # invalid vault token or amount\n    return self._getUnderlyingAmount(_vaultToken, _vaultTokenAmount)\n\n\n@view\n@internal\ndef _getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    return staticcall IERC4626(_vaultToken).convertToAssets(_vaultTokenAmount)\n\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    if empty(address) in [_asset, _vaultToken] or _assetAmount == 0:\n        return 0 # bad inputs\n    if self._getUnderlyingAsset(_vaultToken) != _asset:\n        return 0 # invalid vault token or asset\n    return staticcall IERC4626(_vaultToken).convertToShares(_assetAmount)\n\n\n# usd value\n\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> uint256:\n    return self._getUsdValueOfVaultToken(_vaultToken, _vaultTokenAmount, _appraiser)\n\n\n@view\n@internal\ndef _getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address) -> uint256:\n    asset: address = empty(address)\n    underlyingAmount: uint256 = 0\n    usdValue: uint256 = 0\n    asset, underlyingAmount, usdValue = self._getUnderlyingData(_vaultToken, _vaultTokenAmount, _appraiser)\n    return usdValue\n\n\n# all underlying data together\n\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> (address, uint256, uint256):\n    return self._getUnderlyingData(_vaultToken, _vaultTokenAmount, _appraiser)\n\n\n@view\n@internal\ndef _getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address) -> (address, uint256, uint256):\n    if _vaultTokenAmount == 0 or _vaultToken == empty(address):\n        return empty(address), 0, 0 # bad inputs\n    asset: address = self._getUnderlyingAsset(_vaultToken)\n    if asset == empty(address):\n        return empty(address), 0, 0 # invalid vault token\n    underlyingAmount: uint256 = self._getUnderlyingAmount(_vaultToken, _vaultTokenAmount)\n    usdValue: uint256 = self._getUsdValue(asset, underlyingAmount, _appraiser)\n    return asset, underlyingAmount, usdValue\n\n\n@view\n@internal\ndef _getUsdValue(_asset: address, _amount: uint256, _appraiser: address) -> uint256:\n    appraiser: address = _appraiser\n    if _appraiser == empty(address):\n        appraiser = addys._getAppraiserAddr()\n    return staticcall Appraiser(appraiser).getUsdValue(_asset, _amount)\n\n\n# other\n\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    if not self._isVaultToken(_vaultToken):\n        return 0 # invalid vault token\n    return staticcall IERC4626(_vaultToken).totalAssets()\n\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    return 0 # TODO\n\n\n# price per share\n\n\n@view\n@external\ndef getPricePerShare(_asset: address, _decimals: uint256) -> uint256:\n    return staticcall IERC4626(_asset).convertToAssets(10 ** _decimals)\n\n\n################\n# Registration #\n################\n\n\n@external\ndef addAssetOpportunity(_asset: address, _vaultAddr: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert self._isValidAssetOpportunity(_asset, _vaultAddr) # dev: invalid asset or vault\n    assert not yld._isAssetOpportunity(_asset, _vaultAddr) # dev: already registered\n    self._registerAsset(_asset, _vaultAddr)\n\n\n@internal\ndef _registerAsset(_asset: address, _vaultAddr: address):\n    assert extcall IERC20(_asset).approve(_vaultAddr, max_value(uint256), default_return_value=True) # dev: max approval failed\n    yld._addAssetOpportunity(_asset, _vaultAddr)\n\n\n@external\ndef removeAssetOpportunity(_asset: address, _vaultAddr: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert extcall IERC20(_asset).approve(_vaultAddr, 0, default_return_value=True) # dev: max approval failed\n    yld._removeAssetOpportunity(_asset, _vaultAddr)\n\n\n# validation\n\n\n@view\n@internal\ndef isValidAssetOpportunity(_asset: address, _vaultAddr: address) -> bool:\n    return self._isValidAssetOpportunity(_asset, _vaultAddr)\n\n\n@view\n@internal\ndef _isValidAssetOpportunity(_asset: address, _vaultAddr: address) -> bool:\n    return self._isValidMorphoVault(_vaultAddr) and staticcall IERC4626(_vaultAddr).asset() == _asset\n\n\n# update ledger registration\n\n\n@internal\ndef _updateLedgerVaultToken(\n    _underlyingAsset: address,\n    _vaultToken: address,\n    _ledger: address,\n    _legoBook: address,\n):\n    if empty(address) in [_underlyingAsset, _vaultToken]:\n        return\n\n    if not staticcall Ledger(_ledger).isRegisteredVaultToken(_vaultToken):\n        legoId: uint256 = staticcall Registry(_legoBook).getRegId(self)\n        decimals: uint256 = convert(staticcall IERC20Detailed(_vaultToken).decimals(), uint256)\n        extcall Ledger(_ledger).setVaultToken(_vaultToken, legoId, _underlyingAsset, decimals, self._isRebasing())\n\n\n#########\n# Other #\n#########\n\n\n@external\ndef swapTokens(\n    _amountIn: uint256,\n    _minAmountOut: uint256,\n    _tokenPath: DynArray[address, MAX_TOKEN_PATH],\n    _poolPath: DynArray[address, MAX_TOKEN_PATH - 1],\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256):\n    return 0, 0, 0\n\n\n@external\ndef mintOrRedeemAsset(\n    _tokenIn: address,\n    _tokenOut: address,\n    _tokenInAmount: uint256,\n    _minAmountOut: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, bool, uint256):\n    return 0, 0, False, 0\n\n\n@external\ndef confirmMintOrRedeemAsset(\n    _tokenIn: address,\n    _tokenOut: address,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef addCollateral(\n    _asset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef removeCollateral(\n    _asset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef borrow(\n    _borrowAsset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef repayDebt(\n    _paymentAsset: address,\n    _paymentAmount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef addLiquidity(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _amountA: uint256,\n    _amountB: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _minLpAmount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (address, uint256, uint256, uint256, uint256):\n    return empty(address), 0, 0, 0, 0\n\n\n@external\ndef removeLiquidity(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpToken: address,\n    _lpAmount: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, uint256):\n    return 0, 0, 0, 0\n\n\n@external\ndef addLiquidityConcentrated(\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _tickLower: int24,\n    _tickUpper: int24,\n    _amountA: uint256,\n    _amountB: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, uint256, uint256):\n    return 0, 0, 0, 0, 0\n\n\n@external\ndef removeLiquidityConcentrated(\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _liqToRemove: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, bool, uint256):\n    return 0, 0, 0, False, 0\n\n\n@view\n@external\ndef getAccessForLego(_user: address, _action: ws.ActionType) -> (address, String[64], uint256):\n    return empty(address), empty(String[64]), 0\n\n\n@view\n@external\ndef getPrice(_asset: address, _decimals: uint256) -> uint256:\n    return 0\n",
            "sha256sum": "2b624d92e11d0f3831809378bf97e73ec6efac615141d2fd89eaf5ee6b8e84f7"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/legos/yield/Morpho.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.3+commit.bff19ea2",
        "integrity": "491367e63967047490e314543eba22eb28d2114034355560f6f3bb5f1cbe06b8"
      },
      "args": "00000000000000000000000044cf3c4f000dfd76a35d03298049d37be688d6f9000000000000000000000000ff62a7c278c62ed665133147129245053bbf5918000000000000000000000000a9c3d3a366466fa809d1ae982fb2c46e5fc41101000000000000000000000000330eefa8a787552dc5cad3c3ca644844b1e61ddb",
      "file": "contracts/legos/yield/Morpho.vy"
    },
    "AeroClassic": {
      "address": "0x15099c548DDE962ca9Bf520A771fB523818261C3",
      "abi": [
        {
          "name": "AerodromeSwap",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenIn",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenOut",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amountIn",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "amountOut",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "numTokens",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AerodromeLiquidityAdded",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenA",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenB",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amountA",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "amountB",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "lpAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AerodromeLiquidityRemoved",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": false
            },
            {
              "name": "pool",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenA",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenB",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amountA",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "amountB",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "lpToken",
              "type": "address",
              "indexed": false
            },
            {
              "name": "lpAmountBurned",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LegoPauseModified",
          "inputs": [
            {
              "name": "isPaused",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LegoFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "balance",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddys",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "undyToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "hatchery",
                  "type": "address"
                },
                {
                  "name": "lootDistributor",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                },
                {
                  "name": "walletBackpack",
                  "type": "address"
                },
                {
                  "name": "billing",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUndyHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pause",
          "inputs": [
            {
              "name": "_shouldPause",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFundsMany",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_assets",
              "type": "address[]"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "legoId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isPaused",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasCapability",
          "inputs": [
            {
              "name": "_action",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRegistries",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isYieldLego",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isDexLego",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_tokenPath",
              "type": "address[]"
            },
            {
              "name": "_poolPath",
              "type": "address[]"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_tokenPath",
              "type": "address[]"
            },
            {
              "name": "_poolPath",
              "type": "address[]"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLpToken",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPoolForLpToken",
          "inputs": [
            {
              "name": "_lpToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getCoreRouterPool",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getDeepestLiqPool",
          "inputs": [
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "fee",
                  "type": "uint256"
                },
                {
                  "name": "liquidity",
                  "type": "uint256"
                },
                {
                  "name": "numCoins",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getBestSwapAmountOut",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountIn",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getSwapAmountOut",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountIn",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getBestSwapAmountIn",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountOut",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getSwapAmountIn",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountOut",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddLiqAmountsIn",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_availAmountA",
              "type": "uint256"
            },
            {
              "name": "_availAmountB",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRemoveLiqAmountsOut",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPrice",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_decimals",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPriceUnsafe",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_targetToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPriceUnsafe",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_targetToken",
              "type": "address"
            },
            {
              "name": "_appraiser",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositForYield",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositForYield",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawFromYield",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawFromYield",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_tokenInAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_tokenInAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmMintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmMintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_borrowAsset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_borrowAsset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_paymentAsset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_paymentAsset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAccessForLego",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_action",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "string"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPricePerShare",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_decimals",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "AERODROME_FACTORY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "AERODROME_ROUTER",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "coreRouterPool",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_undyHq",
              "type": "address"
            },
            {
              "name": "_aerodromeFactory",
              "type": "address"
            },
            {
              "name": "_aerodromeRouter",
              "type": "address"
            },
            {
              "name": "_coreRouterPool",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "interfaces/WalletStructs.vyi": {
            "content": "# @version 0.4.3\n\nflag ActionType:\n    TRANSFER\n    EARN_DEPOSIT\n    EARN_WITHDRAW\n    EARN_REBALANCE\n    SWAP\n    MINT_REDEEM\n    CONFIRM_MINT_REDEEM\n    ADD_COLLATERAL\n    REMOVE_COLLATERAL\n    BORROW\n    REPAY_DEBT\n    REWARDS\n    ETH_TO_WETH\n    WETH_TO_ETH\n    ADD_LIQ\n    REMOVE_LIQ\n    ADD_LIQ_CONC\n    REMOVE_LIQ_CONC\n    PAY_CHEQUE\n\nstruct WalletAssetData:\n    assetBalance: uint256\n    usdValue: uint256\n    isYieldAsset: bool\n    lastPricePerShare: uint256\n\nstruct ActionData:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    billing: address\n    wallet: address\n    walletConfig: address\n    walletOwner: address\n    inEjectMode: bool\n    isFrozen: bool\n    lastTotalUsdValue: uint256\n    signer: address\n    isManager: bool\n    legoId: uint256\n    legoAddr: address\n    eth: address\n    weth: address\n\nstruct MiniAddys:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    appraiser: address",
            "sha256sum": "9a4b4f59b3a62043e51b425a665064aae419a3c0bd0514b6b29a9441ae364bb9"
          },
          "interfaces/LegoPartner.vyi": {
            "content": "# @version 0.4.3\n\nfrom interfaces import WalletStructs as ws\n\nMAX_TOKEN_PATH: constant(uint256) = 5\nMAX_RECOVER_ASSETS: constant(uint256) = 20\n\n@external\ndef addLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _tickLower: int24, _tickUpper: int24, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef addLiquidity(_pool: address, _tokenA: address, _tokenB: address, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _minLpAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (address, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef removeLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _liqToRemove: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef removeLiquidity(_pool: address, _tokenA: address, _tokenB: address, _lpToken: address, _lpAmount: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef mintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _tokenInAmount: uint256, _minAmountOut: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef swapTokens(_amountIn: uint256, _minAmountOut: uint256, _tokenPath: DynArray[address, MAX_TOKEN_PATH], _poolPath: DynArray[address, MAX_TOKEN_PATH - 1], _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256):\n    ...\n\n@external\ndef depositForYield(_asset: address, _amount: uint256, _vaultAddr: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef withdrawFromYield(_vaultToken: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef confirmMintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef borrow(_borrowAsset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef repayDebt(_paymentAsset: address, _paymentAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef claimRewards(_user: address, _rewardToken: address, _rewardAmount: uint256, _extraData: bytes32, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef removeCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef addCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@view\n@external\ndef getAccessForLego(_user: address, _action: ws.ActionType) -> (address, String[64], uint256):\n    ...\n\n@view\n@external\ndef hasCapability(_action: ws.ActionType) -> bool:\n    ...\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    ...\n\n@view\n@external\ndef isYieldLego() -> bool:\n    ...\n\n@view\n@external\ndef isDexLego() -> bool:\n    ...\n\n@view\n@external\ndef getPricePerShare(_asset: address, _decimals: uint256) -> uint256:\n    ...\n\n@view\n@external\ndef getPrice(_asset: address, _decimals: uint256) -> uint256:\n    ...\n\n\n# common\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "2513e379aa74d0a8120114a5078a4c1a0900165a1c3f24419bb811d173b56453"
          },
          "interfaces/DexLego.vyi": {
            "content": "# @version 0.4.3\n\n# used in smart contracts\n\n\n@view\n@external\ndef getLpToken(_pool: address) -> address:\n    ...\n\n\n# helper functions for server\n\n\n@view\n@external\ndef getPoolForLpToken(_lpToken: address) -> address:\n    ...\n\n\n@view\n@external\ndef getSwapAmountOut(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n) -> uint256:\n    ...\n\n\n@view\n@external\ndef getSwapAmountIn(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountOut: uint256,\n) -> uint256:\n    ...\n\n\n@view\n@external\ndef getAddLiqAmountsIn(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _availAmountA: uint256,\n    _availAmountB: uint256,\n) -> (uint256, uint256, uint256):\n    ...\n\n\n@view\n@external\ndef getRemoveLiqAmountsOut(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpAmount: uint256,\n) -> (uint256, uint256):\n    ...\n\n\n@view\n@external\ndef getPriceUnsafe(_pool: address, _targetToken: address, _appraiser: address = empty(address)) -> uint256:\n    ...\n\n\n@view\n@external\ndef getBestSwapAmountOut(_tokenIn: address, _tokenOut: address, _amountIn: uint256) -> (address, uint256):\n    ...\n\n\n@view\n@external\ndef getBestSwapAmountIn(_tokenIn: address, _tokenOut: address, _amountOut: uint256) -> (address, uint256):\n    ...\n\n\n@view\n@external\ndef getCoreRouterPool() -> address:\n    ...\n",
            "sha256sum": "44b192d0249c04d635acb9c758c41ebba7014d9287315bc1f7a7cb2646e69631"
          },
          "contracts/modules/Addys.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\ninterface UndyHq:\n    def isValidAddr(_addr: address) -> bool: view\n    def getAddr(_regId: uint256) -> address: view\n    def undyToken() -> address: view\n\ninterface Switchboard:\n    def isSwitchboardAddr(_addr: address) -> bool: view\n\ninterface LegoBook:\n    def isLegoAddr(_addr: address) -> bool: view\n\nstruct Addys:\n    hq: address\n    undyToken: address\n    ledger: address\n    missionControl: address\n    legoBook: address\n    switchboard: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    walletBackpack: address\n    billing: address\n\n# hq\nUNDY_HQ_FOR_ADDYS: immutable(address)\n\n# core addys\nLEDGER_ID: constant(uint256) = 1\nMISSION_CONTROL_ID: constant(uint256) = 2\nLEGO_BOOK_ID: constant(uint256) = 3\nSWITCHBOARD_ID: constant(uint256) = 4\nHATCHERY_ID: constant(uint256) = 5\nLOOT_DISTRIBUTOR_ID: constant(uint256) = 6\nAPPRAISER_ID: constant(uint256) = 7\nWALLET_BACKPACK_ID: constant(uint256) = 8\nBILLING_ID: constant(uint256) = 9\n\n\n@deploy\ndef __init__(_undyHq: address):\n    assert _undyHq != empty(address) # dev: invalid undy hq\n    UNDY_HQ_FOR_ADDYS = _undyHq\n\n\n########\n# Core #\n########\n\n\n@view\n@external\ndef getAddys() -> Addys:\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _getAddys(_addys: Addys = empty(Addys)) -> Addys:\n    if _addys.hq != empty(address):\n        return _addys\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _generateAddys() -> Addys:\n    hq: address = UNDY_HQ_FOR_ADDYS\n    return Addys(\n        hq = hq,\n        undyToken = staticcall UndyHq(hq).undyToken(),\n        ledger = staticcall UndyHq(hq).getAddr(LEDGER_ID),\n        missionControl = staticcall UndyHq(hq).getAddr(MISSION_CONTROL_ID),\n        legoBook = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID),\n        switchboard = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID),\n        hatchery = staticcall UndyHq(hq).getAddr(HATCHERY_ID),\n        lootDistributor = staticcall UndyHq(hq).getAddr(LOOT_DISTRIBUTOR_ID),\n        appraiser = staticcall UndyHq(hq).getAddr(APPRAISER_ID),\n        walletBackpack = staticcall UndyHq(hq).getAddr(WALLET_BACKPACK_ID),\n        billing = staticcall UndyHq(hq).getAddr(BILLING_ID),\n    )\n\n\n##########\n# Tokens #\n##########\n\n\n@view\n@internal\ndef _getUndyToken() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).undyToken()\n\n\n###########\n# Helpers #\n###########\n\n\n# undy hq\n\n\n@view\n@external\ndef getUndyHq() -> address:\n    return self._getUndyHq()\n\n\n@view\n@internal\ndef _getUndyHq() -> address:\n    return UNDY_HQ_FOR_ADDYS\n\n\n# utils\n\n\n@view\n@internal\ndef _isValidUndyAddr(_addr: address, _hq: address = empty(address)) -> bool:\n    hq: address = _hq\n    if _hq == empty(address):\n        hq = UNDY_HQ_FOR_ADDYS\n    \n    # core departments\n    if staticcall UndyHq(hq).isValidAddr(_addr):\n        return True\n\n    # lego book\n    legoBook: address = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID)\n    if legoBook != empty(address) and staticcall LegoBook(legoBook).isLegoAddr(_addr):\n        return True\n\n    # switchboard config\n    switchboard: address = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID)\n    if switchboard != empty(address) and staticcall Switchboard(switchboard).isSwitchboardAddr(_addr):\n        return True\n\n    return False\n\n\n@view\n@internal\ndef _isSwitchboardAddr(_addr: address) -> bool:\n    switchboard: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n    if switchboard == empty(address):\n        return False\n    return staticcall Switchboard(switchboard).isSwitchboardAddr(_addr)\n\n\n@view\n@internal\ndef _isLegoBookAddr(_addr: address) -> bool:\n    legoBook: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n    if legoBook == empty(address):\n        return False\n    return staticcall LegoBook(legoBook).isLegoAddr(_addr)\n\n\n###############\n# Departments #\n###############\n\n\n# ledger\n\n\n@view\n@internal\ndef _getLedgerId() -> uint256:\n    return LEDGER_ID\n\n\n@view\n@internal\ndef _getLedgerAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEDGER_ID)\n\n\n# mission control\n\n\n@view\n@internal\ndef _getMissionControlId() -> uint256:\n    return MISSION_CONTROL_ID\n\n\n@view\n@internal\ndef _getMissionControlAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(MISSION_CONTROL_ID)\n\n\n# lego book\n\n\n@view\n@internal\ndef _getLegoBookId() -> uint256:\n    return LEGO_BOOK_ID\n\n\n@view\n@internal\ndef _getLegoBookAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n\n\n# switchboard\n\n\n@view\n@internal\ndef _getSwitchboardId() -> uint256:\n    return SWITCHBOARD_ID\n\n\n@view\n@internal\ndef _getSwitchboardAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n\n\n# hatchery\n\n\n@view\n@internal\ndef _getHatcheryId() -> uint256:\n    return HATCHERY_ID\n\n\n@view\n@internal\ndef _getHatcheryAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(HATCHERY_ID)\n\n\n# loot distributor\n\n\n@view\n@internal\ndef _getLootDistributorId() -> uint256:\n    return LOOT_DISTRIBUTOR_ID\n\n\n@view\n@internal\ndef _getLootDistributorAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LOOT_DISTRIBUTOR_ID)\n\n\n# appraiser\n\n\n@view\n@internal\ndef _getAppraiserId() -> uint256:\n    return APPRAISER_ID\n\n\n@view\n@internal\ndef _getAppraiserAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(APPRAISER_ID)\n\n\n# wallet backpack\n\n\n@view\n@internal\ndef _getWalletBackpackId() -> uint256:\n    return WALLET_BACKPACK_ID\n\n\n@view\n@internal\ndef _getWalletBackpackAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(WALLET_BACKPACK_ID)\n\n\n# billing\n\n\n@view\n@internal\ndef _getBillingId() -> uint256:\n    return BILLING_ID\n\n\n@view\n@internal\ndef _getBillingAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(BILLING_ID)",
            "sha256sum": "78b58f0b2acb2eaafa4d21adf9135a1cd0e1d53897f7a1fa70a83a04a7738ad3"
          },
          "contracts/modules/DexLegoData.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nuses: addys\n\nimport contracts.modules.Addys as addys\n\nfrom interfaces import WalletStructs as ws\nfrom ethereum.ercs import IERC20\n\nevent LegoPauseModified:\n    isPaused: bool\n\nevent LegoFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    balance: uint256\n\n# config\nlegoId: public(uint256)\nisPaused: public(bool)\n\nMAX_RECOVER_ASSETS: constant(uint256) = 20\n\n\n@deploy\ndef __init__(_shouldPause: bool):\n    self.isPaused = _shouldPause\n\n\n###########\n# General #\n###########\n\n\n# fill mini addys\n\n\n@view\n@internal\ndef _getMiniAddys(_miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> ws.MiniAddys:\n    if _miniAddys.ledger != empty(address):\n        return _miniAddys\n    return ws.MiniAddys(\n        ledger = addys._getLedgerAddr(),\n        missionControl = addys._getMissionControlAddr(),\n        legoBook = addys._getLegoBookAddr(),\n        appraiser = addys._getAppraiserAddr(),\n    )\n\n\n# activate\n\n\n@external\ndef pause(_shouldPause: bool):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert _shouldPause != self.isPaused # dev: no change\n    self.isPaused = _shouldPause\n    log LegoPauseModified(isPaused=_shouldPause)\n\n\n# recover funds\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    self._recoverFunds(_recipient, _asset)\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, MAX_RECOVER_ASSETS]):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    for a: address in _assets:\n        self._recoverFunds(_recipient, a)\n\n\n@internal\ndef _recoverFunds(_recipient: address, _asset: address):\n    assert empty(address) not in [_recipient, _asset] # dev: invalid recipient or asset\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    assert balance != 0 # dev: nothing to recover\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log LegoFundsRecovered(asset=_asset, recipient=_recipient, balance=balance)",
            "sha256sum": "75b15af2475ab409d4b5fd057509d14c20564ebd7fcb0850e3b61397d8e3af48"
          },
          "contracts/legos/dexes/AeroClassic.vy": {
            "content": "#     _____  _____  __  __    ____   _____  _____  _____ \n#    |  _  \\/   __\\/  \\/  \\  /  _/  /   __\\/   __\\/  _  \\\n#    |  |  ||   __|>-    -<  |  |---|   __||  |_ ||  |  |\n#    |_____/\\_____/\\__/\\__/  \\_____/\\_____/\\_____/\\_____/\n#                                                                       \n#     \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n#     \u2551  ** Aero Classic Lego **                \u2551\n#     \u2551  Integration with Aerodrome Classic.    \u2551\n#     \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n#\n#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nimplements: Lego\nimplements: DexLego\n\nexports: addys.__interface__\nexports: dld.__interface__\n\ninitializes: addys\ninitializes: dld[addys := addys]\n\nfrom interfaces import LegoPartner as Lego\nfrom interfaces import DexLego as DexLego\nfrom interfaces import WalletStructs as ws\n\nimport contracts.modules.Addys as addys\nimport contracts.modules.DexLegoData as dld\n\nfrom ethereum.ercs import IERC20\nfrom ethereum.ercs import IERC20Detailed\n\ninterface AeroRouter:\n    def addLiquidity(_tokenA: address, _tokenB: address, _isStable: bool, _amountADesired: uint256, _amountBDesired: uint256, _amountAMin: uint256, _amountBMin: uint256, _recipient: address, _deadline: uint256) -> (uint256, uint256, uint256): nonpayable\n    def removeLiquidity(_tokenA: address, _tokenB: address, _isStable: bool, _lpAmount: uint256, _amountAMin: uint256, _amountBMin: uint256, _recipient: address, _deadline: uint256) -> (uint256, uint256): nonpayable\n    def quoteAddLiquidity(_tokenA: address, _tokenB: address, _isStable: bool, _factory: address, _amountADesired: uint256, _amountBDesired: uint256) -> (uint256, uint256, uint256): view\n    def swapExactTokensForTokens(_amountIn: uint256, _amountOutMin: uint256, _path: DynArray[Route, 10], _to: address, _deadline: uint256) -> DynArray[uint256, 10]: nonpayable\n    def quoteRemoveLiquidity(_tokenA: address, _tokenB: address, _isStable: bool, _factory: address, _liquidity: uint256) -> (uint256, uint256): view\n\ninterface AeroClassicPool:\n    def swap(_amount0Out: uint256, _amount1Out: uint256, _recipient: address, _data: Bytes[256]): nonpayable\n    def getAmountOut(_amountIn: uint256, _tokenIn: address) -> uint256: view\n    def getReserves() -> (uint256, uint256, uint256): view\n    def tokens() -> (address, address): view\n    def stable() -> bool: view\n\ninterface Appraiser:\n    def getNormalAssetPrice(_asset: address, _missionControl: address = empty(address), _legoBook: address = empty(address), _ledger: address = empty(address)) -> uint256: view\n    def updatePriceAndGetUsdValue(_asset: address, _amount: uint256, _missionControl: address = empty(address), _legoBook: address = empty(address)) -> uint256: nonpayable\n\ninterface AeroFactory:\n    def getPool(_tokenA: address, _tokenB: address, _isStable: bool) -> address: view\n    def getFee(_pool: address, _isStable: bool) -> uint256: view\n\nstruct BestPool:\n    pool: address\n    fee: uint256\n    liquidity: uint256\n    numCoins: uint256\n\nstruct Route:\n    from_: address\n    to: address \n    stable: bool\n    factory: address\n\nevent AerodromeSwap:\n    sender: indexed(address)\n    tokenIn: indexed(address)\n    tokenOut: indexed(address)\n    amountIn: uint256\n    amountOut: uint256\n    usdValue: uint256\n    numTokens: uint256\n    recipient: address\n\nevent AerodromeLiquidityAdded:\n    sender: indexed(address)\n    tokenA: indexed(address)\n    tokenB: indexed(address)\n    amountA: uint256\n    amountB: uint256\n    lpAmountReceived: uint256\n    usdValue: uint256\n    recipient: address\n\nevent AerodromeLiquidityRemoved:\n    sender: address\n    pool: indexed(address)\n    tokenA: indexed(address)\n    tokenB: indexed(address)\n    amountA: uint256\n    amountB: uint256\n    lpToken: address\n    lpAmountBurned: uint256\n    usdValue: uint256\n    recipient: address\n\n# aero\nAERODROME_FACTORY: public(immutable(address))\nAERODROME_ROUTER: public(immutable(address))\ncoreRouterPool: public(address)\n\nMAX_TOKEN_PATH: constant(uint256) = 5\nEIGHTEEN_DECIMALS: constant(uint256) = 10 ** 18\n\n\n@deploy\ndef __init__(\n    _undyHq: address,\n    _aerodromeFactory: address,\n    _aerodromeRouter: address,\n    _coreRouterPool: address,\n):\n    addys.__init__(_undyHq)\n    dld.__init__(False)\n\n    assert empty(address) not in [_aerodromeFactory, _aerodromeRouter, _coreRouterPool] # dev: invalid addrs\n    AERODROME_FACTORY = _aerodromeFactory\n    AERODROME_ROUTER = _aerodromeRouter\n    self.coreRouterPool = _coreRouterPool\n\n\n@view\n@external\ndef hasCapability(_action: ws.ActionType) -> bool:\n    return _action in (\n        ws.ActionType.SWAP |\n        ws.ActionType.ADD_LIQ | \n        ws.ActionType.REMOVE_LIQ\n    )\n\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    return [AERODROME_FACTORY, AERODROME_ROUTER]\n\n\n@view\n@external\ndef isYieldLego() -> bool:\n    return False\n\n\n@view\n@external\ndef isDexLego() -> bool:\n    return True\n\n\n#########\n# Swaps #\n#########\n\n\n@external\ndef swapTokens(\n    _amountIn: uint256,\n    _minAmountOut: uint256,\n    _tokenPath: DynArray[address, MAX_TOKEN_PATH],\n    _poolPath: DynArray[address, MAX_TOKEN_PATH - 1],\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256):\n    assert not dld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = dld._getMiniAddys(_miniAddys)\n\n    # validate inputs\n    numTokens: uint256 = len(_tokenPath)\n    numPools: uint256 = len(_poolPath)\n    assert numTokens >= 2 # dev: invalid path\n    assert numPools == numTokens - 1 # dev: invalid path\n\n    # get first token and last token\n    tokenIn: address = _tokenPath[0]\n    tokenOut: address = _tokenPath[numTokens - 1]\n\n    # pre balances\n    preLegoBalance: uint256 = staticcall IERC20(tokenIn).balanceOf(self)\n\n    # transfer deposit asset to this contract\n    amountIn: uint256 = min(_amountIn, staticcall IERC20(tokenIn).balanceOf(msg.sender))\n    assert amountIn != 0 # dev: nothing to transfer\n    assert extcall IERC20(tokenIn).transferFrom(msg.sender, self, amountIn, default_return_value=True) # dev: transfer failed\n\n    # transfer initial amount to first pool\n    assert extcall IERC20(tokenIn).transfer(_poolPath[0], amountIn, default_return_value=True) # dev: transfer failed\n\n    # iterate through swap routes\n    tempAmountIn: uint256 = amountIn\n    aeroFactory: address = AERODROME_FACTORY\n    for i: uint256 in range(numTokens - 1, bound=MAX_TOKEN_PATH):\n        tempTokenIn: address = _tokenPath[i]\n        tempTokenOut: address = _tokenPath[i + 1]\n        tempPool: address = _poolPath[i]\n\n        # transfer to next pool (or to recipient if last swap)\n        recipient: address = _recipient\n        if i < numTokens - 2:\n            recipient = _poolPath[i + 1]\n\n        # swap\n        tempAmountIn = self._swapTokensInPool(tempPool, tempTokenIn, tempTokenOut, tempAmountIn, recipient, aeroFactory)\n\n    # final amount\n    amountOut: uint256 = tempAmountIn\n    assert amountOut >= _minAmountOut # dev: min amount out not met\n\n    # refund if full swap didn't get through\n    currentLegoBalance: uint256 = staticcall IERC20(tokenIn).balanceOf(self)\n    refundAssetAmount: uint256 = 0\n    if currentLegoBalance > preLegoBalance:\n        refundAssetAmount = currentLegoBalance - preLegoBalance\n        assert extcall IERC20(tokenIn).transfer(msg.sender, refundAssetAmount, default_return_value=True) # dev: transfer failed\n        amountIn -= refundAssetAmount\n\n    # get usd values\n    usdValue: uint256 = extcall Appraiser(miniAddys.appraiser).updatePriceAndGetUsdValue(tokenIn, amountIn, miniAddys.missionControl, miniAddys.legoBook)\n    if usdValue == 0:\n        usdValue = extcall Appraiser(miniAddys.appraiser).updatePriceAndGetUsdValue(tokenOut, amountOut, miniAddys.missionControl, miniAddys.legoBook)\n\n    log AerodromeSwap(\n        sender = msg.sender,\n        tokenIn = tokenIn,\n        tokenOut = tokenOut,\n        amountIn = amountIn,\n        amountOut = amountOut,\n        usdValue = usdValue,\n        numTokens = numTokens,\n        recipient = _recipient,\n    )\n    return amountIn, amountOut, usdValue\n\n\n# swap in pool\n\n\n@internal\ndef _swapTokensInPool(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n    _recipient: address,\n    _aeroFactory: address,\n) -> uint256:\n    token0: address = empty(address)\n    token1: address = empty(address)\n    token0, token1 = staticcall AeroClassicPool(_pool).tokens()\n\n    tokens: address[2] = [token0, token1]\n    assert _tokenIn in tokens # dev: invalid tokenIn\n    assert _tokenOut in tokens # dev: invalid tokenOut\n    assert _tokenIn != _tokenOut # dev: invalid tokens\n\n    # verify actual aerodrome pool\n    assert staticcall AeroFactory(_aeroFactory).getPool(_tokenIn, _tokenOut, staticcall AeroClassicPool(_pool).stable()) == _pool # dev: invalid pool\n\n    zeroForOne: bool = _tokenIn == token0\n    amountOut: uint256 = staticcall AeroClassicPool(_pool).getAmountOut(_amountIn, _tokenIn)\n    assert amountOut != 0 # dev: no tokens swapped\n\n    # put in correct order\n    amount0Out: uint256 = amountOut\n    amount1Out: uint256 = 0\n    if zeroForOne:\n        amount0Out = 0\n        amount1Out = amountOut\n\n    extcall AeroClassicPool(_pool).swap(amount0Out, amount1Out, _recipient, b\"\")\n    return amountOut\n\n\n#############\n# Liquidity #\n#############\n\n\n# add liquidity\n\n\n@external\ndef addLiquidity(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _amountA: uint256,\n    _amountB: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _minLpAmount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (address, uint256, uint256, uint256, uint256):\n    assert not dld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = dld._getMiniAddys(_miniAddys)\n\n    # validate tokens\n    token0: address = empty(address)\n    token1: address = empty(address)\n    token0, token1 = staticcall AeroClassicPool(_pool).tokens()\n\n    tokens: address[2] = [token0, token1]\n    assert _tokenA in tokens # dev: invalid tokenA\n    assert _tokenB in tokens # dev: invalid tokenB\n    assert _tokenA != _tokenB # dev: invalid tokens\n\n    # pre balances\n    preLegoBalanceA: uint256 = staticcall IERC20(_tokenA).balanceOf(self)\n    preLegoBalanceB: uint256 = staticcall IERC20(_tokenB).balanceOf(self)\n\n    # token a\n    liqAmountA: uint256 = min(_amountA, staticcall IERC20(_tokenA).balanceOf(msg.sender))\n    assert liqAmountA != 0 # dev: nothing to transfer\n    assert extcall IERC20(_tokenA).transferFrom(msg.sender, self, liqAmountA, default_return_value=True) # dev: transfer failed\n\n    # token b\n    liqAmountB: uint256 = min(_amountB, staticcall IERC20(_tokenB).balanceOf(msg.sender))\n    assert liqAmountB != 0 # dev: nothing to transfer\n    assert extcall IERC20(_tokenB).transferFrom(msg.sender, self, liqAmountB, default_return_value=True) # dev: transfer failed\n\n    # approvals\n    router: address = AERODROME_ROUTER\n    assert extcall IERC20(_tokenA).approve(router, liqAmountA, default_return_value=True) # dev: approval failed\n    assert extcall IERC20(_tokenB).approve(router, liqAmountB, default_return_value=True) # dev: approval failed\n\n    # add liquidity\n    lpAmountReceived: uint256 = 0\n    liqAmountA, liqAmountB, lpAmountReceived = extcall AeroRouter(router).addLiquidity(\n        _tokenA,\n        _tokenB,\n        staticcall AeroClassicPool(_pool).stable(),\n        liqAmountA,\n        liqAmountB,\n        _minAmountA,\n        _minAmountB,\n        _recipient,\n        block.timestamp,\n    )\n    assert lpAmountReceived != 0 # dev: no liquidity added\n    if _minLpAmount != 0:\n        assert lpAmountReceived >= _minLpAmount # dev: insufficient liquidity added\n\n    # reset approvals\n    assert extcall IERC20(_tokenA).approve(router, 0, default_return_value=True) # dev: approval failed\n    assert extcall IERC20(_tokenB).approve(router, 0, default_return_value=True) # dev: approval failed\n\n    # refund if full liquidity was not added\n    currentLegoBalanceA: uint256 = staticcall IERC20(_tokenA).balanceOf(self)\n    refundAssetAmountA: uint256 = 0\n    if currentLegoBalanceA > preLegoBalanceA:\n        refundAssetAmountA = currentLegoBalanceA - preLegoBalanceA\n        assert extcall IERC20(_tokenA).transfer(msg.sender, refundAssetAmountA, default_return_value=True) # dev: transfer failed\n\n    currentLegoBalanceB: uint256 = staticcall IERC20(_tokenB).balanceOf(self)\n    refundAssetAmountB: uint256 = 0\n    if currentLegoBalanceB > preLegoBalanceB:\n        refundAssetAmountB = currentLegoBalanceB - preLegoBalanceB\n        assert extcall IERC20(_tokenB).transfer(msg.sender, refundAssetAmountB, default_return_value=True) # dev: transfer failed\n\n    usdValue: uint256 = self._getUsdValue(_tokenA, liqAmountA, _tokenB, liqAmountB, miniAddys)\n    log AerodromeLiquidityAdded(\n        sender = msg.sender,\n        tokenA = _tokenA,\n        tokenB = _tokenB,\n        amountA = liqAmountA,\n        amountB = liqAmountB,\n        lpAmountReceived = lpAmountReceived,\n        usdValue = usdValue,\n        recipient = _recipient,\n    )\n    return _pool, lpAmountReceived, liqAmountA, liqAmountB, usdValue\n\n\n# remove liquidity\n\n\n@external\ndef removeLiquidity(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpToken: address,\n    _lpAmount: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, uint256):\n    assert not dld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = dld._getMiniAddys(_miniAddys)\n\n    # validate tokens\n    token0: address = empty(address)\n    token1: address = empty(address)\n    token0, token1 = staticcall AeroClassicPool(_pool).tokens()\n\n    tokens: address[2] = [token0, token1]\n    assert _tokenA in tokens # dev: invalid tokenA\n    assert _tokenB in tokens # dev: invalid tokenB\n    assert _tokenA != _tokenB # dev: invalid tokens\n\n    # pre balance\n    preLegoBalance: uint256 = staticcall IERC20(_lpToken).balanceOf(self)\n\n    # lp token\n    lpAmount: uint256 = min(_lpAmount, staticcall IERC20(_lpToken).balanceOf(msg.sender))\n    assert lpAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_lpToken).transferFrom(msg.sender, self, lpAmount, default_return_value=True) # dev: transfer failed\n\n    # approvals\n    router: address = AERODROME_ROUTER\n    assert extcall IERC20(_lpToken).approve(router, lpAmount, default_return_value=True) # dev: approval failed\n\n    # remove liquidity\n    amountA: uint256 = 0\n    amountB: uint256 = 0\n    amountA, amountB = extcall AeroRouter(router).removeLiquidity(\n        _tokenA,\n        _tokenB,\n        staticcall AeroClassicPool(_pool).stable(),\n        lpAmount,\n        _minAmountA,\n        _minAmountB,\n        _recipient,\n        block.timestamp,\n    )\n    assert amountA != 0 # dev: no amountA removed\n    assert amountB != 0 # dev: no amountB removed\n\n    # reset approvals\n    assert extcall IERC20(_lpToken).approve(router, 0, default_return_value=True) # dev: approval failed\n\n    # refund if full liquidity was not removed\n    currentLegoBalance: uint256 = staticcall IERC20(_lpToken).balanceOf(self)\n    refundedLpAmount: uint256 = 0\n    if currentLegoBalance > preLegoBalance:\n        refundedLpAmount = currentLegoBalance - preLegoBalance\n        assert extcall IERC20(_lpToken).transfer(msg.sender, refundedLpAmount, default_return_value=True) # dev: transfer failed\n        lpAmount -= refundedLpAmount\n\n    usdValue: uint256 = self._getUsdValue(_tokenA, amountA, _tokenB, amountB, miniAddys)\n    log AerodromeLiquidityRemoved(\n        sender = msg.sender,\n        pool = _pool,\n        tokenA = _tokenA,\n        tokenB = _tokenB,\n        amountA = amountA,\n        amountB = amountB,\n        lpToken = _lpToken,\n        lpAmountBurned = lpAmount,\n        usdValue = usdValue,\n        recipient = _recipient,\n    )\n    return amountA, amountB, lpAmount, usdValue\n\n\n# get usd value on liquidity actions\n\n\n@internal\ndef _getUsdValue(\n    _tokenA: address,\n    _amountA: uint256,\n    _tokenB: address,\n    _amountB: uint256,\n    _miniAddys: ws.MiniAddys,\n) -> uint256:\n\n    usdValueA: uint256 = 0\n    if _amountA != 0:\n        usdValueA = extcall Appraiser(_miniAddys.appraiser).updatePriceAndGetUsdValue(_tokenA, _amountA, _miniAddys.missionControl, _miniAddys.legoBook)\n\n    usdValueB: uint256 = 0\n    if _amountB != 0:\n        usdValueB = extcall Appraiser(_miniAddys.appraiser).updatePriceAndGetUsdValue(_tokenB, _amountB, _miniAddys.missionControl, _miniAddys.legoBook)\n\n    return usdValueA + usdValueB\n\n\n#############\n# Utilities #\n#############\n\n\n@view\n@external\ndef getLpToken(_pool: address) -> address:\n    # in uniswap v2, the lp token is the pool address\n    return _pool\n\n\n@view\n@external\ndef getPoolForLpToken(_lpToken: address) -> address:\n    # in uniswap v2, the pool is the lp token address\n    return _lpToken\n\n\n@view\n@external\ndef getCoreRouterPool() -> address:\n    return self.coreRouterPool\n\n\n@view\n@external\ndef getDeepestLiqPool(_tokenA: address, _tokenB: address) -> BestPool:\n    factory: address = AERODROME_FACTORY\n    reserve0: uint256 = 0\n    reserve1: uint256 = 0\n    na: uint256 = 0\n\n    # get pool options\n    stablePool: address = staticcall AeroFactory(factory).getPool(_tokenA, _tokenB, True)\n    volatilePool: address = staticcall AeroFactory(factory).getPool(_tokenA, _tokenB, False)\n\n    # no pools found\n    if stablePool == empty(address) and volatilePool == empty(address):\n        return empty(BestPool)\n\n    # stable pool\n    stableLiquidity: uint256 = 0\n    if stablePool != empty(address):\n        reserve0, reserve1, na = staticcall AeroClassicPool(stablePool).getReserves()\n        stableLiquidity = reserve0 + reserve1\n\n    # volatile pool\n    volatileLiquidity: uint256 = 0\n    if volatilePool != empty(address):\n        reserve0, reserve1, na = staticcall AeroClassicPool(volatilePool).getReserves()\n        volatileLiquidity = reserve0 + reserve1\n\n    # best pool determined by liquidity\n    bestPoolAddr: address = stablePool\n    bestLiquidity: uint256 = stableLiquidity\n    isStable: bool = True\n    if volatileLiquidity > stableLiquidity:\n        bestPoolAddr = volatilePool\n        bestLiquidity = volatileLiquidity\n        isStable = False\n\n    return BestPool(\n        pool=bestPoolAddr,\n        fee=staticcall AeroFactory(factory).getFee(bestPoolAddr, isStable),\n        liquidity=bestLiquidity,\n        numCoins=2,\n    )\n\n\n@view\n@external\ndef getBestSwapAmountOut(_tokenIn: address, _tokenOut: address, _amountIn: uint256) -> (address, uint256):\n    factory: address = AERODROME_FACTORY\n    stablePool: address = staticcall AeroFactory(factory).getPool(_tokenIn, _tokenOut, True)\n    volatilePool: address = staticcall AeroFactory(factory).getPool(_tokenIn, _tokenOut, False)\n    if stablePool == empty(address) and volatilePool == empty(address):\n        return empty(address), 0\n\n    # stable pool\n    stableAmountOut: uint256 = 0\n    if stablePool != empty(address):\n        stableAmountOut = staticcall AeroClassicPool(stablePool).getAmountOut(_amountIn, _tokenIn)\n\n    # volatile pool\n    volatileAmountOut: uint256 = 0\n    if volatilePool != empty(address):\n        volatileAmountOut = staticcall AeroClassicPool(volatilePool).getAmountOut(_amountIn, _tokenIn)\n\n    if stableAmountOut == 0 and volatileAmountOut == 0:\n        return empty(address), 0\n\n    pool: address = stablePool\n    amountOut: uint256 = stableAmountOut\n    if volatileAmountOut > stableAmountOut:\n        pool = volatilePool\n        amountOut = volatileAmountOut\n\n    return pool, amountOut\n\n\n@view\n@external\ndef getSwapAmountOut(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n) -> uint256:\n    return staticcall AeroClassicPool(_pool).getAmountOut(_amountIn, _tokenIn)\n\n\n@view\n@external\ndef getBestSwapAmountIn(_tokenIn: address, _tokenOut: address, _amountOut: uint256) -> (address, uint256):\n    # TODO: implement stable pools\n    pool: address = staticcall AeroFactory(AERODROME_FACTORY).getPool(_tokenIn, _tokenOut, False)\n    if pool == empty(address):\n        return empty(address), max_value(uint256)\n\n    token0: address = empty(address)\n    token1: address = empty(address)\n    token0, token1 = staticcall AeroClassicPool(pool).tokens()\n    return pool, self._getAmountInForVolatilePools(pool, token0 == _tokenIn, _amountOut)\n\n\n@view\n@external\ndef getSwapAmountIn(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountOut: uint256,\n) -> uint256:\n    if not staticcall AeroClassicPool(_pool).stable():\n        token0: address = empty(address)\n        token1: address = empty(address)\n        token0, token1 = staticcall AeroClassicPool(_pool).tokens()\n        return self._getAmountInForVolatilePools(_pool, token0 == _tokenIn, _amountOut)\n    else:\n        return max_value(uint256) # TODO: implement stable pools\n\n\n@view\n@external\ndef getAddLiqAmountsIn(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _availAmountA: uint256,\n    _availAmountB: uint256,\n) -> (uint256, uint256, uint256):\n    return staticcall AeroRouter(AERODROME_ROUTER).quoteAddLiquidity(_tokenA, _tokenB, staticcall AeroClassicPool(_pool).stable(), AERODROME_FACTORY, _availAmountA, _availAmountB)\n\n\n@view\n@external\ndef getRemoveLiqAmountsOut(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpAmount: uint256,\n) -> (uint256, uint256):\n    return staticcall AeroRouter(AERODROME_ROUTER).quoteRemoveLiquidity(_tokenA, _tokenB, staticcall AeroClassicPool(_pool).stable(), AERODROME_FACTORY, _lpAmount)\n\n\n@view\n@external\ndef getPrice(_asset: address, _decimals: uint256) -> uint256:\n    return 0 # TODO: implement price\n\n\n@view\n@external\ndef getPriceUnsafe(_pool: address, _targetToken: address, _appraiser: address = empty(address)) -> uint256:\n    if not staticcall AeroClassicPool(_pool).stable():\n        return self._getPriceUnsafeVolatilePool(_pool, _targetToken, _appraiser)\n    else:\n        return 0 # TODO: implement stable pools\n\n\n# internal utils\n\n\n@view\n@internal\ndef _getPriceUnsafeVolatilePool(_pool: address, _targetToken: address, _appraiser: address) -> uint256:\n    token0: address = empty(address)\n    token1: address = empty(address)\n    token0, token1 = staticcall AeroClassicPool(_pool).tokens()\n\n    # appraiser\n    appraiser: address = _appraiser\n    if _appraiser == empty(address):\n        appraiser = addys._getAppraiserAddr()\n\n    # alt price\n    altPrice: uint256 = 0\n    if _targetToken == token0:\n        altPrice = staticcall Appraiser(appraiser).getNormalAssetPrice(token1)\n    else:\n        altPrice = staticcall Appraiser(appraiser).getNormalAssetPrice(token0)\n\n    # return early if no alt price\n    if altPrice == 0:\n        return 0\n\n    # reserves\n    reserve0: uint256 = 0\n    reserve1: uint256 = 0\n    na: uint256 = 0\n    reserve0, reserve1, na = staticcall AeroClassicPool(_pool).getReserves()\n\n    # avoid division by zero\n    if reserve0 == 0 or reserve1 == 0:\n        return 0  \n\n    # price of token0 in token1\n    priceZeroToOne: uint256 = reserve1 * EIGHTEEN_DECIMALS // reserve0\n\n    # adjust for decimals: price should be in 18 decimals\n    decimals0: uint256 = convert(staticcall IERC20Detailed(token0).decimals(), uint256)\n    decimals1: uint256 = convert(staticcall IERC20Detailed(token1).decimals(), uint256)\n    if decimals0 > decimals1:\n        scaleFactor: uint256 = 10 ** (decimals0 - decimals1)\n        priceZeroToOne = priceZeroToOne * scaleFactor\n    elif decimals1 > decimals0:\n        scaleFactor: uint256 = 10 ** (decimals1 - decimals0)\n        priceZeroToOne = priceZeroToOne // scaleFactor\n\n    # if _targetToken is token1, make price inverse\n    priceToOther: uint256 = priceZeroToOne\n    if _targetToken == token1:\n        priceToOther = EIGHTEEN_DECIMALS * EIGHTEEN_DECIMALS // priceZeroToOne\n\n    return altPrice * priceToOther // EIGHTEEN_DECIMALS\n\n\n@view\n@internal\ndef _getAmountInForVolatilePools(_pool: address, _zeroForOne: bool, _amountOut: uint256) -> uint256:\n    if _amountOut == 0 or _amountOut == max_value(uint256):\n        return max_value(uint256)\n\n    reserve0: uint256 = 0\n    reserve1: uint256 = 0\n    na: uint256 = 0\n    reserve0, reserve1, na = staticcall AeroClassicPool(_pool).getReserves()\n    if reserve0 == 0 or reserve1 == 0:\n        return max_value(uint256)\n\n    # determine which token is which\n    reserveIn: uint256 = reserve0\n    reserveOut: uint256 = reserve1\n    if not _zeroForOne:\n        reserveIn = reserve1\n        reserveOut = reserve0\n\n    if _amountOut > reserveOut:\n        return max_value(uint256)\n\n    fee: uint256 = staticcall AeroFactory(AERODROME_FACTORY).getFee(_pool, False)\n    numerator: uint256 = reserveIn * _amountOut * 100_00\n    denominator: uint256 = (reserveOut - _amountOut) * (100_00 - fee)\n    return (numerator // denominator) + 1\n\n\n#########\n# Other #\n#########\n\n\n@external\ndef depositForYield(\n    _asset: address,\n    _amount: uint256,\n    _vaultAddr: address,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, address, uint256, uint256):\n    return 0, empty(address), 0, 0\n\n\n@external\ndef withdrawFromYield(\n    _vaultToken: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, address, uint256, uint256):\n    return 0, empty(address), 0, 0\n\n\n@external\ndef mintOrRedeemAsset(\n    _tokenIn: address,\n    _tokenOut: address,\n    _tokenInAmount: uint256,\n    _minAmountOut: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, bool, uint256):\n    return 0, 0, False, 0\n\n\n@external\ndef confirmMintOrRedeemAsset(\n    _tokenIn: address,\n    _tokenOut: address,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef addCollateral(\n    _asset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef removeCollateral(\n    _asset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef borrow(\n    _borrowAsset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef repayDebt(\n    _paymentAsset: address,\n    _paymentAmount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef claimRewards(\n    _user: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _extraData: bytes32,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n@external\ndef addLiquidityConcentrated(\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _tickLower: int24,\n    _tickUpper: int24,\n    _amountA: uint256,\n    _amountB: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, uint256, uint256):\n    return 0, 0, 0, 0, 0\n\n\n@external\ndef removeLiquidityConcentrated(\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _liqToRemove: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, bool, uint256):\n    return 0, 0, 0, False, 0\n\n\n\n@view\n@external\ndef getAccessForLego(_user: address, _action: ws.ActionType) -> (address, String[64], uint256):\n    return empty(address), empty(String[64]), 0\n\n\n@view\n@external\ndef getPricePerShare(_asset: address, _decimals: uint256) -> uint256:\n    return 0\n",
            "sha256sum": "f3a5182badb7676003bfb00509dcb081675d564dfeb8245c62f37196b7ee5d58"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/legos/dexes/AeroClassic.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.3+commit.bff19ea2",
        "integrity": "db7709dfb20c2599233d2231cb2bb006c7bcee2784abf8319d17dda346b87b2a"
      },
      "args": "00000000000000000000000044cf3c4f000dfd76a35d03298049d37be688d6f9000000000000000000000000420dd381b31aef6683db6b902084cb0ffece40da000000000000000000000000cf77a3ba9a5ca399b7c97c74d54e5b1beb874e43000000000000000000000000cdac0d6c6c59727a65f871236188350531885c43",
      "file": "contracts/legos/dexes/AeroClassic.vy"
    },
    "AeroSlipstream": {
      "address": "0x680D5701F6f328C01eF0dad2B1E6eAD224a51D36",
      "abi": [
        {
          "name": "AeroSlipStreamSwap",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenIn",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenOut",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amountIn",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "amountOut",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "numTokens",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AeroSlipStreamLiquidityAdded",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenA",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenB",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amountA",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "amountB",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "liquidityAdded",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "nftTokenId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AeroSlipStreamLiquidityRemoved",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": false
            },
            {
              "name": "pool",
              "type": "address",
              "indexed": true
            },
            {
              "name": "nftTokenId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "tokenA",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenB",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amountA",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "amountB",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "liquidityRemoved",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AeroSlipStreamNftRecovered",
          "inputs": [
            {
              "name": "collection",
              "type": "address",
              "indexed": true
            },
            {
              "name": "nftTokenId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LegoPauseModified",
          "inputs": [
            {
              "name": "isPaused",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LegoFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "balance",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddys",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "undyToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "hatchery",
                  "type": "address"
                },
                {
                  "name": "lootDistributor",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                },
                {
                  "name": "walletBackpack",
                  "type": "address"
                },
                {
                  "name": "billing",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUndyHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pause",
          "inputs": [
            {
              "name": "_shouldPause",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFundsMany",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_assets",
              "type": "address[]"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "legoId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isPaused",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasCapability",
          "inputs": [
            {
              "name": "_action",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "onERC721Received",
          "inputs": [
            {
              "name": "_operator",
              "type": "address"
            },
            {
              "name": "_owner",
              "type": "address"
            },
            {
              "name": "_tokenId",
              "type": "uint256"
            },
            {
              "name": "_data",
              "type": "bytes"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bytes4"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRegistries",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isYieldLego",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isDexLego",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_tokenPath",
              "type": "address[]"
            },
            {
              "name": "_poolPath",
              "type": "address[]"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_tokenPath",
              "type": "address[]"
            },
            {
              "name": "_poolPath",
              "type": "address[]"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "uniswapV3SwapCallback",
          "inputs": [
            {
              "name": "_amount0Delta",
              "type": "int256"
            },
            {
              "name": "_amount1Delta",
              "type": "int256"
            },
            {
              "name": "_data",
              "type": "bytes"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLpToken",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPoolForLpToken",
          "inputs": [
            {
              "name": "_lpToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getCoreRouterPool",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getDeepestLiqPool",
          "inputs": [
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "fee",
                  "type": "uint256"
                },
                {
                  "name": "liquidity",
                  "type": "uint256"
                },
                {
                  "name": "numCoins",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getBestSwapAmountOut",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountIn",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getSwapAmountOut",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountIn",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getBestSwapAmountIn",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountOut",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getSwapAmountIn",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountOut",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddLiqAmountsIn",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_availAmountA",
              "type": "uint256"
            },
            {
              "name": "_availAmountB",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRemoveLiqAmountsOut",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPrice",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_decimals",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPriceUnsafe",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_targetToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPriceUnsafe",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_targetToken",
              "type": "address"
            },
            {
              "name": "_appraiser",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverNft",
          "inputs": [
            {
              "name": "_collection",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositForYield",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositForYield",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawFromYield",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawFromYield",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_tokenInAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_tokenInAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmMintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmMintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_borrowAsset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_borrowAsset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_paymentAsset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_paymentAsset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAccessForLego",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_action",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "string"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPricePerShare",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_decimals",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "AERO_SLIPSTREAM_FACTORY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "AERO_SLIPSTREAM_NFT_MANAGER",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "AERO_SLIPSTREAM_QUOTER",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "coreRouterPool",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_undyHq",
              "type": "address"
            },
            {
              "name": "_aeroFactory",
              "type": "address"
            },
            {
              "name": "_aeroNftPositionManager",
              "type": "address"
            },
            {
              "name": "_aeroQuoter",
              "type": "address"
            },
            {
              "name": "_coreRouterPool",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "interfaces/WalletStructs.vyi": {
            "content": "# @version 0.4.3\n\nflag ActionType:\n    TRANSFER\n    EARN_DEPOSIT\n    EARN_WITHDRAW\n    EARN_REBALANCE\n    SWAP\n    MINT_REDEEM\n    CONFIRM_MINT_REDEEM\n    ADD_COLLATERAL\n    REMOVE_COLLATERAL\n    BORROW\n    REPAY_DEBT\n    REWARDS\n    ETH_TO_WETH\n    WETH_TO_ETH\n    ADD_LIQ\n    REMOVE_LIQ\n    ADD_LIQ_CONC\n    REMOVE_LIQ_CONC\n    PAY_CHEQUE\n\nstruct WalletAssetData:\n    assetBalance: uint256\n    usdValue: uint256\n    isYieldAsset: bool\n    lastPricePerShare: uint256\n\nstruct ActionData:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    billing: address\n    wallet: address\n    walletConfig: address\n    walletOwner: address\n    inEjectMode: bool\n    isFrozen: bool\n    lastTotalUsdValue: uint256\n    signer: address\n    isManager: bool\n    legoId: uint256\n    legoAddr: address\n    eth: address\n    weth: address\n\nstruct MiniAddys:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    appraiser: address",
            "sha256sum": "9a4b4f59b3a62043e51b425a665064aae419a3c0bd0514b6b29a9441ae364bb9"
          },
          "interfaces/LegoPartner.vyi": {
            "content": "# @version 0.4.3\n\nfrom interfaces import WalletStructs as ws\n\nMAX_TOKEN_PATH: constant(uint256) = 5\nMAX_RECOVER_ASSETS: constant(uint256) = 20\n\n@external\ndef addLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _tickLower: int24, _tickUpper: int24, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef addLiquidity(_pool: address, _tokenA: address, _tokenB: address, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _minLpAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (address, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef removeLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _liqToRemove: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef removeLiquidity(_pool: address, _tokenA: address, _tokenB: address, _lpToken: address, _lpAmount: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef mintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _tokenInAmount: uint256, _minAmountOut: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef swapTokens(_amountIn: uint256, _minAmountOut: uint256, _tokenPath: DynArray[address, MAX_TOKEN_PATH], _poolPath: DynArray[address, MAX_TOKEN_PATH - 1], _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256):\n    ...\n\n@external\ndef depositForYield(_asset: address, _amount: uint256, _vaultAddr: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef withdrawFromYield(_vaultToken: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef confirmMintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef borrow(_borrowAsset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef repayDebt(_paymentAsset: address, _paymentAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef claimRewards(_user: address, _rewardToken: address, _rewardAmount: uint256, _extraData: bytes32, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef removeCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef addCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@view\n@external\ndef getAccessForLego(_user: address, _action: ws.ActionType) -> (address, String[64], uint256):\n    ...\n\n@view\n@external\ndef hasCapability(_action: ws.ActionType) -> bool:\n    ...\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    ...\n\n@view\n@external\ndef isYieldLego() -> bool:\n    ...\n\n@view\n@external\ndef isDexLego() -> bool:\n    ...\n\n@view\n@external\ndef getPricePerShare(_asset: address, _decimals: uint256) -> uint256:\n    ...\n\n@view\n@external\ndef getPrice(_asset: address, _decimals: uint256) -> uint256:\n    ...\n\n\n# common\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "2513e379aa74d0a8120114a5078a4c1a0900165a1c3f24419bb811d173b56453"
          },
          "contracts/modules/Addys.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\ninterface UndyHq:\n    def isValidAddr(_addr: address) -> bool: view\n    def getAddr(_regId: uint256) -> address: view\n    def undyToken() -> address: view\n\ninterface Switchboard:\n    def isSwitchboardAddr(_addr: address) -> bool: view\n\ninterface LegoBook:\n    def isLegoAddr(_addr: address) -> bool: view\n\nstruct Addys:\n    hq: address\n    undyToken: address\n    ledger: address\n    missionControl: address\n    legoBook: address\n    switchboard: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    walletBackpack: address\n    billing: address\n\n# hq\nUNDY_HQ_FOR_ADDYS: immutable(address)\n\n# core addys\nLEDGER_ID: constant(uint256) = 1\nMISSION_CONTROL_ID: constant(uint256) = 2\nLEGO_BOOK_ID: constant(uint256) = 3\nSWITCHBOARD_ID: constant(uint256) = 4\nHATCHERY_ID: constant(uint256) = 5\nLOOT_DISTRIBUTOR_ID: constant(uint256) = 6\nAPPRAISER_ID: constant(uint256) = 7\nWALLET_BACKPACK_ID: constant(uint256) = 8\nBILLING_ID: constant(uint256) = 9\n\n\n@deploy\ndef __init__(_undyHq: address):\n    assert _undyHq != empty(address) # dev: invalid undy hq\n    UNDY_HQ_FOR_ADDYS = _undyHq\n\n\n########\n# Core #\n########\n\n\n@view\n@external\ndef getAddys() -> Addys:\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _getAddys(_addys: Addys = empty(Addys)) -> Addys:\n    if _addys.hq != empty(address):\n        return _addys\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _generateAddys() -> Addys:\n    hq: address = UNDY_HQ_FOR_ADDYS\n    return Addys(\n        hq = hq,\n        undyToken = staticcall UndyHq(hq).undyToken(),\n        ledger = staticcall UndyHq(hq).getAddr(LEDGER_ID),\n        missionControl = staticcall UndyHq(hq).getAddr(MISSION_CONTROL_ID),\n        legoBook = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID),\n        switchboard = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID),\n        hatchery = staticcall UndyHq(hq).getAddr(HATCHERY_ID),\n        lootDistributor = staticcall UndyHq(hq).getAddr(LOOT_DISTRIBUTOR_ID),\n        appraiser = staticcall UndyHq(hq).getAddr(APPRAISER_ID),\n        walletBackpack = staticcall UndyHq(hq).getAddr(WALLET_BACKPACK_ID),\n        billing = staticcall UndyHq(hq).getAddr(BILLING_ID),\n    )\n\n\n##########\n# Tokens #\n##########\n\n\n@view\n@internal\ndef _getUndyToken() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).undyToken()\n\n\n###########\n# Helpers #\n###########\n\n\n# undy hq\n\n\n@view\n@external\ndef getUndyHq() -> address:\n    return self._getUndyHq()\n\n\n@view\n@internal\ndef _getUndyHq() -> address:\n    return UNDY_HQ_FOR_ADDYS\n\n\n# utils\n\n\n@view\n@internal\ndef _isValidUndyAddr(_addr: address, _hq: address = empty(address)) -> bool:\n    hq: address = _hq\n    if _hq == empty(address):\n        hq = UNDY_HQ_FOR_ADDYS\n    \n    # core departments\n    if staticcall UndyHq(hq).isValidAddr(_addr):\n        return True\n\n    # lego book\n    legoBook: address = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID)\n    if legoBook != empty(address) and staticcall LegoBook(legoBook).isLegoAddr(_addr):\n        return True\n\n    # switchboard config\n    switchboard: address = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID)\n    if switchboard != empty(address) and staticcall Switchboard(switchboard).isSwitchboardAddr(_addr):\n        return True\n\n    return False\n\n\n@view\n@internal\ndef _isSwitchboardAddr(_addr: address) -> bool:\n    switchboard: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n    if switchboard == empty(address):\n        return False\n    return staticcall Switchboard(switchboard).isSwitchboardAddr(_addr)\n\n\n@view\n@internal\ndef _isLegoBookAddr(_addr: address) -> bool:\n    legoBook: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n    if legoBook == empty(address):\n        return False\n    return staticcall LegoBook(legoBook).isLegoAddr(_addr)\n\n\n###############\n# Departments #\n###############\n\n\n# ledger\n\n\n@view\n@internal\ndef _getLedgerId() -> uint256:\n    return LEDGER_ID\n\n\n@view\n@internal\ndef _getLedgerAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEDGER_ID)\n\n\n# mission control\n\n\n@view\n@internal\ndef _getMissionControlId() -> uint256:\n    return MISSION_CONTROL_ID\n\n\n@view\n@internal\ndef _getMissionControlAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(MISSION_CONTROL_ID)\n\n\n# lego book\n\n\n@view\n@internal\ndef _getLegoBookId() -> uint256:\n    return LEGO_BOOK_ID\n\n\n@view\n@internal\ndef _getLegoBookAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n\n\n# switchboard\n\n\n@view\n@internal\ndef _getSwitchboardId() -> uint256:\n    return SWITCHBOARD_ID\n\n\n@view\n@internal\ndef _getSwitchboardAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n\n\n# hatchery\n\n\n@view\n@internal\ndef _getHatcheryId() -> uint256:\n    return HATCHERY_ID\n\n\n@view\n@internal\ndef _getHatcheryAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(HATCHERY_ID)\n\n\n# loot distributor\n\n\n@view\n@internal\ndef _getLootDistributorId() -> uint256:\n    return LOOT_DISTRIBUTOR_ID\n\n\n@view\n@internal\ndef _getLootDistributorAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LOOT_DISTRIBUTOR_ID)\n\n\n# appraiser\n\n\n@view\n@internal\ndef _getAppraiserId() -> uint256:\n    return APPRAISER_ID\n\n\n@view\n@internal\ndef _getAppraiserAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(APPRAISER_ID)\n\n\n# wallet backpack\n\n\n@view\n@internal\ndef _getWalletBackpackId() -> uint256:\n    return WALLET_BACKPACK_ID\n\n\n@view\n@internal\ndef _getWalletBackpackAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(WALLET_BACKPACK_ID)\n\n\n# billing\n\n\n@view\n@internal\ndef _getBillingId() -> uint256:\n    return BILLING_ID\n\n\n@view\n@internal\ndef _getBillingAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(BILLING_ID)",
            "sha256sum": "78b58f0b2acb2eaafa4d21adf9135a1cd0e1d53897f7a1fa70a83a04a7738ad3"
          },
          "contracts/modules/DexLegoData.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nuses: addys\n\nimport contracts.modules.Addys as addys\n\nfrom interfaces import WalletStructs as ws\nfrom ethereum.ercs import IERC20\n\nevent LegoPauseModified:\n    isPaused: bool\n\nevent LegoFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    balance: uint256\n\n# config\nlegoId: public(uint256)\nisPaused: public(bool)\n\nMAX_RECOVER_ASSETS: constant(uint256) = 20\n\n\n@deploy\ndef __init__(_shouldPause: bool):\n    self.isPaused = _shouldPause\n\n\n###########\n# General #\n###########\n\n\n# fill mini addys\n\n\n@view\n@internal\ndef _getMiniAddys(_miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> ws.MiniAddys:\n    if _miniAddys.ledger != empty(address):\n        return _miniAddys\n    return ws.MiniAddys(\n        ledger = addys._getLedgerAddr(),\n        missionControl = addys._getMissionControlAddr(),\n        legoBook = addys._getLegoBookAddr(),\n        appraiser = addys._getAppraiserAddr(),\n    )\n\n\n# activate\n\n\n@external\ndef pause(_shouldPause: bool):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert _shouldPause != self.isPaused # dev: no change\n    self.isPaused = _shouldPause\n    log LegoPauseModified(isPaused=_shouldPause)\n\n\n# recover funds\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    self._recoverFunds(_recipient, _asset)\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, MAX_RECOVER_ASSETS]):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    for a: address in _assets:\n        self._recoverFunds(_recipient, a)\n\n\n@internal\ndef _recoverFunds(_recipient: address, _asset: address):\n    assert empty(address) not in [_recipient, _asset] # dev: invalid recipient or asset\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    assert balance != 0 # dev: nothing to recover\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log LegoFundsRecovered(asset=_asset, recipient=_recipient, balance=balance)",
            "sha256sum": "75b15af2475ab409d4b5fd057509d14c20564ebd7fcb0850e3b61397d8e3af48"
          },
          "contracts/legos/dexes/AeroSlipstream.vy": {
            "content": "#     _____  _____  __  __    ____   _____  _____  _____ \n#    |  _  \\/   __\\/  \\/  \\  /  _/  /   __\\/   __\\/  _  \\\n#    |  |  ||   __|>-    -<  |  |---|   __||  |_ ||  |  |\n#    |_____/\\_____/\\__/\\__/  \\_____/\\_____/\\_____/\\_____/\n#                                                                       \n#     \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n#     \u2551  ** Aero Slipstream Lego **             \u2551\n#     \u2551  Integration with Aerodrome Slipstream. \u2551\n#     \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n#\n#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nimplements: Lego\nimplements: IUniswapV3Callback\n\nexports: addys.__interface__\nexports: dld.__interface__\n\ninitializes: addys\ninitializes: dld[addys := addys]\n\nfrom interfaces import LegoPartner as Lego\nfrom interfaces import WalletStructs as ws\n\nimport contracts.modules.Addys as addys\nimport contracts.modules.DexLegoData as dld\n\nfrom ethereum.ercs import IERC20\nfrom ethereum.ercs import IERC20Detailed\nfrom ethereum.ercs import IERC721\n\n# `getSwapAmountOut()` and `getSwapAmountIn()` cannot be view functions, sadly\n# keeping here to uncomment to test all other functions\n# implements: DexLego\n# from interfaces import DexLego as DexLego\n\ninterface AeroSlipStreamPool:\n    def swap(_recipient: address, _zeroForOne: bool, _amountSpecified: int256, _sqrtPriceLimitX96: uint160, _data: Bytes[256]) -> (int256, int256): nonpayable\n    def slot0() -> (uint160, int24, uint16, uint16, uint16, bool): view\n    def tickSpacing() -> int24: view\n    def liquidity() -> uint128: view\n    def token0() -> address: view\n    def token1() -> address: view\n    def fee() -> uint24: view\n\ninterface AeroNftPositionManager:\n    def increaseLiquidity(_params: IncreaseLiquidityParams) -> (uint128, uint256, uint256): nonpayable\n    def decreaseLiquidity(_params: DecreaseLiquidityParams) -> (uint256, uint256): nonpayable\n    def mint(_params: MintParams) -> (uint256, uint128, uint256, uint256): nonpayable\n    def collect(_params: CollectParams) -> (uint256, uint256): nonpayable\n    def positions(_tokenId: uint256) -> PositionData: view\n    def burn(_tokenId: uint256): nonpayable\n\ninterface Appraiser:\n    def getNormalAssetPrice(_asset: address, _missionControl: address = empty(address), _legoBook: address = empty(address), _ledger: address = empty(address)) -> uint256: view\n    def updatePriceAndGetUsdValue(_asset: address, _amount: uint256, _missionControl: address = empty(address), _legoBook: address = empty(address)) -> uint256: nonpayable\n\ninterface AeroQuoter:\n    def quoteExactOutputSingle(_params: QuoteExactOutputSingleParams) -> (uint256, uint160, uint32, uint256): nonpayable\n    def quoteExactInputSingle(_params: QuoteExactInputSingleParams) -> (uint256, uint160, uint32, uint256): nonpayable\n\ninterface IUniswapV3Callback:\n    def uniswapV3SwapCallback(_amount0Delta: int256, _amount1Delta: int256, _data: Bytes[256]): nonpayable\n\ninterface AeroSlipStreamFactory:\n    def getPool(_tokenA: address, _tokenB: address, _tickSpacing: int24) -> address: view\n\nstruct PoolSwapData:\n    pool: address\n    tokenIn: address\n    amountIn: uint256\n\nstruct BestPool:\n    pool: address\n    fee: uint256\n    liquidity: uint256\n    numCoins: uint256\n\nstruct QuoteExactInputSingleParams:\n    tokenIn: address\n    tokenOut: address\n    amountIn: uint256\n    tickSpacing: int24\n    sqrtPriceLimitX96: uint160\n\nstruct QuoteExactOutputSingleParams:\n    tokenIn: address\n    tokenOut: address\n    amount: uint256\n    tickSpacing: int24\n    sqrtPriceLimitX96: uint160\n\nstruct MintParams:\n    token0: address\n    token1: address\n    tickSpacing: int24\n    tickLower: int24\n    tickUpper: int24\n    amount0Desired: uint256\n    amount1Desired: uint256\n    amount0Min: uint256\n    amount1Min: uint256\n    recipient: address\n    deadline: uint256\n    sqrtPriceX96: uint160\n\nstruct IncreaseLiquidityParams:\n    tokenId: uint256\n    amount0Desired: uint256\n    amount1Desired: uint256\n    amount0Min: uint256\n    amount1Min: uint256\n    deadline: uint256\n\nstruct DecreaseLiquidityParams:\n    tokenId: uint256\n    liquidity: uint128\n    amount0Min: uint256\n    amount1Min: uint256\n    deadline: uint256\n\nstruct CollectParams:\n    tokenId: uint256\n    recipient: address\n    amount0Max: uint128\n    amount1Max: uint128\n\nstruct PositionData:\n    nonce: uint96\n    operator: address\n    token0: address\n    token1: address\n    tickSpacing: uint24\n    tickLower: int24\n    tickUpper: int24\n    liquidity: uint128\n    feeGrowthInside0LastX128: uint256\n    feeGrowthInside1LastX128: uint256\n    tokensOwed0: uint128\n    tokensOwed1: uint128\n\nevent AeroSlipStreamSwap:\n    sender: indexed(address)\n    tokenIn: indexed(address)\n    tokenOut: indexed(address)\n    amountIn: uint256\n    amountOut: uint256\n    usdValue: uint256\n    numTokens: uint256\n    recipient: address\n\nevent AeroSlipStreamLiquidityAdded:\n    sender: indexed(address)\n    tokenA: indexed(address)\n    tokenB: indexed(address)\n    amountA: uint256\n    amountB: uint256\n    liquidityAdded: uint256\n    nftTokenId: uint256\n    usdValue: uint256\n    recipient: address\n\nevent AeroSlipStreamLiquidityRemoved:\n    sender: address\n    pool: indexed(address)\n    nftTokenId: uint256\n    tokenA: indexed(address)\n    tokenB: indexed(address)\n    amountA: uint256\n    amountB: uint256\n    liquidityRemoved: uint256\n    usdValue: uint256\n    recipient: address\n\nevent AeroSlipStreamNftRecovered:\n    collection: indexed(address)\n    nftTokenId: uint256\n    recipient: indexed(address)\n\n# transient storage\npoolSwapData: transient(PoolSwapData)\n\n# aero\nAERO_SLIPSTREAM_FACTORY: public(immutable(address))\nAERO_SLIPSTREAM_NFT_MANAGER: public(immutable(address))\nAERO_SLIPSTREAM_QUOTER: public(immutable(address))\ncoreRouterPool: public(address)\n\nTICK_SPACING: constant(int24[5]) = [1, 50, 100, 200, 2000]\nMIN_SQRT_RATIO_PLUS_ONE: constant(uint160) = 4295128740\nMAX_SQRT_RATIO_MINUS_ONE: constant(uint160) = 1461446703485210103287273052203988822378723970341\nTICK_LOWER: constant(int24) = -887272\nTICK_UPPER: constant(int24) = 887272\nERC721_RECEIVE_DATA: constant(Bytes[1024]) = b\"UE721\"\nEIGHTEEN_DECIMALS: constant(uint256) = 10 ** 18\nUNISWAP_Q96: constant(uint256) = 2 ** 96  # uniswap's fixed point scaling factor\nMAX_TOKEN_PATH: constant(uint256) = 5\n\n\n@deploy\ndef __init__(\n    _undyHq: address,\n    _aeroFactory: address,\n    _aeroNftPositionManager: address,\n    _aeroQuoter: address,\n    _coreRouterPool: address,\n):\n    addys.__init__(_undyHq)\n    dld.__init__(False)\n\n    assert empty(address) not in [_aeroFactory, _aeroNftPositionManager, _aeroQuoter, _coreRouterPool] # dev: invalid addrs\n    AERO_SLIPSTREAM_FACTORY = _aeroFactory\n    AERO_SLIPSTREAM_NFT_MANAGER = _aeroNftPositionManager\n    AERO_SLIPSTREAM_QUOTER = _aeroQuoter\n    self.coreRouterPool = _coreRouterPool\n\n\n@view\n@external\ndef hasCapability(_action: ws.ActionType) -> bool:\n    return _action in (\n        ws.ActionType.SWAP |\n        ws.ActionType.ADD_LIQ_CONC | \n        ws.ActionType.REMOVE_LIQ_CONC\n    )\n\n\n@view\n@external\ndef onERC721Received(_operator: address, _owner: address, _tokenId: uint256, _data: Bytes[1024]) -> bytes4:\n    # must implement method for safe NFT transfers\n    assert _data == ERC721_RECEIVE_DATA # dev: did not receive from within Underscore wallet\n    return method_id(\"onERC721Received(address,address,uint256,bytes)\", output_type=bytes4)\n\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    return [AERO_SLIPSTREAM_FACTORY, AERO_SLIPSTREAM_NFT_MANAGER, AERO_SLIPSTREAM_QUOTER]\n\n\n@view\n@external\ndef isYieldLego() -> bool:\n    return False\n\n\n@view\n@external\ndef isDexLego() -> bool:\n    return True\n\n\n#########\n# Swaps #\n#########\n\n\n@external\ndef swapTokens(\n    _amountIn: uint256,\n    _minAmountOut: uint256,\n    _tokenPath: DynArray[address, MAX_TOKEN_PATH],\n    _poolPath: DynArray[address, MAX_TOKEN_PATH - 1],\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256):\n    assert not dld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = dld._getMiniAddys(_miniAddys)\n\n    # validate inputs\n    numTokens: uint256 = len(_tokenPath)\n    numPools: uint256 = len(_poolPath)\n    assert numTokens >= 2 # dev: invalid path\n    assert numPools == numTokens - 1 # dev: invalid path\n\n    # get first token and last token\n    tokenIn: address = _tokenPath[0]\n    tokenOut: address = _tokenPath[numTokens - 1]\n\n    # pre balances\n    preLegoBalance: uint256 = staticcall IERC20(tokenIn).balanceOf(self)\n\n    # transfer deposit asset to this contract\n    amountIn: uint256 = min(_amountIn, staticcall IERC20(tokenIn).balanceOf(msg.sender))\n    assert amountIn != 0 # dev: nothing to transfer\n    assert extcall IERC20(tokenIn).transferFrom(msg.sender, self, amountIn, default_return_value=True) # dev: transfer failed\n\n    # iterate through swap routes\n    aeroFactory: address = AERO_SLIPSTREAM_FACTORY\n    tempAmountIn: uint256 = amountIn\n    for i: uint256 in range(numTokens - 1, bound=MAX_TOKEN_PATH):\n        tempTokenIn: address = _tokenPath[i]\n        tempTokenOut: address = _tokenPath[i + 1]\n        tempPool: address = _poolPath[i]\n\n        # transfer to self (or to recipient if last swap)\n        recipient: address = _recipient\n        if i < numTokens - 2:\n            recipient = self\n\n        # swap\n        tempAmountIn = self._swapTokensInPool(tempPool, tempTokenIn, tempTokenOut, tempAmountIn, recipient, aeroFactory)\n\n    # final amount\n    amountOut: uint256 = tempAmountIn\n    assert amountOut >= _minAmountOut # dev: min amount out not met\n\n    # refund if full swap didn't get through\n    currentLegoBalance: uint256 = staticcall IERC20(tokenIn).balanceOf(self)\n    refundAssetAmount: uint256 = 0\n    if currentLegoBalance > preLegoBalance:\n        refundAssetAmount = currentLegoBalance - preLegoBalance\n        assert extcall IERC20(tokenIn).transfer(msg.sender, refundAssetAmount, default_return_value=True) # dev: transfer failed\n        amountIn -= refundAssetAmount\n\n    # get usd values\n    usdValue: uint256 = extcall Appraiser(miniAddys.appraiser).updatePriceAndGetUsdValue(tokenIn, amountIn, miniAddys.missionControl, miniAddys.legoBook)\n    if usdValue == 0:\n        usdValue = extcall Appraiser(miniAddys.appraiser).updatePriceAndGetUsdValue(tokenOut, amountOut, miniAddys.missionControl, miniAddys.legoBook)\n\n    log AeroSlipStreamSwap(\n        sender = msg.sender,\n        tokenIn = tokenIn,\n        tokenOut = tokenOut,\n        amountIn = amountIn,\n        amountOut = amountOut,\n        usdValue = usdValue,\n        numTokens = numTokens,\n        recipient = _recipient,\n    )\n    return amountIn, amountOut, usdValue\n\n\n# swap in pool\n\n\n@internal\ndef _swapTokensInPool(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n    _recipient: address,\n    _aeroFactory: address,\n) -> uint256:\n    tokens: address[2] = [staticcall AeroSlipStreamPool(_pool).token0(), staticcall AeroSlipStreamPool(_pool).token1()]\n    assert _tokenIn in tokens # dev: invalid tokenIn\n    assert _tokenOut in tokens # dev: invalid tokenOut\n    assert _tokenIn != _tokenOut # dev: invalid tokens\n\n    # verify actual aero pool\n    assert staticcall AeroSlipStreamFactory(_aeroFactory).getPool(_tokenIn, _tokenOut, staticcall AeroSlipStreamPool(_pool).tickSpacing()) == _pool # dev: invalid pool\n\n    # save in transient storage (for use in callback)\n    self.poolSwapData = PoolSwapData(\n        pool=_pool,\n        tokenIn=_tokenIn,\n        amountIn=_amountIn,\n    )\n\n    zeroForOne: bool = _tokenIn == tokens[0]\n    sqrtPriceLimitX96: uint160 = MAX_SQRT_RATIO_MINUS_ONE\n    if zeroForOne:\n        sqrtPriceLimitX96 = MIN_SQRT_RATIO_PLUS_ONE\n\n    # perform swap\n    amount0: int256 = 0\n    amount1: int256 = 0\n    amount0, amount1 = extcall AeroSlipStreamPool(_pool).swap(_recipient, zeroForOne, convert(_amountIn, int256), sqrtPriceLimitX96, b\"\")\n\n    # check swap results\n    toAmount: uint256 = 0\n    if zeroForOne:\n        toAmount = convert(-amount1, uint256)\n    else:\n        toAmount = convert(-amount0, uint256)\n\n    assert toAmount != 0 # dev: no tokens swapped\n    return toAmount\n\n\n# callback\n\n\n@external\ndef uniswapV3SwapCallback(_amount0Delta: int256, _amount1Delta: int256, _data: Bytes[256]):\n    poolSwapData: PoolSwapData = self.poolSwapData\n    assert msg.sender == poolSwapData.pool # dev: no perms\n\n    # transfer tokens to pool\n    assert extcall IERC20(poolSwapData.tokenIn).transfer(poolSwapData.pool, poolSwapData.amountIn, default_return_value=True) # dev: transfer failed\n    self.poolSwapData = empty(PoolSwapData)\n\n\n#################\n# Add Liquidity #\n#################\n\n\n@external\ndef addLiquidityConcentrated(\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _tickLower: int24,\n    _tickUpper: int24,\n    _amountA: uint256,\n    _amountB: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, uint256, uint256):\n    assert not dld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = dld._getMiniAddys(_miniAddys)\n\n    # validate tokens\n    tokens: address[2] = [staticcall AeroSlipStreamPool(_pool).token0(), staticcall AeroSlipStreamPool(_pool).token1()]\n    assert _tokenA in tokens # dev: invalid tokenA\n    assert _tokenB in tokens # dev: invalid tokenB\n    assert _tokenA != _tokenB # dev: invalid tokens\n\n    # pre balances\n    preLegoBalanceA: uint256 = staticcall IERC20(_tokenA).balanceOf(self)\n    preLegoBalanceB: uint256 = staticcall IERC20(_tokenB).balanceOf(self)\n\n    # token a\n    liqAmountA: uint256 = min(_amountA, staticcall IERC20(_tokenA).balanceOf(msg.sender))\n    assert liqAmountA != 0 # dev: nothing to transfer\n    assert extcall IERC20(_tokenA).transferFrom(msg.sender, self, liqAmountA, default_return_value=True) # dev: transfer failed\n\n    # token b\n    liqAmountB: uint256 = min(_amountB, staticcall IERC20(_tokenB).balanceOf(msg.sender))\n    assert liqAmountB != 0 # dev: nothing to transfer\n    assert extcall IERC20(_tokenB).transferFrom(msg.sender, self, liqAmountB, default_return_value=True) # dev: transfer failed\n\n    # approvals\n    nftPositionManager: address = AERO_SLIPSTREAM_NFT_MANAGER\n    assert extcall IERC20(_tokenA).approve(nftPositionManager, liqAmountA, default_return_value=True) # dev: approval failed\n    assert extcall IERC20(_tokenB).approve(nftPositionManager, liqAmountB, default_return_value=True) # dev: approval failed\n\n    # organized the index of tokens\n    token0: address = _tokenA\n    token1: address = _tokenB\n    amount0: uint256 = liqAmountA\n    amount1: uint256 = liqAmountB\n    minAmount0: uint256 = _minAmountA\n    minAmount1: uint256 = _minAmountB\n    if tokens[0] != _tokenA:\n        token0 = _tokenB\n        token1 = _tokenA\n        amount0 = liqAmountB\n        amount1 = liqAmountA\n        minAmount0 = _minAmountB\n        minAmount1 = _minAmountA\n\n    # add liquidity\n    nftTokenId: uint256 = _nftTokenId\n    liquidityAdded: uint256 = 0\n    liquidityAddedInt128: uint128 = 0\n    if _nftTokenId == 0:\n        nftTokenId, liquidityAddedInt128, amount0, amount1 = self._mintNewPosition(nftPositionManager, _pool, token0, token1, _tickLower, _tickUpper, amount0, amount1, minAmount0, minAmount1, _recipient)\n    else:\n        liquidityAddedInt128, amount0, amount1 = self._increaseExistingPosition(nftPositionManager, _nftTokenId, amount0, amount1, minAmount0, minAmount1, _recipient)\n\n    liquidityAdded = convert(liquidityAddedInt128, uint256)\n    assert liquidityAdded != 0 # dev: no liquidity added\n\n    # reset approvals\n    assert extcall IERC20(_tokenA).approve(nftPositionManager, 0, default_return_value=True) # dev: approval failed\n    assert extcall IERC20(_tokenB).approve(nftPositionManager, 0, default_return_value=True) # dev: approval failed\n\n    # refund if full liquidity was not added\n    currentLegoBalanceA: uint256 = staticcall IERC20(_tokenA).balanceOf(self)\n    refundAssetAmountA: uint256 = 0\n    if currentLegoBalanceA > preLegoBalanceA:\n        refundAssetAmountA = currentLegoBalanceA - preLegoBalanceA\n        assert extcall IERC20(_tokenA).transfer(msg.sender, refundAssetAmountA, default_return_value=True) # dev: transfer failed\n\n    currentLegoBalanceB: uint256 = staticcall IERC20(_tokenB).balanceOf(self)\n    refundAssetAmountB: uint256 = 0\n    if currentLegoBalanceB > preLegoBalanceB:\n        refundAssetAmountB = currentLegoBalanceB - preLegoBalanceB\n        assert extcall IERC20(_tokenB).transfer(msg.sender, refundAssetAmountB, default_return_value=True) # dev: transfer failed\n\n    # a/b amounts\n    liqAmountA = amount0\n    liqAmountB = amount1\n    if tokens[0] != _tokenA:\n        liqAmountA = amount1\n        liqAmountB = amount0\n\n    usdValue: uint256 = self._getUsdValue(_tokenA, liqAmountA, _tokenB, liqAmountB, miniAddys)\n    log AeroSlipStreamLiquidityAdded(\n        sender = msg.sender,\n        tokenA = _tokenA,\n        tokenB = _tokenB,\n        amountA = liqAmountA,\n        amountB = liqAmountB,\n        liquidityAdded = liquidityAdded,\n        nftTokenId = nftTokenId,\n        usdValue = usdValue,\n        recipient = _recipient,\n    )\n    return liquidityAdded, liqAmountA, liqAmountB, nftTokenId, usdValue\n\n\n# mint new position\n\n\n@internal\ndef _mintNewPosition(\n    _nftPositionManager: address,\n    _pool: address,\n    _token0: address,\n    _token1: address,\n    _tickLower: int24,\n    _tickUpper: int24,\n    _amount0: uint256,\n    _amount1: uint256,\n    _minAmount0: uint256,\n    _minAmount1: uint256,\n    _recipient: address,\n) -> (uint256, uint128, uint256, uint256):\n    tickSpacing: int24 = staticcall AeroSlipStreamPool(_pool).tickSpacing()\n\n    tickLower: int24 = 0\n    tickUpper: int24 = 0\n    tickLower, tickUpper = self._getTicks(tickSpacing, _tickLower, _tickUpper)\n\n    # mint new position\n    params: MintParams = MintParams(\n        token0=_token0,\n        token1=_token1,\n        tickSpacing=tickSpacing,\n        tickLower=tickLower,\n        tickUpper=tickUpper,\n        amount0Desired=_amount0,\n        amount1Desired=_amount1,\n        amount0Min=_minAmount0,\n        amount1Min=_minAmount1,\n        recipient=_recipient,\n        deadline=block.timestamp,\n        sqrtPriceX96=0,\n    )\n    return extcall AeroNftPositionManager(_nftPositionManager).mint(params)\n\n\n# get ticks\n\n\n@view\n@internal\ndef _getTicks(_tickSpacing: int24, _tickLower: int24, _tickUpper: int24) -> (int24, int24):\n    tickLower: int24 = _tickLower\n    if _tickLower == min_value(int24):\n        tickLower = (TICK_LOWER // _tickSpacing) * _tickSpacing\n\n    tickUpper: int24 = _tickUpper\n    if _tickUpper == max_value(int24):\n        tickUpper = (TICK_UPPER // _tickSpacing) * _tickSpacing\n\n    return tickLower, tickUpper\n\n\n# increase existing position\n\n\n@internal\ndef _increaseExistingPosition(\n    _nftPositionManager: address,\n    _tokenId: uint256,\n    _amount0: uint256,\n    _amount1: uint256,\n    _minAmount0: uint256,\n    _minAmount1: uint256,\n    _recipient: address,\n) -> (uint128, uint256, uint256):\n    assert staticcall IERC721(_nftPositionManager).ownerOf(_tokenId) == self # dev: nft not here\n\n    liquidityAddedInt128: uint128 = 0\n    amount0: uint256 = 0\n    amount1: uint256 = 0\n    params: IncreaseLiquidityParams = IncreaseLiquidityParams(\n        tokenId=_tokenId,\n        amount0Desired=_amount0,\n        amount1Desired=_amount1,\n        amount0Min=_minAmount0,\n        amount1Min=_minAmount1,\n        deadline=block.timestamp,\n    )\n    liquidityAddedInt128, amount0, amount1 = extcall AeroNftPositionManager(_nftPositionManager).increaseLiquidity(params)\n\n    # collect fees (if applicable) -- must be done before transferring nft\n    positionData: PositionData = staticcall AeroNftPositionManager(_nftPositionManager).positions(_tokenId)\n    self._collectFees(_nftPositionManager, _tokenId, _recipient, positionData)\n\n    # transfer nft to recipient\n    extcall IERC721(_nftPositionManager).safeTransferFrom(self, _recipient, _tokenId)\n\n    return liquidityAddedInt128, amount0, amount1\n\n\n# collect fees\n\n\n@internal\ndef _collectFees(_nftPositionManager: address, _tokenId: uint256, _recipient: address, _positionData: PositionData) -> (uint256, uint256):\n    if _positionData.tokensOwed0 == 0 and _positionData.tokensOwed1 == 0:\n        return 0, 0\n\n    params: CollectParams = CollectParams(\n        tokenId=_tokenId,\n        recipient=_recipient,\n        amount0Max=max_value(uint128),\n        amount1Max=max_value(uint128),\n    )\n    return extcall AeroNftPositionManager(_nftPositionManager).collect(params)\n\n\n####################\n# Remove Liquidity #\n####################\n\n\n@external\ndef removeLiquidityConcentrated(\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _liqToRemove: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, bool, uint256):\n    assert not dld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = dld._getMiniAddys(_miniAddys)\n\n    # make sure nft is here\n    nftPositionManager: address = AERO_SLIPSTREAM_NFT_MANAGER\n    assert staticcall IERC721(nftPositionManager).ownerOf(_nftTokenId) == self # dev: nft not here\n\n    # get position data\n    positionData: PositionData = staticcall AeroNftPositionManager(nftPositionManager).positions(_nftTokenId)\n    originalLiquidity: uint128 = positionData.liquidity\n\n    # validate tokens\n    tokens: address[2] = [positionData.token0, positionData.token1]\n    assert _tokenA in tokens # dev: invalid tokenA\n    assert _tokenB in tokens # dev: invalid tokenB\n    assert _tokenA != _tokenB # dev: invalid tokens\n\n    # organized the index of tokens\n    minAmount0: uint256 = _minAmountA\n    minAmount1: uint256 = _minAmountB\n    if _tokenA != tokens[0]:\n        minAmount0 = _minAmountB\n        minAmount1 = _minAmountA\n\n    # decrease liquidity\n    liqToRemove: uint256 = min(_liqToRemove, convert(positionData.liquidity, uint256))\n    assert liqToRemove != 0 # dev: no liquidity to remove\n\n    params: DecreaseLiquidityParams = DecreaseLiquidityParams(\n        tokenId=_nftTokenId,\n        liquidity=convert(liqToRemove, uint128),\n        amount0Min=minAmount0,\n        amount1Min=minAmount1,\n        deadline=block.timestamp,\n    )\n    amount0: uint256 = 0\n    amount1: uint256 = 0\n    amount0, amount1 = extcall AeroNftPositionManager(nftPositionManager).decreaseLiquidity(params)\n    assert amount0 != 0 and amount1 != 0 # dev: no liquidity removed\n\n    # a/b amounts\n    amountA: uint256 = amount0\n    amountB: uint256 = amount1\n    if _tokenA != tokens[0]:\n        amountA = amount1\n        amountB = amount0\n\n    # get latest position data -- collect withdrawn tokens AND any fees (if applicable)\n    positionData = staticcall AeroNftPositionManager(nftPositionManager).positions(_nftTokenId)\n    self._collectFees(nftPositionManager, _nftTokenId, _recipient, positionData)\n\n    # burn nft (if applicable)\n    isDepleted: bool = False\n    if positionData.liquidity == 0:\n        isDepleted = True\n        extcall AeroNftPositionManager(nftPositionManager).burn(_nftTokenId)\n\n    # transfer nft to recipient\n    else:\n        extcall IERC721(nftPositionManager).safeTransferFrom(self, _recipient, _nftTokenId)\n\n    usdValue: uint256 = self._getUsdValue(_tokenA, amountA, _tokenB, amountB, miniAddys)\n    liquidityRemoved: uint256 = convert(originalLiquidity - positionData.liquidity, uint256)\n    log AeroSlipStreamLiquidityRemoved(\n        sender = msg.sender,\n        pool = _pool,\n        nftTokenId = _nftTokenId,\n        tokenA = _tokenA,\n        tokenB = _tokenB,\n        amountA = amountA,\n        amountB = amountB,\n        liquidityRemoved = liquidityRemoved,\n        usdValue = usdValue,\n        recipient = _recipient,\n    )\n    return amountA, amountB, liquidityRemoved, isDepleted, usdValue\n\n\n# get usd value on liquidity actions\n\n\n@internal\ndef _getUsdValue(\n    _tokenA: address,\n    _amountA: uint256,\n    _tokenB: address,\n    _amountB: uint256,\n    _miniAddys: ws.MiniAddys,\n) -> uint256:\n\n    usdValueA: uint256 = 0\n    if _amountA != 0:\n        usdValueA = extcall Appraiser(_miniAddys.appraiser).updatePriceAndGetUsdValue(_tokenA, _amountA, _miniAddys.missionControl, _miniAddys.legoBook)\n\n    usdValueB: uint256 = 0\n    if _amountB != 0:\n        usdValueB = extcall Appraiser(_miniAddys.appraiser).updatePriceAndGetUsdValue(_tokenB, _amountB, _miniAddys.missionControl, _miniAddys.legoBook)\n\n    return usdValueA + usdValueB\n\n\n#############\n# Utilities #\n#############\n\n\n@view\n@external\ndef getLpToken(_pool: address) -> address:\n    # no lp tokens for aero slipstream (uni v3)\n    return empty(address)\n\n\n@view\n@external\ndef getPoolForLpToken(_lpToken: address) -> address:\n    # no lp tokens for aero slipstream (uni v3)\n    return empty(address)\n\n\n@view\n@external\ndef getCoreRouterPool() -> address:\n    return self.coreRouterPool\n\n\n@view\n@external\ndef getDeepestLiqPool(_tokenA: address, _tokenB: address) -> BestPool:\n    bestPoolAddr: address = empty(address)\n    na: int24 = 0\n    bestPoolAddr, na = self._getDeepestLiqPool(_tokenA, _tokenB)\n\n    if bestPoolAddr == empty(address):\n        return empty(BestPool)\n\n    # get token balances\n    tokenABal: uint256 = staticcall IERC20(_tokenA).balanceOf(bestPoolAddr)\n    tokenBBal: uint256 = staticcall IERC20(_tokenB).balanceOf(bestPoolAddr)\n\n    return BestPool(\n        pool=bestPoolAddr,\n        fee=convert(staticcall AeroSlipStreamPool(bestPoolAddr).fee() // 100, uint256), # normalize to have 100_00 denominator\n        liquidity=tokenABal + tokenBBal, # not exactly \"liquidity\" but this comparable to \"reserves\"\n        numCoins=2,\n    )\n\n\n# annoying that this cannot be view function, thanks uni v3\n@external\ndef getBestSwapAmountOut(_tokenIn: address, _tokenOut: address, _amountIn: uint256) -> (address, uint256):\n    bestPoolAddr: address = empty(address)\n    bestTickSpacing: int24 = 0\n    bestPoolAddr, bestTickSpacing = self._getDeepestLiqPool(_tokenIn, _tokenOut)\n    if bestPoolAddr == empty(address):\n        return empty(address), 0\n\n    amountOut: uint256 = 0\n    na1: uint160 = 0\n    na2: uint32 = 0\n    na3: uint256 = 0\n    amountOut, na1, na2, na3 = extcall AeroQuoter(AERO_SLIPSTREAM_QUOTER).quoteExactInputSingle(\n        QuoteExactInputSingleParams(\n            tokenIn=_tokenIn,\n            tokenOut=_tokenOut,\n            amountIn=_amountIn,\n            tickSpacing=bestTickSpacing,\n            sqrtPriceLimitX96=0,\n        )\n    )\n    return bestPoolAddr, amountOut\n\n\n# annoying that this cannot be view function, thanks uni v3\n@external\ndef getSwapAmountOut(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n) -> uint256:\n    amountOut: uint256 = 0\n    na1: uint160 = 0\n    na2: uint32 = 0\n    na3: uint256 = 0\n    amountOut, na1, na2, na3 = extcall AeroQuoter(AERO_SLIPSTREAM_QUOTER).quoteExactInputSingle(\n        QuoteExactInputSingleParams(\n            tokenIn=_tokenIn,\n            tokenOut=_tokenOut,\n            amountIn=_amountIn,\n            tickSpacing=staticcall AeroSlipStreamPool(_pool).tickSpacing(),\n            sqrtPriceLimitX96=0,\n        )\n    )\n    return amountOut\n\n\n# annoying that this cannot be view function, thanks uni v3\n@external\ndef getBestSwapAmountIn(_tokenIn: address, _tokenOut: address, _amountOut: uint256) -> (address, uint256):\n    if _amountOut == 0 or _amountOut == max_value(uint256):\n        return empty(address), max_value(uint256)\n\n    bestPoolAddr: address = empty(address)\n    bestTickSpacing: int24 = 0\n    bestPoolAddr, bestTickSpacing = self._getDeepestLiqPool(_tokenIn, _tokenOut)\n    if bestPoolAddr == empty(address):\n        return empty(address), 0\n\n    amountIn: uint256 = 0\n    na1: uint160 = 0\n    na2: uint32 = 0\n    na3: uint256 = 0\n    amountIn, na1, na2, na3 = extcall AeroQuoter(AERO_SLIPSTREAM_QUOTER).quoteExactOutputSingle(\n        QuoteExactOutputSingleParams(\n            tokenIn=_tokenIn,\n            tokenOut=_tokenOut,\n            amount=_amountOut,\n            tickSpacing=bestTickSpacing,\n            sqrtPriceLimitX96=0,\n        )\n    )\n    return bestPoolAddr, amountIn\n\n\n# annoying that this cannot be view function, thanks uni v3\n@external\ndef getSwapAmountIn(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountOut: uint256,\n) -> uint256:\n    if _amountOut == 0 or _amountOut == max_value(uint256):\n        return max_value(uint256)\n\n    amountIn: uint256 = 0\n    na1: uint160 = 0\n    na2: uint32 = 0\n    na3: uint256 = 0\n    amountIn, na1, na2, na3 = extcall AeroQuoter(AERO_SLIPSTREAM_QUOTER).quoteExactOutputSingle(\n        QuoteExactOutputSingleParams(\n            tokenIn=_tokenIn,\n            tokenOut=_tokenOut,\n            amount=_amountOut,\n            tickSpacing=staticcall AeroSlipStreamPool(_pool).tickSpacing(),\n            sqrtPriceLimitX96=0,\n        )\n    )\n    return amountIn\n\n\n@view\n@external\ndef getAddLiqAmountsIn(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _availAmountA: uint256,\n    _availAmountB: uint256,\n) -> (uint256, uint256, uint256):\n    token0: address = staticcall AeroSlipStreamPool(_pool).token0()\n\n    # get correct numerator and denominator\n    numerator: uint256 = 0\n    denominator: uint256 = 0\n    sqrtPriceX96Squared: uint256 = self._getSqrtPriceX96(_pool) ** 2\n    if _tokenA == token0:\n        numerator = sqrtPriceX96Squared\n        denominator = UNISWAP_Q96 ** 2\n    else:\n        numerator = UNISWAP_Q96 ** 2\n        denominator = sqrtPriceX96Squared\n\n    # calculate optimal amounts\n    amountA: uint256 = _availAmountA\n    amountB: uint256 = _availAmountA * numerator // denominator\n    if amountB > _availAmountB:\n        maybeAmountA: uint256 = _availAmountB * denominator // numerator\n        if maybeAmountA <= _availAmountA:\n            amountA = maybeAmountA\n            amountB = _availAmountB\n    return amountA, amountB, 0\n\n\n@view\n@external\ndef getRemoveLiqAmountsOut(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpAmount: uint256,\n) -> (uint256, uint256):\n    token0: address = staticcall AeroSlipStreamPool(_pool).token0()\n\n    # calculate expected amounts out\n    sqrtPriceX96: uint256 = self._getSqrtPriceX96(_pool)\n    amount0Out: uint256 = _lpAmount * UNISWAP_Q96 // sqrtPriceX96\n    amount1Out: uint256 = _lpAmount * sqrtPriceX96 // UNISWAP_Q96\n\n    # return amounts out\n    if _tokenA == token0:\n        return amount0Out, amount1Out\n    else:\n        return amount1Out, amount0Out\n\n\n@view\n@external\ndef getPrice(_asset: address, _decimals: uint256) -> uint256:\n    return 0 # TODO: implement price\n\n\n@view\n@external\ndef getPriceUnsafe(_pool: address, _targetToken: address, _appraiser: address = empty(address)) -> uint256:\n    token0: address = staticcall AeroSlipStreamPool(_pool).token0()\n    token1: address = staticcall AeroSlipStreamPool(_pool).token1()\n\n    # appraiser\n    appraiser: address = _appraiser\n    if _appraiser == empty(address):\n        appraiser = addys._getAppraiserAddr()\n\n    # alt price\n    altPrice: uint256 = 0\n    if _targetToken == token0:\n        altPrice = staticcall Appraiser(appraiser).getNormalAssetPrice(token1)\n    else:\n        altPrice = staticcall Appraiser(appraiser).getNormalAssetPrice(token0)\n\n    # return early if no alt price\n    if altPrice == 0:\n        return 0\n\n    # price of token0 in token1\n    sqrtPriceX96: uint256 = self._getSqrtPriceX96(_pool)\n    numerator: uint256 = sqrtPriceX96 ** 2 * EIGHTEEN_DECIMALS\n    priceZeroToOne: uint256 = numerator // (UNISWAP_Q96 ** 2)\n\n    # adjust for decimals: price should be in 18 decimals\n    decimals0: uint256 = convert(staticcall IERC20Detailed(token0).decimals(), uint256)\n    decimals1: uint256 = convert(staticcall IERC20Detailed(token1).decimals(), uint256)\n    if decimals0 > decimals1:\n        scaleFactor: uint256 = 10 ** (decimals0 - decimals1)\n        priceZeroToOne = priceZeroToOne * scaleFactor\n    elif decimals1 > decimals0:\n        scaleFactor: uint256 = 10 ** (decimals1 - decimals0)\n        priceZeroToOne = priceZeroToOne // scaleFactor\n\n    # if _targetToken is token1, make price inverse\n    priceToOther: uint256 = priceZeroToOne\n    if _targetToken == token1:\n        priceToOther = EIGHTEEN_DECIMALS * EIGHTEEN_DECIMALS // priceZeroToOne\n\n    return altPrice * priceToOther // EIGHTEEN_DECIMALS\n\n\n# internal utils\n\n\n@view\n@internal\ndef _getDeepestLiqPool(_tokenA: address, _tokenB: address) -> (address, int24):\n    bestPoolAddr: address = empty(address)\n    bestTickSpacing: int24 = 0\n    bestLiquidity: uint128 = 0\n\n    factory: address = AERO_SLIPSTREAM_FACTORY\n    for i: uint256 in range(5):\n        tickSpacing: int24 = TICK_SPACING[i]\n        pool: address = staticcall AeroSlipStreamFactory(factory).getPool(_tokenA, _tokenB, tickSpacing)\n        if pool == empty(address):\n            continue\n        liquidity: uint128 = staticcall AeroSlipStreamPool(pool).liquidity()\n        if liquidity > bestLiquidity:\n            bestPoolAddr = pool\n            bestTickSpacing = tickSpacing\n            bestLiquidity = liquidity\n\n    return bestPoolAddr, bestTickSpacing\n\n\n@view\n@internal\ndef _getSqrtPriceX96(_pool: address) -> uint256:\n    sqrtPriceX96: uint160 = 0\n    tick: int24 = 0\n    observationIndex: uint16 = 0\n    observationCardinality: uint16 = 0\n    observationCardinalityNext: uint16 = 0\n    unlocked: bool = False\n    sqrtPriceX96, tick, observationIndex, observationCardinality, observationCardinalityNext, unlocked = staticcall AeroSlipStreamPool(_pool).slot0()\n    return convert(sqrtPriceX96, uint256)\n\n\n# nft recovery\n\n\n@external\ndef recoverNft(_collection: address, _nftTokenId: uint256, _recipient: address) -> bool:\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n\n    if staticcall IERC721(_collection).ownerOf(_nftTokenId) != self:\n        return False\n\n    extcall IERC721(_collection).safeTransferFrom(self, _recipient, _nftTokenId)\n    log AeroSlipStreamNftRecovered(collection=_collection, nftTokenId=_nftTokenId, recipient=_recipient)\n    return True\n\n\n#########\n# Other #\n#########\n\n\n@external\ndef depositForYield(\n    _asset: address,\n    _amount: uint256,\n    _vaultAddr: address,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, address, uint256, uint256):\n    return 0, empty(address), 0, 0\n\n\n@external\ndef withdrawFromYield(\n    _vaultToken: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, address, uint256, uint256):\n    return 0, empty(address), 0, 0\n\n\n@external\ndef mintOrRedeemAsset(\n    _tokenIn: address,\n    _tokenOut: address,\n    _tokenInAmount: uint256,\n    _minAmountOut: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, bool, uint256):\n    return 0, 0, False, 0\n\n\n@external\ndef confirmMintOrRedeemAsset(\n    _tokenIn: address,\n    _tokenOut: address,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef addCollateral(\n    _asset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef removeCollateral(\n    _asset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef borrow(\n    _borrowAsset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef repayDebt(\n    _paymentAsset: address,\n    _paymentAmount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef claimRewards(\n    _user: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _extraData: bytes32,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n@external\ndef addLiquidity(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _amountA: uint256,\n    _amountB: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _minLpAmount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (address, uint256, uint256, uint256, uint256):\n    return empty(address), 0, 0, 0, 0\n\n\n@external\ndef removeLiquidity(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpToken: address,\n    _lpAmount: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, uint256):\n    return 0, 0, 0, 0\n\n\n@view\n@external\ndef getAccessForLego(_user: address, _action: ws.ActionType) -> (address, String[64], uint256):\n    return empty(address), empty(String[64]), 0\n\n\n@view\n@external\ndef getPricePerShare(_asset: address, _decimals: uint256) -> uint256:\n    return 0\n\n",
            "sha256sum": "bdd9f3a44182b3fe1b6079142e9682b50bf8f4809c06a21ee3e2ef7c766d3325"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/legos/dexes/AeroSlipstream.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.3+commit.bff19ea2",
        "integrity": "008ca54d8dd32951aceb04a10a39c9496d17261f493c48400c1c5457f812411b"
      },
      "args": "00000000000000000000000044cf3c4f000dfd76a35d03298049d37be688d6f90000000000000000000000005e7bb104d84c7cb9b682aac2f3d509f5f406809a000000000000000000000000827922686190790b37229fd06084350e74485b72000000000000000000000000254cf9e1e6e233aa1ac962cb9b05b2cfeaae15b0000000000000000000000000b2cc224c1c9fee385f8ad6a55b4d94e92359dc59",
      "file": "contracts/legos/dexes/AeroSlipstream.vy"
    },
    "Curve": {
      "address": "0x01A8Fa2Dbd240f197C820DE22e279150edE5BCF4",
      "abi": [
        {
          "name": "CurveSwap",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenIn",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenOut",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amountIn",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "amountOut",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "numTokens",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "CurveLiquidityAdded",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenA",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenB",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amountA",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "amountB",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "lpAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "CurveLiquidityRemoved",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": false
            },
            {
              "name": "pool",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenA",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenB",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amountA",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "amountB",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "lpToken",
              "type": "address",
              "indexed": false
            },
            {
              "name": "lpAmountBurned",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LegoPauseModified",
          "inputs": [
            {
              "name": "isPaused",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LegoFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "balance",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddys",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "undyToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "hatchery",
                  "type": "address"
                },
                {
                  "name": "lootDistributor",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                },
                {
                  "name": "walletBackpack",
                  "type": "address"
                },
                {
                  "name": "billing",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUndyHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pause",
          "inputs": [
            {
              "name": "_shouldPause",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFundsMany",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_assets",
              "type": "address[]"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "legoId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isPaused",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasCapability",
          "inputs": [
            {
              "name": "_action",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRegistries",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isYieldLego",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isDexLego",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_tokenPath",
              "type": "address[]"
            },
            {
              "name": "_poolPath",
              "type": "address[]"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_tokenPath",
              "type": "address[]"
            },
            {
              "name": "_poolPath",
              "type": "address[]"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLpToken",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPoolForLpToken",
          "inputs": [
            {
              "name": "_lpToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getCoreRouterPool",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getDeepestLiqPool",
          "inputs": [
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "fee",
                  "type": "uint256"
                },
                {
                  "name": "liquidity",
                  "type": "uint256"
                },
                {
                  "name": "numCoins",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getBestSwapAmountOut",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountIn",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getSwapAmountOut",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountIn",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getBestSwapAmountIn",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountOut",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getSwapAmountIn",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountOut",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddLiqAmountsIn",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_availAmountA",
              "type": "uint256"
            },
            {
              "name": "_availAmountB",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRemoveLiqAmountsOut",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPrice",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_decimals",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPriceUnsafe",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_targetToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPriceUnsafe",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_targetToken",
              "type": "address"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAccessForLego",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_action",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "string"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPricePerShare",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_decimals",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "CURVE_META_REGISTRY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "CURVE_REGISTRIES",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "StableSwapNg",
                  "type": "address"
                },
                {
                  "name": "TwoCryptoNg",
                  "type": "address"
                },
                {
                  "name": "TricryptoNg",
                  "type": "address"
                },
                {
                  "name": "TwoCrypto",
                  "type": "address"
                },
                {
                  "name": "MetaPool",
                  "type": "address"
                },
                {
                  "name": "RateProvider",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_undyHq",
              "type": "address"
            },
            {
              "name": "_curveAddressProvider",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "interfaces/WalletStructs.vyi": {
            "content": "# @version 0.4.3\n\nflag ActionType:\n    TRANSFER\n    EARN_DEPOSIT\n    EARN_WITHDRAW\n    EARN_REBALANCE\n    SWAP\n    MINT_REDEEM\n    CONFIRM_MINT_REDEEM\n    ADD_COLLATERAL\n    REMOVE_COLLATERAL\n    BORROW\n    REPAY_DEBT\n    REWARDS\n    ETH_TO_WETH\n    WETH_TO_ETH\n    ADD_LIQ\n    REMOVE_LIQ\n    ADD_LIQ_CONC\n    REMOVE_LIQ_CONC\n    PAY_CHEQUE\n\nstruct WalletAssetData:\n    assetBalance: uint256\n    usdValue: uint256\n    isYieldAsset: bool\n    lastPricePerShare: uint256\n\nstruct ActionData:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    billing: address\n    wallet: address\n    walletConfig: address\n    walletOwner: address\n    inEjectMode: bool\n    isFrozen: bool\n    lastTotalUsdValue: uint256\n    signer: address\n    isManager: bool\n    legoId: uint256\n    legoAddr: address\n    eth: address\n    weth: address\n\nstruct MiniAddys:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    appraiser: address",
            "sha256sum": "9a4b4f59b3a62043e51b425a665064aae419a3c0bd0514b6b29a9441ae364bb9"
          },
          "interfaces/LegoPartner.vyi": {
            "content": "# @version 0.4.3\n\nfrom interfaces import WalletStructs as ws\n\nMAX_TOKEN_PATH: constant(uint256) = 5\nMAX_RECOVER_ASSETS: constant(uint256) = 20\n\n@external\ndef addLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _tickLower: int24, _tickUpper: int24, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef addLiquidity(_pool: address, _tokenA: address, _tokenB: address, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _minLpAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (address, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef removeLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _liqToRemove: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef removeLiquidity(_pool: address, _tokenA: address, _tokenB: address, _lpToken: address, _lpAmount: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef mintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _tokenInAmount: uint256, _minAmountOut: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef swapTokens(_amountIn: uint256, _minAmountOut: uint256, _tokenPath: DynArray[address, MAX_TOKEN_PATH], _poolPath: DynArray[address, MAX_TOKEN_PATH - 1], _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256):\n    ...\n\n@external\ndef depositForYield(_asset: address, _amount: uint256, _vaultAddr: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef withdrawFromYield(_vaultToken: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef confirmMintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef borrow(_borrowAsset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef repayDebt(_paymentAsset: address, _paymentAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef claimRewards(_user: address, _rewardToken: address, _rewardAmount: uint256, _extraData: bytes32, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef removeCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef addCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@view\n@external\ndef getAccessForLego(_user: address, _action: ws.ActionType) -> (address, String[64], uint256):\n    ...\n\n@view\n@external\ndef hasCapability(_action: ws.ActionType) -> bool:\n    ...\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    ...\n\n@view\n@external\ndef isYieldLego() -> bool:\n    ...\n\n@view\n@external\ndef isDexLego() -> bool:\n    ...\n\n@view\n@external\ndef getPricePerShare(_asset: address, _decimals: uint256) -> uint256:\n    ...\n\n@view\n@external\ndef getPrice(_asset: address, _decimals: uint256) -> uint256:\n    ...\n\n\n# common\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "2513e379aa74d0a8120114a5078a4c1a0900165a1c3f24419bb811d173b56453"
          },
          "interfaces/DexLego.vyi": {
            "content": "# @version 0.4.3\n\n# used in smart contracts\n\n\n@view\n@external\ndef getLpToken(_pool: address) -> address:\n    ...\n\n\n# helper functions for server\n\n\n@view\n@external\ndef getPoolForLpToken(_lpToken: address) -> address:\n    ...\n\n\n@view\n@external\ndef getSwapAmountOut(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n) -> uint256:\n    ...\n\n\n@view\n@external\ndef getSwapAmountIn(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountOut: uint256,\n) -> uint256:\n    ...\n\n\n@view\n@external\ndef getAddLiqAmountsIn(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _availAmountA: uint256,\n    _availAmountB: uint256,\n) -> (uint256, uint256, uint256):\n    ...\n\n\n@view\n@external\ndef getRemoveLiqAmountsOut(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpAmount: uint256,\n) -> (uint256, uint256):\n    ...\n\n\n@view\n@external\ndef getPriceUnsafe(_pool: address, _targetToken: address, _appraiser: address = empty(address)) -> uint256:\n    ...\n\n\n@view\n@external\ndef getBestSwapAmountOut(_tokenIn: address, _tokenOut: address, _amountIn: uint256) -> (address, uint256):\n    ...\n\n\n@view\n@external\ndef getBestSwapAmountIn(_tokenIn: address, _tokenOut: address, _amountOut: uint256) -> (address, uint256):\n    ...\n\n\n@view\n@external\ndef getCoreRouterPool() -> address:\n    ...\n",
            "sha256sum": "44b192d0249c04d635acb9c758c41ebba7014d9287315bc1f7a7cb2646e69631"
          },
          "contracts/modules/Addys.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\ninterface UndyHq:\n    def isValidAddr(_addr: address) -> bool: view\n    def getAddr(_regId: uint256) -> address: view\n    def undyToken() -> address: view\n\ninterface Switchboard:\n    def isSwitchboardAddr(_addr: address) -> bool: view\n\ninterface LegoBook:\n    def isLegoAddr(_addr: address) -> bool: view\n\nstruct Addys:\n    hq: address\n    undyToken: address\n    ledger: address\n    missionControl: address\n    legoBook: address\n    switchboard: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    walletBackpack: address\n    billing: address\n\n# hq\nUNDY_HQ_FOR_ADDYS: immutable(address)\n\n# core addys\nLEDGER_ID: constant(uint256) = 1\nMISSION_CONTROL_ID: constant(uint256) = 2\nLEGO_BOOK_ID: constant(uint256) = 3\nSWITCHBOARD_ID: constant(uint256) = 4\nHATCHERY_ID: constant(uint256) = 5\nLOOT_DISTRIBUTOR_ID: constant(uint256) = 6\nAPPRAISER_ID: constant(uint256) = 7\nWALLET_BACKPACK_ID: constant(uint256) = 8\nBILLING_ID: constant(uint256) = 9\n\n\n@deploy\ndef __init__(_undyHq: address):\n    assert _undyHq != empty(address) # dev: invalid undy hq\n    UNDY_HQ_FOR_ADDYS = _undyHq\n\n\n########\n# Core #\n########\n\n\n@view\n@external\ndef getAddys() -> Addys:\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _getAddys(_addys: Addys = empty(Addys)) -> Addys:\n    if _addys.hq != empty(address):\n        return _addys\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _generateAddys() -> Addys:\n    hq: address = UNDY_HQ_FOR_ADDYS\n    return Addys(\n        hq = hq,\n        undyToken = staticcall UndyHq(hq).undyToken(),\n        ledger = staticcall UndyHq(hq).getAddr(LEDGER_ID),\n        missionControl = staticcall UndyHq(hq).getAddr(MISSION_CONTROL_ID),\n        legoBook = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID),\n        switchboard = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID),\n        hatchery = staticcall UndyHq(hq).getAddr(HATCHERY_ID),\n        lootDistributor = staticcall UndyHq(hq).getAddr(LOOT_DISTRIBUTOR_ID),\n        appraiser = staticcall UndyHq(hq).getAddr(APPRAISER_ID),\n        walletBackpack = staticcall UndyHq(hq).getAddr(WALLET_BACKPACK_ID),\n        billing = staticcall UndyHq(hq).getAddr(BILLING_ID),\n    )\n\n\n##########\n# Tokens #\n##########\n\n\n@view\n@internal\ndef _getUndyToken() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).undyToken()\n\n\n###########\n# Helpers #\n###########\n\n\n# undy hq\n\n\n@view\n@external\ndef getUndyHq() -> address:\n    return self._getUndyHq()\n\n\n@view\n@internal\ndef _getUndyHq() -> address:\n    return UNDY_HQ_FOR_ADDYS\n\n\n# utils\n\n\n@view\n@internal\ndef _isValidUndyAddr(_addr: address, _hq: address = empty(address)) -> bool:\n    hq: address = _hq\n    if _hq == empty(address):\n        hq = UNDY_HQ_FOR_ADDYS\n    \n    # core departments\n    if staticcall UndyHq(hq).isValidAddr(_addr):\n        return True\n\n    # lego book\n    legoBook: address = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID)\n    if legoBook != empty(address) and staticcall LegoBook(legoBook).isLegoAddr(_addr):\n        return True\n\n    # switchboard config\n    switchboard: address = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID)\n    if switchboard != empty(address) and staticcall Switchboard(switchboard).isSwitchboardAddr(_addr):\n        return True\n\n    return False\n\n\n@view\n@internal\ndef _isSwitchboardAddr(_addr: address) -> bool:\n    switchboard: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n    if switchboard == empty(address):\n        return False\n    return staticcall Switchboard(switchboard).isSwitchboardAddr(_addr)\n\n\n@view\n@internal\ndef _isLegoBookAddr(_addr: address) -> bool:\n    legoBook: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n    if legoBook == empty(address):\n        return False\n    return staticcall LegoBook(legoBook).isLegoAddr(_addr)\n\n\n###############\n# Departments #\n###############\n\n\n# ledger\n\n\n@view\n@internal\ndef _getLedgerId() -> uint256:\n    return LEDGER_ID\n\n\n@view\n@internal\ndef _getLedgerAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEDGER_ID)\n\n\n# mission control\n\n\n@view\n@internal\ndef _getMissionControlId() -> uint256:\n    return MISSION_CONTROL_ID\n\n\n@view\n@internal\ndef _getMissionControlAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(MISSION_CONTROL_ID)\n\n\n# lego book\n\n\n@view\n@internal\ndef _getLegoBookId() -> uint256:\n    return LEGO_BOOK_ID\n\n\n@view\n@internal\ndef _getLegoBookAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n\n\n# switchboard\n\n\n@view\n@internal\ndef _getSwitchboardId() -> uint256:\n    return SWITCHBOARD_ID\n\n\n@view\n@internal\ndef _getSwitchboardAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n\n\n# hatchery\n\n\n@view\n@internal\ndef _getHatcheryId() -> uint256:\n    return HATCHERY_ID\n\n\n@view\n@internal\ndef _getHatcheryAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(HATCHERY_ID)\n\n\n# loot distributor\n\n\n@view\n@internal\ndef _getLootDistributorId() -> uint256:\n    return LOOT_DISTRIBUTOR_ID\n\n\n@view\n@internal\ndef _getLootDistributorAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LOOT_DISTRIBUTOR_ID)\n\n\n# appraiser\n\n\n@view\n@internal\ndef _getAppraiserId() -> uint256:\n    return APPRAISER_ID\n\n\n@view\n@internal\ndef _getAppraiserAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(APPRAISER_ID)\n\n\n# wallet backpack\n\n\n@view\n@internal\ndef _getWalletBackpackId() -> uint256:\n    return WALLET_BACKPACK_ID\n\n\n@view\n@internal\ndef _getWalletBackpackAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(WALLET_BACKPACK_ID)\n\n\n# billing\n\n\n@view\n@internal\ndef _getBillingId() -> uint256:\n    return BILLING_ID\n\n\n@view\n@internal\ndef _getBillingAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(BILLING_ID)",
            "sha256sum": "78b58f0b2acb2eaafa4d21adf9135a1cd0e1d53897f7a1fa70a83a04a7738ad3"
          },
          "contracts/modules/DexLegoData.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nuses: addys\n\nimport contracts.modules.Addys as addys\n\nfrom interfaces import WalletStructs as ws\nfrom ethereum.ercs import IERC20\n\nevent LegoPauseModified:\n    isPaused: bool\n\nevent LegoFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    balance: uint256\n\n# config\nlegoId: public(uint256)\nisPaused: public(bool)\n\nMAX_RECOVER_ASSETS: constant(uint256) = 20\n\n\n@deploy\ndef __init__(_shouldPause: bool):\n    self.isPaused = _shouldPause\n\n\n###########\n# General #\n###########\n\n\n# fill mini addys\n\n\n@view\n@internal\ndef _getMiniAddys(_miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> ws.MiniAddys:\n    if _miniAddys.ledger != empty(address):\n        return _miniAddys\n    return ws.MiniAddys(\n        ledger = addys._getLedgerAddr(),\n        missionControl = addys._getMissionControlAddr(),\n        legoBook = addys._getLegoBookAddr(),\n        appraiser = addys._getAppraiserAddr(),\n    )\n\n\n# activate\n\n\n@external\ndef pause(_shouldPause: bool):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert _shouldPause != self.isPaused # dev: no change\n    self.isPaused = _shouldPause\n    log LegoPauseModified(isPaused=_shouldPause)\n\n\n# recover funds\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    self._recoverFunds(_recipient, _asset)\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, MAX_RECOVER_ASSETS]):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    for a: address in _assets:\n        self._recoverFunds(_recipient, a)\n\n\n@internal\ndef _recoverFunds(_recipient: address, _asset: address):\n    assert empty(address) not in [_recipient, _asset] # dev: invalid recipient or asset\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    assert balance != 0 # dev: nothing to recover\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log LegoFundsRecovered(asset=_asset, recipient=_recipient, balance=balance)",
            "sha256sum": "75b15af2475ab409d4b5fd057509d14c20564ebd7fcb0850e3b61397d8e3af48"
          },
          "contracts/legos/dexes/Curve.vy": {
            "content": "#     _____  _____  __  __    ____   _____  _____  _____ \n#    |  _  \\/   __\\/  \\/  \\  /  _/  /   __\\/   __\\/  _  \\\n#    |  |  ||   __|>-    -<  |  |---|   __||  |_ ||  |  |\n#    |_____/\\_____/\\__/\\__/  \\_____/\\_____/\\_____/\\_____/\n#                                                                       \n#     \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n#     \u2551  ** Curve Lego **              \u2551\n#     \u2551  Integration with Curve DEX.   \u2551\n#     \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n#\n#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n# pragma optimize codesize\n\nimplements: DexLego\n\nexports: addys.__interface__\nexports: dld.__interface__\n\ninitializes: addys\ninitializes: dld[addys := addys]\n\nfrom interfaces import LegoPartner as Lego\nfrom interfaces import DexLego as DexLego\nfrom interfaces import WalletStructs as ws\n\nimport contracts.modules.Addys as addys\nimport contracts.modules.DexLegoData as dld\n\nfrom ethereum.ercs import IERC20\nfrom ethereum.ercs import IERC20Detailed\n\ninterface CurveMetaRegistry:\n    def get_coin_indices(_pool: address, _from: address, _to: address) -> (int128, int128, bool): view\n    def find_pools_for_coins(_from: address, _to: address) -> DynArray[address, MAX_POOLS]: view\n    def get_registry_handlers_from_pool(_pool: address) -> address[10]: view\n    def get_pool_from_lp_token(_lpToken: address) -> address: view\n    def get_base_registry(_addr: address) -> address: view\n    def get_balances(_pool: address) -> uint256[8]: view\n    def get_coins(_pool: address) -> address[8]: view\n    def get_n_coins(_pool: address) -> uint256: view\n    def get_lp_token(_pool: address) -> address: view\n    def is_registered(_pool: address) -> bool: view\n    def is_meta(_pool: address) -> bool: view\n\ninterface TwoCryptoPool:\n    def remove_liquidity_one_coin(_lpBurnAmount: uint256, _index: uint256, _minAmountOut: uint256, _useEth: bool = False, _recipient: address = msg.sender) -> uint256: nonpayable\n    def exchange(_i: uint256, _j: uint256, _dx: uint256, _min_dy: uint256, _use_eth: bool = False, _receiver: address = msg.sender) -> uint256: payable\n    def remove_liquidity(_lpBurnAmount: uint256, _minAmountsOut: uint256[2], _useEth: bool = False, _recipient: address = msg.sender): nonpayable\n    def add_liquidity(_amounts: uint256[2], _minLpAmount: uint256, _useEth: bool = False, _recipient: address = msg.sender) -> uint256: payable\n    def calc_withdraw_one_coin(_burnAmount: uint256, _index: uint256) -> uint256: view\n    def calc_token_amount(_amounts: uint256[2]) -> uint256: view\n\ninterface TwoCryptoNgPool:\n    def remove_liquidity_one_coin(_lpBurnAmount: uint256, _index: uint256, _minAmountOut: uint256, _recipient: address = msg.sender) -> uint256: nonpayable\n    def remove_liquidity(_lpBurnAmount: uint256, _minAmountsOut: uint256[2], _recipient: address = msg.sender) -> uint256[2]: nonpayable\n    def exchange(i: uint256, j: uint256, dx: uint256, min_dy: uint256, receiver: address = msg.sender) -> uint256: nonpayable\n    def add_liquidity(_amounts: uint256[2], _minLpAmount: uint256, _recipient: address = msg.sender) -> uint256: nonpayable\n    def calc_withdraw_one_coin(_burnAmount: uint256, _index: uint256) -> uint256: view\n    def calc_token_amount(_amounts: uint256[2], _isDeposit: bool) -> uint256: view\n\ninterface StableNgTwo:\n    def remove_liquidity(_lpBurnAmount: uint256, _minAmountsOut: DynArray[uint256, 2], _recipient: address = msg.sender, _claimAdminFees: bool = True) -> DynArray[uint256, 2]: nonpayable\n    def remove_liquidity_one_coin(_lpBurnAmount: uint256, _index: int128, _minAmountOut: uint256, _recipient: address = msg.sender) -> uint256: nonpayable\n    def add_liquidity(_amounts: DynArray[uint256, 2], _minLpAmount: uint256, _recipient: address = msg.sender) -> uint256: nonpayable\n    def calc_token_amount(_amounts: DynArray[uint256, 2], _isDeposit: bool) -> uint256: view\n    def calc_withdraw_one_coin(_burnAmount: uint256, _index: int128) -> uint256: view\n\ninterface TriCryptoPool:\n    def remove_liquidity(_lpBurnAmount: uint256, _minAmountsOut: uint256[3], _useEth: bool = False, _recipient: address = msg.sender, _claimAdminFees: bool = True) -> uint256[3]: nonpayable\n    def remove_liquidity_one_coin(_lpBurnAmount: uint256, _index: uint256, _minAmountOut: uint256, _useEth: bool = False, _recipient: address = msg.sender) -> uint256: nonpayable\n    def add_liquidity(_amounts: uint256[3], _minLpAmount: uint256, _useEth: bool = False, _recipient: address = msg.sender) -> uint256: payable\n    def calc_withdraw_one_coin(_burnAmount: uint256, _index: uint256) -> uint256: view\n    def calc_token_amount(_amounts: uint256[3], _isDeposit: bool) -> uint256: view\n\ninterface MetaPoolTwo:\n    def remove_liquidity(_lpBurnAmount: uint256, _minAmountsOut: uint256[2], _recipient: address = msg.sender) -> uint256[2]: nonpayable\n    def add_liquidity(_amounts: uint256[2], _minLpAmount: uint256, _recipient: address = msg.sender) -> uint256: nonpayable\n    def calc_token_amount(_amounts: uint256[2], _isDeposit: bool) -> uint256: view\n\ninterface MetaPoolThree:\n    def remove_liquidity(_lpBurnAmount: uint256, _minAmountsOut: uint256[3], _recipient: address = msg.sender) -> uint256[3]: nonpayable\n    def add_liquidity(_amounts: uint256[3], _minLpAmount: uint256, _recipient: address = msg.sender) -> uint256: nonpayable\n    def calc_token_amount(_amounts: uint256[3], _isDeposit: bool) -> uint256: view\n\ninterface MetaPoolFour:\n    def remove_liquidity(_lpBurnAmount: uint256, _minAmountsOut: uint256[4], _recipient: address = msg.sender) -> uint256[4]: nonpayable\n    def add_liquidity(_amounts: uint256[4], _minLpAmount: uint256, _recipient: address = msg.sender) -> uint256: nonpayable\n    def calc_token_amount(_amounts: uint256[4], _isDeposit: bool) -> uint256: view\n\ninterface Appraiser:\n    def getNormalAssetPrice(_asset: address, _missionControl: address = empty(address), _legoBook: address = empty(address), _ledger: address = empty(address)) -> uint256: view\n    def updatePriceAndGetUsdValue(_asset: address, _amount: uint256, _missionControl: address = empty(address), _legoBook: address = empty(address)) -> uint256: nonpayable\n\ninterface MetaPoolCommon:\n    def remove_liquidity_one_coin(_lpBurnAmount: uint256, _index: int128, _minAmountOut: uint256, _recipient: address = msg.sender) -> uint256: nonpayable\n    def calc_withdraw_one_coin(_burnAmount: uint256, _index: int128) -> uint256: view\n\ninterface StableNgThree:\n    def add_liquidity(_amounts: DynArray[uint256, 3], _minLpAmount: uint256, _recipient: address = msg.sender) -> uint256: nonpayable\n    def calc_token_amount(_amounts: DynArray[uint256, 3], _isDeposit: bool) -> uint256: view\n\ninterface StableNgFour:\n    def add_liquidity(_amounts: DynArray[uint256, 4], _minLpAmount: uint256, _recipient: address = msg.sender) -> uint256: nonpayable\n    def calc_token_amount(_amounts: DynArray[uint256, 4], _isDeposit: bool) -> uint256: view\n\ninterface CommonCurvePool:\n    def exchange(_i: int128, _j: int128, _dx: uint256, _min_dy: uint256, _receiver: address = msg.sender) -> uint256: nonpayable\n    def fee() -> uint256: view\n\ninterface CurveRateProvider:\n    def get_quotes(_tokenIn: address, _tokenOut: address, _amountIn: uint256) -> DynArray[Quote, MAX_QUOTES]: view\n    def get_aggregated_rate(_tokenIn: address, _tokenOut: address) -> uint256: view\n\ninterface CryptoLegacyPool:\n    def exchange(_i: uint256, _j: uint256, _dx: uint256, _min_dy: uint256, _use_eth: bool = False) -> uint256: payable\n\ninterface OracleRegistry:\n    def getUsdValue(_asset: address, _amount: uint256, _shouldRaise: bool = False) -> uint256: view\n\ninterface CurveAddressProvider:\n    def get_address(_id: uint256) -> address: view\n\nflag PoolType:\n    STABLESWAP_NG\n    TWO_CRYPTO_NG\n    TRICRYPTO_NG\n    TWO_CRYPTO\n    METAPOOL\n    CRYPTO\n\nstruct Quote:\n    source_token_index: uint256\n    dest_token_index: uint256\n    is_underlying: bool\n    amount_out: uint256\n    pool: address\n    source_token_pool_balance: uint256\n    dest_token_pool_balance: uint256\n    pool_type: uint8\n\nstruct PoolData:\n    pool: address\n    indexTokenA: uint256\n    indexTokenB: uint256\n    poolType: PoolType\n    numCoins: uint256\n\nstruct BestPool:\n    pool: address\n    fee: uint256\n    liquidity: uint256\n    numCoins: uint256\n\nstruct CurveRegistries:\n    StableSwapNg: address\n    TwoCryptoNg: address\n    TricryptoNg: address\n    TwoCrypto: address\n    MetaPool: address\n    RateProvider: address\n\nevent CurveSwap:\n    sender: indexed(address)\n    tokenIn: indexed(address)\n    tokenOut: indexed(address)\n    amountIn: uint256\n    amountOut: uint256\n    usdValue: uint256\n    numTokens: uint256\n    recipient: address\n\nevent CurveLiquidityAdded:\n    sender: indexed(address)\n    tokenA: indexed(address)\n    tokenB: indexed(address)\n    amountA: uint256\n    amountB: uint256\n    lpAmountReceived: uint256\n    usdValue: uint256\n    recipient: address\n\nevent CurveLiquidityRemoved:\n    sender: address\n    pool: indexed(address)\n    tokenA: indexed(address)\n    tokenB: indexed(address)\n    amountA: uint256\n    amountB: uint256\n    lpToken: address\n    lpAmountBurned: uint256\n    usdValue: uint256\n    recipient: address\n\n# curve\nCURVE_META_REGISTRY: public(immutable(address))\nCURVE_REGISTRIES: public(immutable(CurveRegistries))\n\n# curve address provider ids\nMETAPOOL_FACTORY_ID: constant(uint256) = 3\nTWO_CRYPTO_FACTORY_ID: constant(uint256) = 6\nMETA_REGISTRY_ID: constant(uint256) = 7\nTRICRYPTO_NG_FACTORY_ID: constant(uint256) = 11\nSTABLESWAP_NG_FACTORY_ID: constant(uint256) = 12\nTWO_CRYPTO_NG_FACTORY_ID: constant(uint256) = 13\nRATE_PROVIDER_ID: constant(uint256) = 18\n\nMAX_POOLS: constant(uint256) = 50\nMAX_QUOTES: constant(uint256) = 100\nMAX_TOKEN_PATH: constant(uint256) = 5\n\n\n@deploy\ndef __init__(_undyHq: address, _curveAddressProvider: address):\n    addys.__init__(_undyHq)\n    dld.__init__(False)\n\n    CURVE_META_REGISTRY = staticcall CurveAddressProvider(_curveAddressProvider).get_address(META_REGISTRY_ID)\n    CURVE_REGISTRIES = CurveRegistries(\n        StableSwapNg= staticcall CurveAddressProvider(_curveAddressProvider).get_address(STABLESWAP_NG_FACTORY_ID),\n        TwoCryptoNg= staticcall CurveAddressProvider(_curveAddressProvider).get_address(TWO_CRYPTO_NG_FACTORY_ID),\n        TricryptoNg= staticcall CurveAddressProvider(_curveAddressProvider).get_address(TRICRYPTO_NG_FACTORY_ID),\n        TwoCrypto= staticcall CurveAddressProvider(_curveAddressProvider).get_address(TWO_CRYPTO_FACTORY_ID),\n        MetaPool= staticcall CurveAddressProvider(_curveAddressProvider).get_address(METAPOOL_FACTORY_ID),\n        RateProvider= staticcall CurveAddressProvider(_curveAddressProvider).get_address(RATE_PROVIDER_ID),\n    )\n\n\n@view\n@external\ndef hasCapability(_action: ws.ActionType) -> bool:\n    return _action in (\n        ws.ActionType.SWAP |\n        ws.ActionType.ADD_LIQ | \n        ws.ActionType.REMOVE_LIQ\n    )\n\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    return [CURVE_META_REGISTRY]\n\n\n@view\n@external\ndef isYieldLego() -> bool:\n    return False\n\n\n@view\n@external\ndef isDexLego() -> bool:\n    return True\n\n\n#########\n# Swaps #\n#########\n\n\n@external\ndef swapTokens(\n    _amountIn: uint256,\n    _minAmountOut: uint256,\n    _tokenPath: DynArray[address, MAX_TOKEN_PATH],\n    _poolPath: DynArray[address, MAX_TOKEN_PATH - 1],\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256):\n    assert not dld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = dld._getMiniAddys(_miniAddys)\n\n    # validate inputs\n    numTokens: uint256 = len(_tokenPath)\n    numPools: uint256 = len(_poolPath)\n    assert numTokens >= 2 # dev: invalid path\n    assert numPools == numTokens - 1 # dev: invalid path\n\n    # get first token and last token\n    tokenIn: address = _tokenPath[0]\n    tokenOut: address = _tokenPath[numTokens - 1]\n\n    # pre balances\n    preLegoBalance: uint256 = staticcall IERC20(tokenIn).balanceOf(self)\n\n    # transfer deposit asset to this contract\n    amountIn: uint256 = min(_amountIn, staticcall IERC20(tokenIn).balanceOf(msg.sender))\n    assert amountIn != 0 # dev: nothing to transfer\n    assert extcall IERC20(tokenIn).transferFrom(msg.sender, self, amountIn, default_return_value=True) # dev: transfer failed\n\n    # iterate through swap routes\n    tempAmountIn: uint256 = amountIn\n    curveMetaRegistry: address = CURVE_META_REGISTRY\n    for i: uint256 in range(numTokens - 1, bound=MAX_TOKEN_PATH):\n        tempTokenIn: address = _tokenPath[i]\n        tempTokenOut: address = _tokenPath[i + 1]\n        tempPool: address = _poolPath[i]\n\n        # transfer to self (or to recipient if last swap)\n        recipient: address = _recipient\n        if i < numTokens - 2:\n            recipient = self\n\n        # swap\n        tempAmountIn = self._swapTokensInPool(tempPool, tempTokenIn, tempTokenOut, tempAmountIn, recipient, curveMetaRegistry)\n\n    # final amount\n    amountOut: uint256 = tempAmountIn\n    assert amountOut >= _minAmountOut # dev: min amount out not met\n\n    # refund if full swap didn't get through\n    currentLegoBalance: uint256 = staticcall IERC20(tokenIn).balanceOf(self)\n    refundAssetAmount: uint256 = 0\n    if currentLegoBalance > preLegoBalance:\n        refundAssetAmount = currentLegoBalance - preLegoBalance\n        assert extcall IERC20(tokenIn).transfer(msg.sender, refundAssetAmount, default_return_value=True) # dev: transfer failed\n        amountIn -= refundAssetAmount\n\n    # get usd values\n    usdValue: uint256 = extcall Appraiser(miniAddys.appraiser).updatePriceAndGetUsdValue(tokenIn, amountIn, miniAddys.missionControl, miniAddys.legoBook)\n    if usdValue == 0:\n        usdValue = extcall Appraiser(miniAddys.appraiser).updatePriceAndGetUsdValue(tokenOut, amountOut, miniAddys.missionControl, miniAddys.legoBook)\n\n    log CurveSwap(\n        sender = msg.sender,\n        tokenIn = tokenIn,\n        tokenOut = tokenOut,\n        amountIn = amountIn,\n        amountOut = amountOut,\n        usdValue = usdValue,\n        numTokens = numTokens,\n        recipient = _recipient,\n    )\n    return amountIn, amountOut, usdValue\n\n\n# swap in pool\n\n\n@internal\ndef _swapTokensInPool(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n    _recipient: address,\n    _curveMetaRegistry: address,\n) -> uint256:\n    amountOut: uint256 = 0\n    p: PoolData = self._getPoolData(_pool, _tokenIn, _tokenOut, _curveMetaRegistry)\n    assert extcall IERC20(_tokenIn).approve(_pool, _amountIn, default_return_value=True) # dev: approval failed\n\n    # stable ng\n    if p.poolType == PoolType.STABLESWAP_NG:\n        amountOut = extcall CommonCurvePool(_pool).exchange(convert(p.indexTokenA, int128), convert(p.indexTokenB, int128), _amountIn, 0, _recipient)\n\n    # two crypto ng\n    elif p.poolType == PoolType.TWO_CRYPTO_NG:\n        amountOut = extcall TwoCryptoNgPool(_pool).exchange(p.indexTokenA, p.indexTokenB, _amountIn, 0, _recipient)\n\n    # two crypto + tricrypto ng pools\n    elif p.poolType == PoolType.TRICRYPTO_NG or p.poolType == PoolType.TWO_CRYPTO:\n        amountOut = extcall TwoCryptoPool(_pool).exchange(p.indexTokenA, p.indexTokenB, _amountIn, 0, False, _recipient)\n\n    # meta pools\n    elif p.poolType == PoolType.METAPOOL:\n        if staticcall CurveMetaRegistry(_curveMetaRegistry).is_meta(_pool):\n            raise \"Not Implemented\"\n        else:\n            amountOut = extcall CommonCurvePool(_pool).exchange(convert(p.indexTokenA, int128), convert(p.indexTokenB, int128), _amountIn, 0, _recipient)\n\n    # crypto v1\n    else:\n        amountOut = extcall CryptoLegacyPool(_pool).exchange(p.indexTokenA, p.indexTokenB, _amountIn, 0, False)\n        if _recipient != self:\n            assert extcall IERC20(_tokenOut).transfer(_recipient, amountOut, default_return_value=True) # dev: transfer failed\n\n    assert extcall IERC20(_tokenIn).approve(_pool, 0, default_return_value=True) # dev: approval failed\n    assert amountOut != 0 # dev: no tokens swapped\n    return amountOut\n\n\n#################\n# Add Liquidity #\n#################\n\n\n@external\ndef addLiquidity(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _amountA: uint256,\n    _amountB: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _minLpAmount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (address, uint256, uint256, uint256, uint256):\n    assert not dld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = dld._getMiniAddys(_miniAddys)\n\n    assert empty(address) not in [_tokenA, _tokenB] # dev: invalid tokens\n    assert _tokenA != _tokenB # dev: invalid tokens\n\n    # pre balances\n    preLegoBalanceA: uint256 = staticcall IERC20(_tokenA).balanceOf(self)\n    preLegoBalanceB: uint256 = staticcall IERC20(_tokenB).balanceOf(self)\n\n    # token a\n    liqAmountA: uint256 = min(_amountA, staticcall IERC20(_tokenA).balanceOf(msg.sender))\n    if liqAmountA != 0:\n        assert extcall IERC20(_tokenA).transferFrom(msg.sender, self, liqAmountA, default_return_value=True) # dev: transfer failed\n        assert extcall IERC20(_tokenA).approve(_pool, liqAmountA, default_return_value=True) # dev: approval failed\n\n    # token b\n    liqAmountB: uint256 = min(_amountB, staticcall IERC20(_tokenB).balanceOf(msg.sender))\n    if liqAmountB != 0:\n        assert extcall IERC20(_tokenB).transferFrom(msg.sender, self, liqAmountB, default_return_value=True) # dev: transfer failed\n        assert extcall IERC20(_tokenB).approve(_pool, liqAmountB, default_return_value=True) # dev: approval failed\n\n    assert liqAmountA != 0 or liqAmountB != 0 # dev: need at least one token amount\n\n    # pool data\n    metaRegistry: address = CURVE_META_REGISTRY\n    p: PoolData = self._getPoolData(_pool, _tokenA, _tokenB, metaRegistry)\n\n    # add liquidity\n    lpAmountReceived: uint256 = 0\n    if p.poolType == PoolType.STABLESWAP_NG:\n        lpAmountReceived = self._addLiquidityStableNg(p, liqAmountA, liqAmountB, _minLpAmount, _recipient)\n    elif p.poolType == PoolType.TWO_CRYPTO_NG:\n        lpAmountReceived = self._addLiquidityTwoCryptoNg(p, liqAmountA, liqAmountB, _minLpAmount, _recipient)\n    elif p.poolType == PoolType.TWO_CRYPTO:\n        lpAmountReceived = self._addLiquidityTwoCrypto(p, liqAmountA, liqAmountB, _minLpAmount, _recipient)\n    elif p.poolType == PoolType.TRICRYPTO_NG:\n        lpAmountReceived = self._addLiquidityTricrypto(p, liqAmountA, liqAmountB, _minLpAmount, _recipient)\n    elif p.poolType == PoolType.METAPOOL and not staticcall CurveMetaRegistry(metaRegistry).is_meta(p.pool):\n        lpAmountReceived = self._addLiquidityMetaPool(p, liqAmountA, liqAmountB, _minLpAmount, _recipient)\n    assert lpAmountReceived != 0 # dev: no liquidity added\n\n    # handle token a refunds / approvals\n    refundAssetAmountA: uint256 = 0\n    if liqAmountA != 0:\n        assert extcall IERC20(_tokenA).approve(_pool, 0, default_return_value=True) # dev: approval failed\n\n        currentLegoBalanceA: uint256 = staticcall IERC20(_tokenA).balanceOf(self)\n        if currentLegoBalanceA > preLegoBalanceA:\n            refundAssetAmountA = currentLegoBalanceA - preLegoBalanceA\n            assert extcall IERC20(_tokenA).transfer(msg.sender, refundAssetAmountA, default_return_value=True) # dev: transfer failed\n            liqAmountA -= refundAssetAmountA\n\n    # handle token b refunds / approvals\n    refundAssetAmountB: uint256 = 0\n    if liqAmountB != 0:\n        assert extcall IERC20(_tokenB).approve(_pool, 0, default_return_value=True) # dev: approval failed\n\n        currentLegoBalanceB: uint256 = staticcall IERC20(_tokenB).balanceOf(self)\n        if currentLegoBalanceB > preLegoBalanceB:\n            refundAssetAmountB = currentLegoBalanceB - preLegoBalanceB\n            assert extcall IERC20(_tokenB).transfer(msg.sender, refundAssetAmountB, default_return_value=True) # dev: transfer failed\n            liqAmountB -= refundAssetAmountB\n\n    usdValue: uint256 = self._getUsdValue(_tokenA, liqAmountA, _tokenB, liqAmountB, miniAddys)\n    log CurveLiquidityAdded(\n        sender = msg.sender,\n        tokenA = _tokenA,\n        tokenB = _tokenB,\n        amountA = liqAmountA,\n        amountB = liqAmountB,\n        lpAmountReceived = lpAmountReceived,\n        usdValue = usdValue,\n        recipient = _recipient,\n    )\n    lpToken: address = staticcall CurveMetaRegistry(metaRegistry).get_lp_token(_pool)\n    return lpToken, lpAmountReceived, liqAmountA, liqAmountB, usdValue\n\n\n@internal\ndef _addLiquidityStableNg(\n    _p: PoolData,\n    _liqAmountA: uint256,\n    _liqAmountB: uint256,\n    _minLpAmount: uint256,\n    _recipient: address,\n) -> uint256:\n    lpAmountReceived: uint256 = 0\n\n    if _p.numCoins == 2:\n        amounts: DynArray[uint256, 2] = [0, 0]\n        amounts[_p.indexTokenA] = _liqAmountA\n        amounts[_p.indexTokenB] = _liqAmountB\n        lpAmountReceived = extcall StableNgTwo(_p.pool).add_liquidity(amounts, _minLpAmount, _recipient)\n\n    elif _p.numCoins == 3:\n        amounts: DynArray[uint256, 3] = [0, 0, 0]\n        amounts[_p.indexTokenA] = _liqAmountA\n        amounts[_p.indexTokenB] = _liqAmountB\n        lpAmountReceived = extcall StableNgThree(_p.pool).add_liquidity(amounts, _minLpAmount, _recipient)\n\n    elif _p.numCoins == 4:\n        amounts: DynArray[uint256, 4] = [0, 0, 0, 0]\n        amounts[_p.indexTokenA] = _liqAmountA\n        amounts[_p.indexTokenB] = _liqAmountB\n        lpAmountReceived = extcall StableNgFour(_p.pool).add_liquidity(amounts, _minLpAmount, _recipient)\n\n    return lpAmountReceived\n\n\n@internal\ndef _addLiquidityTwoCryptoNg(\n    _p: PoolData,\n    _liqAmountA: uint256,\n    _liqAmountB: uint256,\n    _minLpAmount: uint256,\n    _recipient: address,\n) -> uint256:\n    amounts: uint256[2] = [0, 0]\n    amounts[_p.indexTokenA] = _liqAmountA\n    amounts[_p.indexTokenB] = _liqAmountB\n    return extcall TwoCryptoNgPool(_p.pool).add_liquidity(amounts, _minLpAmount, _recipient)\n\n\n@internal\ndef _addLiquidityTwoCrypto(\n    _p: PoolData,\n    _liqAmountA: uint256,\n    _liqAmountB: uint256,\n    _minLpAmount: uint256,\n    _recipient: address,\n) -> uint256:\n    amounts: uint256[2] = [0, 0]\n    amounts[_p.indexTokenA] = _liqAmountA\n    amounts[_p.indexTokenB] = _liqAmountB\n    return extcall TwoCryptoPool(_p.pool).add_liquidity(amounts, _minLpAmount, False, _recipient)\n\n\n@internal\ndef _addLiquidityTricrypto(\n    _p: PoolData,\n    _liqAmountA: uint256,\n    _liqAmountB: uint256,\n    _minLpAmount: uint256,\n    _recipient: address,\n) -> uint256:\n    amounts: uint256[3] = [0, 0, 0]\n    amounts[_p.indexTokenA] = _liqAmountA\n    amounts[_p.indexTokenB] = _liqAmountB\n    return extcall TriCryptoPool(_p.pool).add_liquidity(amounts, _minLpAmount, False, _recipient)\n\n\n@internal\ndef _addLiquidityMetaPool(\n    _p: PoolData,\n    _liqAmountA: uint256,\n    _liqAmountB: uint256,\n    _minLpAmount: uint256,\n    _recipient: address,\n) -> uint256:\n    lpAmountReceived: uint256 = 0\n\n    if _p.numCoins == 2:\n        amounts: uint256[2] = [0, 0]\n        amounts[_p.indexTokenA] = _liqAmountA\n        amounts[_p.indexTokenB] = _liqAmountB\n        lpAmountReceived = extcall MetaPoolTwo(_p.pool).add_liquidity(amounts, _minLpAmount, _recipient)\n\n    elif _p.numCoins == 3:\n        amounts: uint256[3] = [0, 0, 0]\n        amounts[_p.indexTokenA] = _liqAmountA\n        amounts[_p.indexTokenB] = _liqAmountB\n        lpAmountReceived = extcall MetaPoolThree(_p.pool).add_liquidity(amounts, _minLpAmount, _recipient)\n\n    elif _p.numCoins == 4:\n        amounts: uint256[4] = [0, 0, 0, 0]\n        amounts[_p.indexTokenA] = _liqAmountA\n        amounts[_p.indexTokenB] = _liqAmountB\n        lpAmountReceived = extcall MetaPoolFour(_p.pool).add_liquidity(amounts, _minLpAmount, _recipient)\n\n    return lpAmountReceived\n\n\n####################\n# Remove Liquidity #\n####################\n\n\n@external\ndef removeLiquidity(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpToken: address,\n    _lpAmount: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, uint256):\n    assert not dld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = dld._getMiniAddys(_miniAddys)\n\n    # if one of the tokens is empty, it means they only want to remove liquidity for one token\n    assert _tokenA != empty(address) or _tokenB != empty(address) # dev: invalid tokens\n    assert _tokenA != _tokenB # dev: invalid tokens\n\n    isEmptyTokenA: bool = _tokenA == empty(address)\n    isOneCoinRemoval: bool = isEmptyTokenA or _tokenB == empty(address)\n\n    # pre balance\n    preLegoBalance: uint256 = staticcall IERC20(_lpToken).balanceOf(self)\n\n    # lp token amount\n    lpAmount: uint256 = min(_lpAmount, staticcall IERC20(_lpToken).balanceOf(msg.sender))\n    assert lpAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_lpToken).transferFrom(msg.sender, self, lpAmount, default_return_value=True) # dev: transfer failed\n\n    # approvals\n    assert extcall IERC20(_lpToken).approve(_pool, lpAmount, default_return_value=True) # dev: approval failed\n\n    # pool data\n    metaRegistry: address = CURVE_META_REGISTRY\n    p: PoolData = self._getPoolData(_pool, _tokenA, _tokenB, metaRegistry)\n\n    # remove liquidity\n    amountA: uint256 = 0\n    amountB: uint256 = 0\n    if p.poolType == PoolType.STABLESWAP_NG:\n        if isOneCoinRemoval:\n            amountA, amountB = self._removeLiquidityStableNgOneCoin(p, isEmptyTokenA, lpAmount, _minAmountA, _minAmountB, _recipient)\n        else:\n            amountA, amountB = self._removeLiquidityStableNg(p, lpAmount, _minAmountA, _minAmountB, _recipient)\n    elif p.poolType == PoolType.TWO_CRYPTO_NG:\n        if isOneCoinRemoval:\n            amountA, amountB = self._removeLiquidityTwoCryptoNgOneCoin(p, isEmptyTokenA, lpAmount, _minAmountA, _minAmountB, _recipient)\n        else:\n            amountA, amountB = self._removeLiquidityTwoCryptoNg(p, lpAmount, _minAmountA, _minAmountB, _recipient)\n    elif p.poolType == PoolType.TWO_CRYPTO:\n        if isOneCoinRemoval:\n            amountA, amountB = self._removeLiquidityTwoCryptoOneCoin(p, isEmptyTokenA, lpAmount, _minAmountA, _minAmountB, _recipient)\n        else:\n            amountA, amountB = self._removeLiquidityTwoCrypto(p, lpAmount, _tokenA, _tokenB, _minAmountA, _minAmountB, _recipient)\n    elif p.poolType == PoolType.TRICRYPTO_NG:\n        if isOneCoinRemoval:\n            amountA, amountB = self._removeLiquidityTricryptoOneCoin(p, isEmptyTokenA, lpAmount, _minAmountA, _minAmountB, _recipient)\n        else:\n            amountA, amountB = self._removeLiquidityTricrypto(p, lpAmount, _minAmountA, _minAmountB, _recipient)\n    elif p.poolType == PoolType.METAPOOL and not staticcall CurveMetaRegistry(metaRegistry).is_meta(p.pool):\n        if isOneCoinRemoval:\n            amountA, amountB = self._removeLiquidityMetaPoolOneCoin(p, isEmptyTokenA, lpAmount, _minAmountA, _minAmountB, _recipient)\n        else:\n            amountA, amountB = self._removeLiquidityMetaPool(p, lpAmount, _minAmountA, _minAmountB, _recipient)\n    assert amountA != 0 or amountB != 0 # dev: nothing removed\n\n    # reset approvals\n    assert extcall IERC20(_lpToken).approve(_pool, 0, default_return_value=True) # dev: approval failed\n\n    # refund if full liquidity was not removed\n    currentLegoBalance: uint256 = staticcall IERC20(_lpToken).balanceOf(self)\n    refundedLpAmount: uint256 = 0\n    if currentLegoBalance > preLegoBalance:\n        refundedLpAmount = currentLegoBalance - preLegoBalance\n        assert extcall IERC20(_lpToken).transfer(msg.sender, refundedLpAmount, default_return_value=True) # dev: transfer failed\n        lpAmount -= refundedLpAmount\n\n    usdValue: uint256 = self._getUsdValue(_tokenA, amountA, _tokenB, amountB, miniAddys)\n    log CurveLiquidityRemoved(\n        sender = msg.sender,\n        pool = _pool,\n        tokenA = _tokenA,\n        tokenB = _tokenB,\n        amountA = amountA,\n        amountB = amountB,\n        lpToken = _lpToken,\n        lpAmountBurned = lpAmount,\n        usdValue = usdValue,\n        recipient = _recipient,\n    )\n    return amountA, amountB, lpAmount, usdValue\n\n\n# stable ng\n\n\n@internal\ndef _removeLiquidityStableNgOneCoin(\n    _p: PoolData,\n    _isEmptyTokenA: bool,\n    _lpAmount: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _recipient: address,\n) -> (uint256, uint256):\n    tokenIndex: uint256 = 0\n    minAmountOut: uint256 = 0\n    tokenIndex, minAmountOut = self._getTokenIndexAndMinAmountOut(_isEmptyTokenA, _p.indexTokenA, _p.indexTokenB, _minAmountA, _minAmountB)\n    amountOut: uint256 = extcall StableNgTwo(_p.pool).remove_liquidity_one_coin(_lpAmount, convert(tokenIndex, int128), minAmountOut, _recipient)\n    return self._getTokenAmounts(_isEmptyTokenA, amountOut)\n\n\n@internal\ndef _removeLiquidityStableNg(\n    _p: PoolData,\n    _lpAmount: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _recipient: address,\n) -> (uint256, uint256):\n\n    # only supporting 2-coin pools, can't give minAmountsOut for other coins\n    assert _p.numCoins == 2 # dev: invalid pool\n\n    minAmountsOut: DynArray[uint256, 2] = [0, 0]\n    minAmountsOut[_p.indexTokenA] = _minAmountA\n    minAmountsOut[_p.indexTokenB] = _minAmountB\n\n    # remove liquidity\n    amountsOut: DynArray[uint256, 2] = extcall StableNgTwo(_p.pool).remove_liquidity(_lpAmount, minAmountsOut, _recipient, False)\n    return amountsOut[_p.indexTokenA], amountsOut[_p.indexTokenB]\n\n\n# two crypto ng\n\n\n@internal\ndef _removeLiquidityTwoCryptoNgOneCoin(\n    _p: PoolData,\n    _isEmptyTokenA: bool,\n    _lpAmount: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _recipient: address,\n) -> (uint256, uint256):\n    tokenIndex: uint256 = 0\n    minAmountOut: uint256 = 0\n    tokenIndex, minAmountOut = self._getTokenIndexAndMinAmountOut(_isEmptyTokenA, _p.indexTokenA, _p.indexTokenB, _minAmountA, _minAmountB)\n    amountOut: uint256 = extcall TwoCryptoNgPool(_p.pool).remove_liquidity_one_coin(_lpAmount, tokenIndex, minAmountOut, _recipient)\n    return self._getTokenAmounts(_isEmptyTokenA, amountOut)\n\n\n@internal\ndef _removeLiquidityTwoCryptoNg(\n    _p: PoolData,\n    _lpAmount: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _recipient: address,\n) -> (uint256, uint256):\n\n    # only supporting 2-coin pools, can't give minAmountsOut for other coins\n    assert _p.numCoins == 2 # dev: invalid pool\n\n    minAmountsOut: uint256[2] = [0, 0]\n    minAmountsOut[_p.indexTokenA] = _minAmountA\n    minAmountsOut[_p.indexTokenB] = _minAmountB\n\n    # remove liquidity\n    amountsOut: uint256[2] = extcall TwoCryptoNgPool(_p.pool).remove_liquidity(_lpAmount, minAmountsOut, _recipient)\n    return amountsOut[_p.indexTokenA], amountsOut[_p.indexTokenB]\n\n\n# two crypto\n\n\n@internal\ndef _removeLiquidityTwoCryptoOneCoin(\n    _p: PoolData,\n    _isEmptyTokenA: bool,\n    _lpAmount: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _recipient: address,\n) -> (uint256, uint256):\n    tokenIndex: uint256 = 0\n    minAmountOut: uint256 = 0\n    tokenIndex, minAmountOut = self._getTokenIndexAndMinAmountOut(_isEmptyTokenA, _p.indexTokenA, _p.indexTokenB, _minAmountA, _minAmountB)\n    amountOut: uint256 = extcall TwoCryptoPool(_p.pool).remove_liquidity_one_coin(_lpAmount, tokenIndex, minAmountOut, False, _recipient)\n    return self._getTokenAmounts(_isEmptyTokenA, amountOut)\n\n\n@internal\ndef _removeLiquidityTwoCrypto(\n    _p: PoolData,\n    _lpAmount: uint256,\n    _tokenA: address,\n    _tokenB: address,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _recipient: address,\n) -> (uint256, uint256):\n\n    # only supporting 2-coin pools\n    assert _p.numCoins == 2 # dev: invalid pool\n\n    # pre balances\n    preBalTokenA: uint256 = staticcall IERC20(_tokenA).balanceOf(_recipient)\n    preBalTokenB: uint256 = staticcall IERC20(_tokenB).balanceOf(_recipient)\n\n    # organize min amounts out\n    minAmountsOut: uint256[2] = [0, 0]\n    minAmountsOut[_p.indexTokenA] = _minAmountA\n    minAmountsOut[_p.indexTokenB] = _minAmountB\n\n    # remove liquidity\n    extcall TwoCryptoPool(_p.pool).remove_liquidity(_lpAmount, minAmountsOut, False, _recipient)\n\n    # get amounts\n    amountA: uint256 = 0\n    postBalTokenA: uint256 = staticcall IERC20(_tokenA).balanceOf(_recipient)\n    if postBalTokenA > preBalTokenA:\n        amountA = postBalTokenA - preBalTokenA\n\n    amountB: uint256 = 0\n    postBalTokenB: uint256 = staticcall IERC20(_tokenB).balanceOf(_recipient)\n    if postBalTokenB > preBalTokenB:\n        amountB = postBalTokenB - preBalTokenB\n\n    return amountA, amountB\n\n\n# tricrypto ng\n\n\n@internal\ndef _removeLiquidityTricryptoOneCoin(\n    _p: PoolData,\n    _isEmptyTokenA: bool,\n    _lpAmount: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _recipient: address,\n) -> (uint256, uint256):\n    tokenIndex: uint256 = 0\n    minAmountOut: uint256 = 0\n    tokenIndex, minAmountOut = self._getTokenIndexAndMinAmountOut(_isEmptyTokenA, _p.indexTokenA, _p.indexTokenB, _minAmountA, _minAmountB)\n    amountOut: uint256 = extcall TriCryptoPool(_p.pool).remove_liquidity_one_coin(_lpAmount, tokenIndex, minAmountOut, False, _recipient)\n    return self._getTokenAmounts(_isEmptyTokenA, amountOut)\n\n\n@internal\ndef _removeLiquidityTricrypto(\n    _p: PoolData,\n    _lpAmount: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _recipient: address,\n) -> (uint256, uint256):\n    minAmountsOut: uint256[3] = [0, 0, 0]\n    minAmountsOut[_p.indexTokenA] = _minAmountA\n    minAmountsOut[_p.indexTokenB] = _minAmountB\n\n    # NOTE: user can only specify two min amounts out, the third will be set to zero\n\n    # remove liquidity\n    amountsOut: uint256[3] = extcall TriCryptoPool(_p.pool).remove_liquidity(_lpAmount, minAmountsOut, False, _recipient, False)\n    return amountsOut[_p.indexTokenA], amountsOut[_p.indexTokenB]\n\n\n# meta pool\n\n\n@internal\ndef _removeLiquidityMetaPoolOneCoin(\n    _p: PoolData,\n    _isEmptyTokenA: bool,\n    _lpAmount: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _recipient: address,\n) -> (uint256, uint256):\n    tokenIndex: uint256 = 0\n    minAmountOut: uint256 = 0\n    tokenIndex, minAmountOut = self._getTokenIndexAndMinAmountOut(_isEmptyTokenA, _p.indexTokenA, _p.indexTokenB, _minAmountA, _minAmountB)\n    amountOut: uint256 = extcall MetaPoolCommon(_p.pool).remove_liquidity_one_coin(_lpAmount, convert(tokenIndex, int128), minAmountOut, _recipient)\n    return self._getTokenAmounts(_isEmptyTokenA, amountOut)\n\n\n@internal\ndef _removeLiquidityMetaPool(\n    _p: PoolData,\n    _lpAmount: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _recipient: address,\n) -> (uint256, uint256):\n    amountA: uint256 = 0\n    amountB: uint256 = 0\n\n    # NOTE: user can only specify two min amounts out, the third/fourth will be set to zero\n\n    if _p.numCoins == 2:\n        minAmountsOut: uint256[2] = [0, 0]\n        minAmountsOut[_p.indexTokenA] = _minAmountA\n        minAmountsOut[_p.indexTokenB] = _minAmountB\n        amountsOut: uint256[2] = extcall MetaPoolTwo(_p.pool).remove_liquidity(_lpAmount, minAmountsOut, _recipient)\n        amountA = amountsOut[_p.indexTokenA]\n        amountB = amountsOut[_p.indexTokenB]\n\n    elif _p.numCoins == 3:\n        minAmountsOut: uint256[3] = [0, 0, 0]\n        minAmountsOut[_p.indexTokenA] = _minAmountA\n        minAmountsOut[_p.indexTokenB] = _minAmountB\n        amountsOut: uint256[3] = extcall MetaPoolThree(_p.pool).remove_liquidity(_lpAmount, minAmountsOut, _recipient)\n        amountA = amountsOut[_p.indexTokenA]\n        amountB = amountsOut[_p.indexTokenB]\n\n    elif _p.numCoins == 4:\n        minAmountsOut: uint256[4] = [0, 0, 0, 0]\n        minAmountsOut[_p.indexTokenA] = _minAmountA\n        minAmountsOut[_p.indexTokenB] = _minAmountB\n        amountsOut: uint256[4] = extcall MetaPoolFour(_p.pool).remove_liquidity(_lpAmount, minAmountsOut, _recipient)\n        amountA = amountsOut[_p.indexTokenA]\n        amountB = amountsOut[_p.indexTokenB]\n\n    else:\n        raise \"meta pool: pools beyond 4-coin are not supported\"\n\n    return amountA, amountB\n\n\n# utils\n\n\n@pure\n@internal\ndef _getTokenIndexAndMinAmountOut(\n    _isEmptyTokenA: bool,\n    _indexTokenA: uint256,\n    _indexTokenB: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n) -> (uint256, uint256):\n    tokenIndex: uint256 = _indexTokenA\n    minAmountOut: uint256 = _minAmountA\n    if _isEmptyTokenA:\n        tokenIndex = _indexTokenB\n        minAmountOut = _minAmountB\n    return tokenIndex, minAmountOut\n\n\n@pure\n@internal\ndef _getTokenAmounts(_isEmptyTokenA: bool, _amountOut: uint256) -> (uint256, uint256):\n    amountA: uint256 = 0\n    amountB: uint256 = 0\n    if _isEmptyTokenA:\n        amountB = _amountOut\n    else:\n        amountA = _amountOut\n    return amountA, amountB\n\n\n\n# get usd value on liquidity actions\n\n\n@internal\ndef _getUsdValue(\n    _tokenA: address,\n    _amountA: uint256,\n    _tokenB: address,\n    _amountB: uint256,\n    _miniAddys: ws.MiniAddys,\n) -> uint256:\n\n    usdValueA: uint256 = 0\n    if _amountA != 0:\n        usdValueA = extcall Appraiser(_miniAddys.appraiser).updatePriceAndGetUsdValue(_tokenA, _amountA, _miniAddys.missionControl, _miniAddys.legoBook)\n\n    usdValueB: uint256 = 0\n    if _amountB != 0:\n        usdValueB = extcall Appraiser(_miniAddys.appraiser).updatePriceAndGetUsdValue(_tokenB, _amountB, _miniAddys.missionControl, _miniAddys.legoBook)\n\n    return usdValueA + usdValueB\n\n\n#############\n# Utilities #\n#############\n\n\n@view\n@external\ndef getLpToken(_pool: address) -> address:\n    return staticcall CurveMetaRegistry(CURVE_META_REGISTRY).get_lp_token(_pool)\n\n\n@view\n@external\ndef getPoolForLpToken(_lpToken: address) -> address:\n    return staticcall CurveMetaRegistry(CURVE_META_REGISTRY).get_pool_from_lp_token(_lpToken)\n\n\n@view\n@external\ndef getCoreRouterPool() -> address:\n    return empty(address)\n\n\n@view\n@external\ndef getDeepestLiqPool(_tokenA: address, _tokenB: address) -> BestPool:\n    metaRegistry: address = CURVE_META_REGISTRY\n\n    # all pools with tokens\n    allPools: DynArray[address, MAX_POOLS] = staticcall CurveMetaRegistry(metaRegistry).find_pools_for_coins(_tokenA, _tokenB)\n    if len(allPools) == 0:\n        return empty(BestPool)\n\n    # get deepest liquidity pool\n    bestPoolAddr: address = empty(address)\n    na1: int128 = 0\n    na2: int128 = 0\n    bestLiquidity: uint256 = 0\n    bestPoolAddr, na1, na2, bestLiquidity = self._getDeepestLiqPool(_tokenA, _tokenB, allPools, metaRegistry)\n\n    if bestPoolAddr == empty(address):\n        return empty(BestPool)\n\n    return BestPool(\n        pool=bestPoolAddr,\n        fee=staticcall CommonCurvePool(bestPoolAddr).fee() // 1000000, # normalize to have 100_00 denominator\n        liquidity=bestLiquidity,\n        numCoins=staticcall CurveMetaRegistry(metaRegistry).get_n_coins(bestPoolAddr),\n    )\n\n\n@view\n@external\ndef getBestSwapAmountOut(_tokenIn: address, _tokenOut: address, _amountIn: uint256) -> (address, uint256):\n    return self._getBestSwapAmountOut(_tokenIn, _tokenOut, _amountIn)\n\n\n@view\n@internal\ndef _getBestSwapAmountOut(_tokenIn: address, _tokenOut: address, _amountIn: uint256) -> (address, uint256):\n    bestPool: address = empty(address)\n    bestAmountOut: uint256 = 0\n\n    quotes: DynArray[Quote, MAX_QUOTES] = staticcall CurveRateProvider(CURVE_REGISTRIES.RateProvider).get_quotes(_tokenIn, _tokenOut, _amountIn)\n    for quote: Quote in quotes:\n        if quote.amount_out > bestAmountOut:\n            bestAmountOut = quote.amount_out\n            bestPool = quote.pool\n\n    return bestPool, bestAmountOut\n\n\n@view\n@external\ndef getSwapAmountOut(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n) -> uint256:\n    quotes: DynArray[Quote, MAX_QUOTES] = staticcall CurveRateProvider(CURVE_REGISTRIES.RateProvider).get_quotes(_tokenIn, _tokenOut, _amountIn)\n    bestAmountOut: uint256 = 0\n    for quote: Quote in quotes:\n        if _pool == quote.pool:\n            return quote.amount_out\n    return 0\n\n\n@view\n@external\ndef getBestSwapAmountIn(_tokenIn: address, _tokenOut: address, _amountOut: uint256) -> (address, uint256):\n    if _amountOut == 0 or _amountOut == max_value(uint256):\n        return empty(address), max_value(uint256)\n\n    expAmountIn: uint256 = self._getSwapAmountIn(empty(address), _tokenIn, _tokenOut, _amountOut)\n    if expAmountIn == 0:\n        return empty(address), 0\n\n    # NOTE: this isn't perfect, but it's good enough\n\n    bestPool: address = empty(address)\n    na: uint256 = 0\n    bestPool, na = self._getBestSwapAmountOut(_tokenIn, _tokenOut, expAmountIn)\n    return bestPool, expAmountIn\n\n\n@view\n@external\ndef getSwapAmountIn(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountOut: uint256,\n) -> uint256:\n    if _amountOut == 0 or _amountOut == max_value(uint256):\n        return max_value(uint256)\n    return self._getSwapAmountIn(_pool, _tokenIn, _tokenOut, _amountOut)\n\n\n@view\n@internal\ndef _getSwapAmountIn(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountOut: uint256,\n) -> uint256:\n    rate: uint256 = staticcall CurveRateProvider(CURVE_REGISTRIES.RateProvider).get_aggregated_rate(_tokenIn, _tokenOut)\n    if rate == 0:\n        return 0\n    decimalsTokenIn: uint256 = convert(staticcall IERC20Detailed(_tokenIn).decimals(), uint256)\n    return _amountOut * (10 ** decimalsTokenIn) // rate\n\n\n@view\n@external\ndef getAddLiqAmountsIn(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _availAmountA: uint256,\n    _availAmountB: uint256,\n) -> (uint256, uint256, uint256):\n    metaRegistry: address = CURVE_META_REGISTRY\n    p: PoolData = self._getPoolData(_pool, _tokenA, _tokenB, metaRegistry)\n\n    balances: uint256[8] = staticcall CurveMetaRegistry(metaRegistry).get_balances(_pool)\n    reserveA: uint256 = balances[p.indexTokenA]\n    reserveB: uint256 = balances[p.indexTokenB]\n\n    # insufficient liquidity\n    if reserveA == 0 or reserveB == 0:\n        return 0, 0, 0\n\n    # calculate optimal amounts\n    amountA: uint256 = 0\n    amountB: uint256 = 0\n    amountA, amountB = self._getCorrectRatioAmounts(_availAmountA, _availAmountB, reserveA, reserveB)\n\n    expectedLpAmount: uint256 = 0\n    if p.poolType == PoolType.STABLESWAP_NG:\n        expectedLpAmount = self._getAddLiqAmountsInStableNg(p, amountA, amountB)\n    elif p.poolType == PoolType.TWO_CRYPTO_NG:\n        expectedLpAmount = self._getAddLiqAmountsInCryptoNg(p, amountA, amountB)\n    elif p.poolType == PoolType.TWO_CRYPTO:\n        expectedLpAmount = self._getAddLiqAmountsInTwoCrypto(p, amountA, amountB)\n    elif p.poolType == PoolType.TRICRYPTO_NG:\n        expectedLpAmount = self._getAddLiqAmountsInTricrypto(p, amountA, amountB)\n    elif p.poolType == PoolType.METAPOOL and not staticcall CurveMetaRegistry(metaRegistry).is_meta(p.pool):\n        expectedLpAmount = self._getAddLiqAmountsInMetaPool(p, amountA, amountB)\n\n    if expectedLpAmount == 0:\n        return 0, 0, 0\n\n    return amountA, amountB, expectedLpAmount\n\n\n@view\n@external\ndef getRemoveLiqAmountsOut(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpAmount: uint256,\n) -> (uint256, uint256):\n    metaRegistry: address = CURVE_META_REGISTRY\n    p: PoolData = self._getPoolData(_pool, _tokenA, _tokenB, metaRegistry)\n\n    # NOTE: in this case, allowing 0x0 for one token, signifying desire to withdraw just one token\n\n    # normal scenario, 2-coin pool\n    if _tokenA != empty(address) and _tokenB != empty(address):\n        return self._getRemoveLiqAmountsOutTwoCoinPool(p, _tokenA, _tokenB, _lpAmount, metaRegistry)\n\n    # withdraw just one token\n    amountOut: uint256 = 0\n    tokenIndex: uint256 = p.indexTokenA\n    if _tokenA == empty(address):\n        tokenIndex = p.indexTokenB\n\n    # perform calculation\n    if p.poolType == PoolType.STABLESWAP_NG:\n        amountOut = staticcall StableNgTwo(p.pool).calc_withdraw_one_coin(_lpAmount, convert(tokenIndex, int128))\n    elif p.poolType == PoolType.TWO_CRYPTO_NG:\n        amountOut = staticcall TwoCryptoNgPool(p.pool).calc_withdraw_one_coin(_lpAmount, tokenIndex)\n    elif p.poolType == PoolType.TWO_CRYPTO:\n        amountOut = staticcall TwoCryptoPool(p.pool).calc_withdraw_one_coin(_lpAmount, tokenIndex)\n    elif p.poolType == PoolType.TRICRYPTO_NG:\n        amountOut = staticcall TriCryptoPool(p.pool).calc_withdraw_one_coin(_lpAmount, tokenIndex)\n    elif p.poolType == PoolType.METAPOOL and not staticcall CurveMetaRegistry(metaRegistry).is_meta(p.pool):\n        amountOut = staticcall MetaPoolCommon(p.pool).calc_withdraw_one_coin(_lpAmount, convert(tokenIndex, int128))\n\n    # get in correct order\n    amountA: uint256 = amountOut\n    amountB: uint256 = 0\n    if _tokenA == empty(address):\n        amountA = 0\n        amountB = amountOut\n\n    return amountA, amountB\n\n\n@view\n@external\ndef getPrice(_asset: address, _decimals: uint256) -> uint256:\n    return 0 # TODO: implement price\n\n\n@view\n@external\ndef getPriceUnsafe(_pool: address, _targetToken: address, _oracleRegistry: address = empty(address)) -> uint256:\n    return 0\n\n\n# internal utils\n\n\n@view\n@internal\ndef _getDeepestLiqPool(_tokenA: address, _tokenB: address, _allPools: DynArray[address, MAX_POOLS], _metaRegistry: address) -> (address, int128, int128, uint256):\n    bestPoolAddr: address = empty(address)\n    bestTokenAIndex: int128 = 0\n    bestTokenBIndex: int128 = 0\n    bestLiquidity: uint256 = 0\n\n    for i: uint256 in range(len(_allPools), bound=MAX_POOLS):\n        pool: address = _allPools[i]\n        if pool == empty(address):\n            continue\n\n        # balances\n        balances: uint256[8] = staticcall CurveMetaRegistry(_metaRegistry).get_balances(pool)\n        if balances[0] == 0:\n            continue\n\n        # token indexes \n        indexTokenA: int128 = 0\n        indexTokenB: int128 = 0\n        na: bool = False\n        indexTokenA, indexTokenB, na = staticcall CurveMetaRegistry(_metaRegistry).get_coin_indices(pool, _tokenA, _tokenB)\n\n        # compare liquidity\n        liquidity: uint256 = balances[indexTokenA] + balances[indexTokenB]\n        if liquidity > bestLiquidity:\n            bestPoolAddr = pool\n            bestTokenAIndex = indexTokenA\n            bestTokenBIndex = indexTokenB\n            bestLiquidity = liquidity\n\n    return bestPoolAddr, bestTokenAIndex, bestTokenBIndex, bestLiquidity\n\n\n@view\n@internal\ndef _getPoolData(_pool: address, _tokenA: address, _tokenB: address, _metaRegistry: address) -> PoolData:\n    assert staticcall CurveMetaRegistry(_metaRegistry).is_registered(_pool) # dev: invalid pool\n    coins: address[8] = staticcall CurveMetaRegistry(_metaRegistry).get_coins(_pool)\n\n    # validate tokens\n    if _tokenA != empty(address):\n        assert _tokenA in coins # dev: invalid tokens\n    if _tokenB != empty(address):\n        assert _tokenB in coins # dev: invalid tokens\n\n    # get indices\n    indexTokenA: uint256 = max_value(uint256)\n    indexTokenB: uint256 = max_value(uint256)\n    numCoins: uint256 = 0\n    for coin: address in coins:\n        if coin == empty(address):\n            break\n        if coin == _tokenA:\n            indexTokenA = numCoins\n        elif coin == _tokenB:\n            indexTokenB = numCoins\n        numCoins += 1\n\n    return PoolData(\n        pool=_pool,\n        indexTokenA=indexTokenA,\n        indexTokenB=indexTokenB,\n        poolType=self._getPoolType(_pool, _metaRegistry),\n        numCoins=numCoins,\n    )\n\n\n@view\n@internal\ndef _getPoolType(_pool: address, _metaRegistry: address) -> PoolType:\n    # check what type of pool this is based on where it's registered on Curve\n    registryHandlers: address[10] = staticcall CurveMetaRegistry(_metaRegistry).get_registry_handlers_from_pool(_pool)\n    baseRegistry: address = staticcall CurveMetaRegistry(_metaRegistry).get_base_registry(registryHandlers[0])\n\n    curveRegistries: CurveRegistries = CURVE_REGISTRIES\n    poolType: PoolType = empty(PoolType)\n    if baseRegistry == curveRegistries.StableSwapNg:\n        poolType = PoolType.STABLESWAP_NG\n    elif baseRegistry == curveRegistries.TwoCryptoNg:\n        poolType = PoolType.TWO_CRYPTO_NG\n    elif baseRegistry == curveRegistries.TricryptoNg:\n        poolType = PoolType.TRICRYPTO_NG\n    elif baseRegistry == curveRegistries.TwoCrypto:\n        poolType = PoolType.TWO_CRYPTO\n    elif baseRegistry == curveRegistries.MetaPool:\n        poolType = PoolType.METAPOOL\n    else:\n        poolType = PoolType.CRYPTO\n    return poolType\n\n\n@view\n@internal\ndef _getAddLiqAmountsInStableNg(\n    _p: PoolData,\n    _liqAmountA: uint256,\n    _liqAmountB: uint256,\n) -> uint256:\n    expLpAmount: uint256 = 0\n\n    if _p.numCoins == 2:\n        amounts: DynArray[uint256, 2] = [0, 0]\n        amounts[_p.indexTokenA] = _liqAmountA\n        amounts[_p.indexTokenB] = _liqAmountB\n        expLpAmount = staticcall StableNgTwo(_p.pool).calc_token_amount(amounts, True)\n\n    elif _p.numCoins == 3:\n        amounts: DynArray[uint256, 3] = [0, 0, 0]\n        amounts[_p.indexTokenA] = _liqAmountA\n        amounts[_p.indexTokenB] = _liqAmountB\n        expLpAmount = staticcall StableNgThree(_p.pool).calc_token_amount(amounts, True)\n\n    elif _p.numCoins == 4:\n        amounts: DynArray[uint256, 4] = [0, 0, 0, 0]\n        amounts[_p.indexTokenA] = _liqAmountA\n        amounts[_p.indexTokenB] = _liqAmountB\n        expLpAmount = staticcall StableNgFour(_p.pool).calc_token_amount(amounts, True)\n\n    return expLpAmount\n\n\n@view\n@internal\ndef _getAddLiqAmountsInCryptoNg(\n    _p: PoolData,\n    _liqAmountA: uint256,\n    _liqAmountB: uint256,\n) -> uint256:\n    amounts: uint256[2] = [0, 0]\n    amounts[_p.indexTokenA] = _liqAmountA\n    amounts[_p.indexTokenB] = _liqAmountB\n    return staticcall TwoCryptoNgPool(_p.pool).calc_token_amount(amounts, True)\n\n\n@view\n@internal\ndef _getAddLiqAmountsInTwoCrypto(\n    _p: PoolData,\n    _liqAmountA: uint256,\n    _liqAmountB: uint256,\n) -> uint256:\n    amounts: uint256[2] = [0, 0]\n    amounts[_p.indexTokenA] = _liqAmountA\n    amounts[_p.indexTokenB] = _liqAmountB\n    return staticcall TwoCryptoPool(_p.pool).calc_token_amount(amounts)\n\n\n@view\n@internal\ndef _getAddLiqAmountsInTricrypto(\n    _p: PoolData,\n    _liqAmountA: uint256,\n    _liqAmountB: uint256,\n) -> uint256:\n    amounts: uint256[3] = [0, 0, 0]\n    amounts[_p.indexTokenA] = _liqAmountA\n    amounts[_p.indexTokenB] = _liqAmountB\n    return staticcall TriCryptoPool(_p.pool).calc_token_amount(amounts, True)\n\n\n@view\n@internal\ndef _getAddLiqAmountsInMetaPool(\n    _p: PoolData,\n    _liqAmountA: uint256,\n    _liqAmountB: uint256,\n) -> uint256:\n    expLpAmount: uint256 = 0\n\n    if _p.numCoins == 2:\n        amounts: uint256[2] = [0, 0]\n        amounts[_p.indexTokenA] = _liqAmountA\n        amounts[_p.indexTokenB] = _liqAmountB\n        expLpAmount = staticcall MetaPoolTwo(_p.pool).calc_token_amount(amounts, True)\n\n    elif _p.numCoins == 3:\n        amounts: uint256[3] = [0, 0, 0]\n        amounts[_p.indexTokenA] = _liqAmountA\n        amounts[_p.indexTokenB] = _liqAmountB\n        expLpAmount = staticcall MetaPoolThree(_p.pool).calc_token_amount(amounts, True)\n\n    elif _p.numCoins == 4:\n        amounts: uint256[4] = [0, 0, 0, 0]\n        amounts[_p.indexTokenA] = _liqAmountA\n        amounts[_p.indexTokenB] = _liqAmountB\n        expLpAmount = staticcall MetaPoolFour(_p.pool).calc_token_amount(amounts, True)\n\n    return expLpAmount\n\n\n@view\n@internal\ndef _getRemoveLiqAmountsOutTwoCoinPool(\n    _p: PoolData,\n    _tokenA: address,\n    _tokenB: address,\n    _lpAmount: uint256,\n    _metaRegistry: address,\n) -> (uint256, uint256):\n\n    # only supporting 2-coin pools\n    if _p.numCoins > 2:\n        return max_value(uint256), max_value(uint256)\n\n    # get balances\n    balances: uint256[8] = staticcall CurveMetaRegistry(_metaRegistry).get_balances(_p.pool)\n    reserveA: uint256 = balances[_p.indexTokenA]\n    reserveB: uint256 = balances[_p.indexTokenB]\n\n    # insufficient liquidity\n    if reserveA == 0 or reserveB == 0:\n        return max_value(uint256), max_value(uint256)\n\n    # calculate expected amounts out\n    lpToken: address = staticcall CurveMetaRegistry(_metaRegistry).get_lp_token(_p.pool)\n    totalSupply: uint256 = staticcall IERC20(lpToken).totalSupply()\n    expectedAmountA: uint256 = _lpAmount * reserveA // totalSupply\n    expectedAmountB: uint256 = _lpAmount * reserveB // totalSupply\n    return expectedAmountA, expectedAmountB\n\n\n@view\n@internal\ndef _getCorrectRatioAmounts(\n    _availAmountA: uint256,\n    _availAmountB: uint256,\n    _reserveA: uint256,\n    _reserveB: uint256,\n) -> (uint256, uint256):\n    amountA: uint256 = _availAmountA\n    amountB: uint256 = self._quote(_availAmountA, _reserveA, _reserveB)\n    if amountB > _availAmountB:\n        maybeAmountA: uint256 = self._quote(_availAmountB, _reserveB, _reserveA)\n        if maybeAmountA <= _availAmountA:\n            amountA = maybeAmountA\n            amountB = _availAmountB\n    return amountA, amountB\n\n\n@view\n@internal\ndef _quote(_amountA: uint256, _reserveA: uint256, _reserveB: uint256) -> uint256:\n    return (_amountA * _reserveB) // _reserveA\n\n\n@view\n@external\ndef getAccessForLego(_user: address, _action: ws.ActionType) -> (address, String[64], uint256):\n    return empty(address), empty(String[64]), 0\n\n\n@view\n@external\ndef getPricePerShare(_asset: address, _decimals: uint256) -> uint256:\n    return 0\n",
            "sha256sum": "63c9bb54a4737cb681ba559863821e0c175cfb337311124957ed71e31b7518a6"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/legos/dexes/Curve.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.3+commit.bff19ea2",
        "integrity": "436a98021c2722a469931cd5abb5f85f905bb3399b44711e5ec993fb314483e1"
      },
      "args": "00000000000000000000000044cf3c4f000dfd76a35d03298049d37be688d6f90000000000000000000000005ffe7fb82894076ecb99a30d6a32e969e6e35e98",
      "file": "contracts/legos/dexes/Curve.vy"
    },
    "UniswapV2": {
      "address": "0xadB9aa252dD6163f4958443b414177248435c0EC",
      "abi": [
        {
          "name": "UniswapV2Swap",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenIn",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenOut",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amountIn",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "amountOut",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "numTokens",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UniswapV2LiquidityAdded",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenA",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenB",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amountA",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "amountB",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "lpAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UniswapV2LiquidityRemoved",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": false
            },
            {
              "name": "pool",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenA",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenB",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amountA",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "amountB",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "lpToken",
              "type": "address",
              "indexed": false
            },
            {
              "name": "lpAmountBurned",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LegoPauseModified",
          "inputs": [
            {
              "name": "isPaused",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LegoFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "balance",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddys",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "undyToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "hatchery",
                  "type": "address"
                },
                {
                  "name": "lootDistributor",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                },
                {
                  "name": "walletBackpack",
                  "type": "address"
                },
                {
                  "name": "billing",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUndyHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pause",
          "inputs": [
            {
              "name": "_shouldPause",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFundsMany",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_assets",
              "type": "address[]"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "legoId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isPaused",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasCapability",
          "inputs": [
            {
              "name": "_action",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRegistries",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isYieldLego",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isDexLego",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_tokenPath",
              "type": "address[]"
            },
            {
              "name": "_poolPath",
              "type": "address[]"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_tokenPath",
              "type": "address[]"
            },
            {
              "name": "_poolPath",
              "type": "address[]"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLpToken",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPoolForLpToken",
          "inputs": [
            {
              "name": "_lpToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getCoreRouterPool",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getDeepestLiqPool",
          "inputs": [
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "fee",
                  "type": "uint256"
                },
                {
                  "name": "liquidity",
                  "type": "uint256"
                },
                {
                  "name": "numCoins",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getBestSwapAmountOut",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountIn",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getSwapAmountOut",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountIn",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getBestSwapAmountIn",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountOut",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getSwapAmountIn",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountOut",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddLiqAmountsIn",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_availAmountA",
              "type": "uint256"
            },
            {
              "name": "_availAmountB",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRemoveLiqAmountsOut",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPrice",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_decimals",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPriceUnsafe",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_targetToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPriceUnsafe",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_targetToken",
              "type": "address"
            },
            {
              "name": "_appraiser",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositForYield",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositForYield",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawFromYield",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawFromYield",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_tokenInAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_tokenInAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmMintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmMintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_borrowAsset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_borrowAsset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_paymentAsset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_paymentAsset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAccessForLego",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_action",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "string"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPricePerShare",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_decimals",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "UNISWAP_V2_FACTORY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "UNISWAP_V2_ROUTER",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "coreRouterPool",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_undyHq",
              "type": "address"
            },
            {
              "name": "_uniswapV2Factory",
              "type": "address"
            },
            {
              "name": "_uniswapV2Router",
              "type": "address"
            },
            {
              "name": "_coreRouterPool",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "interfaces/WalletStructs.vyi": {
            "content": "# @version 0.4.3\n\nflag ActionType:\n    TRANSFER\n    EARN_DEPOSIT\n    EARN_WITHDRAW\n    EARN_REBALANCE\n    SWAP\n    MINT_REDEEM\n    CONFIRM_MINT_REDEEM\n    ADD_COLLATERAL\n    REMOVE_COLLATERAL\n    BORROW\n    REPAY_DEBT\n    REWARDS\n    ETH_TO_WETH\n    WETH_TO_ETH\n    ADD_LIQ\n    REMOVE_LIQ\n    ADD_LIQ_CONC\n    REMOVE_LIQ_CONC\n    PAY_CHEQUE\n\nstruct WalletAssetData:\n    assetBalance: uint256\n    usdValue: uint256\n    isYieldAsset: bool\n    lastPricePerShare: uint256\n\nstruct ActionData:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    billing: address\n    wallet: address\n    walletConfig: address\n    walletOwner: address\n    inEjectMode: bool\n    isFrozen: bool\n    lastTotalUsdValue: uint256\n    signer: address\n    isManager: bool\n    legoId: uint256\n    legoAddr: address\n    eth: address\n    weth: address\n\nstruct MiniAddys:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    appraiser: address",
            "sha256sum": "9a4b4f59b3a62043e51b425a665064aae419a3c0bd0514b6b29a9441ae364bb9"
          },
          "interfaces/LegoPartner.vyi": {
            "content": "# @version 0.4.3\n\nfrom interfaces import WalletStructs as ws\n\nMAX_TOKEN_PATH: constant(uint256) = 5\nMAX_RECOVER_ASSETS: constant(uint256) = 20\n\n@external\ndef addLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _tickLower: int24, _tickUpper: int24, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef addLiquidity(_pool: address, _tokenA: address, _tokenB: address, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _minLpAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (address, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef removeLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _liqToRemove: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef removeLiquidity(_pool: address, _tokenA: address, _tokenB: address, _lpToken: address, _lpAmount: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef mintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _tokenInAmount: uint256, _minAmountOut: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef swapTokens(_amountIn: uint256, _minAmountOut: uint256, _tokenPath: DynArray[address, MAX_TOKEN_PATH], _poolPath: DynArray[address, MAX_TOKEN_PATH - 1], _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256):\n    ...\n\n@external\ndef depositForYield(_asset: address, _amount: uint256, _vaultAddr: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef withdrawFromYield(_vaultToken: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef confirmMintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef borrow(_borrowAsset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef repayDebt(_paymentAsset: address, _paymentAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef claimRewards(_user: address, _rewardToken: address, _rewardAmount: uint256, _extraData: bytes32, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef removeCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef addCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@view\n@external\ndef getAccessForLego(_user: address, _action: ws.ActionType) -> (address, String[64], uint256):\n    ...\n\n@view\n@external\ndef hasCapability(_action: ws.ActionType) -> bool:\n    ...\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    ...\n\n@view\n@external\ndef isYieldLego() -> bool:\n    ...\n\n@view\n@external\ndef isDexLego() -> bool:\n    ...\n\n@view\n@external\ndef getPricePerShare(_asset: address, _decimals: uint256) -> uint256:\n    ...\n\n@view\n@external\ndef getPrice(_asset: address, _decimals: uint256) -> uint256:\n    ...\n\n\n# common\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "2513e379aa74d0a8120114a5078a4c1a0900165a1c3f24419bb811d173b56453"
          },
          "interfaces/DexLego.vyi": {
            "content": "# @version 0.4.3\n\n# used in smart contracts\n\n\n@view\n@external\ndef getLpToken(_pool: address) -> address:\n    ...\n\n\n# helper functions for server\n\n\n@view\n@external\ndef getPoolForLpToken(_lpToken: address) -> address:\n    ...\n\n\n@view\n@external\ndef getSwapAmountOut(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n) -> uint256:\n    ...\n\n\n@view\n@external\ndef getSwapAmountIn(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountOut: uint256,\n) -> uint256:\n    ...\n\n\n@view\n@external\ndef getAddLiqAmountsIn(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _availAmountA: uint256,\n    _availAmountB: uint256,\n) -> (uint256, uint256, uint256):\n    ...\n\n\n@view\n@external\ndef getRemoveLiqAmountsOut(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpAmount: uint256,\n) -> (uint256, uint256):\n    ...\n\n\n@view\n@external\ndef getPriceUnsafe(_pool: address, _targetToken: address, _appraiser: address = empty(address)) -> uint256:\n    ...\n\n\n@view\n@external\ndef getBestSwapAmountOut(_tokenIn: address, _tokenOut: address, _amountIn: uint256) -> (address, uint256):\n    ...\n\n\n@view\n@external\ndef getBestSwapAmountIn(_tokenIn: address, _tokenOut: address, _amountOut: uint256) -> (address, uint256):\n    ...\n\n\n@view\n@external\ndef getCoreRouterPool() -> address:\n    ...\n",
            "sha256sum": "44b192d0249c04d635acb9c758c41ebba7014d9287315bc1f7a7cb2646e69631"
          },
          "contracts/modules/Addys.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\ninterface UndyHq:\n    def isValidAddr(_addr: address) -> bool: view\n    def getAddr(_regId: uint256) -> address: view\n    def undyToken() -> address: view\n\ninterface Switchboard:\n    def isSwitchboardAddr(_addr: address) -> bool: view\n\ninterface LegoBook:\n    def isLegoAddr(_addr: address) -> bool: view\n\nstruct Addys:\n    hq: address\n    undyToken: address\n    ledger: address\n    missionControl: address\n    legoBook: address\n    switchboard: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    walletBackpack: address\n    billing: address\n\n# hq\nUNDY_HQ_FOR_ADDYS: immutable(address)\n\n# core addys\nLEDGER_ID: constant(uint256) = 1\nMISSION_CONTROL_ID: constant(uint256) = 2\nLEGO_BOOK_ID: constant(uint256) = 3\nSWITCHBOARD_ID: constant(uint256) = 4\nHATCHERY_ID: constant(uint256) = 5\nLOOT_DISTRIBUTOR_ID: constant(uint256) = 6\nAPPRAISER_ID: constant(uint256) = 7\nWALLET_BACKPACK_ID: constant(uint256) = 8\nBILLING_ID: constant(uint256) = 9\n\n\n@deploy\ndef __init__(_undyHq: address):\n    assert _undyHq != empty(address) # dev: invalid undy hq\n    UNDY_HQ_FOR_ADDYS = _undyHq\n\n\n########\n# Core #\n########\n\n\n@view\n@external\ndef getAddys() -> Addys:\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _getAddys(_addys: Addys = empty(Addys)) -> Addys:\n    if _addys.hq != empty(address):\n        return _addys\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _generateAddys() -> Addys:\n    hq: address = UNDY_HQ_FOR_ADDYS\n    return Addys(\n        hq = hq,\n        undyToken = staticcall UndyHq(hq).undyToken(),\n        ledger = staticcall UndyHq(hq).getAddr(LEDGER_ID),\n        missionControl = staticcall UndyHq(hq).getAddr(MISSION_CONTROL_ID),\n        legoBook = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID),\n        switchboard = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID),\n        hatchery = staticcall UndyHq(hq).getAddr(HATCHERY_ID),\n        lootDistributor = staticcall UndyHq(hq).getAddr(LOOT_DISTRIBUTOR_ID),\n        appraiser = staticcall UndyHq(hq).getAddr(APPRAISER_ID),\n        walletBackpack = staticcall UndyHq(hq).getAddr(WALLET_BACKPACK_ID),\n        billing = staticcall UndyHq(hq).getAddr(BILLING_ID),\n    )\n\n\n##########\n# Tokens #\n##########\n\n\n@view\n@internal\ndef _getUndyToken() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).undyToken()\n\n\n###########\n# Helpers #\n###########\n\n\n# undy hq\n\n\n@view\n@external\ndef getUndyHq() -> address:\n    return self._getUndyHq()\n\n\n@view\n@internal\ndef _getUndyHq() -> address:\n    return UNDY_HQ_FOR_ADDYS\n\n\n# utils\n\n\n@view\n@internal\ndef _isValidUndyAddr(_addr: address, _hq: address = empty(address)) -> bool:\n    hq: address = _hq\n    if _hq == empty(address):\n        hq = UNDY_HQ_FOR_ADDYS\n    \n    # core departments\n    if staticcall UndyHq(hq).isValidAddr(_addr):\n        return True\n\n    # lego book\n    legoBook: address = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID)\n    if legoBook != empty(address) and staticcall LegoBook(legoBook).isLegoAddr(_addr):\n        return True\n\n    # switchboard config\n    switchboard: address = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID)\n    if switchboard != empty(address) and staticcall Switchboard(switchboard).isSwitchboardAddr(_addr):\n        return True\n\n    return False\n\n\n@view\n@internal\ndef _isSwitchboardAddr(_addr: address) -> bool:\n    switchboard: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n    if switchboard == empty(address):\n        return False\n    return staticcall Switchboard(switchboard).isSwitchboardAddr(_addr)\n\n\n@view\n@internal\ndef _isLegoBookAddr(_addr: address) -> bool:\n    legoBook: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n    if legoBook == empty(address):\n        return False\n    return staticcall LegoBook(legoBook).isLegoAddr(_addr)\n\n\n###############\n# Departments #\n###############\n\n\n# ledger\n\n\n@view\n@internal\ndef _getLedgerId() -> uint256:\n    return LEDGER_ID\n\n\n@view\n@internal\ndef _getLedgerAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEDGER_ID)\n\n\n# mission control\n\n\n@view\n@internal\ndef _getMissionControlId() -> uint256:\n    return MISSION_CONTROL_ID\n\n\n@view\n@internal\ndef _getMissionControlAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(MISSION_CONTROL_ID)\n\n\n# lego book\n\n\n@view\n@internal\ndef _getLegoBookId() -> uint256:\n    return LEGO_BOOK_ID\n\n\n@view\n@internal\ndef _getLegoBookAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n\n\n# switchboard\n\n\n@view\n@internal\ndef _getSwitchboardId() -> uint256:\n    return SWITCHBOARD_ID\n\n\n@view\n@internal\ndef _getSwitchboardAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n\n\n# hatchery\n\n\n@view\n@internal\ndef _getHatcheryId() -> uint256:\n    return HATCHERY_ID\n\n\n@view\n@internal\ndef _getHatcheryAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(HATCHERY_ID)\n\n\n# loot distributor\n\n\n@view\n@internal\ndef _getLootDistributorId() -> uint256:\n    return LOOT_DISTRIBUTOR_ID\n\n\n@view\n@internal\ndef _getLootDistributorAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LOOT_DISTRIBUTOR_ID)\n\n\n# appraiser\n\n\n@view\n@internal\ndef _getAppraiserId() -> uint256:\n    return APPRAISER_ID\n\n\n@view\n@internal\ndef _getAppraiserAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(APPRAISER_ID)\n\n\n# wallet backpack\n\n\n@view\n@internal\ndef _getWalletBackpackId() -> uint256:\n    return WALLET_BACKPACK_ID\n\n\n@view\n@internal\ndef _getWalletBackpackAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(WALLET_BACKPACK_ID)\n\n\n# billing\n\n\n@view\n@internal\ndef _getBillingId() -> uint256:\n    return BILLING_ID\n\n\n@view\n@internal\ndef _getBillingAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(BILLING_ID)",
            "sha256sum": "78b58f0b2acb2eaafa4d21adf9135a1cd0e1d53897f7a1fa70a83a04a7738ad3"
          },
          "contracts/modules/DexLegoData.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nuses: addys\n\nimport contracts.modules.Addys as addys\n\nfrom interfaces import WalletStructs as ws\nfrom ethereum.ercs import IERC20\n\nevent LegoPauseModified:\n    isPaused: bool\n\nevent LegoFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    balance: uint256\n\n# config\nlegoId: public(uint256)\nisPaused: public(bool)\n\nMAX_RECOVER_ASSETS: constant(uint256) = 20\n\n\n@deploy\ndef __init__(_shouldPause: bool):\n    self.isPaused = _shouldPause\n\n\n###########\n# General #\n###########\n\n\n# fill mini addys\n\n\n@view\n@internal\ndef _getMiniAddys(_miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> ws.MiniAddys:\n    if _miniAddys.ledger != empty(address):\n        return _miniAddys\n    return ws.MiniAddys(\n        ledger = addys._getLedgerAddr(),\n        missionControl = addys._getMissionControlAddr(),\n        legoBook = addys._getLegoBookAddr(),\n        appraiser = addys._getAppraiserAddr(),\n    )\n\n\n# activate\n\n\n@external\ndef pause(_shouldPause: bool):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert _shouldPause != self.isPaused # dev: no change\n    self.isPaused = _shouldPause\n    log LegoPauseModified(isPaused=_shouldPause)\n\n\n# recover funds\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    self._recoverFunds(_recipient, _asset)\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, MAX_RECOVER_ASSETS]):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    for a: address in _assets:\n        self._recoverFunds(_recipient, a)\n\n\n@internal\ndef _recoverFunds(_recipient: address, _asset: address):\n    assert empty(address) not in [_recipient, _asset] # dev: invalid recipient or asset\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    assert balance != 0 # dev: nothing to recover\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log LegoFundsRecovered(asset=_asset, recipient=_recipient, balance=balance)",
            "sha256sum": "75b15af2475ab409d4b5fd057509d14c20564ebd7fcb0850e3b61397d8e3af48"
          },
          "contracts/legos/dexes/UniswapV2.vy": {
            "content": "#     _____  _____  __  __    ____   _____  _____  _____ \n#    |  _  \\/   __\\/  \\/  \\  /  _/  /   __\\/   __\\/  _  \\\n#    |  |  ||   __|>-    -<  |  |---|   __||  |_ ||  |  |\n#    |_____/\\_____/\\__/\\__/  \\_____/\\_____/\\_____/\\_____/\n#                                                                       \n#     \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n#     \u2551  ** Uniswap V2 Lego **           \u2551\n#     \u2551  Integration with Uniswap V2.    \u2551\n#     \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n#\n#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nimplements: Lego\nimplements: DexLego\n\nexports: addys.__interface__\nexports: dld.__interface__\n\ninitializes: addys\ninitializes: dld[addys := addys]\n\nfrom interfaces import LegoPartner as Lego\nfrom interfaces import DexLego as DexLego\nfrom interfaces import WalletStructs as ws\n\nimport contracts.modules.Addys as addys\nimport contracts.modules.DexLegoData as dld\n\nfrom ethereum.ercs import IERC20\nfrom ethereum.ercs import IERC20Detailed\n\ninterface IUniswapV2Pair:\n    def swap(_amount0Out: uint256, _amount1Out: uint256, _recipient: address, _data: Bytes[256]): nonpayable\n    def getReserves() -> (uint112, uint112, uint32): view\n    def token0() -> address: view\n    def token1() -> address: view\n\ninterface Appraiser:\n    def getNormalAssetPrice(_asset: address, _missionControl: address = empty(address), _legoBook: address = empty(address), _ledger: address = empty(address)) -> uint256: view\n    def updatePriceAndGetUsdValue(_asset: address, _amount: uint256, _missionControl: address = empty(address), _legoBook: address = empty(address)) -> uint256: nonpayable\n\ninterface UniV2Router:\n    def addLiquidity(_tokenA: address, _tokenB: address, _amountADesired: uint256, _amountBDesired: uint256, _amountAMin: uint256, _amountBMin: uint256, _recipient: address, _deadline: uint256) -> (uint256, uint256, uint256): nonpayable\n    def removeLiquidity(_tokenA: address, _tokenB: address, _lpAmount: uint256, _amountAMin: uint256, _amountBMin: uint256, _recipient: address, _deadline: uint256) -> (uint256, uint256): nonpayable\n\ninterface UniV2Factory:\n    def getPair(_tokenA: address, _tokenB: address) -> address: view\n\nstruct BestPool:\n    pool: address\n    fee: uint256\n    liquidity: uint256\n    numCoins: uint256\n\nstruct Route:\n    from_: address\n    to: address \n    stable: bool\n    factory: address\n\nevent UniswapV2Swap:\n    sender: indexed(address)\n    tokenIn: indexed(address)\n    tokenOut: indexed(address)\n    amountIn: uint256\n    amountOut: uint256\n    usdValue: uint256\n    numTokens: uint256\n    recipient: address\n\nevent UniswapV2LiquidityAdded:\n    sender: indexed(address)\n    tokenA: indexed(address)\n    tokenB: indexed(address)\n    amountA: uint256\n    amountB: uint256\n    lpAmountReceived: uint256\n    usdValue: uint256\n    recipient: address\n\nevent UniswapV2LiquidityRemoved:\n    sender: address\n    pool: indexed(address)\n    tokenA: indexed(address)\n    tokenB: indexed(address)\n    amountA: uint256\n    amountB: uint256\n    lpToken: address\n    lpAmountBurned: uint256\n    usdValue: uint256\n    recipient: address\n\n# uniswap v2\nUNISWAP_V2_FACTORY: public(immutable(address))\nUNISWAP_V2_ROUTER: public(immutable(address))\ncoreRouterPool: public(address)\n\nEIGHTEEN_DECIMALS: constant(uint256) = 10 ** 18\nMAX_TOKEN_PATH: constant(uint256) = 5\n\n\n@deploy\ndef __init__(\n    _undyHq: address,\n    _uniswapV2Factory: address,\n    _uniswapV2Router: address,\n    _coreRouterPool: address,\n):\n    addys.__init__(_undyHq)\n    dld.__init__(False)\n\n    assert empty(address) not in [_uniswapV2Factory, _uniswapV2Router, _coreRouterPool] # dev: invalid addrs\n    UNISWAP_V2_FACTORY = _uniswapV2Factory\n    UNISWAP_V2_ROUTER = _uniswapV2Router\n    self.coreRouterPool = _coreRouterPool\n\n\n@view\n@external\ndef hasCapability(_action: ws.ActionType) -> bool:\n    return _action in (\n        ws.ActionType.SWAP |\n        ws.ActionType.ADD_LIQ | \n        ws.ActionType.REMOVE_LIQ\n    )\n\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    return [UNISWAP_V2_FACTORY, UNISWAP_V2_ROUTER]\n\n\n@view\n@external\ndef isYieldLego() -> bool:\n    return False\n\n\n@view\n@external\ndef isDexLego() -> bool:\n    return True\n\n\n#########\n# Swaps #\n#########\n\n\n@external\ndef swapTokens(\n    _amountIn: uint256,\n    _minAmountOut: uint256,\n    _tokenPath: DynArray[address, MAX_TOKEN_PATH],\n    _poolPath: DynArray[address, MAX_TOKEN_PATH - 1],\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256):\n    assert not dld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = dld._getMiniAddys(_miniAddys)\n\n    # validate inputs\n    numTokens: uint256 = len(_tokenPath)\n    numPools: uint256 = len(_poolPath)\n    assert numTokens >= 2 # dev: invalid path\n    assert numPools == numTokens - 1 # dev: invalid path\n\n    # get first token and last token\n    tokenIn: address = _tokenPath[0]\n    tokenOut: address = _tokenPath[numTokens - 1]\n\n    # pre balances\n    preLegoBalance: uint256 = staticcall IERC20(tokenIn).balanceOf(self)\n\n    # transfer deposit asset to this contract\n    amountIn: uint256 = min(_amountIn, staticcall IERC20(tokenIn).balanceOf(msg.sender))\n    assert amountIn != 0 # dev: nothing to transfer\n    assert extcall IERC20(tokenIn).transferFrom(msg.sender, self, amountIn, default_return_value=True) # dev: transfer failed\n\n    # transfer initial amount to first pool\n    assert extcall IERC20(tokenIn).transfer(_poolPath[0], amountIn, default_return_value=True) # dev: transfer failed\n\n    # iterate through swap routes\n    tempAmountIn: uint256 = amountIn\n    uniswapV2Factory: address = UNISWAP_V2_FACTORY\n    for i: uint256 in range(numTokens - 1, bound=MAX_TOKEN_PATH):\n        tempTokenIn: address = _tokenPath[i]\n        tempTokenOut: address = _tokenPath[i + 1]\n        tempPool: address = _poolPath[i]\n\n        # transfer to next pool (or to recipient if last swap)\n        recipient: address = _recipient\n        if i < numTokens - 2:\n            recipient = _poolPath[i + 1]\n\n        # swap\n        tempAmountIn = self._swapTokensInPool(tempPool, tempTokenIn, tempTokenOut, tempAmountIn, recipient, uniswapV2Factory)\n\n    # final amount\n    amountOut: uint256 = tempAmountIn\n    assert amountOut >= _minAmountOut # dev: min amount out not met\n\n    # refund if full swap didn't get through\n    currentLegoBalance: uint256 = staticcall IERC20(tokenIn).balanceOf(self)\n    refundAssetAmount: uint256 = 0\n    if currentLegoBalance > preLegoBalance:\n        refundAssetAmount = currentLegoBalance - preLegoBalance\n        assert extcall IERC20(tokenIn).transfer(msg.sender, refundAssetAmount, default_return_value=True) # dev: transfer failed\n        amountIn -= refundAssetAmount\n\n    # get usd values\n    usdValue: uint256 = extcall Appraiser(miniAddys.appraiser).updatePriceAndGetUsdValue(tokenIn, amountIn, miniAddys.missionControl, miniAddys.legoBook)\n    if usdValue == 0:\n        usdValue = extcall Appraiser(miniAddys.appraiser).updatePriceAndGetUsdValue(tokenOut, amountOut, miniAddys.missionControl, miniAddys.legoBook)\n\n    log UniswapV2Swap(\n        sender = msg.sender,\n        tokenIn = tokenIn,\n        tokenOut = tokenOut,\n        amountIn = amountIn,\n        amountOut = amountOut,\n        usdValue = usdValue,\n        numTokens = numTokens,\n        recipient = _recipient,\n    )\n    return amountIn, amountOut, usdValue\n\n\n# swap in pool\n\n\n@internal\ndef _swapTokensInPool(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n    _recipient: address,\n    _uniswapV2Factory: address,\n) -> uint256:\n    tokens: address[2] = [staticcall IUniswapV2Pair(_pool).token0(), staticcall IUniswapV2Pair(_pool).token1()]\n    assert _tokenIn in tokens # dev: invalid tokenIn\n    assert _tokenOut in tokens # dev: invalid tokenOut\n    assert _tokenIn != _tokenOut # dev: invalid tokens\n\n    # verify actual uniswap v2 pool\n    assert staticcall UniV2Factory(_uniswapV2Factory).getPair(_tokenIn, _tokenOut) == _pool # dev: invalid pool\n\n    zeroForOne: bool = _tokenIn == tokens[0]\n    amountOut: uint256 = self._getAmountOut(_pool, zeroForOne, _amountIn)\n    assert amountOut != 0 # dev: no tokens swapped\n\n    # put in correct order\n    amount0Out: uint256 = amountOut\n    amount1Out: uint256 = 0\n    if zeroForOne:\n        amount0Out = 0\n        amount1Out = amountOut\n\n    # perform swap\n    extcall IUniswapV2Pair(_pool).swap(amount0Out, amount1Out, _recipient, b\"\")\n    return amountOut\n\n\n#############\n# Liquidity #\n#############\n\n\n# add liquidity\n\n\n@external\ndef addLiquidity(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _amountA: uint256,\n    _amountB: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _minLpAmount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (address, uint256, uint256, uint256, uint256):\n    assert not dld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = dld._getMiniAddys(_miniAddys)\n\n    # validate tokens\n    tokens: address[2] = [staticcall IUniswapV2Pair(_pool).token0(), staticcall IUniswapV2Pair(_pool).token1()]\n    assert _tokenA in tokens # dev: invalid tokenA\n    assert _tokenB in tokens # dev: invalid tokenB\n    assert _tokenA != _tokenB # dev: invalid tokens\n\n    # pre balances\n    preLegoBalanceA: uint256 = staticcall IERC20(_tokenA).balanceOf(self)\n    preLegoBalanceB: uint256 = staticcall IERC20(_tokenB).balanceOf(self)\n\n    # token a\n    liqAmountA: uint256 = min(_amountA, staticcall IERC20(_tokenA).balanceOf(msg.sender))\n    assert liqAmountA != 0 # dev: nothing to transfer\n    assert extcall IERC20(_tokenA).transferFrom(msg.sender, self, liqAmountA, default_return_value=True) # dev: transfer failed\n\n    # token b\n    liqAmountB: uint256 = min(_amountB, staticcall IERC20(_tokenB).balanceOf(msg.sender))\n    assert liqAmountB != 0 # dev: nothing to transfer\n    assert extcall IERC20(_tokenB).transferFrom(msg.sender, self, liqAmountB, default_return_value=True) # dev: transfer failed\n\n    # approvals\n    router: address = UNISWAP_V2_ROUTER\n    assert extcall IERC20(_tokenA).approve(router, liqAmountA, default_return_value=True) # dev: approval failed\n    assert extcall IERC20(_tokenB).approve(router, liqAmountB, default_return_value=True) # dev: approval failed\n\n    # add liquidity\n    lpAmountReceived: uint256 = 0\n    liqAmountA, liqAmountB, lpAmountReceived = extcall UniV2Router(router).addLiquidity(\n        _tokenA,\n        _tokenB,\n        liqAmountA,\n        liqAmountB,\n        _minAmountA,\n        _minAmountB,\n        _recipient,\n        block.timestamp,\n    )\n    assert lpAmountReceived != 0 # dev: no liquidity added\n\n    # reset approvals\n    assert extcall IERC20(_tokenA).approve(router, 0, default_return_value=True) # dev: approval failed\n    assert extcall IERC20(_tokenB).approve(router, 0, default_return_value=True) # dev: approval failed\n\n    # refund if full liquidity was not added\n    currentLegoBalanceA: uint256 = staticcall IERC20(_tokenA).balanceOf(self)\n    refundAssetAmountA: uint256 = 0\n    if currentLegoBalanceA > preLegoBalanceA:\n        refundAssetAmountA = currentLegoBalanceA - preLegoBalanceA\n        assert extcall IERC20(_tokenA).transfer(msg.sender, refundAssetAmountA, default_return_value=True) # dev: transfer failed\n\n    currentLegoBalanceB: uint256 = staticcall IERC20(_tokenB).balanceOf(self)\n    refundAssetAmountB: uint256 = 0\n    if currentLegoBalanceB > preLegoBalanceB:\n        refundAssetAmountB = currentLegoBalanceB - preLegoBalanceB\n        assert extcall IERC20(_tokenB).transfer(msg.sender, refundAssetAmountB, default_return_value=True) # dev: transfer failed\n\n    usdValue: uint256 = self._getUsdValue(_tokenA, liqAmountA, _tokenB, liqAmountB, miniAddys)\n    log UniswapV2LiquidityAdded(\n        sender = msg.sender,\n        tokenA = _tokenA,\n        tokenB = _tokenB,\n        amountA = liqAmountA,\n        amountB = liqAmountB,\n        lpAmountReceived = lpAmountReceived,\n        usdValue = usdValue,\n        recipient = _recipient,\n    )\n    return _pool, lpAmountReceived, liqAmountA, liqAmountB, usdValue\n\n\n# remove liquidity\n\n\n@external\ndef removeLiquidity(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpToken: address,\n    _lpAmount: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, uint256):\n    assert not dld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = dld._getMiniAddys(_miniAddys)\n\n    # validate tokens\n    tokens: address[2] = [staticcall IUniswapV2Pair(_pool).token0(), staticcall IUniswapV2Pair(_pool).token1()]\n    assert _tokenA in tokens # dev: invalid tokenA\n    assert _tokenB in tokens # dev: invalid tokenB\n    assert _tokenA != _tokenB # dev: invalid tokens\n\n    # pre balance\n    preLegoBalance: uint256 = staticcall IERC20(_lpToken).balanceOf(self)\n\n    # lp token\n    lpAmount: uint256 = min(_lpAmount, staticcall IERC20(_lpToken).balanceOf(msg.sender))\n    assert lpAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_lpToken).transferFrom(msg.sender, self, lpAmount, default_return_value=True) # dev: transfer failed\n\n    # approvals\n    router: address = UNISWAP_V2_ROUTER\n    assert extcall IERC20(_lpToken).approve(router, lpAmount, default_return_value=True) # dev: approval failed\n\n    # remove liquidity\n    amountA: uint256 = 0\n    amountB: uint256 = 0\n    amountA, amountB = extcall UniV2Router(router).removeLiquidity(\n        _tokenA,\n        _tokenB,\n        lpAmount,\n        _minAmountA,\n        _minAmountB,\n        _recipient,\n        block.timestamp,\n    )\n    assert amountA != 0 # dev: no amountA removed\n    assert amountB != 0 # dev: no amountB removed\n\n    # reset approvals\n    assert extcall IERC20(_lpToken).approve(router, 0, default_return_value=True) # dev: approval failed\n\n    # refund if full liquidity was not removed\n    currentLegoBalance: uint256 = staticcall IERC20(_lpToken).balanceOf(self)\n    refundedLpAmount: uint256 = 0\n    if currentLegoBalance > preLegoBalance:\n        refundedLpAmount = currentLegoBalance - preLegoBalance\n        assert extcall IERC20(_lpToken).transfer(msg.sender, refundedLpAmount, default_return_value=True) # dev: transfer failed\n        lpAmount -= refundedLpAmount\n\n    usdValue: uint256 = self._getUsdValue(_tokenA, amountA, _tokenB, amountB, miniAddys)\n    log UniswapV2LiquidityRemoved(\n        sender = msg.sender,\n        pool = _pool,\n        tokenA = _tokenA,\n        tokenB = _tokenB,\n        amountA = amountA,\n        amountB = amountB,\n        lpToken = _lpToken,\n        lpAmountBurned = lpAmount,\n        usdValue = usdValue,\n        recipient = _recipient,\n    )\n    return amountA, amountB, lpAmount, usdValue\n\n\n# get usd value on liquidity actions\n\n\n@internal\ndef _getUsdValue(\n    _tokenA: address,\n    _amountA: uint256,\n    _tokenB: address,\n    _amountB: uint256,\n    _miniAddys: ws.MiniAddys,\n) -> uint256:\n\n    usdValueA: uint256 = 0\n    if _amountA != 0:\n        usdValueA = extcall Appraiser(_miniAddys.appraiser).updatePriceAndGetUsdValue(_tokenA, _amountA, _miniAddys.missionControl, _miniAddys.legoBook)\n\n    usdValueB: uint256 = 0\n    if _amountB != 0:\n        usdValueB = extcall Appraiser(_miniAddys.appraiser).updatePriceAndGetUsdValue(_tokenB, _amountB, _miniAddys.missionControl, _miniAddys.legoBook)\n\n    return usdValueA + usdValueB\n\n\n#############\n# Utilities #\n#############\n\n\n@view\n@external\ndef getLpToken(_pool: address) -> address:\n    # in uniswap v2, the lp token is the pool address\n    return _pool\n\n\n@view\n@external\ndef getPoolForLpToken(_lpToken: address) -> address:\n    # in uniswap v2, the pool is the lp token address\n    return _lpToken\n\n\n@view\n@external\ndef getCoreRouterPool() -> address:\n    return self.coreRouterPool\n\n\n@view\n@external\ndef getDeepestLiqPool(_tokenA: address, _tokenB: address) -> BestPool:\n    pool: address = staticcall UniV2Factory(UNISWAP_V2_FACTORY).getPair(_tokenA, _tokenB)\n    if pool == empty(address):\n        return empty(BestPool)\n\n    # get reserves\n    reserve0: uint112 = 0\n    reserve1: uint112 = 0\n    na: uint32 = 0\n    reserve0, reserve1, na = staticcall IUniswapV2Pair(pool).getReserves()\n\n    return BestPool(\n        pool=pool,\n        fee=30, # 0.3%, denominator is 100_00\n        liquidity=convert(reserve0 + reserve1, uint256),\n        numCoins=2,\n    )\n\n\n@view\n@external\ndef getBestSwapAmountOut(_tokenIn: address, _tokenOut: address, _amountIn: uint256) -> (address, uint256):\n    pool: address = staticcall UniV2Factory(UNISWAP_V2_FACTORY).getPair(_tokenIn, _tokenOut)\n    if pool == empty(address):\n        return empty(address), 0\n    token0: address = staticcall IUniswapV2Pair(pool).token0()\n    return pool, self._getAmountOut(pool, _tokenIn == token0, _amountIn)\n\n\n@view\n@external\ndef getSwapAmountOut(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n) -> uint256:\n    token0: address = staticcall IUniswapV2Pair(_pool).token0()\n    return self._getAmountOut(_pool, _tokenIn == token0, _amountIn)\n\n\n@view\n@external\ndef getBestSwapAmountIn(_tokenIn: address, _tokenOut: address, _amountOut: uint256) -> (address, uint256):\n    pool: address = staticcall UniV2Factory(UNISWAP_V2_FACTORY).getPair(_tokenIn, _tokenOut)\n    if pool == empty(address):\n        return empty(address), 0\n    token0: address = staticcall IUniswapV2Pair(pool).token0()\n    return pool, self._getAmountIn(pool, _tokenIn == token0, _amountOut)\n\n\n@view\n@external\ndef getSwapAmountIn(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountOut: uint256,\n) -> uint256:\n    token0: address = staticcall IUniswapV2Pair(_pool).token0()\n    return self._getAmountIn(_pool, _tokenIn == token0, _amountOut)\n\n\n@view\n@external\ndef getAddLiqAmountsIn(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _availAmountA: uint256,\n    _availAmountB: uint256,\n) -> (uint256, uint256, uint256):\n    token0: address = staticcall IUniswapV2Pair(_pool).token0()\n\n    reserveA: uint256 = 0\n    reserveB: uint256 = 0\n    reserveA, reserveB = self._getReserves(_pool, _tokenA == token0)\n\n    # insufficient liquidity\n    if reserveA == 0 or reserveB == 0:\n        return 0, 0, 0\n\n    # calculate optimal amounts\n    amountA: uint256 = _availAmountA\n    amountB: uint256 = self._quote(_availAmountA, reserveA, reserveB)\n    if amountB > _availAmountB:\n        maybeAmountA: uint256 = self._quote(_availAmountB, reserveB, reserveA)\n        if maybeAmountA <= _availAmountA:\n            amountA = maybeAmountA\n            amountB = _availAmountB\n    return amountA, amountB, 0\n\n\n@view\n@external\ndef getRemoveLiqAmountsOut(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpAmount: uint256,\n) -> (uint256, uint256):\n    token0: address = staticcall IUniswapV2Pair(_pool).token0()\n\n    reserveA: uint256 = 0\n    reserveB: uint256 = 0\n    reserveA, reserveB = self._getReserves(_pool, _tokenA == token0)\n\n    # insufficient liquidity\n    if reserveA == 0 or reserveB == 0:\n        return max_value(uint256), max_value(uint256)\n\n    # calculate expected amounts out\n    totalSupply: uint256 = staticcall IERC20(_pool).totalSupply()\n    expectedAmountA: uint256 = _lpAmount * reserveA // totalSupply\n    expectedAmountB: uint256 = _lpAmount * reserveB // totalSupply\n    return expectedAmountA, expectedAmountB\n\n\n@view\n@external\ndef getPrice(_asset: address, _decimals: uint256) -> uint256:\n    return 0 # TODO: implement price\n\n\n@view\n@external\ndef getPriceUnsafe(_pool: address, _targetToken: address, _appraiser: address = empty(address)) -> uint256:\n    token0: address = staticcall IUniswapV2Pair(_pool).token0()\n    token1: address = staticcall IUniswapV2Pair(_pool).token1()\n\n    # appraiser\n    appraiser: address = _appraiser\n    if _appraiser == empty(address):\n        appraiser = addys._getAppraiserAddr()\n\n    # alt price\n    altPrice: uint256 = 0\n    if _targetToken == token0:\n        altPrice = staticcall Appraiser(appraiser).getNormalAssetPrice(token1)\n    else:\n        altPrice = staticcall Appraiser(appraiser).getNormalAssetPrice(token0)\n\n    # return early if no alt price\n    if altPrice == 0:\n        return 0\n\n    # reserves\n    reserve0: uint112 = 0\n    reserve1: uint112 = 0\n    na: uint32 = 0\n    reserve0, reserve1, na = staticcall IUniswapV2Pair(_pool).getReserves()\n\n    # avoid division by zero\n    if reserve0 == 0 or reserve1 == 0:\n        return 0  \n\n    # price of token0 in token1\n    priceZeroToOne: uint256 = convert(reserve1, uint256) * EIGHTEEN_DECIMALS // convert(reserve0, uint256)\n\n    # adjust for decimals: price should be in 18 decimals\n    decimals0: uint256 = convert(staticcall IERC20Detailed(token0).decimals(), uint256)\n    decimals1: uint256 = convert(staticcall IERC20Detailed(token1).decimals(), uint256)\n    if decimals0 > decimals1:\n        scaleFactor: uint256 = 10 ** (decimals0 - decimals1)\n        priceZeroToOne = priceZeroToOne * scaleFactor\n    elif decimals1 > decimals0:\n        scaleFactor: uint256 = 10 ** (decimals1 - decimals0)\n        priceZeroToOne = priceZeroToOne // scaleFactor\n\n    # if _targetToken is token1, make price inverse\n    priceToOther: uint256 = priceZeroToOne\n    if _targetToken == token1:\n        priceToOther = EIGHTEEN_DECIMALS * EIGHTEEN_DECIMALS // priceZeroToOne\n\n    return altPrice * priceToOther // EIGHTEEN_DECIMALS\n\n\n# internal utils\n\n\n@view\n@internal\ndef _quote(_amountA: uint256, _reserveA: uint256, _reserveB: uint256) -> uint256:\n    return (_amountA * _reserveB) // _reserveA\n\n\n@view\n@internal\ndef _getReserves(_pool: address, _isTokenAZeroIndex: bool) -> (uint256, uint256):\n    reserve0: uint112 = 0\n    reserve1: uint112 = 0\n    na: uint32 = 0\n    reserve0, reserve1, na = staticcall IUniswapV2Pair(_pool).getReserves()\n\n    # determine which token is which\n    reserveA: uint256 = convert(reserve0, uint256)\n    reserveB: uint256 = convert(reserve1, uint256)\n    if not _isTokenAZeroIndex:\n        reserveA = convert(reserve1, uint256)\n        reserveB = convert(reserve0, uint256)\n\n    return reserveA, reserveB\n\n\n@view\n@internal\ndef _getAmountOut(\n    _pool: address,\n    _zeroForOne: bool,\n    _amountIn: uint256,\n) -> uint256:\n    if _amountIn == 0:\n        return 0\n\n    # get reserves\n    reserveIn: uint256 = 0\n    reserveOut: uint256 = 0\n    reserveIn, reserveOut = self._getReserves(_pool, _zeroForOne)\n    if reserveIn == 0 or reserveOut == 0:\n        return 0\n\n    # calculate amount out\n    amountInWithFee: uint256 = _amountIn * 997 # 1000 - 3 (0.3% fee)\n    numerator: uint256 = amountInWithFee * reserveOut\n    denominator: uint256 = (reserveIn * 1000) + amountInWithFee\n    return numerator // denominator\n\n\n@view\n@internal\ndef _getAmountIn(_pool: address, _zeroForOne: bool, _amountOut: uint256) -> uint256:\n    if _amountOut == 0 or _amountOut == max_value(uint256):\n        return max_value(uint256)\n\n    reserveIn: uint256 = 0\n    reserveOut: uint256 = 0\n    reserveIn, reserveOut = self._getReserves(_pool, _zeroForOne)\n    if reserveIn == 0 or reserveOut == 0:\n        return max_value(uint256)\n\n    if _amountOut > reserveOut:\n        return max_value(uint256)\n\n    numerator: uint256 = reserveIn * _amountOut * 1000\n    denominator: uint256 = (reserveOut - _amountOut) * 997\n    return (numerator // denominator) + 1\n\n\n#########\n# Other #\n#########\n\n\n@external\ndef depositForYield(\n    _asset: address,\n    _amount: uint256,\n    _vaultAddr: address,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, address, uint256, uint256):\n    return 0, empty(address), 0, 0\n\n\n@external\ndef withdrawFromYield(\n    _vaultToken: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, address, uint256, uint256):\n    return 0, empty(address), 0, 0\n\n\n@external\ndef mintOrRedeemAsset(\n    _tokenIn: address,\n    _tokenOut: address,\n    _tokenInAmount: uint256,\n    _minAmountOut: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, bool, uint256):\n    return 0, 0, False, 0\n\n\n@external\ndef confirmMintOrRedeemAsset(\n    _tokenIn: address,\n    _tokenOut: address,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef addCollateral(\n    _asset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef removeCollateral(\n    _asset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef borrow(\n    _borrowAsset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef repayDebt(\n    _paymentAsset: address,\n    _paymentAmount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef claimRewards(\n    _user: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _extraData: bytes32,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n@external\ndef addLiquidityConcentrated(\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _tickLower: int24,\n    _tickUpper: int24,\n    _amountA: uint256,\n    _amountB: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, uint256, uint256):\n    return 0, 0, 0, 0, 0\n\n\n@external\ndef removeLiquidityConcentrated(\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _liqToRemove: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, bool, uint256):\n    return 0, 0, 0, False, 0\n\n\n\n@view\n@external\ndef getAccessForLego(_user: address, _action: ws.ActionType) -> (address, String[64], uint256):\n    return empty(address), empty(String[64]), 0\n\n\n@view\n@external\ndef getPricePerShare(_asset: address, _decimals: uint256) -> uint256:\n    return 0\n",
            "sha256sum": "720f9f5a7484fddb68fe5f05cfb4c5917c421adec0a472a1e811654dad1eb389"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/legos/dexes/UniswapV2.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.3+commit.bff19ea2",
        "integrity": "0673b5cf77c564fe43a3ccb7e202843f42419fef7ae538b70191da8c2393576e"
      },
      "args": "00000000000000000000000044cf3c4f000dfd76a35d03298049d37be688d6f90000000000000000000000008909dc15e40173ff4699343b6eb8132c65e18ec60000000000000000000000004752ba5dbc23f44d87826276bf6fd6b1c372ad2400000000000000000000000088a43bbdf9d098eec7bceda4e2494615dfd9bb9c",
      "file": "contracts/legos/dexes/UniswapV2.vy"
    },
    "UniswapV3": {
      "address": "0x804EC0b82525DE4EA25Bc777a652e8A5c0A97249",
      "abi": [
        {
          "name": "UniswapV3Swap",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenIn",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenOut",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amountIn",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "amountOut",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "numTokens",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UniswapV3LiquidityAdded",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenA",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenB",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amountA",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "amountB",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "liquidityAdded",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "nftTokenId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UniswapV3LiquidityRemoved",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": false
            },
            {
              "name": "pool",
              "type": "address",
              "indexed": true
            },
            {
              "name": "nftTokenId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "tokenA",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenB",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amountA",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "amountB",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "liquidityRemoved",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UniswapV3NftRecovered",
          "inputs": [
            {
              "name": "collection",
              "type": "address",
              "indexed": true
            },
            {
              "name": "nftTokenId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LegoPauseModified",
          "inputs": [
            {
              "name": "isPaused",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LegoFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "balance",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddys",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "undyToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "hatchery",
                  "type": "address"
                },
                {
                  "name": "lootDistributor",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                },
                {
                  "name": "walletBackpack",
                  "type": "address"
                },
                {
                  "name": "billing",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUndyHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pause",
          "inputs": [
            {
              "name": "_shouldPause",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFundsMany",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_assets",
              "type": "address[]"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "legoId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isPaused",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasCapability",
          "inputs": [
            {
              "name": "_action",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "onERC721Received",
          "inputs": [
            {
              "name": "_operator",
              "type": "address"
            },
            {
              "name": "_owner",
              "type": "address"
            },
            {
              "name": "_tokenId",
              "type": "uint256"
            },
            {
              "name": "_data",
              "type": "bytes"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bytes4"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRegistries",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isYieldLego",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isDexLego",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_tokenPath",
              "type": "address[]"
            },
            {
              "name": "_poolPath",
              "type": "address[]"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_tokenPath",
              "type": "address[]"
            },
            {
              "name": "_poolPath",
              "type": "address[]"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "uniswapV3SwapCallback",
          "inputs": [
            {
              "name": "_amount0Delta",
              "type": "int256"
            },
            {
              "name": "_amount1Delta",
              "type": "int256"
            },
            {
              "name": "_data",
              "type": "bytes"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLpToken",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPoolForLpToken",
          "inputs": [
            {
              "name": "_lpToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getCoreRouterPool",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getDeepestLiqPool",
          "inputs": [
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "fee",
                  "type": "uint256"
                },
                {
                  "name": "liquidity",
                  "type": "uint256"
                },
                {
                  "name": "numCoins",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getBestSwapAmountOut",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountIn",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getSwapAmountOut",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountIn",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getBestSwapAmountIn",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountOut",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getSwapAmountIn",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountOut",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddLiqAmountsIn",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_availAmountA",
              "type": "uint256"
            },
            {
              "name": "_availAmountB",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRemoveLiqAmountsOut",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPrice",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_decimals",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPriceUnsafe",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_targetToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPriceUnsafe",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_targetToken",
              "type": "address"
            },
            {
              "name": "_appraiser",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverNft",
          "inputs": [
            {
              "name": "_collection",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositForYield",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositForYield",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawFromYield",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawFromYield",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_tokenInAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_tokenInAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmMintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmMintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_borrowAsset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_borrowAsset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_paymentAsset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_paymentAsset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAccessForLego",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_action",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "string"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPricePerShare",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_decimals",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "UNIV3_FACTORY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "UNIV3_NFT_MANAGER",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "UNIV3_QUOTER",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "coreRouterPool",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_undyHq",
              "type": "address"
            },
            {
              "name": "_uniswapV3Factory",
              "type": "address"
            },
            {
              "name": "_uniNftPositionManager",
              "type": "address"
            },
            {
              "name": "_uniV3Quoter",
              "type": "address"
            },
            {
              "name": "_coreRouterPool",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "interfaces/WalletStructs.vyi": {
            "content": "# @version 0.4.3\n\nflag ActionType:\n    TRANSFER\n    EARN_DEPOSIT\n    EARN_WITHDRAW\n    EARN_REBALANCE\n    SWAP\n    MINT_REDEEM\n    CONFIRM_MINT_REDEEM\n    ADD_COLLATERAL\n    REMOVE_COLLATERAL\n    BORROW\n    REPAY_DEBT\n    REWARDS\n    ETH_TO_WETH\n    WETH_TO_ETH\n    ADD_LIQ\n    REMOVE_LIQ\n    ADD_LIQ_CONC\n    REMOVE_LIQ_CONC\n    PAY_CHEQUE\n\nstruct WalletAssetData:\n    assetBalance: uint256\n    usdValue: uint256\n    isYieldAsset: bool\n    lastPricePerShare: uint256\n\nstruct ActionData:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    billing: address\n    wallet: address\n    walletConfig: address\n    walletOwner: address\n    inEjectMode: bool\n    isFrozen: bool\n    lastTotalUsdValue: uint256\n    signer: address\n    isManager: bool\n    legoId: uint256\n    legoAddr: address\n    eth: address\n    weth: address\n\nstruct MiniAddys:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    appraiser: address",
            "sha256sum": "9a4b4f59b3a62043e51b425a665064aae419a3c0bd0514b6b29a9441ae364bb9"
          },
          "interfaces/LegoPartner.vyi": {
            "content": "# @version 0.4.3\n\nfrom interfaces import WalletStructs as ws\n\nMAX_TOKEN_PATH: constant(uint256) = 5\nMAX_RECOVER_ASSETS: constant(uint256) = 20\n\n@external\ndef addLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _tickLower: int24, _tickUpper: int24, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef addLiquidity(_pool: address, _tokenA: address, _tokenB: address, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _minLpAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (address, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef removeLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _liqToRemove: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef removeLiquidity(_pool: address, _tokenA: address, _tokenB: address, _lpToken: address, _lpAmount: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef mintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _tokenInAmount: uint256, _minAmountOut: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef swapTokens(_amountIn: uint256, _minAmountOut: uint256, _tokenPath: DynArray[address, MAX_TOKEN_PATH], _poolPath: DynArray[address, MAX_TOKEN_PATH - 1], _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256):\n    ...\n\n@external\ndef depositForYield(_asset: address, _amount: uint256, _vaultAddr: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef withdrawFromYield(_vaultToken: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef confirmMintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef borrow(_borrowAsset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef repayDebt(_paymentAsset: address, _paymentAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef claimRewards(_user: address, _rewardToken: address, _rewardAmount: uint256, _extraData: bytes32, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef removeCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef addCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@view\n@external\ndef getAccessForLego(_user: address, _action: ws.ActionType) -> (address, String[64], uint256):\n    ...\n\n@view\n@external\ndef hasCapability(_action: ws.ActionType) -> bool:\n    ...\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    ...\n\n@view\n@external\ndef isYieldLego() -> bool:\n    ...\n\n@view\n@external\ndef isDexLego() -> bool:\n    ...\n\n@view\n@external\ndef getPricePerShare(_asset: address, _decimals: uint256) -> uint256:\n    ...\n\n@view\n@external\ndef getPrice(_asset: address, _decimals: uint256) -> uint256:\n    ...\n\n\n# common\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "2513e379aa74d0a8120114a5078a4c1a0900165a1c3f24419bb811d173b56453"
          },
          "contracts/modules/Addys.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\ninterface UndyHq:\n    def isValidAddr(_addr: address) -> bool: view\n    def getAddr(_regId: uint256) -> address: view\n    def undyToken() -> address: view\n\ninterface Switchboard:\n    def isSwitchboardAddr(_addr: address) -> bool: view\n\ninterface LegoBook:\n    def isLegoAddr(_addr: address) -> bool: view\n\nstruct Addys:\n    hq: address\n    undyToken: address\n    ledger: address\n    missionControl: address\n    legoBook: address\n    switchboard: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    walletBackpack: address\n    billing: address\n\n# hq\nUNDY_HQ_FOR_ADDYS: immutable(address)\n\n# core addys\nLEDGER_ID: constant(uint256) = 1\nMISSION_CONTROL_ID: constant(uint256) = 2\nLEGO_BOOK_ID: constant(uint256) = 3\nSWITCHBOARD_ID: constant(uint256) = 4\nHATCHERY_ID: constant(uint256) = 5\nLOOT_DISTRIBUTOR_ID: constant(uint256) = 6\nAPPRAISER_ID: constant(uint256) = 7\nWALLET_BACKPACK_ID: constant(uint256) = 8\nBILLING_ID: constant(uint256) = 9\n\n\n@deploy\ndef __init__(_undyHq: address):\n    assert _undyHq != empty(address) # dev: invalid undy hq\n    UNDY_HQ_FOR_ADDYS = _undyHq\n\n\n########\n# Core #\n########\n\n\n@view\n@external\ndef getAddys() -> Addys:\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _getAddys(_addys: Addys = empty(Addys)) -> Addys:\n    if _addys.hq != empty(address):\n        return _addys\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _generateAddys() -> Addys:\n    hq: address = UNDY_HQ_FOR_ADDYS\n    return Addys(\n        hq = hq,\n        undyToken = staticcall UndyHq(hq).undyToken(),\n        ledger = staticcall UndyHq(hq).getAddr(LEDGER_ID),\n        missionControl = staticcall UndyHq(hq).getAddr(MISSION_CONTROL_ID),\n        legoBook = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID),\n        switchboard = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID),\n        hatchery = staticcall UndyHq(hq).getAddr(HATCHERY_ID),\n        lootDistributor = staticcall UndyHq(hq).getAddr(LOOT_DISTRIBUTOR_ID),\n        appraiser = staticcall UndyHq(hq).getAddr(APPRAISER_ID),\n        walletBackpack = staticcall UndyHq(hq).getAddr(WALLET_BACKPACK_ID),\n        billing = staticcall UndyHq(hq).getAddr(BILLING_ID),\n    )\n\n\n##########\n# Tokens #\n##########\n\n\n@view\n@internal\ndef _getUndyToken() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).undyToken()\n\n\n###########\n# Helpers #\n###########\n\n\n# undy hq\n\n\n@view\n@external\ndef getUndyHq() -> address:\n    return self._getUndyHq()\n\n\n@view\n@internal\ndef _getUndyHq() -> address:\n    return UNDY_HQ_FOR_ADDYS\n\n\n# utils\n\n\n@view\n@internal\ndef _isValidUndyAddr(_addr: address, _hq: address = empty(address)) -> bool:\n    hq: address = _hq\n    if _hq == empty(address):\n        hq = UNDY_HQ_FOR_ADDYS\n    \n    # core departments\n    if staticcall UndyHq(hq).isValidAddr(_addr):\n        return True\n\n    # lego book\n    legoBook: address = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID)\n    if legoBook != empty(address) and staticcall LegoBook(legoBook).isLegoAddr(_addr):\n        return True\n\n    # switchboard config\n    switchboard: address = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID)\n    if switchboard != empty(address) and staticcall Switchboard(switchboard).isSwitchboardAddr(_addr):\n        return True\n\n    return False\n\n\n@view\n@internal\ndef _isSwitchboardAddr(_addr: address) -> bool:\n    switchboard: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n    if switchboard == empty(address):\n        return False\n    return staticcall Switchboard(switchboard).isSwitchboardAddr(_addr)\n\n\n@view\n@internal\ndef _isLegoBookAddr(_addr: address) -> bool:\n    legoBook: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n    if legoBook == empty(address):\n        return False\n    return staticcall LegoBook(legoBook).isLegoAddr(_addr)\n\n\n###############\n# Departments #\n###############\n\n\n# ledger\n\n\n@view\n@internal\ndef _getLedgerId() -> uint256:\n    return LEDGER_ID\n\n\n@view\n@internal\ndef _getLedgerAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEDGER_ID)\n\n\n# mission control\n\n\n@view\n@internal\ndef _getMissionControlId() -> uint256:\n    return MISSION_CONTROL_ID\n\n\n@view\n@internal\ndef _getMissionControlAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(MISSION_CONTROL_ID)\n\n\n# lego book\n\n\n@view\n@internal\ndef _getLegoBookId() -> uint256:\n    return LEGO_BOOK_ID\n\n\n@view\n@internal\ndef _getLegoBookAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n\n\n# switchboard\n\n\n@view\n@internal\ndef _getSwitchboardId() -> uint256:\n    return SWITCHBOARD_ID\n\n\n@view\n@internal\ndef _getSwitchboardAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n\n\n# hatchery\n\n\n@view\n@internal\ndef _getHatcheryId() -> uint256:\n    return HATCHERY_ID\n\n\n@view\n@internal\ndef _getHatcheryAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(HATCHERY_ID)\n\n\n# loot distributor\n\n\n@view\n@internal\ndef _getLootDistributorId() -> uint256:\n    return LOOT_DISTRIBUTOR_ID\n\n\n@view\n@internal\ndef _getLootDistributorAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LOOT_DISTRIBUTOR_ID)\n\n\n# appraiser\n\n\n@view\n@internal\ndef _getAppraiserId() -> uint256:\n    return APPRAISER_ID\n\n\n@view\n@internal\ndef _getAppraiserAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(APPRAISER_ID)\n\n\n# wallet backpack\n\n\n@view\n@internal\ndef _getWalletBackpackId() -> uint256:\n    return WALLET_BACKPACK_ID\n\n\n@view\n@internal\ndef _getWalletBackpackAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(WALLET_BACKPACK_ID)\n\n\n# billing\n\n\n@view\n@internal\ndef _getBillingId() -> uint256:\n    return BILLING_ID\n\n\n@view\n@internal\ndef _getBillingAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(BILLING_ID)",
            "sha256sum": "78b58f0b2acb2eaafa4d21adf9135a1cd0e1d53897f7a1fa70a83a04a7738ad3"
          },
          "contracts/modules/DexLegoData.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nuses: addys\n\nimport contracts.modules.Addys as addys\n\nfrom interfaces import WalletStructs as ws\nfrom ethereum.ercs import IERC20\n\nevent LegoPauseModified:\n    isPaused: bool\n\nevent LegoFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    balance: uint256\n\n# config\nlegoId: public(uint256)\nisPaused: public(bool)\n\nMAX_RECOVER_ASSETS: constant(uint256) = 20\n\n\n@deploy\ndef __init__(_shouldPause: bool):\n    self.isPaused = _shouldPause\n\n\n###########\n# General #\n###########\n\n\n# fill mini addys\n\n\n@view\n@internal\ndef _getMiniAddys(_miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> ws.MiniAddys:\n    if _miniAddys.ledger != empty(address):\n        return _miniAddys\n    return ws.MiniAddys(\n        ledger = addys._getLedgerAddr(),\n        missionControl = addys._getMissionControlAddr(),\n        legoBook = addys._getLegoBookAddr(),\n        appraiser = addys._getAppraiserAddr(),\n    )\n\n\n# activate\n\n\n@external\ndef pause(_shouldPause: bool):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert _shouldPause != self.isPaused # dev: no change\n    self.isPaused = _shouldPause\n    log LegoPauseModified(isPaused=_shouldPause)\n\n\n# recover funds\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    self._recoverFunds(_recipient, _asset)\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, MAX_RECOVER_ASSETS]):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    for a: address in _assets:\n        self._recoverFunds(_recipient, a)\n\n\n@internal\ndef _recoverFunds(_recipient: address, _asset: address):\n    assert empty(address) not in [_recipient, _asset] # dev: invalid recipient or asset\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    assert balance != 0 # dev: nothing to recover\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log LegoFundsRecovered(asset=_asset, recipient=_recipient, balance=balance)",
            "sha256sum": "75b15af2475ab409d4b5fd057509d14c20564ebd7fcb0850e3b61397d8e3af48"
          },
          "contracts/legos/dexes/UniswapV3.vy": {
            "content": "#     _____  _____  __  __    ____   _____  _____  _____ \n#    |  _  \\/   __\\/  \\/  \\  /  _/  /   __\\/   __\\/  _  \\\n#    |  |  ||   __|>-    -<  |  |---|   __||  |_ ||  |  |\n#    |_____/\\_____/\\__/\\__/  \\_____/\\_____/\\_____/\\_____/\n#                                                                       \n#     \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n#     \u2551  ** Uniswap V3 Lego **           \u2551\n#     \u2551  Integration with Uniswap V3.    \u2551\n#     \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n#\n#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nimplements: Lego\nimplements: IUniswapV3Callback\n\nexports: addys.__interface__\nexports: dld.__interface__\n\ninitializes: addys\ninitializes: dld[addys := addys]\n\nfrom interfaces import LegoPartner as Lego\nfrom interfaces import WalletStructs as ws\n\nimport contracts.modules.Addys as addys\nimport contracts.modules.DexLegoData as dld\n\nfrom ethereum.ercs import IERC20\nfrom ethereum.ercs import IERC20Detailed\nfrom ethereum.ercs import IERC721\n\n# `getSwapAmountOut()` and `getSwapAmountIn()` cannot be view functions, sadly\n# keeping here to uncomment to test all other functions\n# implements: DexLego\n# from interfaces import DexLego as DexLego\n\ninterface UniV3Pool:\n    def slot0() -> (uint160, int24, uint16, uint16, uint16, uint8, bool): view\n    def swap(_recipient: address, _zeroForOne: bool, _amountSpecified: int256, _sqrtPriceLimitX96: uint160, _data: Bytes[256]) -> (int256, int256): nonpayable\n    def liquidity() -> uint128: view\n    def tickSpacing() -> int24: view\n    def token0() -> address: view\n    def token1() -> address: view\n    def fee() -> uint24: view\n\ninterface UniV3NftPositionManager:\n    def increaseLiquidity(_params: IncreaseLiquidityParams) -> (uint128, uint256, uint256): nonpayable\n    def decreaseLiquidity(_params: DecreaseLiquidityParams) -> (uint256, uint256): nonpayable\n    def mint(_params: MintParams) -> (uint256, uint128, uint256, uint256): nonpayable\n    def collect(_params: CollectParams) -> (uint256, uint256): nonpayable\n    def positions(_tokenId: uint256) -> PositionData: view\n    def burn(_tokenId: uint256): nonpayable\n\ninterface UniV3Quoter:\n    def quoteExactOutputSingle(_params: QuoteExactOutputSingleParams) -> (uint256, uint160, uint32, uint256): nonpayable\n    def quoteExactInputSingle(_params: QuoteExactInputSingleParams) -> (uint256, uint160, uint32, uint256): nonpayable\n    def quoteExactInput(_path: Bytes[1024], _amountIn: uint256) -> uint256: nonpayable\n\ninterface Appraiser:\n    def getNormalAssetPrice(_asset: address, _missionControl: address = empty(address), _legoBook: address = empty(address), _ledger: address = empty(address)) -> uint256: view\n    def updatePriceAndGetUsdValue(_asset: address, _amount: uint256, _missionControl: address = empty(address), _legoBook: address = empty(address)) -> uint256: nonpayable\n\ninterface IUniswapV3Callback:\n    def uniswapV3SwapCallback(_amount0Delta: int256, _amount1Delta: int256, _data: Bytes[256]): nonpayable\n\ninterface UniV3Factory:\n    def getPool(_tokenA: address, _tokenB: address, _fee: uint24) -> address: view\n\nstruct QuoteExactInputSingleParams:\n    tokenIn: address\n    tokenOut: address\n    amountIn: uint256\n    fee: uint24\n    sqrtPriceLimitX96: uint160\n\nstruct QuoteExactOutputSingleParams:\n    tokenIn: address\n    tokenOut: address\n    amount: uint256\n    fee: uint24\n    sqrtPriceLimitX96: uint160\n\nstruct BestPool:\n    pool: address\n    fee: uint256\n    liquidity: uint256\n    numCoins: uint256\n\nstruct MintParams:\n    token0: address\n    token1: address\n    fee: uint24\n    tickLower: int24\n    tickUpper: int24\n    amount0Desired: uint256\n    amount1Desired: uint256\n    amount0Min: uint256\n    amount1Min: uint256\n    recipient: address\n    deadline: uint256\n\nstruct IncreaseLiquidityParams:\n    tokenId: uint256\n    amount0Desired: uint256\n    amount1Desired: uint256\n    amount0Min: uint256\n    amount1Min: uint256\n    deadline: uint256\n\nstruct DecreaseLiquidityParams:\n    tokenId: uint256\n    liquidity: uint128\n    amount0Min: uint256\n    amount1Min: uint256\n    deadline: uint256\n\nstruct CollectParams:\n    tokenId: uint256\n    recipient: address\n    amount0Max: uint128\n    amount1Max: uint128\n\nstruct PositionData:\n    nonce: uint96\n    operator: address\n    token0: address\n    token1: address\n    fee: uint24\n    tickLower: int24\n    tickUpper: int24\n    liquidity: uint128\n    feeGrowthInside0LastX128: uint256\n    feeGrowthInside1LastX128: uint256\n    tokensOwed0: uint128\n    tokensOwed1: uint128\n\nstruct PoolSwapData:\n    pool: address\n    tokenIn: address\n    amountIn: uint256\n\nevent UniswapV3Swap:\n    sender: indexed(address)\n    tokenIn: indexed(address)\n    tokenOut: indexed(address)\n    amountIn: uint256\n    amountOut: uint256\n    usdValue: uint256\n    numTokens: uint256\n    recipient: address\n\nevent UniswapV3LiquidityAdded:\n    sender: indexed(address)\n    tokenA: indexed(address)\n    tokenB: indexed(address)\n    amountA: uint256\n    amountB: uint256\n    liquidityAdded: uint256\n    nftTokenId: uint256\n    usdValue: uint256\n    recipient: address\n\nevent UniswapV3LiquidityRemoved:\n    sender: address\n    pool: indexed(address)\n    nftTokenId: uint256\n    tokenA: indexed(address)\n    tokenB: indexed(address)\n    amountA: uint256\n    amountB: uint256\n    liquidityRemoved: uint256\n    usdValue: uint256\n    recipient: address\n\nevent UniswapV3NftRecovered:\n    collection: indexed(address)\n    nftTokenId: uint256\n    recipient: indexed(address)\n\n# transient storage\npoolSwapData: transient(PoolSwapData)\n\n# uniswap v3\nUNIV3_FACTORY: public(immutable(address))\nUNIV3_NFT_MANAGER: public(immutable(address))\nUNIV3_QUOTER: public(immutable(address))\ncoreRouterPool: public(address)\n\nFEE_TIERS: constant(uint24[4]) = [100, 500, 3000, 10000] # 0.01%, 0.05%, 0.3%, 1%\nMIN_SQRT_RATIO_PLUS_ONE: constant(uint160) = 4295128740\nMAX_SQRT_RATIO_MINUS_ONE: constant(uint160) = 1461446703485210103287273052203988822378723970341\nTICK_LOWER: constant(int24) = -887272\nTICK_UPPER: constant(int24) = 887272\nERC721_RECEIVE_DATA: constant(Bytes[1024]) = b\"UE721\"\nEIGHTEEN_DECIMALS: constant(uint256) = 10 ** 18\nUNISWAP_Q96: constant(uint256) = 2 ** 96  # uniswap's fixed point scaling factor\nMAX_TOKEN_PATH: constant(uint256) = 5\n\n\n@deploy\ndef __init__(\n    _undyHq: address,\n    _uniswapV3Factory: address,\n    _uniNftPositionManager: address,\n    _uniV3Quoter: address,\n    _coreRouterPool: address,\n):\n    addys.__init__(_undyHq)\n    dld.__init__(False)\n\n    assert empty(address) not in [_uniswapV3Factory, _uniNftPositionManager, _uniV3Quoter, _coreRouterPool] # dev: invalid addrs\n    UNIV3_FACTORY = _uniswapV3Factory\n    UNIV3_NFT_MANAGER = _uniNftPositionManager\n    UNIV3_QUOTER = _uniV3Quoter\n    self.coreRouterPool = _coreRouterPool\n\n\n@view\n@external\ndef hasCapability(_action: ws.ActionType) -> bool:\n    return _action in (\n        ws.ActionType.SWAP |\n        ws.ActionType.ADD_LIQ_CONC | \n        ws.ActionType.REMOVE_LIQ_CONC\n    )\n\n\n@view\n@external\ndef onERC721Received(_operator: address, _owner: address, _tokenId: uint256, _data: Bytes[1024]) -> bytes4:\n    # must implement method for safe NFT transfers\n    assert _data == ERC721_RECEIVE_DATA # dev: did not receive from within Underscore wallet\n    return method_id(\"onERC721Received(address,address,uint256,bytes)\", output_type=bytes4)\n\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    return [UNIV3_FACTORY, UNIV3_NFT_MANAGER, UNIV3_QUOTER]\n\n\n@view\n@external\ndef isYieldLego() -> bool:\n    return False\n\n\n@view\n@external\ndef isDexLego() -> bool:\n    return True\n\n\n#########\n# Swaps #\n#########\n\n\n@external\ndef swapTokens(\n    _amountIn: uint256,\n    _minAmountOut: uint256,\n    _tokenPath: DynArray[address, MAX_TOKEN_PATH],\n    _poolPath: DynArray[address, MAX_TOKEN_PATH - 1],\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256):\n    assert not dld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = dld._getMiniAddys(_miniAddys)\n\n    # validate inputs\n    numTokens: uint256 = len(_tokenPath)\n    numPools: uint256 = len(_poolPath)\n    assert numTokens >= 2 # dev: invalid path\n    assert numPools == numTokens - 1 # dev: invalid path\n\n    # get first token and last token\n    tokenIn: address = _tokenPath[0]\n    tokenOut: address = _tokenPath[numTokens - 1]\n\n    # pre balances\n    preLegoBalance: uint256 = staticcall IERC20(tokenIn).balanceOf(self)\n\n    # transfer deposit asset to this contract\n    amountIn: uint256 = min(_amountIn, staticcall IERC20(tokenIn).balanceOf(msg.sender))\n    assert amountIn != 0 # dev: nothing to transfer\n    assert extcall IERC20(tokenIn).transferFrom(msg.sender, self, amountIn, default_return_value=True) # dev: transfer failed\n\n    # iterate through swap routes\n    tempAmountIn: uint256 = amountIn\n    uniswapV3Factory: address = UNIV3_FACTORY\n    for i: uint256 in range(numTokens - 1, bound=MAX_TOKEN_PATH):\n        tempTokenIn: address = _tokenPath[i]\n        tempTokenOut: address = _tokenPath[i + 1]\n        tempPool: address = _poolPath[i]\n\n        # transfer to self (or to recipient if last swap)\n        recipient: address = _recipient\n        if i < numTokens - 2:\n            recipient = self\n\n        # swap\n        tempAmountIn = self._swapTokensInPool(tempPool, tempTokenIn, tempTokenOut, tempAmountIn, recipient, uniswapV3Factory)\n\n    # final amount\n    amountOut: uint256 = tempAmountIn\n    assert amountOut >= _minAmountOut # dev: min amount out not met\n\n    # refund if full swap didn't get through\n    currentLegoBalance: uint256 = staticcall IERC20(tokenIn).balanceOf(self)\n    refundAssetAmount: uint256 = 0\n    if currentLegoBalance > preLegoBalance:\n        refundAssetAmount = currentLegoBalance - preLegoBalance\n        assert extcall IERC20(tokenIn).transfer(msg.sender, refundAssetAmount, default_return_value=True) # dev: transfer failed\n        amountIn -= refundAssetAmount\n\n    # get usd values\n    usdValue: uint256 = extcall Appraiser(miniAddys.appraiser).updatePriceAndGetUsdValue(tokenIn, amountIn, miniAddys.missionControl, miniAddys.legoBook)\n    if usdValue == 0:\n        usdValue = extcall Appraiser(miniAddys.appraiser).updatePriceAndGetUsdValue(tokenOut, amountOut, miniAddys.missionControl, miniAddys.legoBook)\n\n    log UniswapV3Swap(\n        sender = msg.sender,\n        tokenIn = tokenIn,\n        tokenOut = tokenOut,\n        amountIn = amountIn,\n        amountOut = amountOut,\n        usdValue = usdValue,\n        numTokens = numTokens,\n        recipient = _recipient,\n    )\n    return amountIn, amountOut, usdValue\n\n\n# swap in pool\n\n\n@internal\ndef _swapTokensInPool(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n    _recipient: address,\n    _uniswapV3Factory: address,\n) -> uint256:\n    tokens: address[2] = [staticcall UniV3Pool(_pool).token0(), staticcall UniV3Pool(_pool).token1()]\n    assert _tokenIn in tokens # dev: invalid tokenIn\n    assert _tokenOut in tokens # dev: invalid tokenOut\n    assert _tokenIn != _tokenOut # dev: invalid tokens\n\n    # verify actual uniswap v3 pool\n    assert staticcall UniV3Factory(_uniswapV3Factory).getPool(_tokenIn, _tokenOut, staticcall UniV3Pool(_pool).fee()) == _pool # dev: invalid pool\n\n    # save in transient storage (for use in callback)\n    self.poolSwapData = PoolSwapData(\n        pool=_pool,\n        tokenIn=_tokenIn,\n        amountIn=_amountIn,\n    )\n\n    zeroForOne: bool = _tokenIn == tokens[0]\n    sqrtPriceLimitX96: uint160 = MAX_SQRT_RATIO_MINUS_ONE\n    if zeroForOne:\n        sqrtPriceLimitX96 = MIN_SQRT_RATIO_PLUS_ONE\n\n    # perform swap\n    amount0: int256 = 0\n    amount1: int256 = 0\n    amount0, amount1 = extcall UniV3Pool(_pool).swap(_recipient, zeroForOne, convert(_amountIn, int256), sqrtPriceLimitX96, b\"\")\n\n    toAmount: uint256 = 0\n    if zeroForOne:\n        toAmount = convert(-amount1, uint256)\n    else:\n        toAmount = convert(-amount0, uint256)\n\n    assert toAmount != 0 # dev: no tokens swapped\n    return toAmount\n\n\n# callback\n\n\n@external\ndef uniswapV3SwapCallback(_amount0Delta: int256, _amount1Delta: int256, _data: Bytes[256]):\n    poolSwapData: PoolSwapData = self.poolSwapData\n    assert msg.sender == poolSwapData.pool # dev: no perms\n\n    # transfer tokens to pool\n    assert extcall IERC20(poolSwapData.tokenIn).transfer(poolSwapData.pool, poolSwapData.amountIn, default_return_value=True) # dev: transfer failed\n    self.poolSwapData = empty(PoolSwapData)\n\n\n#################\n# Add Liquidity #\n#################\n\n\n@external\ndef addLiquidityConcentrated(\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _tickLower: int24,\n    _tickUpper: int24,\n    _amountA: uint256,\n    _amountB: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, uint256, uint256):\n    assert not dld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = dld._getMiniAddys(_miniAddys)\n\n    # validate tokens\n    tokens: address[2] = [staticcall UniV3Pool(_pool).token0(), staticcall UniV3Pool(_pool).token1()]\n    assert _tokenA in tokens # dev: invalid tokenA\n    assert _tokenB in tokens # dev: invalid tokenB\n    assert _tokenA != _tokenB # dev: invalid tokens\n\n    # pre balances\n    preLegoBalanceA: uint256 = staticcall IERC20(_tokenA).balanceOf(self)\n    preLegoBalanceB: uint256 = staticcall IERC20(_tokenB).balanceOf(self)\n\n    # token a\n    liqAmountA: uint256 = min(_amountA, staticcall IERC20(_tokenA).balanceOf(msg.sender))\n    assert liqAmountA != 0 # dev: nothing to transfer\n    assert extcall IERC20(_tokenA).transferFrom(msg.sender, self, liqAmountA, default_return_value=True) # dev: transfer failed\n\n    # token b\n    liqAmountB: uint256 = min(_amountB, staticcall IERC20(_tokenB).balanceOf(msg.sender))\n    assert liqAmountB != 0 # dev: nothing to transfer\n    assert extcall IERC20(_tokenB).transferFrom(msg.sender, self, liqAmountB, default_return_value=True) # dev: transfer failed\n\n    # approvals\n    nftPositionManager: address = UNIV3_NFT_MANAGER\n    assert extcall IERC20(_tokenA).approve(nftPositionManager, liqAmountA, default_return_value=True) # dev: approval failed\n    assert extcall IERC20(_tokenB).approve(nftPositionManager, liqAmountB, default_return_value=True) # dev: approval failed\n\n    # organized the index of tokens\n    token0: address = _tokenA\n    token1: address = _tokenB\n    amount0: uint256 = liqAmountA\n    amount1: uint256 = liqAmountB\n    minAmount0: uint256 = _minAmountA\n    minAmount1: uint256 = _minAmountB\n    if tokens[0] != _tokenA:\n        token0 = _tokenB\n        token1 = _tokenA\n        amount0 = liqAmountB\n        amount1 = liqAmountA\n        minAmount0 = _minAmountB\n        minAmount1 = _minAmountA\n\n    # add liquidity\n    nftTokenId: uint256 = _nftTokenId\n    liquidityAdded: uint256 = 0\n    liquidityAddedInt128: uint128 = 0\n    if _nftTokenId == 0:\n        nftTokenId, liquidityAddedInt128, amount0, amount1 = self._mintNewPosition(nftPositionManager, _pool, token0, token1, _tickLower, _tickUpper, amount0, amount1, minAmount0, minAmount1, _recipient)\n    else:\n        liquidityAddedInt128, amount0, amount1 = self._increaseExistingPosition(nftPositionManager, _nftTokenId, amount0, amount1, minAmount0, minAmount1, _recipient)\n\n    liquidityAdded = convert(liquidityAddedInt128, uint256)\n    assert liquidityAdded != 0 # dev: no liquidity added\n\n    # reset approvals\n    assert extcall IERC20(_tokenA).approve(nftPositionManager, 0, default_return_value=True) # dev: approval failed\n    assert extcall IERC20(_tokenB).approve(nftPositionManager, 0, default_return_value=True) # dev: approval failed\n\n    # refund if full liquidity was not added\n    currentLegoBalanceA: uint256 = staticcall IERC20(_tokenA).balanceOf(self)\n    refundAssetAmountA: uint256 = 0\n    if currentLegoBalanceA > preLegoBalanceA:\n        refundAssetAmountA = currentLegoBalanceA - preLegoBalanceA\n        assert extcall IERC20(_tokenA).transfer(msg.sender, refundAssetAmountA, default_return_value=True) # dev: transfer failed\n\n    currentLegoBalanceB: uint256 = staticcall IERC20(_tokenB).balanceOf(self)\n    refundAssetAmountB: uint256 = 0\n    if currentLegoBalanceB > preLegoBalanceB:\n        refundAssetAmountB = currentLegoBalanceB - preLegoBalanceB\n        assert extcall IERC20(_tokenB).transfer(msg.sender, refundAssetAmountB, default_return_value=True) # dev: transfer failed\n\n    # a/b amounts\n    liqAmountA = amount0\n    liqAmountB = amount1\n    if tokens[0] != _tokenA:\n        liqAmountA = amount1\n        liqAmountB = amount0\n\n    usdValue: uint256 = self._getUsdValue(_tokenA, liqAmountA, _tokenB, liqAmountB, miniAddys)\n    log UniswapV3LiquidityAdded(\n        sender = msg.sender,\n        tokenA = _tokenA,\n        tokenB = _tokenB,\n        amountA = liqAmountA,\n        amountB = liqAmountB,\n        liquidityAdded = liquidityAdded,\n        nftTokenId = nftTokenId,\n        usdValue = usdValue,\n        recipient = _recipient,\n    )\n    return liquidityAdded, liqAmountA, liqAmountB, nftTokenId, usdValue\n\n\n# mint new position\n\n\n@internal\ndef _mintNewPosition(\n    _nftPositionManager: address,\n    _pool: address,\n    _token0: address,\n    _token1: address,\n    _tickLower: int24,\n    _tickUpper: int24,\n    _amount0: uint256,\n    _amount1: uint256,\n    _minAmount0: uint256,\n    _minAmount1: uint256,\n    _recipient: address,\n) -> (uint256, uint128, uint256, uint256):\n    tickLower: int24 = 0\n    tickUpper: int24 = 0\n    tickLower, tickUpper = self._getTicks(_pool, _tickLower, _tickUpper)\n\n    # mint new position\n    params: MintParams = MintParams(\n        token0=_token0,\n        token1=_token1,\n        fee=staticcall UniV3Pool(_pool).fee(),\n        tickLower=tickLower,\n        tickUpper=tickUpper,\n        amount0Desired=_amount0,\n        amount1Desired=_amount1,\n        amount0Min=_minAmount0,\n        amount1Min=_minAmount1,\n        recipient=_recipient,\n        deadline=block.timestamp,\n    )\n    return extcall UniV3NftPositionManager(_nftPositionManager).mint(params)\n\n\n# get ticks\n\n\n@view\n@internal\ndef _getTicks(_pool: address, _tickLower: int24, _tickUpper: int24) -> (int24, int24):\n    tickSpacing: int24 = 0\n    if _tickLower == min_value(int24) or _tickUpper == max_value(int24):\n        tickSpacing = staticcall UniV3Pool(_pool).tickSpacing()\n\n    tickLower: int24 = _tickLower\n    if _tickLower == min_value(int24):\n        tickLower = (TICK_LOWER // tickSpacing) * tickSpacing\n\n    tickUpper: int24 = _tickUpper\n    if _tickUpper == max_value(int24):\n        tickUpper = (TICK_UPPER // tickSpacing) * tickSpacing\n\n    return tickLower, tickUpper\n\n\n# increase existing position\n\n\n@internal\ndef _increaseExistingPosition(\n    _nftPositionManager: address,\n    _tokenId: uint256,\n    _amount0: uint256,\n    _amount1: uint256,\n    _minAmount0: uint256,\n    _minAmount1: uint256,\n    _recipient: address,\n) -> (uint128, uint256, uint256):\n    assert staticcall IERC721(_nftPositionManager).ownerOf(_tokenId) == self # dev: nft not here\n\n    liquidityAddedInt128: uint128 = 0\n    amount0: uint256 = 0\n    amount1: uint256 = 0\n    params: IncreaseLiquidityParams = IncreaseLiquidityParams(\n        tokenId=_tokenId,\n        amount0Desired=_amount0,\n        amount1Desired=_amount1,\n        amount0Min=_minAmount0,\n        amount1Min=_minAmount1,\n        deadline=block.timestamp,\n    )\n    liquidityAddedInt128, amount0, amount1 = extcall UniV3NftPositionManager(_nftPositionManager).increaseLiquidity(params)\n\n    # collect fees (if applicable) -- must be done before transferring nft\n    positionData: PositionData = staticcall UniV3NftPositionManager(_nftPositionManager).positions(_tokenId)\n    self._collectFees(_nftPositionManager, _tokenId, _recipient, positionData)\n\n    # transfer nft to recipient\n    extcall IERC721(_nftPositionManager).safeTransferFrom(self, _recipient, _tokenId)\n\n    return liquidityAddedInt128, amount0, amount1\n\n\n# collect fees\n\n\n@internal\ndef _collectFees(_nftPositionManager: address, _tokenId: uint256, _recipient: address, _positionData: PositionData) -> (uint256, uint256):\n    if _positionData.tokensOwed0 == 0 and _positionData.tokensOwed1 == 0:\n        return 0, 0\n\n    params: CollectParams = CollectParams(\n        tokenId=_tokenId,\n        recipient=_recipient,\n        amount0Max=max_value(uint128),\n        amount1Max=max_value(uint128),\n    )\n    return extcall UniV3NftPositionManager(_nftPositionManager).collect(params)\n\n\n####################\n# Remove Liquidity #\n####################\n\n\n@external\ndef removeLiquidityConcentrated(\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _liqToRemove: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, bool, uint256):\n    assert not dld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = dld._getMiniAddys(_miniAddys)\n\n    # make sure nft is here\n    nftPositionManager: address = UNIV3_NFT_MANAGER\n    assert staticcall IERC721(nftPositionManager).ownerOf(_nftTokenId) == self # dev: nft not here\n\n    # get position data\n    positionData: PositionData = staticcall UniV3NftPositionManager(nftPositionManager).positions(_nftTokenId)\n    originalLiquidity: uint128 = positionData.liquidity\n\n    # validate tokens\n    tokens: address[2] = [positionData.token0, positionData.token1]\n    assert _tokenA in tokens # dev: invalid tokenA\n    assert _tokenB in tokens # dev: invalid tokenB\n    assert _tokenA != _tokenB # dev: invalid tokens\n\n    # organized the index of tokens\n    minAmount0: uint256 = _minAmountA\n    minAmount1: uint256 = _minAmountB\n    if _tokenA != tokens[0]:\n        minAmount0 = _minAmountB\n        minAmount1 = _minAmountA\n\n    # decrease liquidity\n    liqToRemove: uint256 = min(_liqToRemove, convert(positionData.liquidity, uint256))\n    assert liqToRemove != 0 # dev: no liquidity to remove\n\n    params: DecreaseLiquidityParams = DecreaseLiquidityParams(\n        tokenId=_nftTokenId,\n        liquidity=convert(liqToRemove, uint128),\n        amount0Min=minAmount0,\n        amount1Min=minAmount1,\n        deadline=block.timestamp,\n    )\n    amount0: uint256 = 0\n    amount1: uint256 = 0\n    amount0, amount1 = extcall UniV3NftPositionManager(nftPositionManager).decreaseLiquidity(params)\n    assert amount0 != 0 and amount1 != 0 # dev: no liquidity removed\n\n    # a/b amounts\n    amountA: uint256 = amount0\n    amountB: uint256 = amount1\n    if _tokenA != tokens[0]:\n        amountA = amount1\n        amountB = amount0\n\n    # get latest position data -- collect withdrawn tokens AND any fees (if applicable)\n    positionData = staticcall UniV3NftPositionManager(nftPositionManager).positions(_nftTokenId)\n    self._collectFees(nftPositionManager, _nftTokenId, _recipient, positionData)\n\n    # burn nft (if applicable)\n    isDepleted: bool = False\n    if positionData.liquidity == 0:\n        isDepleted = True\n        extcall UniV3NftPositionManager(nftPositionManager).burn(_nftTokenId)\n\n    # transfer nft to recipient\n    else:\n        extcall IERC721(nftPositionManager).safeTransferFrom(self, _recipient, _nftTokenId)\n\n    usdValue: uint256 = self._getUsdValue(_tokenA, amountA, _tokenB, amountB, miniAddys)\n    liquidityRemoved: uint256 = convert(originalLiquidity - positionData.liquidity, uint256)\n    log UniswapV3LiquidityRemoved(\n        sender = msg.sender,\n        pool = _pool,\n        nftTokenId = _nftTokenId,\n        tokenA = _tokenA,\n        tokenB = _tokenB,\n        amountA = amountA,\n        amountB = amountB,\n        liquidityRemoved = liquidityRemoved,\n        usdValue = usdValue,\n        recipient = _recipient,\n    )\n    return amountA, amountB, liquidityRemoved, isDepleted, usdValue\n\n\n# get usd value on liquidity actions\n\n\n@internal\ndef _getUsdValue(\n    _tokenA: address,\n    _amountA: uint256,\n    _tokenB: address,\n    _amountB: uint256,\n    _miniAddys: ws.MiniAddys,\n) -> uint256:\n\n    usdValueA: uint256 = 0\n    if _amountA != 0:\n        usdValueA = extcall Appraiser(_miniAddys.appraiser).updatePriceAndGetUsdValue(_tokenA, _amountA, _miniAddys.missionControl, _miniAddys.legoBook)\n\n    usdValueB: uint256 = 0\n    if _amountB != 0:\n        usdValueB = extcall Appraiser(_miniAddys.appraiser).updatePriceAndGetUsdValue(_tokenB, _amountB, _miniAddys.missionControl, _miniAddys.legoBook)\n\n    return usdValueA + usdValueB\n\n\n#############\n# Utilities #\n#############\n\n\n@view\n@external\ndef getLpToken(_pool: address) -> address:\n    # no lp tokens for uniswap v3\n    return empty(address)\n\n\n@view\n@external\ndef getPoolForLpToken(_lpToken: address) -> address:\n    # no lp tokens for uniswap v3\n    return empty(address)\n\n\n@view\n@external\ndef getCoreRouterPool() -> address:\n    return self.coreRouterPool\n\n\n@view\n@external\ndef getDeepestLiqPool(_tokenA: address, _tokenB: address) -> BestPool:\n    bestPoolAddr: address = empty(address)\n    bestFeeTier: uint24 = 0\n    bestPoolAddr, bestFeeTier = self._getDeepestLiqPool(_tokenA, _tokenB)\n\n    if bestPoolAddr == empty(address):\n        return empty(BestPool)\n\n    # get token balances\n    tokenABal: uint256 = staticcall IERC20(_tokenA).balanceOf(bestPoolAddr)\n    tokenBBal: uint256 = staticcall IERC20(_tokenB).balanceOf(bestPoolAddr)\n\n    return BestPool(\n        pool=bestPoolAddr,\n        fee=convert(bestFeeTier // 100, uint256), # normalize to have 100_00 denominator\n        liquidity=tokenABal + tokenBBal, # not exactly \"liquidity\" but this comparable to \"reserves\"\n        numCoins=2,\n    )\n\n\n# annoying that this cannot be view function, thanks uni v3\n@external\ndef getBestSwapAmountOut(_tokenIn: address, _tokenOut: address, _amountIn: uint256) -> (address, uint256):\n    bestPoolAddr: address = empty(address)\n    bestFeeTier: uint24 = 0\n    bestPoolAddr, bestFeeTier = self._getDeepestLiqPool(_tokenIn, _tokenOut)\n\n    if bestPoolAddr == empty(address):\n        return empty(address), 0\n\n    amountOut: uint256 = 0\n    na1: uint160 = 0\n    na2: uint32 = 0\n    na3: uint256 = 0\n    amountOut, na1, na2, na3 = extcall UniV3Quoter(UNIV3_QUOTER).quoteExactInputSingle(\n        QuoteExactInputSingleParams(\n            tokenIn=_tokenIn,\n            tokenOut=_tokenOut,\n            amountIn=_amountIn,\n            fee=bestFeeTier,\n            sqrtPriceLimitX96=0,\n        )\n    )\n    return bestPoolAddr, amountOut\n\n\n# annoying that this cannot be view function, thanks uni v3\n@external\ndef getSwapAmountOut(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n) -> uint256:\n    amountOut: uint256 = 0\n    na1: uint160 = 0\n    na2: uint32 = 0\n    na3: uint256 = 0\n    amountOut, na1, na2, na3 = extcall UniV3Quoter(UNIV3_QUOTER).quoteExactInputSingle(\n        QuoteExactInputSingleParams(\n            tokenIn=_tokenIn,\n            tokenOut=_tokenOut,\n            amountIn=_amountIn,\n            fee=staticcall UniV3Pool(_pool).fee(),\n            sqrtPriceLimitX96=0,\n        )\n    )\n    return amountOut\n\n\n# annoying that this cannot be view function, thanks uni v3\n@external\ndef getBestSwapAmountIn(_tokenIn: address, _tokenOut: address, _amountOut: uint256) -> (address, uint256):\n    if _amountOut == 0 or _amountOut == max_value(uint256):\n        return empty(address), max_value(uint256)\n\n    bestPoolAddr: address = empty(address)\n    bestFeeTier: uint24 = 0\n    bestPoolAddr, bestFeeTier = self._getDeepestLiqPool(_tokenIn, _tokenOut)\n    if bestPoolAddr == empty(address):\n        return empty(address), 0\n\n    amountIn: uint256 = 0\n    na1: uint160 = 0\n    na2: uint32 = 0\n    na3: uint256 = 0\n    amountIn, na1, na2, na3 = extcall UniV3Quoter(UNIV3_QUOTER).quoteExactOutputSingle(\n        QuoteExactOutputSingleParams(\n            tokenIn=_tokenIn,\n            tokenOut=_tokenOut,\n            amount=_amountOut,\n            fee=bestFeeTier,\n            sqrtPriceLimitX96=0,\n        )\n    )\n    return bestPoolAddr, amountIn\n\n\n# annoying that this cannot be view function, thanks uni v3\n@external\ndef getSwapAmountIn(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountOut: uint256,\n) -> uint256:\n    if _amountOut == 0 or _amountOut == max_value(uint256):\n        return max_value(uint256)\n\n    amountIn: uint256 = 0\n    na1: uint160 = 0\n    na2: uint32 = 0\n    na3: uint256 = 0\n    amountIn, na1, na2, na3 = extcall UniV3Quoter(UNIV3_QUOTER).quoteExactOutputSingle(\n        QuoteExactOutputSingleParams(\n            tokenIn=_tokenIn,\n            tokenOut=_tokenOut,\n            amount=_amountOut,\n            fee=staticcall UniV3Pool(_pool).fee(),\n            sqrtPriceLimitX96=0,\n        )\n    )\n    return amountIn\n\n\n@view\n@external\ndef getAddLiqAmountsIn(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _availAmountA: uint256,\n    _availAmountB: uint256,\n) -> (uint256, uint256, uint256):\n    token0: address = staticcall UniV3Pool(_pool).token0()\n\n    # get correct numerator and denominator\n    numerator: uint256 = 0\n    denominator: uint256 = 0\n    sqrtPriceX96Squared: uint256 = self._getSqrtPriceX96(_pool) ** 2\n    if _tokenA == token0:\n        numerator = sqrtPriceX96Squared\n        denominator = UNISWAP_Q96 ** 2\n    else:\n        numerator = UNISWAP_Q96 ** 2\n        denominator = sqrtPriceX96Squared\n\n    # calculate optimal amounts\n    amountA: uint256 = _availAmountA\n    amountB: uint256 = _availAmountA * numerator // denominator\n    if amountB > _availAmountB:\n        maybeAmountA: uint256 = _availAmountB * denominator // numerator\n        if maybeAmountA <= _availAmountA:\n            amountA = maybeAmountA\n            amountB = _availAmountB\n    return amountA, amountB, 0\n\n\n@view\n@external\ndef getRemoveLiqAmountsOut(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpAmount: uint256,\n) -> (uint256, uint256):\n    token0: address = staticcall UniV3Pool(_pool).token0()\n\n    # calculate expected amounts out\n    sqrtPriceX96: uint256 = self._getSqrtPriceX96(_pool)\n    amount0Out: uint256 = _lpAmount * UNISWAP_Q96 // sqrtPriceX96\n    amount1Out: uint256 = _lpAmount * sqrtPriceX96 // UNISWAP_Q96\n\n    # return amounts out\n    if _tokenA == token0:\n        return amount0Out, amount1Out\n    else:\n        return amount1Out, amount0Out\n\n\n@view\n@external\ndef getPrice(_asset: address, _decimals: uint256) -> uint256:\n    return 0 # TODO: implement price\n\n\n@view\n@external\ndef getPriceUnsafe(_pool: address, _targetToken: address, _appraiser: address = empty(address)) -> uint256:\n    token0: address = staticcall UniV3Pool(_pool).token0()\n    token1: address = staticcall UniV3Pool(_pool).token1()\n\n    # appraiser\n    appraiser: address = _appraiser\n    if _appraiser == empty(address):\n        appraiser = addys._getAppraiserAddr()\n\n    # alt price\n    altPrice: uint256 = 0\n    if _targetToken == token0:\n        altPrice = staticcall Appraiser(appraiser).getNormalAssetPrice(token1)\n    else:\n        altPrice = staticcall Appraiser(appraiser).getNormalAssetPrice(token0)\n\n    # return early if no alt price\n    if altPrice == 0:\n        return 0\n\n    # price of token0 in token1\n    sqrtPriceX96: uint256 = self._getSqrtPriceX96(_pool)\n    numerator: uint256 = sqrtPriceX96 ** 2 * EIGHTEEN_DECIMALS\n    priceZeroToOne: uint256 = numerator // (UNISWAP_Q96 ** 2)\n\n    # adjust for decimals: price should be in 18 decimals\n    decimals0: uint256 = convert(staticcall IERC20Detailed(token0).decimals(), uint256)\n    decimals1: uint256 = convert(staticcall IERC20Detailed(token1).decimals(), uint256)\n    if decimals0 > decimals1:\n        scaleFactor: uint256 = 10 ** (decimals0 - decimals1)\n        priceZeroToOne = priceZeroToOne * scaleFactor\n    elif decimals1 > decimals0:\n        scaleFactor: uint256 = 10 ** (decimals1 - decimals0)\n        priceZeroToOne = priceZeroToOne // scaleFactor\n\n    # if _targetToken is token1, make price inverse\n    priceToOther: uint256 = priceZeroToOne\n    if _targetToken == token1:\n        priceToOther = EIGHTEEN_DECIMALS * EIGHTEEN_DECIMALS // priceZeroToOne\n\n    return altPrice * priceToOther // EIGHTEEN_DECIMALS\n\n\n# internal utils\n\n\n@view\n@internal\ndef _getDeepestLiqPool(_tokenA: address, _tokenB: address) -> (address, uint24):\n    bestPoolAddr: address = empty(address)\n    bestFeeTier: uint24 = 0\n    bestLiquidity: uint128 = 0\n\n    factory: address = UNIV3_FACTORY\n    for i: uint256 in range(4):\n        fee: uint24 = FEE_TIERS[i]\n        pool: address = staticcall UniV3Factory(factory).getPool(_tokenA, _tokenB, fee)\n        if pool == empty(address):\n            continue\n        liquidity: uint128 = staticcall UniV3Pool(pool).liquidity()\n        if liquidity > bestLiquidity:\n            bestPoolAddr = pool\n            bestFeeTier = fee\n            bestLiquidity = liquidity\n\n    return bestPoolAddr, bestFeeTier\n\n\n@view\n@internal\ndef _getSqrtPriceX96(_pool: address) -> uint256:\n    sqrtPriceX96: uint160 = 0\n    tick: int24 = 0\n    observationIndex: uint16 = 0\n    observationCardinality: uint16 = 0\n    observationCardinalityNext: uint16 = 0\n    feeProtocol: uint8 = 0\n    unlocked: bool = False\n    sqrtPriceX96, tick, observationIndex, observationCardinality, observationCardinalityNext, feeProtocol, unlocked = staticcall UniV3Pool(_pool).slot0()\n    return convert(sqrtPriceX96, uint256)\n\n\n# nft recovery\n\n\n@external\ndef recoverNft(_collection: address, _nftTokenId: uint256, _recipient: address) -> bool:\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n\n    if staticcall IERC721(_collection).ownerOf(_nftTokenId) != self:\n        return False\n\n    extcall IERC721(_collection).safeTransferFrom(self, _recipient, _nftTokenId)\n    log UniswapV3NftRecovered(collection=_collection, nftTokenId=_nftTokenId, recipient=_recipient)\n    return True\n\n\n#########\n# Other #\n#########\n\n\n@external\ndef depositForYield(\n    _asset: address,\n    _amount: uint256,\n    _vaultAddr: address,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, address, uint256, uint256):\n    return 0, empty(address), 0, 0\n\n\n@external\ndef withdrawFromYield(\n    _vaultToken: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, address, uint256, uint256):\n    return 0, empty(address), 0, 0\n\n\n@external\ndef mintOrRedeemAsset(\n    _tokenIn: address,\n    _tokenOut: address,\n    _tokenInAmount: uint256,\n    _minAmountOut: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, bool, uint256):\n    return 0, 0, False, 0\n\n\n@external\ndef confirmMintOrRedeemAsset(\n    _tokenIn: address,\n    _tokenOut: address,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef addCollateral(\n    _asset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef removeCollateral(\n    _asset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef borrow(\n    _borrowAsset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef repayDebt(\n    _paymentAsset: address,\n    _paymentAmount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef claimRewards(\n    _user: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _extraData: bytes32,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n@external\ndef addLiquidity(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _amountA: uint256,\n    _amountB: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _minLpAmount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (address, uint256, uint256, uint256, uint256):\n    return empty(address), 0, 0, 0, 0\n\n\n@external\ndef removeLiquidity(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpToken: address,\n    _lpAmount: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, uint256):\n    return 0, 0, 0, 0\n\n@view\n@external\ndef getAccessForLego(_user: address, _action: ws.ActionType) -> (address, String[64], uint256):\n    return empty(address), empty(String[64]), 0\n\n\n@view\n@external\ndef getPricePerShare(_asset: address, _decimals: uint256) -> uint256:\n    return 0\n",
            "sha256sum": "5a0114ce13225a541691fbe9f2668d1d14c8b7046dd36eeab878cb139170d6ec"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/legos/dexes/UniswapV3.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.3+commit.bff19ea2",
        "integrity": "1e7c04ab96fca50bcb98c32be16d3b666a2070673b884709e9d024c3063fd918"
      },
      "args": "00000000000000000000000044cf3c4f000dfd76a35d03298049d37be688d6f900000000000000000000000033128a8fc17869897dce68ed026d694621f6fdfd00000000000000000000000003a520b32c04bf3beef7beb72e919cf822ed34f10000000000000000000000003d4e44eb1374240ce5f1b871ab261cd16335b76a000000000000000000000000d0b53d9277642d899df5c87a3966a349a798f224",
      "file": "contracts/legos/dexes/UniswapV3.vy"
    },
    "LegoTools": {
      "address": "0x2edb54bE8c4F6Cde402CAAe86A809D434b3AFC66",
      "abi": [
        {
          "name": "DepartmentPauseModified",
          "inputs": [
            {
              "name": "isPaused",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "DepartmentFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "balance",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddys",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "undyToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "hatchery",
                  "type": "address"
                },
                {
                  "name": "lootDistributor",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                },
                {
                  "name": "walletBackpack",
                  "type": "address"
                },
                {
                  "name": "billing",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUndyHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canMintUndy",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pause",
          "inputs": [
            {
              "name": "_shouldPause",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFundsMany",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_assets",
              "type": "address[]"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isPaused",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "aaveV3",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "aaveV3Id",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "compoundV3",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "compoundV3Id",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "euler",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "eulerId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "fluid",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "fluidId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "moonwell",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "moonwellId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "morpho",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "morphoId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "uniswapV2",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "uniswapV2Id",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "uniswapV3",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "uniswapV3Id",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "aerodrome",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "aerodromeId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "aerodromeSlipstream",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "aerodromeSlipstreamId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "curve",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "curveId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAsset",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAsset",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_legoBook",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingForUser",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingForUser",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_legoBook",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getVaultTokensForUser",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple[]",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "vaultToken",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getVaultTokensForUser",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_legoBook",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple[]",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "vaultToken",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_legoBook",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getVaultTokenAmount",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_assetAmount",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getVaultTokenAmount",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_assetAmount",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_legoBook",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLegoInfoFromVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "string"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLegoInfoFromVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_legoBook",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "string"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingData",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "amount",
                  "type": "uint256"
                },
                {
                  "name": "usdValue",
                  "type": "uint256"
                },
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "legoAddr",
                  "type": "address"
                },
                {
                  "name": "legoDesc",
                  "type": "string"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingData",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_legoBook",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "amount",
                  "type": "uint256"
                },
                {
                  "name": "usdValue",
                  "type": "uint256"
                },
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "legoAddr",
                  "type": "address"
                },
                {
                  "name": "legoDesc",
                  "type": "string"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getRoutesAndSwapInstructionsAmountOut",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_slippage",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple[]",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "minAmountOut",
                  "type": "uint256"
                },
                {
                  "name": "tokenPath",
                  "type": "address[]"
                },
                {
                  "name": "poolPath",
                  "type": "address[]"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getRoutesAndSwapInstructionsAmountOut",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_slippage",
              "type": "uint256"
            },
            {
              "name": "_includeLegoIds",
              "type": "uint256[]"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple[]",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "minAmountOut",
                  "type": "uint256"
                },
                {
                  "name": "tokenPath",
                  "type": "address[]"
                },
                {
                  "name": "poolPath",
                  "type": "address[]"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getRoutesAndSwapInstructionsAmountIn",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountOut",
              "type": "uint256"
            },
            {
              "name": "_amountInAvailable",
              "type": "uint256"
            },
            {
              "name": "_slippage",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple[]",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "minAmountOut",
                  "type": "uint256"
                },
                {
                  "name": "tokenPath",
                  "type": "address[]"
                },
                {
                  "name": "poolPath",
                  "type": "address[]"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getRoutesAndSwapInstructionsAmountIn",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountOut",
              "type": "uint256"
            },
            {
              "name": "_amountInAvailable",
              "type": "uint256"
            },
            {
              "name": "_slippage",
              "type": "uint256"
            },
            {
              "name": "_includeLegoIds",
              "type": "uint256[]"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple[]",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "minAmountOut",
                  "type": "uint256"
                },
                {
                  "name": "tokenPath",
                  "type": "address[]"
                },
                {
                  "name": "poolPath",
                  "type": "address[]"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "prepareSwapInstructionsAmountOut",
          "inputs": [
            {
              "name": "_slippage",
              "type": "uint256"
            },
            {
              "name": "_routes",
              "type": "tuple[]",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "name": "tokenOut",
                  "type": "address"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "amountOut",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple[]",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "minAmountOut",
                  "type": "uint256"
                },
                {
                  "name": "tokenPath",
                  "type": "address[]"
                },
                {
                  "name": "poolPath",
                  "type": "address[]"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getBestSwapRoutesAmountOut",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountIn",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple[]",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "name": "tokenOut",
                  "type": "address"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "amountOut",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getBestSwapRoutesAmountOut",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_includeLegoIds",
              "type": "uint256[]"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple[]",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "name": "tokenOut",
                  "type": "address"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "amountOut",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getBestSwapAmountOutWithRouterPool",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountIn",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "tuple[]",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "name": "tokenOut",
                  "type": "address"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "amountOut",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getBestSwapAmountOutWithRouterPool",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_includeLegoIds",
              "type": "uint256[]"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "tuple[]",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "name": "tokenOut",
                  "type": "address"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "amountOut",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getBestSwapAmountOutSinglePool",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountIn",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "name": "tokenOut",
                  "type": "address"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "amountOut",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getBestSwapAmountOutSinglePool",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_includeLegoIds",
              "type": "uint256[]"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "name": "tokenOut",
                  "type": "address"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "amountOut",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getSwapAmountOutViaRouterPool",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountIn",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "name": "tokenOut",
                  "type": "address"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "amountOut",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getSwapAmountOutViaRouterPool",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_includeLegoIds",
              "type": "uint256[]"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "name": "tokenOut",
                  "type": "address"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "amountOut",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getBestSwapRoutesAmountIn",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountOut",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple[]",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "name": "tokenOut",
                  "type": "address"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "amountOut",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getBestSwapRoutesAmountIn",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountOut",
              "type": "uint256"
            },
            {
              "name": "_includeLegoIds",
              "type": "uint256[]"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple[]",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "name": "tokenOut",
                  "type": "address"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "amountOut",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getBestSwapAmountInWithRouterPool",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountOut",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "tuple[]",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "name": "tokenOut",
                  "type": "address"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "amountOut",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getBestSwapAmountInWithRouterPool",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountOut",
              "type": "uint256"
            },
            {
              "name": "_includeLegoIds",
              "type": "uint256[]"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "tuple[]",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "name": "tokenOut",
                  "type": "address"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "amountOut",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getBestSwapAmountInSinglePool",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountOut",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "name": "tokenOut",
                  "type": "address"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "amountOut",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getBestSwapAmountInSinglePool",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountOut",
              "type": "uint256"
            },
            {
              "name": "_includeLegoIds",
              "type": "uint256[]"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "name": "tokenOut",
                  "type": "address"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "amountOut",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getSwapAmountInViaRouterPool",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountOut",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "name": "tokenOut",
                  "type": "address"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "amountOut",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getSwapAmountInViaRouterPool",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountOut",
              "type": "uint256"
            },
            {
              "name": "_includeLegoIds",
              "type": "uint256[]"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "name": "tokenOut",
                  "type": "address"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "amountOut",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ROUTER_TOKENA",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ROUTER_TOKENB",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "AAVE_V3_ID",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "COMPOUND_V3_ID",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "EULER_ID",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "FLUID_ID",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MOONWELL_ID",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MORPHO_ID",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "UNISWAP_V2_ID",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "UNISWAP_V3_ID",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "AERODROME_ID",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "AERODROME_SLIPSTREAM_ID",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "CURVE_ID",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_undyHq",
              "type": "address"
            },
            {
              "name": "_routerTokenA",
              "type": "address"
            },
            {
              "name": "_routerTokenB",
              "type": "address"
            },
            {
              "name": "_aaveV3Id",
              "type": "uint256"
            },
            {
              "name": "_compoundV3Id",
              "type": "uint256"
            },
            {
              "name": "_eulerId",
              "type": "uint256"
            },
            {
              "name": "_fluidId",
              "type": "uint256"
            },
            {
              "name": "_moonwellId",
              "type": "uint256"
            },
            {
              "name": "_morphoId",
              "type": "uint256"
            },
            {
              "name": "_uniswapV2Id",
              "type": "uint256"
            },
            {
              "name": "_uniswapV3Id",
              "type": "uint256"
            },
            {
              "name": "_aerodromeId",
              "type": "uint256"
            },
            {
              "name": "_aerodromeSlipstreamId",
              "type": "uint256"
            },
            {
              "name": "_curveId",
              "type": "uint256"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "interfaces/WalletStructs.vyi": {
            "content": "# @version 0.4.3\n\nflag ActionType:\n    TRANSFER\n    EARN_DEPOSIT\n    EARN_WITHDRAW\n    EARN_REBALANCE\n    SWAP\n    MINT_REDEEM\n    CONFIRM_MINT_REDEEM\n    ADD_COLLATERAL\n    REMOVE_COLLATERAL\n    BORROW\n    REPAY_DEBT\n    REWARDS\n    ETH_TO_WETH\n    WETH_TO_ETH\n    ADD_LIQ\n    REMOVE_LIQ\n    ADD_LIQ_CONC\n    REMOVE_LIQ_CONC\n    PAY_CHEQUE\n\nstruct WalletAssetData:\n    assetBalance: uint256\n    usdValue: uint256\n    isYieldAsset: bool\n    lastPricePerShare: uint256\n\nstruct ActionData:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    billing: address\n    wallet: address\n    walletConfig: address\n    walletOwner: address\n    inEjectMode: bool\n    isFrozen: bool\n    lastTotalUsdValue: uint256\n    signer: address\n    isManager: bool\n    legoId: uint256\n    legoAddr: address\n    eth: address\n    weth: address\n\nstruct MiniAddys:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    appraiser: address",
            "sha256sum": "9a4b4f59b3a62043e51b425a665064aae419a3c0bd0514b6b29a9441ae364bb9"
          },
          "interfaces/LegoPartner.vyi": {
            "content": "# @version 0.4.3\n\nfrom interfaces import WalletStructs as ws\n\nMAX_TOKEN_PATH: constant(uint256) = 5\nMAX_RECOVER_ASSETS: constant(uint256) = 20\n\n@external\ndef addLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _tickLower: int24, _tickUpper: int24, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef addLiquidity(_pool: address, _tokenA: address, _tokenB: address, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _minLpAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (address, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef removeLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _liqToRemove: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef removeLiquidity(_pool: address, _tokenA: address, _tokenB: address, _lpToken: address, _lpAmount: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef mintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _tokenInAmount: uint256, _minAmountOut: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef swapTokens(_amountIn: uint256, _minAmountOut: uint256, _tokenPath: DynArray[address, MAX_TOKEN_PATH], _poolPath: DynArray[address, MAX_TOKEN_PATH - 1], _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256):\n    ...\n\n@external\ndef depositForYield(_asset: address, _amount: uint256, _vaultAddr: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef withdrawFromYield(_vaultToken: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef confirmMintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef borrow(_borrowAsset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef repayDebt(_paymentAsset: address, _paymentAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef claimRewards(_user: address, _rewardToken: address, _rewardAmount: uint256, _extraData: bytes32, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef removeCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef addCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@view\n@external\ndef getAccessForLego(_user: address, _action: ws.ActionType) -> (address, String[64], uint256):\n    ...\n\n@view\n@external\ndef hasCapability(_action: ws.ActionType) -> bool:\n    ...\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    ...\n\n@view\n@external\ndef isYieldLego() -> bool:\n    ...\n\n@view\n@external\ndef isDexLego() -> bool:\n    ...\n\n@view\n@external\ndef getPricePerShare(_asset: address, _decimals: uint256) -> uint256:\n    ...\n\n@view\n@external\ndef getPrice(_asset: address, _decimals: uint256) -> uint256:\n    ...\n\n\n# common\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "2513e379aa74d0a8120114a5078a4c1a0900165a1c3f24419bb811d173b56453"
          },
          "interfaces/YieldLego.vyi": {
            "content": "# @version 0.4.3\n\n@view\n@external\ndef isRebasing() -> bool:\n    ...\n\n\n@view\n@external\ndef isEligibleForYieldBonus(_asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef isEligibleVaultForTrialFunds(_vaultToken: address, _underlyingAsset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    ...\n\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    ...\n\n\n@view\n@external\ndef isVaultToken(_vaultToken: address) -> bool:\n    ...\n\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> uint256:\n    ...\n\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> (address, uint256, uint256):\n    ...\n\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    ...\n\n\n@external\ndef addAssetOpportunity(_asset: address, _vaultAddr: address):\n    ...\n\n\n@external\ndef removeAssetOpportunity(_asset: address, _vaultAddr: address):\n    ...\n\n\n# YieldLegoData.vy module\n\n\n@view\n@external\ndef assetOpportunities(_asset: address, _index: uint256) -> address:\n    ...\n\n\n@view\n@external\ndef indexOfAssetOpportunity(_asset: address, _vaultAddr: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef numAssetOpportunities(_asset: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef vaultToAsset(_vaultAddr: address) -> address:\n    ...\n\n\n@view\n@external\ndef assets(_index: uint256) -> address:\n    ...\n\n\n@view\n@external\ndef indexOfAsset(_asset: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef numAssets() -> uint256:\n    ...\n\n\n@view\n@external\ndef isLegoAsset(_asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, 40]:\n    ...\n\n\n@view\n@external\ndef getAssets() -> DynArray[address, 20]:\n    ...\n\n\n@view\n@external\ndef isAssetOpportunity(_asset: address, _vaultAddr: address) -> bool:\n    ...\n\n\n@view\n@external\ndef getNumLegoAssets() -> uint256:\n    ...\n",
            "sha256sum": "3337ce5f78b0df6f86d1144b07505512bb1044304f67add97be6c3816b3c0b42"
          },
          "interfaces/DexLego.vyi": {
            "content": "# @version 0.4.3\n\n# used in smart contracts\n\n\n@view\n@external\ndef getLpToken(_pool: address) -> address:\n    ...\n\n\n# helper functions for server\n\n\n@view\n@external\ndef getPoolForLpToken(_lpToken: address) -> address:\n    ...\n\n\n@view\n@external\ndef getSwapAmountOut(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n) -> uint256:\n    ...\n\n\n@view\n@external\ndef getSwapAmountIn(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountOut: uint256,\n) -> uint256:\n    ...\n\n\n@view\n@external\ndef getAddLiqAmountsIn(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _availAmountA: uint256,\n    _availAmountB: uint256,\n) -> (uint256, uint256, uint256):\n    ...\n\n\n@view\n@external\ndef getRemoveLiqAmountsOut(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpAmount: uint256,\n) -> (uint256, uint256):\n    ...\n\n\n@view\n@external\ndef getPriceUnsafe(_pool: address, _targetToken: address, _appraiser: address = empty(address)) -> uint256:\n    ...\n\n\n@view\n@external\ndef getBestSwapAmountOut(_tokenIn: address, _tokenOut: address, _amountIn: uint256) -> (address, uint256):\n    ...\n\n\n@view\n@external\ndef getBestSwapAmountIn(_tokenIn: address, _tokenOut: address, _amountOut: uint256) -> (address, uint256):\n    ...\n\n\n@view\n@external\ndef getCoreRouterPool() -> address:\n    ...\n",
            "sha256sum": "44b192d0249c04d635acb9c758c41ebba7014d9287315bc1f7a7cb2646e69631"
          },
          "interfaces/Department.vyi": {
            "content": "# @version 0.4.3\n\n\n###########\n# Minting #\n###########\n\n\n@view\n@external\ndef canMintUndy() -> bool:\n    # used in UndyHq.vy\n    ...\n\n\n########\n# Undy #\n########\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "53e48da591c4ee36045a8950c9d3a01458456b471b797df536e9a9f54404e721"
          },
          "contracts/modules/Addys.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\ninterface UndyHq:\n    def isValidAddr(_addr: address) -> bool: view\n    def getAddr(_regId: uint256) -> address: view\n    def undyToken() -> address: view\n\ninterface Switchboard:\n    def isSwitchboardAddr(_addr: address) -> bool: view\n\ninterface LegoBook:\n    def isLegoAddr(_addr: address) -> bool: view\n\nstruct Addys:\n    hq: address\n    undyToken: address\n    ledger: address\n    missionControl: address\n    legoBook: address\n    switchboard: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    walletBackpack: address\n    billing: address\n\n# hq\nUNDY_HQ_FOR_ADDYS: immutable(address)\n\n# core addys\nLEDGER_ID: constant(uint256) = 1\nMISSION_CONTROL_ID: constant(uint256) = 2\nLEGO_BOOK_ID: constant(uint256) = 3\nSWITCHBOARD_ID: constant(uint256) = 4\nHATCHERY_ID: constant(uint256) = 5\nLOOT_DISTRIBUTOR_ID: constant(uint256) = 6\nAPPRAISER_ID: constant(uint256) = 7\nWALLET_BACKPACK_ID: constant(uint256) = 8\nBILLING_ID: constant(uint256) = 9\n\n\n@deploy\ndef __init__(_undyHq: address):\n    assert _undyHq != empty(address) # dev: invalid undy hq\n    UNDY_HQ_FOR_ADDYS = _undyHq\n\n\n########\n# Core #\n########\n\n\n@view\n@external\ndef getAddys() -> Addys:\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _getAddys(_addys: Addys = empty(Addys)) -> Addys:\n    if _addys.hq != empty(address):\n        return _addys\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _generateAddys() -> Addys:\n    hq: address = UNDY_HQ_FOR_ADDYS\n    return Addys(\n        hq = hq,\n        undyToken = staticcall UndyHq(hq).undyToken(),\n        ledger = staticcall UndyHq(hq).getAddr(LEDGER_ID),\n        missionControl = staticcall UndyHq(hq).getAddr(MISSION_CONTROL_ID),\n        legoBook = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID),\n        switchboard = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID),\n        hatchery = staticcall UndyHq(hq).getAddr(HATCHERY_ID),\n        lootDistributor = staticcall UndyHq(hq).getAddr(LOOT_DISTRIBUTOR_ID),\n        appraiser = staticcall UndyHq(hq).getAddr(APPRAISER_ID),\n        walletBackpack = staticcall UndyHq(hq).getAddr(WALLET_BACKPACK_ID),\n        billing = staticcall UndyHq(hq).getAddr(BILLING_ID),\n    )\n\n\n##########\n# Tokens #\n##########\n\n\n@view\n@internal\ndef _getUndyToken() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).undyToken()\n\n\n###########\n# Helpers #\n###########\n\n\n# undy hq\n\n\n@view\n@external\ndef getUndyHq() -> address:\n    return self._getUndyHq()\n\n\n@view\n@internal\ndef _getUndyHq() -> address:\n    return UNDY_HQ_FOR_ADDYS\n\n\n# utils\n\n\n@view\n@internal\ndef _isValidUndyAddr(_addr: address, _hq: address = empty(address)) -> bool:\n    hq: address = _hq\n    if _hq == empty(address):\n        hq = UNDY_HQ_FOR_ADDYS\n    \n    # core departments\n    if staticcall UndyHq(hq).isValidAddr(_addr):\n        return True\n\n    # lego book\n    legoBook: address = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID)\n    if legoBook != empty(address) and staticcall LegoBook(legoBook).isLegoAddr(_addr):\n        return True\n\n    # switchboard config\n    switchboard: address = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID)\n    if switchboard != empty(address) and staticcall Switchboard(switchboard).isSwitchboardAddr(_addr):\n        return True\n\n    return False\n\n\n@view\n@internal\ndef _isSwitchboardAddr(_addr: address) -> bool:\n    switchboard: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n    if switchboard == empty(address):\n        return False\n    return staticcall Switchboard(switchboard).isSwitchboardAddr(_addr)\n\n\n@view\n@internal\ndef _isLegoBookAddr(_addr: address) -> bool:\n    legoBook: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n    if legoBook == empty(address):\n        return False\n    return staticcall LegoBook(legoBook).isLegoAddr(_addr)\n\n\n###############\n# Departments #\n###############\n\n\n# ledger\n\n\n@view\n@internal\ndef _getLedgerId() -> uint256:\n    return LEDGER_ID\n\n\n@view\n@internal\ndef _getLedgerAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEDGER_ID)\n\n\n# mission control\n\n\n@view\n@internal\ndef _getMissionControlId() -> uint256:\n    return MISSION_CONTROL_ID\n\n\n@view\n@internal\ndef _getMissionControlAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(MISSION_CONTROL_ID)\n\n\n# lego book\n\n\n@view\n@internal\ndef _getLegoBookId() -> uint256:\n    return LEGO_BOOK_ID\n\n\n@view\n@internal\ndef _getLegoBookAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n\n\n# switchboard\n\n\n@view\n@internal\ndef _getSwitchboardId() -> uint256:\n    return SWITCHBOARD_ID\n\n\n@view\n@internal\ndef _getSwitchboardAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n\n\n# hatchery\n\n\n@view\n@internal\ndef _getHatcheryId() -> uint256:\n    return HATCHERY_ID\n\n\n@view\n@internal\ndef _getHatcheryAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(HATCHERY_ID)\n\n\n# loot distributor\n\n\n@view\n@internal\ndef _getLootDistributorId() -> uint256:\n    return LOOT_DISTRIBUTOR_ID\n\n\n@view\n@internal\ndef _getLootDistributorAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LOOT_DISTRIBUTOR_ID)\n\n\n# appraiser\n\n\n@view\n@internal\ndef _getAppraiserId() -> uint256:\n    return APPRAISER_ID\n\n\n@view\n@internal\ndef _getAppraiserAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(APPRAISER_ID)\n\n\n# wallet backpack\n\n\n@view\n@internal\ndef _getWalletBackpackId() -> uint256:\n    return WALLET_BACKPACK_ID\n\n\n@view\n@internal\ndef _getWalletBackpackAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(WALLET_BACKPACK_ID)\n\n\n# billing\n\n\n@view\n@internal\ndef _getBillingId() -> uint256:\n    return BILLING_ID\n\n\n@view\n@internal\ndef _getBillingAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(BILLING_ID)",
            "sha256sum": "78b58f0b2acb2eaafa4d21adf9135a1cd0e1d53897f7a1fa70a83a04a7738ad3"
          },
          "contracts/modules/DeptBasics.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nuses: addys\nimplements: dept\n\nimport contracts.modules.Addys as addys\nimport interfaces.Department as dept\nfrom ethereum.ercs import IERC20\n\nevent DepartmentPauseModified:\n    isPaused: bool\n\nevent DepartmentFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    balance: uint256\n\nisPaused: public(bool)\n\nCAN_MINT_UNDY: immutable(bool)\nMAX_RECOVER_ASSETS: constant(uint256) = 20\n\n\n@deploy\ndef __init__(_shouldPause: bool, _canMintUndy: bool):\n    self.isPaused = _shouldPause\n    CAN_MINT_UNDY = _canMintUndy\n\n\n###########\n# Minting #\n###########\n\n\n@view\n@external\ndef canMintUndy() -> bool:\n    return CAN_MINT_UNDY\n\n\n########\n# Undy #\n########\n\n\n# activate\n\n\n@external\ndef pause(_shouldPause: bool):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert _shouldPause != self.isPaused # dev: no change\n    self.isPaused = _shouldPause\n    log DepartmentPauseModified(isPaused=_shouldPause)\n\n\n# recover funds\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    self._recoverFunds(_recipient, _asset)\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, MAX_RECOVER_ASSETS]):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    for a: address in _assets:\n        self._recoverFunds(_recipient, a)\n\n\n@internal\ndef _recoverFunds(_recipient: address, _asset: address):\n    assert empty(address) not in [_recipient, _asset] # dev: invalid recipient or asset\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    assert balance != 0 # dev: nothing to recover\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log DepartmentFundsRecovered(asset=_asset, recipient=_recipient, balance=balance)\n",
            "sha256sum": "976a50a3807bcf71f3f1c57de5cd7a59fe4e8f27b4d4560e774073962f44d1ac"
          },
          "contracts/legos/LegoTools.vy": {
            "content": "#     __                   _____         _     \n#    |  |   ___ ___ ___   |_   _|___ ___| |___ \n#    |  |__| -_| . | . |    | | | . | . | |_ -|\n#    |_____|___|_  |___|    |_| |___|___|_|___|\n#              |___|                           \n#\n#     \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n#     \u2551  ** Lego Tools **                         \u2551\n#     \u2551  Tools for interacting with the legos.    \u2551\n#     \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n#\n#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nimplements: Department\n\nexports: addys.__interface__\nexports: deptBasics.__interface__\n\ninitializes: addys\ninitializes: deptBasics[addys := addys]\n\nfrom interfaces import LegoPartner\nfrom interfaces import YieldLego\nfrom interfaces import DexLego\nfrom interfaces import Department\n\nimport contracts.modules.Addys as addys\nimport contracts.modules.DeptBasics as deptBasics\nfrom ethereum.ercs import IERC20\n\ninterface LegoDexNonStandard:\n    def getSwapAmountOut(_pool: address, _tokenIn: address, _tokenOut: address, _amountIn: uint256) -> uint256: nonpayable\n    def getSwapAmountIn(_pool: address, _tokenIn: address, _tokenOut: address, _amountOut: uint256) -> uint256: nonpayable\n    def getBestSwapAmountIn(_tokenIn: address, _tokenOut: address, _amountOut: uint256) -> (address, uint256): nonpayable\n    def getBestSwapAmountOut(_tokenIn: address, _tokenOut: address, _amountIn: uint256) -> (address, uint256): nonpayable\n\ninterface Registry:\n    def getAddrInfo(_regId: uint256) -> AddressInfo: view\n    def isValidRegId(_regId: uint256) -> bool: view\n    def getAddr(_regId: uint256) -> address: view\n    def numAddrs() -> uint256: view\n\ninterface Appraiser:\n    def getUsdValue(_asset: address, _amount: uint256) -> uint256: view\n\nstruct AddressInfo:\n    addr: address\n    version: uint256\n    lastModified: uint256\n    description: String[64]\n\nstruct SwapRoute:\n    legoId: uint256\n    pool: address\n    tokenIn: address\n    tokenOut: address\n    amountIn: uint256\n    amountOut: uint256\n\nstruct SwapInstruction:\n    legoId: uint256\n    amountIn: uint256\n    minAmountOut: uint256\n    tokenPath: DynArray[address, MAX_TOKEN_PATH]\n    poolPath: DynArray[address, MAX_TOKEN_PATH - 1]\n\nstruct UnderlyingData:\n    asset: address\n    amount: uint256\n    usdValue: uint256\n    legoId: uint256\n    legoAddr: address\n    legoDesc: String[64]\n\nstruct VaultTokenInfo:\n    legoId: uint256\n    vaultToken: address\n\n# key router tokens\nROUTER_TOKENA: public(immutable(address))\nROUTER_TOKENB: public(immutable(address))\n\n# yield lego ids\nAAVE_V3_ID: public(immutable(uint256))\nCOMPOUND_V3_ID: public(immutable(uint256))\nEULER_ID: public(immutable(uint256))\nFLUID_ID: public(immutable(uint256))\nMOONWELL_ID: public(immutable(uint256))\nMORPHO_ID: public(immutable(uint256))\n\n# dex lego ids\nUNISWAP_V2_ID: public(immutable(uint256))\nUNISWAP_V3_ID: public(immutable(uint256))\nAERODROME_ID: public(immutable(uint256))\nAERODROME_SLIPSTREAM_ID: public(immutable(uint256))\nCURVE_ID: public(immutable(uint256))\n\nMAX_VAULTS_FOR_USER: constant(uint256) = 50\nMAX_VAULTS: constant(uint256) = 40\nMAX_ROUTES: constant(uint256) = 10\nMAX_TOKEN_PATH: constant(uint256) = 5\nMAX_SWAP_INSTRUCTIONS: constant(uint256) = 5\nMAX_LEGOS: constant(uint256) = 10\nHUNDRED_PERCENT: constant(uint256) = 100_00 # 100%\n\n\n@deploy\ndef __init__(\n    _undyHq: address,\n    _routerTokenA: address,\n    _routerTokenB: address,\n    # yield lego ids\n    _aaveV3Id: uint256,\n    _compoundV3Id: uint256,\n    _eulerId: uint256,\n    _fluidId: uint256,\n    _moonwellId: uint256,\n    _morphoId: uint256,\n    # dex lego ids\n    _uniswapV2Id: uint256,\n    _uniswapV3Id: uint256,\n    _aerodromeId: uint256,\n    _aerodromeSlipstreamId: uint256,\n    _curveId: uint256,\n):\n    addys.__init__(_undyHq)\n    deptBasics.__init__(False, False) # no minting\n\n    assert empty(address) not in [_routerTokenA, _routerTokenB] # dev: invalid address\n    ROUTER_TOKENA = _routerTokenA\n    ROUTER_TOKENB = _routerTokenB\n\n    # yield lego ids\n    legoBook: address = addys._getLegoBookAddr()\n    assert staticcall Registry(legoBook).isValidRegId(_aaveV3Id) # dev: invalid id\n    assert staticcall Registry(legoBook).isValidRegId(_compoundV3Id) # dev: invalid id\n    assert staticcall Registry(legoBook).isValidRegId(_eulerId) # dev: invalid id\n    assert staticcall Registry(legoBook).isValidRegId(_fluidId) # dev: invalid id\n    assert staticcall Registry(legoBook).isValidRegId(_moonwellId) # dev: invalid id\n    assert staticcall Registry(legoBook).isValidRegId(_morphoId) # dev: invalid id\n\n    AAVE_V3_ID = _aaveV3Id\n    COMPOUND_V3_ID = _compoundV3Id\n    EULER_ID = _eulerId\n    FLUID_ID = _fluidId\n    MOONWELL_ID = _moonwellId\n    MORPHO_ID = _morphoId\n\n    # dex lego ids\n    assert staticcall Registry(legoBook).isValidRegId(_uniswapV2Id) # dev: invalid id\n    assert staticcall Registry(legoBook).isValidRegId(_uniswapV3Id) # dev: invalid id\n    assert staticcall Registry(legoBook).isValidRegId(_aerodromeId) # dev: invalid id\n    assert staticcall Registry(legoBook).isValidRegId(_aerodromeSlipstreamId) # dev: invalid id\n    assert staticcall Registry(legoBook).isValidRegId(_curveId) # dev: invalid id\n\n    UNISWAP_V2_ID = _uniswapV2Id\n    UNISWAP_V3_ID = _uniswapV3Id\n    AERODROME_ID = _aerodromeId\n    AERODROME_SLIPSTREAM_ID = _aerodromeSlipstreamId\n    CURVE_ID = _curveId\n\n\n###############\n# Yield Legos #\n###############\n\n\n@view\n@external\ndef aaveV3() -> address:\n    return staticcall Registry(addys._getLegoBookAddr()).getAddr(AAVE_V3_ID)\n\n\n@view\n@external\ndef aaveV3Id() -> uint256:\n    return AAVE_V3_ID\n\n\n@view\n@external\ndef compoundV3() -> address:\n    return staticcall Registry(addys._getLegoBookAddr()).getAddr(COMPOUND_V3_ID)\n\n\n@view\n@external\ndef compoundV3Id() -> uint256:\n    return COMPOUND_V3_ID\n\n\n@view\n@external\ndef euler() -> address:\n    return staticcall Registry(addys._getLegoBookAddr()).getAddr(EULER_ID)\n\n\n@view\n@external\ndef eulerId() -> uint256:\n    return EULER_ID\n\n\n@view\n@external\ndef fluid() -> address:\n    return staticcall Registry(addys._getLegoBookAddr()).getAddr(FLUID_ID)\n\n\n@view\n@external\ndef fluidId() -> uint256:\n    return FLUID_ID\n\n\n@view\n@external\ndef moonwell() -> address:\n    return staticcall Registry(addys._getLegoBookAddr()).getAddr(MOONWELL_ID)\n\n\n@view\n@external\ndef moonwellId() -> uint256:\n    return MOONWELL_ID\n\n\n@view\n@external\ndef morpho() -> address:\n    return staticcall Registry(addys._getLegoBookAddr()).getAddr(MORPHO_ID)\n\n\n@view\n@external\ndef morphoId() -> uint256:\n    return MORPHO_ID\n\n\n#############\n# DEX Legos #\n#############\n\n\n@view\n@external\ndef uniswapV2() -> address:\n    return staticcall Registry(addys._getLegoBookAddr()).getAddr(UNISWAP_V2_ID)\n\n\n@view\n@external\ndef uniswapV2Id() -> uint256:\n    return UNISWAP_V2_ID\n\n\n@view\n@external\ndef uniswapV3() -> address:\n    return staticcall Registry(addys._getLegoBookAddr()).getAddr(UNISWAP_V3_ID)\n\n\n@view\n@external\ndef uniswapV3Id() -> uint256:\n    return UNISWAP_V3_ID\n\n\n@view\n@external\ndef aerodrome() -> address:\n    return staticcall Registry(addys._getLegoBookAddr()).getAddr(AERODROME_ID)\n\n\n@view\n@external\ndef aerodromeId() -> uint256:\n    return AERODROME_ID\n\n\n@view\n@external\ndef aerodromeSlipstream() -> address:\n    return staticcall Registry(addys._getLegoBookAddr()).getAddr(AERODROME_SLIPSTREAM_ID)\n\n\n@view\n@external\ndef aerodromeSlipstreamId() -> uint256:\n    return AERODROME_SLIPSTREAM_ID\n\n\n@view\n@external\ndef curve() -> address:\n    return staticcall Registry(addys._getLegoBookAddr()).getAddr(CURVE_ID)\n\n\n@view\n@external\ndef curveId() -> uint256:\n    return CURVE_ID\n\n\n#################\n# Yield Helpers #\n#################\n\n\n# get underlying asset (given a vault token)\n\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address, _legoBook: address = empty(address)) -> address:\n    if _vaultToken == empty(address):\n        return empty(address)\n\n    legoBook: address = _legoBook\n    if _legoBook == empty(address):\n        legoBook = addys._getLegoBookAddr()\n\n    numLegos: uint256 = staticcall Registry(legoBook).numAddrs()\n    if numLegos == 0:\n        return empty(address)\n\n    for i: uint256 in range(1, numLegos, bound=max_value(uint256)):\n        legoAddr: address = staticcall Registry(legoBook).getAddr(i)\n        if not staticcall LegoPartner(legoAddr).isYieldLego():\n            continue\n\n        asset: address = staticcall YieldLego(legoAddr).getUnderlyingAsset(_vaultToken)\n        if asset != empty(address):\n            return asset\n\n    return empty(address)\n\n\n# get underlying amount (given user and underlying asset)\n\n\n@view\n@external\ndef getUnderlyingForUser(_user: address, _asset: address, _legoBook: address = empty(address)) -> uint256:\n    if empty(address) in [_user, _asset]:\n        return 0\n\n    legoBook: address = _legoBook\n    if _legoBook == empty(address):\n        legoBook = addys._getLegoBookAddr()\n\n    numLegos: uint256 = staticcall Registry(legoBook).numAddrs()\n    if numLegos == 0:\n        return 0\n\n    totalDeposited: uint256 = 0\n    for i: uint256 in range(1, numLegos, bound=max_value(uint256)):\n        legoAddr: address = staticcall Registry(legoBook).getAddr(i)\n        if not staticcall LegoPartner(legoAddr).isYieldLego():\n            continue\n\n        legoVaultTokens: DynArray[address, MAX_VAULTS] = staticcall YieldLego(legoAddr).getAssetOpportunities(_asset)\n        if len(legoVaultTokens) == 0:\n            continue\n\n        for vaultToken: address in legoVaultTokens:\n            if vaultToken == empty(address):\n                continue\n            vaultTokenBal: uint256 = staticcall IERC20(vaultToken).balanceOf(_user)\n            if vaultTokenBal != 0:\n                totalDeposited += staticcall YieldLego(legoAddr).getUnderlyingAmount(vaultToken, vaultTokenBal)\n\n    return totalDeposited\n\n\n# get all vault tokens (given user and underlying asset)\n\n\n@view\n@external\ndef getVaultTokensForUser(_user: address, _asset: address, _legoBook: address = empty(address)) -> DynArray[VaultTokenInfo, MAX_VAULTS_FOR_USER]:\n    if empty(address) in [_user, _asset]:\n        return []\n\n    legoBook: address = _legoBook\n    if _legoBook == empty(address):\n        legoBook = addys._getLegoBookAddr()\n\n    numLegos: uint256 = staticcall Registry(legoBook).numAddrs()\n    if numLegos == 0:\n        return []\n\n    vaultTokens: DynArray[VaultTokenInfo, MAX_VAULTS_FOR_USER] = []\n    for i: uint256 in range(1, numLegos, bound=max_value(uint256)):\n        legoAddr: address = staticcall Registry(legoBook).getAddr(i)\n        if not staticcall LegoPartner(legoAddr).isYieldLego():\n            continue\n\n        legoVaultTokens: DynArray[address, MAX_VAULTS] = staticcall YieldLego(legoAddr).getAssetOpportunities(_asset)\n        if len(legoVaultTokens) == 0:\n            continue\n\n        for vaultToken: address in legoVaultTokens:\n            if vaultToken == empty(address):\n                continue\n            if staticcall IERC20(vaultToken).balanceOf(_user) != 0:\n                vaultTokens.append(VaultTokenInfo(\n                    legoId=i,\n                    vaultToken=vaultToken\n                ))\n\n    return vaultTokens\n\n\n\n# is vault token (given a vault token)\n\n\n@view\n@external\ndef isVaultToken(_vaultToken: address, _legoBook: address = empty(address)) -> bool:\n    if _vaultToken == empty(address):\n        return False\n\n    legoBook: address = _legoBook\n    if _legoBook == empty(address):\n        legoBook = addys._getLegoBookAddr()\n\n    numLegos: uint256 = staticcall Registry(legoBook).numAddrs()\n    if numLegos == 0:\n        return False\n\n    for i: uint256 in range(1, numLegos, bound=max_value(uint256)):\n        legoAddr: address = staticcall Registry(legoBook).getAddr(i)\n        if not staticcall LegoPartner(legoAddr).isYieldLego():\n            continue\n\n        if staticcall YieldLego(legoAddr).isVaultToken(_vaultToken):\n            return True\n\n    return False\n\n\n# get vault token amount (given an underlying asset, underlying amount, and vault token)\n\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address, _legoBook: address = empty(address)) -> uint256:\n    if _assetAmount == 0 or _asset == empty(address) or _vaultToken == empty(address):\n        return 0\n\n    legoBook: address = _legoBook\n    if _legoBook == empty(address):\n        legoBook = addys._getLegoBookAddr()\n\n    numLegos: uint256 = staticcall Registry(legoBook).numAddrs()\n    if numLegos == 0:\n        return 0\n\n    for i: uint256 in range(1, numLegos, bound=max_value(uint256)):\n        legoAddr: address = staticcall Registry(legoBook).getAddr(i)\n        if not staticcall LegoPartner(legoAddr).isYieldLego():\n            continue\n\n        vaultTokenAmount: uint256 = staticcall YieldLego(legoAddr).getVaultTokenAmount(_asset, _assetAmount, _vaultToken)\n        if vaultTokenAmount != 0:\n            return vaultTokenAmount\n\n    return 0\n\n\n# get lego info (given a vault token)\n\n\n@view\n@external\ndef getLegoInfoFromVaultToken(_vaultToken: address, _legoBook: address = empty(address)) -> (uint256, address, String[64]):\n    if _vaultToken == empty(address):\n        return 0, empty(address), \"\"\n\n    legoBook: address = _legoBook\n    if _legoBook == empty(address):\n        legoBook = addys._getLegoBookAddr()\n\n    numLegos: uint256 = staticcall Registry(legoBook).numAddrs()\n    if numLegos == 0:\n        return 0, empty(address), \"\"\n\n    for i: uint256 in range(1, numLegos, bound=max_value(uint256)):\n        legoInfo: AddressInfo = staticcall Registry(legoBook).getAddrInfo(i)\n        if not staticcall LegoPartner(legoInfo.addr).isYieldLego():\n            continue\n\n        if staticcall YieldLego(legoInfo.addr).isVaultToken(_vaultToken):\n            return i, legoInfo.addr, legoInfo.description\n\n    return 0, empty(address), \"\"\n\n\n# get underlying data (given an underlying asset, underlying amount)\n\n\n@view\n@external\ndef getUnderlyingData(_asset: address, _amount: uint256, _legoBook: address = empty(address)) -> UnderlyingData:\n    if _amount == 0 or _asset == empty(address):\n        return empty(UnderlyingData)\n\n    legoBook: address = _legoBook\n    if _legoBook == empty(address):\n        legoBook = addys._getLegoBookAddr()\n\n    numLegos: uint256 = staticcall Registry(legoBook).numAddrs()\n    if numLegos == 0:\n        return empty(UnderlyingData)\n\n    appraiser: address = addys._getAppraiserAddr()\n    for i: uint256 in range(1, numLegos, bound=max_value(uint256)):\n        legoInfo: AddressInfo = staticcall Registry(legoBook).getAddrInfo(i)\n        if not staticcall LegoPartner(legoInfo.addr).isYieldLego():\n            continue\n\n        asset: address = empty(address)\n        underlyingAmount: uint256 = 0\n        usdValue: uint256 = 0\n        asset, underlyingAmount, usdValue = staticcall YieldLego(legoInfo.addr).getUnderlyingData(_asset, _amount, appraiser)\n        if asset != empty(address):\n            return UnderlyingData(\n                asset = asset,\n                amount = underlyingAmount,\n                usdValue = usdValue,\n                legoId = i,\n                legoAddr = legoInfo.addr,\n                legoDesc = legoInfo.description,\n            )\n\n    # fallback to appraiser\n    return UnderlyingData(\n        asset = _asset,\n        amount = _amount,\n        usdValue = staticcall Appraiser(appraiser).getUsdValue(_asset, _amount),\n        legoId = 0,\n        legoAddr = empty(address),\n        legoDesc = \"\",\n    )\n\n\n###############\n# Dex Helpers #\n###############\n\n\n# get routes and swap instructions (amountOut as input)\n\n\n@external\ndef getRoutesAndSwapInstructionsAmountOut(\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n    _slippage: uint256,\n    _includeLegoIds: DynArray[uint256, MAX_LEGOS] = [],\n) -> DynArray[SwapInstruction, MAX_SWAP_INSTRUCTIONS]:\n    routes: DynArray[SwapRoute, MAX_ROUTES] = self._getBestSwapRoutesAmountOut(_tokenIn, _tokenOut, _amountIn, _includeLegoIds)\n    return self._prepareSwapInstructionsAmountOut(_slippage, routes)\n\n\n# get routes and swap instructions (amountIn as input)\n\n\n@external\ndef getRoutesAndSwapInstructionsAmountIn(\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountOut: uint256,\n    _amountInAvailable: uint256,\n    _slippage: uint256,\n    _includeLegoIds: DynArray[uint256, MAX_LEGOS] = [],\n) -> DynArray[SwapInstruction, MAX_SWAP_INSTRUCTIONS]:\n    routes: DynArray[SwapRoute, MAX_ROUTES] = self._getBestSwapRoutesAmountIn(_tokenIn, _tokenOut, _amountOut, _includeLegoIds)\n    if len(routes) == 0:\n        return []\n\n    # let's re-run the routes with amountIn as input (this is more accurate, for example, Aerodrome doesn't have getAmountIn for stable pools\n    amountIn: uint256 = min(_amountInAvailable, routes[0].amountIn)\n    routes = self._getBestSwapRoutesAmountOut(_tokenIn, _tokenOut, amountIn, _includeLegoIds)\n    return self._prepareSwapInstructionsAmountOut(_slippage, routes)\n\n\n########################\n# Dex: Swap Amount Out #\n########################\n\n\n# prepare swap instructions (amountIn as input)\n\n\n@external\ndef prepareSwapInstructionsAmountOut(_slippage: uint256, _routes: DynArray[SwapRoute, MAX_ROUTES]) -> DynArray[SwapInstruction, MAX_SWAP_INSTRUCTIONS]:\n    return self._prepareSwapInstructionsAmountOut(_slippage, _routes)\n\n\n@internal\ndef _prepareSwapInstructionsAmountOut(_slippage: uint256, _routes: DynArray[SwapRoute, MAX_ROUTES]) -> DynArray[SwapInstruction, MAX_SWAP_INSTRUCTIONS]:\n    if len(_routes) == 0:\n        return []\n\n    instructions: DynArray[SwapInstruction, MAX_SWAP_INSTRUCTIONS] = []\n\n    # start with first route\n    prevRoute: SwapRoute = _routes[0]\n    prevInstruction: SwapInstruction = self._createNewInstruction(prevRoute, _slippage)\n\n    # iterate thru swap routes, skip first\n    for i: uint256 in range(1, len(_routes), bound=MAX_ROUTES):\n        newRoute: SwapRoute = _routes[i]\n        assert prevRoute.tokenOut == newRoute.tokenIn # dev: invalid route\n\n        # add to previous instruction\n        if prevRoute.legoId == newRoute.legoId:\n            prevInstruction.minAmountOut = newRoute.amountOut * (HUNDRED_PERCENT - _slippage) // HUNDRED_PERCENT\n            prevInstruction.tokenPath.append(newRoute.tokenOut)\n            prevInstruction.poolPath.append(newRoute.pool)\n\n        # create new instruction\n        else:\n            instructions.append(prevInstruction)\n            prevInstruction = self._createNewInstruction(newRoute, _slippage)\n\n        # set previous item\n        prevRoute = newRoute\n\n    # add last instruction\n    instructions.append(prevInstruction)\n    return instructions\n\n\n@view\n@internal\ndef _createNewInstruction(_route: SwapRoute, _slippage: uint256) -> SwapInstruction:\n    return SwapInstruction(\n        legoId=_route.legoId,\n        amountIn=_route.amountIn,\n        minAmountOut=_route.amountOut * (HUNDRED_PERCENT - _slippage) // HUNDRED_PERCENT,\n        tokenPath=[_route.tokenIn, _route.tokenOut],\n        poolPath=[_route.pool],\n    )\n\n\n# best swap routes (amountIn as input)\n\n\n@external\ndef getBestSwapRoutesAmountOut(\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n    _includeLegoIds: DynArray[uint256, MAX_LEGOS] = [],\n) -> DynArray[SwapRoute, MAX_ROUTES]:\n    return self._getBestSwapRoutesAmountOut(_tokenIn, _tokenOut, _amountIn, _includeLegoIds)\n\n\n@internal\ndef _getBestSwapRoutesAmountOut(\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n    _includeLegoIds: DynArray[uint256, MAX_LEGOS],\n) -> DynArray[SwapRoute, MAX_ROUTES]:\n    if _tokenIn == _tokenOut or _amountIn == 0 or empty(address) in [_tokenIn, _tokenOut]:\n        return []\n\n    bestSwapRoutes: DynArray[SwapRoute, MAX_ROUTES] = []\n\n    # required data\n    legoBook: address = addys._getLegoBookAddr()\n    numLegos: uint256 = staticcall Registry(legoBook).numAddrs()\n    routerTokenA: address = ROUTER_TOKENA\n    routerTokenB: address = ROUTER_TOKENB\n\n    # direct swap route\n    directSwapRoute: SwapRoute = self._getBestSwapAmountOutSinglePool(_tokenIn, _tokenOut, _amountIn, numLegos, legoBook, _includeLegoIds)\n\n    # check with router pools\n    withRouterHopAmountOut: uint256 = 0\n    withHopRoutes: DynArray[SwapRoute, MAX_ROUTES] = []\n    withRouterHopAmountOut, withHopRoutes = self._getBestSwapAmountOutWithRouterPool(routerTokenA, routerTokenB, _tokenIn, _tokenOut, _amountIn, numLegos, legoBook, _includeLegoIds)\n\n    # compare direct swap route with hop routes\n    if directSwapRoute.amountOut > withRouterHopAmountOut:\n        bestSwapRoutes = [directSwapRoute]\n\n    # update router token pool (if possible)\n    elif withRouterHopAmountOut != 0:\n        bestSwapRoutes = withHopRoutes\n\n    return bestSwapRoutes\n\n\n# check various routes via core router pools\n\n\n@external\ndef getBestSwapAmountOutWithRouterPool(\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n    _includeLegoIds: DynArray[uint256, MAX_LEGOS] = [],\n) -> (uint256, DynArray[SwapRoute, MAX_ROUTES]):\n    legoBook: address = addys._getLegoBookAddr()\n    numLegos: uint256 = staticcall Registry(legoBook).numAddrs()\n    return self._getBestSwapAmountOutWithRouterPool(ROUTER_TOKENA, ROUTER_TOKENB, _tokenIn, _tokenOut, _amountIn, numLegos, legoBook, _includeLegoIds)\n\n\n@internal\ndef _getBestSwapAmountOutWithRouterPool(\n    _routerTokenA: address,\n    _routerTokenB: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n    _numLegos: uint256,\n    _legoRegistry: address,\n    _includeLegoIds: DynArray[uint256, MAX_LEGOS],\n) -> (uint256, DynArray[SwapRoute, MAX_ROUTES]):\n\n    # nothing to do, already have router pool to use\n    if self._isRouterPool(_tokenIn, _tokenOut, _routerTokenA, _routerTokenB):\n        return 0, []\n\n    isMultiHop: bool = False\n    finalAmountOut: uint256 = 0\n    bestSwapRoutes: DynArray[SwapRoute, MAX_ROUTES] = []\n    firstRoute: SwapRoute = empty(SwapRoute)\n    secondRoute: SwapRoute = empty(SwapRoute)\n\n    # usdc -> weth -> tokenOut\n    if _tokenIn == _routerTokenA:\n        firstRoute = self._getSwapAmountOutViaRouterPool(_routerTokenA, _routerTokenB, _amountIn, _numLegos, _legoRegistry, _includeLegoIds)\n        secondRoute = self._getBestSwapAmountOutSinglePool(_routerTokenB, _tokenOut, firstRoute.amountOut, _numLegos, _legoRegistry, _includeLegoIds)\n\n    # tokenIn -> weth -> usdc\n    elif _tokenOut == _routerTokenA:\n        firstRoute = self._getBestSwapAmountOutSinglePool(_tokenIn, _routerTokenB, _amountIn, _numLegos, _legoRegistry, _includeLegoIds)\n        secondRoute = self._getSwapAmountOutViaRouterPool(_routerTokenB, _routerTokenA, firstRoute.amountOut, _numLegos, _legoRegistry, _includeLegoIds)\n\n    # weth -> usdc -> tokenOut\n    elif _tokenIn == _routerTokenB:\n        firstRoute = self._getSwapAmountOutViaRouterPool(_routerTokenB, _routerTokenA, _amountIn, _numLegos, _legoRegistry, _includeLegoIds)\n        secondRoute = self._getBestSwapAmountOutSinglePool(_routerTokenA, _tokenOut, firstRoute.amountOut, _numLegos, _legoRegistry, _includeLegoIds)\n\n    # tokenIn -> usdc -> weth\n    elif _tokenOut == _routerTokenB:\n        firstRoute = self._getBestSwapAmountOutSinglePool(_tokenIn, _routerTokenA, _amountIn, _numLegos, _legoRegistry, _includeLegoIds)\n        secondRoute = self._getSwapAmountOutViaRouterPool(_routerTokenA, _routerTokenB, firstRoute.amountOut, _numLegos, _legoRegistry, _includeLegoIds)\n\n    # let's try multi hop routes\n    else:\n        isMultiHop = True\n\n        # router token A as starting point\n        viaRouterTokenAAmountOut: uint256 = 0\n        viaRouterTokenARoutes: DynArray[SwapRoute, MAX_ROUTES] = []\n        viaRouterTokenAAmountOut, viaRouterTokenARoutes = self._checkRouterPoolForMiddleSwapAmountOut(_routerTokenA, _routerTokenB, _tokenIn, _tokenOut, _amountIn, _numLegos, _legoRegistry, _includeLegoIds)\n\n        # router token B as starting point\n        viaRouterTokenBAmountOut: uint256 = 0\n        viaRouterTokenBRoutes: DynArray[SwapRoute, MAX_ROUTES] = []\n        viaRouterTokenBAmountOut, viaRouterTokenBRoutes = self._checkRouterPoolForMiddleSwapAmountOut(_routerTokenB, _routerTokenA, _tokenIn, _tokenOut, _amountIn, _numLegos, _legoRegistry, _includeLegoIds)\n\n        # compare\n        if viaRouterTokenAAmountOut > viaRouterTokenBAmountOut:\n            finalAmountOut = viaRouterTokenAAmountOut\n            bestSwapRoutes = viaRouterTokenARoutes\n        elif viaRouterTokenBAmountOut != 0:\n            finalAmountOut = viaRouterTokenBAmountOut\n            bestSwapRoutes = viaRouterTokenBRoutes\n\n    if not isMultiHop:\n        finalAmountOut = secondRoute.amountOut\n        bestSwapRoutes = [firstRoute, secondRoute]\n\n    return finalAmountOut, bestSwapRoutes\n\n\n@internal\ndef _checkRouterPoolForMiddleSwapAmountOut(\n    _firstRouterTokenHop: address,\n    _secondRouterTokenHop: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n    _numLegos: uint256,\n    _legoRegistry: address,\n    _includeLegoIds: DynArray[uint256, MAX_LEGOS],\n) -> (uint256, DynArray[SwapRoute, MAX_ROUTES]):\n    secondHopToTokenOut: SwapRoute = empty(SwapRoute)\n\n    # tokenIn -> first Router Token\n    tokenInToFirstHop: SwapRoute = self._getBestSwapAmountOutSinglePool(_tokenIn, _firstRouterTokenHop, _amountIn, _numLegos, _legoRegistry, _includeLegoIds)\n    if tokenInToFirstHop.amountOut == 0:\n        return 0, []\n\n    # first Router Token -> tokenOut\n    firstHopToTokenOut: SwapRoute = self._getBestSwapAmountOutSinglePool(_firstRouterTokenHop, _tokenOut, tokenInToFirstHop.amountOut, _numLegos, _legoRegistry, _includeLegoIds)\n\n    # first Router Token -> second Router Token -- this will always happen in router pools (i.e. usdc <-> weth)\n    firstHopToSecondHop: SwapRoute = self._getSwapAmountOutViaRouterPool(_firstRouterTokenHop, _secondRouterTokenHop, tokenInToFirstHop.amountOut, _numLegos, _legoRegistry, _includeLegoIds)\n\n    # second Router Token -> tokenOut\n    if firstHopToSecondHop.amountOut != 0:\n        secondHopToTokenOut = self._getBestSwapAmountOutSinglePool(_secondRouterTokenHop, _tokenOut, firstHopToSecondHop.amountOut, _numLegos, _legoRegistry, _includeLegoIds)\n\n    # compare routes\n    if firstHopToTokenOut.amountOut > secondHopToTokenOut.amountOut:\n        return firstHopToTokenOut.amountOut, [tokenInToFirstHop, firstHopToTokenOut]\n    elif secondHopToTokenOut.amountOut != 0:\n        return secondHopToTokenOut.amountOut, [tokenInToFirstHop, firstHopToSecondHop, secondHopToTokenOut]\n    return 0, []\n\n\n# single pool\n\n\n@external\ndef getBestSwapAmountOutSinglePool(\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n    _includeLegoIds: DynArray[uint256, MAX_LEGOS] = [],\n) -> SwapRoute:\n    legoBook: address = addys._getLegoBookAddr()\n    numLegos: uint256 = staticcall Registry(legoBook).numAddrs()\n    return self._getBestSwapAmountOutSinglePool(_tokenIn, _tokenOut, _amountIn, numLegos, legoBook, _includeLegoIds)\n\n\n@internal\ndef _getBestSwapAmountOutSinglePool(\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n    _numLegos: uint256,\n    _legoRegistry: address,\n    _includeLegoIds: DynArray[uint256, MAX_LEGOS],\n) -> SwapRoute:\n\n    bestRoute: SwapRoute = SwapRoute(\n        legoId=0,\n        pool=empty(address),\n        tokenIn=_tokenIn,\n        tokenOut=_tokenOut,\n        amountIn=_amountIn,\n        amountOut=0,\n    )\n\n    if _numLegos == 0:\n        return bestRoute\n\n    shouldCheckLegoIds: bool = len(_includeLegoIds) != 0\n    for i: uint256 in range(1, _numLegos, bound=max_value(uint256)):\n\n        # skip if we should check lego ids and it's not in the list\n        if shouldCheckLegoIds and i not in _includeLegoIds:\n            continue\n\n        # get lego addr\n        legoAddr: address = staticcall Registry(_legoRegistry).getAddr(i)\n        if not staticcall LegoPartner(legoAddr).isDexLego():\n            continue\n\n        pool: address = empty(address)\n        amountOut: uint256 = 0\n        if i in [UNISWAP_V3_ID, AERODROME_SLIPSTREAM_ID]:\n            pool, amountOut = extcall LegoDexNonStandard(legoAddr).getBestSwapAmountOut(_tokenIn, _tokenOut, _amountIn)\n        else:\n            pool, amountOut = staticcall DexLego(legoAddr).getBestSwapAmountOut(_tokenIn, _tokenOut, _amountIn)\n\n        # compare best\n        if pool != empty(address) and amountOut > bestRoute.amountOut:\n            bestRoute.pool = pool\n            bestRoute.amountOut = amountOut\n            bestRoute.legoId = i\n\n    return bestRoute\n\n\n# router pool only\n\n\n@external\ndef getSwapAmountOutViaRouterPool(\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n    _includeLegoIds: DynArray[uint256, MAX_LEGOS] = [],\n) -> SwapRoute:\n    legoBook: address = addys._getLegoBookAddr()\n    numLegos: uint256 = staticcall Registry(legoBook).numAddrs()\n    return self._getSwapAmountOutViaRouterPool(_tokenIn, _tokenOut, _amountIn, numLegos, legoBook, _includeLegoIds)\n\n\n@internal\ndef _getSwapAmountOutViaRouterPool(\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n    _numLegos: uint256,\n    _legoRegistry: address,\n    _includeLegoIds: DynArray[uint256, MAX_LEGOS],\n) -> SwapRoute:\n\n    # NOTE: _tokenIn and _tokenOut need to be ROUTER_TOKENA/ROUTER_TOKENB -- in the `getCoreRouterPool()` pool\n\n    bestRoute: SwapRoute = SwapRoute(\n        legoId=0,\n        pool=empty(address),\n        tokenIn=_tokenIn,\n        tokenOut=_tokenOut,\n        amountIn=_amountIn,\n        amountOut=0,\n    )\n\n    if _numLegos == 0:\n        return bestRoute\n\n    shouldCheckLegoIds: bool = len(_includeLegoIds) != 0\n    for i: uint256 in range(1, _numLegos, bound=max_value(uint256)):\n\n        # skip if we should check lego ids and it's not in the list\n        if shouldCheckLegoIds and i not in _includeLegoIds:\n            continue\n\n        # get lego addr\n        legoAddr: address = staticcall Registry(_legoRegistry).getAddr(i)\n        if not staticcall LegoPartner(legoAddr).isDexLego():\n            continue\n\n        pool: address = staticcall DexLego(legoAddr).getCoreRouterPool()\n        if pool == empty(address):\n            continue\n\n        amountOut: uint256 = 0\n        if i in [UNISWAP_V3_ID, AERODROME_SLIPSTREAM_ID]:\n            amountOut = extcall LegoDexNonStandard(legoAddr).getSwapAmountOut(pool, _tokenIn, _tokenOut, _amountIn)\n        else:\n            amountOut = staticcall DexLego(legoAddr).getSwapAmountOut(pool, _tokenIn, _tokenOut, _amountIn)\n\n        # compare best\n        if amountOut > bestRoute.amountOut:\n            bestRoute.pool = pool\n            bestRoute.amountOut = amountOut\n            bestRoute.legoId = i\n\n    return bestRoute\n\n\n#######################\n# Dex: Swap Amount In #\n#######################\n\n\n# best swap routes (amountOut as input)\n\n\n@external\ndef getBestSwapRoutesAmountIn(\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountOut: uint256,\n    _includeLegoIds: DynArray[uint256, MAX_LEGOS] = [],\n) -> DynArray[SwapRoute, MAX_ROUTES]:\n    return self._getBestSwapRoutesAmountIn(_tokenIn, _tokenOut, _amountOut, _includeLegoIds)\n\n\n@internal\ndef _getBestSwapRoutesAmountIn(\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountOut: uint256,\n    _includeLegoIds: DynArray[uint256, MAX_LEGOS],\n) -> DynArray[SwapRoute, MAX_ROUTES]:\n    if _tokenIn == _tokenOut or _amountOut == 0 or empty(address) in [_tokenIn, _tokenOut]:\n        return []\n\n    bestSwapRoutes: DynArray[SwapRoute, MAX_ROUTES] = []\n\n    # required data\n    legoBook: address = addys._getLegoBookAddr()\n    numLegos: uint256 = staticcall Registry(legoBook).numAddrs()\n    routerTokenA: address = ROUTER_TOKENA\n    routerTokenB: address = ROUTER_TOKENB\n\n    # direct swap route\n    directSwapRoute: SwapRoute = self._getBestSwapAmountInSinglePool(_tokenIn, _tokenOut, _amountOut, numLegos, legoBook, _includeLegoIds)\n\n    # check with router pools\n    withRouterHopAmountIn: uint256 = 0\n    withHopRoutes: DynArray[SwapRoute, MAX_ROUTES] = []\n    withRouterHopAmountIn, withHopRoutes = self._getBestSwapAmountInWithRouterPool(routerTokenA, routerTokenB, _tokenIn, _tokenOut, _amountOut, numLegos, legoBook, _includeLegoIds)\n\n    # compare direct swap route with hop routes\n    if directSwapRoute.amountIn < withRouterHopAmountIn:\n        bestSwapRoutes = [directSwapRoute]\n\n    # update router token pool (if possible)\n    elif withRouterHopAmountIn != max_value(uint256):\n        bestSwapRoutes = withHopRoutes\n\n    return bestSwapRoutes\n\n\n# check various routes via core router pools\n\n\n@external\ndef getBestSwapAmountInWithRouterPool(\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountOut: uint256,\n    _includeLegoIds: DynArray[uint256, MAX_LEGOS] = [],\n) -> (uint256, DynArray[SwapRoute, MAX_ROUTES]):\n    legoBook: address = addys._getLegoBookAddr()\n    numLegos: uint256 = staticcall Registry(legoBook).numAddrs()\n    return self._getBestSwapAmountInWithRouterPool(ROUTER_TOKENA, ROUTER_TOKENB, _tokenIn, _tokenOut, _amountOut, numLegos, legoBook, _includeLegoIds)\n\n\n@internal\ndef _getBestSwapAmountInWithRouterPool(\n    _routerTokenA: address,\n    _routerTokenB: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountOut: uint256,\n    _numLegos: uint256,\n    _legoRegistry: address,\n    _includeLegoIds: DynArray[uint256, MAX_LEGOS],\n) -> (uint256, DynArray[SwapRoute, MAX_ROUTES]):\n\n    # nothing to do, already have router pool to use\n    if self._isRouterPool(_tokenIn, _tokenOut, _routerTokenA, _routerTokenB):\n        return max_value(uint256), []\n\n    isMultiHop: bool = False\n    finalAmountIn: uint256 = max_value(uint256)\n    bestSwapRoutes: DynArray[SwapRoute, MAX_ROUTES] = []\n    firstRoute: SwapRoute = empty(SwapRoute)\n    secondRoute: SwapRoute = empty(SwapRoute)\n\n    # usdc -> weth -> tokenOut\n    if _tokenIn == _routerTokenA:\n        secondRoute = self._getBestSwapAmountInSinglePool(_routerTokenB, _tokenOut, _amountOut, _numLegos, _legoRegistry, _includeLegoIds)\n        firstRoute = self._getSwapAmountInViaRouterPool(_routerTokenA, _routerTokenB, secondRoute.amountIn, _numLegos, _legoRegistry, _includeLegoIds)\n\n    # tokenIn -> weth -> usdc\n    elif _tokenOut == _routerTokenA:\n        secondRoute = self._getSwapAmountInViaRouterPool(_routerTokenB, _routerTokenA, _amountOut, _numLegos, _legoRegistry, _includeLegoIds)\n        firstRoute = self._getBestSwapAmountInSinglePool(_tokenIn, _routerTokenB, secondRoute.amountIn, _numLegos, _legoRegistry, _includeLegoIds)\n\n    # weth -> usdc -> tokenOut\n    elif _tokenIn == _routerTokenB:\n        secondRoute = self._getBestSwapAmountInSinglePool(_routerTokenA, _tokenOut, _amountOut, _numLegos, _legoRegistry, _includeLegoIds)\n        firstRoute = self._getSwapAmountInViaRouterPool(_routerTokenB, _routerTokenA, secondRoute.amountIn, _numLegos, _legoRegistry, _includeLegoIds)\n\n    # tokenIn -> usdc -> weth\n    elif _tokenOut == _routerTokenB:\n        secondRoute = self._getSwapAmountInViaRouterPool(_routerTokenA, _routerTokenB, _amountOut, _numLegos, _legoRegistry, _includeLegoIds)\n        firstRoute = self._getBestSwapAmountInSinglePool(_tokenIn, _routerTokenA, secondRoute.amountIn, _numLegos, _legoRegistry, _includeLegoIds)\n\n    # let's try multi hop routes\n    else:\n        isMultiHop = True\n\n        # router token A as starting point\n        viaRouterTokenAAmountIn: uint256 = 0\n        viaRouterTokenARoutes: DynArray[SwapRoute, MAX_ROUTES] = []\n        viaRouterTokenAAmountIn, viaRouterTokenARoutes = self._checkRouterPoolForMiddleSwapAmountIn(_routerTokenA, _routerTokenB, _tokenIn, _tokenOut, _amountOut, _numLegos, _legoRegistry, _includeLegoIds)\n\n        # router token B as starting point\n        viaRouterTokenBAmountIn: uint256 = 0\n        viaRouterTokenBRoutes: DynArray[SwapRoute, MAX_ROUTES] = []\n        viaRouterTokenBAmountIn, viaRouterTokenBRoutes = self._checkRouterPoolForMiddleSwapAmountIn(_routerTokenB, _routerTokenA, _tokenIn, _tokenOut, _amountOut, _numLegos, _legoRegistry, _includeLegoIds)\n\n        # compare\n        if viaRouterTokenAAmountIn < viaRouterTokenBAmountIn:\n            finalAmountIn = viaRouterTokenAAmountIn\n            bestSwapRoutes = viaRouterTokenARoutes\n        elif viaRouterTokenBAmountIn != max_value(uint256):\n            finalAmountIn = viaRouterTokenBAmountIn\n            bestSwapRoutes = viaRouterTokenBRoutes\n\n    if not isMultiHop:\n        finalAmountIn = firstRoute.amountIn\n        bestSwapRoutes = [firstRoute, secondRoute]\n\n    return finalAmountIn, bestSwapRoutes\n\n\n@internal\ndef _checkRouterPoolForMiddleSwapAmountIn(\n    _firstRouterToken: address,\n    _secondRouterToken: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountOut: uint256,\n    _numLegos: uint256,\n    _legoRegistry: address,\n    _includeLegoIds: DynArray[uint256, MAX_LEGOS],\n) -> (uint256, DynArray[SwapRoute, MAX_ROUTES]):\n    tokenInToFirstHop: SwapRoute = empty(SwapRoute)\n    tokenInToFirstHop.amountIn = max_value(uint256)\n\n    # second Router Token -> tokenOut\n    secondHopToTokenOut: SwapRoute = self._getBestSwapAmountInSinglePool(_secondRouterToken, _tokenOut, _amountOut, _numLegos, _legoRegistry, _includeLegoIds)\n    if secondHopToTokenOut.amountIn == max_value(uint256):\n        return max_value(uint256), []\n\n    # tokenIn -> second Router Token\n    tokenInToSecondHop: SwapRoute = self._getBestSwapAmountInSinglePool(_tokenIn, _secondRouterToken, secondHopToTokenOut.amountIn, _numLegos, _legoRegistry, _includeLegoIds)\n\n    # first Router Token -> second Router Token -- this will always happen in router pools (i.e. usdc <-> weth)\n    firstHopToSecondHop: SwapRoute = self._getSwapAmountInViaRouterPool(_firstRouterToken, _secondRouterToken, secondHopToTokenOut.amountIn, _numLegos, _legoRegistry, _includeLegoIds)\n\n    # tokenIn -> first Router Token\n    if firstHopToSecondHop.amountIn != max_value(uint256):\n        tokenInToFirstHop = self._getBestSwapAmountInSinglePool(_tokenIn, _firstRouterToken, firstHopToSecondHop.amountIn, _numLegos, _legoRegistry, _includeLegoIds)\n\n    # compare routes\n    if tokenInToSecondHop.amountIn < tokenInToFirstHop.amountIn:\n        return tokenInToSecondHop.amountIn, [tokenInToSecondHop, secondHopToTokenOut]\n    elif tokenInToFirstHop.amountIn != max_value(uint256):\n        return tokenInToFirstHop.amountIn, [tokenInToFirstHop, firstHopToSecondHop, secondHopToTokenOut]\n    return max_value(uint256), []\n\n\n# single pool\n\n\n@external\ndef getBestSwapAmountInSinglePool(\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountOut: uint256,\n    _includeLegoIds: DynArray[uint256, MAX_LEGOS] = [],\n) -> SwapRoute:\n    legoBook: address = addys._getLegoBookAddr()\n    numLegos: uint256 = staticcall Registry(legoBook).numAddrs()\n    return self._getBestSwapAmountInSinglePool(_tokenIn, _tokenOut, _amountOut, numLegos, legoBook, _includeLegoIds)\n\n\n@internal\ndef _getBestSwapAmountInSinglePool(\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountOut: uint256,\n    _numLegos: uint256,\n    _legoRegistry: address,\n    _includeLegoIds: DynArray[uint256, MAX_LEGOS],\n) -> SwapRoute:\n\n    bestRoute: SwapRoute = SwapRoute(\n        legoId=0,\n        pool=empty(address),\n        tokenIn=_tokenIn,\n        tokenOut=_tokenOut,\n        amountIn=max_value(uint256),\n        amountOut=_amountOut,\n    )\n\n    if _numLegos == 0:\n        return bestRoute\n\n    shouldCheckLegoIds: bool = len(_includeLegoIds) != 0\n    for i: uint256 in range(1, _numLegos, bound=max_value(uint256)):\n\n        # skip if we should check lego ids and it's not in the list\n        if shouldCheckLegoIds and i not in _includeLegoIds:\n            continue\n\n        # get lego addr\n        legoAddr: address = staticcall Registry(_legoRegistry).getAddr(i)\n        if not staticcall LegoPartner(legoAddr).isDexLego():\n            continue\n\n        pool: address = empty(address)\n        amountIn: uint256 = max_value(uint256)\n        if i in [UNISWAP_V3_ID, AERODROME_SLIPSTREAM_ID]:\n            pool, amountIn = extcall LegoDexNonStandard(legoAddr).getBestSwapAmountIn(_tokenIn, _tokenOut, _amountOut)\n        else:\n            pool, amountIn = staticcall DexLego(legoAddr).getBestSwapAmountIn(_tokenIn, _tokenOut, _amountOut)\n\n        # compare best\n        if pool != empty(address) and amountIn != 0 and amountIn < bestRoute.amountIn:\n            bestRoute.pool = pool\n            bestRoute.amountIn = amountIn\n            bestRoute.legoId = i\n\n    return bestRoute\n\n\n# router pool only\n\n\n@external\ndef getSwapAmountInViaRouterPool(\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountOut: uint256,\n    _includeLegoIds: DynArray[uint256, MAX_LEGOS] = [],\n) -> SwapRoute:\n    legoBook: address = addys._getLegoBookAddr()\n    numLegos: uint256 = staticcall Registry(legoBook).numAddrs()\n    return self._getSwapAmountInViaRouterPool(_tokenIn, _tokenOut, _amountOut, numLegos, legoBook, _includeLegoIds)\n\n\n@internal\ndef _getSwapAmountInViaRouterPool(\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountOut: uint256,\n    _numLegos: uint256,\n    _legoRegistry: address,\n    _includeLegoIds: DynArray[uint256, MAX_LEGOS],\n) -> SwapRoute:\n\n    # NOTE: _tokenIn and _tokenOut need to be ROUTER_TOKENA/ROUTER_TOKENB -- in the `getCoreRouterPool()` pool\n\n    bestRoute: SwapRoute = SwapRoute(\n        legoId=0,\n        pool=empty(address),\n        tokenIn=_tokenIn,\n        tokenOut=_tokenOut,\n        amountIn=max_value(uint256),\n        amountOut=_amountOut,\n    )\n\n    if _numLegos == 0:\n        return bestRoute\n\n    shouldCheckLegoIds: bool = len(_includeLegoIds) != 0\n    for i: uint256 in range(1, _numLegos, bound=max_value(uint256)):\n\n        # skip if we should check lego ids and it's not in the list\n        if shouldCheckLegoIds and i not in _includeLegoIds:\n            continue\n\n        # get lego addr\n        legoAddr: address = staticcall Registry(_legoRegistry).getAddr(i)\n        if not staticcall LegoPartner(legoAddr).isDexLego():\n            continue\n\n        # get router pool\n        pool: address = staticcall DexLego(legoAddr).getCoreRouterPool()\n        if pool == empty(address):\n            continue\n\n        amountIn: uint256 = max_value(uint256)\n        if i in [UNISWAP_V3_ID, AERODROME_SLIPSTREAM_ID]:\n            amountIn = extcall LegoDexNonStandard(legoAddr).getSwapAmountIn(pool, _tokenIn, _tokenOut, _amountOut)\n        else:\n            amountIn = staticcall DexLego(legoAddr).getSwapAmountIn(pool, _tokenIn, _tokenOut, _amountOut)\n\n        # compare best\n        if amountIn != 0 and amountIn < bestRoute.amountIn:\n            bestRoute.pool = pool\n            bestRoute.amountIn = amountIn\n            bestRoute.legoId = i\n\n    return bestRoute\n\n\n@view\n@internal\ndef _isRouterPool(_tokenIn: address, _tokenOut: address, _routerTokenA: address, _routerTokenB: address) -> bool:\n    return _tokenIn in [_routerTokenA, _routerTokenB] and _tokenOut in [_routerTokenA, _routerTokenB]\n",
            "sha256sum": "40fb094bd8b54395d03906d1ea960e02ca03f392fde6616f1f5f98058115e0a9"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/legos/LegoTools.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.3+commit.bff19ea2",
        "integrity": "d5c9443beb4da08ecbf6b0d595db037f3bb52ae1811535c0ab329068e1c2366c"
      },
      "args": "00000000000000000000000044cf3c4f000dfd76a35d03298049d37be688d6f9000000000000000000000000833589fcd6edb6e08f4c7c32d4f71b54bda029130000000000000000000000004200000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000500000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000007000000000000000000000000000000000000000000000000000000000000000b000000000000000000000000000000000000000000000000000000000000000c00000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000009000000000000000000000000000000000000000000000000000000000000000a",
      "file": "contracts/legos/LegoTools.vy"
    },
    "Switchboard": {
      "address": "0xe52A6790fC8210DE16847f1FaF55A6146c0BfC7e",
      "abi": [
        {
          "name": "GovChangeTimeLockModified",
          "inputs": [
            {
              "name": "prevTimeLock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "newTimeLock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "RegistryTimeLockModified",
          "inputs": [
            {
              "name": "newTimeLock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "prevTimeLock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeStarted",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeConfirmed",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeCancelled",
          "inputs": [
            {
              "name": "cancelledGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovRelinquished",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UndyHqSetupFinished",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "timeLock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "DepartmentPauseModified",
          "inputs": [
            {
              "name": "isPaused",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "DepartmentFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "balance",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "NewAddressPending",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "NewAddressConfirmed",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "regId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "NewAddressCancelled",
          "inputs": [
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddressUpdatePending",
          "inputs": [
            {
              "name": "regId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "newAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "prevAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "version",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddressUpdateConfirmed",
          "inputs": [
            {
              "name": "regId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "newAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "prevAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "version",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddressUpdateCancelled",
          "inputs": [
            {
              "name": "regId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "newAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "prevAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddressDisablePending",
          "inputs": [
            {
              "name": "regId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "version",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddressDisableConfirmed",
          "inputs": [
            {
              "name": "regId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "version",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddressDisableCancelled",
          "inputs": [
            {
              "name": "regId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUndyHqFromGov",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canGovern",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getGovernors",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPendingGovChange",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "startGovernanceChange",
          "inputs": [
            {
              "name": "_newGov",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "relinquishGov",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setGovTimeLock",
          "inputs": [
            {
              "name": "_numBlocks",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidGovTimeLock",
          "inputs": [
            {
              "name": "_newTimeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "minGovChangeTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "maxGovChangeTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "finishUndyHqSetup",
          "inputs": [
            {
              "name": "_newGov",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "finishUndyHqSetup",
          "inputs": [
            {
              "name": "_newGov",
              "type": "address"
            },
            {
              "name": "_timeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "governance",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingGov",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "newGov",
                  "type": "address"
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numGovChanges",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "govChangeTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRegistryDescription",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "string"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidNewAddress",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidAddressUpdate",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            },
            {
              "name": "_newAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidAddressDisable",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setRegistryTimeLock",
          "inputs": [
            {
              "name": "_numBlocks",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidRegistryTimeLock",
          "inputs": [
            {
              "name": "_numBlocks",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setRegistryTimeLockAfterSetup",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setRegistryTimeLockAfterSetup",
          "inputs": [
            {
              "name": "_numBlocks",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "minRegistryTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "maxRegistryTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidAddr",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidRegId",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRegId",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddr",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddrInfo",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "addr",
                  "type": "address"
                },
                {
                  "name": "version",
                  "type": "uint256"
                },
                {
                  "name": "lastModified",
                  "type": "uint256"
                },
                {
                  "name": "description",
                  "type": "string"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddrDescription",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "string"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getNumAddrs",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLastAddr",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLastRegId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "registryChangeTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "addrInfo",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "addr",
                  "type": "address"
                },
                {
                  "name": "version",
                  "type": "uint256"
                },
                {
                  "name": "lastModified",
                  "type": "uint256"
                },
                {
                  "name": "description",
                  "type": "string"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "addrToRegId",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAddrs",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingNewAddr",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "description",
                  "type": "string"
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingAddrUpdate",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "newAddr",
                  "type": "address"
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingAddrDisable",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddys",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "undyToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "hatchery",
                  "type": "address"
                },
                {
                  "name": "lootDistributor",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                },
                {
                  "name": "walletBackpack",
                  "type": "address"
                },
                {
                  "name": "billing",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUndyHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canMintUndy",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pause",
          "inputs": [
            {
              "name": "_shouldPause",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFundsMany",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_assets",
              "type": "address[]"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isPaused",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isSwitchboardAddr",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "startAddNewAddressToRegistry",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            },
            {
              "name": "_description",
              "type": "string"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmNewAddressToRegistry",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelNewAddressToRegistry",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "startAddressUpdateToRegistry",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            },
            {
              "name": "_newAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmAddressUpdateToRegistry",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelAddressUpdateToRegistry",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "startAddressDisableInRegistry",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmAddressDisableInRegistry",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelAddressDisableInRegistry",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setBlacklist",
          "inputs": [
            {
              "name": "_tokenAddr",
              "type": "address"
            },
            {
              "name": "_addr",
              "type": "address"
            },
            {
              "name": "_shouldBlacklist",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_undyHq",
              "type": "address"
            },
            {
              "name": "_minRegistryTimeLock",
              "type": "uint256"
            },
            {
              "name": "_maxRegistryTimeLock",
              "type": "uint256"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/modules/LocalGov.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\ninterface UndyHq:\n    def minGovChangeTimeLock() -> uint256: view\n    def maxGovChangeTimeLock() -> uint256: view\n    def governance() -> address: view\n\nstruct PendingGovernance:\n    newGov: address\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeStarted:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    confirmBlock: uint256\n\nevent GovChangeConfirmed:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeCancelled:\n    cancelledGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovRelinquished:\n    prevGov: indexed(address)\n\nevent GovChangeTimeLockModified:\n    prevTimeLock: uint256\n    newTimeLock: uint256\n\nevent UndyHqSetupFinished:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    timeLock: uint256\n\n# governance\ngovernance: public(address)\npendingGov: public(PendingGovernance)\nnumGovChanges: public(uint256)\n\n# time lock\ngovChangeTimeLock: public(uint256)\n\n# config\nUNDY_HQ_FOR_GOV: immutable(address)\nMIN_GOV_TIME_LOCK: immutable(uint256)\nMAX_GOV_TIME_LOCK: immutable(uint256)\n\n\n@deploy\ndef __init__(\n    _undyHq: address,\n    _initialGov: address,\n    _minTimeLock: uint256,\n    _maxTimeLock: uint256,\n    _initialTimeLock: uint256,\n):\n    UNDY_HQ_FOR_GOV = _undyHq\n    self.governance = _initialGov\n\n    # undy hq\n    if _undyHq == empty(address):\n        assert _initialGov != empty(address) # dev: undy hq must have gov\n\n    # local gov (department, other smart contracts)\n    else:\n        hqGov: address = staticcall UndyHq(_undyHq).governance()\n        assert hqGov != empty(address) # dev: undy hq must have gov\n        assert _initialGov != hqGov # dev: undy hq cannot set same gov\n\n    # time locks\n    minTimeLock: uint256 = _minTimeLock\n    maxTimeLock: uint256 = _maxTimeLock\n    if minTimeLock == 0 or maxTimeLock == 0:\n        assert _undyHq != empty(address) # dev: need undy hq if no time locks\n        minTimeLock = staticcall UndyHq(_undyHq).minGovChangeTimeLock()\n        maxTimeLock = staticcall UndyHq(_undyHq).maxGovChangeTimeLock()\n\n    # set min and max time locks\n    assert minTimeLock < maxTimeLock # dev: invalid time lock\n    assert minTimeLock != 0 and maxTimeLock != max_value(uint256) # dev: invalid time lock\n    MIN_GOV_TIME_LOCK = minTimeLock\n    MAX_GOV_TIME_LOCK = maxTimeLock\n\n    # this contract is top level governance from Undy HQ -- not setting initial time lock during setup\n    if _undyHq == empty(address):\n        return\n\n    # set initial time lock (for local gov)\n    initialTimeLock: uint256 = max(minTimeLock, _initialTimeLock)\n    assert self._setGovTimeLock(initialTimeLock) # dev: invalid time lock\n\n\n@view\n@external\ndef getUndyHqFromGov() -> address:\n    return self._getUndyHqFromGov()\n\n\n@view\n@internal\ndef _getUndyHqFromGov() -> address:\n    return UNDY_HQ_FOR_GOV\n\n\n##############\n# Gov Access #\n##############\n\n\n@view\n@external\ndef canGovern(_addr: address) -> bool:\n    return self._canGovern(_addr)\n\n\n@view\n@internal\ndef _canGovern(_addr: address) -> bool:\n    if _addr == empty(address):\n        return False\n    return _addr in self._getGovernors()\n\n\n@view\n@external\ndef getGovernors() -> DynArray[address, 2]:\n    return self._getGovernors()\n\n\n@view\n@internal\ndef _getGovernors() -> DynArray[address, 2]:\n    governors: DynArray[address, 2] = []\n\n    # local governance\n    localGov: address = self.governance\n    if localGov != empty(address):\n        governors.append(localGov)\n\n    # undy hq governance\n    undyHq: address = UNDY_HQ_FOR_GOV\n    if undyHq == empty(address):\n        return governors\n\n    hqGov: address = staticcall UndyHq(undyHq).governance()\n    if hqGov != empty(address):\n        governors.append(hqGov)\n\n    return governors\n\n\n######################\n# Governance Changes #\n######################\n\n\n@view\n@external\ndef hasPendingGovChange() -> bool:\n    return self.pendingGov.confirmBlock != 0\n\n\n@view\n@internal\ndef _isUndyHq() -> bool:\n    return UNDY_HQ_FOR_GOV == empty(address)\n\n\n# start gov change\n\n\n@external\ndef startGovernanceChange(_newGov: address):\n    governors: DynArray[address, 2] = self._getGovernors()\n    assert msg.sender in governors # dev: no perms\n\n    # validation\n    if _newGov != empty(address):\n        assert _newGov not in governors # dev: invalid _newGov\n        assert _newGov.is_contract # dev: _newGov must be a contract\n    else:\n        assert not self._isUndyHq() # dev: undy hq cannot set 0x0\n\n    confirmBlock: uint256 = block.number + self.govChangeTimeLock\n    self.pendingGov = PendingGovernance(\n        newGov= _newGov,\n        initiatedBlock= block.number,\n        confirmBlock= confirmBlock,\n    )\n    log GovChangeStarted(prevGov=self.governance, newGov=_newGov, confirmBlock=confirmBlock)\n\n\n# confirm gov change\n\n\n@external\ndef confirmGovernanceChange():\n    data: PendingGovernance = self.pendingGov\n    assert data.confirmBlock != 0 and block.number >= data.confirmBlock # dev: time lock not reached\n\n    # check permissions\n    if data.newGov != empty(address):\n        assert msg.sender == data.newGov # dev: only new gov can confirm\n    else:\n        assert self._canGovern(msg.sender) # dev: no perms\n        assert not self._isUndyHq() # dev: undy hq cannot set 0x0\n\n    # set new governance\n    prevGov: address = self.governance\n    self.governance = data.newGov\n    self.numGovChanges += 1\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeConfirmed(prevGov=prevGov, newGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n# cancel gov change\n\n\n@external\ndef cancelGovernanceChange():\n    assert self._canGovern(msg.sender) # dev: no perms\n    data: PendingGovernance = self.pendingGov\n    assert data.confirmBlock != 0 # dev: no pending change\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeCancelled(cancelledGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n# relinquish gov (only for local gov)\n\n\n@external\ndef relinquishGov():\n    assert msg.sender == self.governance # dev: no perms\n    assert not self._isUndyHq() # dev: undy hq cannot relinquish gov\n\n    self.governance = empty(address)\n    self.numGovChanges += 1\n    log GovRelinquished(prevGov=msg.sender)\n\n\n####################\n# Time Lock Config #\n####################\n\n\n# set time lock\n\n\n@external\ndef setGovTimeLock(_numBlocks: uint256) -> bool:\n    assert self._canGovern(msg.sender) # dev: no perms\n    return self._setGovTimeLock(_numBlocks)\n\n\n@internal\ndef _setGovTimeLock(_numBlocks: uint256) -> bool:\n    prevTimeLock: uint256 = self.govChangeTimeLock\n    assert self._isValidGovTimeLock(_numBlocks, prevTimeLock) # dev: invalid time lock\n    self.govChangeTimeLock = _numBlocks\n    log GovChangeTimeLockModified(prevTimeLock=prevTimeLock, newTimeLock=_numBlocks)\n    return True\n\n\n# validation\n\n\n@view\n@external\ndef isValidGovTimeLock(_newTimeLock: uint256) -> bool:\n    return self._isValidGovTimeLock(_newTimeLock, self.govChangeTimeLock)\n\n\n@view\n@internal\ndef _isValidGovTimeLock(_newTimeLock: uint256, _prevTimeLock: uint256) -> bool:\n    if _newTimeLock == _prevTimeLock:\n        return False # no change\n    if self.pendingGov.confirmBlock != 0:\n        return False # cannot change while pending gov change\n    return _newTimeLock >= MIN_GOV_TIME_LOCK and _newTimeLock <= MAX_GOV_TIME_LOCK\n\n\n# utils\n\n\n@view\n@external\ndef minGovChangeTimeLock() -> uint256:\n    return MIN_GOV_TIME_LOCK\n\n\n@view\n@external\ndef maxGovChangeTimeLock() -> uint256:\n    return MAX_GOV_TIME_LOCK\n\n\n#################\n# Undy Hq Setup #\n#################\n\n\n@external\ndef finishUndyHqSetup(_newGov: address, _timeLock: uint256 = 0) -> bool:\n    assert self._isUndyHq() # dev: only undy hq\n    assert msg.sender == self.governance # dev: no perms\n    assert self.numGovChanges == 0 # dev: already changed gov\n\n    # validation\n    assert _newGov != empty(address) and _newGov.is_contract # dev: invalid _newGov\n    prevGov: address = self.governance\n\n    # set new gov\n    self.governance = _newGov\n    self.numGovChanges += 1\n\n    # set time lock\n    timeLock: uint256 = _timeLock\n    if timeLock == 0:\n        timeLock = MIN_GOV_TIME_LOCK\n    assert self._setGovTimeLock(timeLock) # dev: invalid time lock\n\n    log UndyHqSetupFinished(prevGov=prevGov, newGov=_newGov, timeLock=timeLock)\n    return True",
            "sha256sum": "c41aa3e0d0d96b512171813377ea277e2c7da690c3cd9b4662733b3f11f705b0"
          },
          "contracts/modules/AddressRegistry.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nuses: gov\nimport contracts.modules.LocalGov as gov\n\nstruct AddressInfo:\n    addr: address\n    version: uint256\n    lastModified: uint256\n    description: String[64]\n\nstruct PendingNewAddress:\n    description: String[64]\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nstruct PendingAddressUpdate:\n    newAddr: address\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nstruct PendingAddressDisable:\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent NewAddressPending:\n    addr: indexed(address)\n    description: String[64]\n    confirmBlock: uint256\n    registry: String[28]\n\nevent NewAddressConfirmed:\n    addr: indexed(address)\n    regId: uint256\n    description: String[64]\n    registry: String[28]\n\nevent NewAddressCancelled:\n    description: String[64]\n    addr: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n    registry: String[28]\n\nevent AddressUpdatePending:\n    regId: uint256\n    description: String[64]\n    newAddr: indexed(address)\n    prevAddr: indexed(address)\n    version: uint256\n    confirmBlock: uint256\n    registry: String[28]\n\nevent AddressUpdateConfirmed:\n    regId: uint256\n    description: String[64]\n    newAddr: indexed(address)\n    prevAddr: indexed(address)\n    version: uint256\n    registry: String[28]\n\nevent AddressUpdateCancelled:\n    regId: uint256\n    description: String[64]\n    newAddr: indexed(address)\n    prevAddr: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n    registry: String[28]\n\nevent AddressDisablePending:\n    regId: uint256\n    description: String[64]\n    addr: indexed(address)\n    version: uint256\n    confirmBlock: uint256\n    registry: String[28]\n\nevent AddressDisableConfirmed:\n    regId: uint256\n    description: String[64]\n    addr: indexed(address)\n    version: uint256\n    registry: String[28]\n\nevent AddressDisableCancelled:\n    regId: uint256\n    description: String[64]\n    addr: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n    registry: String[28]\n\nevent RegistryTimeLockModified:\n    newTimeLock: uint256\n    prevTimeLock: uint256\n    registry: String[28]\n\n# time lock\nregistryChangeTimeLock: public(uint256)\n\n# core data (address registry)\naddrInfo: public(HashMap[uint256, AddressInfo]) # regId -> address info\naddrToRegId: public(HashMap[address, uint256]) # addr -> regId\nnumAddrs: public(uint256) # number of addrs in registry\n\n# pending changes\npendingNewAddr: public(HashMap[address, PendingNewAddress]) # addr -> pending new addr\npendingAddrUpdate: public(HashMap[uint256, PendingAddressUpdate]) # regId -> pending addr update\npendingAddrDisable: public(HashMap[uint256, PendingAddressDisable]) # regId -> pending addr disable\n\nREGISTRY_STR: immutable(String[28])\nMIN_REG_TIME_LOCK: immutable(uint256)\nMAX_REG_TIME_LOCK: immutable(uint256)\n\n\n@deploy\ndef __init__(\n    _minTimeLock: uint256,\n    _maxTimeLock: uint256,\n    _initialTimeLock: uint256,\n    _registryStr: String[28],\n):\n    REGISTRY_STR = _registryStr\n\n    assert _minTimeLock < _maxTimeLock # dev: invalid time lock\n    assert _minTimeLock != 0 and _maxTimeLock != max_value(uint256) # dev: invalid time lock\n    MIN_REG_TIME_LOCK = _minTimeLock\n    MAX_REG_TIME_LOCK = _maxTimeLock\n\n    # set initial time lock -- this may be zero during inital setup of registry\n    if _initialTimeLock != 0:\n        assert self._setRegistryTimeLock(_initialTimeLock) # dev: invalid time lock\n\n    # start at 1 index\n    self.numAddrs = 1\n\n\n@view\n@external\ndef getRegistryDescription() -> String[28]:\n    return REGISTRY_STR\n\n\n###############\n# New Address #\n###############\n\n\n# register new address\n\n\n@internal\ndef _startAddNewAddressToRegistry(_addr: address, _description: String[64]) -> bool:\n    assert self._isValidNewAddress(_addr) # dev: invalid addy\n\n    confirmBlock: uint256 = block.number + self.registryChangeTimeLock\n    self.pendingNewAddr[_addr] = PendingNewAddress(\n        description=_description,\n        initiatedBlock=block.number,\n        confirmBlock=confirmBlock,\n    )\n\n    log NewAddressPending(addr=_addr, description=_description, confirmBlock=confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n# confirm new address\n\n\n@internal\ndef _confirmNewAddressToRegistry(_addr: address) -> uint256:\n    data: PendingNewAddress = self.pendingNewAddr[_addr]\n    assert data.confirmBlock != 0 and block.number >= data.confirmBlock # dev: time lock not reached\n\n    if not self._isValidNewAddress(_addr):\n        self.pendingNewAddr[_addr] = empty(PendingNewAddress) # clear pending\n        return 0\n\n    # register new addy\n    regId: uint256 = self.numAddrs\n    self.addrToRegId[_addr] = regId\n    self.numAddrs = regId + 1\n    self.addrInfo[regId] = AddressInfo(\n        addr=_addr,\n        version=1,\n        lastModified=block.timestamp,\n        description=data.description,\n    )\n\n    # clear pending\n    self.pendingNewAddr[_addr] = empty(PendingNewAddress)\n\n    log NewAddressConfirmed(addr=_addr, regId=regId, description=data.description, registry=REGISTRY_STR)\n    return regId\n\n\n# cancel new address\n\n\n@internal\ndef _cancelNewAddressToRegistry(_addr: address) -> bool:\n    data: PendingNewAddress = self.pendingNewAddr[_addr]\n    assert data.confirmBlock != 0 # dev: no pending\n\n    self.pendingNewAddr[_addr] = empty(PendingNewAddress)\n    log NewAddressCancelled(description=data.description, addr=_addr, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n# validation\n\n\n@view\n@external\ndef isValidNewAddress(_addr: address) -> bool:\n    return self._isValidNewAddress(_addr)\n\n\n@view\n@internal\ndef _isValidNewAddress(_addr: address) -> bool:\n    if _addr == empty(address) or not _addr.is_contract:\n        return False\n    return self.addrToRegId[_addr] == 0\n\n\n###################\n# Address Updates #\n###################\n\n\n# update address\n\n\n@internal\ndef _startAddressUpdateToRegistry(_regId: uint256, _newAddr: address) -> bool:\n    data: AddressInfo = self.addrInfo[_regId]\n    assert self._isValidAddressUpdate(_regId, _newAddr, data.addr) # dev: invalid update\n\n    # set pending\n    confirmBlock: uint256 = block.number + self.registryChangeTimeLock\n    self.pendingAddrUpdate[_regId] = PendingAddressUpdate(\n        newAddr=_newAddr,\n        initiatedBlock=block.number,\n        confirmBlock=confirmBlock,\n    )\n\n    log AddressUpdatePending(regId=_regId, description=data.description, newAddr=_newAddr, prevAddr=data.addr, version=data.version, confirmBlock=confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n# confirm update address\n\n\n@internal\ndef _confirmAddressUpdateToRegistry(_regId: uint256) -> bool:\n    newData: PendingAddressUpdate = self.pendingAddrUpdate[_regId]\n    assert newData.confirmBlock != 0 and block.number >= newData.confirmBlock # dev: time lock not reached\n\n    data: AddressInfo = self.addrInfo[_regId]\n    prevAddr: address = data.addr # needed for later\n    if not self._isValidAddressUpdate(_regId, newData.newAddr, prevAddr):\n        self.pendingAddrUpdate[_regId] = empty(PendingAddressUpdate) # clear pending\n        return False\n\n    # update addy data\n    data.addr = newData.newAddr\n    data.lastModified = block.timestamp\n    data.version += 1\n    self.addrInfo[_regId] = data\n    self.addrToRegId[newData.newAddr] = _regId\n\n    # handle previous addr\n    if prevAddr != empty(address):\n        self.addrToRegId[prevAddr] = 0\n\n    # clear pending\n    self.pendingAddrUpdate[_regId] = empty(PendingAddressUpdate)\n\n    log AddressUpdateConfirmed(regId=_regId, description=data.description, newAddr=newData.newAddr, prevAddr=prevAddr, version=data.version, registry=REGISTRY_STR)\n    return True\n\n\n# cancel update address\n\n\n@internal\ndef _cancelAddressUpdateToRegistry(_regId: uint256) -> bool:\n    data: PendingAddressUpdate = self.pendingAddrUpdate[_regId]\n    assert data.confirmBlock != 0 # dev: no pending\n\n    self.pendingAddrUpdate[_regId] = empty(PendingAddressUpdate)\n    prevData: AddressInfo = self.addrInfo[_regId]\n    log AddressUpdateCancelled(regId=_regId, description=prevData.description, newAddr=data.newAddr, prevAddr=prevData.addr, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n# validation\n\n\n@view\n@external\ndef isValidAddressUpdate(_regId: uint256, _newAddr: address) -> bool:\n    return self._isValidAddressUpdate(_regId, _newAddr, self.addrInfo[_regId].addr)\n\n\n@view\n@internal\ndef _isValidAddressUpdate(_regId: uint256, _newAddr: address, _prevAddr: address) -> bool:\n    if not self._isValidRegId(_regId):\n        return False\n    if not self._isValidNewAddress(_newAddr):\n        return False\n    return _newAddr != _prevAddr\n\n\n###################\n# Disable Address #\n###################\n\n\n# start disable address\n\n\n@internal\ndef _startAddressDisableInRegistry(_regId: uint256) -> bool:\n    data: AddressInfo = self.addrInfo[_regId]\n    assert self._isValidAddressDisable(_regId, data.addr) # dev: invalid disable\n\n    # set pending\n    confirmBlock: uint256 = block.number + self.registryChangeTimeLock\n    self.pendingAddrDisable[_regId] = PendingAddressDisable(\n        initiatedBlock=block.number,\n        confirmBlock=confirmBlock,\n    )\n\n    log AddressDisablePending(regId=_regId, description=data.description, addr=data.addr, version=data.version, confirmBlock=confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n# confirm disable address\n\n\n@internal\ndef _confirmAddressDisableInRegistry(_regId: uint256) -> bool:\n    newData: PendingAddressDisable = self.pendingAddrDisable[_regId]\n    assert newData.confirmBlock != 0 and block.number >= newData.confirmBlock # dev: time lock not reached\n\n    data: AddressInfo = self.addrInfo[_regId]\n    prevAddr: address = data.addr # needed for later\n    if not self._isValidAddressDisable(_regId, prevAddr):\n        self.pendingAddrDisable[_regId] = empty(PendingAddressDisable) # clear pending\n        return False\n\n    # disable addy\n    data.addr = empty(address)\n    data.lastModified = block.timestamp\n    data.version += 1\n    self.addrInfo[_regId] = data\n    self.addrToRegId[prevAddr] = 0\n\n    # clear pending\n    self.pendingAddrDisable[_regId] = empty(PendingAddressDisable)\n\n    log AddressDisableConfirmed(regId=_regId, description=data.description, addr=prevAddr, version=data.version, registry=REGISTRY_STR)\n    return True\n\n\n# cancel disable address\n\n\n@internal\ndef _cancelAddressDisableInRegistry(_regId: uint256) -> bool:\n    data: PendingAddressDisable = self.pendingAddrDisable[_regId]\n    assert data.confirmBlock != 0 # dev: no pending\n\n    self.pendingAddrDisable[_regId] = empty(PendingAddressDisable)\n    prevData: AddressInfo = self.addrInfo[_regId]\n    log AddressDisableCancelled(regId=_regId, description=prevData.description, addr=prevData.addr, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n# validation\n\n\n@view\n@external\ndef isValidAddressDisable(_regId: uint256) -> bool:\n    return self._isValidAddressDisable(_regId, self.addrInfo[_regId].addr)\n\n\n@view\n@internal\ndef _isValidAddressDisable(_regId: uint256, _prevAddr: address) -> bool:\n    if not self._isValidRegId(_regId):\n        return False\n    return _prevAddr != empty(address)\n\n\n####################\n# Time Lock Config #\n####################\n\n\n@external\ndef setRegistryTimeLock(_numBlocks: uint256) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return self._setRegistryTimeLock(_numBlocks)\n\n\n@internal\ndef _setRegistryTimeLock(_numBlocks: uint256) -> bool:\n    prevTimeLock: uint256 = self.registryChangeTimeLock\n    assert self._isValidRegistryTimeLock(_numBlocks, prevTimeLock) # dev: invalid time lock\n    self.registryChangeTimeLock = _numBlocks\n    log RegistryTimeLockModified(newTimeLock=_numBlocks, prevTimeLock=prevTimeLock, registry=REGISTRY_STR)\n    return True\n\n\n# validation\n\n\n@view\n@external\ndef isValidRegistryTimeLock(_numBlocks: uint256) -> bool:\n    return self._isValidRegistryTimeLock(_numBlocks, self.registryChangeTimeLock)\n\n\n@view\n@internal\ndef _isValidRegistryTimeLock(_newTimeLock: uint256, _prevTimeLock: uint256) -> bool:\n    if _newTimeLock == _prevTimeLock:\n        return False\n    return _newTimeLock >= MIN_REG_TIME_LOCK and _newTimeLock <= MAX_REG_TIME_LOCK\n\n\n# finish setup\n\n\n@external\ndef setRegistryTimeLockAfterSetup(_numBlocks: uint256 = 0) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert self.registryChangeTimeLock == 0 # dev: already set\n\n    timeLock: uint256 = _numBlocks\n    if timeLock == 0:\n        timeLock = MIN_REG_TIME_LOCK\n    return self._setRegistryTimeLock(timeLock)\n\n\n# utils\n\n\n@view\n@external\ndef minRegistryTimeLock() -> uint256:\n    return MIN_REG_TIME_LOCK\n\n\n@view\n@external\ndef maxRegistryTimeLock() -> uint256:\n    return MAX_REG_TIME_LOCK\n\n\n#################\n# Views / Utils #\n#################\n\n\n# is valid addr\n\n\n@view\n@external\ndef isValidAddr(_addr: address) -> bool:\n    return self._isValidAddr(_addr)\n\n\n@view\n@internal\ndef _isValidAddr(_addr: address) -> bool:\n    return self.addrToRegId[_addr] != 0\n\n\n# is valid addr id\n\n\n@view\n@external\ndef isValidRegId(_regId: uint256) -> bool:\n    return self._isValidRegId(_regId)\n\n\n@view\n@internal\ndef _isValidRegId(_regId: uint256) -> bool:\n    return _regId != 0 and _regId < self.numAddrs\n\n\n# get reg id\n\n\n@view\n@external\ndef getRegId(_addr: address) -> uint256:\n    return self._getRegId(_addr)\n\n\n@view\n@internal\ndef _getRegId(_addr: address) -> uint256:\n    return self.addrToRegId[_addr]\n\n\n# get addr\n\n\n@view\n@external\ndef getAddr(_regId: uint256) -> address:\n    return self._getAddr(_regId)\n\n\n@view\n@internal\ndef _getAddr(_regId: uint256) -> address:\n    return self.addrInfo[_regId].addr\n\n\n# get addr info\n\n\n@view\n@external\ndef getAddrInfo(_regId: uint256) -> AddressInfo:\n    return self._getAddrInfo(_regId)\n\n\n@view\n@internal\ndef _getAddrInfo(_regId: uint256) -> AddressInfo:\n    return self.addrInfo[_regId]\n\n\n# get addr description\n\n\n@view\n@external\ndef getAddrDescription(_regId: uint256) -> String[64]:\n    return self._getAddrDescription(_regId)\n\n\n@view\n@internal\ndef _getAddrDescription(_regId: uint256) -> String[64]:\n    return self.addrInfo[_regId].description\n\n\n# get num addrs\n\n\n@view\n@external\ndef getNumAddrs() -> uint256:\n    return self._getNumAddrs()\n\n\n@view\n@internal\ndef _getNumAddrs() -> uint256:\n    return self.numAddrs - 1\n\n\n# get last addr\n\n\n@view\n@external\ndef getLastAddr() -> address:\n    return self._getLastAddr()\n\n\n@view\n@internal\ndef _getLastAddr() -> address:\n    lastRegId: uint256 = self.numAddrs - 1\n    return self.addrInfo[lastRegId].addr\n\n\n# get last reg id\n\n\n@view\n@external\ndef getLastRegId() -> uint256:\n    return self._getLastRegId()\n\n\n@view\n@internal\ndef _getLastRegId() -> uint256:\n    return self.numAddrs - 1\n",
            "sha256sum": "b88f6fc85ae3cd815c5a476c620b2fb5494b4dec5f1ce738878eded11c46396b"
          },
          "contracts/modules/Addys.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\ninterface UndyHq:\n    def isValidAddr(_addr: address) -> bool: view\n    def getAddr(_regId: uint256) -> address: view\n    def undyToken() -> address: view\n\ninterface Switchboard:\n    def isSwitchboardAddr(_addr: address) -> bool: view\n\ninterface LegoBook:\n    def isLegoAddr(_addr: address) -> bool: view\n\nstruct Addys:\n    hq: address\n    undyToken: address\n    ledger: address\n    missionControl: address\n    legoBook: address\n    switchboard: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    walletBackpack: address\n    billing: address\n\n# hq\nUNDY_HQ_FOR_ADDYS: immutable(address)\n\n# core addys\nLEDGER_ID: constant(uint256) = 1\nMISSION_CONTROL_ID: constant(uint256) = 2\nLEGO_BOOK_ID: constant(uint256) = 3\nSWITCHBOARD_ID: constant(uint256) = 4\nHATCHERY_ID: constant(uint256) = 5\nLOOT_DISTRIBUTOR_ID: constant(uint256) = 6\nAPPRAISER_ID: constant(uint256) = 7\nWALLET_BACKPACK_ID: constant(uint256) = 8\nBILLING_ID: constant(uint256) = 9\n\n\n@deploy\ndef __init__(_undyHq: address):\n    assert _undyHq != empty(address) # dev: invalid undy hq\n    UNDY_HQ_FOR_ADDYS = _undyHq\n\n\n########\n# Core #\n########\n\n\n@view\n@external\ndef getAddys() -> Addys:\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _getAddys(_addys: Addys = empty(Addys)) -> Addys:\n    if _addys.hq != empty(address):\n        return _addys\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _generateAddys() -> Addys:\n    hq: address = UNDY_HQ_FOR_ADDYS\n    return Addys(\n        hq = hq,\n        undyToken = staticcall UndyHq(hq).undyToken(),\n        ledger = staticcall UndyHq(hq).getAddr(LEDGER_ID),\n        missionControl = staticcall UndyHq(hq).getAddr(MISSION_CONTROL_ID),\n        legoBook = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID),\n        switchboard = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID),\n        hatchery = staticcall UndyHq(hq).getAddr(HATCHERY_ID),\n        lootDistributor = staticcall UndyHq(hq).getAddr(LOOT_DISTRIBUTOR_ID),\n        appraiser = staticcall UndyHq(hq).getAddr(APPRAISER_ID),\n        walletBackpack = staticcall UndyHq(hq).getAddr(WALLET_BACKPACK_ID),\n        billing = staticcall UndyHq(hq).getAddr(BILLING_ID),\n    )\n\n\n##########\n# Tokens #\n##########\n\n\n@view\n@internal\ndef _getUndyToken() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).undyToken()\n\n\n###########\n# Helpers #\n###########\n\n\n# undy hq\n\n\n@view\n@external\ndef getUndyHq() -> address:\n    return self._getUndyHq()\n\n\n@view\n@internal\ndef _getUndyHq() -> address:\n    return UNDY_HQ_FOR_ADDYS\n\n\n# utils\n\n\n@view\n@internal\ndef _isValidUndyAddr(_addr: address, _hq: address = empty(address)) -> bool:\n    hq: address = _hq\n    if _hq == empty(address):\n        hq = UNDY_HQ_FOR_ADDYS\n    \n    # core departments\n    if staticcall UndyHq(hq).isValidAddr(_addr):\n        return True\n\n    # lego book\n    legoBook: address = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID)\n    if legoBook != empty(address) and staticcall LegoBook(legoBook).isLegoAddr(_addr):\n        return True\n\n    # switchboard config\n    switchboard: address = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID)\n    if switchboard != empty(address) and staticcall Switchboard(switchboard).isSwitchboardAddr(_addr):\n        return True\n\n    return False\n\n\n@view\n@internal\ndef _isSwitchboardAddr(_addr: address) -> bool:\n    switchboard: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n    if switchboard == empty(address):\n        return False\n    return staticcall Switchboard(switchboard).isSwitchboardAddr(_addr)\n\n\n@view\n@internal\ndef _isLegoBookAddr(_addr: address) -> bool:\n    legoBook: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n    if legoBook == empty(address):\n        return False\n    return staticcall LegoBook(legoBook).isLegoAddr(_addr)\n\n\n###############\n# Departments #\n###############\n\n\n# ledger\n\n\n@view\n@internal\ndef _getLedgerId() -> uint256:\n    return LEDGER_ID\n\n\n@view\n@internal\ndef _getLedgerAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEDGER_ID)\n\n\n# mission control\n\n\n@view\n@internal\ndef _getMissionControlId() -> uint256:\n    return MISSION_CONTROL_ID\n\n\n@view\n@internal\ndef _getMissionControlAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(MISSION_CONTROL_ID)\n\n\n# lego book\n\n\n@view\n@internal\ndef _getLegoBookId() -> uint256:\n    return LEGO_BOOK_ID\n\n\n@view\n@internal\ndef _getLegoBookAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n\n\n# switchboard\n\n\n@view\n@internal\ndef _getSwitchboardId() -> uint256:\n    return SWITCHBOARD_ID\n\n\n@view\n@internal\ndef _getSwitchboardAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n\n\n# hatchery\n\n\n@view\n@internal\ndef _getHatcheryId() -> uint256:\n    return HATCHERY_ID\n\n\n@view\n@internal\ndef _getHatcheryAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(HATCHERY_ID)\n\n\n# loot distributor\n\n\n@view\n@internal\ndef _getLootDistributorId() -> uint256:\n    return LOOT_DISTRIBUTOR_ID\n\n\n@view\n@internal\ndef _getLootDistributorAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LOOT_DISTRIBUTOR_ID)\n\n\n# appraiser\n\n\n@view\n@internal\ndef _getAppraiserId() -> uint256:\n    return APPRAISER_ID\n\n\n@view\n@internal\ndef _getAppraiserAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(APPRAISER_ID)\n\n\n# wallet backpack\n\n\n@view\n@internal\ndef _getWalletBackpackId() -> uint256:\n    return WALLET_BACKPACK_ID\n\n\n@view\n@internal\ndef _getWalletBackpackAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(WALLET_BACKPACK_ID)\n\n\n# billing\n\n\n@view\n@internal\ndef _getBillingId() -> uint256:\n    return BILLING_ID\n\n\n@view\n@internal\ndef _getBillingAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(BILLING_ID)",
            "sha256sum": "78b58f0b2acb2eaafa4d21adf9135a1cd0e1d53897f7a1fa70a83a04a7738ad3"
          },
          "interfaces/Department.vyi": {
            "content": "# @version 0.4.3\n\n\n###########\n# Minting #\n###########\n\n\n@view\n@external\ndef canMintUndy() -> bool:\n    # used in UndyHq.vy\n    ...\n\n\n########\n# Undy #\n########\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "53e48da591c4ee36045a8950c9d3a01458456b471b797df536e9a9f54404e721"
          },
          "contracts/modules/DeptBasics.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nuses: addys\nimplements: dept\n\nimport contracts.modules.Addys as addys\nimport interfaces.Department as dept\nfrom ethereum.ercs import IERC20\n\nevent DepartmentPauseModified:\n    isPaused: bool\n\nevent DepartmentFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    balance: uint256\n\nisPaused: public(bool)\n\nCAN_MINT_UNDY: immutable(bool)\nMAX_RECOVER_ASSETS: constant(uint256) = 20\n\n\n@deploy\ndef __init__(_shouldPause: bool, _canMintUndy: bool):\n    self.isPaused = _shouldPause\n    CAN_MINT_UNDY = _canMintUndy\n\n\n###########\n# Minting #\n###########\n\n\n@view\n@external\ndef canMintUndy() -> bool:\n    return CAN_MINT_UNDY\n\n\n########\n# Undy #\n########\n\n\n# activate\n\n\n@external\ndef pause(_shouldPause: bool):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert _shouldPause != self.isPaused # dev: no change\n    self.isPaused = _shouldPause\n    log DepartmentPauseModified(isPaused=_shouldPause)\n\n\n# recover funds\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    self._recoverFunds(_recipient, _asset)\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, MAX_RECOVER_ASSETS]):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    for a: address in _assets:\n        self._recoverFunds(_recipient, a)\n\n\n@internal\ndef _recoverFunds(_recipient: address, _asset: address):\n    assert empty(address) not in [_recipient, _asset] # dev: invalid recipient or asset\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    assert balance != 0 # dev: nothing to recover\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log DepartmentFundsRecovered(asset=_asset, recipient=_recipient, balance=balance)\n",
            "sha256sum": "976a50a3807bcf71f3f1c57de5cd7a59fe4e8f27b4d4560e774073962f44d1ac"
          },
          "contracts/registries/Switchboard.vy": {
            "content": "#      _____              _  _           _      _                              _ \n#     (_____)            (_)(_)_        (_)    (_)                   _        (_)\n#    (_)___    _   _   _  _ (___)   ___ (_)__  (_)_     ___    ____ (_)__   __(_)\n#      (___)_ (_) ( ) (_)(_)(_)   _(___)(____) (___)_  (___)  (____)(____) (____)\n#      ____(_)(_)_(_)_(_)(_)(_)_ (_)___ (_) (_)(_)_(_)(_)_(_)( )_( )(_)   (_)_(_)\n#     (_____)  (__) (__) (_) (__) (____)(_) (_)(____)  (___)  (__)_)(_)    (____)\n#                                                                                                                                                       \n#     \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n#     \u2551  ** Switchboard **                                 \u2551\n#     \u2551  Registry for all configuration-related contracts  \u2551\n#     \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n#\n#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nimplements: Department\n\nexports: gov.__interface__\nexports: registry.__interface__\nexports: addys.__interface__\nexports: deptBasics.__interface__\n\ninitializes: gov\ninitializes: registry[gov := gov]\ninitializes: addys\ninitializes: deptBasics[addys := addys]\n\nimport contracts.modules.LocalGov as gov\nimport contracts.modules.AddressRegistry as registry\nimport contracts.modules.Addys as addys\nimport contracts.modules.DeptBasics as deptBasics\n\nfrom interfaces import Department\n\ninterface TokenContract:\n    def setBlacklist(_addr: address, _shouldBlacklist: bool) -> bool: nonpayable\n\n\n@deploy\ndef __init__(\n    _undyHq: address,\n    _minRegistryTimeLock: uint256,\n    _maxRegistryTimeLock: uint256,\n):\n    gov.__init__(_undyHq, empty(address), 0, 0, 0)\n    registry.__init__(_minRegistryTimeLock, _maxRegistryTimeLock, 0, \"Switchboard.vy\")\n    addys.__init__(_undyHq)\n    deptBasics.__init__(False, False) # no minting\n\n\n@view\n@external\ndef isSwitchboardAddr(_addr: address) -> bool:\n    return registry._isValidAddr(_addr)\n\n\n############\n# Registry #\n############\n\n\n# new address\n\n\n@external\ndef startAddNewAddressToRegistry(_addr: address, _description: String[64]) -> bool:\n    assert self._canPerformAction(msg.sender) # dev: no perms\n    return registry._startAddNewAddressToRegistry(_addr, _description)\n\n\n@external\ndef confirmNewAddressToRegistry(_addr: address) -> uint256:\n    assert self._canPerformAction(msg.sender) # dev: no perms\n    return registry._confirmNewAddressToRegistry(_addr)\n\n\n@external\ndef cancelNewAddressToRegistry(_addr: address) -> bool:\n    assert self._canPerformAction(msg.sender) # dev: no perms\n    return registry._cancelNewAddressToRegistry(_addr)\n\n\n# address update\n\n\n@external\ndef startAddressUpdateToRegistry(_regId: uint256, _newAddr: address) -> bool:\n    assert self._canPerformAction(msg.sender) # dev: no perms\n    return registry._startAddressUpdateToRegistry(_regId, _newAddr)\n\n\n@external\ndef confirmAddressUpdateToRegistry(_regId: uint256) -> bool:\n    assert self._canPerformAction(msg.sender) # dev: no perms\n    return registry._confirmAddressUpdateToRegistry(_regId)\n\n\n@external\ndef cancelAddressUpdateToRegistry(_regId: uint256) -> bool:\n    assert self._canPerformAction(msg.sender) # dev: no perms\n    return registry._cancelAddressUpdateToRegistry(_regId)\n\n\n# address disable\n\n\n@external\ndef startAddressDisableInRegistry(_regId: uint256) -> bool:\n    assert self._canPerformAction(msg.sender) # dev: no perms\n    return registry._startAddressDisableInRegistry(_regId)\n\n\n@external\ndef confirmAddressDisableInRegistry(_regId: uint256) -> bool:\n    assert self._canPerformAction(msg.sender) # dev: no perms\n    return registry._confirmAddressDisableInRegistry(_regId)\n\n\n@external\ndef cancelAddressDisableInRegistry(_regId: uint256) -> bool:\n    assert self._canPerformAction(msg.sender) # dev: no perms\n    return registry._cancelAddressDisableInRegistry(_regId)\n\n\n#############\n# Blacklist #\n#############\n\n\n# pass thru from specific switchboard contract\n\n\n@external\ndef setBlacklist(_tokenAddr: address, _addr: address, _shouldBlacklist: bool) -> bool:\n    assert registry._isValidAddr(msg.sender) # dev: no perms\n    extcall TokenContract(_tokenAddr).setBlacklist(_addr, _shouldBlacklist)\n    return True\n\n\n#############\n# Utilities #\n#############\n\n\n@view\n@internal\ndef _canPerformAction(_caller: address) -> bool:\n    return gov._canGovern(_caller) and not deptBasics.isPaused",
            "sha256sum": "78e5c7465a9ab32f82e23ece12ad001906e52165d851d8a4e5f6a5f367e88898"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/registries/Switchboard.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.3+commit.bff19ea2",
        "integrity": "443f6be7e25c120b6d94eba391e5649dc3450c5a4f9a20f6bf07b14935c9e32d"
      },
      "args": "00000000000000000000000044cf3c4f000dfd76a35d03298049d37be688d6f90000000000000000000000000000000000000000000000000000000000005460000000000000000000000000000000000000000000000000000000000013c680",
      "file": "contracts/registries/Switchboard.vy"
    },
    "SwitchboardAlpha": {
      "address": "0x2256122FCb6F9789aa356F387435F545c3C52ba5",
      "abi": [
        {
          "name": "PendingUserWalletTemplatesChange",
          "inputs": [
            {
              "name": "walletTemplate",
              "type": "address",
              "indexed": false
            },
            {
              "name": "configTemplate",
              "type": "address",
              "indexed": false
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UserWalletTemplatesSet",
          "inputs": [
            {
              "name": "walletTemplate",
              "type": "address",
              "indexed": false
            },
            {
              "name": "configTemplate",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PendingTrialFundsChange",
          "inputs": [
            {
              "name": "trialAsset",
              "type": "address",
              "indexed": false
            },
            {
              "name": "trialAmount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "TrialFundsSet",
          "inputs": [
            {
              "name": "trialAsset",
              "type": "address",
              "indexed": false
            },
            {
              "name": "trialAmount",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PendingWalletCreationLimitsChange",
          "inputs": [
            {
              "name": "numUserWalletsAllowed",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "enforceCreatorWhitelist",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "WalletCreationLimitsSet",
          "inputs": [
            {
              "name": "numUserWalletsAllowed",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "enforceCreatorWhitelist",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PendingKeyActionTimelockBoundsChange",
          "inputs": [
            {
              "name": "minKeyActionTimeLock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "maxKeyActionTimeLock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "KeyActionTimelockBoundsSet",
          "inputs": [
            {
              "name": "minKeyActionTimeLock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "maxKeyActionTimeLock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PendingDefaultStaleBlocksChange",
          "inputs": [
            {
              "name": "defaultStaleBlocks",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "DefaultStaleBlocksSet",
          "inputs": [
            {
              "name": "defaultStaleBlocks",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PendingTxFeesChange",
          "inputs": [
            {
              "name": "swapFee",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "stableSwapFee",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "rewardsFee",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "TxFeesSet",
          "inputs": [
            {
              "name": "swapFee",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "stableSwapFee",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "rewardsFee",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PendingAmbassadorRevShareChange",
          "inputs": [
            {
              "name": "swapRatio",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "rewardsRatio",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "yieldRatio",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AmbassadorRevShareSet",
          "inputs": [
            {
              "name": "swapRatio",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "rewardsRatio",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "yieldRatio",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PendingDefaultYieldParamsChange",
          "inputs": [
            {
              "name": "defaultYieldMaxIncrease",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "defaultYieldPerformanceFee",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "defaultYieldAmbassadorBonusRatio",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "defaultYieldBonusRatio",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "defaultYieldAltBonusAsset",
              "type": "address",
              "indexed": false
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "DefaultYieldParamsSet",
          "inputs": [
            {
              "name": "defaultYieldMaxIncrease",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "defaultYieldPerformanceFee",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "defaultYieldAmbassadorBonusRatio",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "defaultYieldBonusRatio",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "defaultYieldAltBonusAsset",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PendingLootParamsChange",
          "inputs": [
            {
              "name": "depositRewardsAsset",
              "type": "address",
              "indexed": false
            },
            {
              "name": "lootClaimCoolOffPeriod",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LootParamsSet",
          "inputs": [
            {
              "name": "depositRewardsAsset",
              "type": "address",
              "indexed": false
            },
            {
              "name": "lootClaimCoolOffPeriod",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PendingAssetConfigChange",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": false
            },
            {
              "name": "legoId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "staleBlocks",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "txFeesSwapFee",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "txFeesStableSwapFee",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "txFeesRewardsFee",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "ambassadorRevShareSwapRatio",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "ambassadorRevShareRewardsRatio",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "ambassadorRevShareYieldRatio",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "isYieldAsset",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "isRebasing",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "underlyingAsset",
              "type": "address",
              "indexed": false
            },
            {
              "name": "maxYieldIncrease",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "performanceFee",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "ambassadorBonusRatio",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "bonusRatio",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "altBonusAsset",
              "type": "address",
              "indexed": false
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PendingIsStablecoinChange",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": false
            },
            {
              "name": "isStablecoin",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "IsStablecoinSet",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": false
            },
            {
              "name": "isStablecoin",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetConfigSet",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": false
            },
            {
              "name": "legoId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "staleBlocks",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "txFeesSwapFee",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "txFeesStableSwapFee",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "txFeesRewardsFee",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "ambassadorRevShareSwapRatio",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "ambassadorRevShareRewardsRatio",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "ambassadorRevShareYieldRatio",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "isYieldAsset",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "isRebasing",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "underlyingAsset",
              "type": "address",
              "indexed": false
            },
            {
              "name": "maxYieldIncrease",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "performanceFee",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "ambassadorBonusRatio",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "bonusRatio",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "altBonusAsset",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PendingAgentTemplateChange",
          "inputs": [
            {
              "name": "agentTemplate",
              "type": "address",
              "indexed": false
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AgentTemplateSet",
          "inputs": [
            {
              "name": "agentTemplate",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PendingAgentCreationLimitsChange",
          "inputs": [
            {
              "name": "numAgentsAllowed",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "enforceCreatorWhitelist",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AgentCreationLimitsSet",
          "inputs": [
            {
              "name": "numAgentsAllowed",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "enforceCreatorWhitelist",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PendingStarterAgentParamsChange",
          "inputs": [
            {
              "name": "startingAgent",
              "type": "address",
              "indexed": false
            },
            {
              "name": "startingAgentActivationLength",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "StarterAgentParamsSet",
          "inputs": [
            {
              "name": "startingAgent",
              "type": "address",
              "indexed": false
            },
            {
              "name": "startingAgentActivationLength",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PendingManagerConfigChange",
          "inputs": [
            {
              "name": "managerPeriod",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "managerActivationLength",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PendingPayeeConfigChange",
          "inputs": [
            {
              "name": "payeePeriod",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "payeeActivationLength",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PendingCanPerformSecurityAction",
          "inputs": [
            {
              "name": "signer",
              "type": "address",
              "indexed": false
            },
            {
              "name": "canPerform",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "CreatorWhitelistSet",
          "inputs": [
            {
              "name": "creator",
              "type": "address",
              "indexed": false
            },
            {
              "name": "isWhitelisted",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "caller",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "ManagerConfigSet",
          "inputs": [
            {
              "name": "managerPeriod",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "managerActivationLength",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PayeeConfigSet",
          "inputs": [
            {
              "name": "payeePeriod",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "payeeActivationLength",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "CanPerformSecurityAction",
          "inputs": [
            {
              "name": "signer",
              "type": "address",
              "indexed": false
            },
            {
              "name": "canPerform",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LockedSignerSet",
          "inputs": [
            {
              "name": "signer",
              "type": "address",
              "indexed": false
            },
            {
              "name": "isLocked",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "caller",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeTimeLockModified",
          "inputs": [
            {
              "name": "prevTimeLock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "newTimeLock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "ExpirationSet",
          "inputs": [
            {
              "name": "expiration",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "ActionTimeLockSet",
          "inputs": [
            {
              "name": "newTimeLock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "prevTimeLock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeStarted",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeConfirmed",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeCancelled",
          "inputs": [
            {
              "name": "cancelledGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovRelinquished",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UndyHqSetupFinished",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "timeLock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddys",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "undyToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "hatchery",
                  "type": "address"
                },
                {
                  "name": "lootDistributor",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                },
                {
                  "name": "walletBackpack",
                  "type": "address"
                },
                {
                  "name": "billing",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUndyHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUndyHqFromGov",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canGovern",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getGovernors",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPendingGovChange",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "startGovernanceChange",
          "inputs": [
            {
              "name": "_newGov",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "relinquishGov",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setGovTimeLock",
          "inputs": [
            {
              "name": "_numBlocks",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidGovTimeLock",
          "inputs": [
            {
              "name": "_newTimeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "minGovChangeTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "maxGovChangeTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "finishUndyHqSetup",
          "inputs": [
            {
              "name": "_newGov",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "finishUndyHqSetup",
          "inputs": [
            {
              "name": "_newGov",
              "type": "address"
            },
            {
              "name": "_timeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "governance",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingGov",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "newGov",
                  "type": "address"
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numGovChanges",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "govChangeTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canConfirmAction",
          "inputs": [
            {
              "name": "_actionId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isExpired",
          "inputs": [
            {
              "name": "_actionId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPendingAction",
          "inputs": [
            {
              "name": "_actionId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getActionConfirmationBlock",
          "inputs": [
            {
              "name": "_actionId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setActionTimeLock",
          "inputs": [
            {
              "name": "_newTimeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidActionTimeLock",
          "inputs": [
            {
              "name": "_newTimeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "minActionTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "maxActionTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setExpiration",
          "inputs": [
            {
              "name": "_expiration",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setActionTimeLockAfterSetup",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setActionTimeLockAfterSetup",
          "inputs": [
            {
              "name": "_newTimeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingActions",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                },
                {
                  "name": "expiration",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "actionId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "actionTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "expiration",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setUserWalletTemplates",
          "inputs": [
            {
              "name": "_walletTemplate",
              "type": "address"
            },
            {
              "name": "_configTemplate",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setTrialFunds",
          "inputs": [
            {
              "name": "_trialAsset",
              "type": "address"
            },
            {
              "name": "_trialAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setWalletCreationLimits",
          "inputs": [
            {
              "name": "_numUserWalletsAllowed",
              "type": "uint256"
            },
            {
              "name": "_enforceCreatorWhitelist",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setKeyActionTimelockBounds",
          "inputs": [
            {
              "name": "_minKeyActionTimeLock",
              "type": "uint256"
            },
            {
              "name": "_maxKeyActionTimeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setDefaultStaleBlocks",
          "inputs": [
            {
              "name": "_defaultStaleBlocks",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setTxFees",
          "inputs": [
            {
              "name": "_swapFee",
              "type": "uint256"
            },
            {
              "name": "_stableSwapFee",
              "type": "uint256"
            },
            {
              "name": "_rewardsFee",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setAmbassadorRevShare",
          "inputs": [
            {
              "name": "_swapRatio",
              "type": "uint256"
            },
            {
              "name": "_rewardsRatio",
              "type": "uint256"
            },
            {
              "name": "_yieldRatio",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setDefaultYieldParams",
          "inputs": [
            {
              "name": "_defaultYieldMaxIncrease",
              "type": "uint256"
            },
            {
              "name": "_defaultYieldPerformanceFee",
              "type": "uint256"
            },
            {
              "name": "_defaultYieldAmbassadorBonusRatio",
              "type": "uint256"
            },
            {
              "name": "_defaultYieldBonusRatio",
              "type": "uint256"
            },
            {
              "name": "_defaultYieldAltBonusAsset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setLootParams",
          "inputs": [
            {
              "name": "_depositRewardsAsset",
              "type": "address"
            },
            {
              "name": "_lootClaimCoolOffPeriod",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setAssetConfig",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_staleBlocks",
              "type": "uint256"
            },
            {
              "name": "_txFeesSwapFee",
              "type": "uint256"
            },
            {
              "name": "_txFeesStableSwapFee",
              "type": "uint256"
            },
            {
              "name": "_txFeesRewardsFee",
              "type": "uint256"
            },
            {
              "name": "_ambassadorRevShareSwapRatio",
              "type": "uint256"
            },
            {
              "name": "_ambassadorRevShareRewardsRatio",
              "type": "uint256"
            },
            {
              "name": "_ambassadorRevShareYieldRatio",
              "type": "uint256"
            },
            {
              "name": "_isYieldAsset",
              "type": "bool"
            },
            {
              "name": "_isRebasing",
              "type": "bool"
            },
            {
              "name": "_underlyingAsset",
              "type": "address"
            },
            {
              "name": "_maxYieldIncrease",
              "type": "uint256"
            },
            {
              "name": "_performanceFee",
              "type": "uint256"
            },
            {
              "name": "_ambassadorBonusRatio",
              "type": "uint256"
            },
            {
              "name": "_bonusRatio",
              "type": "uint256"
            },
            {
              "name": "_altBonusAsset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setIsStablecoin",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_isStablecoin",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setAgentTemplate",
          "inputs": [
            {
              "name": "_agentTemplate",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setAgentCreationLimits",
          "inputs": [
            {
              "name": "_numAgentsAllowed",
              "type": "uint256"
            },
            {
              "name": "_enforceCreatorWhitelist",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setStarterAgentParams",
          "inputs": [
            {
              "name": "_startingAgent",
              "type": "address"
            },
            {
              "name": "_startingAgentActivationLength",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setManagerConfig",
          "inputs": [
            {
              "name": "_managerPeriod",
              "type": "uint256"
            },
            {
              "name": "_managerActivationLength",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setPayeeConfig",
          "inputs": [
            {
              "name": "_payeePeriod",
              "type": "uint256"
            },
            {
              "name": "_payeeActivationLength",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setCanPerformSecurityAction",
          "inputs": [
            {
              "name": "_signer",
              "type": "address"
            },
            {
              "name": "_canPerform",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setCreatorWhitelist",
          "inputs": [
            {
              "name": "_creator",
              "type": "address"
            },
            {
              "name": "_isWhitelisted",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setLockedSigner",
          "inputs": [
            {
              "name": "_signer",
              "type": "address"
            },
            {
              "name": "_isLocked",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "executePendingAction",
          "inputs": [
            {
              "name": "_aid",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelPendingAction",
          "inputs": [
            {
              "name": "_aid",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "actionType",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingUserWalletConfig",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "walletTemplate",
                  "type": "address"
                },
                {
                  "name": "configTemplate",
                  "type": "address"
                },
                {
                  "name": "trialAsset",
                  "type": "address"
                },
                {
                  "name": "trialAmount",
                  "type": "uint256"
                },
                {
                  "name": "numUserWalletsAllowed",
                  "type": "uint256"
                },
                {
                  "name": "enforceCreatorWhitelist",
                  "type": "bool"
                },
                {
                  "name": "minKeyActionTimeLock",
                  "type": "uint256"
                },
                {
                  "name": "maxKeyActionTimeLock",
                  "type": "uint256"
                },
                {
                  "name": "defaultStaleBlocks",
                  "type": "uint256"
                },
                {
                  "name": "depositRewardsAsset",
                  "type": "address"
                },
                {
                  "name": "txFees",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "swapFee",
                      "type": "uint256"
                    },
                    {
                      "name": "stableSwapFee",
                      "type": "uint256"
                    },
                    {
                      "name": "rewardsFee",
                      "type": "uint256"
                    }
                  ]
                },
                {
                  "name": "ambassadorRevShare",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "swapRatio",
                      "type": "uint256"
                    },
                    {
                      "name": "rewardsRatio",
                      "type": "uint256"
                    },
                    {
                      "name": "yieldRatio",
                      "type": "uint256"
                    }
                  ]
                },
                {
                  "name": "defaultYieldMaxIncrease",
                  "type": "uint256"
                },
                {
                  "name": "defaultYieldPerformanceFee",
                  "type": "uint256"
                },
                {
                  "name": "defaultYieldAmbassadorBonusRatio",
                  "type": "uint256"
                },
                {
                  "name": "defaultYieldBonusRatio",
                  "type": "uint256"
                },
                {
                  "name": "defaultYieldAltBonusAsset",
                  "type": "address"
                },
                {
                  "name": "lootClaimCoolOffPeriod",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingAssetConfig",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "config",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "legoId",
                      "type": "uint256"
                    },
                    {
                      "name": "decimals",
                      "type": "uint256"
                    },
                    {
                      "name": "staleBlocks",
                      "type": "uint256"
                    },
                    {
                      "name": "txFees",
                      "type": "tuple",
                      "components": [
                        {
                          "name": "swapFee",
                          "type": "uint256"
                        },
                        {
                          "name": "stableSwapFee",
                          "type": "uint256"
                        },
                        {
                          "name": "rewardsFee",
                          "type": "uint256"
                        }
                      ]
                    },
                    {
                      "name": "ambassadorRevShare",
                      "type": "tuple",
                      "components": [
                        {
                          "name": "swapRatio",
                          "type": "uint256"
                        },
                        {
                          "name": "rewardsRatio",
                          "type": "uint256"
                        },
                        {
                          "name": "yieldRatio",
                          "type": "uint256"
                        }
                      ]
                    },
                    {
                      "name": "yieldConfig",
                      "type": "tuple",
                      "components": [
                        {
                          "name": "isYieldAsset",
                          "type": "bool"
                        },
                        {
                          "name": "isRebasing",
                          "type": "bool"
                        },
                        {
                          "name": "underlyingAsset",
                          "type": "address"
                        },
                        {
                          "name": "maxYieldIncrease",
                          "type": "uint256"
                        },
                        {
                          "name": "performanceFee",
                          "type": "uint256"
                        },
                        {
                          "name": "ambassadorBonusRatio",
                          "type": "uint256"
                        },
                        {
                          "name": "bonusRatio",
                          "type": "uint256"
                        },
                        {
                          "name": "altBonusAsset",
                          "type": "address"
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingAgentConfig",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "agentTemplate",
                  "type": "address"
                },
                {
                  "name": "numAgentsAllowed",
                  "type": "uint256"
                },
                {
                  "name": "enforceCreatorWhitelist",
                  "type": "bool"
                },
                {
                  "name": "startingAgent",
                  "type": "address"
                },
                {
                  "name": "startingAgentActivationLength",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingManagerConfig",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "managerPeriod",
                  "type": "uint256"
                },
                {
                  "name": "managerActivationLength",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingPayeeConfig",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "payeePeriod",
                  "type": "uint256"
                },
                {
                  "name": "payeeActivationLength",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingAddrToBool",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "addr",
                  "type": "address"
                },
                {
                  "name": "isAllowed",
                  "type": "bool"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_undyHq",
              "type": "address"
            },
            {
              "name": "_tempGov",
              "type": "address"
            },
            {
              "name": "_minConfigTimeLock",
              "type": "uint256"
            },
            {
              "name": "_maxConfigTimeLock",
              "type": "uint256"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/modules/Addys.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\ninterface UndyHq:\n    def isValidAddr(_addr: address) -> bool: view\n    def getAddr(_regId: uint256) -> address: view\n    def undyToken() -> address: view\n\ninterface Switchboard:\n    def isSwitchboardAddr(_addr: address) -> bool: view\n\ninterface LegoBook:\n    def isLegoAddr(_addr: address) -> bool: view\n\nstruct Addys:\n    hq: address\n    undyToken: address\n    ledger: address\n    missionControl: address\n    legoBook: address\n    switchboard: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    walletBackpack: address\n    billing: address\n\n# hq\nUNDY_HQ_FOR_ADDYS: immutable(address)\n\n# core addys\nLEDGER_ID: constant(uint256) = 1\nMISSION_CONTROL_ID: constant(uint256) = 2\nLEGO_BOOK_ID: constant(uint256) = 3\nSWITCHBOARD_ID: constant(uint256) = 4\nHATCHERY_ID: constant(uint256) = 5\nLOOT_DISTRIBUTOR_ID: constant(uint256) = 6\nAPPRAISER_ID: constant(uint256) = 7\nWALLET_BACKPACK_ID: constant(uint256) = 8\nBILLING_ID: constant(uint256) = 9\n\n\n@deploy\ndef __init__(_undyHq: address):\n    assert _undyHq != empty(address) # dev: invalid undy hq\n    UNDY_HQ_FOR_ADDYS = _undyHq\n\n\n########\n# Core #\n########\n\n\n@view\n@external\ndef getAddys() -> Addys:\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _getAddys(_addys: Addys = empty(Addys)) -> Addys:\n    if _addys.hq != empty(address):\n        return _addys\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _generateAddys() -> Addys:\n    hq: address = UNDY_HQ_FOR_ADDYS\n    return Addys(\n        hq = hq,\n        undyToken = staticcall UndyHq(hq).undyToken(),\n        ledger = staticcall UndyHq(hq).getAddr(LEDGER_ID),\n        missionControl = staticcall UndyHq(hq).getAddr(MISSION_CONTROL_ID),\n        legoBook = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID),\n        switchboard = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID),\n        hatchery = staticcall UndyHq(hq).getAddr(HATCHERY_ID),\n        lootDistributor = staticcall UndyHq(hq).getAddr(LOOT_DISTRIBUTOR_ID),\n        appraiser = staticcall UndyHq(hq).getAddr(APPRAISER_ID),\n        walletBackpack = staticcall UndyHq(hq).getAddr(WALLET_BACKPACK_ID),\n        billing = staticcall UndyHq(hq).getAddr(BILLING_ID),\n    )\n\n\n##########\n# Tokens #\n##########\n\n\n@view\n@internal\ndef _getUndyToken() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).undyToken()\n\n\n###########\n# Helpers #\n###########\n\n\n# undy hq\n\n\n@view\n@external\ndef getUndyHq() -> address:\n    return self._getUndyHq()\n\n\n@view\n@internal\ndef _getUndyHq() -> address:\n    return UNDY_HQ_FOR_ADDYS\n\n\n# utils\n\n\n@view\n@internal\ndef _isValidUndyAddr(_addr: address, _hq: address = empty(address)) -> bool:\n    hq: address = _hq\n    if _hq == empty(address):\n        hq = UNDY_HQ_FOR_ADDYS\n    \n    # core departments\n    if staticcall UndyHq(hq).isValidAddr(_addr):\n        return True\n\n    # lego book\n    legoBook: address = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID)\n    if legoBook != empty(address) and staticcall LegoBook(legoBook).isLegoAddr(_addr):\n        return True\n\n    # switchboard config\n    switchboard: address = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID)\n    if switchboard != empty(address) and staticcall Switchboard(switchboard).isSwitchboardAddr(_addr):\n        return True\n\n    return False\n\n\n@view\n@internal\ndef _isSwitchboardAddr(_addr: address) -> bool:\n    switchboard: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n    if switchboard == empty(address):\n        return False\n    return staticcall Switchboard(switchboard).isSwitchboardAddr(_addr)\n\n\n@view\n@internal\ndef _isLegoBookAddr(_addr: address) -> bool:\n    legoBook: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n    if legoBook == empty(address):\n        return False\n    return staticcall LegoBook(legoBook).isLegoAddr(_addr)\n\n\n###############\n# Departments #\n###############\n\n\n# ledger\n\n\n@view\n@internal\ndef _getLedgerId() -> uint256:\n    return LEDGER_ID\n\n\n@view\n@internal\ndef _getLedgerAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEDGER_ID)\n\n\n# mission control\n\n\n@view\n@internal\ndef _getMissionControlId() -> uint256:\n    return MISSION_CONTROL_ID\n\n\n@view\n@internal\ndef _getMissionControlAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(MISSION_CONTROL_ID)\n\n\n# lego book\n\n\n@view\n@internal\ndef _getLegoBookId() -> uint256:\n    return LEGO_BOOK_ID\n\n\n@view\n@internal\ndef _getLegoBookAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n\n\n# switchboard\n\n\n@view\n@internal\ndef _getSwitchboardId() -> uint256:\n    return SWITCHBOARD_ID\n\n\n@view\n@internal\ndef _getSwitchboardAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n\n\n# hatchery\n\n\n@view\n@internal\ndef _getHatcheryId() -> uint256:\n    return HATCHERY_ID\n\n\n@view\n@internal\ndef _getHatcheryAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(HATCHERY_ID)\n\n\n# loot distributor\n\n\n@view\n@internal\ndef _getLootDistributorId() -> uint256:\n    return LOOT_DISTRIBUTOR_ID\n\n\n@view\n@internal\ndef _getLootDistributorAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LOOT_DISTRIBUTOR_ID)\n\n\n# appraiser\n\n\n@view\n@internal\ndef _getAppraiserId() -> uint256:\n    return APPRAISER_ID\n\n\n@view\n@internal\ndef _getAppraiserAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(APPRAISER_ID)\n\n\n# wallet backpack\n\n\n@view\n@internal\ndef _getWalletBackpackId() -> uint256:\n    return WALLET_BACKPACK_ID\n\n\n@view\n@internal\ndef _getWalletBackpackAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(WALLET_BACKPACK_ID)\n\n\n# billing\n\n\n@view\n@internal\ndef _getBillingId() -> uint256:\n    return BILLING_ID\n\n\n@view\n@internal\ndef _getBillingAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(BILLING_ID)",
            "sha256sum": "78b58f0b2acb2eaafa4d21adf9135a1cd0e1d53897f7a1fa70a83a04a7738ad3"
          },
          "contracts/modules/LocalGov.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\ninterface UndyHq:\n    def minGovChangeTimeLock() -> uint256: view\n    def maxGovChangeTimeLock() -> uint256: view\n    def governance() -> address: view\n\nstruct PendingGovernance:\n    newGov: address\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeStarted:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    confirmBlock: uint256\n\nevent GovChangeConfirmed:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeCancelled:\n    cancelledGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovRelinquished:\n    prevGov: indexed(address)\n\nevent GovChangeTimeLockModified:\n    prevTimeLock: uint256\n    newTimeLock: uint256\n\nevent UndyHqSetupFinished:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    timeLock: uint256\n\n# governance\ngovernance: public(address)\npendingGov: public(PendingGovernance)\nnumGovChanges: public(uint256)\n\n# time lock\ngovChangeTimeLock: public(uint256)\n\n# config\nUNDY_HQ_FOR_GOV: immutable(address)\nMIN_GOV_TIME_LOCK: immutable(uint256)\nMAX_GOV_TIME_LOCK: immutable(uint256)\n\n\n@deploy\ndef __init__(\n    _undyHq: address,\n    _initialGov: address,\n    _minTimeLock: uint256,\n    _maxTimeLock: uint256,\n    _initialTimeLock: uint256,\n):\n    UNDY_HQ_FOR_GOV = _undyHq\n    self.governance = _initialGov\n\n    # undy hq\n    if _undyHq == empty(address):\n        assert _initialGov != empty(address) # dev: undy hq must have gov\n\n    # local gov (department, other smart contracts)\n    else:\n        hqGov: address = staticcall UndyHq(_undyHq).governance()\n        assert hqGov != empty(address) # dev: undy hq must have gov\n        assert _initialGov != hqGov # dev: undy hq cannot set same gov\n\n    # time locks\n    minTimeLock: uint256 = _minTimeLock\n    maxTimeLock: uint256 = _maxTimeLock\n    if minTimeLock == 0 or maxTimeLock == 0:\n        assert _undyHq != empty(address) # dev: need undy hq if no time locks\n        minTimeLock = staticcall UndyHq(_undyHq).minGovChangeTimeLock()\n        maxTimeLock = staticcall UndyHq(_undyHq).maxGovChangeTimeLock()\n\n    # set min and max time locks\n    assert minTimeLock < maxTimeLock # dev: invalid time lock\n    assert minTimeLock != 0 and maxTimeLock != max_value(uint256) # dev: invalid time lock\n    MIN_GOV_TIME_LOCK = minTimeLock\n    MAX_GOV_TIME_LOCK = maxTimeLock\n\n    # this contract is top level governance from Undy HQ -- not setting initial time lock during setup\n    if _undyHq == empty(address):\n        return\n\n    # set initial time lock (for local gov)\n    initialTimeLock: uint256 = max(minTimeLock, _initialTimeLock)\n    assert self._setGovTimeLock(initialTimeLock) # dev: invalid time lock\n\n\n@view\n@external\ndef getUndyHqFromGov() -> address:\n    return self._getUndyHqFromGov()\n\n\n@view\n@internal\ndef _getUndyHqFromGov() -> address:\n    return UNDY_HQ_FOR_GOV\n\n\n##############\n# Gov Access #\n##############\n\n\n@view\n@external\ndef canGovern(_addr: address) -> bool:\n    return self._canGovern(_addr)\n\n\n@view\n@internal\ndef _canGovern(_addr: address) -> bool:\n    if _addr == empty(address):\n        return False\n    return _addr in self._getGovernors()\n\n\n@view\n@external\ndef getGovernors() -> DynArray[address, 2]:\n    return self._getGovernors()\n\n\n@view\n@internal\ndef _getGovernors() -> DynArray[address, 2]:\n    governors: DynArray[address, 2] = []\n\n    # local governance\n    localGov: address = self.governance\n    if localGov != empty(address):\n        governors.append(localGov)\n\n    # undy hq governance\n    undyHq: address = UNDY_HQ_FOR_GOV\n    if undyHq == empty(address):\n        return governors\n\n    hqGov: address = staticcall UndyHq(undyHq).governance()\n    if hqGov != empty(address):\n        governors.append(hqGov)\n\n    return governors\n\n\n######################\n# Governance Changes #\n######################\n\n\n@view\n@external\ndef hasPendingGovChange() -> bool:\n    return self.pendingGov.confirmBlock != 0\n\n\n@view\n@internal\ndef _isUndyHq() -> bool:\n    return UNDY_HQ_FOR_GOV == empty(address)\n\n\n# start gov change\n\n\n@external\ndef startGovernanceChange(_newGov: address):\n    governors: DynArray[address, 2] = self._getGovernors()\n    assert msg.sender in governors # dev: no perms\n\n    # validation\n    if _newGov != empty(address):\n        assert _newGov not in governors # dev: invalid _newGov\n        assert _newGov.is_contract # dev: _newGov must be a contract\n    else:\n        assert not self._isUndyHq() # dev: undy hq cannot set 0x0\n\n    confirmBlock: uint256 = block.number + self.govChangeTimeLock\n    self.pendingGov = PendingGovernance(\n        newGov= _newGov,\n        initiatedBlock= block.number,\n        confirmBlock= confirmBlock,\n    )\n    log GovChangeStarted(prevGov=self.governance, newGov=_newGov, confirmBlock=confirmBlock)\n\n\n# confirm gov change\n\n\n@external\ndef confirmGovernanceChange():\n    data: PendingGovernance = self.pendingGov\n    assert data.confirmBlock != 0 and block.number >= data.confirmBlock # dev: time lock not reached\n\n    # check permissions\n    if data.newGov != empty(address):\n        assert msg.sender == data.newGov # dev: only new gov can confirm\n    else:\n        assert self._canGovern(msg.sender) # dev: no perms\n        assert not self._isUndyHq() # dev: undy hq cannot set 0x0\n\n    # set new governance\n    prevGov: address = self.governance\n    self.governance = data.newGov\n    self.numGovChanges += 1\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeConfirmed(prevGov=prevGov, newGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n# cancel gov change\n\n\n@external\ndef cancelGovernanceChange():\n    assert self._canGovern(msg.sender) # dev: no perms\n    data: PendingGovernance = self.pendingGov\n    assert data.confirmBlock != 0 # dev: no pending change\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeCancelled(cancelledGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n# relinquish gov (only for local gov)\n\n\n@external\ndef relinquishGov():\n    assert msg.sender == self.governance # dev: no perms\n    assert not self._isUndyHq() # dev: undy hq cannot relinquish gov\n\n    self.governance = empty(address)\n    self.numGovChanges += 1\n    log GovRelinquished(prevGov=msg.sender)\n\n\n####################\n# Time Lock Config #\n####################\n\n\n# set time lock\n\n\n@external\ndef setGovTimeLock(_numBlocks: uint256) -> bool:\n    assert self._canGovern(msg.sender) # dev: no perms\n    return self._setGovTimeLock(_numBlocks)\n\n\n@internal\ndef _setGovTimeLock(_numBlocks: uint256) -> bool:\n    prevTimeLock: uint256 = self.govChangeTimeLock\n    assert self._isValidGovTimeLock(_numBlocks, prevTimeLock) # dev: invalid time lock\n    self.govChangeTimeLock = _numBlocks\n    log GovChangeTimeLockModified(prevTimeLock=prevTimeLock, newTimeLock=_numBlocks)\n    return True\n\n\n# validation\n\n\n@view\n@external\ndef isValidGovTimeLock(_newTimeLock: uint256) -> bool:\n    return self._isValidGovTimeLock(_newTimeLock, self.govChangeTimeLock)\n\n\n@view\n@internal\ndef _isValidGovTimeLock(_newTimeLock: uint256, _prevTimeLock: uint256) -> bool:\n    if _newTimeLock == _prevTimeLock:\n        return False # no change\n    if self.pendingGov.confirmBlock != 0:\n        return False # cannot change while pending gov change\n    return _newTimeLock >= MIN_GOV_TIME_LOCK and _newTimeLock <= MAX_GOV_TIME_LOCK\n\n\n# utils\n\n\n@view\n@external\ndef minGovChangeTimeLock() -> uint256:\n    return MIN_GOV_TIME_LOCK\n\n\n@view\n@external\ndef maxGovChangeTimeLock() -> uint256:\n    return MAX_GOV_TIME_LOCK\n\n\n#################\n# Undy Hq Setup #\n#################\n\n\n@external\ndef finishUndyHqSetup(_newGov: address, _timeLock: uint256 = 0) -> bool:\n    assert self._isUndyHq() # dev: only undy hq\n    assert msg.sender == self.governance # dev: no perms\n    assert self.numGovChanges == 0 # dev: already changed gov\n\n    # validation\n    assert _newGov != empty(address) and _newGov.is_contract # dev: invalid _newGov\n    prevGov: address = self.governance\n\n    # set new gov\n    self.governance = _newGov\n    self.numGovChanges += 1\n\n    # set time lock\n    timeLock: uint256 = _timeLock\n    if timeLock == 0:\n        timeLock = MIN_GOV_TIME_LOCK\n    assert self._setGovTimeLock(timeLock) # dev: invalid time lock\n\n    log UndyHqSetupFinished(prevGov=prevGov, newGov=_newGov, timeLock=timeLock)\n    return True",
            "sha256sum": "c41aa3e0d0d96b512171813377ea277e2c7da690c3cd9b4662733b3f11f705b0"
          },
          "contracts/modules/TimeLock.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nuses: gov\nimport contracts.modules.LocalGov as gov\n\nstruct PendingAction:\n    initiatedBlock: uint256\n    confirmBlock: uint256\n    expiration: uint256\n\nevent ActionTimeLockSet:\n    newTimeLock: uint256\n    prevTimeLock: uint256\n\nevent ExpirationSet:\n    expiration: uint256\n\n# core data\npendingActions: public(HashMap[uint256, PendingAction])\nactionId: public(uint256)\n\n# config\nactionTimeLock: public(uint256)\nexpiration: public(uint256)\n\nMIN_ACTION_TIMELOCK: immutable(uint256)\nMAX_ACTION_TIMELOCK: immutable(uint256)\n\n\n@deploy\ndef __init__(\n    _minActionTimeLock: uint256,\n    _maxActionTimeLock: uint256,\n    _initialTimeLock: uint256,\n    _expiration: uint256,\n):\n    # start at 1 index\n    self.actionId = 1\n\n    # set time lock boundaries\n    assert _minActionTimeLock < _maxActionTimeLock # dev: invalid time lock boundaries\n    assert _minActionTimeLock != 0 and _maxActionTimeLock != max_value(uint256) # dev: invalid time lock boundaries\n    MIN_ACTION_TIMELOCK = _minActionTimeLock\n    MAX_ACTION_TIMELOCK = _maxActionTimeLock\n\n    # set expiration time\n    self._setExpiration(_expiration, _initialTimeLock)\n\n    # set initial time lock\n    if _initialTimeLock != 0:\n        assert self._setActionTimeLock(_initialTimeLock, 0) # dev: failed to set initial time lock\n\n\n########\n# Core #\n########\n\n\n# initiate\n\n\n@internal\ndef _initiateAction() -> uint256:\n    actionId: uint256 = self.actionId\n    confirmBlock: uint256 = block.number + self.actionTimeLock\n    self.pendingActions[actionId] = PendingAction(\n        initiatedBlock= block.number,\n        confirmBlock= confirmBlock,\n        expiration= confirmBlock + self.expiration,\n    )\n    self.actionId += 1\n    return actionId\n\n\n# confirm\n\n\n@internal\ndef _confirmAction(_actionId: uint256) -> bool:\n    if not self._canConfirmAction(_actionId):\n        return False\n    self.pendingActions[_actionId] = empty(PendingAction)\n    return True\n\n\n# cancel\n\n\n@internal\ndef _cancelAction(_actionId: uint256) -> bool:\n    data: PendingAction = self.pendingActions[_actionId]\n    if data.confirmBlock == 0:\n        return False\n    self.pendingActions[_actionId] = empty(PendingAction)\n    return True\n\n\n#########\n# Utils #\n#########\n\n\n# can confirm\n\n\n@view\n@external\ndef canConfirmAction(_actionId: uint256) -> bool:\n    return self._canConfirmAction(_actionId)\n\n\n@view\n@internal\ndef _canConfirmAction(_actionId: uint256) -> bool:\n    data: PendingAction = self.pendingActions[_actionId]\n    if data.confirmBlock == 0 or block.number < data.confirmBlock:\n        return False\n    if block.number >= data.expiration:\n        return False\n    return True\n\n\n# is expired\n\n\n@view\n@external\ndef isExpired(_actionId: uint256) -> bool:\n    return self._isExpired(_actionId)\n\n\n@view\n@internal\ndef _isExpired(_actionId: uint256) -> bool:\n    data: PendingAction = self.pendingActions[_actionId]\n    if data.confirmBlock == 0:\n        return False\n    return block.number >= data.expiration\n\n\n# pending action\n\n\n@view\n@external\ndef hasPendingAction(_actionId: uint256) -> bool:\n    return self._hasPendingAction(_actionId)\n\n\n@view\n@internal\ndef _hasPendingAction(_actionId: uint256) -> bool:\n    return self.pendingActions[_actionId].confirmBlock != 0\n\n\n# confirmation block\n\n\n@view\n@external\ndef getActionConfirmationBlock(_actionId: uint256) -> uint256:\n    return self._getActionConfirmationBlock(_actionId)\n\n\n@view\n@internal\ndef _getActionConfirmationBlock(_actionId: uint256) -> uint256:\n    return self.pendingActions[_actionId].confirmBlock\n\n\n######################\n# Config - Time Lock #\n######################\n\n\n@external\ndef setActionTimeLock(_newTimeLock: uint256) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return self._setActionTimeLock(_newTimeLock, self.actionTimeLock)\n\n\n@internal\ndef _setActionTimeLock(_newTimeLock: uint256, _prevTimeLock: uint256) -> bool:\n    assert self._isValidActionTimeLock(_newTimeLock, _prevTimeLock) # dev: invalid time lock\n    self.actionTimeLock = _newTimeLock\n    log ActionTimeLockSet(newTimeLock=_newTimeLock, prevTimeLock=_prevTimeLock)\n    return True\n\n\n# validation\n\n\n@view\n@external\ndef isValidActionTimeLock(_newTimeLock: uint256) -> bool:\n    return self._isValidActionTimeLock(_newTimeLock, self.actionTimeLock)\n\n\n@view\n@internal\ndef _isValidActionTimeLock(_newTimeLock: uint256, _prevTimeLock: uint256) -> bool:\n    if _newTimeLock == _prevTimeLock:\n        return False # no change\n    return _newTimeLock >= MIN_ACTION_TIMELOCK and _newTimeLock <= MAX_ACTION_TIMELOCK\n\n\n# utils\n\n\n@view\n@external\ndef minActionTimeLock() -> uint256:\n    return MIN_ACTION_TIMELOCK\n\n\n@view\n@external\ndef maxActionTimeLock() -> uint256:\n    return MAX_ACTION_TIMELOCK\n\n\n#######################\n# Config - Expiration #\n#######################\n\n\n@external\ndef setExpiration(_expiration: uint256) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return self._setExpiration(_expiration, self.actionTimeLock)\n\n\n@internal\ndef _setExpiration(_expiration: uint256, _timeLock: uint256) -> bool:\n    assert self._isValidExpiration(_expiration, _timeLock) # dev: invalid expiration\n    self.expiration = _expiration\n    log ExpirationSet(expiration=_expiration)\n    return True\n\n\n# validation\n\n\n@view\n@internal\ndef _isValidExpiration(_expiration: uint256, _timeLock: uint256) -> bool:\n    if _expiration == 0 or _expiration == max_value(uint256):\n        return False\n    if _expiration < _timeLock:\n        return False\n    return True\n\n\n################\n# Finish Setup #\n################\n\n\n@external\ndef setActionTimeLockAfterSetup(_newTimeLock: uint256 = 0) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    prevTimeLock: uint256 = self.actionTimeLock\n    assert prevTimeLock == 0 # dev: already set\n\n    timeLock: uint256 = _newTimeLock\n    if timeLock == 0:\n        timeLock = MIN_ACTION_TIMELOCK\n    return self._setActionTimeLock(timeLock, prevTimeLock)",
            "sha256sum": "80ec25619b21a5ac9791a94ca96d5ee38a887cb59d0e9368e23ea4a2de75da8e"
          },
          "interfaces/ConfigStructs.vyi": {
            "content": "# @version 0.4.3\n\nstruct UserWalletConfig:\n    walletTemplate: address\n    configTemplate: address\n    trialAsset: address\n    trialAmount: uint256\n    numUserWalletsAllowed: uint256\n    enforceCreatorWhitelist: bool\n    minKeyActionTimeLock: uint256\n    maxKeyActionTimeLock: uint256\n    defaultStaleBlocks: uint256\n    depositRewardsAsset: address\n    txFees: TxFees\n    ambassadorRevShare: AmbassadorRevShare\n    defaultYieldMaxIncrease: uint256\n    defaultYieldPerformanceFee: uint256\n    defaultYieldAmbassadorBonusRatio: uint256\n    defaultYieldBonusRatio: uint256\n    defaultYieldAltBonusAsset: address\n    lootClaimCoolOffPeriod: uint256\n\nstruct AssetConfig:\n    legoId: uint256\n    decimals: uint256\n    staleBlocks: uint256\n    txFees: TxFees\n    ambassadorRevShare: AmbassadorRevShare\n    yieldConfig: YieldConfig\n\nstruct TxFees:\n    swapFee: uint256\n    stableSwapFee: uint256\n    rewardsFee: uint256\n\nstruct AmbassadorRevShare:\n    swapRatio: uint256\n    rewardsRatio: uint256\n    yieldRatio: uint256\n\nstruct YieldConfig:\n    isYieldAsset: bool\n    isRebasing: bool\n    underlyingAsset: address\n    maxYieldIncrease: uint256\n    performanceFee: uint256\n    ambassadorBonusRatio: uint256\n    bonusRatio: uint256\n    altBonusAsset: address\n\nstruct AgentConfig:\n    agentTemplate: address\n    numAgentsAllowed: uint256\n    enforceCreatorWhitelist: bool\n    startingAgent: address\n    startingAgentActivationLength: uint256\n\nstruct ManagerConfig:\n    managerPeriod: uint256\n    managerActivationLength: uint256\n\nstruct PayeeConfig:\n    payeePeriod: uint256\n    payeeActivationLength: uint256\n\nstruct ChequeConfig:\n    maxNumActiveCheques: uint256\n    instantUsdThreshold: uint256\n    periodLength: uint256\n    expensiveDelayBlocks: uint256\n    defaultExpiryBlocks: uint256",
            "sha256sum": "5398a73269f73f958f8d644802e65a65f335cf33c46938d0e05eabad7bc8d45f"
          },
          "contracts/config/SwitchboardAlpha.vy": {
            "content": "#        ______   __     __   __   ______  ______   __  __   ______   ______   ______   ______   _____    \n#       /\\  ___\\ /\\ \\  _ \\ \\ /\\ \\ /\\__  _\\/\\  ___\\ /\\ \\_\\ \\ /\\  == \\ /\\  __ \\ /\\  __ \\ /\\  == \\ /\\  __-.  \n#       \\ \\___  \\\\ \\ \\/ \".\\ \\\\ \\ \\\\/_/\\ \\/\\ \\ \\____\\ \\  __ \\\\ \\  __< \\ \\ \\/\\ \\\\ \\  __ \\\\ \\  __< \\ \\ \\/\\ \\ \n#        \\/\\_____\\\\ \\__/\".~\\_\\\\ \\_\\  \\ \\_\\ \\ \\_____\\\\ \\_\\ \\_\\\\ \\_____\\\\ \\_____\\\\ \\_\\ \\_\\\\ \\_\\ \\_\\\\ \\____- \n#         \\/_____/ \\/_/   \\/_/ \\/_/   \\/_/  \\/_____/ \\/_/\\/_/ \\/_____/ \\/_____/ \\/_/\\/_/ \\/_/ /_/ \\/____/ \n#                                                  \u250f\u2513\u2513  \u2513   \n#                                                  \u2523\u252b\u2503\u250f\u2513\u2523\u2513\u250f\u2513\n#                                                  \u251b\u2517\u2517\u2523\u251b\u251b\u2517\u2517\u253b\n#                                                     \u251b     \n#\n#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nexports: addys.__interface__\nexports: gov.__interface__\nexports: timeLock.__interface__\n\ninitializes: addys\ninitializes: gov\ninitializes: timeLock[gov := gov]\n\nimport contracts.modules.Addys as addys\nimport contracts.modules.LocalGov as gov\nimport contracts.modules.TimeLock as timeLock\n\nimport interfaces.ConfigStructs as cs\nfrom ethereum.ercs import IERC20Detailed\n\ninterface MissionControl:\n    def setCanPerformSecurityAction(_signer: address, _canPerform: bool): nonpayable\n    def setCreatorWhitelist(_creator: address, _isWhitelisted: bool): nonpayable\n    def setAssetConfig(_asset: address, _config: cs.AssetConfig): nonpayable\n    def setIsStablecoin(_asset: address, _isStablecoin: bool): nonpayable\n    def setLockedSigner(_signer: address, _isLocked: bool): nonpayable\n    def setUserWalletConfig(_config: cs.UserWalletConfig): nonpayable\n    def canPerformSecurityAction(_signer: address) -> bool: view\n    def setManagerConfig(_config: cs.ManagerConfig): nonpayable\n    def setPayeeConfig(_config: cs.PayeeConfig): nonpayable\n    def setAgentConfig(_config: cs.AgentConfig): nonpayable\n    def userWalletConfig() -> cs.UserWalletConfig: view\n    def agentConfig() -> cs.AgentConfig: view\n\ninterface Registry:\n    def isValidRegId(_regId: uint256) -> bool: view\n\nflag ActionType:\n    USER_WALLET_TEMPLATES\n    TRIAL_FUNDS\n    WALLET_CREATION_LIMITS\n    KEY_ACTION_TIMELOCK_BOUNDS\n    DEFAULT_STALE_BLOCKS\n    TX_FEES\n    AMBASSADOR_REV_SHARE\n    DEFAULT_YIELD_PARAMS\n    LOOT_PARAMS\n    AGENT_TEMPLATE\n    AGENT_CREATION_LIMITS\n    STARTER_AGENT_PARAMS\n    MANAGER_CONFIG\n    PAYEE_CONFIG\n    CAN_PERFORM_SECURITY_ACTION\n    ASSET_CONFIG\n    IS_STABLECOIN\n\nstruct IsAddrAllowed:\n    addr: address\n    isAllowed: bool\n\nstruct PendingAssetConfig:\n    asset: address\n    config: cs.AssetConfig\n\nevent PendingUserWalletTemplatesChange:\n    walletTemplate: address\n    configTemplate: address\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent UserWalletTemplatesSet:\n    walletTemplate: address\n    configTemplate: address\n\nevent PendingTrialFundsChange:\n    trialAsset: address\n    trialAmount: uint256\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent TrialFundsSet:\n    trialAsset: address\n    trialAmount: uint256\n\nevent PendingWalletCreationLimitsChange:\n    numUserWalletsAllowed: uint256\n    enforceCreatorWhitelist: bool\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent WalletCreationLimitsSet:\n    numUserWalletsAllowed: uint256\n    enforceCreatorWhitelist: bool\n\nevent PendingKeyActionTimelockBoundsChange:\n    minKeyActionTimeLock: uint256\n    maxKeyActionTimeLock: uint256\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent KeyActionTimelockBoundsSet:\n    minKeyActionTimeLock: uint256\n    maxKeyActionTimeLock: uint256\n\nevent PendingDefaultStaleBlocksChange:\n    defaultStaleBlocks: uint256\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent DefaultStaleBlocksSet:\n    defaultStaleBlocks: uint256\n\nevent PendingTxFeesChange:\n    swapFee: uint256\n    stableSwapFee: uint256\n    rewardsFee: uint256\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent TxFeesSet:\n    swapFee: uint256\n    stableSwapFee: uint256\n    rewardsFee: uint256\n\nevent PendingAmbassadorRevShareChange:\n    swapRatio: uint256\n    rewardsRatio: uint256\n    yieldRatio: uint256\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent AmbassadorRevShareSet:\n    swapRatio: uint256\n    rewardsRatio: uint256\n    yieldRatio: uint256\n\nevent PendingDefaultYieldParamsChange:\n    defaultYieldMaxIncrease: uint256\n    defaultYieldPerformanceFee: uint256\n    defaultYieldAmbassadorBonusRatio: uint256\n    defaultYieldBonusRatio: uint256\n    defaultYieldAltBonusAsset: address\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent DefaultYieldParamsSet:\n    defaultYieldMaxIncrease: uint256\n    defaultYieldPerformanceFee: uint256\n    defaultYieldAmbassadorBonusRatio: uint256\n    defaultYieldBonusRatio: uint256\n    defaultYieldAltBonusAsset: address\n\nevent PendingLootParamsChange:\n    depositRewardsAsset: address\n    lootClaimCoolOffPeriod: uint256\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent LootParamsSet:\n    depositRewardsAsset: address\n    lootClaimCoolOffPeriod: uint256\n\nevent PendingAssetConfigChange:\n    asset: address\n    legoId: uint256\n    staleBlocks: uint256\n    txFeesSwapFee: uint256\n    txFeesStableSwapFee: uint256\n    txFeesRewardsFee: uint256\n    ambassadorRevShareSwapRatio: uint256\n    ambassadorRevShareRewardsRatio: uint256\n    ambassadorRevShareYieldRatio: uint256\n    isYieldAsset: bool\n    isRebasing: bool\n    underlyingAsset: address\n    maxYieldIncrease: uint256\n    performanceFee: uint256\n    ambassadorBonusRatio: uint256\n    bonusRatio: uint256\n    altBonusAsset: address\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent PendingIsStablecoinChange:\n    asset: address\n    isStablecoin: bool\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent IsStablecoinSet:\n    asset: address\n    isStablecoin: bool\n\nevent AssetConfigSet:\n    asset: address\n    legoId: uint256\n    staleBlocks: uint256\n    txFeesSwapFee: uint256\n    txFeesStableSwapFee: uint256\n    txFeesRewardsFee: uint256\n    ambassadorRevShareSwapRatio: uint256\n    ambassadorRevShareRewardsRatio: uint256\n    ambassadorRevShareYieldRatio: uint256\n    isYieldAsset: bool\n    isRebasing: bool\n    underlyingAsset: address\n    maxYieldIncrease: uint256\n    performanceFee: uint256\n    ambassadorBonusRatio: uint256\n    bonusRatio: uint256\n    altBonusAsset: address\n\nevent PendingAgentTemplateChange:\n    agentTemplate: address\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent AgentTemplateSet:\n    agentTemplate: address\n\nevent PendingAgentCreationLimitsChange:\n    numAgentsAllowed: uint256\n    enforceCreatorWhitelist: bool\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent AgentCreationLimitsSet:\n    numAgentsAllowed: uint256\n    enforceCreatorWhitelist: bool\n\nevent PendingStarterAgentParamsChange:\n    startingAgent: address\n    startingAgentActivationLength: uint256\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent StarterAgentParamsSet:\n    startingAgent: address\n    startingAgentActivationLength: uint256\n\nevent PendingManagerConfigChange:\n    managerPeriod: uint256\n    managerActivationLength: uint256\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent PendingPayeeConfigChange:\n    payeePeriod: uint256\n    payeeActivationLength: uint256\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent PendingCanPerformSecurityAction:\n    signer: address\n    canPerform: bool\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent CreatorWhitelistSet:\n    creator: address\n    isWhitelisted: bool\n    caller: address\n\nevent ManagerConfigSet:\n    managerPeriod: uint256\n    managerActivationLength: uint256\n\nevent PayeeConfigSet:\n    payeePeriod: uint256\n    payeeActivationLength: uint256\n\nevent CanPerformSecurityAction:\n    signer: address\n    canPerform: bool\n\nevent LockedSignerSet:\n    signer: address\n    isLocked: bool\n    caller: address\n\n# pending config changes\nactionType: public(HashMap[uint256, ActionType]) # aid -> type\npendingUserWalletConfig: public(HashMap[uint256, cs.UserWalletConfig]) # aid -> config\npendingAssetConfig: public(HashMap[uint256, PendingAssetConfig]) # aid -> config\npendingAgentConfig: public(HashMap[uint256, cs.AgentConfig]) # aid -> config\npendingManagerConfig: public(HashMap[uint256, cs.ManagerConfig]) # aid -> config\npendingPayeeConfig: public(HashMap[uint256, cs.PayeeConfig]) # aid -> config\npendingAddrToBool: public(HashMap[uint256, IsAddrAllowed])\n\nHUNDRED_PERCENT: constant(uint256) = 100_00 # 100%\n\n\n@deploy\ndef __init__(\n    _undyHq: address,\n    _tempGov: address,\n    _minConfigTimeLock: uint256,\n    _maxConfigTimeLock: uint256,\n):\n    addys.__init__(_undyHq)\n    gov.__init__(_undyHq, _tempGov, 0, 0, 0)\n    timeLock.__init__(_minConfigTimeLock, _maxConfigTimeLock, 0, _maxConfigTimeLock)\n\n\n# access control\n\n\n@view\n@internal\ndef _hasPermsToEnable(_caller: address, _shouldEnable: bool) -> bool:\n    if gov._canGovern(_caller):\n        return True\n    if not _shouldEnable:\n        return staticcall MissionControl(addys._getMissionControlAddr()).canPerformSecurityAction(_caller)\n    return False\n\n\n######################\n# User Wallet Config #\n######################\n\n\n# user wallet templates\n\n\n@external\ndef setUserWalletTemplates(_walletTemplate: address, _configTemplate: address) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    assert self._areValidUserWalletTemplates(_walletTemplate, _configTemplate) # dev: invalid user wallet templates\n    return self._setPendingUserWalletConfig(ActionType.USER_WALLET_TEMPLATES, _walletTemplate, _configTemplate)\n\n\n@view\n@internal\ndef _areValidUserWalletTemplates(_walletTemplate: address, _configTemplate: address) -> bool:\n    if empty(address) in [_walletTemplate, _configTemplate]:\n        return False\n    if not _walletTemplate.is_contract or not _configTemplate.is_contract:\n        return False\n    return True\n\n\n# trial funds\n\n\n@external\ndef setTrialFunds(_trialAsset: address, _trialAmount: uint256) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return self._setPendingUserWalletConfig(\n        ActionType.TRIAL_FUNDS,\n        empty(address),\n        empty(address),\n        _trialAsset,\n        _trialAmount\n    )\n\n\n# wallet creation limits\n\n\n@external\ndef setWalletCreationLimits(_numUserWalletsAllowed: uint256, _enforceCreatorWhitelist: bool) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    assert self._isValidNumUserWalletsAllowed(_numUserWalletsAllowed) # dev: invalid num user wallets allowed\n    return self._setPendingUserWalletConfig(\n        ActionType.WALLET_CREATION_LIMITS,\n        empty(address),\n        empty(address),\n        empty(address),\n        0,\n        _numUserWalletsAllowed,\n        _enforceCreatorWhitelist\n    )\n\n\n@view\n@internal\ndef _isValidNumUserWalletsAllowed(_numUserWalletsAllowed: uint256) -> bool:\n    if _numUserWalletsAllowed == 0:\n        return False\n    if _numUserWalletsAllowed == max_value(uint256):\n        return False\n    return True\n\n\n# key action timelock bounds\n\n\n@external\ndef setKeyActionTimelockBounds(_minKeyActionTimeLock: uint256, _maxKeyActionTimeLock: uint256) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    assert self._areValidKeyActionTimelockBounds(_minKeyActionTimeLock, _maxKeyActionTimeLock) # dev: invalid key action timelock bounds\n    return self._setPendingUserWalletConfig(\n        ActionType.KEY_ACTION_TIMELOCK_BOUNDS,\n        empty(address),\n        empty(address),\n        empty(address),\n        0,\n        0,\n        False,\n        _minKeyActionTimeLock,\n        _maxKeyActionTimeLock\n    )\n\n\n@view\n@internal\ndef _areValidKeyActionTimelockBounds(_minKeyActionTimeLock: uint256, _maxKeyActionTimeLock: uint256) -> bool:\n    if 0 in [_minKeyActionTimeLock, _maxKeyActionTimeLock]:\n        return False\n    if max_value(uint256) in [_minKeyActionTimeLock, _maxKeyActionTimeLock]:\n        return False\n    if _minKeyActionTimeLock >= _maxKeyActionTimeLock:\n        return False\n    return True\n\n\n# default stale blocks\n\n\n@external\ndef setDefaultStaleBlocks(_defaultStaleBlocks: uint256) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    assert self._isValidStaleBlocks(_defaultStaleBlocks) # dev: invalid default stale blocks\n    return self._setPendingUserWalletConfig(\n        ActionType.DEFAULT_STALE_BLOCKS,\n        empty(address),\n        empty(address),\n        empty(address),\n        0,\n        0,\n        False,\n        0,\n        0,\n        _defaultStaleBlocks\n    )\n\n\n@view\n@internal\ndef _isValidStaleBlocks(_staleBlocks: uint256) -> bool:\n    if _staleBlocks == 0:\n        return False\n    if _staleBlocks == max_value(uint256):\n        return False\n    return True\n\n\n# tx fees\n\n\n@external\ndef setTxFees(_swapFee: uint256, _stableSwapFee: uint256, _rewardsFee: uint256) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    assert self._areValidTxFees(_swapFee, _stableSwapFee, _rewardsFee) # dev: invalid tx fees\n    return self._setPendingUserWalletConfig(\n        ActionType.TX_FEES,\n        empty(address),\n        empty(address),\n        empty(address),\n        0,\n        0,\n        False,\n        0,\n        0,\n        0,\n        empty(address),\n        _swapFee,\n        _stableSwapFee,\n        _rewardsFee\n    )\n\n\n@view\n@internal\ndef _areValidTxFees(_swapFee: uint256, _stableSwapFee: uint256, _rewardsFee: uint256) -> bool:\n    if _swapFee > 5_00: # 5% max\n        return False\n    if _stableSwapFee > 2_00: # 2% max\n        return False\n    if _rewardsFee > 25_00: # 25% max\n        return False\n    return True\n\n\n# ambassador rev share\n\n\n@external\ndef setAmbassadorRevShare(_swapRatio: uint256, _rewardsRatio: uint256, _yieldRatio: uint256) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    assert self._areValidAmbassadorRevShareRatios(_swapRatio, _rewardsRatio, _yieldRatio) # dev: invalid ambassador rev share ratios\n    return self._setPendingUserWalletConfig(\n        ActionType.AMBASSADOR_REV_SHARE,\n        empty(address),\n        empty(address),\n        empty(address),\n        0,\n        0,\n        False,\n        0,\n        0,\n        0,\n        empty(address),\n        0,\n        0,\n        0,\n        _swapRatio,\n        _rewardsRatio,\n        _yieldRatio\n    )\n\n\n@view\n@internal\ndef _areValidAmbassadorRevShareRatios(_swapRatio: uint256, _rewardsRatio: uint256, _yieldRatio: uint256) -> bool:\n    if _swapRatio > HUNDRED_PERCENT:\n        return False\n    if _rewardsRatio > HUNDRED_PERCENT:\n        return False\n    if _yieldRatio > HUNDRED_PERCENT:\n        return False\n    return True\n\n\n# default yield params\n\n\n@external\ndef setDefaultYieldParams(\n    _defaultYieldMaxIncrease: uint256,\n    _defaultYieldPerformanceFee: uint256,\n    _defaultYieldAmbassadorBonusRatio: uint256,\n    _defaultYieldBonusRatio: uint256,\n    _defaultYieldAltBonusAsset: address\n) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    assert self._areValidYieldParams(\n        _defaultYieldMaxIncrease,\n        _defaultYieldPerformanceFee,\n        _defaultYieldAmbassadorBonusRatio,\n        _defaultYieldBonusRatio\n    ) # dev: invalid default yield params\n\n    return self._setPendingUserWalletConfig(\n        ActionType.DEFAULT_YIELD_PARAMS,\n        empty(address),\n        empty(address),\n        empty(address),\n        0,\n        0,\n        False,\n        0,\n        0,\n        0,\n        empty(address),\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        _defaultYieldMaxIncrease,\n        _defaultYieldPerformanceFee,\n        _defaultYieldAmbassadorBonusRatio,\n        _defaultYieldBonusRatio,\n        _defaultYieldAltBonusAsset\n    )\n\n\n@view\n@internal\ndef _areValidYieldParams(\n    _maxIncrease: uint256,\n    _performanceFee: uint256,\n    _ambassadorBonusRatio: uint256,\n    _bonusRatio: uint256\n) -> bool:\n    if _maxIncrease > 10_00: # 10% max\n        return False\n    if _performanceFee > 25_00: # 25% max\n        return False\n    if _ambassadorBonusRatio > HUNDRED_PERCENT:\n        return False\n    if _bonusRatio > HUNDRED_PERCENT:\n        return False\n    return True\n\n\n# loot params\n\n\n@external\ndef setLootParams(_depositRewardsAsset: address, _lootClaimCoolOffPeriod: uint256) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    assert self._areValidLootParams(_lootClaimCoolOffPeriod) # dev: invalid loot params\n    return self._setPendingUserWalletConfig(\n        ActionType.LOOT_PARAMS,\n        empty(address),\n        empty(address),\n        empty(address),\n        0,\n        0,\n        False,\n        0,\n        0,\n        0,\n        _depositRewardsAsset,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        empty(address),\n        _lootClaimCoolOffPeriod\n    )\n\n\n@view\n@internal\ndef _areValidLootParams(_lootClaimCoolOffPeriod: uint256) -> bool:\n    if _lootClaimCoolOffPeriod == 0:\n        return False\n    if _lootClaimCoolOffPeriod == max_value(uint256):\n        return False\n    return True\n\n\n################\n# Asset Config #\n################\n\n\n@external\ndef setAssetConfig(\n    _asset: address,\n    _legoId: uint256,\n    _staleBlocks: uint256,\n    _txFeesSwapFee: uint256,\n    _txFeesStableSwapFee: uint256,\n    _txFeesRewardsFee: uint256,\n    _ambassadorRevShareSwapRatio: uint256,\n    _ambassadorRevShareRewardsRatio: uint256,\n    _ambassadorRevShareYieldRatio: uint256,\n    _isYieldAsset: bool,\n    _isRebasing: bool,\n    _underlyingAsset: address,\n    _maxYieldIncrease: uint256,\n    _performanceFee: uint256,\n    _ambassadorBonusRatio: uint256,\n    _bonusRatio: uint256,\n    _altBonusAsset: address\n) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    assert self._isValidAssetConfig(\n        _asset,\n        _legoId,\n        _staleBlocks,\n        _txFeesSwapFee,\n        _txFeesStableSwapFee,\n        _txFeesRewardsFee,\n        _ambassadorRevShareSwapRatio,\n        _ambassadorRevShareRewardsRatio,\n        _ambassadorRevShareYieldRatio,\n        _isYieldAsset,\n        _isRebasing,\n        _underlyingAsset,\n        _maxYieldIncrease,\n        _performanceFee,\n        _ambassadorBonusRatio,\n        _bonusRatio,\n        _altBonusAsset\n    ) # dev: invalid asset config\n\n    yieldConfig: cs.YieldConfig = empty(cs.YieldConfig)\n    if _isYieldAsset:\n        yieldConfig = cs.YieldConfig(\n            isYieldAsset=_isYieldAsset,\n            isRebasing=_isRebasing,\n            underlyingAsset=_underlyingAsset,\n            maxYieldIncrease=_maxYieldIncrease,\n            performanceFee=_performanceFee,\n            ambassadorBonusRatio=_ambassadorBonusRatio,\n            bonusRatio=_bonusRatio,\n            altBonusAsset=_altBonusAsset\n        )\n\n    aid: uint256 = timeLock._initiateAction()\n    self.actionType[aid] = ActionType.ASSET_CONFIG\n    self.pendingAssetConfig[aid] = PendingAssetConfig(\n        asset=_asset,\n        config=cs.AssetConfig(\n            legoId=_legoId,\n            decimals=convert(staticcall IERC20Detailed(_asset).decimals(), uint256),\n            staleBlocks=_staleBlocks,\n            txFees=cs.TxFees(\n                swapFee=_txFeesSwapFee,\n                stableSwapFee=_txFeesStableSwapFee,\n                rewardsFee=_txFeesRewardsFee,\n            ),\n            ambassadorRevShare=cs.AmbassadorRevShare(\n                swapRatio=_ambassadorRevShareSwapRatio,\n                rewardsRatio=_ambassadorRevShareRewardsRatio,\n                yieldRatio=_ambassadorRevShareYieldRatio,\n            ),\n            yieldConfig=yieldConfig,\n        )\n    )\n    confirmationBlock: uint256 = timeLock._getActionConfirmationBlock(aid)\n    log PendingAssetConfigChange(\n        asset=_asset,\n        legoId=_legoId,\n        staleBlocks=_staleBlocks,\n        txFeesSwapFee=_txFeesSwapFee,\n        txFeesStableSwapFee=_txFeesStableSwapFee,\n        txFeesRewardsFee=_txFeesRewardsFee,\n        ambassadorRevShareSwapRatio=_ambassadorRevShareSwapRatio,\n        ambassadorRevShareRewardsRatio=_ambassadorRevShareRewardsRatio,\n        ambassadorRevShareYieldRatio=_ambassadorRevShareYieldRatio,\n        isYieldAsset=_isYieldAsset,\n        isRebasing=_isRebasing,\n        underlyingAsset=_underlyingAsset,\n        maxYieldIncrease=_maxYieldIncrease,\n        performanceFee=_performanceFee,\n        ambassadorBonusRatio=_ambassadorBonusRatio,\n        bonusRatio=_bonusRatio,\n        altBonusAsset=_altBonusAsset,\n        confirmationBlock=confirmationBlock,\n        actionId=aid,\n    )\n    return aid\n\n\n@view\n@internal\ndef _isValidAssetConfig(\n    _asset: address,\n    _legoId: uint256,\n    _staleBlocks: uint256,\n    _txFeesSwapFee: uint256,\n    _txFeesStableSwapFee: uint256,\n    _txFeesRewardsFee: uint256,\n    _ambassadorRevShareSwapRatio: uint256,\n    _ambassadorRevShareRewardsRatio: uint256,\n    _ambassadorRevShareYieldRatio: uint256,\n    _isYieldAsset: bool,\n    _isRebasing: bool,\n    _underlyingAsset: address,\n    _maxYieldIncrease: uint256,\n    _performanceFee: uint256,\n    _ambassadorBonusRatio: uint256,\n    _bonusRatio: uint256,\n    _altBonusAsset: address\n) -> bool:\n    if _asset == empty(address):\n        return False\n\n    if not staticcall Registry(addys._getLegoBookAddr()).isValidRegId(_legoId):\n        return False\n\n    if not self._isValidStaleBlocks(_staleBlocks):\n        return False\n\n    if not self._areValidTxFees(_txFeesSwapFee, _txFeesStableSwapFee, _txFeesRewardsFee):\n        return False\n\n    if not self._areValidAmbassadorRevShareRatios(_ambassadorRevShareSwapRatio, _ambassadorRevShareRewardsRatio, _ambassadorRevShareYieldRatio):\n        return False\n\n    if _isYieldAsset and not self._areValidYieldParams(_maxYieldIncrease, _performanceFee, _ambassadorBonusRatio, _bonusRatio):\n        return False\n\n    return True\n\n\n# is stablecoin\n\n\n@external\ndef setIsStablecoin(_asset: address, _isStablecoin: bool) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    aid: uint256 = timeLock._initiateAction()\n    self.actionType[aid] = ActionType.IS_STABLECOIN\n    self.pendingAddrToBool[aid] = IsAddrAllowed(addr=_asset, isAllowed=_isStablecoin)\n    confirmationBlock: uint256 = timeLock._getActionConfirmationBlock(aid)\n    log PendingIsStablecoinChange(asset=_asset, isStablecoin=_isStablecoin, confirmationBlock=confirmationBlock, actionId=aid)\n    return aid\n\n\n################\n# Agent Config #\n################\n\n\n# agent template\n\n\n@external\ndef setAgentTemplate(_agentTemplate: address) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    assert self._isValidAgentTemplate(_agentTemplate) # dev: invalid agent template\n    return self._setPendingAgentConfig(\n        ActionType.AGENT_TEMPLATE,\n        _agentTemplate\n    )\n\n\n@view\n@internal\ndef _isValidAgentTemplate(_agentTemplate: address) -> bool:\n    if _agentTemplate == empty(address):\n        return False\n    if not _agentTemplate.is_contract:\n        return False\n    return True\n\n\n# agent creation limits\n\n\n@external\ndef setAgentCreationLimits(_numAgentsAllowed: uint256, _enforceCreatorWhitelist: bool) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    assert self._isValidNumAgentsAllowed(_numAgentsAllowed) # dev: invalid num agents allowed\n    return self._setPendingAgentConfig(\n        ActionType.AGENT_CREATION_LIMITS,\n        empty(address),\n        _numAgentsAllowed,\n        _enforceCreatorWhitelist\n    )\n\n\n@view\n@internal\ndef _isValidNumAgentsAllowed(_numAgentsAllowed: uint256) -> bool:\n    if _numAgentsAllowed == 0:\n        return False\n    if _numAgentsAllowed == max_value(uint256):\n        return False\n    return True\n\n\n# starter agent params\n\n\n@external\ndef setStarterAgentParams(_startingAgent: address, _startingAgentActivationLength: uint256) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    assert self._areValidStarterAgentParams(_startingAgent, _startingAgentActivationLength) # dev: invalid starter agent params\n    return self._setPendingAgentConfig(\n        ActionType.STARTER_AGENT_PARAMS,\n        empty(address),\n        0,\n        False,\n        _startingAgent,\n        _startingAgentActivationLength\n    )\n\n\n@view\n@internal\ndef _areValidStarterAgentParams(_startingAgent: address, _startingAgentActivationLength: uint256) -> bool:\n\n    # If starting agent is set, activation length must be non-zero\n    if _startingAgent != empty(address) and _startingAgentActivationLength == 0:\n        return False\n\n    # If starting agent is zero address, activation length must be zero\n    if _startingAgent == empty(address) and _startingAgentActivationLength != 0:\n        return False\n\n    # Activation length cannot be max value\n    if _startingAgentActivationLength == max_value(uint256):\n        return False\n\n    return True\n\n\n##################\n# Manager Config #\n##################\n\n\n@external\ndef setManagerConfig(_managerPeriod: uint256, _managerActivationLength: uint256) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    assert 0 not in [_managerPeriod, _managerActivationLength] # dev: invalid manager config\n    assert max_value(uint256) not in [_managerPeriod, _managerActivationLength] # dev: invalid manager config\n\n    aid: uint256 = timeLock._initiateAction()\n    self.actionType[aid] = ActionType.MANAGER_CONFIG\n    self.pendingManagerConfig[aid] = cs.ManagerConfig(\n        managerPeriod=_managerPeriod,\n        managerActivationLength=_managerActivationLength\n    )\n    confirmationBlock: uint256 = timeLock._getActionConfirmationBlock(aid)\n    log PendingManagerConfigChange(\n        managerPeriod=_managerPeriod,\n        managerActivationLength=_managerActivationLength,\n        confirmationBlock=confirmationBlock,\n        actionId=aid,\n    )\n    return aid\n\n\n################\n# Payee Config #\n################\n\n\n@external\ndef setPayeeConfig(_payeePeriod: uint256, _payeeActivationLength: uint256) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    assert 0 not in [_payeePeriod, _payeeActivationLength] # dev: invalid payee config\n    assert max_value(uint256) not in [_payeePeriod, _payeeActivationLength] # dev: invalid payee config\n\n    aid: uint256 = timeLock._initiateAction()\n    self.actionType[aid] = ActionType.PAYEE_CONFIG\n    self.pendingPayeeConfig[aid] = cs.PayeeConfig(\n        payeePeriod=_payeePeriod,\n        payeeActivationLength=_payeeActivationLength\n    )\n    confirmationBlock: uint256 = timeLock._getActionConfirmationBlock(aid)\n    log PendingPayeeConfigChange(\n        payeePeriod=_payeePeriod,\n        payeeActivationLength=_payeeActivationLength,\n        confirmationBlock=confirmationBlock,\n        actionId=aid,\n    )\n    return aid\n\n\n#########\n# Other #\n#########\n\n\n# can perform security action\n\n\n@external\ndef setCanPerformSecurityAction(_signer: address, _canPerform: bool) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    # when removing, allow to do immediately\n    if not _canPerform:\n        extcall MissionControl(addys._getMissionControlAddr()).setCanPerformSecurityAction(_signer, _canPerform)\n        log CanPerformSecurityAction(signer=_signer, canPerform=_canPerform)\n        return 0\n\n    aid: uint256 = timeLock._initiateAction()\n    self.actionType[aid] = ActionType.CAN_PERFORM_SECURITY_ACTION\n    self.pendingAddrToBool[aid] = IsAddrAllowed(addr=_signer, isAllowed=_canPerform)\n    confirmationBlock: uint256 = timeLock._getActionConfirmationBlock(aid)\n    log PendingCanPerformSecurityAction(signer=_signer, canPerform=_canPerform, confirmationBlock=confirmationBlock, actionId=aid)\n    return aid\n\n\n# set creator whitelist\n\n\n@external\ndef setCreatorWhitelist(_creator: address, _isWhitelisted: bool):\n    assert self._hasPermsToEnable(msg.sender, _isWhitelisted) # dev: no perms\n\n    assert _creator != empty(address) # dev: invalid creator\n    mc: address = addys._getMissionControlAddr()\n    extcall MissionControl(mc).setCreatorWhitelist(_creator, _isWhitelisted)\n\n    log CreatorWhitelistSet(creator=_creator, isWhitelisted=_isWhitelisted, caller=msg.sender)\n\n\n# locked signer\n\n\n@external\ndef setLockedSigner(_signer: address, _isLocked: bool):\n    assert self._hasPermsToEnable(msg.sender, not _isLocked) # dev: no perms\n\n    assert _signer != empty(address) # dev: invalid creator\n    mc: address = addys._getMissionControlAddr()\n    extcall MissionControl(mc).setLockedSigner(_signer, _isLocked)\n\n    log LockedSignerSet(signer=_signer, isLocked=_isLocked, caller=msg.sender)\n\n\n###############\n# Set Pending #\n###############\n\n\n@internal\ndef _setPendingUserWalletConfig(\n    _actionType: ActionType,\n    _walletTemplate: address = empty(address),\n    _configTemplate: address = empty(address),\n    _trialAsset: address = empty(address),\n    _trialAmount: uint256 = 0,\n    _numUserWalletsAllowed: uint256 = 0,\n    _enforceCreatorWhitelist: bool = False,\n    _minKeyActionTimeLock: uint256 = 0,\n    _maxKeyActionTimeLock: uint256 = 0,\n    _defaultStaleBlocks: uint256 = 0,\n    _depositRewardsAsset: address = empty(address),\n    _txFeesSwapFee: uint256 = 0,\n    _txFeesStableSwapFee: uint256 = 0,\n    _txFeesRewardsFee: uint256 = 0,\n    _ambassadorRevShareSwapRatio: uint256 = 0,\n    _ambassadorRevShareRewardsRatio: uint256 = 0,\n    _ambassadorRevShareYieldRatio: uint256 = 0,\n    _defaultYieldMaxIncrease: uint256 = 0,\n    _defaultYieldPerformanceFee: uint256 = 0,\n    _defaultYieldAmbassadorBonusRatio: uint256 = 0,\n    _defaultYieldBonusRatio: uint256 = 0,\n    _defaultYieldAltBonusAsset: address = empty(address),\n    _lootClaimCoolOffPeriod: uint256 = 0,\n) -> uint256:\n    aid: uint256 = timeLock._initiateAction()\n\n    self.actionType[aid] = _actionType\n    self.pendingUserWalletConfig[aid] = cs.UserWalletConfig(\n        walletTemplate=_walletTemplate,\n        configTemplate=_configTemplate,\n        trialAsset=_trialAsset,\n        trialAmount=_trialAmount,\n        numUserWalletsAllowed=_numUserWalletsAllowed,\n        enforceCreatorWhitelist=_enforceCreatorWhitelist,\n        minKeyActionTimeLock=_minKeyActionTimeLock,\n        maxKeyActionTimeLock=_maxKeyActionTimeLock,\n        defaultStaleBlocks=_defaultStaleBlocks,\n        depositRewardsAsset=_depositRewardsAsset,\n        txFees=cs.TxFees(\n            swapFee=_txFeesSwapFee,\n            stableSwapFee=_txFeesStableSwapFee,\n            rewardsFee=_txFeesRewardsFee,\n        ),\n        ambassadorRevShare=cs.AmbassadorRevShare(\n            swapRatio=_ambassadorRevShareSwapRatio,\n            rewardsRatio=_ambassadorRevShareRewardsRatio,\n            yieldRatio=_ambassadorRevShareYieldRatio,\n        ),\n        defaultYieldMaxIncrease=_defaultYieldMaxIncrease,\n        defaultYieldPerformanceFee=_defaultYieldPerformanceFee,\n        defaultYieldAmbassadorBonusRatio=_defaultYieldAmbassadorBonusRatio,\n        defaultYieldBonusRatio=_defaultYieldBonusRatio,\n        defaultYieldAltBonusAsset=_defaultYieldAltBonusAsset,\n        lootClaimCoolOffPeriod=_lootClaimCoolOffPeriod,\n    )\n\n    confirmationBlock: uint256 = timeLock._getActionConfirmationBlock(aid)\n    if _actionType == ActionType.USER_WALLET_TEMPLATES:\n        log PendingUserWalletTemplatesChange(\n            walletTemplate=_walletTemplate,\n            configTemplate=_configTemplate,\n            confirmationBlock=confirmationBlock,\n            actionId=aid,\n        )\n    elif _actionType == ActionType.TRIAL_FUNDS:\n        log PendingTrialFundsChange(\n            trialAsset=_trialAsset,\n            trialAmount=_trialAmount,\n            confirmationBlock=confirmationBlock,\n            actionId=aid,\n        )\n    elif _actionType == ActionType.WALLET_CREATION_LIMITS:\n        log PendingWalletCreationLimitsChange(\n            numUserWalletsAllowed=_numUserWalletsAllowed,\n            enforceCreatorWhitelist=_enforceCreatorWhitelist,\n            confirmationBlock=confirmationBlock,\n            actionId=aid,\n        )\n    elif _actionType == ActionType.KEY_ACTION_TIMELOCK_BOUNDS:\n        log PendingKeyActionTimelockBoundsChange(\n            minKeyActionTimeLock=_minKeyActionTimeLock,\n            maxKeyActionTimeLock=_maxKeyActionTimeLock,\n            confirmationBlock=confirmationBlock,\n            actionId=aid,\n        )\n    elif _actionType == ActionType.DEFAULT_STALE_BLOCKS:\n        log PendingDefaultStaleBlocksChange(\n            defaultStaleBlocks=_defaultStaleBlocks,\n            confirmationBlock=confirmationBlock,\n            actionId=aid,\n        )\n    elif _actionType == ActionType.TX_FEES:\n        log PendingTxFeesChange(\n            swapFee=_txFeesSwapFee,\n            stableSwapFee=_txFeesStableSwapFee,\n            rewardsFee=_txFeesRewardsFee,\n            confirmationBlock=confirmationBlock,\n            actionId=aid,\n        )\n    elif _actionType == ActionType.AMBASSADOR_REV_SHARE:\n        log PendingAmbassadorRevShareChange(\n            swapRatio=_ambassadorRevShareSwapRatio,\n            rewardsRatio=_ambassadorRevShareRewardsRatio,\n            yieldRatio=_ambassadorRevShareYieldRatio,\n            confirmationBlock=confirmationBlock,\n            actionId=aid,\n        )\n    elif _actionType == ActionType.DEFAULT_YIELD_PARAMS:\n        log PendingDefaultYieldParamsChange(\n            defaultYieldMaxIncrease=_defaultYieldMaxIncrease,\n            defaultYieldPerformanceFee=_defaultYieldPerformanceFee,\n            defaultYieldAmbassadorBonusRatio=_defaultYieldAmbassadorBonusRatio,\n            defaultYieldBonusRatio=_defaultYieldBonusRatio,\n            defaultYieldAltBonusAsset=_defaultYieldAltBonusAsset,\n            confirmationBlock=confirmationBlock,\n            actionId=aid,\n        )\n    elif _actionType == ActionType.LOOT_PARAMS:\n        log PendingLootParamsChange(\n            depositRewardsAsset=_depositRewardsAsset,\n            lootClaimCoolOffPeriod=_lootClaimCoolOffPeriod,\n            confirmationBlock=confirmationBlock,\n            actionId=aid,\n        )\n    return aid\n\n\n@internal\ndef _setPendingAgentConfig(\n    _actionType: ActionType,\n    _agentTemplate: address = empty(address),\n    _numAgentsAllowed: uint256 = 0,\n    _enforceCreatorWhitelist: bool = False,\n    _startingAgent: address = empty(address),\n    _startingAgentActivationLength: uint256 = 0,\n) -> uint256:\n    aid: uint256 = timeLock._initiateAction()\n\n    self.actionType[aid] = _actionType\n    self.pendingAgentConfig[aid] = cs.AgentConfig(\n        agentTemplate=_agentTemplate,\n        numAgentsAllowed=_numAgentsAllowed,\n        enforceCreatorWhitelist=_enforceCreatorWhitelist,\n        startingAgent=_startingAgent,\n        startingAgentActivationLength=_startingAgentActivationLength,\n    )\n\n    confirmationBlock: uint256 = timeLock._getActionConfirmationBlock(aid)\n    if _actionType == ActionType.AGENT_TEMPLATE:\n        log PendingAgentTemplateChange(\n            agentTemplate=_agentTemplate,\n            confirmationBlock=confirmationBlock,\n            actionId=aid,\n        )\n    elif _actionType == ActionType.AGENT_CREATION_LIMITS:\n        log PendingAgentCreationLimitsChange(\n            numAgentsAllowed=_numAgentsAllowed,\n            enforceCreatorWhitelist=_enforceCreatorWhitelist,\n            confirmationBlock=confirmationBlock,\n            actionId=aid,\n        )\n    elif _actionType == ActionType.STARTER_AGENT_PARAMS:\n        log PendingStarterAgentParamsChange(\n            startingAgent=_startingAgent,\n            startingAgentActivationLength=_startingAgentActivationLength,\n            confirmationBlock=confirmationBlock,\n            actionId=aid,\n        )\n    return aid\n\n\n#############\n# Execution #\n#############\n\n\n@external\ndef executePendingAction(_aid: uint256) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    # check time lock\n    if not timeLock._confirmAction(_aid):\n        if timeLock._isExpired(_aid):\n            self._cancelPendingAction(_aid)\n        return False\n\n    actionType: ActionType = self.actionType[_aid]\n    mc: address = addys._getMissionControlAddr()\n\n    if actionType == ActionType.USER_WALLET_TEMPLATES:\n        config: cs.UserWalletConfig = staticcall MissionControl(mc).userWalletConfig()\n        p: cs.UserWalletConfig = self.pendingUserWalletConfig[_aid]\n        config.walletTemplate = p.walletTemplate\n        config.configTemplate = p.configTemplate\n        extcall MissionControl(mc).setUserWalletConfig(config)\n        log UserWalletTemplatesSet(walletTemplate=p.walletTemplate, configTemplate=p.configTemplate)\n\n    elif actionType == ActionType.TRIAL_FUNDS:\n        config: cs.UserWalletConfig = staticcall MissionControl(mc).userWalletConfig()\n        p: cs.UserWalletConfig = self.pendingUserWalletConfig[_aid]\n        config.trialAsset = p.trialAsset\n        config.trialAmount = p.trialAmount\n        extcall MissionControl(mc).setUserWalletConfig(config)\n        log TrialFundsSet(trialAsset=p.trialAsset, trialAmount=p.trialAmount)\n\n    elif actionType == ActionType.WALLET_CREATION_LIMITS:\n        config: cs.UserWalletConfig = staticcall MissionControl(mc).userWalletConfig()\n        p: cs.UserWalletConfig = self.pendingUserWalletConfig[_aid]\n        config.numUserWalletsAllowed = p.numUserWalletsAllowed\n        config.enforceCreatorWhitelist = p.enforceCreatorWhitelist\n        extcall MissionControl(mc).setUserWalletConfig(config)\n        log WalletCreationLimitsSet(numUserWalletsAllowed=p.numUserWalletsAllowed, enforceCreatorWhitelist=p.enforceCreatorWhitelist)\n\n    elif actionType == ActionType.KEY_ACTION_TIMELOCK_BOUNDS:\n        config: cs.UserWalletConfig = staticcall MissionControl(mc).userWalletConfig()\n        p: cs.UserWalletConfig = self.pendingUserWalletConfig[_aid]\n        config.minKeyActionTimeLock = p.minKeyActionTimeLock\n        config.maxKeyActionTimeLock = p.maxKeyActionTimeLock\n        extcall MissionControl(mc).setUserWalletConfig(config)\n        log KeyActionTimelockBoundsSet(minKeyActionTimeLock=p.minKeyActionTimeLock, maxKeyActionTimeLock=p.maxKeyActionTimeLock)\n\n    elif actionType == ActionType.DEFAULT_STALE_BLOCKS:\n        config: cs.UserWalletConfig = staticcall MissionControl(mc).userWalletConfig()\n        p: cs.UserWalletConfig = self.pendingUserWalletConfig[_aid]\n        config.defaultStaleBlocks = p.defaultStaleBlocks\n        extcall MissionControl(mc).setUserWalletConfig(config)\n        log DefaultStaleBlocksSet(defaultStaleBlocks=p.defaultStaleBlocks)\n\n    elif actionType == ActionType.TX_FEES:\n        config: cs.UserWalletConfig = staticcall MissionControl(mc).userWalletConfig()\n        p: cs.UserWalletConfig = self.pendingUserWalletConfig[_aid]\n        config.txFees = p.txFees\n        extcall MissionControl(mc).setUserWalletConfig(config)\n        log TxFeesSet(swapFee=p.txFees.swapFee, stableSwapFee=p.txFees.stableSwapFee, rewardsFee=p.txFees.rewardsFee)\n\n    elif actionType == ActionType.AMBASSADOR_REV_SHARE:\n        config: cs.UserWalletConfig = staticcall MissionControl(mc).userWalletConfig()\n        p: cs.UserWalletConfig = self.pendingUserWalletConfig[_aid]\n        config.ambassadorRevShare = p.ambassadorRevShare\n        extcall MissionControl(mc).setUserWalletConfig(config)\n        log AmbassadorRevShareSet(swapRatio=p.ambassadorRevShare.swapRatio, rewardsRatio=p.ambassadorRevShare.rewardsRatio, yieldRatio=p.ambassadorRevShare.yieldRatio)\n\n    elif actionType == ActionType.DEFAULT_YIELD_PARAMS:\n        config: cs.UserWalletConfig = staticcall MissionControl(mc).userWalletConfig()\n        p: cs.UserWalletConfig = self.pendingUserWalletConfig[_aid]\n        config.defaultYieldMaxIncrease = p.defaultYieldMaxIncrease\n        config.defaultYieldPerformanceFee = p.defaultYieldPerformanceFee\n        config.defaultYieldAmbassadorBonusRatio = p.defaultYieldAmbassadorBonusRatio\n        config.defaultYieldBonusRatio = p.defaultYieldBonusRatio\n        config.defaultYieldAltBonusAsset = p.defaultYieldAltBonusAsset\n        extcall MissionControl(mc).setUserWalletConfig(config)\n        log DefaultYieldParamsSet(\n            defaultYieldMaxIncrease=p.defaultYieldMaxIncrease,\n            defaultYieldPerformanceFee=p.defaultYieldPerformanceFee,\n            defaultYieldAmbassadorBonusRatio=p.defaultYieldAmbassadorBonusRatio,\n            defaultYieldBonusRatio=p.defaultYieldBonusRatio,\n            defaultYieldAltBonusAsset=p.defaultYieldAltBonusAsset\n        )\n\n    elif actionType == ActionType.LOOT_PARAMS:\n        config: cs.UserWalletConfig = staticcall MissionControl(mc).userWalletConfig()\n        p: cs.UserWalletConfig = self.pendingUserWalletConfig[_aid]\n        config.depositRewardsAsset = p.depositRewardsAsset\n        config.lootClaimCoolOffPeriod = p.lootClaimCoolOffPeriod\n        extcall MissionControl(mc).setUserWalletConfig(config)\n        log LootParamsSet(depositRewardsAsset=p.depositRewardsAsset, lootClaimCoolOffPeriod=p.lootClaimCoolOffPeriod)\n\n    elif actionType == ActionType.ASSET_CONFIG:\n        p: PendingAssetConfig = self.pendingAssetConfig[_aid]\n        extcall MissionControl(mc).setAssetConfig(p.asset, p.config)\n        log AssetConfigSet(\n            asset=p.asset,\n            legoId=p.config.legoId,\n            staleBlocks=p.config.staleBlocks,\n            txFeesSwapFee=p.config.txFees.swapFee,\n            txFeesStableSwapFee=p.config.txFees.stableSwapFee,\n            txFeesRewardsFee=p.config.txFees.rewardsFee,\n            ambassadorRevShareSwapRatio=p.config.ambassadorRevShare.swapRatio,\n            ambassadorRevShareRewardsRatio=p.config.ambassadorRevShare.rewardsRatio,\n            ambassadorRevShareYieldRatio=p.config.ambassadorRevShare.yieldRatio,\n            isYieldAsset=p.config.yieldConfig.isYieldAsset,\n            isRebasing=p.config.yieldConfig.isRebasing,\n            underlyingAsset=p.config.yieldConfig.underlyingAsset,\n            maxYieldIncrease=p.config.yieldConfig.maxYieldIncrease,\n            performanceFee=p.config.yieldConfig.performanceFee,\n            ambassadorBonusRatio=p.config.yieldConfig.ambassadorBonusRatio,\n            bonusRatio=p.config.yieldConfig.bonusRatio,\n            altBonusAsset=p.config.yieldConfig.altBonusAsset,\n        )\n\n    elif actionType == ActionType.IS_STABLECOIN:\n        p: IsAddrAllowed = self.pendingAddrToBool[_aid]\n        extcall MissionControl(mc).setIsStablecoin(p.addr, p.isAllowed)\n        log IsStablecoinSet(asset=p.addr, isStablecoin=p.isAllowed)\n\n    elif actionType == ActionType.AGENT_TEMPLATE:\n        config: cs.AgentConfig = staticcall MissionControl(mc).agentConfig()\n        p: cs.AgentConfig = self.pendingAgentConfig[_aid]\n        config.agentTemplate = p.agentTemplate\n        extcall MissionControl(mc).setAgentConfig(config)\n        log AgentTemplateSet(agentTemplate=p.agentTemplate)\n\n    elif actionType == ActionType.AGENT_CREATION_LIMITS:\n        config: cs.AgentConfig = staticcall MissionControl(mc).agentConfig()\n        p: cs.AgentConfig = self.pendingAgentConfig[_aid]\n        config.numAgentsAllowed = p.numAgentsAllowed\n        config.enforceCreatorWhitelist = p.enforceCreatorWhitelist\n        extcall MissionControl(mc).setAgentConfig(config)\n        log AgentCreationLimitsSet(numAgentsAllowed=p.numAgentsAllowed, enforceCreatorWhitelist=p.enforceCreatorWhitelist)\n\n    elif actionType == ActionType.STARTER_AGENT_PARAMS:\n        config: cs.AgentConfig = staticcall MissionControl(mc).agentConfig()\n        p: cs.AgentConfig = self.pendingAgentConfig[_aid]\n        config.startingAgent = p.startingAgent\n        config.startingAgentActivationLength = p.startingAgentActivationLength\n        extcall MissionControl(mc).setAgentConfig(config)\n        log StarterAgentParamsSet(startingAgent=p.startingAgent, startingAgentActivationLength=p.startingAgentActivationLength)\n\n    elif actionType == ActionType.MANAGER_CONFIG:\n        p: cs.ManagerConfig = self.pendingManagerConfig[_aid]\n        extcall MissionControl(mc).setManagerConfig(p)\n        log ManagerConfigSet(managerPeriod=p.managerPeriod, managerActivationLength=p.managerActivationLength)\n\n    elif actionType == ActionType.PAYEE_CONFIG:\n        p: cs.PayeeConfig = self.pendingPayeeConfig[_aid]\n        extcall MissionControl(mc).setPayeeConfig(p)\n        log PayeeConfigSet(payeePeriod=p.payeePeriod, payeeActivationLength=p.payeeActivationLength)\n\n    elif actionType == ActionType.CAN_PERFORM_SECURITY_ACTION:\n        data: IsAddrAllowed = self.pendingAddrToBool[_aid]\n        extcall MissionControl(mc).setCanPerformSecurityAction(data.addr, data.isAllowed)\n        log CanPerformSecurityAction(signer=data.addr, canPerform=data.isAllowed)\n\n    self.actionType[_aid] = empty(ActionType)\n    return True\n\n\n# cancel action\n\n\n@external\ndef cancelPendingAction(_aid: uint256) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    self._cancelPendingAction(_aid)\n    return True\n\n\n@internal\ndef _cancelPendingAction(_aid: uint256):\n    assert timeLock._cancelAction(_aid) # dev: cannot cancel action\n    self.actionType[_aid] = empty(ActionType)\n",
            "sha256sum": "096d2e8eb04fbafb1eaba50c75f5febba5840a83d8ac2981817043d94f0d0feb"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/config/SwitchboardAlpha.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.3+commit.bff19ea2",
        "integrity": "82a76e3fc2fd401e3cf4f48abe66e5aa4973ddc7d45b6c1462f9eaaf86ce91e7"
      },
      "args": "00000000000000000000000044cf3c4f000dfd76a35d03298049d37be688d6f900000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000e10000000000000000000000000000000000000000000000000000000000013c680",
      "file": "contracts/config/SwitchboardAlpha.vy"
    },
    "SwitchboardBravo": {
      "address": "0xf1F5938559884D3c54400b417292B93cd81C368c",
      "abi": [
        {
          "name": "PendingRecoverFundsAction",
          "inputs": [
            {
              "name": "contractAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PendingRecoverFundsManyAction",
          "inputs": [
            {
              "name": "contractAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "numAssets",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PendingRecoverNftAction",
          "inputs": [
            {
              "name": "contractAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "collection",
              "type": "address",
              "indexed": true
            },
            {
              "name": "nftTokenId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PendingLootAdjustAction",
          "inputs": [
            {
              "name": "user",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newClaimable",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PendingRecoverDepositRewardsAction",
          "inputs": [
            {
              "name": "lootAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetDataUpdated",
          "inputs": [
            {
              "name": "numUsers",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "caller",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AllAssetDataUpdated",
          "inputs": [
            {
              "name": "numUsers",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "caller",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PendingSetEjectionModeAction",
          "inputs": [
            {
              "name": "user",
              "type": "address",
              "indexed": true
            },
            {
              "name": "shouldEject",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PauseExecuted",
          "inputs": [
            {
              "name": "contractAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "shouldPause",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "RecoverFundsExecuted",
          "inputs": [
            {
              "name": "contractAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "RecoverFundsManyExecuted",
          "inputs": [
            {
              "name": "contractAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "numAssets",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "RecoverNftExecuted",
          "inputs": [
            {
              "name": "contractAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "collection",
              "type": "address",
              "indexed": true
            },
            {
              "name": "nftTokenId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "ClawbackTrialFundsExecuted",
          "inputs": [
            {
              "name": "numUsers",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "DepositPointsUpdated",
          "inputs": [
            {
              "name": "numUsers",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "caller",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LootClaimedForUser",
          "inputs": [
            {
              "name": "user",
              "type": "address",
              "indexed": true
            },
            {
              "name": "caller",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LootClaimedForManyUsers",
          "inputs": [
            {
              "name": "numUsers",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "caller",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LootAdjusted",
          "inputs": [
            {
              "name": "user",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newClaimable",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "RecoverDepositRewardsExecuted",
          "inputs": [
            {
              "name": "lootAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "SetEjectionModeExecuted",
          "inputs": [
            {
              "name": "user",
              "type": "address",
              "indexed": true
            },
            {
              "name": "shouldEject",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeTimeLockModified",
          "inputs": [
            {
              "name": "prevTimeLock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "newTimeLock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "ExpirationSet",
          "inputs": [
            {
              "name": "expiration",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "ActionTimeLockSet",
          "inputs": [
            {
              "name": "newTimeLock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "prevTimeLock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeStarted",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeConfirmed",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeCancelled",
          "inputs": [
            {
              "name": "cancelledGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovRelinquished",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UndyHqSetupFinished",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "timeLock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddys",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "undyToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "hatchery",
                  "type": "address"
                },
                {
                  "name": "lootDistributor",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                },
                {
                  "name": "walletBackpack",
                  "type": "address"
                },
                {
                  "name": "billing",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUndyHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUndyHqFromGov",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canGovern",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getGovernors",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPendingGovChange",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "startGovernanceChange",
          "inputs": [
            {
              "name": "_newGov",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "relinquishGov",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setGovTimeLock",
          "inputs": [
            {
              "name": "_numBlocks",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidGovTimeLock",
          "inputs": [
            {
              "name": "_newTimeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "minGovChangeTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "maxGovChangeTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "finishUndyHqSetup",
          "inputs": [
            {
              "name": "_newGov",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "finishUndyHqSetup",
          "inputs": [
            {
              "name": "_newGov",
              "type": "address"
            },
            {
              "name": "_timeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "governance",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingGov",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "newGov",
                  "type": "address"
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numGovChanges",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "govChangeTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canConfirmAction",
          "inputs": [
            {
              "name": "_actionId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isExpired",
          "inputs": [
            {
              "name": "_actionId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPendingAction",
          "inputs": [
            {
              "name": "_actionId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getActionConfirmationBlock",
          "inputs": [
            {
              "name": "_actionId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setActionTimeLock",
          "inputs": [
            {
              "name": "_newTimeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidActionTimeLock",
          "inputs": [
            {
              "name": "_newTimeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "minActionTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "maxActionTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setExpiration",
          "inputs": [
            {
              "name": "_expiration",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setActionTimeLockAfterSetup",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setActionTimeLockAfterSetup",
          "inputs": [
            {
              "name": "_newTimeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingActions",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                },
                {
                  "name": "expiration",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "actionId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "actionTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "expiration",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pause",
          "inputs": [
            {
              "name": "_contractAddr",
              "type": "address"
            },
            {
              "name": "_shouldPause",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_contractAddr",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFundsMany",
          "inputs": [
            {
              "name": "_contractAddr",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_assets",
              "type": "address[]"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverNft",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            },
            {
              "name": "_collection",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "clawBackTrialFunds",
          "inputs": [
            {
              "name": "_users",
              "type": "address[]"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimLootForUser",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimLootForManyUsers",
          "inputs": [
            {
              "name": "_users",
              "type": "address[]"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "adjustLoot",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_newClaimable",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverDepositRewards",
          "inputs": [
            {
              "name": "_lootAddr",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "updateDepositPoints",
          "inputs": [
            {
              "name": "_users",
              "type": "address[]"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "updateAssetData",
          "inputs": [
            {
              "name": "_bundles",
              "type": "tuple[]",
              "components": [
                {
                  "name": "user",
                  "type": "address"
                },
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "shouldCheckYield",
                  "type": "bool"
                }
              ]
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "updateAllAssetData",
          "inputs": [
            {
              "name": "_bundles",
              "type": "tuple[]",
              "components": [
                {
                  "name": "user",
                  "type": "address"
                },
                {
                  "name": "shouldCheckYield",
                  "type": "bool"
                }
              ]
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setEjectionMode",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_shouldEject",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "executePendingAction",
          "inputs": [
            {
              "name": "_aid",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelPendingAction",
          "inputs": [
            {
              "name": "_aid",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "actionType",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingPauseActions",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "contractAddr",
                  "type": "address"
                },
                {
                  "name": "shouldPause",
                  "type": "bool"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingRecoverFundsActions",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "contractAddr",
                  "type": "address"
                },
                {
                  "name": "recipient",
                  "type": "address"
                },
                {
                  "name": "asset",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingRecoverFundsManyActions",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "contractAddr",
                  "type": "address"
                },
                {
                  "name": "recipient",
                  "type": "address"
                },
                {
                  "name": "assets",
                  "type": "address[]"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingRecoverNftActions",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "contractAddr",
                  "type": "address"
                },
                {
                  "name": "collection",
                  "type": "address"
                },
                {
                  "name": "nftTokenId",
                  "type": "uint256"
                },
                {
                  "name": "recipient",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingLootAdjustActions",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "user",
                  "type": "address"
                },
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "newClaimable",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingRecoverDepositRewardsActions",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "lootAddr",
                  "type": "address"
                },
                {
                  "name": "recipient",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingSetEjectionModeActions",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "user",
                  "type": "address"
                },
                {
                  "name": "shouldEject",
                  "type": "bool"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_undyHq",
              "type": "address"
            },
            {
              "name": "_tempGov",
              "type": "address"
            },
            {
              "name": "_minConfigTimeLock",
              "type": "uint256"
            },
            {
              "name": "_maxConfigTimeLock",
              "type": "uint256"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/modules/Addys.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\ninterface UndyHq:\n    def isValidAddr(_addr: address) -> bool: view\n    def getAddr(_regId: uint256) -> address: view\n    def undyToken() -> address: view\n\ninterface Switchboard:\n    def isSwitchboardAddr(_addr: address) -> bool: view\n\ninterface LegoBook:\n    def isLegoAddr(_addr: address) -> bool: view\n\nstruct Addys:\n    hq: address\n    undyToken: address\n    ledger: address\n    missionControl: address\n    legoBook: address\n    switchboard: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    walletBackpack: address\n    billing: address\n\n# hq\nUNDY_HQ_FOR_ADDYS: immutable(address)\n\n# core addys\nLEDGER_ID: constant(uint256) = 1\nMISSION_CONTROL_ID: constant(uint256) = 2\nLEGO_BOOK_ID: constant(uint256) = 3\nSWITCHBOARD_ID: constant(uint256) = 4\nHATCHERY_ID: constant(uint256) = 5\nLOOT_DISTRIBUTOR_ID: constant(uint256) = 6\nAPPRAISER_ID: constant(uint256) = 7\nWALLET_BACKPACK_ID: constant(uint256) = 8\nBILLING_ID: constant(uint256) = 9\n\n\n@deploy\ndef __init__(_undyHq: address):\n    assert _undyHq != empty(address) # dev: invalid undy hq\n    UNDY_HQ_FOR_ADDYS = _undyHq\n\n\n########\n# Core #\n########\n\n\n@view\n@external\ndef getAddys() -> Addys:\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _getAddys(_addys: Addys = empty(Addys)) -> Addys:\n    if _addys.hq != empty(address):\n        return _addys\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _generateAddys() -> Addys:\n    hq: address = UNDY_HQ_FOR_ADDYS\n    return Addys(\n        hq = hq,\n        undyToken = staticcall UndyHq(hq).undyToken(),\n        ledger = staticcall UndyHq(hq).getAddr(LEDGER_ID),\n        missionControl = staticcall UndyHq(hq).getAddr(MISSION_CONTROL_ID),\n        legoBook = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID),\n        switchboard = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID),\n        hatchery = staticcall UndyHq(hq).getAddr(HATCHERY_ID),\n        lootDistributor = staticcall UndyHq(hq).getAddr(LOOT_DISTRIBUTOR_ID),\n        appraiser = staticcall UndyHq(hq).getAddr(APPRAISER_ID),\n        walletBackpack = staticcall UndyHq(hq).getAddr(WALLET_BACKPACK_ID),\n        billing = staticcall UndyHq(hq).getAddr(BILLING_ID),\n    )\n\n\n##########\n# Tokens #\n##########\n\n\n@view\n@internal\ndef _getUndyToken() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).undyToken()\n\n\n###########\n# Helpers #\n###########\n\n\n# undy hq\n\n\n@view\n@external\ndef getUndyHq() -> address:\n    return self._getUndyHq()\n\n\n@view\n@internal\ndef _getUndyHq() -> address:\n    return UNDY_HQ_FOR_ADDYS\n\n\n# utils\n\n\n@view\n@internal\ndef _isValidUndyAddr(_addr: address, _hq: address = empty(address)) -> bool:\n    hq: address = _hq\n    if _hq == empty(address):\n        hq = UNDY_HQ_FOR_ADDYS\n    \n    # core departments\n    if staticcall UndyHq(hq).isValidAddr(_addr):\n        return True\n\n    # lego book\n    legoBook: address = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID)\n    if legoBook != empty(address) and staticcall LegoBook(legoBook).isLegoAddr(_addr):\n        return True\n\n    # switchboard config\n    switchboard: address = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID)\n    if switchboard != empty(address) and staticcall Switchboard(switchboard).isSwitchboardAddr(_addr):\n        return True\n\n    return False\n\n\n@view\n@internal\ndef _isSwitchboardAddr(_addr: address) -> bool:\n    switchboard: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n    if switchboard == empty(address):\n        return False\n    return staticcall Switchboard(switchboard).isSwitchboardAddr(_addr)\n\n\n@view\n@internal\ndef _isLegoBookAddr(_addr: address) -> bool:\n    legoBook: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n    if legoBook == empty(address):\n        return False\n    return staticcall LegoBook(legoBook).isLegoAddr(_addr)\n\n\n###############\n# Departments #\n###############\n\n\n# ledger\n\n\n@view\n@internal\ndef _getLedgerId() -> uint256:\n    return LEDGER_ID\n\n\n@view\n@internal\ndef _getLedgerAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEDGER_ID)\n\n\n# mission control\n\n\n@view\n@internal\ndef _getMissionControlId() -> uint256:\n    return MISSION_CONTROL_ID\n\n\n@view\n@internal\ndef _getMissionControlAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(MISSION_CONTROL_ID)\n\n\n# lego book\n\n\n@view\n@internal\ndef _getLegoBookId() -> uint256:\n    return LEGO_BOOK_ID\n\n\n@view\n@internal\ndef _getLegoBookAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n\n\n# switchboard\n\n\n@view\n@internal\ndef _getSwitchboardId() -> uint256:\n    return SWITCHBOARD_ID\n\n\n@view\n@internal\ndef _getSwitchboardAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n\n\n# hatchery\n\n\n@view\n@internal\ndef _getHatcheryId() -> uint256:\n    return HATCHERY_ID\n\n\n@view\n@internal\ndef _getHatcheryAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(HATCHERY_ID)\n\n\n# loot distributor\n\n\n@view\n@internal\ndef _getLootDistributorId() -> uint256:\n    return LOOT_DISTRIBUTOR_ID\n\n\n@view\n@internal\ndef _getLootDistributorAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LOOT_DISTRIBUTOR_ID)\n\n\n# appraiser\n\n\n@view\n@internal\ndef _getAppraiserId() -> uint256:\n    return APPRAISER_ID\n\n\n@view\n@internal\ndef _getAppraiserAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(APPRAISER_ID)\n\n\n# wallet backpack\n\n\n@view\n@internal\ndef _getWalletBackpackId() -> uint256:\n    return WALLET_BACKPACK_ID\n\n\n@view\n@internal\ndef _getWalletBackpackAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(WALLET_BACKPACK_ID)\n\n\n# billing\n\n\n@view\n@internal\ndef _getBillingId() -> uint256:\n    return BILLING_ID\n\n\n@view\n@internal\ndef _getBillingAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(BILLING_ID)",
            "sha256sum": "78b58f0b2acb2eaafa4d21adf9135a1cd0e1d53897f7a1fa70a83a04a7738ad3"
          },
          "contracts/modules/LocalGov.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\ninterface UndyHq:\n    def minGovChangeTimeLock() -> uint256: view\n    def maxGovChangeTimeLock() -> uint256: view\n    def governance() -> address: view\n\nstruct PendingGovernance:\n    newGov: address\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeStarted:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    confirmBlock: uint256\n\nevent GovChangeConfirmed:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeCancelled:\n    cancelledGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovRelinquished:\n    prevGov: indexed(address)\n\nevent GovChangeTimeLockModified:\n    prevTimeLock: uint256\n    newTimeLock: uint256\n\nevent UndyHqSetupFinished:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    timeLock: uint256\n\n# governance\ngovernance: public(address)\npendingGov: public(PendingGovernance)\nnumGovChanges: public(uint256)\n\n# time lock\ngovChangeTimeLock: public(uint256)\n\n# config\nUNDY_HQ_FOR_GOV: immutable(address)\nMIN_GOV_TIME_LOCK: immutable(uint256)\nMAX_GOV_TIME_LOCK: immutable(uint256)\n\n\n@deploy\ndef __init__(\n    _undyHq: address,\n    _initialGov: address,\n    _minTimeLock: uint256,\n    _maxTimeLock: uint256,\n    _initialTimeLock: uint256,\n):\n    UNDY_HQ_FOR_GOV = _undyHq\n    self.governance = _initialGov\n\n    # undy hq\n    if _undyHq == empty(address):\n        assert _initialGov != empty(address) # dev: undy hq must have gov\n\n    # local gov (department, other smart contracts)\n    else:\n        hqGov: address = staticcall UndyHq(_undyHq).governance()\n        assert hqGov != empty(address) # dev: undy hq must have gov\n        assert _initialGov != hqGov # dev: undy hq cannot set same gov\n\n    # time locks\n    minTimeLock: uint256 = _minTimeLock\n    maxTimeLock: uint256 = _maxTimeLock\n    if minTimeLock == 0 or maxTimeLock == 0:\n        assert _undyHq != empty(address) # dev: need undy hq if no time locks\n        minTimeLock = staticcall UndyHq(_undyHq).minGovChangeTimeLock()\n        maxTimeLock = staticcall UndyHq(_undyHq).maxGovChangeTimeLock()\n\n    # set min and max time locks\n    assert minTimeLock < maxTimeLock # dev: invalid time lock\n    assert minTimeLock != 0 and maxTimeLock != max_value(uint256) # dev: invalid time lock\n    MIN_GOV_TIME_LOCK = minTimeLock\n    MAX_GOV_TIME_LOCK = maxTimeLock\n\n    # this contract is top level governance from Undy HQ -- not setting initial time lock during setup\n    if _undyHq == empty(address):\n        return\n\n    # set initial time lock (for local gov)\n    initialTimeLock: uint256 = max(minTimeLock, _initialTimeLock)\n    assert self._setGovTimeLock(initialTimeLock) # dev: invalid time lock\n\n\n@view\n@external\ndef getUndyHqFromGov() -> address:\n    return self._getUndyHqFromGov()\n\n\n@view\n@internal\ndef _getUndyHqFromGov() -> address:\n    return UNDY_HQ_FOR_GOV\n\n\n##############\n# Gov Access #\n##############\n\n\n@view\n@external\ndef canGovern(_addr: address) -> bool:\n    return self._canGovern(_addr)\n\n\n@view\n@internal\ndef _canGovern(_addr: address) -> bool:\n    if _addr == empty(address):\n        return False\n    return _addr in self._getGovernors()\n\n\n@view\n@external\ndef getGovernors() -> DynArray[address, 2]:\n    return self._getGovernors()\n\n\n@view\n@internal\ndef _getGovernors() -> DynArray[address, 2]:\n    governors: DynArray[address, 2] = []\n\n    # local governance\n    localGov: address = self.governance\n    if localGov != empty(address):\n        governors.append(localGov)\n\n    # undy hq governance\n    undyHq: address = UNDY_HQ_FOR_GOV\n    if undyHq == empty(address):\n        return governors\n\n    hqGov: address = staticcall UndyHq(undyHq).governance()\n    if hqGov != empty(address):\n        governors.append(hqGov)\n\n    return governors\n\n\n######################\n# Governance Changes #\n######################\n\n\n@view\n@external\ndef hasPendingGovChange() -> bool:\n    return self.pendingGov.confirmBlock != 0\n\n\n@view\n@internal\ndef _isUndyHq() -> bool:\n    return UNDY_HQ_FOR_GOV == empty(address)\n\n\n# start gov change\n\n\n@external\ndef startGovernanceChange(_newGov: address):\n    governors: DynArray[address, 2] = self._getGovernors()\n    assert msg.sender in governors # dev: no perms\n\n    # validation\n    if _newGov != empty(address):\n        assert _newGov not in governors # dev: invalid _newGov\n        assert _newGov.is_contract # dev: _newGov must be a contract\n    else:\n        assert not self._isUndyHq() # dev: undy hq cannot set 0x0\n\n    confirmBlock: uint256 = block.number + self.govChangeTimeLock\n    self.pendingGov = PendingGovernance(\n        newGov= _newGov,\n        initiatedBlock= block.number,\n        confirmBlock= confirmBlock,\n    )\n    log GovChangeStarted(prevGov=self.governance, newGov=_newGov, confirmBlock=confirmBlock)\n\n\n# confirm gov change\n\n\n@external\ndef confirmGovernanceChange():\n    data: PendingGovernance = self.pendingGov\n    assert data.confirmBlock != 0 and block.number >= data.confirmBlock # dev: time lock not reached\n\n    # check permissions\n    if data.newGov != empty(address):\n        assert msg.sender == data.newGov # dev: only new gov can confirm\n    else:\n        assert self._canGovern(msg.sender) # dev: no perms\n        assert not self._isUndyHq() # dev: undy hq cannot set 0x0\n\n    # set new governance\n    prevGov: address = self.governance\n    self.governance = data.newGov\n    self.numGovChanges += 1\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeConfirmed(prevGov=prevGov, newGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n# cancel gov change\n\n\n@external\ndef cancelGovernanceChange():\n    assert self._canGovern(msg.sender) # dev: no perms\n    data: PendingGovernance = self.pendingGov\n    assert data.confirmBlock != 0 # dev: no pending change\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeCancelled(cancelledGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n# relinquish gov (only for local gov)\n\n\n@external\ndef relinquishGov():\n    assert msg.sender == self.governance # dev: no perms\n    assert not self._isUndyHq() # dev: undy hq cannot relinquish gov\n\n    self.governance = empty(address)\n    self.numGovChanges += 1\n    log GovRelinquished(prevGov=msg.sender)\n\n\n####################\n# Time Lock Config #\n####################\n\n\n# set time lock\n\n\n@external\ndef setGovTimeLock(_numBlocks: uint256) -> bool:\n    assert self._canGovern(msg.sender) # dev: no perms\n    return self._setGovTimeLock(_numBlocks)\n\n\n@internal\ndef _setGovTimeLock(_numBlocks: uint256) -> bool:\n    prevTimeLock: uint256 = self.govChangeTimeLock\n    assert self._isValidGovTimeLock(_numBlocks, prevTimeLock) # dev: invalid time lock\n    self.govChangeTimeLock = _numBlocks\n    log GovChangeTimeLockModified(prevTimeLock=prevTimeLock, newTimeLock=_numBlocks)\n    return True\n\n\n# validation\n\n\n@view\n@external\ndef isValidGovTimeLock(_newTimeLock: uint256) -> bool:\n    return self._isValidGovTimeLock(_newTimeLock, self.govChangeTimeLock)\n\n\n@view\n@internal\ndef _isValidGovTimeLock(_newTimeLock: uint256, _prevTimeLock: uint256) -> bool:\n    if _newTimeLock == _prevTimeLock:\n        return False # no change\n    if self.pendingGov.confirmBlock != 0:\n        return False # cannot change while pending gov change\n    return _newTimeLock >= MIN_GOV_TIME_LOCK and _newTimeLock <= MAX_GOV_TIME_LOCK\n\n\n# utils\n\n\n@view\n@external\ndef minGovChangeTimeLock() -> uint256:\n    return MIN_GOV_TIME_LOCK\n\n\n@view\n@external\ndef maxGovChangeTimeLock() -> uint256:\n    return MAX_GOV_TIME_LOCK\n\n\n#################\n# Undy Hq Setup #\n#################\n\n\n@external\ndef finishUndyHqSetup(_newGov: address, _timeLock: uint256 = 0) -> bool:\n    assert self._isUndyHq() # dev: only undy hq\n    assert msg.sender == self.governance # dev: no perms\n    assert self.numGovChanges == 0 # dev: already changed gov\n\n    # validation\n    assert _newGov != empty(address) and _newGov.is_contract # dev: invalid _newGov\n    prevGov: address = self.governance\n\n    # set new gov\n    self.governance = _newGov\n    self.numGovChanges += 1\n\n    # set time lock\n    timeLock: uint256 = _timeLock\n    if timeLock == 0:\n        timeLock = MIN_GOV_TIME_LOCK\n    assert self._setGovTimeLock(timeLock) # dev: invalid time lock\n\n    log UndyHqSetupFinished(prevGov=prevGov, newGov=_newGov, timeLock=timeLock)\n    return True",
            "sha256sum": "c41aa3e0d0d96b512171813377ea277e2c7da690c3cd9b4662733b3f11f705b0"
          },
          "contracts/modules/TimeLock.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nuses: gov\nimport contracts.modules.LocalGov as gov\n\nstruct PendingAction:\n    initiatedBlock: uint256\n    confirmBlock: uint256\n    expiration: uint256\n\nevent ActionTimeLockSet:\n    newTimeLock: uint256\n    prevTimeLock: uint256\n\nevent ExpirationSet:\n    expiration: uint256\n\n# core data\npendingActions: public(HashMap[uint256, PendingAction])\nactionId: public(uint256)\n\n# config\nactionTimeLock: public(uint256)\nexpiration: public(uint256)\n\nMIN_ACTION_TIMELOCK: immutable(uint256)\nMAX_ACTION_TIMELOCK: immutable(uint256)\n\n\n@deploy\ndef __init__(\n    _minActionTimeLock: uint256,\n    _maxActionTimeLock: uint256,\n    _initialTimeLock: uint256,\n    _expiration: uint256,\n):\n    # start at 1 index\n    self.actionId = 1\n\n    # set time lock boundaries\n    assert _minActionTimeLock < _maxActionTimeLock # dev: invalid time lock boundaries\n    assert _minActionTimeLock != 0 and _maxActionTimeLock != max_value(uint256) # dev: invalid time lock boundaries\n    MIN_ACTION_TIMELOCK = _minActionTimeLock\n    MAX_ACTION_TIMELOCK = _maxActionTimeLock\n\n    # set expiration time\n    self._setExpiration(_expiration, _initialTimeLock)\n\n    # set initial time lock\n    if _initialTimeLock != 0:\n        assert self._setActionTimeLock(_initialTimeLock, 0) # dev: failed to set initial time lock\n\n\n########\n# Core #\n########\n\n\n# initiate\n\n\n@internal\ndef _initiateAction() -> uint256:\n    actionId: uint256 = self.actionId\n    confirmBlock: uint256 = block.number + self.actionTimeLock\n    self.pendingActions[actionId] = PendingAction(\n        initiatedBlock= block.number,\n        confirmBlock= confirmBlock,\n        expiration= confirmBlock + self.expiration,\n    )\n    self.actionId += 1\n    return actionId\n\n\n# confirm\n\n\n@internal\ndef _confirmAction(_actionId: uint256) -> bool:\n    if not self._canConfirmAction(_actionId):\n        return False\n    self.pendingActions[_actionId] = empty(PendingAction)\n    return True\n\n\n# cancel\n\n\n@internal\ndef _cancelAction(_actionId: uint256) -> bool:\n    data: PendingAction = self.pendingActions[_actionId]\n    if data.confirmBlock == 0:\n        return False\n    self.pendingActions[_actionId] = empty(PendingAction)\n    return True\n\n\n#########\n# Utils #\n#########\n\n\n# can confirm\n\n\n@view\n@external\ndef canConfirmAction(_actionId: uint256) -> bool:\n    return self._canConfirmAction(_actionId)\n\n\n@view\n@internal\ndef _canConfirmAction(_actionId: uint256) -> bool:\n    data: PendingAction = self.pendingActions[_actionId]\n    if data.confirmBlock == 0 or block.number < data.confirmBlock:\n        return False\n    if block.number >= data.expiration:\n        return False\n    return True\n\n\n# is expired\n\n\n@view\n@external\ndef isExpired(_actionId: uint256) -> bool:\n    return self._isExpired(_actionId)\n\n\n@view\n@internal\ndef _isExpired(_actionId: uint256) -> bool:\n    data: PendingAction = self.pendingActions[_actionId]\n    if data.confirmBlock == 0:\n        return False\n    return block.number >= data.expiration\n\n\n# pending action\n\n\n@view\n@external\ndef hasPendingAction(_actionId: uint256) -> bool:\n    return self._hasPendingAction(_actionId)\n\n\n@view\n@internal\ndef _hasPendingAction(_actionId: uint256) -> bool:\n    return self.pendingActions[_actionId].confirmBlock != 0\n\n\n# confirmation block\n\n\n@view\n@external\ndef getActionConfirmationBlock(_actionId: uint256) -> uint256:\n    return self._getActionConfirmationBlock(_actionId)\n\n\n@view\n@internal\ndef _getActionConfirmationBlock(_actionId: uint256) -> uint256:\n    return self.pendingActions[_actionId].confirmBlock\n\n\n######################\n# Config - Time Lock #\n######################\n\n\n@external\ndef setActionTimeLock(_newTimeLock: uint256) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return self._setActionTimeLock(_newTimeLock, self.actionTimeLock)\n\n\n@internal\ndef _setActionTimeLock(_newTimeLock: uint256, _prevTimeLock: uint256) -> bool:\n    assert self._isValidActionTimeLock(_newTimeLock, _prevTimeLock) # dev: invalid time lock\n    self.actionTimeLock = _newTimeLock\n    log ActionTimeLockSet(newTimeLock=_newTimeLock, prevTimeLock=_prevTimeLock)\n    return True\n\n\n# validation\n\n\n@view\n@external\ndef isValidActionTimeLock(_newTimeLock: uint256) -> bool:\n    return self._isValidActionTimeLock(_newTimeLock, self.actionTimeLock)\n\n\n@view\n@internal\ndef _isValidActionTimeLock(_newTimeLock: uint256, _prevTimeLock: uint256) -> bool:\n    if _newTimeLock == _prevTimeLock:\n        return False # no change\n    return _newTimeLock >= MIN_ACTION_TIMELOCK and _newTimeLock <= MAX_ACTION_TIMELOCK\n\n\n# utils\n\n\n@view\n@external\ndef minActionTimeLock() -> uint256:\n    return MIN_ACTION_TIMELOCK\n\n\n@view\n@external\ndef maxActionTimeLock() -> uint256:\n    return MAX_ACTION_TIMELOCK\n\n\n#######################\n# Config - Expiration #\n#######################\n\n\n@external\ndef setExpiration(_expiration: uint256) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return self._setExpiration(_expiration, self.actionTimeLock)\n\n\n@internal\ndef _setExpiration(_expiration: uint256, _timeLock: uint256) -> bool:\n    assert self._isValidExpiration(_expiration, _timeLock) # dev: invalid expiration\n    self.expiration = _expiration\n    log ExpirationSet(expiration=_expiration)\n    return True\n\n\n# validation\n\n\n@view\n@internal\ndef _isValidExpiration(_expiration: uint256, _timeLock: uint256) -> bool:\n    if _expiration == 0 or _expiration == max_value(uint256):\n        return False\n    if _expiration < _timeLock:\n        return False\n    return True\n\n\n################\n# Finish Setup #\n################\n\n\n@external\ndef setActionTimeLockAfterSetup(_newTimeLock: uint256 = 0) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    prevTimeLock: uint256 = self.actionTimeLock\n    assert prevTimeLock == 0 # dev: already set\n\n    timeLock: uint256 = _newTimeLock\n    if timeLock == 0:\n        timeLock = MIN_ACTION_TIMELOCK\n    return self._setActionTimeLock(timeLock, prevTimeLock)",
            "sha256sum": "80ec25619b21a5ac9791a94ca96d5ee38a887cb59d0e9368e23ea4a2de75da8e"
          },
          "contracts/config/SwitchboardBravo.vy": {
            "content": "#        ______   __     __   __   ______  ______   __  __   ______   ______   ______   ______   _____    \n#       /\\  ___\\ /\\ \\  _ \\ \\ /\\ \\ /\\__  _\\/\\  ___\\ /\\ \\_\\ \\ /\\  == \\ /\\  __ \\ /\\  __ \\ /\\  == \\ /\\  __-.  \n#       \\ \\___  \\\\ \\ \\/ \".\\ \\\\ \\ \\\\/_/\\ \\/\\ \\ \\____\\ \\  __ \\\\ \\  __< \\ \\ \\/\\ \\\\ \\  __ \\\\ \\  __< \\ \\ \\/\\ \\ \n#        \\/\\_____\\\\ \\__/\".~\\_\\\\ \\_\\  \\ \\_\\ \\ \\_____\\\\ \\_\\ \\_\\\\ \\_____\\\\ \\_____\\\\ \\_\\ \\_\\\\ \\_\\ \\_\\\\ \\____- \n#         \\/_____/ \\/_/   \\/_/ \\/_/   \\/_/  \\/_____/ \\/_/\\/_/ \\/_____/ \\/_____/ \\/_/\\/_/ \\/_/ /_/ \\/____/ \n#                                                   \u2533\u2513        \n#                                                   \u2523\u252b\u250f\u2513\u250f\u2513\u2513\u250f\u250f\u2513\n#                                                   \u253b\u251b\u251b \u2517\u253b\u2517\u251b\u2517\u251b\n#\n#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nexports: addys.__interface__\nexports: gov.__interface__\nexports: timeLock.__interface__\n\ninitializes: addys\ninitializes: gov\ninitializes: timeLock[gov := gov]\n\nimport contracts.modules.Addys as addys\nimport contracts.modules.LocalGov as gov\nimport contracts.modules.TimeLock as timeLock\n\ninterface LootDistributor:\n    def adjustLoot(_user: address, _asset: address, _newClaimable: uint256) -> bool: nonpayable\n    def updateDepositPointsOnEjection(_user: address): nonpayable\n    def recoverDepositRewards(_recipient: address): nonpayable\n    def claimAllLoot(_user: address) -> bool: nonpayable\n    def updateDepositPoints(_user: address): nonpayable\n\ninterface UndyEcoContract:\n    def recoverFundsMany(_recipient: address, _assets: DynArray[address, MAX_RECOVER_ASSETS]): nonpayable\n    def recoverNft(_collection: address, _nftTokenId: uint256, _recipient: address): nonpayable\n    def recoverFunds(_recipient: address, _asset: address): nonpayable\n    def pause(_shouldPause: bool): nonpayable\n\ninterface UserWalletConfig:\n    def updateAssetData(_legoId: uint256, _asset: address, _shouldCheckYield: bool) -> uint256: nonpayable\n    def updateAllAssetData(_shouldCheckYield: bool) -> uint256: nonpayable\n    def setEjectionMode(_shouldEject: bool): nonpayable\n\ninterface Hatchery:\n    def clawBackTrialFunds(_user: address) -> uint256: nonpayable\n\ninterface MissionControl:\n    def canPerformSecurityAction(_signer: address) -> bool: view\n\ninterface Ledger:\n    def isUserWallet(_user: address) -> bool: view\n\ninterface UserWallet:\n    def walletConfig() -> address: view\n\nflag ActionType:\n    RECOVER_FUNDS\n    RECOVER_FUNDS_MANY\n    RECOVER_NFT\n    LOOT_ADJUST\n    RECOVER_DEPOSIT_REWARDS\n    SET_EJECTION_MODE\n\nstruct PauseAction:\n    contractAddr: address\n    shouldPause: bool\n\nstruct RecoverFundsAction:\n    contractAddr: address\n    recipient: address\n    asset: address\n\nstruct RecoverFundsManyAction:\n    contractAddr: address\n    recipient: address\n    assets: DynArray[address, MAX_RECOVER_ASSETS]\n\nstruct RecoverNftAction:\n    contractAddr: address\n    collection: address\n    nftTokenId: uint256\n    recipient: address\n\nstruct LootAdjustAction:\n    user: address\n    asset: address\n    newClaimable: uint256\n\nstruct RecoverDepositRewardsAction:\n    lootAddr: address\n    recipient: address\n\nstruct AssetDataUpdate:\n    user: address\n    legoId: uint256\n    asset: address\n    shouldCheckYield: bool\n\nstruct AllAssetDataUpdate:\n    user: address\n    shouldCheckYield: bool\n\nstruct SetEjectionModeAction:\n    user: address\n    shouldEject: bool\n\nevent PendingRecoverFundsAction:\n    contractAddr: indexed(address)\n    recipient: indexed(address)\n    asset: indexed(address)\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent PendingRecoverFundsManyAction:\n    contractAddr: indexed(address)\n    recipient: indexed(address)\n    numAssets: uint256\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent PendingRecoverNftAction:\n    contractAddr: indexed(address)\n    collection: indexed(address)\n    nftTokenId: uint256\n    recipient: indexed(address)\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent PendingLootAdjustAction:\n    user: indexed(address)\n    asset: indexed(address)\n    newClaimable: uint256\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent PendingRecoverDepositRewardsAction:\n    lootAddr: indexed(address)\n    recipient: indexed(address)\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent AssetDataUpdated:\n    numUsers: uint256\n    caller: indexed(address)\n\nevent AllAssetDataUpdated:\n    numUsers: uint256\n    caller: indexed(address)\n\nevent PendingSetEjectionModeAction:\n    user: indexed(address)\n    shouldEject: bool\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent PauseExecuted:\n    contractAddr: indexed(address)\n    shouldPause: bool\n\nevent RecoverFundsExecuted:\n    contractAddr: indexed(address)\n    recipient: indexed(address)\n    asset: indexed(address)\n\nevent RecoverFundsManyExecuted:\n    contractAddr: indexed(address)\n    recipient: indexed(address)\n    numAssets: uint256\n\nevent RecoverNftExecuted:\n    contractAddr: indexed(address)\n    collection: indexed(address)\n    nftTokenId: uint256\n    recipient: indexed(address)\n\nevent ClawbackTrialFundsExecuted:\n    numUsers: uint256\n\nevent DepositPointsUpdated:\n    numUsers: uint256\n    caller: indexed(address)\n\nevent LootClaimedForUser:\n    user: indexed(address)\n    caller: indexed(address)\n\nevent LootClaimedForManyUsers:\n    numUsers: uint256\n    caller: indexed(address)\n\nevent LootAdjusted:\n    user: indexed(address)\n    asset: indexed(address)\n    newClaimable: uint256\n\nevent RecoverDepositRewardsExecuted:\n    lootAddr: indexed(address)\n    recipient: indexed(address)\n\nevent SetEjectionModeExecuted:\n    user: indexed(address)\n    shouldEject: bool\n\n# pending actions storage\nactionType: public(HashMap[uint256, ActionType])\npendingPauseActions: public(HashMap[uint256, PauseAction])\npendingRecoverFundsActions: public(HashMap[uint256, RecoverFundsAction])\npendingRecoverFundsManyActions: public(HashMap[uint256, RecoverFundsManyAction])\npendingRecoverNftActions: public(HashMap[uint256, RecoverNftAction])\npendingLootAdjustActions: public(HashMap[uint256, LootAdjustAction])\npendingRecoverDepositRewardsActions: public(HashMap[uint256, RecoverDepositRewardsAction])\npendingSetEjectionModeActions: public(HashMap[uint256, SetEjectionModeAction])\n\nMAX_RECOVER_ASSETS: constant(uint256) = 20\nMAX_USERS: constant(uint256) = 50\n\n\n@deploy\ndef __init__(\n    _undyHq: address,\n    _tempGov: address,\n    _minConfigTimeLock: uint256,\n    _maxConfigTimeLock: uint256,\n):\n    addys.__init__(_undyHq)\n    gov.__init__(_undyHq, _tempGov, 0, 0, 0)\n    timeLock.__init__(_minConfigTimeLock, _maxConfigTimeLock, 0, _maxConfigTimeLock)\n\n\n# access control\n\n\n@view\n@internal\ndef _hasPerms(_caller: address, _isLiteAccess: bool) -> bool:\n    if gov._canGovern(_caller):\n        return True\n    if _isLiteAccess:\n        return staticcall MissionControl(addys._getMissionControlAddr()).canPerformSecurityAction(_caller)\n    return False\n\n\n###############\n# Dept Basics #\n###############\n\n\n# pause contract\n\n\n@external\ndef pause(_contractAddr: address, _shouldPause: bool) -> bool:\n    assert self._hasPerms(msg.sender, _shouldPause) # dev: no perms\n\n    extcall UndyEcoContract(_contractAddr).pause(_shouldPause)\n    log PauseExecuted(contractAddr=_contractAddr, shouldPause=_shouldPause)\n    return True\n\n\n# recover funds\n\n\n@external\ndef recoverFunds(_contractAddr: address, _recipient: address, _asset: address) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert empty(address) not in [_contractAddr, _recipient, _asset] # dev: invalid parameters\n\n    aid: uint256 = timeLock._initiateAction()\n    self.actionType[aid] = ActionType.RECOVER_FUNDS\n    self.pendingRecoverFundsActions[aid] = RecoverFundsAction(\n        contractAddr=_contractAddr,\n        recipient=_recipient,\n        asset=_asset\n    )\n\n    confirmationBlock: uint256 = timeLock._getActionConfirmationBlock(aid)\n    log PendingRecoverFundsAction(\n        contractAddr=_contractAddr,\n        recipient=_recipient,\n        asset=_asset,\n        confirmationBlock=confirmationBlock,\n        actionId=aid\n    )\n    return aid\n\n\n@external\ndef recoverFundsMany(_contractAddr: address, _recipient: address, _assets: DynArray[address, MAX_RECOVER_ASSETS]) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert empty(address) not in [_contractAddr, _recipient] # dev: invalid parameters\n    assert len(_assets) != 0 # dev: no assets provided\n\n    aid: uint256 = timeLock._initiateAction()\n    self.actionType[aid] = ActionType.RECOVER_FUNDS_MANY\n    self.pendingRecoverFundsManyActions[aid] = RecoverFundsManyAction(\n        contractAddr=_contractAddr,\n        recipient=_recipient,\n        assets=_assets\n    )\n\n    confirmationBlock: uint256 = timeLock._getActionConfirmationBlock(aid)\n    log PendingRecoverFundsManyAction(\n        contractAddr=_contractAddr,\n        recipient=_recipient,\n        numAssets=len(_assets),\n        confirmationBlock=confirmationBlock,\n        actionId=aid\n    )\n    return aid\n\n\n# recover nft\n\n\n@external\ndef recoverNft(_addr: address, _collection: address, _nftTokenId: uint256, _recipient: address) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert empty(address) not in [_addr, _collection, _recipient] # dev: invalid parameters\n\n    aid: uint256 = timeLock._initiateAction()\n    self.actionType[aid] = ActionType.RECOVER_NFT\n    self.pendingRecoverNftActions[aid] = RecoverNftAction(\n        contractAddr=_addr,\n        collection=_collection,\n        nftTokenId=_nftTokenId,\n        recipient=_recipient\n    )\n    confirmationBlock: uint256 = timeLock._getActionConfirmationBlock(aid)\n    log PendingRecoverNftAction(\n        contractAddr=_addr,\n        collection=_collection,\n        nftTokenId=_nftTokenId,\n        recipient=_recipient,\n        confirmationBlock=confirmationBlock,\n        actionId=aid\n    )\n    return aid\n\n\n###############\n# Trial Funds #\n###############\n\n\n@external\ndef clawBackTrialFunds(_users: DynArray[address, MAX_USERS]) -> bool:\n    assert self._hasPerms(msg.sender, True) # dev: no perms\n\n    hatchery: address = addys._getHatcheryAddr()\n    ledger: address = addys._getLedgerAddr()\n    for u: address in _users:\n        if not staticcall Ledger(ledger).isUserWallet(u):\n            continue\n        extcall Hatchery(hatchery).clawBackTrialFunds(u)\n    log ClawbackTrialFundsExecuted(numUsers=len(_users))\n    return True\n\n\n####################\n# Loot Distributor #\n####################\n\n\n# claim loot \n\n\n@external\ndef claimLootForUser(_user: address):\n    assert self._hasPerms(msg.sender, True) # dev: no perms\n    assert _user != empty(address) # dev: invalid user\n\n    extcall LootDistributor(addys._getLootDistributorAddr()).claimAllLoot(_user)\n    log LootClaimedForUser(user=_user, caller=msg.sender)\n\n\n# claim loot for many users\n\n\n@external\ndef claimLootForManyUsers(_users: DynArray[address, MAX_USERS]):\n    assert self._hasPerms(msg.sender, True) # dev: no perms\n    assert len(_users) != 0 # dev: no users provided\n    for u: address in _users:\n        extcall LootDistributor(addys._getLootDistributorAddr()).claimAllLoot(u)\n    log LootClaimedForManyUsers(numUsers=len(_users), caller=msg.sender)\n\n\n# adjust loot\n\n\n@external\ndef adjustLoot(_user: address, _asset: address, _newClaimable: uint256) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert empty(address) not in [_user, _asset] # dev: invalid parameters\n\n    aid: uint256 = timeLock._initiateAction()\n    self.actionType[aid] = ActionType.LOOT_ADJUST\n    self.pendingLootAdjustActions[aid] = LootAdjustAction(\n        user=_user,\n        asset=_asset,\n        newClaimable=_newClaimable\n    )\n    confirmationBlock: uint256 = timeLock._getActionConfirmationBlock(aid)\n    log PendingLootAdjustAction(\n        user=_user,\n        asset=_asset,\n        newClaimable=_newClaimable,\n        confirmationBlock=confirmationBlock,\n        actionId=aid\n    )\n    return aid\n\n\n# recover deposit rewards\n\n\n@external\ndef recoverDepositRewards(_lootAddr: address, _recipient: address) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert empty(address) not in [_lootAddr, _recipient] # dev: invalid parameters\n\n    aid: uint256 = timeLock._initiateAction()\n    self.actionType[aid] = ActionType.RECOVER_DEPOSIT_REWARDS\n    self.pendingRecoverDepositRewardsActions[aid] = RecoverDepositRewardsAction(\n        lootAddr=_lootAddr,\n        recipient=_recipient\n    )\n    confirmationBlock: uint256 = timeLock._getActionConfirmationBlock(aid)\n    log PendingRecoverDepositRewardsAction(\n        lootAddr=_lootAddr,\n        recipient=_recipient,\n        confirmationBlock=confirmationBlock,\n        actionId=aid\n    )\n    return aid\n\n\n# update deposit points\n\n\n@external\ndef updateDepositPoints(_users: DynArray[address, MAX_USERS]):\n    assert self._hasPerms(msg.sender, True) # dev: no perms\n    assert len(_users) != 0 # dev: no users provided\n    for u: address in _users:\n        extcall LootDistributor(addys._getLootDistributorAddr()).updateDepositPoints(u)\n    log DepositPointsUpdated(numUsers=len(_users), caller=msg.sender)\n\n\n######################\n# User Wallet Config #\n######################\n\n\n# update asset data\n\n\n@external\ndef updateAssetData(_bundles: DynArray[AssetDataUpdate, MAX_USERS]):\n    assert self._hasPerms(msg.sender, True) # dev: no perms\n    assert len(_bundles) != 0 # dev: no bundles provided\n    for b: AssetDataUpdate in _bundles:\n        walletConfig: address = staticcall UserWallet(b.user).walletConfig()\n        extcall UserWalletConfig(walletConfig).updateAssetData(b.legoId, b.asset, b.shouldCheckYield)\n    log AssetDataUpdated(numUsers=len(_bundles), caller=msg.sender)\n\n\n# update all asset data\n\n\n@external\ndef updateAllAssetData(_bundles: DynArray[AllAssetDataUpdate, MAX_USERS]):\n    assert self._hasPerms(msg.sender, True) # dev: no perms\n    assert len(_bundles) != 0 # dev: no bundles provided\n    for b: AllAssetDataUpdate in _bundles:\n        walletConfig: address = staticcall UserWallet(b.user).walletConfig()\n        extcall UserWalletConfig(walletConfig).updateAllAssetData(b.shouldCheckYield)\n    log AllAssetDataUpdated(numUsers=len(_bundles), caller=msg.sender)\n\n\n# set ejection mode\n\n\n@external\ndef setEjectionMode(_user: address, _shouldEject: bool) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert _user != empty(address) # dev: invalid user\n\n    aid: uint256 = timeLock._initiateAction()\n    self.actionType[aid] = ActionType.SET_EJECTION_MODE\n    self.pendingSetEjectionModeActions[aid] = SetEjectionModeAction(\n        user=_user,\n        shouldEject=_shouldEject\n    )\n    confirmationBlock: uint256 = timeLock._getActionConfirmationBlock(aid)\n    log PendingSetEjectionModeAction(\n        user=_user,\n        shouldEject=_shouldEject,\n        confirmationBlock=confirmationBlock,\n        actionId=aid\n    )\n    return aid\n\n\n#############\n# Execution #\n#############\n\n\n@external\ndef executePendingAction(_aid: uint256) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    # check time lock\n    if not timeLock._confirmAction(_aid):\n        if timeLock._isExpired(_aid):\n            self._cancelPendingAction(_aid)\n        return False\n\n    actionType: ActionType = self.actionType[_aid]\n\n    if actionType == ActionType.RECOVER_FUNDS:\n        p: RecoverFundsAction = self.pendingRecoverFundsActions[_aid]\n        extcall UndyEcoContract(p.contractAddr).recoverFunds(p.recipient, p.asset)\n        log RecoverFundsExecuted(contractAddr=p.contractAddr, recipient=p.recipient, asset=p.asset)\n\n    elif actionType == ActionType.RECOVER_FUNDS_MANY:\n        p: RecoverFundsManyAction = self.pendingRecoverFundsManyActions[_aid]\n        extcall UndyEcoContract(p.contractAddr).recoverFundsMany(p.recipient, p.assets)\n        log RecoverFundsManyExecuted(contractAddr=p.contractAddr, recipient=p.recipient, numAssets=len(p.assets))\n\n    elif actionType == ActionType.RECOVER_NFT:\n        p: RecoverNftAction = self.pendingRecoverNftActions[_aid]\n        extcall UndyEcoContract(p.contractAddr).recoverNft(p.collection, p.nftTokenId, p.recipient)\n        log RecoverNftExecuted(contractAddr=p.contractAddr, collection=p.collection, nftTokenId=p.nftTokenId, recipient=p.recipient)\n\n    elif actionType == ActionType.LOOT_ADJUST:\n        p: LootAdjustAction = self.pendingLootAdjustActions[_aid]\n        extcall LootDistributor(addys._getLootDistributorAddr()).adjustLoot(p.user, p.asset, p.newClaimable)\n        log LootAdjusted(user=p.user, asset=p.asset, newClaimable=p.newClaimable)\n\n    elif actionType == ActionType.RECOVER_DEPOSIT_REWARDS:\n        p: RecoverDepositRewardsAction = self.pendingRecoverDepositRewardsActions[_aid]\n        extcall LootDistributor(p.lootAddr).recoverDepositRewards(p.recipient)\n        log RecoverDepositRewardsExecuted(lootAddr=p.lootAddr, recipient=p.recipient)\n\n    elif actionType == ActionType.SET_EJECTION_MODE:\n        p: SetEjectionModeAction = self.pendingSetEjectionModeActions[_aid]\n        walletConfig: address = staticcall UserWallet(p.user).walletConfig()\n        extcall UserWalletConfig(walletConfig).setEjectionMode(p.shouldEject)\n        log SetEjectionModeExecuted(user=p.user, shouldEject=p.shouldEject)\n\n        # update loot points\n        extcall LootDistributor(addys._getLootDistributorAddr()).updateDepositPointsOnEjection(p.user)\n\n    self.actionType[_aid] = empty(ActionType)\n    return True\n\n\n#################\n# Cancel Action #\n#################\n\n\n@external\ndef cancelPendingAction(_aid: uint256) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    self._cancelPendingAction(_aid)\n    return True\n\n\n@internal\ndef _cancelPendingAction(_aid: uint256):\n    assert timeLock._cancelAction(_aid) # dev: cannot cancel action\n    self.actionType[_aid] = empty(ActionType)\n",
            "sha256sum": "5bcb9fc6b6da72af88f33d4a67c03f6a22092e23d8daeb8a543c6d1dbcaad24c"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/config/SwitchboardBravo.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.3+commit.bff19ea2",
        "integrity": "5480dfac8a2754449615a904b1e5d87fc1edddc96fcc50954f8cfe6d8816eb24"
      },
      "args": "00000000000000000000000044cf3c4f000dfd76a35d03298049d37be688d6f900000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000e10000000000000000000000000000000000000000000000000000000000013c680",
      "file": "contracts/config/SwitchboardBravo.vy"
    }
  }
}