{
  "contracts": {
    "UndyUsds": {
      "address": "0x04e77BC5885c82d68f523d1deE2e8b88c3036784",
      "abi": [
        {
          "name": "Deposit",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "owner",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assets",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "shares",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "Withdraw",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "receiver",
              "type": "address",
              "indexed": true
            },
            {
              "name": "owner",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assets",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "shares",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "Transfer",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "Approval",
          "inputs": [
            {
              "name": "owner",
              "type": "address",
              "indexed": true
            },
            {
              "name": "spender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "BlacklistModified",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "isBlacklisted",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "TokenPauseModified",
          "inputs": [
            {
              "name": "isPaused",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "EarnVaultAction",
          "inputs": [
            {
              "name": "op",
              "type": "uint8",
              "indexed": false
            },
            {
              "name": "asset1",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset2",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount1",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "amount2",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "legoId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "signer",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PerformanceFeesClaimed",
          "inputs": [
            {
              "name": "pendingFees",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "name",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "string"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "symbol",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "string"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "decimals",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint8"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "transfer",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "transferFrom",
          "inputs": [
            {
              "name": "_sender",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "approve",
          "inputs": [
            {
              "name": "_spender",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "increaseAllowance",
          "inputs": [
            {
              "name": "_spender",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "decreaseAllowance",
          "inputs": [
            {
              "name": "_spender",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "burn",
          "inputs": [
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "DOMAIN_SEPARATOR",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bytes32"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "permit",
          "inputs": [
            {
              "name": "_owner",
              "type": "address"
            },
            {
              "name": "_spender",
              "type": "address"
            },
            {
              "name": "_value",
              "type": "uint256"
            },
            {
              "name": "_deadline",
              "type": "uint256"
            },
            {
              "name": "_signature",
              "type": "bytes"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setBlacklist",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            },
            {
              "name": "_shouldBlacklist",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "burnBlacklistTokens",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "burnBlacklistTokens",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pause",
          "inputs": [
            {
              "name": "_shouldPause",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "undyHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "blacklisted",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isPaused",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "balanceOf",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "allowance",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalSupply",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "TOKEN_NAME",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "string"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "TOKEN_SYMBOL",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "string"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "TOKEN_DECIMALS",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint8"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "VERSION",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "string"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "nonces",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositForYield",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositForYield",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositForYield",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositForYield",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawFromYield",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawFromYield",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawFromYield",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawFromYield",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_isSpecialTx",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_instructions",
              "type": "tuple[]",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "minAmountOut",
                  "type": "uint256"
                },
                {
                  "name": "tokenPath",
                  "type": "address[]"
                },
                {
                  "name": "poolPath",
                  "type": "address[]"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimPerformanceFees",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getClaimablePerformanceFees",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "updateYieldPosition",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addManager",
          "inputs": [
            {
              "name": "_manager",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeManager",
          "inputs": [
            {
              "name": "_manager",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "lastUnderlyingBal",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingYieldRealized",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "vaultToLegoId",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assets",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "managers",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfManager",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numManagers",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "asset",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getTotalAssets",
          "inputs": [
            {
              "name": "_shouldGetMax",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "maxDeposit",
          "inputs": [
            {
              "name": "_receiver",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "previewDeposit",
          "inputs": [
            {
              "name": "_assets",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "deposit",
          "inputs": [
            {
              "name": "_assets",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "deposit",
          "inputs": [
            {
              "name": "_assets",
              "type": "uint256"
            },
            {
              "name": "_receiver",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositWithMinAmountOut",
          "inputs": [
            {
              "name": "_assets",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositWithMinAmountOut",
          "inputs": [
            {
              "name": "_assets",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_receiver",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "maxMint",
          "inputs": [
            {
              "name": "_receiver",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "previewMint",
          "inputs": [
            {
              "name": "_shares",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mint",
          "inputs": [
            {
              "name": "_shares",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mint",
          "inputs": [
            {
              "name": "_shares",
              "type": "uint256"
            },
            {
              "name": "_receiver",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "maxWithdraw",
          "inputs": [
            {
              "name": "_owner",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "previewWithdraw",
          "inputs": [
            {
              "name": "_assets",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdraw",
          "inputs": [
            {
              "name": "_assets",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdraw",
          "inputs": [
            {
              "name": "_assets",
              "type": "uint256"
            },
            {
              "name": "_receiver",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdraw",
          "inputs": [
            {
              "name": "_assets",
              "type": "uint256"
            },
            {
              "name": "_receiver",
              "type": "address"
            },
            {
              "name": "_owner",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "maxRedeem",
          "inputs": [
            {
              "name": "_owner",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "previewRedeem",
          "inputs": [
            {
              "name": "_shares",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "redeem",
          "inputs": [
            {
              "name": "_shares",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "redeem",
          "inputs": [
            {
              "name": "_shares",
              "type": "uint256"
            },
            {
              "name": "_receiver",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "redeem",
          "inputs": [
            {
              "name": "_shares",
              "type": "uint256"
            },
            {
              "name": "_receiver",
              "type": "address"
            },
            {
              "name": "_owner",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "redeemWithMinAmountOut",
          "inputs": [
            {
              "name": "_shares",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "redeemWithMinAmountOut",
          "inputs": [
            {
              "name": "_shares",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_receiver",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "redeemWithMinAmountOut",
          "inputs": [
            {
              "name": "_shares",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_receiver",
              "type": "address"
            },
            {
              "name": "_owner",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "convertToShares",
          "inputs": [
            {
              "name": "_assets",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "convertToSharesSafe",
          "inputs": [
            {
              "name": "_assets",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "convertToAssets",
          "inputs": [
            {
              "name": "_shares",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "convertToAssetsSafe",
          "inputs": [
            {
              "name": "_shares",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_tokenName",
              "type": "string"
            },
            {
              "name": "_tokenSymbol",
              "type": "string"
            },
            {
              "name": "_undyHq",
              "type": "address"
            },
            {
              "name": "_minHqTimeLock",
              "type": "uint256"
            },
            {
              "name": "_maxHqTimeLock",
              "type": "uint256"
            },
            {
              "name": "_startingAgent",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/vaults/modules/VaultErc20Token.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nimplements: IERC20\nfrom ethereum.ercs import IERC20\n\ninterface UndyHq:\n    def canSetTokenBlacklist(_addr: address) -> bool: view\n    def canMintUndy(_addr: address) -> bool: view\n    def hasPendingGovChange() -> bool: view\n    def governance() -> address: view\n\ninterface ERC1271:\n    def isValidSignature(_hash: bytes32, _signature: Bytes[65]) -> bytes4: view\n\n# erc20\n\nevent Transfer:\n    sender: indexed(address)\n    recipient: indexed(address)\n    amount: uint256\n\nevent Approval:\n    owner: indexed(address)\n    spender: indexed(address)\n    amount: uint256\n\n# undy \n\nevent BlacklistModified:\n    addr: indexed(address)\n    isBlacklisted: bool\n\nevent TokenPauseModified:\n    isPaused: bool\n\n# undy hq\nundyHq: public(address)\n\n# config\nblacklisted: public(HashMap[address, bool])\nisPaused: public(bool)\n\n# erc20\nbalanceOf: public(HashMap[address, uint256])\nallowance: public(HashMap[address, HashMap[address, uint256]])\ntotalSupply: public(uint256)\n\n# token info\nTOKEN_NAME: public(immutable(String[64]))\nTOKEN_SYMBOL: public(immutable(String[32]))\nTOKEN_DECIMALS: public(immutable(uint8))\nVERSION: public(constant(String[8])) = \"v1.0.0\"\n\n# eip-712\nnonces: public(HashMap[address, uint256])\nEIP712_TYPEHASH: constant(bytes32) = keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\")\nEIP2612_TYPEHASH: constant(bytes32) = keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\")\nECRECOVER_PRECOMPILE: constant(address) = 0x0000000000000000000000000000000000000001\nERC1271_MAGIC_VAL: constant(bytes4) = 0x1626ba7e\n\nCACHED_DOMAIN_SEPARATOR: immutable(bytes32)\nNAME_HASH: immutable(bytes32)\nVERSION_HASH: constant(bytes32) = keccak256(VERSION)\nCACHED_CHAIN_ID: immutable(uint256)\n\n\n@deploy\ndef __init__(\n    _tokenName: String[64],\n    _tokenSymbol: String[32],\n    _tokenDecimals: uint8,\n    _undyHq: address,\n):\n    # token info\n    TOKEN_NAME = _tokenName\n    TOKEN_SYMBOL = _tokenSymbol\n    TOKEN_DECIMALS = _tokenDecimals\n\n    # set undy hq\n    assert _undyHq != empty(address) # dev: invalid undy hq\n    self.undyHq = _undyHq\n\n    # domain separator\n    NAME_HASH = keccak256(_tokenName)\n    CACHED_CHAIN_ID = chain.id\n    CACHED_DOMAIN_SEPARATOR = keccak256(\n        abi_encode(\n            EIP712_TYPEHASH,\n            NAME_HASH,\n            VERSION_HASH,\n            CACHED_CHAIN_ID,\n            self,\n        )\n    )\n\n\n##############\n# Token Info #\n##############\n\n\n@view\n@external\ndef name() -> String[64]:\n    return TOKEN_NAME\n\n\n@view\n@external\ndef symbol() -> String[32]:\n    return TOKEN_SYMBOL\n\n\n@view\n@external\ndef decimals() -> uint8:\n    return TOKEN_DECIMALS\n\n\n#############\n# Transfers #\n#############\n\n\n@external\ndef transfer(_recipient: address, _amount: uint256) -> bool:\n    self._transfer(msg.sender, _recipient, _amount)\n    return True\n\n\n@external\ndef transferFrom(_sender: address, _recipient: address, _amount: uint256) -> bool:\n    assert not self.blacklisted[msg.sender] # dev: spender blacklisted\n    self._spendAllowance(_sender, msg.sender, _amount)\n    self._transfer(_sender, _recipient, _amount)\n    return True\n\n\n@internal\ndef _transfer(_sender: address, _recipient: address, _amount: uint256):\n    assert not self.isPaused # dev: token paused\n    assert _amount != 0 # dev: cannot transfer 0 amount\n    assert _recipient not in [self, empty(address)] # dev: invalid recipient\n\n    assert not self.blacklisted[_sender] # dev: sender blacklisted\n    assert not self.blacklisted[_recipient] # dev: recipient blacklisted\n\n    senderBalance: uint256 = self.balanceOf[_sender]\n    assert senderBalance >= _amount # dev: insufficient funds\n    self.balanceOf[_sender] = senderBalance - _amount\n    self.balanceOf[_recipient] += _amount\n\n    log Transfer(sender=_sender, recipient=_recipient, amount=_amount)\n\n\n#############\n# Allowance #\n#############\n\n\n# approvals\n\n\n@external\ndef approve(_spender: address, _amount: uint256) -> bool:\n    self._validateNewApprovals(msg.sender, _spender)\n    self._approve(msg.sender, _spender, _amount)\n    return True\n\n\n@internal\ndef _approve(_owner: address, _spender: address, _amount: uint256):\n    self.allowance[_owner][_spender] = _amount\n    log Approval(owner=_owner, spender=_spender, amount=_amount)\n\n\n@internal\ndef _spendAllowance(_owner: address, _spender: address, _amount: uint256):\n    currentAllowance: uint256 = self.allowance[_owner][_spender]\n    if currentAllowance != max_value(uint256):\n        assert currentAllowance >= _amount # dev: insufficient allowance\n        self._approve(_owner, _spender, currentAllowance - _amount)\n\n\n# increase / decrease allowance\n\n\n@external\ndef increaseAllowance(_spender: address, _amount: uint256) -> bool:\n    self._validateNewApprovals(msg.sender, _spender)\n    currentAllowance: uint256 = self.allowance[msg.sender][_spender]\n    maxIncrease: uint256 = max_value(uint256) - currentAllowance\n    newAllowance: uint256 = currentAllowance + min(_amount, maxIncrease)\n    if newAllowance != currentAllowance:\n        self._approve(msg.sender, _spender, newAllowance)\n    return True\n\n\n@external\ndef decreaseAllowance(_spender: address, _amount: uint256) -> bool:\n    self._validateNewApprovals(msg.sender, _spender)\n    currentAllowance: uint256 = self.allowance[msg.sender][_spender]\n    newAllowance: uint256 = currentAllowance - min(_amount, currentAllowance)\n    if newAllowance != currentAllowance:\n        self._approve(msg.sender, _spender, newAllowance)\n    return True\n\n\n# validation\n\n\n@view\n@internal\ndef _validateNewApprovals(_owner: address, _spender: address):\n    assert not self.isPaused # dev: token paused\n    assert not self.blacklisted[_owner] # dev: owner blacklisted\n    assert not self.blacklisted[_spender] # dev: spender blacklisted\n    assert _spender != empty(address) # dev: invalid spender\n\n\n#####################\n# Minting / Burning #\n#####################\n\n\n# mint tokens\n\n\n@internal\ndef _mint(_recipient: address, _amount: uint256) -> bool:\n    assert _recipient not in [self, empty(address)] # dev: invalid recipient\n    assert not self.blacklisted[_recipient] # dev: blacklisted\n    assert not self.isPaused # dev: token paused\n\n    self.balanceOf[_recipient] += _amount\n    self.totalSupply += _amount\n    log Transfer(sender=empty(address), recipient=_recipient, amount=_amount)\n    return True\n\n\n# burn tokens\n\n\n@external\ndef burn(_amount: uint256) -> bool:\n    assert not self.isPaused # dev: token paused\n    self._burn(msg.sender, _amount)\n    return True\n\n\n@internal\ndef _burn(_owner: address, _amount: uint256):\n    self.balanceOf[_owner] -= _amount\n    self.totalSupply -= _amount\n    log Transfer(sender=_owner, recipient=empty(address), amount=_amount)\n\n\n###########\n# EIP 712 #\n###########\n\n\n@view\n@external\ndef DOMAIN_SEPARATOR() -> bytes32:\n    return self._domainSeparator()\n\n\n@view\n@internal\ndef _domainSeparator() -> bytes32:\n    if chain.id != CACHED_CHAIN_ID:\n        return keccak256(\n            abi_encode(\n                EIP712_TYPEHASH,\n                NAME_HASH,\n                VERSION_HASH,\n                chain.id,\n                self,\n            )\n        )\n    return CACHED_DOMAIN_SEPARATOR\n\n\n@external\ndef permit(\n    _owner: address,\n    _spender: address,\n    _value: uint256,\n    _deadline: uint256,\n    _signature: Bytes[65],\n) -> bool:\n    self._validateNewApprovals(_owner, _spender)\n    assert _owner != empty(address) and block.timestamp <= _deadline # dev: permit expired\n\n    nonce: uint256 = self.nonces[_owner]\n    digest: bytes32 = keccak256(\n        concat(\n            b\"\\x19\\x01\",\n            self._domainSeparator(),\n            keccak256(abi_encode(EIP2612_TYPEHASH, _owner, _spender, _value, nonce, _deadline)),\n        )\n    )\n\n    if _owner.is_contract:\n        assert staticcall ERC1271(_owner).isValidSignature(digest, _signature) == ERC1271_MAGIC_VAL # dev: invalid signature\n\n    else:\n        r: bytes32 = convert(slice(_signature, 0, 32), bytes32)\n        s: bytes32 = convert(slice(_signature, 32, 32), bytes32)\n        v: uint8 = convert(slice(_signature, 64, 1), uint8)\n\n        # validate v parameter (27 or 28)\n        if v < 27:\n            v = v + 27\n        assert v == 27 or v == 28 # dev: invalid v parameter\n\n        # prevent signature malleability by ensuring s is in lower half of curve order\n        s_uint: uint256 = convert(s, uint256)\n        assert s_uint != 0 # dev: invalid s value (zero)\n        assert s_uint <= convert(0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, uint256) # dev: invalid s value\n\n        response: Bytes[32] = raw_call(\n            ECRECOVER_PRECOMPILE,\n            abi_encode(digest, v, r, s),\n            max_outsize = 32,\n            is_static_call = True # a view function\n        )\n        assert len(response) == 32  # dev: invalid ecrecover response length\n        assert abi_decode(response, address) == _owner  # dev: invalid signature\n\n    self.nonces[_owner] = nonce + 1\n    self._approve(_owner, _spender, _value)\n    return True\n\n\n#############\n# Blacklist #\n#############\n\n\n@external\ndef setBlacklist(_addr: address, _shouldBlacklist: bool) -> bool:\n    assert staticcall UndyHq(self.undyHq).canSetTokenBlacklist(msg.sender) # dev: no perms\n\n    assert _addr not in [self, empty(address)] # dev: invalid blacklist recipient\n    self.blacklisted[_addr] = _shouldBlacklist\n    log BlacklistModified(addr=_addr, isBlacklisted=_shouldBlacklist)\n    return True\n\n\n@external\ndef burnBlacklistTokens(_addr: address, _amount: uint256 = max_value(uint256)) -> bool:\n    assert msg.sender == staticcall UndyHq(self.undyHq).governance() # dev: no perms\n    assert self.blacklisted[_addr] # dev: not blacklisted\n\n    amount: uint256 = min(_amount, self.balanceOf[_addr])\n    assert amount != 0 # dev: cannot burn 0 tokens\n    self._burn(_addr, amount)\n    return True\n\n\n#########\n# Pause #\n#########\n\n\n@external\ndef pause(_shouldPause: bool):\n    assert msg.sender == staticcall UndyHq(self.undyHq).governance() # dev: no perms\n    assert _shouldPause != self.isPaused # dev: no change\n    self.isPaused = _shouldPause\n    log TokenPauseModified(isPaused=_shouldPause)\n",
            "sha256sum": "c01f0100f9d040bbd95c91f201e0623bd0331c6982e5ef73e832a37bb27eee08"
          },
          "interfaces/Wallet.vyi": {
            "content": "# @version 0.4.3\n\nstruct SwapInstruction:\n    legoId: uint256\n    amountIn: uint256\n    minAmountOut: uint256\n    tokenPath: DynArray[address, MAX_TOKEN_PATH]\n    poolPath: DynArray[address, MAX_TOKEN_PATH - 1]\n\nMAX_SWAP_INSTRUCTIONS: constant(uint256) = 5\nMAX_TOKEN_PATH: constant(uint256) = 5\n\n\n@view\n@external\ndef onERC721Received(_operator: address, _owner: address, _tokenId: uint256, _data: Bytes[1024]) -> bytes4:\n    ...\n\n\n@pure\n@external\ndef apiVersion() -> String[28]:\n    ...\n\n##################\n# Transfer Funds #\n##################\n\n\n@external\ndef transferFunds(\n    _recipient: address,\n    _asset: address = empty(address),\n    _amount: uint256 = max_value(uint256),\n    _isCheque: bool = False,\n    _isTrustedTx: bool = False,\n) -> (uint256, uint256):\n    ...\n\n\n#########\n# Yield #\n#########\n\n\n# deposit\n\n\n@external\ndef depositForYield(\n    _legoId: uint256,\n    _asset: address,\n    _vaultAddr: address = empty(address),\n    _amount: uint256 = max_value(uint256),\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, address, uint256, uint256):\n    ...\n\n\n# withdraw\n\n\n@external\ndef withdrawFromYield(\n    _legoId: uint256,\n    _vaultToken: address,\n    _amount: uint256 = max_value(uint256),\n    _extraData: bytes32 = empty(bytes32),\n    _isTrustedTx: bool = False,\n) -> (uint256, address, uint256, uint256):\n    ...\n\n\n# rebalance position\n\n\n@external\ndef rebalanceYieldPosition(\n    _fromLegoId: uint256,\n    _fromVaultToken: address,\n    _toLegoId: uint256,\n    _toVaultAddr: address = empty(address),\n    _fromVaultAmount: uint256 = max_value(uint256),\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, address, uint256, uint256):\n    ...\n\n\n###################\n# Swap / Exchange #\n###################\n\n\n@external\ndef swapTokens(_instructions: DynArray[SwapInstruction, MAX_SWAP_INSTRUCTIONS]) -> (address, uint256, address, uint256, uint256):\n    ...\n\n\n# mint / redeem\n\n\n@external\ndef mintOrRedeemAsset(\n    _legoId: uint256,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256 = max_value(uint256),\n    _minAmountOut: uint256 = 0,\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, uint256, bool, uint256):\n    ...\n\n\n@external\ndef confirmMintOrRedeemAsset(\n    _legoId: uint256,\n    _tokenIn: address,\n    _tokenOut: address,\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, uint256):\n    ...\n\n\n###################\n# Debt Management #\n###################\n\n\n# add collateral\n\n\n@external\ndef addCollateral(\n    _legoId: uint256,\n    _asset: address,\n    _amount: uint256 = max_value(uint256),\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, uint256):\n    ...\n\n\n# remove collateral\n\n\n@external\ndef removeCollateral(\n    _legoId: uint256,\n    _asset: address,\n    _amount: uint256 = max_value(uint256),\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, uint256):\n    ...\n\n\n# borrow\n\n\n@external\ndef borrow(\n    _legoId: uint256,\n    _borrowAsset: address,\n    _amount: uint256 = max_value(uint256),\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, uint256):\n    ...\n\n\n# repay debt\n\n\n@external\ndef repayDebt(\n    _legoId: uint256,\n    _paymentAsset: address,\n    _paymentAmount: uint256 = max_value(uint256),\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, uint256):\n    ...\n\n\n#################\n# Claim Rewards #\n#################\n\n\n@external\ndef claimRewards(\n    _legoId: uint256,\n    _rewardToken: address = empty(address),\n    _rewardAmount: uint256 = max_value(uint256),\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, uint256):\n    ...\n\n\n################\n# Wrapped ETH #\n################\n\n\n# eth -> weth\n\n\n@payable\n@external\ndef convertEthToWeth(_amount: uint256 = max_value(uint256)) -> (uint256, uint256):\n    ...\n\n\n# weth -> eth\n\n\n@external\ndef convertWethToEth(_amount: uint256 = max_value(uint256)) -> (uint256, uint256):\n    ...\n\n\n#################\n# Add Liquidity #\n#################\n\n\n# add / remove liquidity (simple)\n\n\n@external\ndef addLiquidity(\n    _legoId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _amountA: uint256 = max_value(uint256),\n    _amountB: uint256 = max_value(uint256),\n    _minAmountA: uint256 = 0,\n    _minAmountB: uint256 = 0,\n    _minLpAmount: uint256 = 0,\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, uint256, uint256, uint256):\n    ...\n\n\n@external\ndef removeLiquidity(\n    _legoId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpToken: address,\n    _lpAmount: uint256 = max_value(uint256),\n    _minAmountA: uint256 = 0,\n    _minAmountB: uint256 = 0,\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, uint256, uint256, uint256):\n    ...\n\n\n# add / remove liquidity (concentrated)\n\n\n@external\ndef addLiquidityConcentrated(\n    _legoId: uint256,\n    _nftAddr: address,\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _amountA: uint256 = max_value(uint256),\n    _amountB: uint256 = max_value(uint256),\n    _tickLower: int24 = min_value(int24),\n    _tickUpper: int24 = max_value(int24),\n    _minAmountA: uint256 = 0,\n    _minAmountB: uint256 = 0,\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, uint256, uint256, uint256, uint256):\n    ...\n\n\n@external\ndef removeLiquidityConcentrated(\n    _legoId: uint256,\n    _nftAddr: address,\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _liqToRemove: uint256 = max_value(uint256),\n    _minAmountA: uint256 = 0,\n    _minAmountB: uint256 = 0,\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, uint256, uint256, uint256):\n    ...\n\n\n#############\n# Utilities #\n#############\n\n\n# recover nft\n\n\n@external\ndef recoverNft(_collection: address, _nftTokenId: uint256, _recipient: address):\n    ...\n",
            "sha256sum": "bc36343f2acf1bcd8ce0ae78be20898917cec4f6fa4a4e9fcfea42baa0f75c21"
          },
          "interfaces/WalletStructs.vyi": {
            "content": "# @version 0.4.3\n\nflag ActionType:\n    TRANSFER\n    EARN_DEPOSIT\n    EARN_WITHDRAW\n    EARN_REBALANCE\n    SWAP\n    MINT_REDEEM\n    CONFIRM_MINT_REDEEM\n    ADD_COLLATERAL\n    REMOVE_COLLATERAL\n    BORROW\n    REPAY_DEBT\n    REWARDS\n    ETH_TO_WETH\n    WETH_TO_ETH\n    ADD_LIQ\n    REMOVE_LIQ\n    ADD_LIQ_CONC\n    REMOVE_LIQ_CONC\n    PAY_CHEQUE\n\nstruct WalletAssetData:\n    assetBalance: uint256\n    usdValue: uint256\n    isYieldAsset: bool\n    lastPricePerShare: uint256\n\nstruct ActionData:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    billing: address\n    wallet: address\n    walletConfig: address\n    walletOwner: address\n    inEjectMode: bool\n    isFrozen: bool\n    lastTotalUsdValue: uint256\n    signer: address\n    isManager: bool\n    legoId: uint256\n    legoAddr: address\n    eth: address\n    weth: address\n\nstruct MiniAddys:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    appraiser: address",
            "sha256sum": "9a4b4f59b3a62043e51b425a665064aae419a3c0bd0514b6b29a9441ae364bb9"
          },
          "interfaces/LegoPartner.vyi": {
            "content": "# @version 0.4.3\n\nfrom interfaces import WalletStructs as ws\n\nMAX_TOKEN_PATH: constant(uint256) = 5\nMAX_RECOVER_ASSETS: constant(uint256) = 20\n\n@external\ndef addLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _tickLower: int24, _tickUpper: int24, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef addLiquidity(_pool: address, _tokenA: address, _tokenB: address, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _minLpAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (address, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef removeLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _liqToRemove: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef removeLiquidity(_pool: address, _tokenA: address, _tokenB: address, _lpToken: address, _lpAmount: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef mintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _tokenInAmount: uint256, _minAmountOut: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef swapTokens(_amountIn: uint256, _minAmountOut: uint256, _tokenPath: DynArray[address, MAX_TOKEN_PATH], _poolPath: DynArray[address, MAX_TOKEN_PATH - 1], _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256):\n    ...\n\n@external\ndef depositForYield(_asset: address, _amount: uint256, _vaultAddr: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef withdrawFromYield(_vaultToken: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef confirmMintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef borrow(_borrowAsset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef repayDebt(_paymentAsset: address, _paymentAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef claimRewards(_user: address, _rewardToken: address, _rewardAmount: uint256, _extraData: bytes32, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef removeCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef addCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@view\n@external\ndef getAccessForLego(_user: address, _action: ws.ActionType) -> (address, String[64], uint256):\n    ...\n\n@view\n@external\ndef hasCapability(_action: ws.ActionType) -> bool:\n    ...\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    ...\n\n@view\n@external\ndef isYieldLego() -> bool:\n    ...\n\n@view\n@external\ndef isDexLego() -> bool:\n    ...\n\n\n# common\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "81db71fe4440a3b4b563134c9b5caf1d5705772a5f291fe874c9b5fb3cfb1623"
          },
          "contracts/vaults/modules/EarnVaultWallet.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nfrom interfaces import Wallet as wi\nfrom interfaces import LegoPartner as Lego\nfrom interfaces import WalletStructs as ws\n\nfrom ethereum.ercs import IERC20\nfrom ethereum.ercs import IERC20Detailed\n\ninterface VaultRegistry:\n    def getVaultActionDataWithFrozenStatus(_legoId: uint256, _signer: address, _vaultAddr: address) -> (VaultActionData, bool): view\n    def getVaultActionDataBundle(_legoId: uint256, _signer: address) -> VaultActionData: view\n    def checkVaultApprovals(_vaultAddr: address, _vaultToken: address) -> bool: view\n    def getLegoDataFromVaultToken(_vaultToken: address) -> (uint256, address): view\n    def redemptionConfig(_vaultAddr: address) -> (uint256, uint256): view\n    def getPerformanceFee(_vaultAddr: address) -> uint256: view\n\ninterface YieldLego:\n    def getUnderlyingBalances(_vaultToken: address, _vaultTokenBalance: uint256) -> (uint256, uint256): view\n    def getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256: view\n\ninterface Switchboard:\n    def isSwitchboardAddr(_addr: address) -> bool: view\n\ninterface MissionControl:\n    def isLockedSigner(_signer: address) -> bool: view\n\ninterface Registry:\n    def getAddr(_regId: uint256) -> address: view\n\ninterface UndyHq:\n    def governance() -> address: view\n\nstruct VaultActionData:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    appraiser: address\n    vaultRegistry: address\n    vaultAsset: address\n    signer: address\n    legoId: uint256\n    legoAddr: address\n\nevent EarnVaultAction:\n    op: uint8\n    asset1: indexed(address)\n    asset2: indexed(address)\n    amount1: uint256\n    amount2: uint256\n    usdValue: uint256\n    legoId: uint256\n    signer: indexed(address)\n\nevent PerformanceFeesClaimed:\n    pendingFees: uint256\n\n# yield tracking\nlastUnderlyingBal: public(uint256)\npendingYieldRealized: public(uint256)\n\n# asset data\nvaultToLegoId: public(HashMap[address, uint256]) # vault addr -> lego id\nassets: public(HashMap[uint256, address]) # index -> asset\nindexOfAsset: public(HashMap[address, uint256]) # asset -> index\nnumAssets: public(uint256) # num assets\n\n# managers\nmanagers: public(HashMap[uint256, address]) # index -> manager\nindexOfManager: public(HashMap[address, uint256]) # manager -> index\nnumManagers: public(uint256) # num managers\n\n# constants\nHUNDRED_PERCENT: constant(uint256) = 100_00 # 100.00%\nMAX_SWAP_INSTRUCTIONS: constant(uint256) = 5\nMAX_TOKEN_PATH: constant(uint256) = 5\nMAX_LEGOS: constant(uint256) = 10\nMAX_DEREGISTER_ASSETS: constant(uint256) = 25\n\n# registry ids\nLEGO_BOOK_ID: constant(uint256) = 3\nSWITCHBOARD_ID: constant(uint256) = 4\nVAULT_REGISTRY_ID: constant(uint256) = 10\n\nUNDY_HQ: immutable(address)\nVAULT_ASSET: immutable(address)\n\n\n@deploy\ndef __init__(\n    _undyHq: address,\n    _vaultAsset: address,\n    _startingAgent: address,\n):\n    # not using 0 index\n    self.numManagers = 1\n    self.numAssets = 1\n\n    assert empty(address) not in [_undyHq, _vaultAsset] # dev: inv addr\n    UNDY_HQ = _undyHq\n    VAULT_ASSET = _vaultAsset\n\n    # initial agent\n    if _startingAgent != empty(address):\n        self._registerManager(_startingAgent)\n\n\n#########\n# Yield #\n#########\n\n\n# deposit\n\n\n@external\ndef depositForYield(\n    _legoId: uint256,\n    _asset: address,\n    _vaultAddr: address = empty(address),\n    _amount: uint256 = max_value(uint256),\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, address, uint256, uint256):\n    ad: VaultActionData = self._canManagerPerformAction(msg.sender, [_legoId])\n    return self._depositForYield(_asset, _vaultAddr, _amount, _extraData, self._getUnderlyingAndUpdatePendingYield(), True, ad)\n\n\n@internal\ndef _onReceiveVaultFunds(\n    _vaultAddr: address,\n    _depositor: address,\n    _vaultRegistry: address,\n) -> uint256:\n    legoId: uint256 = self.vaultToLegoId[_vaultAddr]\n    ad: VaultActionData = staticcall VaultRegistry(_vaultRegistry).getVaultActionDataBundle(legoId, _depositor)\n    if ad.legoId == 0 or ad.legoAddr == empty(address):\n        return 0\n    ad.vaultAsset = VAULT_ASSET\n    return self._depositForYield(ad.vaultAsset, _vaultAddr, max_value(uint256), empty(bytes32), 0, False, ad)[0]\n\n\n@internal\ndef _depositForYield(\n    _asset: address,\n    _vaultAddr: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _currentUnderlying: uint256,\n    _shouldSaveUnderlying: bool,\n    _ad: VaultActionData,\n) -> (uint256, address, uint256, uint256):\n    amount: uint256 = self._getAmountAndApprove(_asset, _amount, _ad.legoAddr) # doing approval here\n    currentUnderlying: uint256 = _currentUnderlying\n\n    # deposit for yield\n    assetAmount: uint256 = 0\n    vaultToken: address = empty(address)\n    vaultTokenAmountReceived: uint256 = 0\n    txUsdValue: uint256 = 0\n    assetAmount, vaultToken, vaultTokenAmountReceived, txUsdValue = extcall Lego(_ad.legoAddr).depositForYield(_asset, amount, _vaultAddr, _extraData, self, self._packMiniAddys(_ad.ledger, _ad.missionControl, _ad.legoBook, _ad.appraiser))\n    assert extcall IERC20(_asset).approve(_ad.legoAddr, 0, default_return_value = True) # dev: appr\n\n    # update yield position\n    if _asset == VAULT_ASSET:\n        assert _vaultAddr == vaultToken # dev: vault token mismatch\n        assert staticcall VaultRegistry(_ad.vaultRegistry).checkVaultApprovals(self, vaultToken) # dev: lego or vault token not approved\n        self._updateYieldPosition(vaultToken, _ad.legoId)\n        currentUnderlying += assetAmount\n\n    # save underlying balance\n    if _shouldSaveUnderlying:\n        self.lastUnderlyingBal = currentUnderlying\n\n    log EarnVaultAction(\n        op = 10,\n        asset1 = _asset,\n        asset2 = vaultToken,\n        amount1 = assetAmount,\n        amount2 = vaultTokenAmountReceived,\n        usdValue = txUsdValue,\n        legoId = _ad.legoId,\n        signer = _ad.signer,\n    )\n    return assetAmount, vaultToken, vaultTokenAmountReceived, txUsdValue\n\n\n# withdraw\n\n\n@external\ndef withdrawFromYield(\n    _legoId: uint256,\n    _vaultToken: address,\n    _amount: uint256 = max_value(uint256),\n    _extraData: bytes32 = empty(bytes32),\n    _isSpecialTx: bool = False,\n) -> (uint256, address, uint256, uint256):\n    ad: VaultActionData = self._canManagerPerformAction(msg.sender, [_legoId])\n    return self._withdrawFromYield(_vaultToken, _amount, _extraData, self._getUnderlyingAndUpdatePendingYield(), True, ad)\n\n\n@internal\ndef _withdrawFromYield(\n    _vaultToken: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _currentUnderlying: uint256,\n    _shouldSaveUnderlying: bool,\n    _ad: VaultActionData,\n) -> (uint256, address, uint256, uint256):\n    assert _vaultToken != empty(address) # dev: invalid vault token\n    amount: uint256 = self._getAmountAndApprove(_vaultToken, _amount, empty(address)) # not approving here\n    currentUnderlying: uint256 = _currentUnderlying\n\n    # some vault tokens require max value approval (comp v3)\n    assert extcall IERC20(_vaultToken).approve(_ad.legoAddr, max_value(uint256), default_return_value = True) # dev: appr\n\n    # withdraw from yield\n    vaultTokenAmountBurned: uint256 = 0\n    underlyingAsset: address = empty(address)\n    underlyingAmount: uint256 = 0\n    txUsdValue: uint256 = 0\n    vaultTokenAmountBurned, underlyingAsset, underlyingAmount, txUsdValue = extcall Lego(_ad.legoAddr).withdrawFromYield(_vaultToken, amount, _extraData, self, self._packMiniAddys(_ad.ledger, _ad.missionControl, _ad.legoBook, _ad.appraiser))\n    assert extcall IERC20(_vaultToken).approve(_ad.legoAddr, 0, default_return_value = True) # dev: appr\n\n    # update yield position\n    if underlyingAsset == VAULT_ASSET:\n        self._updateYieldPosition(_vaultToken, _ad.legoId)\n        currentUnderlying -= min(currentUnderlying, underlyingAmount)\n\n    if _shouldSaveUnderlying:\n        self.lastUnderlyingBal = currentUnderlying\n\n    log EarnVaultAction(\n        op = 11,\n        asset1 = _vaultToken,\n        asset2 = underlyingAsset,\n        amount1 = vaultTokenAmountBurned,\n        amount2 = underlyingAmount,\n        usdValue = txUsdValue,\n        legoId = _ad.legoId,\n        signer = _ad.signer,\n    )\n    return vaultTokenAmountBurned, underlyingAsset, underlyingAmount, txUsdValue\n\n\n###################\n# Swap / Exchange #\n###################\n\n\n@external\ndef swapTokens(_instructions: DynArray[wi.SwapInstruction, MAX_SWAP_INSTRUCTIONS]) -> (address, uint256, address, uint256, uint256):\n    tokenIn: address = empty(address)\n    tokenOut: address = empty(address)\n    legoIds: DynArray[uint256, MAX_LEGOS] = []\n    tokenIn, tokenOut, legoIds = self._validateAndGetSwapInfo(_instructions)\n\n    # important checks!\n    vaultAsset: address = VAULT_ASSET\n    assert tokenIn != vaultAsset # dev: cannot swap out of vault asset\n    assert self.vaultToLegoId[tokenIn] == 0 # dev: cannot swap out of vault token\n    assert tokenOut == vaultAsset # dev: must swap into vault asset\n\n    # action data bundle\n    ad: VaultActionData = self._canManagerPerformAction(msg.sender, legoIds)\n    origAmountIn: uint256 = self._getAmountAndApprove(tokenIn, _instructions[0].amountIn, empty(address)) # not approving here\n\n    amountIn: uint256 = origAmountIn\n    lastTokenOut: address = empty(address)\n    lastTokenOutAmount: uint256 = 0\n    maxTxUsdValue: uint256 = 0\n\n    # perform swaps\n    for i: wi.SwapInstruction in _instructions:\n        if lastTokenOut != empty(address):\n            newTokenIn: address = i.tokenPath[0]\n            assert lastTokenOut == newTokenIn # dev: path\n            amountIn = min(lastTokenOutAmount, staticcall IERC20(newTokenIn).balanceOf(self))\n        \n        thisTxUsdValue: uint256 = 0\n        lastTokenOut, lastTokenOutAmount, thisTxUsdValue = self._performSwapInstruction(amountIn, i, ad)\n        maxTxUsdValue = max(maxTxUsdValue, thisTxUsdValue)\n\n    log EarnVaultAction(\n        op = 20,\n        asset1 = tokenIn,\n        asset2 = lastTokenOut,\n        amount1 = origAmountIn,\n        amount2 = lastTokenOutAmount,\n        usdValue = maxTxUsdValue,\n        legoId = ad.legoId, # using just the first lego used\n        signer = ad.signer,\n    )\n    return tokenIn, origAmountIn, lastTokenOut, lastTokenOutAmount, maxTxUsdValue\n\n\n@internal\ndef _performSwapInstruction(\n    _amountIn: uint256,\n    _i: wi.SwapInstruction,\n    _ad: VaultActionData,\n) -> (address, uint256, uint256):\n    legoAddr: address = staticcall Registry(_ad.legoBook).getAddr(_i.legoId)\n    assert legoAddr != empty(address) # dev: lego\n\n    # tokens\n    tokenIn: address = _i.tokenPath[0]\n    tokenOut: address = _i.tokenPath[len(_i.tokenPath) - 1]\n    tokenInAmount: uint256 = 0\n    tokenOutAmount: uint256 = 0\n    txUsdValue: uint256 = 0\n\n    assert extcall IERC20(tokenIn).approve(legoAddr, _amountIn, default_return_value = True) # dev: appr\n    tokenInAmount, tokenOutAmount, txUsdValue = extcall Lego(legoAddr).swapTokens(_amountIn, _i.minAmountOut, _i.tokenPath, _i.poolPath, self, self._packMiniAddys(_ad.ledger, _ad.missionControl, _ad.legoBook, _ad.appraiser))\n    assert extcall IERC20(tokenIn).approve(legoAddr, 0, default_return_value = True) # dev: appr\n    return tokenOut, tokenOutAmount, txUsdValue\n\n\n@internal\ndef _validateAndGetSwapInfo(_instructions: DynArray[wi.SwapInstruction, MAX_SWAP_INSTRUCTIONS]) -> (address, address, DynArray[uint256, MAX_LEGOS]):\n    numSwapInstructions: uint256 = len(_instructions)\n    assert numSwapInstructions != 0 # dev: swaps\n\n    # lego ids, make sure token paths are valid\n    legoIds: DynArray[uint256, MAX_LEGOS] = []\n    for i: wi.SwapInstruction in _instructions:\n        assert len(i.tokenPath) >= 2 # dev: path\n        if i.legoId not in legoIds:\n            legoIds.append(i.legoId)\n\n    # finalize tokens\n    firstRoutePath: DynArray[address, MAX_TOKEN_PATH] = _instructions[0].tokenPath\n    tokenIn: address = firstRoutePath[0]\n    tokenOut: address = empty(address)\n\n    if numSwapInstructions == 1:\n        tokenOut = firstRoutePath[len(firstRoutePath) - 1]\n    else:\n        lastRoutePath: DynArray[address, MAX_TOKEN_PATH] = _instructions[numSwapInstructions - 1].tokenPath\n        tokenOut = lastRoutePath[len(lastRoutePath) - 1]\n\n    assert empty(address) not in [tokenIn, tokenOut] # dev: path\n    return tokenIn, tokenOut, legoIds\n\n\n#################\n# Claim Rewards #\n#################\n\n\n@external\ndef claimRewards(\n    _legoId: uint256,\n    _rewardToken: address = empty(address),\n    _rewardAmount: uint256 = max_value(uint256),\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, uint256):\n    ad: VaultActionData = self._canManagerPerformAction(msg.sender, [_legoId])\n\n    # make sure can access\n    self._setLegoAccessForAction(ad.legoAddr, ws.ActionType.REWARDS)\n\n    # claim rewards\n    rewardAmount: uint256 = 0\n    txUsdValue: uint256 = 0\n    rewardAmount, txUsdValue = extcall Lego(ad.legoAddr).claimRewards(self, _rewardToken, _rewardAmount, _extraData, self._packMiniAddys(ad.ledger, ad.missionControl, ad.legoBook, ad.appraiser))\n\n    log EarnVaultAction(\n        op = 50,\n        asset1 = _rewardToken,\n        asset2 = ad.legoAddr,\n        amount1 = rewardAmount,\n        amount2 = 0,\n        usdValue = txUsdValue,\n        legoId = ad.legoId,\n        signer = ad.signer,\n    )\n    return rewardAmount, txUsdValue\n\n\n#############################\n# Overall Yield Calculation #\n#############################\n\n\n# calculate yield realized\n\n\n@view\n@internal\ndef _calcNewYieldAndGetUnderlying(_currentUnderlying: uint256 = 0) -> (uint256, uint256):\n    currentUnderlying: uint256 = _currentUnderlying\n    if currentUnderlying == 0:\n        currentUnderlying = self._getUnderlyingYieldBalances()[0]\n\n    newYield: uint256 = 0\n    lastUnderlyingBal: uint256 = self.lastUnderlyingBal\n    if lastUnderlyingBal != 0 and currentUnderlying > lastUnderlyingBal:\n        newYield = currentUnderlying - lastUnderlyingBal\n\n    return currentUnderlying, newYield\n\n\n# update pending yield realized\n\n\n@internal\ndef _getUnderlyingAndUpdatePendingYield() -> uint256:\n    currentUnderlying: uint256 = 0\n    newYield: uint256 = 0\n    currentUnderlying, newYield = self._calcNewYieldAndGetUnderlying()\n    self.pendingYieldRealized += newYield\n    return currentUnderlying\n\n\n# claim performance fees\n\n\n@external\ndef claimPerformanceFees() -> uint256:\n    governance: address = staticcall UndyHq(UNDY_HQ).governance()\n    assert self._isSwitchboardAddr(msg.sender) or governance == msg.sender # dev: no perms\n\n    vaultRegistry: address = self._getVaultRegistry()\n    currentUnderlying: uint256 = self._getUnderlyingAndUpdatePendingYield()\n    pendingFees: uint256 = self.pendingYieldRealized * self._getPerformanceFeeRatio(vaultRegistry) // HUNDRED_PERCENT\n\n    # make withdrawals from yield positions\n    availAmount: uint256 = 0\n    withdrawnAmount: uint256 = 0\n    availAmount, withdrawnAmount = self._prepareRedemption(VAULT_ASSET, pendingFees, empty(address), governance, vaultRegistry)\n    assert availAmount >= pendingFees # dev: insufficient funds\n\n    # transfer pending fees to governance\n    assert extcall IERC20(VAULT_ASSET).transfer(governance, pendingFees, default_return_value=True) # dev: withdrawal failed\n\n    # update data\n    self.pendingYieldRealized = 0\n    self.lastUnderlyingBal = currentUnderlying - min(currentUnderlying, withdrawnAmount)\n\n    log PerformanceFeesClaimed(pendingFees=pendingFees)\n    return pendingFees\n\n\n# claimable performance fees\n\n\n@view\n@external\ndef getClaimablePerformanceFees() -> uint256:\n    newYield: uint256 = self._calcNewYieldAndGetUnderlying()[1]\n    return (self.pendingYieldRealized + newYield) * self._getPerformanceFeeRatio(self._getVaultRegistry()) // HUNDRED_PERCENT\n\n\n# get performance fee %\n\n\n@view\n@internal\ndef _getPerformanceFeeRatio(_vaultRegistry: address) -> uint256:\n    return staticcall VaultRegistry(_vaultRegistry).getPerformanceFee(self)\n\n\n#####################\n# Underlying Assets #\n#####################\n\n\n@view\n@internal\ndef _getUnderlyingYieldBalances() -> (uint256, uint256, address):\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return 0, 0, empty(address)\n\n    maxTotalAssets: uint256 = 0\n    safeTotalAssets: uint256 = 0\n\n    maxBalance: uint256 = 0\n    maxBalVaultToken: address = empty(address)\n\n    # iterate over each asset\n    legoBook: address = staticcall Registry(UNDY_HQ).getAddr(LEGO_BOOK_ID)\n    for i: uint256 in range(1, numAssets, bound=max_value(uint256)):\n\n        # get asset addr\n        vaultToken: address = self.assets[i]\n        if vaultToken == empty(address):\n            continue\n\n        vaultTokenBalance: uint256 = staticcall IERC20(vaultToken).balanceOf(self)\n        if vaultTokenBalance == 0:\n            continue\n\n        legoId: uint256 = self.vaultToLegoId[vaultToken]\n        if legoId == 0:\n            continue\n\n        legoAddr: address = staticcall Registry(legoBook).getAddr(legoId)\n        if legoAddr == empty(address):\n            continue\n\n        # get balance data\n        trueUnderlying: uint256 = 0\n        safeUnderlying: uint256 = 0\n        trueUnderlying, safeUnderlying = staticcall YieldLego(legoAddr).getUnderlyingBalances(vaultToken, vaultTokenBalance)\n\n        # add totals\n        maxTotalAssets += trueUnderlying\n        safeTotalAssets += safeUnderlying\n\n        # save max balance / token\n        if trueUnderlying > maxBalance:\n            maxBalance = trueUnderlying\n            maxBalVaultToken = vaultToken\n\n    return maxTotalAssets, safeTotalAssets, maxBalVaultToken\n\n\n###################\n# Redemption Prep #\n###################\n\n\n@internal\ndef _prepareRedemption(\n    _asset: address,\n    _amount: uint256,\n    _maxBalVaultToken: address,\n    _sender: address,\n    _vaultRegistry: address,\n) -> (uint256, uint256):\n    availAmount: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    if availAmount >= _amount:\n        return availAmount, 0\n\n    # get redemption config (buffer and min withdraw amount)\n    redemptionBuffer: uint256 = 0\n    minWithdrawAmount: uint256 = 0\n    redemptionBuffer, minWithdrawAmount = staticcall VaultRegistry(_vaultRegistry).redemptionConfig(self)\n\n    # buffer to make sure we pull out enough for redemption\n    bufferMultiplier: uint256 = HUNDRED_PERCENT + redemptionBuffer\n    targetWithdrawAmount: uint256 = _amount * bufferMultiplier // HUNDRED_PERCENT\n\n    withdrawnAmount: uint256 = 0\n    ad: VaultActionData = staticcall VaultRegistry(_vaultRegistry).getVaultActionDataBundle(0, _sender)\n    ad.vaultAsset = _asset\n    assetsToDeregister: DynArray[address, MAX_DEREGISTER_ASSETS] = []\n\n    # first withdraw from biggest yield position\n    if _maxBalVaultToken != empty(address):\n        underlyingAmount: uint256 = 0\n        needsDeregister: bool = False\n        underlyingAmount, needsDeregister = self._withdrawDuringRedemption(_maxBalVaultToken, targetWithdrawAmount, availAmount, minWithdrawAmount, 0, ad)\n        availAmount += underlyingAmount\n        withdrawnAmount += underlyingAmount\n        if needsDeregister:\n            assetsToDeregister.append(_maxBalVaultToken)\n\n    # next, iterate thru each yield position (order it is saved)\n    if availAmount < targetWithdrawAmount:\n        numAssets: uint256 = self.numAssets\n        if numAssets != 0:\n            for i: uint256 in range(1, numAssets, bound=max_value(uint256)):\n                if availAmount >= targetWithdrawAmount:\n                    break\n\n                vaultToken: address = self.assets[i]\n                if _maxBalVaultToken != empty(address) and vaultToken == _maxBalVaultToken:\n                    continue\n\n                # withdraw from yield opportunity\n                underlyingAmount: uint256 = 0\n                needsDeregister: bool = False\n                underlyingAmount, needsDeregister = self._withdrawDuringRedemption(vaultToken, targetWithdrawAmount, availAmount, minWithdrawAmount, len(assetsToDeregister), ad)\n                availAmount += underlyingAmount\n                withdrawnAmount += underlyingAmount\n\n                # add to deregister list\n                if needsDeregister and vaultToken not in assetsToDeregister:\n                    assetsToDeregister.append(vaultToken)\n\n    # deregister vault positions\n    for asset: address in assetsToDeregister:\n        self._deregisterYieldPosition(asset)\n\n    return availAmount, withdrawnAmount\n\n\n@internal\ndef _withdrawDuringRedemption(\n    _vaultToken: address,\n    _targetWithdrawAmount: uint256,\n    _availAmount: uint256,\n    _minWithdrawAmount: uint256,\n    _numDeregisterAssets: uint256,\n    _ad: VaultActionData,\n) -> (uint256, bool):\n    if _vaultToken == empty(address):\n        return 0, False\n\n    vaultTokenBalance: uint256 = staticcall IERC20(_vaultToken).balanceOf(self)\n    if vaultTokenBalance == 0:\n        return 0, _numDeregisterAssets < MAX_DEREGISTER_ASSETS # need to deregister\n\n    legoId: uint256 = self.vaultToLegoId[_vaultToken]\n    if legoId == 0:\n        return 0, False\n\n    ad: VaultActionData = _ad\n    ad.legoId = legoId\n    ad.legoAddr = staticcall Registry(ad.legoBook).getAddr(legoId)\n\n    # skip if amount still needed is below minimum (dust protection)\n    amountStillNeeded: uint256 = _targetWithdrawAmount - _availAmount\n    if _minWithdrawAmount != 0 and amountStillNeeded < _minWithdrawAmount:\n        return 0, False\n\n    # skip if vault tokens needed rounds to 0 (dust)\n    vaultTokensNeeded: uint256 = staticcall YieldLego(ad.legoAddr).getVaultTokenAmount(_ad.vaultAsset, amountStillNeeded, _vaultToken)\n    if vaultTokensNeeded == 0:\n        return 0, False\n\n    # withdraw from yield opportunity\n    underlyingAmount: uint256 = self._withdrawFromYield(_vaultToken, vaultTokensNeeded, empty(bytes32), 0, False, ad)[2]\n\n    # add to deregister list\n    needsDeregister: bool = False\n    if vaultTokensNeeded >= vaultTokenBalance and staticcall IERC20(_vaultToken).balanceOf(self) == 0 and _numDeregisterAssets < MAX_DEREGISTER_ASSETS:\n        needsDeregister = True\n\n    return underlyingAmount, needsDeregister\n\n\n###################\n# Yield Positions #\n###################\n\n\n# update yield position\n\n\n@external\ndef updateYieldPosition(_vaultToken: address):\n    assert self._isSwitchboardAddr(msg.sender) # dev: no perms\n    vaultRegistry: address = self._getVaultRegistry()\n    legoId: uint256 = 0\n    na: address = empty(address)\n    legoId, na = staticcall VaultRegistry(vaultRegistry).getLegoDataFromVaultToken(_vaultToken)\n    if legoId != 0:\n        self._updateYieldPosition(_vaultToken, legoId)\n\n\n@internal\ndef _updateYieldPosition(_vaultToken: address, _legoId: uint256):\n    if _vaultToken == empty(address):\n        return\n\n    # no balance, deregister asset\n    currentBalance: uint256 = staticcall IERC20(_vaultToken).balanceOf(self)\n    if currentBalance == 0:\n        self._deregisterYieldPosition(_vaultToken)\n        return\n\n    # first time, need to save lego mapping\n    legoId: uint256 = self.vaultToLegoId[_vaultToken]\n    if legoId == 0 and _legoId != 0:\n        self.vaultToLegoId[_vaultToken] = _legoId\n\n    # register asset (if necessary)\n    if self.indexOfAsset[_vaultToken] == 0:\n        self._registerYieldPosition(_vaultToken)\n\n\n# register yield position\n\n\n@internal\ndef _registerYieldPosition(_vaultToken: address):\n    aid: uint256 = self.numAssets\n    self.assets[aid] = _vaultToken\n    self.indexOfAsset[_vaultToken] = aid\n    self.numAssets = aid + 1\n\n\n# deregister yield position\n\n\n@internal\ndef _deregisterYieldPosition(_vaultToken: address) -> bool:\n    numAssets: uint256 = self.numAssets\n    if numAssets == 1:\n        return False\n\n    targetIndex: uint256 = self.indexOfAsset[_vaultToken]\n    if targetIndex == 0:\n        return False\n\n    # update data\n    lastIndex: uint256 = numAssets - 1\n    self.numAssets = lastIndex\n    self.indexOfAsset[_vaultToken] = 0\n\n    # get last item, replace the removed item\n    if targetIndex != lastIndex:\n        lastItem: address = self.assets[lastIndex]\n        self.assets[targetIndex] = lastItem\n        self.indexOfAsset[lastItem] = targetIndex\n\n    return True\n\n\n####################\n# Manager Settings #\n####################\n\n\n# can manage\n\n\n@internal\ndef _canManagerPerformAction(_signer: address, _legoIds: DynArray[uint256, MAX_LEGOS]) -> VaultActionData:\n    assert self.indexOfManager[_signer] != 0 # dev: not manager\n\n    # main data for this transaction - get action data and frozen status in single call\n    legoId: uint256 = 0\n    if len(_legoIds) != 0:\n        legoId = _legoIds[0]\n\n    vaultRegistry: address = self._getVaultRegistry()\n    ad: VaultActionData = empty(VaultActionData)\n    isVaultOpsFrozen: bool = False\n    ad, isVaultOpsFrozen = staticcall VaultRegistry(vaultRegistry).getVaultActionDataWithFrozenStatus(legoId, _signer, self)\n    ad.vaultAsset = VAULT_ASSET\n\n    # cannot perform any actions if vault is frozen\n    assert not isVaultOpsFrozen # dev: frozen vault\n\n    # make sure manager is not locked\n    assert not staticcall MissionControl(ad.missionControl).isLockedSigner(_signer) # dev: manager is locked\n\n    return ad\n\n\n# add manager\n\n\n@external\ndef addManager(_manager: address):\n    assert self._isSwitchboardAddr(msg.sender) # dev: no perms\n    self._registerManager(_manager)\n\n\n# register manager\n\n\n@internal\ndef _registerManager(_manager: address):\n    if self.indexOfManager[_manager] != 0:\n        return\n    mid: uint256 = self.numManagers\n    self.managers[mid] = _manager\n    self.indexOfManager[_manager] = mid\n    self.numManagers = mid + 1\n\n\n# remove manager\n\n\n@external\ndef removeManager(_manager: address):\n    assert self._isSwitchboardAddr(msg.sender) # dev: no perms\n\n    numManagers: uint256 = self.numManagers\n    if numManagers == 1:\n        return\n\n    targetIndex: uint256 = self.indexOfManager[_manager]\n    if targetIndex == 0:\n        return\n\n    # update data\n    lastIndex: uint256 = numManagers - 1\n    self.numManagers = lastIndex\n    self.indexOfManager[_manager] = 0\n\n    # get last item, replace the removed item\n    if targetIndex != lastIndex:\n        lastItem: address = self.managers[lastIndex]\n        self.managers[targetIndex] = lastItem\n        self.indexOfManager[lastItem] = targetIndex\n\n\n#############\n# Utilities #\n#############\n\n\n# get vault registry\n\n\n@view\n@internal\ndef _getVaultRegistry() -> address:\n    return staticcall Registry(UNDY_HQ).getAddr(VAULT_REGISTRY_ID)\n\n\n# is signer switchboard\n\n\n@view\n@internal\ndef _isSwitchboardAddr(_signer: address) -> bool:\n    switchboard: address = staticcall Registry(UNDY_HQ).getAddr(SWITCHBOARD_ID)\n    if switchboard == empty(address):\n        return False\n    return staticcall Switchboard(switchboard).isSwitchboardAddr(_signer)\n\n\n# approve\n\n\n@internal\ndef _getAmountAndApprove(_token: address, _amount: uint256, _legoAddr: address) -> uint256:\n    amount: uint256 = min(_amount, staticcall IERC20(_token).balanceOf(self))\n    assert amount != 0 # dev: no balance for _token\n    if _legoAddr != empty(address):\n        assert extcall IERC20(_token).approve(_legoAddr, amount, default_return_value = True) # dev: appr\n    return amount\n\n\n# lego access\n\n\n@internal\ndef _setLegoAccessForAction(_legoAddr: address, _action: ws.ActionType) -> bool:\n    if _legoAddr == empty(address):\n        return False\n\n    targetAddr: address = empty(address)\n    accessAbi: String[64] = empty(String[64])\n    numInputs: uint256 = 0\n    targetAddr, accessAbi, numInputs = staticcall Lego(_legoAddr).getAccessForLego(self, _action)\n\n    # nothing to do here\n    if targetAddr == empty(address):\n        return False\n\n    method_abi: bytes4 = convert(slice(keccak256(accessAbi), 0, 4), bytes4)\n    success: bool = False\n    response: Bytes[32] = b\"\"\n\n    # assumes input is: lego addr (operator)\n    if numInputs == 1:\n        success, response = raw_call(\n            targetAddr,\n            concat(\n                method_abi,\n                convert(_legoAddr, bytes32),\n            ),\n            revert_on_failure = False,\n            max_outsize = 32,\n        )\n    \n    # assumes input (and order) is: user (self), lego addr (operator)\n    elif numInputs == 2:\n        success, response = raw_call(\n            targetAddr,\n            concat(\n                method_abi,\n                convert(self, bytes32),\n                convert(_legoAddr, bytes32),\n            ),\n            revert_on_failure = False,\n            max_outsize = 32,\n        )\n\n    # assumes input (and order) is: user (self), lego addr (operator), allowed bool\n    elif numInputs == 3:\n        success, response = raw_call(\n            targetAddr,\n            concat(\n                method_abi,\n                convert(self, bytes32),\n                convert(_legoAddr, bytes32),\n                convert(True, bytes32),\n            ),\n            revert_on_failure = False,\n            max_outsize = 32,\n        )\n\n    assert success # dev: failed to set operator\n    return True\n\n\n# mini addys\n\n\n@view\n@internal\ndef _packMiniAddys(\n    _ledger: address,\n    _missionControl: address,\n    _legoBook: address,\n    _appraiser: address,\n) -> ws.MiniAddys:\n    return ws.MiniAddys(\n        ledger = _ledger,\n        missionControl = _missionControl,\n        legoBook = _legoBook,\n        appraiser = _appraiser,\n    )\n\n",
            "sha256sum": "61caf19a6d25ffd6794d5c80690611d91e9217c514154dd9cf284df5f0f8e24d"
          },
          "contracts/vaults/EarnVault.vy": {
            "content": "#    ________   __  __   _________  ______   ______   ________  __       ______   _________  \n#   /_______/\\ /_/\\/_/\\ /________/\\/_____/\\ /_____/\\ /_______/\\/_/\\     /_____/\\ /________/\\ \n#   \\::: _  \\ \\\\:\\ \\:\\ \\\\__.::.__\\/\\:::_ \\ \\\\:::_ \\ \\\\__.::._\\/\\:\\ \\    \\:::_ \\ \\\\__.::.__\\/ \n#    \\::(_)  \\ \\\\:\\ \\:\\ \\  \\::\\ \\   \\:\\ \\ \\ \\\\:(_) \\ \\  \\::\\ \\  \\:\\ \\    \\:\\ \\ \\ \\  \\::\\ \\   \n#     \\:: __  \\ \\\\:\\ \\:\\ \\  \\::\\ \\   \\:\\ \\ \\ \\\\: ___\\/  _\\::\\ \\__\\:\\ \\____\\:\\ \\ \\ \\  \\::\\ \\  \n#      \\:.\\ \\  \\ \\\\:\\_\\:\\ \\  \\::\\ \\   \\:\\_\\ \\ \\\\ \\ \\   /__\\::\\__/\\\\:\\/___/\\\\:\\_\\ \\ \\  \\::\\ \\ \n#       \\__\\/\\__\\/ \\_____\\/   \\__\\/    \\_____\\/ \\_\\/   \\________\\/ \\_____\\/ \\_____\\/   \\__\\/ \n#                                                                       \n#     \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n#     \u2551  ** Earn Autopilot Vaults **                                         \u2551\n#     \u2551  Managed by AI agents, enforced by onchain rules. Erc4626 compliant. \u2551\n#     \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n#\n#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nimplements: IERC4626\nimplements: IERC20\n\nexports: token.__interface__\ninitializes: token\nfrom contracts.vaults.modules import VaultErc20Token as token\n\nexports: vaultWallet.__interface__\ninitializes: vaultWallet\nfrom contracts.vaults.modules import EarnVaultWallet as vaultWallet\n\nfrom ethereum.ercs import IERC4626\nfrom ethereum.ercs import IERC20\nfrom ethereum.ercs import IERC20Detailed\n\ninterface VaultRegistry:\n    def getDepositConfig(_vaultAddr: address) -> (bool, uint256, bool, address): view\n    def canWithdraw(_vaultAddr: address) -> bool: view\n\nevent Deposit:\n    sender: indexed(address)\n    owner: indexed(address)\n    assets: uint256\n    shares: uint256\n\nevent Withdraw:\n    sender: indexed(address)\n    receiver: indexed(address)\n    owner: indexed(address)\n    assets: uint256\n    shares: uint256\n\nHUNDRED_PERCENT: constant(uint256) = 100_00 # 100.00%\n\n\n@deploy\ndef __init__(\n    _asset: address,\n    _tokenName: String[64],\n    _tokenSymbol: String[32],\n    _undyHq: address,\n    _minHqTimeLock: uint256,\n    _maxHqTimeLock: uint256,\n    _startingAgent: address,\n):\n    token.__init__(_tokenName, _tokenSymbol, staticcall IERC20Detailed(_asset).decimals(), _undyHq)\n    vaultWallet.__init__(_undyHq, _asset, _startingAgent)\n\n\n@view\n@external\ndef asset() -> address:\n    return vaultWallet.VAULT_ASSET\n\n\n@view\n@external\ndef totalAssets() -> uint256:\n    return self._getTotalAssets(True)\n\n\n################\n# Total Assets #\n################\n\n\n@view\n@external\ndef getTotalAssets(_shouldGetMax: bool) -> uint256:\n    return self._getTotalAssets(_shouldGetMax)\n\n\n@view\n@internal\ndef _getTotalAssets(_shouldGetMax: bool, _vaultRegistry: address = empty(address)) -> uint256:\n    vaultRegistry: address = _vaultRegistry\n    if vaultRegistry == empty(address):\n        vaultRegistry = vaultWallet._getVaultRegistry()\n    return self._getUnderlyingData(_shouldGetMax, vaultRegistry)[0]\n\n\n@view\n@internal\ndef _getUnderlyingData(_shouldGetMax: bool, _vaultRegistry: address) -> (uint256, uint256, uint256, address):\n    totalAssets: uint256 = staticcall IERC20(vaultWallet.VAULT_ASSET).balanceOf(self)\n\n    # all underlying assets\n    maxTotalAssets: uint256 = 0\n    safeTotalAssets: uint256 = 0\n    maxBalVaultToken: address = empty(address)\n    maxTotalAssets, safeTotalAssets, maxBalVaultToken = vaultWallet._getUnderlyingYieldBalances()\n\n    # new yield\n    currentBalance: uint256 = 0\n    newYield: uint256 = 0\n    currentBalance, newYield = vaultWallet._calcNewYieldAndGetUnderlying(maxTotalAssets)\n\n    # pending fees\n    pendingYieldRealized: uint256 = vaultWallet.pendingYieldRealized + newYield\n    pendingFees: uint256 = pendingYieldRealized * vaultWallet._getPerformanceFeeRatio(_vaultRegistry) // HUNDRED_PERCENT\n\n    # add total assets\n    if _shouldGetMax:\n        totalAssets += maxTotalAssets\n    else:\n        totalAssets += safeTotalAssets\n    totalAssets -= min(pendingFees, totalAssets)\n\n    return totalAssets, currentBalance, pendingYieldRealized, maxBalVaultToken\n\n\n############\n# Deposits #\n############\n\n\n@view\n@external\ndef maxDeposit(_receiver: address) -> uint256:\n    vaultRegistry: address = vaultWallet._getVaultRegistry()\n\n    # deposit config\n    canDeposit: bool = False\n    maxDepositAmount: uint256 = 0\n    na1: bool = False\n    na2: address = empty(address)\n    canDeposit, maxDepositAmount, na1, na2 = staticcall VaultRegistry(vaultRegistry).getDepositConfig(self)\n\n    if not canDeposit:\n        return 0\n\n    if maxDepositAmount == 0:\n        return max_value(uint256)\n\n    totalAssets: uint256 = self._getTotalAssets(True, vaultRegistry)\n    if totalAssets >= maxDepositAmount:\n        return 0\n\n    return maxDepositAmount - totalAssets\n\n\n@view\n@external\ndef previewDeposit(_assets: uint256) -> uint256:\n    return self._amountToShares(_assets, token.totalSupply, self._getTotalAssets(True), False)\n\n\n@nonreentrant\n@external\ndef deposit(_assets: uint256, _receiver: address = msg.sender) -> uint256:\n    return self._deposit(_assets, _receiver, 0)\n\n\n@nonreentrant\n@external\ndef depositWithMinAmountOut(_assets: uint256, _minAmountOut: uint256, _receiver: address = msg.sender) -> uint256:\n    return self._deposit(_assets, _receiver, _minAmountOut)\n\n\n@internal\ndef _deposit(_assets: uint256, _receiver: address, _minAmountOut: uint256) -> uint256:\n    vaultRegistry: address = vaultWallet._getVaultRegistry()\n    asset: address = vaultWallet.VAULT_ASSET\n\n    amount: uint256 = _assets\n    if amount == max_value(uint256):\n        amount = staticcall IERC20(asset).balanceOf(msg.sender)\n\n    # underlying data\n    totalAssets: uint256 = 0\n    currentBalance: uint256 = 0\n    pendingYieldRealized: uint256 = 0\n    maxBalVaultToken: address = empty(address)\n    totalAssets, currentBalance, pendingYieldRealized, maxBalVaultToken = self._getUnderlyingData(True, vaultRegistry)\n\n    shares: uint256 = self._amountToShares(amount, token.totalSupply, totalAssets, False)\n    if _minAmountOut != 0:\n        assert shares >= _minAmountOut # dev: insufficient shares\n\n    self._depositIntoVault(asset, amount, shares, _receiver, totalAssets, currentBalance, pendingYieldRealized, maxBalVaultToken, vaultRegistry)\n    return shares\n\n\n# mint\n\n\n@view\n@external\ndef maxMint(_receiver: address) -> uint256:\n    vaultRegistry: address = vaultWallet._getVaultRegistry()\n\n    # deposit config\n    canDeposit: bool = False\n    maxDepositAmount: uint256 = 0\n    na1: bool = False\n    na2: address = empty(address)\n    canDeposit, maxDepositAmount, na1, na2 = staticcall VaultRegistry(vaultRegistry).getDepositConfig(self)\n\n    if not canDeposit:\n        return 0\n\n    if maxDepositAmount == 0:\n        return max_value(uint256)\n\n    totalAssets: uint256 = self._getTotalAssets(True, vaultRegistry)\n    if totalAssets >= maxDepositAmount:\n        return 0\n\n    maxDepositAmt: uint256 = maxDepositAmount - totalAssets\n    return self._amountToShares(maxDepositAmt, token.totalSupply, totalAssets, False)\n\n\n@view\n@external\ndef previewMint(_shares: uint256) -> uint256:\n    return self._sharesToAmount(_shares, token.totalSupply, self._getTotalAssets(True), True)\n\n\n@nonreentrant\n@external\ndef mint(_shares: uint256, _receiver: address = msg.sender) -> uint256:\n    vaultRegistry: address = vaultWallet._getVaultRegistry()\n\n    # underlying data\n    totalAssets: uint256 = 0\n    currentBalance: uint256 = 0\n    pendingYieldRealized: uint256 = 0\n    maxBalVaultToken: address = empty(address)\n    totalAssets, currentBalance, pendingYieldRealized, maxBalVaultToken = self._getUnderlyingData(True, vaultRegistry)\n\n    amount: uint256 = self._sharesToAmount(_shares, token.totalSupply, totalAssets, True)\n    self._depositIntoVault(vaultWallet.VAULT_ASSET, amount, _shares, _receiver, totalAssets, currentBalance, pendingYieldRealized, maxBalVaultToken, vaultRegistry)\n    return amount\n\n\n# shared deposit logic\n\n\n@internal\ndef _depositIntoVault(\n    _asset: address,\n    _amount: uint256,\n    _shares: uint256,\n    _recipient: address,\n    _totalAssets: uint256,\n    _currentBalance: uint256,\n    _pendingYieldRealized: uint256,\n    _maxBalVaultToken: address,\n    _vaultRegistry: address,\n):\n    # get all deposit config\n    canDeposit: bool = False\n    maxDepositAmount: uint256 = 0\n    shouldAutoDeposit: bool = False\n    defaultTargetVaultToken: address = empty(address)\n    canDeposit, maxDepositAmount, shouldAutoDeposit, defaultTargetVaultToken = staticcall VaultRegistry(_vaultRegistry).getDepositConfig(self)\n\n    assert canDeposit # dev: cannot deposit\n    assert _amount != 0 # dev: cannot deposit 0 amount\n    assert _shares != 0 # dev: cannot receive 0 shares\n    assert _recipient != empty(address) # dev: invalid recipient\n    if maxDepositAmount != 0:\n        assert _totalAssets + _amount <= maxDepositAmount # dev: exceeds max deposit\n\n    # transfer assets to vault\n    assert extcall IERC20(_asset).transferFrom(msg.sender, self, _amount, default_return_value=True) # dev: deposit failed\n\n    # put the deposit to work -- start earning\n    amountDeposited: uint256 = 0\n    if shouldAutoDeposit:\n        targetVaultToken: address = defaultTargetVaultToken\n        if targetVaultToken == empty(address):\n            targetVaultToken = _maxBalVaultToken\n        amountDeposited = vaultWallet._onReceiveVaultFunds(targetVaultToken, _recipient, _vaultRegistry)\n\n    # save data\n    currentBalance: uint256 = _currentBalance + amountDeposited\n    vaultWallet.lastUnderlyingBal = currentBalance\n    vaultWallet.pendingYieldRealized = _pendingYieldRealized\n\n    token._mint(_recipient, _shares)\n    log Deposit(sender=msg.sender, owner=_recipient, assets=_amount, shares=_shares)\n\n\n###############\n# Withdrawals #\n###############\n\n\n@view\n@external\ndef maxWithdraw(_owner: address) -> uint256:\n    ownerShares: uint256 = token.balanceOf[_owner]\n    if ownerShares == 0:\n        return 0\n    availableAssets: uint256 = self._getTotalAssets(False)\n    ownerAssets: uint256 = self._sharesToAmount(ownerShares, token.totalSupply, availableAssets, False)\n    return min(ownerAssets, availableAssets)\n\n\n@view\n@external\ndef previewWithdraw(_assets: uint256) -> uint256:\n    return self._amountToShares(_assets, token.totalSupply, self._getTotalAssets(False), True)\n\n\n@nonreentrant\n@external\ndef withdraw(_assets: uint256, _receiver: address = msg.sender, _owner: address = msg.sender) -> uint256:\n    vaultRegistry: address = vaultWallet._getVaultRegistry()\n\n    # underlying data\n    totalAssets: uint256 = 0\n    currentBalance: uint256 = 0\n    pendingYieldRealized: uint256 = 0\n    maxBalVaultToken: address = empty(address)\n    totalAssets, currentBalance, pendingYieldRealized, maxBalVaultToken = self._getUnderlyingData(False, vaultRegistry)\n\n    shares: uint256 = self._amountToShares(_assets, token.totalSupply, totalAssets, True)\n    self._redeemFromVault(vaultWallet.VAULT_ASSET, _assets, 0, shares, msg.sender, _receiver, _owner, currentBalance, pendingYieldRealized, maxBalVaultToken, vaultRegistry)\n    return shares\n\n\n# redeem\n\n\n@view\n@external\ndef maxRedeem(_owner: address) -> uint256:\n    return token.balanceOf[_owner]\n\n\n@view\n@external\ndef previewRedeem(_shares: uint256) -> uint256:\n    return self._sharesToAmount(_shares, token.totalSupply, self._getTotalAssets(False), False)\n\n\n@nonreentrant\n@external\ndef redeem(_shares: uint256, _receiver: address = msg.sender, _owner: address = msg.sender) -> uint256:\n    return self._redeem(_shares, msg.sender, _receiver, _owner, 0)\n\n\n@nonreentrant\n@external\ndef redeemWithMinAmountOut(_shares: uint256, _minAmountOut: uint256, _receiver: address = msg.sender, _owner: address = msg.sender) -> uint256:\n    return self._redeem(_shares, msg.sender, _receiver, _owner, _minAmountOut)\n\n\n@internal\ndef _redeem(_shares: uint256, _sender: address, _receiver: address, _owner: address, _minAmountOut: uint256) -> uint256:\n    vaultRegistry: address = vaultWallet._getVaultRegistry()\n\n    shares: uint256 = _shares\n    if shares == max_value(uint256):\n        shares = token.balanceOf[_owner]\n\n    # underlying data\n    totalAssets: uint256 = 0\n    currentBalance: uint256 = 0\n    pendingYieldRealized: uint256 = 0\n    maxBalVaultToken: address = empty(address)\n    totalAssets, currentBalance, pendingYieldRealized, maxBalVaultToken = self._getUnderlyingData(False, vaultRegistry)\n\n    amount: uint256 = self._sharesToAmount(shares, token.totalSupply, totalAssets, False)\n    return self._redeemFromVault(vaultWallet.VAULT_ASSET, amount, _minAmountOut, shares, _sender, _receiver, _owner, currentBalance, pendingYieldRealized, maxBalVaultToken, vaultRegistry)\n\n\n# shared redeem logic\n\n\n@internal\ndef _redeemFromVault(\n    _asset: address,\n    _amount: uint256,\n    _minAmountOut: uint256,\n    _shares: uint256,\n    _sender: address,\n    _recipient: address,\n    _owner: address,\n    _currentBalance: uint256,\n    _pendingYieldRealized: uint256,\n    _maxBalVaultToken: address,\n    _vaultRegistry: address,\n) -> uint256:\n    assert staticcall VaultRegistry(_vaultRegistry).canWithdraw(self) # dev: cannot withdraw\n\n    assert _amount != 0 # dev: cannot withdraw 0 amount\n    assert _shares != 0 # dev: cannot redeem 0 shares\n    assert _recipient != empty(address) # dev: invalid recipient\n\n    assert token.balanceOf[_owner] >= _shares # dev: insufficient shares\n\n    if _sender != _owner:\n        token._spendAllowance(_owner, _sender, _shares)\n\n    # withdraw from yield opportunity\n    availAmount: uint256 = 0\n    withdrawnAmount: uint256 = 0\n    availAmount, withdrawnAmount = vaultWallet._prepareRedemption(_asset, _amount, _maxBalVaultToken, _sender, _vaultRegistry)\n    actualAmount: uint256 = min(availAmount, _amount)\n\n    # check amount out\n    if _minAmountOut != 0:\n        assert actualAmount >= _minAmountOut # dev: insufficient amount out\n    else:\n        assert self._isRedemptionCloseEnough(_amount, actualAmount) # dev: insufficient funds\n\n    # save data\n    currentBalance: uint256 = _currentBalance - min(_currentBalance, withdrawnAmount)\n    vaultWallet.lastUnderlyingBal = currentBalance\n    vaultWallet.pendingYieldRealized = _pendingYieldRealized\n\n    # burn shares, transfer assets\n    token._burn(_owner, _shares)\n    assert extcall IERC20(_asset).transfer(_recipient, actualAmount, default_return_value=True) # dev: withdrawal failed\n\n    log Withdraw(sender=_sender, receiver=_recipient, owner=_owner, assets=actualAmount, shares=_shares)\n    return actualAmount\n\n\n@pure\n@internal\ndef _isRedemptionCloseEnough(_requestedAmount: uint256, _actualAmount: uint256) -> bool:\n    # extra check to make sure what was sent was actually close-ish to what was requested\n    buffer: uint256 = _requestedAmount * 10 // HUNDRED_PERCENT # 0.1%\n    lowerBound: uint256 = _requestedAmount - buffer\n    return _actualAmount >= lowerBound\n\n\n##########\n# Shares #\n##########\n\n\n@view\n@external\ndef convertToShares(_assets: uint256) -> uint256:\n    return self._amountToShares(_assets, token.totalSupply, self._getTotalAssets(True), False)\n\n\n@view\n@external\ndef convertToSharesSafe(_assets: uint256) -> uint256:\n    return self._amountToShares(_assets, token.totalSupply, self._getTotalAssets(False), False)\n\n\n@view\n@external\ndef convertToAssets(_shares: uint256) -> uint256:\n    return self._sharesToAmount(_shares, token.totalSupply, self._getTotalAssets(True), False)\n\n\n@view\n@external\ndef convertToAssetsSafe(_shares: uint256) -> uint256:\n    return self._sharesToAmount(_shares, token.totalSupply, self._getTotalAssets(False), False)\n\n\n# amount -> shares\n\n\n@view\n@internal\ndef _amountToShares(\n    _amount: uint256,\n    _totalShares: uint256,\n    _totalBalance: uint256,\n    _shouldRoundUp: bool,\n) -> uint256:\n    if _amount == max_value(uint256) or _amount == 0:\n        return _amount\n\n    # first deposit, price per share = 1\n    if _totalShares == 0:\n        return _amount\n\n    # no underlying balance, price per share = 0\n    if _totalBalance == 0:\n        return 0\n\n    # calc shares\n    numerator: uint256 = _amount * _totalShares\n    shares: uint256 = numerator // _totalBalance\n\n    # rounding\n    if _shouldRoundUp and (numerator % _totalBalance != 0):\n        shares += 1\n\n    return shares\n\n\n# shares -> amount\n\n\n@view\n@internal\ndef _sharesToAmount(\n    _shares: uint256,\n    _totalShares: uint256,\n    _totalBalance: uint256,\n    _shouldRoundUp: bool,\n) -> uint256:\n    if _shares == max_value(uint256) or _shares == 0:\n        return _shares\n\n    # first deposit, price per share = 1\n    if _totalShares == 0:\n        return _shares\n\n    # calc amount\n    numerator: uint256 = _shares * _totalBalance\n    amount: uint256 = numerator // _totalShares\n\n    # rounding\n    if _shouldRoundUp and (numerator % _totalShares != 0):\n        amount += 1\n\n    return amount\n",
            "sha256sum": "4404360a1443d0d8fc4f990e19f2bcc78413322ddd906e276df625cc8181273e"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/vaults/EarnVault.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.3+commit.bff19ea2",
        "integrity": "c6fdf6e04d79c8f1adfe0287effde9a98c581054dad097e446fe37d03bbcfc1e"
      },
      "args": "000000000000000000000000820c137fa70c8691f0e44dc420a5e53c168921dc00000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000012000000000000000000000000044cf3c4f000dfd76a35d03298049d37be688d6f90000000000000000000000000000000000000000000000000000000000000e10000000000000000000000000000000000000000000000000000000000013c6800000000000000000000000009d3f593380875860cc18f5736373ae4b084ba2f90000000000000000000000000000000000000000000000000000000000000019556e64657273636f726520426c756520436869702055534453000000000000000000000000000000000000000000000000000000000000000000000000000008756e647955534453000000000000000000000000000000000000000000000000",
      "file": "contracts/vaults/EarnVault.vy"
    },
    "UndyCbeth": {
      "address": "0xe9EA27C1c67F12D04cb4694F8618AE8Bdb278E50",
      "abi": [
        {
          "name": "Deposit",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "owner",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assets",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "shares",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "Withdraw",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "receiver",
              "type": "address",
              "indexed": true
            },
            {
              "name": "owner",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assets",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "shares",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "Transfer",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "Approval",
          "inputs": [
            {
              "name": "owner",
              "type": "address",
              "indexed": true
            },
            {
              "name": "spender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "BlacklistModified",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "isBlacklisted",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "TokenPauseModified",
          "inputs": [
            {
              "name": "isPaused",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "EarnVaultAction",
          "inputs": [
            {
              "name": "op",
              "type": "uint8",
              "indexed": false
            },
            {
              "name": "asset1",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset2",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount1",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "amount2",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "legoId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "signer",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PerformanceFeesClaimed",
          "inputs": [
            {
              "name": "pendingFees",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "name",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "string"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "symbol",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "string"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "decimals",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint8"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "transfer",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "transferFrom",
          "inputs": [
            {
              "name": "_sender",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "approve",
          "inputs": [
            {
              "name": "_spender",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "increaseAllowance",
          "inputs": [
            {
              "name": "_spender",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "decreaseAllowance",
          "inputs": [
            {
              "name": "_spender",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "burn",
          "inputs": [
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "DOMAIN_SEPARATOR",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bytes32"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "permit",
          "inputs": [
            {
              "name": "_owner",
              "type": "address"
            },
            {
              "name": "_spender",
              "type": "address"
            },
            {
              "name": "_value",
              "type": "uint256"
            },
            {
              "name": "_deadline",
              "type": "uint256"
            },
            {
              "name": "_signature",
              "type": "bytes"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setBlacklist",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            },
            {
              "name": "_shouldBlacklist",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "burnBlacklistTokens",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "burnBlacklistTokens",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pause",
          "inputs": [
            {
              "name": "_shouldPause",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "undyHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "blacklisted",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isPaused",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "balanceOf",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "allowance",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalSupply",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "TOKEN_NAME",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "string"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "TOKEN_SYMBOL",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "string"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "TOKEN_DECIMALS",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint8"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "VERSION",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "string"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "nonces",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositForYield",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositForYield",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositForYield",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositForYield",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawFromYield",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawFromYield",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawFromYield",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawFromYield",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_isSpecialTx",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_instructions",
              "type": "tuple[]",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "minAmountOut",
                  "type": "uint256"
                },
                {
                  "name": "tokenPath",
                  "type": "address[]"
                },
                {
                  "name": "poolPath",
                  "type": "address[]"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimPerformanceFees",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getClaimablePerformanceFees",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "updateYieldPosition",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addManager",
          "inputs": [
            {
              "name": "_manager",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeManager",
          "inputs": [
            {
              "name": "_manager",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "lastUnderlyingBal",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingYieldRealized",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "vaultToLegoId",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assets",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "managers",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfManager",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numManagers",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "asset",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getTotalAssets",
          "inputs": [
            {
              "name": "_shouldGetMax",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "maxDeposit",
          "inputs": [
            {
              "name": "_receiver",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "previewDeposit",
          "inputs": [
            {
              "name": "_assets",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "deposit",
          "inputs": [
            {
              "name": "_assets",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "deposit",
          "inputs": [
            {
              "name": "_assets",
              "type": "uint256"
            },
            {
              "name": "_receiver",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositWithMinAmountOut",
          "inputs": [
            {
              "name": "_assets",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositWithMinAmountOut",
          "inputs": [
            {
              "name": "_assets",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_receiver",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "maxMint",
          "inputs": [
            {
              "name": "_receiver",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "previewMint",
          "inputs": [
            {
              "name": "_shares",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mint",
          "inputs": [
            {
              "name": "_shares",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mint",
          "inputs": [
            {
              "name": "_shares",
              "type": "uint256"
            },
            {
              "name": "_receiver",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "maxWithdraw",
          "inputs": [
            {
              "name": "_owner",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "previewWithdraw",
          "inputs": [
            {
              "name": "_assets",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdraw",
          "inputs": [
            {
              "name": "_assets",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdraw",
          "inputs": [
            {
              "name": "_assets",
              "type": "uint256"
            },
            {
              "name": "_receiver",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdraw",
          "inputs": [
            {
              "name": "_assets",
              "type": "uint256"
            },
            {
              "name": "_receiver",
              "type": "address"
            },
            {
              "name": "_owner",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "maxRedeem",
          "inputs": [
            {
              "name": "_owner",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "previewRedeem",
          "inputs": [
            {
              "name": "_shares",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "redeem",
          "inputs": [
            {
              "name": "_shares",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "redeem",
          "inputs": [
            {
              "name": "_shares",
              "type": "uint256"
            },
            {
              "name": "_receiver",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "redeem",
          "inputs": [
            {
              "name": "_shares",
              "type": "uint256"
            },
            {
              "name": "_receiver",
              "type": "address"
            },
            {
              "name": "_owner",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "redeemWithMinAmountOut",
          "inputs": [
            {
              "name": "_shares",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "redeemWithMinAmountOut",
          "inputs": [
            {
              "name": "_shares",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_receiver",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "redeemWithMinAmountOut",
          "inputs": [
            {
              "name": "_shares",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_receiver",
              "type": "address"
            },
            {
              "name": "_owner",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "convertToShares",
          "inputs": [
            {
              "name": "_assets",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "convertToSharesSafe",
          "inputs": [
            {
              "name": "_assets",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "convertToAssets",
          "inputs": [
            {
              "name": "_shares",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "convertToAssetsSafe",
          "inputs": [
            {
              "name": "_shares",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_tokenName",
              "type": "string"
            },
            {
              "name": "_tokenSymbol",
              "type": "string"
            },
            {
              "name": "_undyHq",
              "type": "address"
            },
            {
              "name": "_minHqTimeLock",
              "type": "uint256"
            },
            {
              "name": "_maxHqTimeLock",
              "type": "uint256"
            },
            {
              "name": "_startingAgent",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/vaults/modules/VaultErc20Token.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nimplements: IERC20\nfrom ethereum.ercs import IERC20\n\ninterface UndyHq:\n    def canSetTokenBlacklist(_addr: address) -> bool: view\n    def canMintUndy(_addr: address) -> bool: view\n    def hasPendingGovChange() -> bool: view\n    def governance() -> address: view\n\ninterface ERC1271:\n    def isValidSignature(_hash: bytes32, _signature: Bytes[65]) -> bytes4: view\n\n# erc20\n\nevent Transfer:\n    sender: indexed(address)\n    recipient: indexed(address)\n    amount: uint256\n\nevent Approval:\n    owner: indexed(address)\n    spender: indexed(address)\n    amount: uint256\n\n# undy \n\nevent BlacklistModified:\n    addr: indexed(address)\n    isBlacklisted: bool\n\nevent TokenPauseModified:\n    isPaused: bool\n\n# undy hq\nundyHq: public(address)\n\n# config\nblacklisted: public(HashMap[address, bool])\nisPaused: public(bool)\n\n# erc20\nbalanceOf: public(HashMap[address, uint256])\nallowance: public(HashMap[address, HashMap[address, uint256]])\ntotalSupply: public(uint256)\n\n# token info\nTOKEN_NAME: public(immutable(String[64]))\nTOKEN_SYMBOL: public(immutable(String[32]))\nTOKEN_DECIMALS: public(immutable(uint8))\nVERSION: public(constant(String[8])) = \"v1.0.0\"\n\n# eip-712\nnonces: public(HashMap[address, uint256])\nEIP712_TYPEHASH: constant(bytes32) = keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\")\nEIP2612_TYPEHASH: constant(bytes32) = keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\")\nECRECOVER_PRECOMPILE: constant(address) = 0x0000000000000000000000000000000000000001\nERC1271_MAGIC_VAL: constant(bytes4) = 0x1626ba7e\n\nCACHED_DOMAIN_SEPARATOR: immutable(bytes32)\nNAME_HASH: immutable(bytes32)\nVERSION_HASH: constant(bytes32) = keccak256(VERSION)\nCACHED_CHAIN_ID: immutable(uint256)\n\n\n@deploy\ndef __init__(\n    _tokenName: String[64],\n    _tokenSymbol: String[32],\n    _tokenDecimals: uint8,\n    _undyHq: address,\n):\n    # token info\n    TOKEN_NAME = _tokenName\n    TOKEN_SYMBOL = _tokenSymbol\n    TOKEN_DECIMALS = _tokenDecimals\n\n    # set undy hq\n    assert _undyHq != empty(address) # dev: invalid undy hq\n    self.undyHq = _undyHq\n\n    # domain separator\n    NAME_HASH = keccak256(_tokenName)\n    CACHED_CHAIN_ID = chain.id\n    CACHED_DOMAIN_SEPARATOR = keccak256(\n        abi_encode(\n            EIP712_TYPEHASH,\n            NAME_HASH,\n            VERSION_HASH,\n            CACHED_CHAIN_ID,\n            self,\n        )\n    )\n\n\n##############\n# Token Info #\n##############\n\n\n@view\n@external\ndef name() -> String[64]:\n    return TOKEN_NAME\n\n\n@view\n@external\ndef symbol() -> String[32]:\n    return TOKEN_SYMBOL\n\n\n@view\n@external\ndef decimals() -> uint8:\n    return TOKEN_DECIMALS\n\n\n#############\n# Transfers #\n#############\n\n\n@external\ndef transfer(_recipient: address, _amount: uint256) -> bool:\n    self._transfer(msg.sender, _recipient, _amount)\n    return True\n\n\n@external\ndef transferFrom(_sender: address, _recipient: address, _amount: uint256) -> bool:\n    assert not self.blacklisted[msg.sender] # dev: spender blacklisted\n    self._spendAllowance(_sender, msg.sender, _amount)\n    self._transfer(_sender, _recipient, _amount)\n    return True\n\n\n@internal\ndef _transfer(_sender: address, _recipient: address, _amount: uint256):\n    assert not self.isPaused # dev: token paused\n    assert _amount != 0 # dev: cannot transfer 0 amount\n    assert _recipient not in [self, empty(address)] # dev: invalid recipient\n\n    assert not self.blacklisted[_sender] # dev: sender blacklisted\n    assert not self.blacklisted[_recipient] # dev: recipient blacklisted\n\n    senderBalance: uint256 = self.balanceOf[_sender]\n    assert senderBalance >= _amount # dev: insufficient funds\n    self.balanceOf[_sender] = senderBalance - _amount\n    self.balanceOf[_recipient] += _amount\n\n    log Transfer(sender=_sender, recipient=_recipient, amount=_amount)\n\n\n#############\n# Allowance #\n#############\n\n\n# approvals\n\n\n@external\ndef approve(_spender: address, _amount: uint256) -> bool:\n    self._validateNewApprovals(msg.sender, _spender)\n    self._approve(msg.sender, _spender, _amount)\n    return True\n\n\n@internal\ndef _approve(_owner: address, _spender: address, _amount: uint256):\n    self.allowance[_owner][_spender] = _amount\n    log Approval(owner=_owner, spender=_spender, amount=_amount)\n\n\n@internal\ndef _spendAllowance(_owner: address, _spender: address, _amount: uint256):\n    currentAllowance: uint256 = self.allowance[_owner][_spender]\n    if currentAllowance != max_value(uint256):\n        assert currentAllowance >= _amount # dev: insufficient allowance\n        self._approve(_owner, _spender, currentAllowance - _amount)\n\n\n# increase / decrease allowance\n\n\n@external\ndef increaseAllowance(_spender: address, _amount: uint256) -> bool:\n    self._validateNewApprovals(msg.sender, _spender)\n    currentAllowance: uint256 = self.allowance[msg.sender][_spender]\n    maxIncrease: uint256 = max_value(uint256) - currentAllowance\n    newAllowance: uint256 = currentAllowance + min(_amount, maxIncrease)\n    if newAllowance != currentAllowance:\n        self._approve(msg.sender, _spender, newAllowance)\n    return True\n\n\n@external\ndef decreaseAllowance(_spender: address, _amount: uint256) -> bool:\n    self._validateNewApprovals(msg.sender, _spender)\n    currentAllowance: uint256 = self.allowance[msg.sender][_spender]\n    newAllowance: uint256 = currentAllowance - min(_amount, currentAllowance)\n    if newAllowance != currentAllowance:\n        self._approve(msg.sender, _spender, newAllowance)\n    return True\n\n\n# validation\n\n\n@view\n@internal\ndef _validateNewApprovals(_owner: address, _spender: address):\n    assert not self.isPaused # dev: token paused\n    assert not self.blacklisted[_owner] # dev: owner blacklisted\n    assert not self.blacklisted[_spender] # dev: spender blacklisted\n    assert _spender != empty(address) # dev: invalid spender\n\n\n#####################\n# Minting / Burning #\n#####################\n\n\n# mint tokens\n\n\n@internal\ndef _mint(_recipient: address, _amount: uint256) -> bool:\n    assert _recipient not in [self, empty(address)] # dev: invalid recipient\n    assert not self.blacklisted[_recipient] # dev: blacklisted\n    assert not self.isPaused # dev: token paused\n\n    self.balanceOf[_recipient] += _amount\n    self.totalSupply += _amount\n    log Transfer(sender=empty(address), recipient=_recipient, amount=_amount)\n    return True\n\n\n# burn tokens\n\n\n@external\ndef burn(_amount: uint256) -> bool:\n    assert not self.isPaused # dev: token paused\n    self._burn(msg.sender, _amount)\n    return True\n\n\n@internal\ndef _burn(_owner: address, _amount: uint256):\n    self.balanceOf[_owner] -= _amount\n    self.totalSupply -= _amount\n    log Transfer(sender=_owner, recipient=empty(address), amount=_amount)\n\n\n###########\n# EIP 712 #\n###########\n\n\n@view\n@external\ndef DOMAIN_SEPARATOR() -> bytes32:\n    return self._domainSeparator()\n\n\n@view\n@internal\ndef _domainSeparator() -> bytes32:\n    if chain.id != CACHED_CHAIN_ID:\n        return keccak256(\n            abi_encode(\n                EIP712_TYPEHASH,\n                NAME_HASH,\n                VERSION_HASH,\n                chain.id,\n                self,\n            )\n        )\n    return CACHED_DOMAIN_SEPARATOR\n\n\n@external\ndef permit(\n    _owner: address,\n    _spender: address,\n    _value: uint256,\n    _deadline: uint256,\n    _signature: Bytes[65],\n) -> bool:\n    self._validateNewApprovals(_owner, _spender)\n    assert _owner != empty(address) and block.timestamp <= _deadline # dev: permit expired\n\n    nonce: uint256 = self.nonces[_owner]\n    digest: bytes32 = keccak256(\n        concat(\n            b\"\\x19\\x01\",\n            self._domainSeparator(),\n            keccak256(abi_encode(EIP2612_TYPEHASH, _owner, _spender, _value, nonce, _deadline)),\n        )\n    )\n\n    if _owner.is_contract:\n        assert staticcall ERC1271(_owner).isValidSignature(digest, _signature) == ERC1271_MAGIC_VAL # dev: invalid signature\n\n    else:\n        r: bytes32 = convert(slice(_signature, 0, 32), bytes32)\n        s: bytes32 = convert(slice(_signature, 32, 32), bytes32)\n        v: uint8 = convert(slice(_signature, 64, 1), uint8)\n\n        # validate v parameter (27 or 28)\n        if v < 27:\n            v = v + 27\n        assert v == 27 or v == 28 # dev: invalid v parameter\n\n        # prevent signature malleability by ensuring s is in lower half of curve order\n        s_uint: uint256 = convert(s, uint256)\n        assert s_uint != 0 # dev: invalid s value (zero)\n        assert s_uint <= convert(0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, uint256) # dev: invalid s value\n\n        response: Bytes[32] = raw_call(\n            ECRECOVER_PRECOMPILE,\n            abi_encode(digest, v, r, s),\n            max_outsize = 32,\n            is_static_call = True # a view function\n        )\n        assert len(response) == 32  # dev: invalid ecrecover response length\n        assert abi_decode(response, address) == _owner  # dev: invalid signature\n\n    self.nonces[_owner] = nonce + 1\n    self._approve(_owner, _spender, _value)\n    return True\n\n\n#############\n# Blacklist #\n#############\n\n\n@external\ndef setBlacklist(_addr: address, _shouldBlacklist: bool) -> bool:\n    assert staticcall UndyHq(self.undyHq).canSetTokenBlacklist(msg.sender) # dev: no perms\n\n    assert _addr not in [self, empty(address)] # dev: invalid blacklist recipient\n    self.blacklisted[_addr] = _shouldBlacklist\n    log BlacklistModified(addr=_addr, isBlacklisted=_shouldBlacklist)\n    return True\n\n\n@external\ndef burnBlacklistTokens(_addr: address, _amount: uint256 = max_value(uint256)) -> bool:\n    assert msg.sender == staticcall UndyHq(self.undyHq).governance() # dev: no perms\n    assert self.blacklisted[_addr] # dev: not blacklisted\n\n    amount: uint256 = min(_amount, self.balanceOf[_addr])\n    assert amount != 0 # dev: cannot burn 0 tokens\n    self._burn(_addr, amount)\n    return True\n\n\n#########\n# Pause #\n#########\n\n\n@external\ndef pause(_shouldPause: bool):\n    assert msg.sender == staticcall UndyHq(self.undyHq).governance() # dev: no perms\n    assert _shouldPause != self.isPaused # dev: no change\n    self.isPaused = _shouldPause\n    log TokenPauseModified(isPaused=_shouldPause)\n",
            "sha256sum": "c01f0100f9d040bbd95c91f201e0623bd0331c6982e5ef73e832a37bb27eee08"
          },
          "interfaces/Wallet.vyi": {
            "content": "# @version 0.4.3\n\nstruct SwapInstruction:\n    legoId: uint256\n    amountIn: uint256\n    minAmountOut: uint256\n    tokenPath: DynArray[address, MAX_TOKEN_PATH]\n    poolPath: DynArray[address, MAX_TOKEN_PATH - 1]\n\nMAX_SWAP_INSTRUCTIONS: constant(uint256) = 5\nMAX_TOKEN_PATH: constant(uint256) = 5\n\n\n@view\n@external\ndef onERC721Received(_operator: address, _owner: address, _tokenId: uint256, _data: Bytes[1024]) -> bytes4:\n    ...\n\n\n@pure\n@external\ndef apiVersion() -> String[28]:\n    ...\n\n##################\n# Transfer Funds #\n##################\n\n\n@external\ndef transferFunds(\n    _recipient: address,\n    _asset: address = empty(address),\n    _amount: uint256 = max_value(uint256),\n    _isCheque: bool = False,\n    _isTrustedTx: bool = False,\n) -> (uint256, uint256):\n    ...\n\n\n#########\n# Yield #\n#########\n\n\n# deposit\n\n\n@external\ndef depositForYield(\n    _legoId: uint256,\n    _asset: address,\n    _vaultAddr: address = empty(address),\n    _amount: uint256 = max_value(uint256),\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, address, uint256, uint256):\n    ...\n\n\n# withdraw\n\n\n@external\ndef withdrawFromYield(\n    _legoId: uint256,\n    _vaultToken: address,\n    _amount: uint256 = max_value(uint256),\n    _extraData: bytes32 = empty(bytes32),\n    _isTrustedTx: bool = False,\n) -> (uint256, address, uint256, uint256):\n    ...\n\n\n# rebalance position\n\n\n@external\ndef rebalanceYieldPosition(\n    _fromLegoId: uint256,\n    _fromVaultToken: address,\n    _toLegoId: uint256,\n    _toVaultAddr: address = empty(address),\n    _fromVaultAmount: uint256 = max_value(uint256),\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, address, uint256, uint256):\n    ...\n\n\n###################\n# Swap / Exchange #\n###################\n\n\n@external\ndef swapTokens(_instructions: DynArray[SwapInstruction, MAX_SWAP_INSTRUCTIONS]) -> (address, uint256, address, uint256, uint256):\n    ...\n\n\n# mint / redeem\n\n\n@external\ndef mintOrRedeemAsset(\n    _legoId: uint256,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256 = max_value(uint256),\n    _minAmountOut: uint256 = 0,\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, uint256, bool, uint256):\n    ...\n\n\n@external\ndef confirmMintOrRedeemAsset(\n    _legoId: uint256,\n    _tokenIn: address,\n    _tokenOut: address,\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, uint256):\n    ...\n\n\n###################\n# Debt Management #\n###################\n\n\n# add collateral\n\n\n@external\ndef addCollateral(\n    _legoId: uint256,\n    _asset: address,\n    _amount: uint256 = max_value(uint256),\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, uint256):\n    ...\n\n\n# remove collateral\n\n\n@external\ndef removeCollateral(\n    _legoId: uint256,\n    _asset: address,\n    _amount: uint256 = max_value(uint256),\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, uint256):\n    ...\n\n\n# borrow\n\n\n@external\ndef borrow(\n    _legoId: uint256,\n    _borrowAsset: address,\n    _amount: uint256 = max_value(uint256),\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, uint256):\n    ...\n\n\n# repay debt\n\n\n@external\ndef repayDebt(\n    _legoId: uint256,\n    _paymentAsset: address,\n    _paymentAmount: uint256 = max_value(uint256),\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, uint256):\n    ...\n\n\n#################\n# Claim Rewards #\n#################\n\n\n@external\ndef claimRewards(\n    _legoId: uint256,\n    _rewardToken: address = empty(address),\n    _rewardAmount: uint256 = max_value(uint256),\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, uint256):\n    ...\n\n\n################\n# Wrapped ETH #\n################\n\n\n# eth -> weth\n\n\n@payable\n@external\ndef convertEthToWeth(_amount: uint256 = max_value(uint256)) -> (uint256, uint256):\n    ...\n\n\n# weth -> eth\n\n\n@external\ndef convertWethToEth(_amount: uint256 = max_value(uint256)) -> (uint256, uint256):\n    ...\n\n\n#################\n# Add Liquidity #\n#################\n\n\n# add / remove liquidity (simple)\n\n\n@external\ndef addLiquidity(\n    _legoId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _amountA: uint256 = max_value(uint256),\n    _amountB: uint256 = max_value(uint256),\n    _minAmountA: uint256 = 0,\n    _minAmountB: uint256 = 0,\n    _minLpAmount: uint256 = 0,\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, uint256, uint256, uint256):\n    ...\n\n\n@external\ndef removeLiquidity(\n    _legoId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpToken: address,\n    _lpAmount: uint256 = max_value(uint256),\n    _minAmountA: uint256 = 0,\n    _minAmountB: uint256 = 0,\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, uint256, uint256, uint256):\n    ...\n\n\n# add / remove liquidity (concentrated)\n\n\n@external\ndef addLiquidityConcentrated(\n    _legoId: uint256,\n    _nftAddr: address,\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _amountA: uint256 = max_value(uint256),\n    _amountB: uint256 = max_value(uint256),\n    _tickLower: int24 = min_value(int24),\n    _tickUpper: int24 = max_value(int24),\n    _minAmountA: uint256 = 0,\n    _minAmountB: uint256 = 0,\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, uint256, uint256, uint256, uint256):\n    ...\n\n\n@external\ndef removeLiquidityConcentrated(\n    _legoId: uint256,\n    _nftAddr: address,\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _liqToRemove: uint256 = max_value(uint256),\n    _minAmountA: uint256 = 0,\n    _minAmountB: uint256 = 0,\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, uint256, uint256, uint256):\n    ...\n\n\n#############\n# Utilities #\n#############\n\n\n# recover nft\n\n\n@external\ndef recoverNft(_collection: address, _nftTokenId: uint256, _recipient: address):\n    ...\n",
            "sha256sum": "bc36343f2acf1bcd8ce0ae78be20898917cec4f6fa4a4e9fcfea42baa0f75c21"
          },
          "interfaces/WalletStructs.vyi": {
            "content": "# @version 0.4.3\n\nflag ActionType:\n    TRANSFER\n    EARN_DEPOSIT\n    EARN_WITHDRAW\n    EARN_REBALANCE\n    SWAP\n    MINT_REDEEM\n    CONFIRM_MINT_REDEEM\n    ADD_COLLATERAL\n    REMOVE_COLLATERAL\n    BORROW\n    REPAY_DEBT\n    REWARDS\n    ETH_TO_WETH\n    WETH_TO_ETH\n    ADD_LIQ\n    REMOVE_LIQ\n    ADD_LIQ_CONC\n    REMOVE_LIQ_CONC\n    PAY_CHEQUE\n\nstruct WalletAssetData:\n    assetBalance: uint256\n    usdValue: uint256\n    isYieldAsset: bool\n    lastPricePerShare: uint256\n\nstruct ActionData:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    billing: address\n    wallet: address\n    walletConfig: address\n    walletOwner: address\n    inEjectMode: bool\n    isFrozen: bool\n    lastTotalUsdValue: uint256\n    signer: address\n    isManager: bool\n    legoId: uint256\n    legoAddr: address\n    eth: address\n    weth: address\n\nstruct MiniAddys:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    appraiser: address",
            "sha256sum": "9a4b4f59b3a62043e51b425a665064aae419a3c0bd0514b6b29a9441ae364bb9"
          },
          "interfaces/LegoPartner.vyi": {
            "content": "# @version 0.4.3\n\nfrom interfaces import WalletStructs as ws\n\nMAX_TOKEN_PATH: constant(uint256) = 5\nMAX_RECOVER_ASSETS: constant(uint256) = 20\n\n@external\ndef addLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _tickLower: int24, _tickUpper: int24, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef addLiquidity(_pool: address, _tokenA: address, _tokenB: address, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _minLpAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (address, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef removeLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _liqToRemove: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef removeLiquidity(_pool: address, _tokenA: address, _tokenB: address, _lpToken: address, _lpAmount: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef mintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _tokenInAmount: uint256, _minAmountOut: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef swapTokens(_amountIn: uint256, _minAmountOut: uint256, _tokenPath: DynArray[address, MAX_TOKEN_PATH], _poolPath: DynArray[address, MAX_TOKEN_PATH - 1], _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256):\n    ...\n\n@external\ndef depositForYield(_asset: address, _amount: uint256, _vaultAddr: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef withdrawFromYield(_vaultToken: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef confirmMintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef borrow(_borrowAsset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef repayDebt(_paymentAsset: address, _paymentAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef claimRewards(_user: address, _rewardToken: address, _rewardAmount: uint256, _extraData: bytes32, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef removeCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef addCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@view\n@external\ndef getAccessForLego(_user: address, _action: ws.ActionType) -> (address, String[64], uint256):\n    ...\n\n@view\n@external\ndef hasCapability(_action: ws.ActionType) -> bool:\n    ...\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    ...\n\n@view\n@external\ndef isYieldLego() -> bool:\n    ...\n\n@view\n@external\ndef isDexLego() -> bool:\n    ...\n\n\n# common\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "81db71fe4440a3b4b563134c9b5caf1d5705772a5f291fe874c9b5fb3cfb1623"
          },
          "contracts/vaults/modules/EarnVaultWallet.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nfrom interfaces import Wallet as wi\nfrom interfaces import LegoPartner as Lego\nfrom interfaces import WalletStructs as ws\n\nfrom ethereum.ercs import IERC20\nfrom ethereum.ercs import IERC20Detailed\n\ninterface VaultRegistry:\n    def getVaultActionDataWithFrozenStatus(_legoId: uint256, _signer: address, _vaultAddr: address) -> (VaultActionData, bool): view\n    def getVaultActionDataBundle(_legoId: uint256, _signer: address) -> VaultActionData: view\n    def checkVaultApprovals(_vaultAddr: address, _vaultToken: address) -> bool: view\n    def getLegoDataFromVaultToken(_vaultToken: address) -> (uint256, address): view\n    def redemptionConfig(_vaultAddr: address) -> (uint256, uint256): view\n    def getPerformanceFee(_vaultAddr: address) -> uint256: view\n\ninterface YieldLego:\n    def getUnderlyingBalances(_vaultToken: address, _vaultTokenBalance: uint256) -> (uint256, uint256): view\n    def getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256: view\n\ninterface Switchboard:\n    def isSwitchboardAddr(_addr: address) -> bool: view\n\ninterface MissionControl:\n    def isLockedSigner(_signer: address) -> bool: view\n\ninterface Registry:\n    def getAddr(_regId: uint256) -> address: view\n\ninterface UndyHq:\n    def governance() -> address: view\n\nstruct VaultActionData:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    appraiser: address\n    vaultRegistry: address\n    vaultAsset: address\n    signer: address\n    legoId: uint256\n    legoAddr: address\n\nevent EarnVaultAction:\n    op: uint8\n    asset1: indexed(address)\n    asset2: indexed(address)\n    amount1: uint256\n    amount2: uint256\n    usdValue: uint256\n    legoId: uint256\n    signer: indexed(address)\n\nevent PerformanceFeesClaimed:\n    pendingFees: uint256\n\n# yield tracking\nlastUnderlyingBal: public(uint256)\npendingYieldRealized: public(uint256)\n\n# asset data\nvaultToLegoId: public(HashMap[address, uint256]) # vault addr -> lego id\nassets: public(HashMap[uint256, address]) # index -> asset\nindexOfAsset: public(HashMap[address, uint256]) # asset -> index\nnumAssets: public(uint256) # num assets\n\n# managers\nmanagers: public(HashMap[uint256, address]) # index -> manager\nindexOfManager: public(HashMap[address, uint256]) # manager -> index\nnumManagers: public(uint256) # num managers\n\n# constants\nHUNDRED_PERCENT: constant(uint256) = 100_00 # 100.00%\nMAX_SWAP_INSTRUCTIONS: constant(uint256) = 5\nMAX_TOKEN_PATH: constant(uint256) = 5\nMAX_LEGOS: constant(uint256) = 10\nMAX_DEREGISTER_ASSETS: constant(uint256) = 25\n\n# registry ids\nLEGO_BOOK_ID: constant(uint256) = 3\nSWITCHBOARD_ID: constant(uint256) = 4\nVAULT_REGISTRY_ID: constant(uint256) = 10\n\nUNDY_HQ: immutable(address)\nVAULT_ASSET: immutable(address)\n\n\n@deploy\ndef __init__(\n    _undyHq: address,\n    _vaultAsset: address,\n    _startingAgent: address,\n):\n    # not using 0 index\n    self.numManagers = 1\n    self.numAssets = 1\n\n    assert empty(address) not in [_undyHq, _vaultAsset] # dev: inv addr\n    UNDY_HQ = _undyHq\n    VAULT_ASSET = _vaultAsset\n\n    # initial agent\n    if _startingAgent != empty(address):\n        self._registerManager(_startingAgent)\n\n\n#########\n# Yield #\n#########\n\n\n# deposit\n\n\n@external\ndef depositForYield(\n    _legoId: uint256,\n    _asset: address,\n    _vaultAddr: address = empty(address),\n    _amount: uint256 = max_value(uint256),\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, address, uint256, uint256):\n    ad: VaultActionData = self._canManagerPerformAction(msg.sender, [_legoId])\n    return self._depositForYield(_asset, _vaultAddr, _amount, _extraData, self._getUnderlyingAndUpdatePendingYield(), True, ad)\n\n\n@internal\ndef _onReceiveVaultFunds(\n    _vaultAddr: address,\n    _depositor: address,\n    _vaultRegistry: address,\n) -> uint256:\n    legoId: uint256 = self.vaultToLegoId[_vaultAddr]\n    ad: VaultActionData = staticcall VaultRegistry(_vaultRegistry).getVaultActionDataBundle(legoId, _depositor)\n    if ad.legoId == 0 or ad.legoAddr == empty(address):\n        return 0\n    ad.vaultAsset = VAULT_ASSET\n    return self._depositForYield(ad.vaultAsset, _vaultAddr, max_value(uint256), empty(bytes32), 0, False, ad)[0]\n\n\n@internal\ndef _depositForYield(\n    _asset: address,\n    _vaultAddr: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _currentUnderlying: uint256,\n    _shouldSaveUnderlying: bool,\n    _ad: VaultActionData,\n) -> (uint256, address, uint256, uint256):\n    amount: uint256 = self._getAmountAndApprove(_asset, _amount, _ad.legoAddr) # doing approval here\n    currentUnderlying: uint256 = _currentUnderlying\n\n    # deposit for yield\n    assetAmount: uint256 = 0\n    vaultToken: address = empty(address)\n    vaultTokenAmountReceived: uint256 = 0\n    txUsdValue: uint256 = 0\n    assetAmount, vaultToken, vaultTokenAmountReceived, txUsdValue = extcall Lego(_ad.legoAddr).depositForYield(_asset, amount, _vaultAddr, _extraData, self, self._packMiniAddys(_ad.ledger, _ad.missionControl, _ad.legoBook, _ad.appraiser))\n    assert extcall IERC20(_asset).approve(_ad.legoAddr, 0, default_return_value = True) # dev: appr\n\n    # update yield position\n    if _asset == VAULT_ASSET:\n        assert _vaultAddr == vaultToken # dev: vault token mismatch\n        assert staticcall VaultRegistry(_ad.vaultRegistry).checkVaultApprovals(self, vaultToken) # dev: lego or vault token not approved\n        self._updateYieldPosition(vaultToken, _ad.legoId)\n        currentUnderlying += assetAmount\n\n    # save underlying balance\n    if _shouldSaveUnderlying:\n        self.lastUnderlyingBal = currentUnderlying\n\n    log EarnVaultAction(\n        op = 10,\n        asset1 = _asset,\n        asset2 = vaultToken,\n        amount1 = assetAmount,\n        amount2 = vaultTokenAmountReceived,\n        usdValue = txUsdValue,\n        legoId = _ad.legoId,\n        signer = _ad.signer,\n    )\n    return assetAmount, vaultToken, vaultTokenAmountReceived, txUsdValue\n\n\n# withdraw\n\n\n@external\ndef withdrawFromYield(\n    _legoId: uint256,\n    _vaultToken: address,\n    _amount: uint256 = max_value(uint256),\n    _extraData: bytes32 = empty(bytes32),\n    _isSpecialTx: bool = False,\n) -> (uint256, address, uint256, uint256):\n    ad: VaultActionData = self._canManagerPerformAction(msg.sender, [_legoId])\n    return self._withdrawFromYield(_vaultToken, _amount, _extraData, self._getUnderlyingAndUpdatePendingYield(), True, ad)\n\n\n@internal\ndef _withdrawFromYield(\n    _vaultToken: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _currentUnderlying: uint256,\n    _shouldSaveUnderlying: bool,\n    _ad: VaultActionData,\n) -> (uint256, address, uint256, uint256):\n    assert _vaultToken != empty(address) # dev: invalid vault token\n    amount: uint256 = self._getAmountAndApprove(_vaultToken, _amount, empty(address)) # not approving here\n    currentUnderlying: uint256 = _currentUnderlying\n\n    # some vault tokens require max value approval (comp v3)\n    assert extcall IERC20(_vaultToken).approve(_ad.legoAddr, max_value(uint256), default_return_value = True) # dev: appr\n\n    # withdraw from yield\n    vaultTokenAmountBurned: uint256 = 0\n    underlyingAsset: address = empty(address)\n    underlyingAmount: uint256 = 0\n    txUsdValue: uint256 = 0\n    vaultTokenAmountBurned, underlyingAsset, underlyingAmount, txUsdValue = extcall Lego(_ad.legoAddr).withdrawFromYield(_vaultToken, amount, _extraData, self, self._packMiniAddys(_ad.ledger, _ad.missionControl, _ad.legoBook, _ad.appraiser))\n    assert extcall IERC20(_vaultToken).approve(_ad.legoAddr, 0, default_return_value = True) # dev: appr\n\n    # update yield position\n    if underlyingAsset == VAULT_ASSET:\n        self._updateYieldPosition(_vaultToken, _ad.legoId)\n        currentUnderlying -= min(currentUnderlying, underlyingAmount)\n\n    if _shouldSaveUnderlying:\n        self.lastUnderlyingBal = currentUnderlying\n\n    log EarnVaultAction(\n        op = 11,\n        asset1 = _vaultToken,\n        asset2 = underlyingAsset,\n        amount1 = vaultTokenAmountBurned,\n        amount2 = underlyingAmount,\n        usdValue = txUsdValue,\n        legoId = _ad.legoId,\n        signer = _ad.signer,\n    )\n    return vaultTokenAmountBurned, underlyingAsset, underlyingAmount, txUsdValue\n\n\n###################\n# Swap / Exchange #\n###################\n\n\n@external\ndef swapTokens(_instructions: DynArray[wi.SwapInstruction, MAX_SWAP_INSTRUCTIONS]) -> (address, uint256, address, uint256, uint256):\n    tokenIn: address = empty(address)\n    tokenOut: address = empty(address)\n    legoIds: DynArray[uint256, MAX_LEGOS] = []\n    tokenIn, tokenOut, legoIds = self._validateAndGetSwapInfo(_instructions)\n\n    # important checks!\n    vaultAsset: address = VAULT_ASSET\n    assert tokenIn != vaultAsset # dev: cannot swap out of vault asset\n    assert self.vaultToLegoId[tokenIn] == 0 # dev: cannot swap out of vault token\n    assert tokenOut == vaultAsset # dev: must swap into vault asset\n\n    # action data bundle\n    ad: VaultActionData = self._canManagerPerformAction(msg.sender, legoIds)\n    origAmountIn: uint256 = self._getAmountAndApprove(tokenIn, _instructions[0].amountIn, empty(address)) # not approving here\n\n    amountIn: uint256 = origAmountIn\n    lastTokenOut: address = empty(address)\n    lastTokenOutAmount: uint256 = 0\n    maxTxUsdValue: uint256 = 0\n\n    # perform swaps\n    for i: wi.SwapInstruction in _instructions:\n        if lastTokenOut != empty(address):\n            newTokenIn: address = i.tokenPath[0]\n            assert lastTokenOut == newTokenIn # dev: path\n            amountIn = min(lastTokenOutAmount, staticcall IERC20(newTokenIn).balanceOf(self))\n        \n        thisTxUsdValue: uint256 = 0\n        lastTokenOut, lastTokenOutAmount, thisTxUsdValue = self._performSwapInstruction(amountIn, i, ad)\n        maxTxUsdValue = max(maxTxUsdValue, thisTxUsdValue)\n\n    log EarnVaultAction(\n        op = 20,\n        asset1 = tokenIn,\n        asset2 = lastTokenOut,\n        amount1 = origAmountIn,\n        amount2 = lastTokenOutAmount,\n        usdValue = maxTxUsdValue,\n        legoId = ad.legoId, # using just the first lego used\n        signer = ad.signer,\n    )\n    return tokenIn, origAmountIn, lastTokenOut, lastTokenOutAmount, maxTxUsdValue\n\n\n@internal\ndef _performSwapInstruction(\n    _amountIn: uint256,\n    _i: wi.SwapInstruction,\n    _ad: VaultActionData,\n) -> (address, uint256, uint256):\n    legoAddr: address = staticcall Registry(_ad.legoBook).getAddr(_i.legoId)\n    assert legoAddr != empty(address) # dev: lego\n\n    # tokens\n    tokenIn: address = _i.tokenPath[0]\n    tokenOut: address = _i.tokenPath[len(_i.tokenPath) - 1]\n    tokenInAmount: uint256 = 0\n    tokenOutAmount: uint256 = 0\n    txUsdValue: uint256 = 0\n\n    assert extcall IERC20(tokenIn).approve(legoAddr, _amountIn, default_return_value = True) # dev: appr\n    tokenInAmount, tokenOutAmount, txUsdValue = extcall Lego(legoAddr).swapTokens(_amountIn, _i.minAmountOut, _i.tokenPath, _i.poolPath, self, self._packMiniAddys(_ad.ledger, _ad.missionControl, _ad.legoBook, _ad.appraiser))\n    assert extcall IERC20(tokenIn).approve(legoAddr, 0, default_return_value = True) # dev: appr\n    return tokenOut, tokenOutAmount, txUsdValue\n\n\n@internal\ndef _validateAndGetSwapInfo(_instructions: DynArray[wi.SwapInstruction, MAX_SWAP_INSTRUCTIONS]) -> (address, address, DynArray[uint256, MAX_LEGOS]):\n    numSwapInstructions: uint256 = len(_instructions)\n    assert numSwapInstructions != 0 # dev: swaps\n\n    # lego ids, make sure token paths are valid\n    legoIds: DynArray[uint256, MAX_LEGOS] = []\n    for i: wi.SwapInstruction in _instructions:\n        assert len(i.tokenPath) >= 2 # dev: path\n        if i.legoId not in legoIds:\n            legoIds.append(i.legoId)\n\n    # finalize tokens\n    firstRoutePath: DynArray[address, MAX_TOKEN_PATH] = _instructions[0].tokenPath\n    tokenIn: address = firstRoutePath[0]\n    tokenOut: address = empty(address)\n\n    if numSwapInstructions == 1:\n        tokenOut = firstRoutePath[len(firstRoutePath) - 1]\n    else:\n        lastRoutePath: DynArray[address, MAX_TOKEN_PATH] = _instructions[numSwapInstructions - 1].tokenPath\n        tokenOut = lastRoutePath[len(lastRoutePath) - 1]\n\n    assert empty(address) not in [tokenIn, tokenOut] # dev: path\n    return tokenIn, tokenOut, legoIds\n\n\n#################\n# Claim Rewards #\n#################\n\n\n@external\ndef claimRewards(\n    _legoId: uint256,\n    _rewardToken: address = empty(address),\n    _rewardAmount: uint256 = max_value(uint256),\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, uint256):\n    ad: VaultActionData = self._canManagerPerformAction(msg.sender, [_legoId])\n\n    # make sure can access\n    self._setLegoAccessForAction(ad.legoAddr, ws.ActionType.REWARDS)\n\n    # claim rewards\n    rewardAmount: uint256 = 0\n    txUsdValue: uint256 = 0\n    rewardAmount, txUsdValue = extcall Lego(ad.legoAddr).claimRewards(self, _rewardToken, _rewardAmount, _extraData, self._packMiniAddys(ad.ledger, ad.missionControl, ad.legoBook, ad.appraiser))\n\n    log EarnVaultAction(\n        op = 50,\n        asset1 = _rewardToken,\n        asset2 = ad.legoAddr,\n        amount1 = rewardAmount,\n        amount2 = 0,\n        usdValue = txUsdValue,\n        legoId = ad.legoId,\n        signer = ad.signer,\n    )\n    return rewardAmount, txUsdValue\n\n\n#############################\n# Overall Yield Calculation #\n#############################\n\n\n# calculate yield realized\n\n\n@view\n@internal\ndef _calcNewYieldAndGetUnderlying(_currentUnderlying: uint256 = 0) -> (uint256, uint256):\n    currentUnderlying: uint256 = _currentUnderlying\n    if currentUnderlying == 0:\n        currentUnderlying = self._getUnderlyingYieldBalances()[0]\n\n    newYield: uint256 = 0\n    lastUnderlyingBal: uint256 = self.lastUnderlyingBal\n    if lastUnderlyingBal != 0 and currentUnderlying > lastUnderlyingBal:\n        newYield = currentUnderlying - lastUnderlyingBal\n\n    return currentUnderlying, newYield\n\n\n# update pending yield realized\n\n\n@internal\ndef _getUnderlyingAndUpdatePendingYield() -> uint256:\n    currentUnderlying: uint256 = 0\n    newYield: uint256 = 0\n    currentUnderlying, newYield = self._calcNewYieldAndGetUnderlying()\n    self.pendingYieldRealized += newYield\n    return currentUnderlying\n\n\n# claim performance fees\n\n\n@external\ndef claimPerformanceFees() -> uint256:\n    governance: address = staticcall UndyHq(UNDY_HQ).governance()\n    assert self._isSwitchboardAddr(msg.sender) or governance == msg.sender # dev: no perms\n\n    vaultRegistry: address = self._getVaultRegistry()\n    currentUnderlying: uint256 = self._getUnderlyingAndUpdatePendingYield()\n    pendingFees: uint256 = self.pendingYieldRealized * self._getPerformanceFeeRatio(vaultRegistry) // HUNDRED_PERCENT\n\n    # make withdrawals from yield positions\n    availAmount: uint256 = 0\n    withdrawnAmount: uint256 = 0\n    availAmount, withdrawnAmount = self._prepareRedemption(VAULT_ASSET, pendingFees, empty(address), governance, vaultRegistry)\n    assert availAmount >= pendingFees # dev: insufficient funds\n\n    # transfer pending fees to governance\n    assert extcall IERC20(VAULT_ASSET).transfer(governance, pendingFees, default_return_value=True) # dev: withdrawal failed\n\n    # update data\n    self.pendingYieldRealized = 0\n    self.lastUnderlyingBal = currentUnderlying - min(currentUnderlying, withdrawnAmount)\n\n    log PerformanceFeesClaimed(pendingFees=pendingFees)\n    return pendingFees\n\n\n# claimable performance fees\n\n\n@view\n@external\ndef getClaimablePerformanceFees() -> uint256:\n    newYield: uint256 = self._calcNewYieldAndGetUnderlying()[1]\n    return (self.pendingYieldRealized + newYield) * self._getPerformanceFeeRatio(self._getVaultRegistry()) // HUNDRED_PERCENT\n\n\n# get performance fee %\n\n\n@view\n@internal\ndef _getPerformanceFeeRatio(_vaultRegistry: address) -> uint256:\n    return staticcall VaultRegistry(_vaultRegistry).getPerformanceFee(self)\n\n\n#####################\n# Underlying Assets #\n#####################\n\n\n@view\n@internal\ndef _getUnderlyingYieldBalances() -> (uint256, uint256, address):\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return 0, 0, empty(address)\n\n    maxTotalAssets: uint256 = 0\n    safeTotalAssets: uint256 = 0\n\n    maxBalance: uint256 = 0\n    maxBalVaultToken: address = empty(address)\n\n    # iterate over each asset\n    legoBook: address = staticcall Registry(UNDY_HQ).getAddr(LEGO_BOOK_ID)\n    for i: uint256 in range(1, numAssets, bound=max_value(uint256)):\n\n        # get asset addr\n        vaultToken: address = self.assets[i]\n        if vaultToken == empty(address):\n            continue\n\n        vaultTokenBalance: uint256 = staticcall IERC20(vaultToken).balanceOf(self)\n        if vaultTokenBalance == 0:\n            continue\n\n        legoId: uint256 = self.vaultToLegoId[vaultToken]\n        if legoId == 0:\n            continue\n\n        legoAddr: address = staticcall Registry(legoBook).getAddr(legoId)\n        if legoAddr == empty(address):\n            continue\n\n        # get balance data\n        trueUnderlying: uint256 = 0\n        safeUnderlying: uint256 = 0\n        trueUnderlying, safeUnderlying = staticcall YieldLego(legoAddr).getUnderlyingBalances(vaultToken, vaultTokenBalance)\n\n        # add totals\n        maxTotalAssets += trueUnderlying\n        safeTotalAssets += safeUnderlying\n\n        # save max balance / token\n        if trueUnderlying > maxBalance:\n            maxBalance = trueUnderlying\n            maxBalVaultToken = vaultToken\n\n    return maxTotalAssets, safeTotalAssets, maxBalVaultToken\n\n\n###################\n# Redemption Prep #\n###################\n\n\n@internal\ndef _prepareRedemption(\n    _asset: address,\n    _amount: uint256,\n    _maxBalVaultToken: address,\n    _sender: address,\n    _vaultRegistry: address,\n) -> (uint256, uint256):\n    availAmount: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    if availAmount >= _amount:\n        return availAmount, 0\n\n    # get redemption config (buffer and min withdraw amount)\n    redemptionBuffer: uint256 = 0\n    minWithdrawAmount: uint256 = 0\n    redemptionBuffer, minWithdrawAmount = staticcall VaultRegistry(_vaultRegistry).redemptionConfig(self)\n\n    # buffer to make sure we pull out enough for redemption\n    bufferMultiplier: uint256 = HUNDRED_PERCENT + redemptionBuffer\n    targetWithdrawAmount: uint256 = _amount * bufferMultiplier // HUNDRED_PERCENT\n\n    withdrawnAmount: uint256 = 0\n    ad: VaultActionData = staticcall VaultRegistry(_vaultRegistry).getVaultActionDataBundle(0, _sender)\n    ad.vaultAsset = _asset\n    assetsToDeregister: DynArray[address, MAX_DEREGISTER_ASSETS] = []\n\n    # first withdraw from biggest yield position\n    if _maxBalVaultToken != empty(address):\n        underlyingAmount: uint256 = 0\n        needsDeregister: bool = False\n        underlyingAmount, needsDeregister = self._withdrawDuringRedemption(_maxBalVaultToken, targetWithdrawAmount, availAmount, minWithdrawAmount, 0, ad)\n        availAmount += underlyingAmount\n        withdrawnAmount += underlyingAmount\n        if needsDeregister:\n            assetsToDeregister.append(_maxBalVaultToken)\n\n    # next, iterate thru each yield position (order it is saved)\n    if availAmount < targetWithdrawAmount:\n        numAssets: uint256 = self.numAssets\n        if numAssets != 0:\n            for i: uint256 in range(1, numAssets, bound=max_value(uint256)):\n                if availAmount >= targetWithdrawAmount:\n                    break\n\n                vaultToken: address = self.assets[i]\n                if _maxBalVaultToken != empty(address) and vaultToken == _maxBalVaultToken:\n                    continue\n\n                # withdraw from yield opportunity\n                underlyingAmount: uint256 = 0\n                needsDeregister: bool = False\n                underlyingAmount, needsDeregister = self._withdrawDuringRedemption(vaultToken, targetWithdrawAmount, availAmount, minWithdrawAmount, len(assetsToDeregister), ad)\n                availAmount += underlyingAmount\n                withdrawnAmount += underlyingAmount\n\n                # add to deregister list\n                if needsDeregister and vaultToken not in assetsToDeregister:\n                    assetsToDeregister.append(vaultToken)\n\n    # deregister vault positions\n    for asset: address in assetsToDeregister:\n        self._deregisterYieldPosition(asset)\n\n    return availAmount, withdrawnAmount\n\n\n@internal\ndef _withdrawDuringRedemption(\n    _vaultToken: address,\n    _targetWithdrawAmount: uint256,\n    _availAmount: uint256,\n    _minWithdrawAmount: uint256,\n    _numDeregisterAssets: uint256,\n    _ad: VaultActionData,\n) -> (uint256, bool):\n    if _vaultToken == empty(address):\n        return 0, False\n\n    vaultTokenBalance: uint256 = staticcall IERC20(_vaultToken).balanceOf(self)\n    if vaultTokenBalance == 0:\n        return 0, _numDeregisterAssets < MAX_DEREGISTER_ASSETS # need to deregister\n\n    legoId: uint256 = self.vaultToLegoId[_vaultToken]\n    if legoId == 0:\n        return 0, False\n\n    ad: VaultActionData = _ad\n    ad.legoId = legoId\n    ad.legoAddr = staticcall Registry(ad.legoBook).getAddr(legoId)\n\n    # skip if amount still needed is below minimum (dust protection)\n    amountStillNeeded: uint256 = _targetWithdrawAmount - _availAmount\n    if _minWithdrawAmount != 0 and amountStillNeeded < _minWithdrawAmount:\n        return 0, False\n\n    # skip if vault tokens needed rounds to 0 (dust)\n    vaultTokensNeeded: uint256 = staticcall YieldLego(ad.legoAddr).getVaultTokenAmount(_ad.vaultAsset, amountStillNeeded, _vaultToken)\n    if vaultTokensNeeded == 0:\n        return 0, False\n\n    # withdraw from yield opportunity\n    underlyingAmount: uint256 = self._withdrawFromYield(_vaultToken, vaultTokensNeeded, empty(bytes32), 0, False, ad)[2]\n\n    # add to deregister list\n    needsDeregister: bool = False\n    if vaultTokensNeeded >= vaultTokenBalance and staticcall IERC20(_vaultToken).balanceOf(self) == 0 and _numDeregisterAssets < MAX_DEREGISTER_ASSETS:\n        needsDeregister = True\n\n    return underlyingAmount, needsDeregister\n\n\n###################\n# Yield Positions #\n###################\n\n\n# update yield position\n\n\n@external\ndef updateYieldPosition(_vaultToken: address):\n    assert self._isSwitchboardAddr(msg.sender) # dev: no perms\n    vaultRegistry: address = self._getVaultRegistry()\n    legoId: uint256 = 0\n    na: address = empty(address)\n    legoId, na = staticcall VaultRegistry(vaultRegistry).getLegoDataFromVaultToken(_vaultToken)\n    if legoId != 0:\n        self._updateYieldPosition(_vaultToken, legoId)\n\n\n@internal\ndef _updateYieldPosition(_vaultToken: address, _legoId: uint256):\n    if _vaultToken == empty(address):\n        return\n\n    # no balance, deregister asset\n    currentBalance: uint256 = staticcall IERC20(_vaultToken).balanceOf(self)\n    if currentBalance == 0:\n        self._deregisterYieldPosition(_vaultToken)\n        return\n\n    # first time, need to save lego mapping\n    legoId: uint256 = self.vaultToLegoId[_vaultToken]\n    if legoId == 0 and _legoId != 0:\n        self.vaultToLegoId[_vaultToken] = _legoId\n\n    # register asset (if necessary)\n    if self.indexOfAsset[_vaultToken] == 0:\n        self._registerYieldPosition(_vaultToken)\n\n\n# register yield position\n\n\n@internal\ndef _registerYieldPosition(_vaultToken: address):\n    aid: uint256 = self.numAssets\n    self.assets[aid] = _vaultToken\n    self.indexOfAsset[_vaultToken] = aid\n    self.numAssets = aid + 1\n\n\n# deregister yield position\n\n\n@internal\ndef _deregisterYieldPosition(_vaultToken: address) -> bool:\n    numAssets: uint256 = self.numAssets\n    if numAssets == 1:\n        return False\n\n    targetIndex: uint256 = self.indexOfAsset[_vaultToken]\n    if targetIndex == 0:\n        return False\n\n    # update data\n    lastIndex: uint256 = numAssets - 1\n    self.numAssets = lastIndex\n    self.indexOfAsset[_vaultToken] = 0\n\n    # get last item, replace the removed item\n    if targetIndex != lastIndex:\n        lastItem: address = self.assets[lastIndex]\n        self.assets[targetIndex] = lastItem\n        self.indexOfAsset[lastItem] = targetIndex\n\n    return True\n\n\n####################\n# Manager Settings #\n####################\n\n\n# can manage\n\n\n@internal\ndef _canManagerPerformAction(_signer: address, _legoIds: DynArray[uint256, MAX_LEGOS]) -> VaultActionData:\n    assert self.indexOfManager[_signer] != 0 # dev: not manager\n\n    # main data for this transaction - get action data and frozen status in single call\n    legoId: uint256 = 0\n    if len(_legoIds) != 0:\n        legoId = _legoIds[0]\n\n    vaultRegistry: address = self._getVaultRegistry()\n    ad: VaultActionData = empty(VaultActionData)\n    isVaultOpsFrozen: bool = False\n    ad, isVaultOpsFrozen = staticcall VaultRegistry(vaultRegistry).getVaultActionDataWithFrozenStatus(legoId, _signer, self)\n    ad.vaultAsset = VAULT_ASSET\n\n    # cannot perform any actions if vault is frozen\n    assert not isVaultOpsFrozen # dev: frozen vault\n\n    # make sure manager is not locked\n    assert not staticcall MissionControl(ad.missionControl).isLockedSigner(_signer) # dev: manager is locked\n\n    return ad\n\n\n# add manager\n\n\n@external\ndef addManager(_manager: address):\n    assert self._isSwitchboardAddr(msg.sender) # dev: no perms\n    self._registerManager(_manager)\n\n\n# register manager\n\n\n@internal\ndef _registerManager(_manager: address):\n    if self.indexOfManager[_manager] != 0:\n        return\n    mid: uint256 = self.numManagers\n    self.managers[mid] = _manager\n    self.indexOfManager[_manager] = mid\n    self.numManagers = mid + 1\n\n\n# remove manager\n\n\n@external\ndef removeManager(_manager: address):\n    assert self._isSwitchboardAddr(msg.sender) # dev: no perms\n\n    numManagers: uint256 = self.numManagers\n    if numManagers == 1:\n        return\n\n    targetIndex: uint256 = self.indexOfManager[_manager]\n    if targetIndex == 0:\n        return\n\n    # update data\n    lastIndex: uint256 = numManagers - 1\n    self.numManagers = lastIndex\n    self.indexOfManager[_manager] = 0\n\n    # get last item, replace the removed item\n    if targetIndex != lastIndex:\n        lastItem: address = self.managers[lastIndex]\n        self.managers[targetIndex] = lastItem\n        self.indexOfManager[lastItem] = targetIndex\n\n\n#############\n# Utilities #\n#############\n\n\n# get vault registry\n\n\n@view\n@internal\ndef _getVaultRegistry() -> address:\n    return staticcall Registry(UNDY_HQ).getAddr(VAULT_REGISTRY_ID)\n\n\n# is signer switchboard\n\n\n@view\n@internal\ndef _isSwitchboardAddr(_signer: address) -> bool:\n    switchboard: address = staticcall Registry(UNDY_HQ).getAddr(SWITCHBOARD_ID)\n    if switchboard == empty(address):\n        return False\n    return staticcall Switchboard(switchboard).isSwitchboardAddr(_signer)\n\n\n# approve\n\n\n@internal\ndef _getAmountAndApprove(_token: address, _amount: uint256, _legoAddr: address) -> uint256:\n    amount: uint256 = min(_amount, staticcall IERC20(_token).balanceOf(self))\n    assert amount != 0 # dev: no balance for _token\n    if _legoAddr != empty(address):\n        assert extcall IERC20(_token).approve(_legoAddr, amount, default_return_value = True) # dev: appr\n    return amount\n\n\n# lego access\n\n\n@internal\ndef _setLegoAccessForAction(_legoAddr: address, _action: ws.ActionType) -> bool:\n    if _legoAddr == empty(address):\n        return False\n\n    targetAddr: address = empty(address)\n    accessAbi: String[64] = empty(String[64])\n    numInputs: uint256 = 0\n    targetAddr, accessAbi, numInputs = staticcall Lego(_legoAddr).getAccessForLego(self, _action)\n\n    # nothing to do here\n    if targetAddr == empty(address):\n        return False\n\n    method_abi: bytes4 = convert(slice(keccak256(accessAbi), 0, 4), bytes4)\n    success: bool = False\n    response: Bytes[32] = b\"\"\n\n    # assumes input is: lego addr (operator)\n    if numInputs == 1:\n        success, response = raw_call(\n            targetAddr,\n            concat(\n                method_abi,\n                convert(_legoAddr, bytes32),\n            ),\n            revert_on_failure = False,\n            max_outsize = 32,\n        )\n    \n    # assumes input (and order) is: user (self), lego addr (operator)\n    elif numInputs == 2:\n        success, response = raw_call(\n            targetAddr,\n            concat(\n                method_abi,\n                convert(self, bytes32),\n                convert(_legoAddr, bytes32),\n            ),\n            revert_on_failure = False,\n            max_outsize = 32,\n        )\n\n    # assumes input (and order) is: user (self), lego addr (operator), allowed bool\n    elif numInputs == 3:\n        success, response = raw_call(\n            targetAddr,\n            concat(\n                method_abi,\n                convert(self, bytes32),\n                convert(_legoAddr, bytes32),\n                convert(True, bytes32),\n            ),\n            revert_on_failure = False,\n            max_outsize = 32,\n        )\n\n    assert success # dev: failed to set operator\n    return True\n\n\n# mini addys\n\n\n@view\n@internal\ndef _packMiniAddys(\n    _ledger: address,\n    _missionControl: address,\n    _legoBook: address,\n    _appraiser: address,\n) -> ws.MiniAddys:\n    return ws.MiniAddys(\n        ledger = _ledger,\n        missionControl = _missionControl,\n        legoBook = _legoBook,\n        appraiser = _appraiser,\n    )\n\n",
            "sha256sum": "61caf19a6d25ffd6794d5c80690611d91e9217c514154dd9cf284df5f0f8e24d"
          },
          "contracts/vaults/EarnVault.vy": {
            "content": "#    ________   __  __   _________  ______   ______   ________  __       ______   _________  \n#   /_______/\\ /_/\\/_/\\ /________/\\/_____/\\ /_____/\\ /_______/\\/_/\\     /_____/\\ /________/\\ \n#   \\::: _  \\ \\\\:\\ \\:\\ \\\\__.::.__\\/\\:::_ \\ \\\\:::_ \\ \\\\__.::._\\/\\:\\ \\    \\:::_ \\ \\\\__.::.__\\/ \n#    \\::(_)  \\ \\\\:\\ \\:\\ \\  \\::\\ \\   \\:\\ \\ \\ \\\\:(_) \\ \\  \\::\\ \\  \\:\\ \\    \\:\\ \\ \\ \\  \\::\\ \\   \n#     \\:: __  \\ \\\\:\\ \\:\\ \\  \\::\\ \\   \\:\\ \\ \\ \\\\: ___\\/  _\\::\\ \\__\\:\\ \\____\\:\\ \\ \\ \\  \\::\\ \\  \n#      \\:.\\ \\  \\ \\\\:\\_\\:\\ \\  \\::\\ \\   \\:\\_\\ \\ \\\\ \\ \\   /__\\::\\__/\\\\:\\/___/\\\\:\\_\\ \\ \\  \\::\\ \\ \n#       \\__\\/\\__\\/ \\_____\\/   \\__\\/    \\_____\\/ \\_\\/   \\________\\/ \\_____\\/ \\_____\\/   \\__\\/ \n#                                                                       \n#     \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n#     \u2551  ** Earn Autopilot Vaults **                                         \u2551\n#     \u2551  Managed by AI agents, enforced by onchain rules. Erc4626 compliant. \u2551\n#     \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n#\n#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nimplements: IERC4626\nimplements: IERC20\n\nexports: token.__interface__\ninitializes: token\nfrom contracts.vaults.modules import VaultErc20Token as token\n\nexports: vaultWallet.__interface__\ninitializes: vaultWallet\nfrom contracts.vaults.modules import EarnVaultWallet as vaultWallet\n\nfrom ethereum.ercs import IERC4626\nfrom ethereum.ercs import IERC20\nfrom ethereum.ercs import IERC20Detailed\n\ninterface VaultRegistry:\n    def getDepositConfig(_vaultAddr: address) -> (bool, uint256, bool, address): view\n    def canWithdraw(_vaultAddr: address) -> bool: view\n\nevent Deposit:\n    sender: indexed(address)\n    owner: indexed(address)\n    assets: uint256\n    shares: uint256\n\nevent Withdraw:\n    sender: indexed(address)\n    receiver: indexed(address)\n    owner: indexed(address)\n    assets: uint256\n    shares: uint256\n\nHUNDRED_PERCENT: constant(uint256) = 100_00 # 100.00%\n\n\n@deploy\ndef __init__(\n    _asset: address,\n    _tokenName: String[64],\n    _tokenSymbol: String[32],\n    _undyHq: address,\n    _minHqTimeLock: uint256,\n    _maxHqTimeLock: uint256,\n    _startingAgent: address,\n):\n    token.__init__(_tokenName, _tokenSymbol, staticcall IERC20Detailed(_asset).decimals(), _undyHq)\n    vaultWallet.__init__(_undyHq, _asset, _startingAgent)\n\n\n@view\n@external\ndef asset() -> address:\n    return vaultWallet.VAULT_ASSET\n\n\n@view\n@external\ndef totalAssets() -> uint256:\n    return self._getTotalAssets(True)\n\n\n################\n# Total Assets #\n################\n\n\n@view\n@external\ndef getTotalAssets(_shouldGetMax: bool) -> uint256:\n    return self._getTotalAssets(_shouldGetMax)\n\n\n@view\n@internal\ndef _getTotalAssets(_shouldGetMax: bool, _vaultRegistry: address = empty(address)) -> uint256:\n    vaultRegistry: address = _vaultRegistry\n    if vaultRegistry == empty(address):\n        vaultRegistry = vaultWallet._getVaultRegistry()\n    return self._getUnderlyingData(_shouldGetMax, vaultRegistry)[0]\n\n\n@view\n@internal\ndef _getUnderlyingData(_shouldGetMax: bool, _vaultRegistry: address) -> (uint256, uint256, uint256, address):\n    totalAssets: uint256 = staticcall IERC20(vaultWallet.VAULT_ASSET).balanceOf(self)\n\n    # all underlying assets\n    maxTotalAssets: uint256 = 0\n    safeTotalAssets: uint256 = 0\n    maxBalVaultToken: address = empty(address)\n    maxTotalAssets, safeTotalAssets, maxBalVaultToken = vaultWallet._getUnderlyingYieldBalances()\n\n    # new yield\n    currentBalance: uint256 = 0\n    newYield: uint256 = 0\n    currentBalance, newYield = vaultWallet._calcNewYieldAndGetUnderlying(maxTotalAssets)\n\n    # pending fees\n    pendingYieldRealized: uint256 = vaultWallet.pendingYieldRealized + newYield\n    pendingFees: uint256 = pendingYieldRealized * vaultWallet._getPerformanceFeeRatio(_vaultRegistry) // HUNDRED_PERCENT\n\n    # add total assets\n    if _shouldGetMax:\n        totalAssets += maxTotalAssets\n    else:\n        totalAssets += safeTotalAssets\n    totalAssets -= min(pendingFees, totalAssets)\n\n    return totalAssets, currentBalance, pendingYieldRealized, maxBalVaultToken\n\n\n############\n# Deposits #\n############\n\n\n@view\n@external\ndef maxDeposit(_receiver: address) -> uint256:\n    vaultRegistry: address = vaultWallet._getVaultRegistry()\n\n    # deposit config\n    canDeposit: bool = False\n    maxDepositAmount: uint256 = 0\n    na1: bool = False\n    na2: address = empty(address)\n    canDeposit, maxDepositAmount, na1, na2 = staticcall VaultRegistry(vaultRegistry).getDepositConfig(self)\n\n    if not canDeposit:\n        return 0\n\n    if maxDepositAmount == 0:\n        return max_value(uint256)\n\n    totalAssets: uint256 = self._getTotalAssets(True, vaultRegistry)\n    if totalAssets >= maxDepositAmount:\n        return 0\n\n    return maxDepositAmount - totalAssets\n\n\n@view\n@external\ndef previewDeposit(_assets: uint256) -> uint256:\n    return self._amountToShares(_assets, token.totalSupply, self._getTotalAssets(True), False)\n\n\n@nonreentrant\n@external\ndef deposit(_assets: uint256, _receiver: address = msg.sender) -> uint256:\n    return self._deposit(_assets, _receiver, 0)\n\n\n@nonreentrant\n@external\ndef depositWithMinAmountOut(_assets: uint256, _minAmountOut: uint256, _receiver: address = msg.sender) -> uint256:\n    return self._deposit(_assets, _receiver, _minAmountOut)\n\n\n@internal\ndef _deposit(_assets: uint256, _receiver: address, _minAmountOut: uint256) -> uint256:\n    vaultRegistry: address = vaultWallet._getVaultRegistry()\n    asset: address = vaultWallet.VAULT_ASSET\n\n    amount: uint256 = _assets\n    if amount == max_value(uint256):\n        amount = staticcall IERC20(asset).balanceOf(msg.sender)\n\n    # underlying data\n    totalAssets: uint256 = 0\n    currentBalance: uint256 = 0\n    pendingYieldRealized: uint256 = 0\n    maxBalVaultToken: address = empty(address)\n    totalAssets, currentBalance, pendingYieldRealized, maxBalVaultToken = self._getUnderlyingData(True, vaultRegistry)\n\n    shares: uint256 = self._amountToShares(amount, token.totalSupply, totalAssets, False)\n    if _minAmountOut != 0:\n        assert shares >= _minAmountOut # dev: insufficient shares\n\n    self._depositIntoVault(asset, amount, shares, _receiver, totalAssets, currentBalance, pendingYieldRealized, maxBalVaultToken, vaultRegistry)\n    return shares\n\n\n# mint\n\n\n@view\n@external\ndef maxMint(_receiver: address) -> uint256:\n    vaultRegistry: address = vaultWallet._getVaultRegistry()\n\n    # deposit config\n    canDeposit: bool = False\n    maxDepositAmount: uint256 = 0\n    na1: bool = False\n    na2: address = empty(address)\n    canDeposit, maxDepositAmount, na1, na2 = staticcall VaultRegistry(vaultRegistry).getDepositConfig(self)\n\n    if not canDeposit:\n        return 0\n\n    if maxDepositAmount == 0:\n        return max_value(uint256)\n\n    totalAssets: uint256 = self._getTotalAssets(True, vaultRegistry)\n    if totalAssets >= maxDepositAmount:\n        return 0\n\n    maxDepositAmt: uint256 = maxDepositAmount - totalAssets\n    return self._amountToShares(maxDepositAmt, token.totalSupply, totalAssets, False)\n\n\n@view\n@external\ndef previewMint(_shares: uint256) -> uint256:\n    return self._sharesToAmount(_shares, token.totalSupply, self._getTotalAssets(True), True)\n\n\n@nonreentrant\n@external\ndef mint(_shares: uint256, _receiver: address = msg.sender) -> uint256:\n    vaultRegistry: address = vaultWallet._getVaultRegistry()\n\n    # underlying data\n    totalAssets: uint256 = 0\n    currentBalance: uint256 = 0\n    pendingYieldRealized: uint256 = 0\n    maxBalVaultToken: address = empty(address)\n    totalAssets, currentBalance, pendingYieldRealized, maxBalVaultToken = self._getUnderlyingData(True, vaultRegistry)\n\n    amount: uint256 = self._sharesToAmount(_shares, token.totalSupply, totalAssets, True)\n    self._depositIntoVault(vaultWallet.VAULT_ASSET, amount, _shares, _receiver, totalAssets, currentBalance, pendingYieldRealized, maxBalVaultToken, vaultRegistry)\n    return amount\n\n\n# shared deposit logic\n\n\n@internal\ndef _depositIntoVault(\n    _asset: address,\n    _amount: uint256,\n    _shares: uint256,\n    _recipient: address,\n    _totalAssets: uint256,\n    _currentBalance: uint256,\n    _pendingYieldRealized: uint256,\n    _maxBalVaultToken: address,\n    _vaultRegistry: address,\n):\n    # get all deposit config\n    canDeposit: bool = False\n    maxDepositAmount: uint256 = 0\n    shouldAutoDeposit: bool = False\n    defaultTargetVaultToken: address = empty(address)\n    canDeposit, maxDepositAmount, shouldAutoDeposit, defaultTargetVaultToken = staticcall VaultRegistry(_vaultRegistry).getDepositConfig(self)\n\n    assert canDeposit # dev: cannot deposit\n    assert _amount != 0 # dev: cannot deposit 0 amount\n    assert _shares != 0 # dev: cannot receive 0 shares\n    assert _recipient != empty(address) # dev: invalid recipient\n    if maxDepositAmount != 0:\n        assert _totalAssets + _amount <= maxDepositAmount # dev: exceeds max deposit\n\n    # transfer assets to vault\n    assert extcall IERC20(_asset).transferFrom(msg.sender, self, _amount, default_return_value=True) # dev: deposit failed\n\n    # put the deposit to work -- start earning\n    amountDeposited: uint256 = 0\n    if shouldAutoDeposit:\n        targetVaultToken: address = defaultTargetVaultToken\n        if targetVaultToken == empty(address):\n            targetVaultToken = _maxBalVaultToken\n        amountDeposited = vaultWallet._onReceiveVaultFunds(targetVaultToken, _recipient, _vaultRegistry)\n\n    # save data\n    currentBalance: uint256 = _currentBalance + amountDeposited\n    vaultWallet.lastUnderlyingBal = currentBalance\n    vaultWallet.pendingYieldRealized = _pendingYieldRealized\n\n    token._mint(_recipient, _shares)\n    log Deposit(sender=msg.sender, owner=_recipient, assets=_amount, shares=_shares)\n\n\n###############\n# Withdrawals #\n###############\n\n\n@view\n@external\ndef maxWithdraw(_owner: address) -> uint256:\n    ownerShares: uint256 = token.balanceOf[_owner]\n    if ownerShares == 0:\n        return 0\n    availableAssets: uint256 = self._getTotalAssets(False)\n    ownerAssets: uint256 = self._sharesToAmount(ownerShares, token.totalSupply, availableAssets, False)\n    return min(ownerAssets, availableAssets)\n\n\n@view\n@external\ndef previewWithdraw(_assets: uint256) -> uint256:\n    return self._amountToShares(_assets, token.totalSupply, self._getTotalAssets(False), True)\n\n\n@nonreentrant\n@external\ndef withdraw(_assets: uint256, _receiver: address = msg.sender, _owner: address = msg.sender) -> uint256:\n    vaultRegistry: address = vaultWallet._getVaultRegistry()\n\n    # underlying data\n    totalAssets: uint256 = 0\n    currentBalance: uint256 = 0\n    pendingYieldRealized: uint256 = 0\n    maxBalVaultToken: address = empty(address)\n    totalAssets, currentBalance, pendingYieldRealized, maxBalVaultToken = self._getUnderlyingData(False, vaultRegistry)\n\n    shares: uint256 = self._amountToShares(_assets, token.totalSupply, totalAssets, True)\n    self._redeemFromVault(vaultWallet.VAULT_ASSET, _assets, 0, shares, msg.sender, _receiver, _owner, currentBalance, pendingYieldRealized, maxBalVaultToken, vaultRegistry)\n    return shares\n\n\n# redeem\n\n\n@view\n@external\ndef maxRedeem(_owner: address) -> uint256:\n    return token.balanceOf[_owner]\n\n\n@view\n@external\ndef previewRedeem(_shares: uint256) -> uint256:\n    return self._sharesToAmount(_shares, token.totalSupply, self._getTotalAssets(False), False)\n\n\n@nonreentrant\n@external\ndef redeem(_shares: uint256, _receiver: address = msg.sender, _owner: address = msg.sender) -> uint256:\n    return self._redeem(_shares, msg.sender, _receiver, _owner, 0)\n\n\n@nonreentrant\n@external\ndef redeemWithMinAmountOut(_shares: uint256, _minAmountOut: uint256, _receiver: address = msg.sender, _owner: address = msg.sender) -> uint256:\n    return self._redeem(_shares, msg.sender, _receiver, _owner, _minAmountOut)\n\n\n@internal\ndef _redeem(_shares: uint256, _sender: address, _receiver: address, _owner: address, _minAmountOut: uint256) -> uint256:\n    vaultRegistry: address = vaultWallet._getVaultRegistry()\n\n    shares: uint256 = _shares\n    if shares == max_value(uint256):\n        shares = token.balanceOf[_owner]\n\n    # underlying data\n    totalAssets: uint256 = 0\n    currentBalance: uint256 = 0\n    pendingYieldRealized: uint256 = 0\n    maxBalVaultToken: address = empty(address)\n    totalAssets, currentBalance, pendingYieldRealized, maxBalVaultToken = self._getUnderlyingData(False, vaultRegistry)\n\n    amount: uint256 = self._sharesToAmount(shares, token.totalSupply, totalAssets, False)\n    return self._redeemFromVault(vaultWallet.VAULT_ASSET, amount, _minAmountOut, shares, _sender, _receiver, _owner, currentBalance, pendingYieldRealized, maxBalVaultToken, vaultRegistry)\n\n\n# shared redeem logic\n\n\n@internal\ndef _redeemFromVault(\n    _asset: address,\n    _amount: uint256,\n    _minAmountOut: uint256,\n    _shares: uint256,\n    _sender: address,\n    _recipient: address,\n    _owner: address,\n    _currentBalance: uint256,\n    _pendingYieldRealized: uint256,\n    _maxBalVaultToken: address,\n    _vaultRegistry: address,\n) -> uint256:\n    assert staticcall VaultRegistry(_vaultRegistry).canWithdraw(self) # dev: cannot withdraw\n\n    assert _amount != 0 # dev: cannot withdraw 0 amount\n    assert _shares != 0 # dev: cannot redeem 0 shares\n    assert _recipient != empty(address) # dev: invalid recipient\n\n    assert token.balanceOf[_owner] >= _shares # dev: insufficient shares\n\n    if _sender != _owner:\n        token._spendAllowance(_owner, _sender, _shares)\n\n    # withdraw from yield opportunity\n    availAmount: uint256 = 0\n    withdrawnAmount: uint256 = 0\n    availAmount, withdrawnAmount = vaultWallet._prepareRedemption(_asset, _amount, _maxBalVaultToken, _sender, _vaultRegistry)\n    actualAmount: uint256 = min(availAmount, _amount)\n\n    # check amount out\n    if _minAmountOut != 0:\n        assert actualAmount >= _minAmountOut # dev: insufficient amount out\n    else:\n        assert self._isRedemptionCloseEnough(_amount, actualAmount) # dev: insufficient funds\n\n    # save data\n    currentBalance: uint256 = _currentBalance - min(_currentBalance, withdrawnAmount)\n    vaultWallet.lastUnderlyingBal = currentBalance\n    vaultWallet.pendingYieldRealized = _pendingYieldRealized\n\n    # burn shares, transfer assets\n    token._burn(_owner, _shares)\n    assert extcall IERC20(_asset).transfer(_recipient, actualAmount, default_return_value=True) # dev: withdrawal failed\n\n    log Withdraw(sender=_sender, receiver=_recipient, owner=_owner, assets=actualAmount, shares=_shares)\n    return actualAmount\n\n\n@pure\n@internal\ndef _isRedemptionCloseEnough(_requestedAmount: uint256, _actualAmount: uint256) -> bool:\n    # extra check to make sure what was sent was actually close-ish to what was requested\n    buffer: uint256 = _requestedAmount * 10 // HUNDRED_PERCENT # 0.1%\n    lowerBound: uint256 = _requestedAmount - buffer\n    return _actualAmount >= lowerBound\n\n\n##########\n# Shares #\n##########\n\n\n@view\n@external\ndef convertToShares(_assets: uint256) -> uint256:\n    return self._amountToShares(_assets, token.totalSupply, self._getTotalAssets(True), False)\n\n\n@view\n@external\ndef convertToSharesSafe(_assets: uint256) -> uint256:\n    return self._amountToShares(_assets, token.totalSupply, self._getTotalAssets(False), False)\n\n\n@view\n@external\ndef convertToAssets(_shares: uint256) -> uint256:\n    return self._sharesToAmount(_shares, token.totalSupply, self._getTotalAssets(True), False)\n\n\n@view\n@external\ndef convertToAssetsSafe(_shares: uint256) -> uint256:\n    return self._sharesToAmount(_shares, token.totalSupply, self._getTotalAssets(False), False)\n\n\n# amount -> shares\n\n\n@view\n@internal\ndef _amountToShares(\n    _amount: uint256,\n    _totalShares: uint256,\n    _totalBalance: uint256,\n    _shouldRoundUp: bool,\n) -> uint256:\n    if _amount == max_value(uint256) or _amount == 0:\n        return _amount\n\n    # first deposit, price per share = 1\n    if _totalShares == 0:\n        return _amount\n\n    # no underlying balance, price per share = 0\n    if _totalBalance == 0:\n        return 0\n\n    # calc shares\n    numerator: uint256 = _amount * _totalShares\n    shares: uint256 = numerator // _totalBalance\n\n    # rounding\n    if _shouldRoundUp and (numerator % _totalBalance != 0):\n        shares += 1\n\n    return shares\n\n\n# shares -> amount\n\n\n@view\n@internal\ndef _sharesToAmount(\n    _shares: uint256,\n    _totalShares: uint256,\n    _totalBalance: uint256,\n    _shouldRoundUp: bool,\n) -> uint256:\n    if _shares == max_value(uint256) or _shares == 0:\n        return _shares\n\n    # first deposit, price per share = 1\n    if _totalShares == 0:\n        return _shares\n\n    # calc amount\n    numerator: uint256 = _shares * _totalBalance\n    amount: uint256 = numerator // _totalShares\n\n    # rounding\n    if _shouldRoundUp and (numerator % _totalShares != 0):\n        amount += 1\n\n    return amount\n",
            "sha256sum": "4404360a1443d0d8fc4f990e19f2bcc78413322ddd906e276df625cc8181273e"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/vaults/EarnVault.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.3+commit.bff19ea2",
        "integrity": "c6fdf6e04d79c8f1adfe0287effde9a98c581054dad097e446fe37d03bbcfc1e"
      },
      "args": "0000000000000000000000002ae3f1ec7f1f5012cfeab0185bfc7aa3cf0dec2200000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000012000000000000000000000000044cf3c4f000dfd76a35d03298049d37be688d6f90000000000000000000000000000000000000000000000000000000000000e10000000000000000000000000000000000000000000000000000000000013c6800000000000000000000000009d3f593380875860cc18f5736373ae4b084ba2f9000000000000000000000000000000000000000000000000000000000000001a556e64657273636f726520426c756520436869702043424554480000000000000000000000000000000000000000000000000000000000000000000000000009756e647943424554480000000000000000000000000000000000000000000000",
      "file": "contracts/vaults/EarnVault.vy"
    },
    "UndyGho": {
      "address": "0x78De8bd82035593e140e0f6567A019db3d716B74",
      "abi": [
        {
          "name": "Deposit",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "owner",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assets",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "shares",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "Withdraw",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "receiver",
              "type": "address",
              "indexed": true
            },
            {
              "name": "owner",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assets",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "shares",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "Transfer",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "Approval",
          "inputs": [
            {
              "name": "owner",
              "type": "address",
              "indexed": true
            },
            {
              "name": "spender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "BlacklistModified",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "isBlacklisted",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "TokenPauseModified",
          "inputs": [
            {
              "name": "isPaused",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "EarnVaultAction",
          "inputs": [
            {
              "name": "op",
              "type": "uint8",
              "indexed": false
            },
            {
              "name": "asset1",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset2",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount1",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "amount2",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "legoId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "signer",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PerformanceFeesClaimed",
          "inputs": [
            {
              "name": "pendingFees",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "name",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "string"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "symbol",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "string"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "decimals",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint8"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "transfer",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "transferFrom",
          "inputs": [
            {
              "name": "_sender",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "approve",
          "inputs": [
            {
              "name": "_spender",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "increaseAllowance",
          "inputs": [
            {
              "name": "_spender",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "decreaseAllowance",
          "inputs": [
            {
              "name": "_spender",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "burn",
          "inputs": [
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "DOMAIN_SEPARATOR",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bytes32"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "permit",
          "inputs": [
            {
              "name": "_owner",
              "type": "address"
            },
            {
              "name": "_spender",
              "type": "address"
            },
            {
              "name": "_value",
              "type": "uint256"
            },
            {
              "name": "_deadline",
              "type": "uint256"
            },
            {
              "name": "_signature",
              "type": "bytes"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setBlacklist",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            },
            {
              "name": "_shouldBlacklist",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "burnBlacklistTokens",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "burnBlacklistTokens",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pause",
          "inputs": [
            {
              "name": "_shouldPause",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "undyHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "blacklisted",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isPaused",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "balanceOf",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "allowance",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalSupply",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "TOKEN_NAME",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "string"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "TOKEN_SYMBOL",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "string"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "TOKEN_DECIMALS",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint8"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "VERSION",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "string"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "nonces",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositForYield",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositForYield",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositForYield",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositForYield",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawFromYield",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawFromYield",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawFromYield",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawFromYield",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_isSpecialTx",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_instructions",
              "type": "tuple[]",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "minAmountOut",
                  "type": "uint256"
                },
                {
                  "name": "tokenPath",
                  "type": "address[]"
                },
                {
                  "name": "poolPath",
                  "type": "address[]"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimPerformanceFees",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getClaimablePerformanceFees",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "updateYieldPosition",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addManager",
          "inputs": [
            {
              "name": "_manager",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeManager",
          "inputs": [
            {
              "name": "_manager",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "lastUnderlyingBal",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingYieldRealized",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "vaultToLegoId",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assets",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "managers",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfManager",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numManagers",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "asset",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getTotalAssets",
          "inputs": [
            {
              "name": "_shouldGetMax",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "maxDeposit",
          "inputs": [
            {
              "name": "_receiver",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "previewDeposit",
          "inputs": [
            {
              "name": "_assets",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "deposit",
          "inputs": [
            {
              "name": "_assets",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "deposit",
          "inputs": [
            {
              "name": "_assets",
              "type": "uint256"
            },
            {
              "name": "_receiver",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositWithMinAmountOut",
          "inputs": [
            {
              "name": "_assets",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositWithMinAmountOut",
          "inputs": [
            {
              "name": "_assets",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_receiver",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "maxMint",
          "inputs": [
            {
              "name": "_receiver",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "previewMint",
          "inputs": [
            {
              "name": "_shares",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mint",
          "inputs": [
            {
              "name": "_shares",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mint",
          "inputs": [
            {
              "name": "_shares",
              "type": "uint256"
            },
            {
              "name": "_receiver",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "maxWithdraw",
          "inputs": [
            {
              "name": "_owner",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "previewWithdraw",
          "inputs": [
            {
              "name": "_assets",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdraw",
          "inputs": [
            {
              "name": "_assets",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdraw",
          "inputs": [
            {
              "name": "_assets",
              "type": "uint256"
            },
            {
              "name": "_receiver",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdraw",
          "inputs": [
            {
              "name": "_assets",
              "type": "uint256"
            },
            {
              "name": "_receiver",
              "type": "address"
            },
            {
              "name": "_owner",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "maxRedeem",
          "inputs": [
            {
              "name": "_owner",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "previewRedeem",
          "inputs": [
            {
              "name": "_shares",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "redeem",
          "inputs": [
            {
              "name": "_shares",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "redeem",
          "inputs": [
            {
              "name": "_shares",
              "type": "uint256"
            },
            {
              "name": "_receiver",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "redeem",
          "inputs": [
            {
              "name": "_shares",
              "type": "uint256"
            },
            {
              "name": "_receiver",
              "type": "address"
            },
            {
              "name": "_owner",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "redeemWithMinAmountOut",
          "inputs": [
            {
              "name": "_shares",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "redeemWithMinAmountOut",
          "inputs": [
            {
              "name": "_shares",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_receiver",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "redeemWithMinAmountOut",
          "inputs": [
            {
              "name": "_shares",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_receiver",
              "type": "address"
            },
            {
              "name": "_owner",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "convertToShares",
          "inputs": [
            {
              "name": "_assets",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "convertToSharesSafe",
          "inputs": [
            {
              "name": "_assets",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "convertToAssets",
          "inputs": [
            {
              "name": "_shares",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "convertToAssetsSafe",
          "inputs": [
            {
              "name": "_shares",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_tokenName",
              "type": "string"
            },
            {
              "name": "_tokenSymbol",
              "type": "string"
            },
            {
              "name": "_undyHq",
              "type": "address"
            },
            {
              "name": "_minHqTimeLock",
              "type": "uint256"
            },
            {
              "name": "_maxHqTimeLock",
              "type": "uint256"
            },
            {
              "name": "_startingAgent",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/vaults/modules/VaultErc20Token.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nimplements: IERC20\nfrom ethereum.ercs import IERC20\n\ninterface UndyHq:\n    def canSetTokenBlacklist(_addr: address) -> bool: view\n    def canMintUndy(_addr: address) -> bool: view\n    def hasPendingGovChange() -> bool: view\n    def governance() -> address: view\n\ninterface ERC1271:\n    def isValidSignature(_hash: bytes32, _signature: Bytes[65]) -> bytes4: view\n\n# erc20\n\nevent Transfer:\n    sender: indexed(address)\n    recipient: indexed(address)\n    amount: uint256\n\nevent Approval:\n    owner: indexed(address)\n    spender: indexed(address)\n    amount: uint256\n\n# undy \n\nevent BlacklistModified:\n    addr: indexed(address)\n    isBlacklisted: bool\n\nevent TokenPauseModified:\n    isPaused: bool\n\n# undy hq\nundyHq: public(address)\n\n# config\nblacklisted: public(HashMap[address, bool])\nisPaused: public(bool)\n\n# erc20\nbalanceOf: public(HashMap[address, uint256])\nallowance: public(HashMap[address, HashMap[address, uint256]])\ntotalSupply: public(uint256)\n\n# token info\nTOKEN_NAME: public(immutable(String[64]))\nTOKEN_SYMBOL: public(immutable(String[32]))\nTOKEN_DECIMALS: public(immutable(uint8))\nVERSION: public(constant(String[8])) = \"v1.0.0\"\n\n# eip-712\nnonces: public(HashMap[address, uint256])\nEIP712_TYPEHASH: constant(bytes32) = keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\")\nEIP2612_TYPEHASH: constant(bytes32) = keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\")\nECRECOVER_PRECOMPILE: constant(address) = 0x0000000000000000000000000000000000000001\nERC1271_MAGIC_VAL: constant(bytes4) = 0x1626ba7e\n\nCACHED_DOMAIN_SEPARATOR: immutable(bytes32)\nNAME_HASH: immutable(bytes32)\nVERSION_HASH: constant(bytes32) = keccak256(VERSION)\nCACHED_CHAIN_ID: immutable(uint256)\n\n\n@deploy\ndef __init__(\n    _tokenName: String[64],\n    _tokenSymbol: String[32],\n    _tokenDecimals: uint8,\n    _undyHq: address,\n):\n    # token info\n    TOKEN_NAME = _tokenName\n    TOKEN_SYMBOL = _tokenSymbol\n    TOKEN_DECIMALS = _tokenDecimals\n\n    # set undy hq\n    assert _undyHq != empty(address) # dev: invalid undy hq\n    self.undyHq = _undyHq\n\n    # domain separator\n    NAME_HASH = keccak256(_tokenName)\n    CACHED_CHAIN_ID = chain.id\n    CACHED_DOMAIN_SEPARATOR = keccak256(\n        abi_encode(\n            EIP712_TYPEHASH,\n            NAME_HASH,\n            VERSION_HASH,\n            CACHED_CHAIN_ID,\n            self,\n        )\n    )\n\n\n##############\n# Token Info #\n##############\n\n\n@view\n@external\ndef name() -> String[64]:\n    return TOKEN_NAME\n\n\n@view\n@external\ndef symbol() -> String[32]:\n    return TOKEN_SYMBOL\n\n\n@view\n@external\ndef decimals() -> uint8:\n    return TOKEN_DECIMALS\n\n\n#############\n# Transfers #\n#############\n\n\n@external\ndef transfer(_recipient: address, _amount: uint256) -> bool:\n    self._transfer(msg.sender, _recipient, _amount)\n    return True\n\n\n@external\ndef transferFrom(_sender: address, _recipient: address, _amount: uint256) -> bool:\n    assert not self.blacklisted[msg.sender] # dev: spender blacklisted\n    self._spendAllowance(_sender, msg.sender, _amount)\n    self._transfer(_sender, _recipient, _amount)\n    return True\n\n\n@internal\ndef _transfer(_sender: address, _recipient: address, _amount: uint256):\n    assert not self.isPaused # dev: token paused\n    assert _amount != 0 # dev: cannot transfer 0 amount\n    assert _recipient not in [self, empty(address)] # dev: invalid recipient\n\n    assert not self.blacklisted[_sender] # dev: sender blacklisted\n    assert not self.blacklisted[_recipient] # dev: recipient blacklisted\n\n    senderBalance: uint256 = self.balanceOf[_sender]\n    assert senderBalance >= _amount # dev: insufficient funds\n    self.balanceOf[_sender] = senderBalance - _amount\n    self.balanceOf[_recipient] += _amount\n\n    log Transfer(sender=_sender, recipient=_recipient, amount=_amount)\n\n\n#############\n# Allowance #\n#############\n\n\n# approvals\n\n\n@external\ndef approve(_spender: address, _amount: uint256) -> bool:\n    self._validateNewApprovals(msg.sender, _spender)\n    self._approve(msg.sender, _spender, _amount)\n    return True\n\n\n@internal\ndef _approve(_owner: address, _spender: address, _amount: uint256):\n    self.allowance[_owner][_spender] = _amount\n    log Approval(owner=_owner, spender=_spender, amount=_amount)\n\n\n@internal\ndef _spendAllowance(_owner: address, _spender: address, _amount: uint256):\n    currentAllowance: uint256 = self.allowance[_owner][_spender]\n    if currentAllowance != max_value(uint256):\n        assert currentAllowance >= _amount # dev: insufficient allowance\n        self._approve(_owner, _spender, currentAllowance - _amount)\n\n\n# increase / decrease allowance\n\n\n@external\ndef increaseAllowance(_spender: address, _amount: uint256) -> bool:\n    self._validateNewApprovals(msg.sender, _spender)\n    currentAllowance: uint256 = self.allowance[msg.sender][_spender]\n    maxIncrease: uint256 = max_value(uint256) - currentAllowance\n    newAllowance: uint256 = currentAllowance + min(_amount, maxIncrease)\n    if newAllowance != currentAllowance:\n        self._approve(msg.sender, _spender, newAllowance)\n    return True\n\n\n@external\ndef decreaseAllowance(_spender: address, _amount: uint256) -> bool:\n    self._validateNewApprovals(msg.sender, _spender)\n    currentAllowance: uint256 = self.allowance[msg.sender][_spender]\n    newAllowance: uint256 = currentAllowance - min(_amount, currentAllowance)\n    if newAllowance != currentAllowance:\n        self._approve(msg.sender, _spender, newAllowance)\n    return True\n\n\n# validation\n\n\n@view\n@internal\ndef _validateNewApprovals(_owner: address, _spender: address):\n    assert not self.isPaused # dev: token paused\n    assert not self.blacklisted[_owner] # dev: owner blacklisted\n    assert not self.blacklisted[_spender] # dev: spender blacklisted\n    assert _spender != empty(address) # dev: invalid spender\n\n\n#####################\n# Minting / Burning #\n#####################\n\n\n# mint tokens\n\n\n@internal\ndef _mint(_recipient: address, _amount: uint256) -> bool:\n    assert _recipient not in [self, empty(address)] # dev: invalid recipient\n    assert not self.blacklisted[_recipient] # dev: blacklisted\n    assert not self.isPaused # dev: token paused\n\n    self.balanceOf[_recipient] += _amount\n    self.totalSupply += _amount\n    log Transfer(sender=empty(address), recipient=_recipient, amount=_amount)\n    return True\n\n\n# burn tokens\n\n\n@external\ndef burn(_amount: uint256) -> bool:\n    assert not self.isPaused # dev: token paused\n    self._burn(msg.sender, _amount)\n    return True\n\n\n@internal\ndef _burn(_owner: address, _amount: uint256):\n    self.balanceOf[_owner] -= _amount\n    self.totalSupply -= _amount\n    log Transfer(sender=_owner, recipient=empty(address), amount=_amount)\n\n\n###########\n# EIP 712 #\n###########\n\n\n@view\n@external\ndef DOMAIN_SEPARATOR() -> bytes32:\n    return self._domainSeparator()\n\n\n@view\n@internal\ndef _domainSeparator() -> bytes32:\n    if chain.id != CACHED_CHAIN_ID:\n        return keccak256(\n            abi_encode(\n                EIP712_TYPEHASH,\n                NAME_HASH,\n                VERSION_HASH,\n                chain.id,\n                self,\n            )\n        )\n    return CACHED_DOMAIN_SEPARATOR\n\n\n@external\ndef permit(\n    _owner: address,\n    _spender: address,\n    _value: uint256,\n    _deadline: uint256,\n    _signature: Bytes[65],\n) -> bool:\n    self._validateNewApprovals(_owner, _spender)\n    assert _owner != empty(address) and block.timestamp <= _deadline # dev: permit expired\n\n    nonce: uint256 = self.nonces[_owner]\n    digest: bytes32 = keccak256(\n        concat(\n            b\"\\x19\\x01\",\n            self._domainSeparator(),\n            keccak256(abi_encode(EIP2612_TYPEHASH, _owner, _spender, _value, nonce, _deadline)),\n        )\n    )\n\n    if _owner.is_contract:\n        assert staticcall ERC1271(_owner).isValidSignature(digest, _signature) == ERC1271_MAGIC_VAL # dev: invalid signature\n\n    else:\n        r: bytes32 = convert(slice(_signature, 0, 32), bytes32)\n        s: bytes32 = convert(slice(_signature, 32, 32), bytes32)\n        v: uint8 = convert(slice(_signature, 64, 1), uint8)\n\n        # validate v parameter (27 or 28)\n        if v < 27:\n            v = v + 27\n        assert v == 27 or v == 28 # dev: invalid v parameter\n\n        # prevent signature malleability by ensuring s is in lower half of curve order\n        s_uint: uint256 = convert(s, uint256)\n        assert s_uint != 0 # dev: invalid s value (zero)\n        assert s_uint <= convert(0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, uint256) # dev: invalid s value\n\n        response: Bytes[32] = raw_call(\n            ECRECOVER_PRECOMPILE,\n            abi_encode(digest, v, r, s),\n            max_outsize = 32,\n            is_static_call = True # a view function\n        )\n        assert len(response) == 32  # dev: invalid ecrecover response length\n        assert abi_decode(response, address) == _owner  # dev: invalid signature\n\n    self.nonces[_owner] = nonce + 1\n    self._approve(_owner, _spender, _value)\n    return True\n\n\n#############\n# Blacklist #\n#############\n\n\n@external\ndef setBlacklist(_addr: address, _shouldBlacklist: bool) -> bool:\n    assert staticcall UndyHq(self.undyHq).canSetTokenBlacklist(msg.sender) # dev: no perms\n\n    assert _addr not in [self, empty(address)] # dev: invalid blacklist recipient\n    self.blacklisted[_addr] = _shouldBlacklist\n    log BlacklistModified(addr=_addr, isBlacklisted=_shouldBlacklist)\n    return True\n\n\n@external\ndef burnBlacklistTokens(_addr: address, _amount: uint256 = max_value(uint256)) -> bool:\n    assert msg.sender == staticcall UndyHq(self.undyHq).governance() # dev: no perms\n    assert self.blacklisted[_addr] # dev: not blacklisted\n\n    amount: uint256 = min(_amount, self.balanceOf[_addr])\n    assert amount != 0 # dev: cannot burn 0 tokens\n    self._burn(_addr, amount)\n    return True\n\n\n#########\n# Pause #\n#########\n\n\n@external\ndef pause(_shouldPause: bool):\n    assert msg.sender == staticcall UndyHq(self.undyHq).governance() # dev: no perms\n    assert _shouldPause != self.isPaused # dev: no change\n    self.isPaused = _shouldPause\n    log TokenPauseModified(isPaused=_shouldPause)\n",
            "sha256sum": "c01f0100f9d040bbd95c91f201e0623bd0331c6982e5ef73e832a37bb27eee08"
          },
          "interfaces/Wallet.vyi": {
            "content": "# @version 0.4.3\n\nstruct SwapInstruction:\n    legoId: uint256\n    amountIn: uint256\n    minAmountOut: uint256\n    tokenPath: DynArray[address, MAX_TOKEN_PATH]\n    poolPath: DynArray[address, MAX_TOKEN_PATH - 1]\n\nMAX_SWAP_INSTRUCTIONS: constant(uint256) = 5\nMAX_TOKEN_PATH: constant(uint256) = 5\n\n\n@view\n@external\ndef onERC721Received(_operator: address, _owner: address, _tokenId: uint256, _data: Bytes[1024]) -> bytes4:\n    ...\n\n\n@pure\n@external\ndef apiVersion() -> String[28]:\n    ...\n\n##################\n# Transfer Funds #\n##################\n\n\n@external\ndef transferFunds(\n    _recipient: address,\n    _asset: address = empty(address),\n    _amount: uint256 = max_value(uint256),\n    _isCheque: bool = False,\n    _isTrustedTx: bool = False,\n) -> (uint256, uint256):\n    ...\n\n\n#########\n# Yield #\n#########\n\n\n# deposit\n\n\n@external\ndef depositForYield(\n    _legoId: uint256,\n    _asset: address,\n    _vaultAddr: address = empty(address),\n    _amount: uint256 = max_value(uint256),\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, address, uint256, uint256):\n    ...\n\n\n# withdraw\n\n\n@external\ndef withdrawFromYield(\n    _legoId: uint256,\n    _vaultToken: address,\n    _amount: uint256 = max_value(uint256),\n    _extraData: bytes32 = empty(bytes32),\n    _isTrustedTx: bool = False,\n) -> (uint256, address, uint256, uint256):\n    ...\n\n\n# rebalance position\n\n\n@external\ndef rebalanceYieldPosition(\n    _fromLegoId: uint256,\n    _fromVaultToken: address,\n    _toLegoId: uint256,\n    _toVaultAddr: address = empty(address),\n    _fromVaultAmount: uint256 = max_value(uint256),\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, address, uint256, uint256):\n    ...\n\n\n###################\n# Swap / Exchange #\n###################\n\n\n@external\ndef swapTokens(_instructions: DynArray[SwapInstruction, MAX_SWAP_INSTRUCTIONS]) -> (address, uint256, address, uint256, uint256):\n    ...\n\n\n# mint / redeem\n\n\n@external\ndef mintOrRedeemAsset(\n    _legoId: uint256,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256 = max_value(uint256),\n    _minAmountOut: uint256 = 0,\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, uint256, bool, uint256):\n    ...\n\n\n@external\ndef confirmMintOrRedeemAsset(\n    _legoId: uint256,\n    _tokenIn: address,\n    _tokenOut: address,\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, uint256):\n    ...\n\n\n###################\n# Debt Management #\n###################\n\n\n# add collateral\n\n\n@external\ndef addCollateral(\n    _legoId: uint256,\n    _asset: address,\n    _amount: uint256 = max_value(uint256),\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, uint256):\n    ...\n\n\n# remove collateral\n\n\n@external\ndef removeCollateral(\n    _legoId: uint256,\n    _asset: address,\n    _amount: uint256 = max_value(uint256),\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, uint256):\n    ...\n\n\n# borrow\n\n\n@external\ndef borrow(\n    _legoId: uint256,\n    _borrowAsset: address,\n    _amount: uint256 = max_value(uint256),\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, uint256):\n    ...\n\n\n# repay debt\n\n\n@external\ndef repayDebt(\n    _legoId: uint256,\n    _paymentAsset: address,\n    _paymentAmount: uint256 = max_value(uint256),\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, uint256):\n    ...\n\n\n#################\n# Claim Rewards #\n#################\n\n\n@external\ndef claimRewards(\n    _legoId: uint256,\n    _rewardToken: address = empty(address),\n    _rewardAmount: uint256 = max_value(uint256),\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, uint256):\n    ...\n\n\n################\n# Wrapped ETH #\n################\n\n\n# eth -> weth\n\n\n@payable\n@external\ndef convertEthToWeth(_amount: uint256 = max_value(uint256)) -> (uint256, uint256):\n    ...\n\n\n# weth -> eth\n\n\n@external\ndef convertWethToEth(_amount: uint256 = max_value(uint256)) -> (uint256, uint256):\n    ...\n\n\n#################\n# Add Liquidity #\n#################\n\n\n# add / remove liquidity (simple)\n\n\n@external\ndef addLiquidity(\n    _legoId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _amountA: uint256 = max_value(uint256),\n    _amountB: uint256 = max_value(uint256),\n    _minAmountA: uint256 = 0,\n    _minAmountB: uint256 = 0,\n    _minLpAmount: uint256 = 0,\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, uint256, uint256, uint256):\n    ...\n\n\n@external\ndef removeLiquidity(\n    _legoId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpToken: address,\n    _lpAmount: uint256 = max_value(uint256),\n    _minAmountA: uint256 = 0,\n    _minAmountB: uint256 = 0,\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, uint256, uint256, uint256):\n    ...\n\n\n# add / remove liquidity (concentrated)\n\n\n@external\ndef addLiquidityConcentrated(\n    _legoId: uint256,\n    _nftAddr: address,\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _amountA: uint256 = max_value(uint256),\n    _amountB: uint256 = max_value(uint256),\n    _tickLower: int24 = min_value(int24),\n    _tickUpper: int24 = max_value(int24),\n    _minAmountA: uint256 = 0,\n    _minAmountB: uint256 = 0,\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, uint256, uint256, uint256, uint256):\n    ...\n\n\n@external\ndef removeLiquidityConcentrated(\n    _legoId: uint256,\n    _nftAddr: address,\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _liqToRemove: uint256 = max_value(uint256),\n    _minAmountA: uint256 = 0,\n    _minAmountB: uint256 = 0,\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, uint256, uint256, uint256):\n    ...\n\n\n#############\n# Utilities #\n#############\n\n\n# recover nft\n\n\n@external\ndef recoverNft(_collection: address, _nftTokenId: uint256, _recipient: address):\n    ...\n",
            "sha256sum": "bc36343f2acf1bcd8ce0ae78be20898917cec4f6fa4a4e9fcfea42baa0f75c21"
          },
          "interfaces/WalletStructs.vyi": {
            "content": "# @version 0.4.3\n\nflag ActionType:\n    TRANSFER\n    EARN_DEPOSIT\n    EARN_WITHDRAW\n    EARN_REBALANCE\n    SWAP\n    MINT_REDEEM\n    CONFIRM_MINT_REDEEM\n    ADD_COLLATERAL\n    REMOVE_COLLATERAL\n    BORROW\n    REPAY_DEBT\n    REWARDS\n    ETH_TO_WETH\n    WETH_TO_ETH\n    ADD_LIQ\n    REMOVE_LIQ\n    ADD_LIQ_CONC\n    REMOVE_LIQ_CONC\n    PAY_CHEQUE\n\nstruct WalletAssetData:\n    assetBalance: uint256\n    usdValue: uint256\n    isYieldAsset: bool\n    lastPricePerShare: uint256\n\nstruct ActionData:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    billing: address\n    wallet: address\n    walletConfig: address\n    walletOwner: address\n    inEjectMode: bool\n    isFrozen: bool\n    lastTotalUsdValue: uint256\n    signer: address\n    isManager: bool\n    legoId: uint256\n    legoAddr: address\n    eth: address\n    weth: address\n\nstruct MiniAddys:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    appraiser: address",
            "sha256sum": "9a4b4f59b3a62043e51b425a665064aae419a3c0bd0514b6b29a9441ae364bb9"
          },
          "interfaces/LegoPartner.vyi": {
            "content": "# @version 0.4.3\n\nfrom interfaces import WalletStructs as ws\n\nMAX_TOKEN_PATH: constant(uint256) = 5\nMAX_RECOVER_ASSETS: constant(uint256) = 20\n\n@external\ndef addLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _tickLower: int24, _tickUpper: int24, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef addLiquidity(_pool: address, _tokenA: address, _tokenB: address, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _minLpAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (address, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef removeLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _liqToRemove: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef removeLiquidity(_pool: address, _tokenA: address, _tokenB: address, _lpToken: address, _lpAmount: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef mintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _tokenInAmount: uint256, _minAmountOut: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef swapTokens(_amountIn: uint256, _minAmountOut: uint256, _tokenPath: DynArray[address, MAX_TOKEN_PATH], _poolPath: DynArray[address, MAX_TOKEN_PATH - 1], _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256):\n    ...\n\n@external\ndef depositForYield(_asset: address, _amount: uint256, _vaultAddr: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef withdrawFromYield(_vaultToken: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef confirmMintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef borrow(_borrowAsset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef repayDebt(_paymentAsset: address, _paymentAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef claimRewards(_user: address, _rewardToken: address, _rewardAmount: uint256, _extraData: bytes32, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef removeCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef addCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@view\n@external\ndef getAccessForLego(_user: address, _action: ws.ActionType) -> (address, String[64], uint256):\n    ...\n\n@view\n@external\ndef hasCapability(_action: ws.ActionType) -> bool:\n    ...\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    ...\n\n@view\n@external\ndef isYieldLego() -> bool:\n    ...\n\n@view\n@external\ndef isDexLego() -> bool:\n    ...\n\n\n# common\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "81db71fe4440a3b4b563134c9b5caf1d5705772a5f291fe874c9b5fb3cfb1623"
          },
          "contracts/vaults/modules/EarnVaultWallet.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nfrom interfaces import Wallet as wi\nfrom interfaces import LegoPartner as Lego\nfrom interfaces import WalletStructs as ws\n\nfrom ethereum.ercs import IERC20\nfrom ethereum.ercs import IERC20Detailed\n\ninterface VaultRegistry:\n    def getVaultActionDataWithFrozenStatus(_legoId: uint256, _signer: address, _vaultAddr: address) -> (VaultActionData, bool): view\n    def getVaultActionDataBundle(_legoId: uint256, _signer: address) -> VaultActionData: view\n    def checkVaultApprovals(_vaultAddr: address, _vaultToken: address) -> bool: view\n    def getLegoDataFromVaultToken(_vaultToken: address) -> (uint256, address): view\n    def redemptionConfig(_vaultAddr: address) -> (uint256, uint256): view\n    def getPerformanceFee(_vaultAddr: address) -> uint256: view\n\ninterface YieldLego:\n    def getUnderlyingBalances(_vaultToken: address, _vaultTokenBalance: uint256) -> (uint256, uint256): view\n    def getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256: view\n\ninterface Switchboard:\n    def isSwitchboardAddr(_addr: address) -> bool: view\n\ninterface MissionControl:\n    def isLockedSigner(_signer: address) -> bool: view\n\ninterface Registry:\n    def getAddr(_regId: uint256) -> address: view\n\ninterface UndyHq:\n    def governance() -> address: view\n\nstruct VaultActionData:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    appraiser: address\n    vaultRegistry: address\n    vaultAsset: address\n    signer: address\n    legoId: uint256\n    legoAddr: address\n\nevent EarnVaultAction:\n    op: uint8\n    asset1: indexed(address)\n    asset2: indexed(address)\n    amount1: uint256\n    amount2: uint256\n    usdValue: uint256\n    legoId: uint256\n    signer: indexed(address)\n\nevent PerformanceFeesClaimed:\n    pendingFees: uint256\n\n# yield tracking\nlastUnderlyingBal: public(uint256)\npendingYieldRealized: public(uint256)\n\n# asset data\nvaultToLegoId: public(HashMap[address, uint256]) # vault addr -> lego id\nassets: public(HashMap[uint256, address]) # index -> asset\nindexOfAsset: public(HashMap[address, uint256]) # asset -> index\nnumAssets: public(uint256) # num assets\n\n# managers\nmanagers: public(HashMap[uint256, address]) # index -> manager\nindexOfManager: public(HashMap[address, uint256]) # manager -> index\nnumManagers: public(uint256) # num managers\n\n# constants\nHUNDRED_PERCENT: constant(uint256) = 100_00 # 100.00%\nMAX_SWAP_INSTRUCTIONS: constant(uint256) = 5\nMAX_TOKEN_PATH: constant(uint256) = 5\nMAX_LEGOS: constant(uint256) = 10\nMAX_DEREGISTER_ASSETS: constant(uint256) = 25\n\n# registry ids\nLEGO_BOOK_ID: constant(uint256) = 3\nSWITCHBOARD_ID: constant(uint256) = 4\nVAULT_REGISTRY_ID: constant(uint256) = 10\n\nUNDY_HQ: immutable(address)\nVAULT_ASSET: immutable(address)\n\n\n@deploy\ndef __init__(\n    _undyHq: address,\n    _vaultAsset: address,\n    _startingAgent: address,\n):\n    # not using 0 index\n    self.numManagers = 1\n    self.numAssets = 1\n\n    assert empty(address) not in [_undyHq, _vaultAsset] # dev: inv addr\n    UNDY_HQ = _undyHq\n    VAULT_ASSET = _vaultAsset\n\n    # initial agent\n    if _startingAgent != empty(address):\n        self._registerManager(_startingAgent)\n\n\n#########\n# Yield #\n#########\n\n\n# deposit\n\n\n@external\ndef depositForYield(\n    _legoId: uint256,\n    _asset: address,\n    _vaultAddr: address = empty(address),\n    _amount: uint256 = max_value(uint256),\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, address, uint256, uint256):\n    ad: VaultActionData = self._canManagerPerformAction(msg.sender, [_legoId])\n    return self._depositForYield(_asset, _vaultAddr, _amount, _extraData, self._getUnderlyingAndUpdatePendingYield(), True, ad)\n\n\n@internal\ndef _onReceiveVaultFunds(\n    _vaultAddr: address,\n    _depositor: address,\n    _vaultRegistry: address,\n) -> uint256:\n    legoId: uint256 = self.vaultToLegoId[_vaultAddr]\n    ad: VaultActionData = staticcall VaultRegistry(_vaultRegistry).getVaultActionDataBundle(legoId, _depositor)\n    if ad.legoId == 0 or ad.legoAddr == empty(address):\n        return 0\n    ad.vaultAsset = VAULT_ASSET\n    return self._depositForYield(ad.vaultAsset, _vaultAddr, max_value(uint256), empty(bytes32), 0, False, ad)[0]\n\n\n@internal\ndef _depositForYield(\n    _asset: address,\n    _vaultAddr: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _currentUnderlying: uint256,\n    _shouldSaveUnderlying: bool,\n    _ad: VaultActionData,\n) -> (uint256, address, uint256, uint256):\n    amount: uint256 = self._getAmountAndApprove(_asset, _amount, _ad.legoAddr) # doing approval here\n    currentUnderlying: uint256 = _currentUnderlying\n\n    # deposit for yield\n    assetAmount: uint256 = 0\n    vaultToken: address = empty(address)\n    vaultTokenAmountReceived: uint256 = 0\n    txUsdValue: uint256 = 0\n    assetAmount, vaultToken, vaultTokenAmountReceived, txUsdValue = extcall Lego(_ad.legoAddr).depositForYield(_asset, amount, _vaultAddr, _extraData, self, self._packMiniAddys(_ad.ledger, _ad.missionControl, _ad.legoBook, _ad.appraiser))\n    assert extcall IERC20(_asset).approve(_ad.legoAddr, 0, default_return_value = True) # dev: appr\n\n    # update yield position\n    if _asset == VAULT_ASSET:\n        assert _vaultAddr == vaultToken # dev: vault token mismatch\n        assert staticcall VaultRegistry(_ad.vaultRegistry).checkVaultApprovals(self, vaultToken) # dev: lego or vault token not approved\n        self._updateYieldPosition(vaultToken, _ad.legoId)\n        currentUnderlying += assetAmount\n\n    # save underlying balance\n    if _shouldSaveUnderlying:\n        self.lastUnderlyingBal = currentUnderlying\n\n    log EarnVaultAction(\n        op = 10,\n        asset1 = _asset,\n        asset2 = vaultToken,\n        amount1 = assetAmount,\n        amount2 = vaultTokenAmountReceived,\n        usdValue = txUsdValue,\n        legoId = _ad.legoId,\n        signer = _ad.signer,\n    )\n    return assetAmount, vaultToken, vaultTokenAmountReceived, txUsdValue\n\n\n# withdraw\n\n\n@external\ndef withdrawFromYield(\n    _legoId: uint256,\n    _vaultToken: address,\n    _amount: uint256 = max_value(uint256),\n    _extraData: bytes32 = empty(bytes32),\n    _isSpecialTx: bool = False,\n) -> (uint256, address, uint256, uint256):\n    ad: VaultActionData = self._canManagerPerformAction(msg.sender, [_legoId])\n    return self._withdrawFromYield(_vaultToken, _amount, _extraData, self._getUnderlyingAndUpdatePendingYield(), True, ad)\n\n\n@internal\ndef _withdrawFromYield(\n    _vaultToken: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _currentUnderlying: uint256,\n    _shouldSaveUnderlying: bool,\n    _ad: VaultActionData,\n) -> (uint256, address, uint256, uint256):\n    assert _vaultToken != empty(address) # dev: invalid vault token\n    amount: uint256 = self._getAmountAndApprove(_vaultToken, _amount, empty(address)) # not approving here\n    currentUnderlying: uint256 = _currentUnderlying\n\n    # some vault tokens require max value approval (comp v3)\n    assert extcall IERC20(_vaultToken).approve(_ad.legoAddr, max_value(uint256), default_return_value = True) # dev: appr\n\n    # withdraw from yield\n    vaultTokenAmountBurned: uint256 = 0\n    underlyingAsset: address = empty(address)\n    underlyingAmount: uint256 = 0\n    txUsdValue: uint256 = 0\n    vaultTokenAmountBurned, underlyingAsset, underlyingAmount, txUsdValue = extcall Lego(_ad.legoAddr).withdrawFromYield(_vaultToken, amount, _extraData, self, self._packMiniAddys(_ad.ledger, _ad.missionControl, _ad.legoBook, _ad.appraiser))\n    assert extcall IERC20(_vaultToken).approve(_ad.legoAddr, 0, default_return_value = True) # dev: appr\n\n    # update yield position\n    if underlyingAsset == VAULT_ASSET:\n        self._updateYieldPosition(_vaultToken, _ad.legoId)\n        currentUnderlying -= min(currentUnderlying, underlyingAmount)\n\n    if _shouldSaveUnderlying:\n        self.lastUnderlyingBal = currentUnderlying\n\n    log EarnVaultAction(\n        op = 11,\n        asset1 = _vaultToken,\n        asset2 = underlyingAsset,\n        amount1 = vaultTokenAmountBurned,\n        amount2 = underlyingAmount,\n        usdValue = txUsdValue,\n        legoId = _ad.legoId,\n        signer = _ad.signer,\n    )\n    return vaultTokenAmountBurned, underlyingAsset, underlyingAmount, txUsdValue\n\n\n###################\n# Swap / Exchange #\n###################\n\n\n@external\ndef swapTokens(_instructions: DynArray[wi.SwapInstruction, MAX_SWAP_INSTRUCTIONS]) -> (address, uint256, address, uint256, uint256):\n    tokenIn: address = empty(address)\n    tokenOut: address = empty(address)\n    legoIds: DynArray[uint256, MAX_LEGOS] = []\n    tokenIn, tokenOut, legoIds = self._validateAndGetSwapInfo(_instructions)\n\n    # important checks!\n    vaultAsset: address = VAULT_ASSET\n    assert tokenIn != vaultAsset # dev: cannot swap out of vault asset\n    assert self.vaultToLegoId[tokenIn] == 0 # dev: cannot swap out of vault token\n    assert tokenOut == vaultAsset # dev: must swap into vault asset\n\n    # action data bundle\n    ad: VaultActionData = self._canManagerPerformAction(msg.sender, legoIds)\n    origAmountIn: uint256 = self._getAmountAndApprove(tokenIn, _instructions[0].amountIn, empty(address)) # not approving here\n\n    amountIn: uint256 = origAmountIn\n    lastTokenOut: address = empty(address)\n    lastTokenOutAmount: uint256 = 0\n    maxTxUsdValue: uint256 = 0\n\n    # perform swaps\n    for i: wi.SwapInstruction in _instructions:\n        if lastTokenOut != empty(address):\n            newTokenIn: address = i.tokenPath[0]\n            assert lastTokenOut == newTokenIn # dev: path\n            amountIn = min(lastTokenOutAmount, staticcall IERC20(newTokenIn).balanceOf(self))\n        \n        thisTxUsdValue: uint256 = 0\n        lastTokenOut, lastTokenOutAmount, thisTxUsdValue = self._performSwapInstruction(amountIn, i, ad)\n        maxTxUsdValue = max(maxTxUsdValue, thisTxUsdValue)\n\n    log EarnVaultAction(\n        op = 20,\n        asset1 = tokenIn,\n        asset2 = lastTokenOut,\n        amount1 = origAmountIn,\n        amount2 = lastTokenOutAmount,\n        usdValue = maxTxUsdValue,\n        legoId = ad.legoId, # using just the first lego used\n        signer = ad.signer,\n    )\n    return tokenIn, origAmountIn, lastTokenOut, lastTokenOutAmount, maxTxUsdValue\n\n\n@internal\ndef _performSwapInstruction(\n    _amountIn: uint256,\n    _i: wi.SwapInstruction,\n    _ad: VaultActionData,\n) -> (address, uint256, uint256):\n    legoAddr: address = staticcall Registry(_ad.legoBook).getAddr(_i.legoId)\n    assert legoAddr != empty(address) # dev: lego\n\n    # tokens\n    tokenIn: address = _i.tokenPath[0]\n    tokenOut: address = _i.tokenPath[len(_i.tokenPath) - 1]\n    tokenInAmount: uint256 = 0\n    tokenOutAmount: uint256 = 0\n    txUsdValue: uint256 = 0\n\n    assert extcall IERC20(tokenIn).approve(legoAddr, _amountIn, default_return_value = True) # dev: appr\n    tokenInAmount, tokenOutAmount, txUsdValue = extcall Lego(legoAddr).swapTokens(_amountIn, _i.minAmountOut, _i.tokenPath, _i.poolPath, self, self._packMiniAddys(_ad.ledger, _ad.missionControl, _ad.legoBook, _ad.appraiser))\n    assert extcall IERC20(tokenIn).approve(legoAddr, 0, default_return_value = True) # dev: appr\n    return tokenOut, tokenOutAmount, txUsdValue\n\n\n@internal\ndef _validateAndGetSwapInfo(_instructions: DynArray[wi.SwapInstruction, MAX_SWAP_INSTRUCTIONS]) -> (address, address, DynArray[uint256, MAX_LEGOS]):\n    numSwapInstructions: uint256 = len(_instructions)\n    assert numSwapInstructions != 0 # dev: swaps\n\n    # lego ids, make sure token paths are valid\n    legoIds: DynArray[uint256, MAX_LEGOS] = []\n    for i: wi.SwapInstruction in _instructions:\n        assert len(i.tokenPath) >= 2 # dev: path\n        if i.legoId not in legoIds:\n            legoIds.append(i.legoId)\n\n    # finalize tokens\n    firstRoutePath: DynArray[address, MAX_TOKEN_PATH] = _instructions[0].tokenPath\n    tokenIn: address = firstRoutePath[0]\n    tokenOut: address = empty(address)\n\n    if numSwapInstructions == 1:\n        tokenOut = firstRoutePath[len(firstRoutePath) - 1]\n    else:\n        lastRoutePath: DynArray[address, MAX_TOKEN_PATH] = _instructions[numSwapInstructions - 1].tokenPath\n        tokenOut = lastRoutePath[len(lastRoutePath) - 1]\n\n    assert empty(address) not in [tokenIn, tokenOut] # dev: path\n    return tokenIn, tokenOut, legoIds\n\n\n#################\n# Claim Rewards #\n#################\n\n\n@external\ndef claimRewards(\n    _legoId: uint256,\n    _rewardToken: address = empty(address),\n    _rewardAmount: uint256 = max_value(uint256),\n    _extraData: bytes32 = empty(bytes32),\n) -> (uint256, uint256):\n    ad: VaultActionData = self._canManagerPerformAction(msg.sender, [_legoId])\n\n    # make sure can access\n    self._setLegoAccessForAction(ad.legoAddr, ws.ActionType.REWARDS)\n\n    # claim rewards\n    rewardAmount: uint256 = 0\n    txUsdValue: uint256 = 0\n    rewardAmount, txUsdValue = extcall Lego(ad.legoAddr).claimRewards(self, _rewardToken, _rewardAmount, _extraData, self._packMiniAddys(ad.ledger, ad.missionControl, ad.legoBook, ad.appraiser))\n\n    log EarnVaultAction(\n        op = 50,\n        asset1 = _rewardToken,\n        asset2 = ad.legoAddr,\n        amount1 = rewardAmount,\n        amount2 = 0,\n        usdValue = txUsdValue,\n        legoId = ad.legoId,\n        signer = ad.signer,\n    )\n    return rewardAmount, txUsdValue\n\n\n#############################\n# Overall Yield Calculation #\n#############################\n\n\n# calculate yield realized\n\n\n@view\n@internal\ndef _calcNewYieldAndGetUnderlying(_currentUnderlying: uint256 = 0) -> (uint256, uint256):\n    currentUnderlying: uint256 = _currentUnderlying\n    if currentUnderlying == 0:\n        currentUnderlying = self._getUnderlyingYieldBalances()[0]\n\n    newYield: uint256 = 0\n    lastUnderlyingBal: uint256 = self.lastUnderlyingBal\n    if lastUnderlyingBal != 0 and currentUnderlying > lastUnderlyingBal:\n        newYield = currentUnderlying - lastUnderlyingBal\n\n    return currentUnderlying, newYield\n\n\n# update pending yield realized\n\n\n@internal\ndef _getUnderlyingAndUpdatePendingYield() -> uint256:\n    currentUnderlying: uint256 = 0\n    newYield: uint256 = 0\n    currentUnderlying, newYield = self._calcNewYieldAndGetUnderlying()\n    self.pendingYieldRealized += newYield\n    return currentUnderlying\n\n\n# claim performance fees\n\n\n@external\ndef claimPerformanceFees() -> uint256:\n    governance: address = staticcall UndyHq(UNDY_HQ).governance()\n    assert self._isSwitchboardAddr(msg.sender) or governance == msg.sender # dev: no perms\n\n    vaultRegistry: address = self._getVaultRegistry()\n    currentUnderlying: uint256 = self._getUnderlyingAndUpdatePendingYield()\n    pendingFees: uint256 = self.pendingYieldRealized * self._getPerformanceFeeRatio(vaultRegistry) // HUNDRED_PERCENT\n\n    # make withdrawals from yield positions\n    availAmount: uint256 = 0\n    withdrawnAmount: uint256 = 0\n    availAmount, withdrawnAmount = self._prepareRedemption(VAULT_ASSET, pendingFees, empty(address), governance, vaultRegistry)\n    assert availAmount >= pendingFees # dev: insufficient funds\n\n    # transfer pending fees to governance\n    assert extcall IERC20(VAULT_ASSET).transfer(governance, pendingFees, default_return_value=True) # dev: withdrawal failed\n\n    # update data\n    self.pendingYieldRealized = 0\n    self.lastUnderlyingBal = currentUnderlying - min(currentUnderlying, withdrawnAmount)\n\n    log PerformanceFeesClaimed(pendingFees=pendingFees)\n    return pendingFees\n\n\n# claimable performance fees\n\n\n@view\n@external\ndef getClaimablePerformanceFees() -> uint256:\n    newYield: uint256 = self._calcNewYieldAndGetUnderlying()[1]\n    return (self.pendingYieldRealized + newYield) * self._getPerformanceFeeRatio(self._getVaultRegistry()) // HUNDRED_PERCENT\n\n\n# get performance fee %\n\n\n@view\n@internal\ndef _getPerformanceFeeRatio(_vaultRegistry: address) -> uint256:\n    return staticcall VaultRegistry(_vaultRegistry).getPerformanceFee(self)\n\n\n#####################\n# Underlying Assets #\n#####################\n\n\n@view\n@internal\ndef _getUnderlyingYieldBalances() -> (uint256, uint256, address):\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return 0, 0, empty(address)\n\n    maxTotalAssets: uint256 = 0\n    safeTotalAssets: uint256 = 0\n\n    maxBalance: uint256 = 0\n    maxBalVaultToken: address = empty(address)\n\n    # iterate over each asset\n    legoBook: address = staticcall Registry(UNDY_HQ).getAddr(LEGO_BOOK_ID)\n    for i: uint256 in range(1, numAssets, bound=max_value(uint256)):\n\n        # get asset addr\n        vaultToken: address = self.assets[i]\n        if vaultToken == empty(address):\n            continue\n\n        vaultTokenBalance: uint256 = staticcall IERC20(vaultToken).balanceOf(self)\n        if vaultTokenBalance == 0:\n            continue\n\n        legoId: uint256 = self.vaultToLegoId[vaultToken]\n        if legoId == 0:\n            continue\n\n        legoAddr: address = staticcall Registry(legoBook).getAddr(legoId)\n        if legoAddr == empty(address):\n            continue\n\n        # get balance data\n        trueUnderlying: uint256 = 0\n        safeUnderlying: uint256 = 0\n        trueUnderlying, safeUnderlying = staticcall YieldLego(legoAddr).getUnderlyingBalances(vaultToken, vaultTokenBalance)\n\n        # add totals\n        maxTotalAssets += trueUnderlying\n        safeTotalAssets += safeUnderlying\n\n        # save max balance / token\n        if trueUnderlying > maxBalance:\n            maxBalance = trueUnderlying\n            maxBalVaultToken = vaultToken\n\n    return maxTotalAssets, safeTotalAssets, maxBalVaultToken\n\n\n###################\n# Redemption Prep #\n###################\n\n\n@internal\ndef _prepareRedemption(\n    _asset: address,\n    _amount: uint256,\n    _maxBalVaultToken: address,\n    _sender: address,\n    _vaultRegistry: address,\n) -> (uint256, uint256):\n    availAmount: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    if availAmount >= _amount:\n        return availAmount, 0\n\n    # get redemption config (buffer and min withdraw amount)\n    redemptionBuffer: uint256 = 0\n    minWithdrawAmount: uint256 = 0\n    redemptionBuffer, minWithdrawAmount = staticcall VaultRegistry(_vaultRegistry).redemptionConfig(self)\n\n    # buffer to make sure we pull out enough for redemption\n    bufferMultiplier: uint256 = HUNDRED_PERCENT + redemptionBuffer\n    targetWithdrawAmount: uint256 = _amount * bufferMultiplier // HUNDRED_PERCENT\n\n    withdrawnAmount: uint256 = 0\n    ad: VaultActionData = staticcall VaultRegistry(_vaultRegistry).getVaultActionDataBundle(0, _sender)\n    ad.vaultAsset = _asset\n    assetsToDeregister: DynArray[address, MAX_DEREGISTER_ASSETS] = []\n\n    # first withdraw from biggest yield position\n    if _maxBalVaultToken != empty(address):\n        underlyingAmount: uint256 = 0\n        needsDeregister: bool = False\n        underlyingAmount, needsDeregister = self._withdrawDuringRedemption(_maxBalVaultToken, targetWithdrawAmount, availAmount, minWithdrawAmount, 0, ad)\n        availAmount += underlyingAmount\n        withdrawnAmount += underlyingAmount\n        if needsDeregister:\n            assetsToDeregister.append(_maxBalVaultToken)\n\n    # next, iterate thru each yield position (order it is saved)\n    if availAmount < targetWithdrawAmount:\n        numAssets: uint256 = self.numAssets\n        if numAssets != 0:\n            for i: uint256 in range(1, numAssets, bound=max_value(uint256)):\n                if availAmount >= targetWithdrawAmount:\n                    break\n\n                vaultToken: address = self.assets[i]\n                if _maxBalVaultToken != empty(address) and vaultToken == _maxBalVaultToken:\n                    continue\n\n                # withdraw from yield opportunity\n                underlyingAmount: uint256 = 0\n                needsDeregister: bool = False\n                underlyingAmount, needsDeregister = self._withdrawDuringRedemption(vaultToken, targetWithdrawAmount, availAmount, minWithdrawAmount, len(assetsToDeregister), ad)\n                availAmount += underlyingAmount\n                withdrawnAmount += underlyingAmount\n\n                # add to deregister list\n                if needsDeregister and vaultToken not in assetsToDeregister:\n                    assetsToDeregister.append(vaultToken)\n\n    # deregister vault positions\n    for asset: address in assetsToDeregister:\n        self._deregisterYieldPosition(asset)\n\n    return availAmount, withdrawnAmount\n\n\n@internal\ndef _withdrawDuringRedemption(\n    _vaultToken: address,\n    _targetWithdrawAmount: uint256,\n    _availAmount: uint256,\n    _minWithdrawAmount: uint256,\n    _numDeregisterAssets: uint256,\n    _ad: VaultActionData,\n) -> (uint256, bool):\n    if _vaultToken == empty(address):\n        return 0, False\n\n    vaultTokenBalance: uint256 = staticcall IERC20(_vaultToken).balanceOf(self)\n    if vaultTokenBalance == 0:\n        return 0, _numDeregisterAssets < MAX_DEREGISTER_ASSETS # need to deregister\n\n    legoId: uint256 = self.vaultToLegoId[_vaultToken]\n    if legoId == 0:\n        return 0, False\n\n    ad: VaultActionData = _ad\n    ad.legoId = legoId\n    ad.legoAddr = staticcall Registry(ad.legoBook).getAddr(legoId)\n\n    # skip if amount still needed is below minimum (dust protection)\n    amountStillNeeded: uint256 = _targetWithdrawAmount - _availAmount\n    if _minWithdrawAmount != 0 and amountStillNeeded < _minWithdrawAmount:\n        return 0, False\n\n    # skip if vault tokens needed rounds to 0 (dust)\n    vaultTokensNeeded: uint256 = staticcall YieldLego(ad.legoAddr).getVaultTokenAmount(_ad.vaultAsset, amountStillNeeded, _vaultToken)\n    if vaultTokensNeeded == 0:\n        return 0, False\n\n    # withdraw from yield opportunity\n    underlyingAmount: uint256 = self._withdrawFromYield(_vaultToken, vaultTokensNeeded, empty(bytes32), 0, False, ad)[2]\n\n    # add to deregister list\n    needsDeregister: bool = False\n    if vaultTokensNeeded >= vaultTokenBalance and staticcall IERC20(_vaultToken).balanceOf(self) == 0 and _numDeregisterAssets < MAX_DEREGISTER_ASSETS:\n        needsDeregister = True\n\n    return underlyingAmount, needsDeregister\n\n\n###################\n# Yield Positions #\n###################\n\n\n# update yield position\n\n\n@external\ndef updateYieldPosition(_vaultToken: address):\n    assert self._isSwitchboardAddr(msg.sender) # dev: no perms\n    vaultRegistry: address = self._getVaultRegistry()\n    legoId: uint256 = 0\n    na: address = empty(address)\n    legoId, na = staticcall VaultRegistry(vaultRegistry).getLegoDataFromVaultToken(_vaultToken)\n    if legoId != 0:\n        self._updateYieldPosition(_vaultToken, legoId)\n\n\n@internal\ndef _updateYieldPosition(_vaultToken: address, _legoId: uint256):\n    if _vaultToken == empty(address):\n        return\n\n    # no balance, deregister asset\n    currentBalance: uint256 = staticcall IERC20(_vaultToken).balanceOf(self)\n    if currentBalance == 0:\n        self._deregisterYieldPosition(_vaultToken)\n        return\n\n    # first time, need to save lego mapping\n    legoId: uint256 = self.vaultToLegoId[_vaultToken]\n    if legoId == 0 and _legoId != 0:\n        self.vaultToLegoId[_vaultToken] = _legoId\n\n    # register asset (if necessary)\n    if self.indexOfAsset[_vaultToken] == 0:\n        self._registerYieldPosition(_vaultToken)\n\n\n# register yield position\n\n\n@internal\ndef _registerYieldPosition(_vaultToken: address):\n    aid: uint256 = self.numAssets\n    self.assets[aid] = _vaultToken\n    self.indexOfAsset[_vaultToken] = aid\n    self.numAssets = aid + 1\n\n\n# deregister yield position\n\n\n@internal\ndef _deregisterYieldPosition(_vaultToken: address) -> bool:\n    numAssets: uint256 = self.numAssets\n    if numAssets == 1:\n        return False\n\n    targetIndex: uint256 = self.indexOfAsset[_vaultToken]\n    if targetIndex == 0:\n        return False\n\n    # update data\n    lastIndex: uint256 = numAssets - 1\n    self.numAssets = lastIndex\n    self.indexOfAsset[_vaultToken] = 0\n\n    # get last item, replace the removed item\n    if targetIndex != lastIndex:\n        lastItem: address = self.assets[lastIndex]\n        self.assets[targetIndex] = lastItem\n        self.indexOfAsset[lastItem] = targetIndex\n\n    return True\n\n\n####################\n# Manager Settings #\n####################\n\n\n# can manage\n\n\n@internal\ndef _canManagerPerformAction(_signer: address, _legoIds: DynArray[uint256, MAX_LEGOS]) -> VaultActionData:\n    assert self.indexOfManager[_signer] != 0 # dev: not manager\n\n    # main data for this transaction - get action data and frozen status in single call\n    legoId: uint256 = 0\n    if len(_legoIds) != 0:\n        legoId = _legoIds[0]\n\n    vaultRegistry: address = self._getVaultRegistry()\n    ad: VaultActionData = empty(VaultActionData)\n    isVaultOpsFrozen: bool = False\n    ad, isVaultOpsFrozen = staticcall VaultRegistry(vaultRegistry).getVaultActionDataWithFrozenStatus(legoId, _signer, self)\n    ad.vaultAsset = VAULT_ASSET\n\n    # cannot perform any actions if vault is frozen\n    assert not isVaultOpsFrozen # dev: frozen vault\n\n    # make sure manager is not locked\n    assert not staticcall MissionControl(ad.missionControl).isLockedSigner(_signer) # dev: manager is locked\n\n    return ad\n\n\n# add manager\n\n\n@external\ndef addManager(_manager: address):\n    assert self._isSwitchboardAddr(msg.sender) # dev: no perms\n    self._registerManager(_manager)\n\n\n# register manager\n\n\n@internal\ndef _registerManager(_manager: address):\n    if self.indexOfManager[_manager] != 0:\n        return\n    mid: uint256 = self.numManagers\n    self.managers[mid] = _manager\n    self.indexOfManager[_manager] = mid\n    self.numManagers = mid + 1\n\n\n# remove manager\n\n\n@external\ndef removeManager(_manager: address):\n    assert self._isSwitchboardAddr(msg.sender) # dev: no perms\n\n    numManagers: uint256 = self.numManagers\n    if numManagers == 1:\n        return\n\n    targetIndex: uint256 = self.indexOfManager[_manager]\n    if targetIndex == 0:\n        return\n\n    # update data\n    lastIndex: uint256 = numManagers - 1\n    self.numManagers = lastIndex\n    self.indexOfManager[_manager] = 0\n\n    # get last item, replace the removed item\n    if targetIndex != lastIndex:\n        lastItem: address = self.managers[lastIndex]\n        self.managers[targetIndex] = lastItem\n        self.indexOfManager[lastItem] = targetIndex\n\n\n#############\n# Utilities #\n#############\n\n\n# get vault registry\n\n\n@view\n@internal\ndef _getVaultRegistry() -> address:\n    return staticcall Registry(UNDY_HQ).getAddr(VAULT_REGISTRY_ID)\n\n\n# is signer switchboard\n\n\n@view\n@internal\ndef _isSwitchboardAddr(_signer: address) -> bool:\n    switchboard: address = staticcall Registry(UNDY_HQ).getAddr(SWITCHBOARD_ID)\n    if switchboard == empty(address):\n        return False\n    return staticcall Switchboard(switchboard).isSwitchboardAddr(_signer)\n\n\n# approve\n\n\n@internal\ndef _getAmountAndApprove(_token: address, _amount: uint256, _legoAddr: address) -> uint256:\n    amount: uint256 = min(_amount, staticcall IERC20(_token).balanceOf(self))\n    assert amount != 0 # dev: no balance for _token\n    if _legoAddr != empty(address):\n        assert extcall IERC20(_token).approve(_legoAddr, amount, default_return_value = True) # dev: appr\n    return amount\n\n\n# lego access\n\n\n@internal\ndef _setLegoAccessForAction(_legoAddr: address, _action: ws.ActionType) -> bool:\n    if _legoAddr == empty(address):\n        return False\n\n    targetAddr: address = empty(address)\n    accessAbi: String[64] = empty(String[64])\n    numInputs: uint256 = 0\n    targetAddr, accessAbi, numInputs = staticcall Lego(_legoAddr).getAccessForLego(self, _action)\n\n    # nothing to do here\n    if targetAddr == empty(address):\n        return False\n\n    method_abi: bytes4 = convert(slice(keccak256(accessAbi), 0, 4), bytes4)\n    success: bool = False\n    response: Bytes[32] = b\"\"\n\n    # assumes input is: lego addr (operator)\n    if numInputs == 1:\n        success, response = raw_call(\n            targetAddr,\n            concat(\n                method_abi,\n                convert(_legoAddr, bytes32),\n            ),\n            revert_on_failure = False,\n            max_outsize = 32,\n        )\n    \n    # assumes input (and order) is: user (self), lego addr (operator)\n    elif numInputs == 2:\n        success, response = raw_call(\n            targetAddr,\n            concat(\n                method_abi,\n                convert(self, bytes32),\n                convert(_legoAddr, bytes32),\n            ),\n            revert_on_failure = False,\n            max_outsize = 32,\n        )\n\n    # assumes input (and order) is: user (self), lego addr (operator), allowed bool\n    elif numInputs == 3:\n        success, response = raw_call(\n            targetAddr,\n            concat(\n                method_abi,\n                convert(self, bytes32),\n                convert(_legoAddr, bytes32),\n                convert(True, bytes32),\n            ),\n            revert_on_failure = False,\n            max_outsize = 32,\n        )\n\n    assert success # dev: failed to set operator\n    return True\n\n\n# mini addys\n\n\n@view\n@internal\ndef _packMiniAddys(\n    _ledger: address,\n    _missionControl: address,\n    _legoBook: address,\n    _appraiser: address,\n) -> ws.MiniAddys:\n    return ws.MiniAddys(\n        ledger = _ledger,\n        missionControl = _missionControl,\n        legoBook = _legoBook,\n        appraiser = _appraiser,\n    )\n\n",
            "sha256sum": "61caf19a6d25ffd6794d5c80690611d91e9217c514154dd9cf284df5f0f8e24d"
          },
          "contracts/vaults/EarnVault.vy": {
            "content": "#    ________   __  __   _________  ______   ______   ________  __       ______   _________  \n#   /_______/\\ /_/\\/_/\\ /________/\\/_____/\\ /_____/\\ /_______/\\/_/\\     /_____/\\ /________/\\ \n#   \\::: _  \\ \\\\:\\ \\:\\ \\\\__.::.__\\/\\:::_ \\ \\\\:::_ \\ \\\\__.::._\\/\\:\\ \\    \\:::_ \\ \\\\__.::.__\\/ \n#    \\::(_)  \\ \\\\:\\ \\:\\ \\  \\::\\ \\   \\:\\ \\ \\ \\\\:(_) \\ \\  \\::\\ \\  \\:\\ \\    \\:\\ \\ \\ \\  \\::\\ \\   \n#     \\:: __  \\ \\\\:\\ \\:\\ \\  \\::\\ \\   \\:\\ \\ \\ \\\\: ___\\/  _\\::\\ \\__\\:\\ \\____\\:\\ \\ \\ \\  \\::\\ \\  \n#      \\:.\\ \\  \\ \\\\:\\_\\:\\ \\  \\::\\ \\   \\:\\_\\ \\ \\\\ \\ \\   /__\\::\\__/\\\\:\\/___/\\\\:\\_\\ \\ \\  \\::\\ \\ \n#       \\__\\/\\__\\/ \\_____\\/   \\__\\/    \\_____\\/ \\_\\/   \\________\\/ \\_____\\/ \\_____\\/   \\__\\/ \n#                                                                       \n#     \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n#     \u2551  ** Earn Autopilot Vaults **                                         \u2551\n#     \u2551  Managed by AI agents, enforced by onchain rules. Erc4626 compliant. \u2551\n#     \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n#\n#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nimplements: IERC4626\nimplements: IERC20\n\nexports: token.__interface__\ninitializes: token\nfrom contracts.vaults.modules import VaultErc20Token as token\n\nexports: vaultWallet.__interface__\ninitializes: vaultWallet\nfrom contracts.vaults.modules import EarnVaultWallet as vaultWallet\n\nfrom ethereum.ercs import IERC4626\nfrom ethereum.ercs import IERC20\nfrom ethereum.ercs import IERC20Detailed\n\ninterface VaultRegistry:\n    def getDepositConfig(_vaultAddr: address) -> (bool, uint256, bool, address): view\n    def canWithdraw(_vaultAddr: address) -> bool: view\n\nevent Deposit:\n    sender: indexed(address)\n    owner: indexed(address)\n    assets: uint256\n    shares: uint256\n\nevent Withdraw:\n    sender: indexed(address)\n    receiver: indexed(address)\n    owner: indexed(address)\n    assets: uint256\n    shares: uint256\n\nHUNDRED_PERCENT: constant(uint256) = 100_00 # 100.00%\n\n\n@deploy\ndef __init__(\n    _asset: address,\n    _tokenName: String[64],\n    _tokenSymbol: String[32],\n    _undyHq: address,\n    _minHqTimeLock: uint256,\n    _maxHqTimeLock: uint256,\n    _startingAgent: address,\n):\n    token.__init__(_tokenName, _tokenSymbol, staticcall IERC20Detailed(_asset).decimals(), _undyHq)\n    vaultWallet.__init__(_undyHq, _asset, _startingAgent)\n\n\n@view\n@external\ndef asset() -> address:\n    return vaultWallet.VAULT_ASSET\n\n\n@view\n@external\ndef totalAssets() -> uint256:\n    return self._getTotalAssets(True)\n\n\n################\n# Total Assets #\n################\n\n\n@view\n@external\ndef getTotalAssets(_shouldGetMax: bool) -> uint256:\n    return self._getTotalAssets(_shouldGetMax)\n\n\n@view\n@internal\ndef _getTotalAssets(_shouldGetMax: bool, _vaultRegistry: address = empty(address)) -> uint256:\n    vaultRegistry: address = _vaultRegistry\n    if vaultRegistry == empty(address):\n        vaultRegistry = vaultWallet._getVaultRegistry()\n    return self._getUnderlyingData(_shouldGetMax, vaultRegistry)[0]\n\n\n@view\n@internal\ndef _getUnderlyingData(_shouldGetMax: bool, _vaultRegistry: address) -> (uint256, uint256, uint256, address):\n    totalAssets: uint256 = staticcall IERC20(vaultWallet.VAULT_ASSET).balanceOf(self)\n\n    # all underlying assets\n    maxTotalAssets: uint256 = 0\n    safeTotalAssets: uint256 = 0\n    maxBalVaultToken: address = empty(address)\n    maxTotalAssets, safeTotalAssets, maxBalVaultToken = vaultWallet._getUnderlyingYieldBalances()\n\n    # new yield\n    currentBalance: uint256 = 0\n    newYield: uint256 = 0\n    currentBalance, newYield = vaultWallet._calcNewYieldAndGetUnderlying(maxTotalAssets)\n\n    # pending fees\n    pendingYieldRealized: uint256 = vaultWallet.pendingYieldRealized + newYield\n    pendingFees: uint256 = pendingYieldRealized * vaultWallet._getPerformanceFeeRatio(_vaultRegistry) // HUNDRED_PERCENT\n\n    # add total assets\n    if _shouldGetMax:\n        totalAssets += maxTotalAssets\n    else:\n        totalAssets += safeTotalAssets\n    totalAssets -= min(pendingFees, totalAssets)\n\n    return totalAssets, currentBalance, pendingYieldRealized, maxBalVaultToken\n\n\n############\n# Deposits #\n############\n\n\n@view\n@external\ndef maxDeposit(_receiver: address) -> uint256:\n    vaultRegistry: address = vaultWallet._getVaultRegistry()\n\n    # deposit config\n    canDeposit: bool = False\n    maxDepositAmount: uint256 = 0\n    na1: bool = False\n    na2: address = empty(address)\n    canDeposit, maxDepositAmount, na1, na2 = staticcall VaultRegistry(vaultRegistry).getDepositConfig(self)\n\n    if not canDeposit:\n        return 0\n\n    if maxDepositAmount == 0:\n        return max_value(uint256)\n\n    totalAssets: uint256 = self._getTotalAssets(True, vaultRegistry)\n    if totalAssets >= maxDepositAmount:\n        return 0\n\n    return maxDepositAmount - totalAssets\n\n\n@view\n@external\ndef previewDeposit(_assets: uint256) -> uint256:\n    return self._amountToShares(_assets, token.totalSupply, self._getTotalAssets(True), False)\n\n\n@nonreentrant\n@external\ndef deposit(_assets: uint256, _receiver: address = msg.sender) -> uint256:\n    return self._deposit(_assets, _receiver, 0)\n\n\n@nonreentrant\n@external\ndef depositWithMinAmountOut(_assets: uint256, _minAmountOut: uint256, _receiver: address = msg.sender) -> uint256:\n    return self._deposit(_assets, _receiver, _minAmountOut)\n\n\n@internal\ndef _deposit(_assets: uint256, _receiver: address, _minAmountOut: uint256) -> uint256:\n    vaultRegistry: address = vaultWallet._getVaultRegistry()\n    asset: address = vaultWallet.VAULT_ASSET\n\n    amount: uint256 = _assets\n    if amount == max_value(uint256):\n        amount = staticcall IERC20(asset).balanceOf(msg.sender)\n\n    # underlying data\n    totalAssets: uint256 = 0\n    currentBalance: uint256 = 0\n    pendingYieldRealized: uint256 = 0\n    maxBalVaultToken: address = empty(address)\n    totalAssets, currentBalance, pendingYieldRealized, maxBalVaultToken = self._getUnderlyingData(True, vaultRegistry)\n\n    shares: uint256 = self._amountToShares(amount, token.totalSupply, totalAssets, False)\n    if _minAmountOut != 0:\n        assert shares >= _minAmountOut # dev: insufficient shares\n\n    self._depositIntoVault(asset, amount, shares, _receiver, totalAssets, currentBalance, pendingYieldRealized, maxBalVaultToken, vaultRegistry)\n    return shares\n\n\n# mint\n\n\n@view\n@external\ndef maxMint(_receiver: address) -> uint256:\n    vaultRegistry: address = vaultWallet._getVaultRegistry()\n\n    # deposit config\n    canDeposit: bool = False\n    maxDepositAmount: uint256 = 0\n    na1: bool = False\n    na2: address = empty(address)\n    canDeposit, maxDepositAmount, na1, na2 = staticcall VaultRegistry(vaultRegistry).getDepositConfig(self)\n\n    if not canDeposit:\n        return 0\n\n    if maxDepositAmount == 0:\n        return max_value(uint256)\n\n    totalAssets: uint256 = self._getTotalAssets(True, vaultRegistry)\n    if totalAssets >= maxDepositAmount:\n        return 0\n\n    maxDepositAmt: uint256 = maxDepositAmount - totalAssets\n    return self._amountToShares(maxDepositAmt, token.totalSupply, totalAssets, False)\n\n\n@view\n@external\ndef previewMint(_shares: uint256) -> uint256:\n    return self._sharesToAmount(_shares, token.totalSupply, self._getTotalAssets(True), True)\n\n\n@nonreentrant\n@external\ndef mint(_shares: uint256, _receiver: address = msg.sender) -> uint256:\n    vaultRegistry: address = vaultWallet._getVaultRegistry()\n\n    # underlying data\n    totalAssets: uint256 = 0\n    currentBalance: uint256 = 0\n    pendingYieldRealized: uint256 = 0\n    maxBalVaultToken: address = empty(address)\n    totalAssets, currentBalance, pendingYieldRealized, maxBalVaultToken = self._getUnderlyingData(True, vaultRegistry)\n\n    amount: uint256 = self._sharesToAmount(_shares, token.totalSupply, totalAssets, True)\n    self._depositIntoVault(vaultWallet.VAULT_ASSET, amount, _shares, _receiver, totalAssets, currentBalance, pendingYieldRealized, maxBalVaultToken, vaultRegistry)\n    return amount\n\n\n# shared deposit logic\n\n\n@internal\ndef _depositIntoVault(\n    _asset: address,\n    _amount: uint256,\n    _shares: uint256,\n    _recipient: address,\n    _totalAssets: uint256,\n    _currentBalance: uint256,\n    _pendingYieldRealized: uint256,\n    _maxBalVaultToken: address,\n    _vaultRegistry: address,\n):\n    # get all deposit config\n    canDeposit: bool = False\n    maxDepositAmount: uint256 = 0\n    shouldAutoDeposit: bool = False\n    defaultTargetVaultToken: address = empty(address)\n    canDeposit, maxDepositAmount, shouldAutoDeposit, defaultTargetVaultToken = staticcall VaultRegistry(_vaultRegistry).getDepositConfig(self)\n\n    assert canDeposit # dev: cannot deposit\n    assert _amount != 0 # dev: cannot deposit 0 amount\n    assert _shares != 0 # dev: cannot receive 0 shares\n    assert _recipient != empty(address) # dev: invalid recipient\n    if maxDepositAmount != 0:\n        assert _totalAssets + _amount <= maxDepositAmount # dev: exceeds max deposit\n\n    # transfer assets to vault\n    assert extcall IERC20(_asset).transferFrom(msg.sender, self, _amount, default_return_value=True) # dev: deposit failed\n\n    # put the deposit to work -- start earning\n    amountDeposited: uint256 = 0\n    if shouldAutoDeposit:\n        targetVaultToken: address = defaultTargetVaultToken\n        if targetVaultToken == empty(address):\n            targetVaultToken = _maxBalVaultToken\n        amountDeposited = vaultWallet._onReceiveVaultFunds(targetVaultToken, _recipient, _vaultRegistry)\n\n    # save data\n    currentBalance: uint256 = _currentBalance + amountDeposited\n    vaultWallet.lastUnderlyingBal = currentBalance\n    vaultWallet.pendingYieldRealized = _pendingYieldRealized\n\n    token._mint(_recipient, _shares)\n    log Deposit(sender=msg.sender, owner=_recipient, assets=_amount, shares=_shares)\n\n\n###############\n# Withdrawals #\n###############\n\n\n@view\n@external\ndef maxWithdraw(_owner: address) -> uint256:\n    ownerShares: uint256 = token.balanceOf[_owner]\n    if ownerShares == 0:\n        return 0\n    availableAssets: uint256 = self._getTotalAssets(False)\n    ownerAssets: uint256 = self._sharesToAmount(ownerShares, token.totalSupply, availableAssets, False)\n    return min(ownerAssets, availableAssets)\n\n\n@view\n@external\ndef previewWithdraw(_assets: uint256) -> uint256:\n    return self._amountToShares(_assets, token.totalSupply, self._getTotalAssets(False), True)\n\n\n@nonreentrant\n@external\ndef withdraw(_assets: uint256, _receiver: address = msg.sender, _owner: address = msg.sender) -> uint256:\n    vaultRegistry: address = vaultWallet._getVaultRegistry()\n\n    # underlying data\n    totalAssets: uint256 = 0\n    currentBalance: uint256 = 0\n    pendingYieldRealized: uint256 = 0\n    maxBalVaultToken: address = empty(address)\n    totalAssets, currentBalance, pendingYieldRealized, maxBalVaultToken = self._getUnderlyingData(False, vaultRegistry)\n\n    shares: uint256 = self._amountToShares(_assets, token.totalSupply, totalAssets, True)\n    self._redeemFromVault(vaultWallet.VAULT_ASSET, _assets, 0, shares, msg.sender, _receiver, _owner, currentBalance, pendingYieldRealized, maxBalVaultToken, vaultRegistry)\n    return shares\n\n\n# redeem\n\n\n@view\n@external\ndef maxRedeem(_owner: address) -> uint256:\n    return token.balanceOf[_owner]\n\n\n@view\n@external\ndef previewRedeem(_shares: uint256) -> uint256:\n    return self._sharesToAmount(_shares, token.totalSupply, self._getTotalAssets(False), False)\n\n\n@nonreentrant\n@external\ndef redeem(_shares: uint256, _receiver: address = msg.sender, _owner: address = msg.sender) -> uint256:\n    return self._redeem(_shares, msg.sender, _receiver, _owner, 0)\n\n\n@nonreentrant\n@external\ndef redeemWithMinAmountOut(_shares: uint256, _minAmountOut: uint256, _receiver: address = msg.sender, _owner: address = msg.sender) -> uint256:\n    return self._redeem(_shares, msg.sender, _receiver, _owner, _minAmountOut)\n\n\n@internal\ndef _redeem(_shares: uint256, _sender: address, _receiver: address, _owner: address, _minAmountOut: uint256) -> uint256:\n    vaultRegistry: address = vaultWallet._getVaultRegistry()\n\n    shares: uint256 = _shares\n    if shares == max_value(uint256):\n        shares = token.balanceOf[_owner]\n\n    # underlying data\n    totalAssets: uint256 = 0\n    currentBalance: uint256 = 0\n    pendingYieldRealized: uint256 = 0\n    maxBalVaultToken: address = empty(address)\n    totalAssets, currentBalance, pendingYieldRealized, maxBalVaultToken = self._getUnderlyingData(False, vaultRegistry)\n\n    amount: uint256 = self._sharesToAmount(shares, token.totalSupply, totalAssets, False)\n    return self._redeemFromVault(vaultWallet.VAULT_ASSET, amount, _minAmountOut, shares, _sender, _receiver, _owner, currentBalance, pendingYieldRealized, maxBalVaultToken, vaultRegistry)\n\n\n# shared redeem logic\n\n\n@internal\ndef _redeemFromVault(\n    _asset: address,\n    _amount: uint256,\n    _minAmountOut: uint256,\n    _shares: uint256,\n    _sender: address,\n    _recipient: address,\n    _owner: address,\n    _currentBalance: uint256,\n    _pendingYieldRealized: uint256,\n    _maxBalVaultToken: address,\n    _vaultRegistry: address,\n) -> uint256:\n    assert staticcall VaultRegistry(_vaultRegistry).canWithdraw(self) # dev: cannot withdraw\n\n    assert _amount != 0 # dev: cannot withdraw 0 amount\n    assert _shares != 0 # dev: cannot redeem 0 shares\n    assert _recipient != empty(address) # dev: invalid recipient\n\n    assert token.balanceOf[_owner] >= _shares # dev: insufficient shares\n\n    if _sender != _owner:\n        token._spendAllowance(_owner, _sender, _shares)\n\n    # withdraw from yield opportunity\n    availAmount: uint256 = 0\n    withdrawnAmount: uint256 = 0\n    availAmount, withdrawnAmount = vaultWallet._prepareRedemption(_asset, _amount, _maxBalVaultToken, _sender, _vaultRegistry)\n    actualAmount: uint256 = min(availAmount, _amount)\n\n    # check amount out\n    if _minAmountOut != 0:\n        assert actualAmount >= _minAmountOut # dev: insufficient amount out\n    else:\n        assert self._isRedemptionCloseEnough(_amount, actualAmount) # dev: insufficient funds\n\n    # save data\n    currentBalance: uint256 = _currentBalance - min(_currentBalance, withdrawnAmount)\n    vaultWallet.lastUnderlyingBal = currentBalance\n    vaultWallet.pendingYieldRealized = _pendingYieldRealized\n\n    # burn shares, transfer assets\n    token._burn(_owner, _shares)\n    assert extcall IERC20(_asset).transfer(_recipient, actualAmount, default_return_value=True) # dev: withdrawal failed\n\n    log Withdraw(sender=_sender, receiver=_recipient, owner=_owner, assets=actualAmount, shares=_shares)\n    return actualAmount\n\n\n@pure\n@internal\ndef _isRedemptionCloseEnough(_requestedAmount: uint256, _actualAmount: uint256) -> bool:\n    # extra check to make sure what was sent was actually close-ish to what was requested\n    buffer: uint256 = _requestedAmount * 10 // HUNDRED_PERCENT # 0.1%\n    lowerBound: uint256 = _requestedAmount - buffer\n    return _actualAmount >= lowerBound\n\n\n##########\n# Shares #\n##########\n\n\n@view\n@external\ndef convertToShares(_assets: uint256) -> uint256:\n    return self._amountToShares(_assets, token.totalSupply, self._getTotalAssets(True), False)\n\n\n@view\n@external\ndef convertToSharesSafe(_assets: uint256) -> uint256:\n    return self._amountToShares(_assets, token.totalSupply, self._getTotalAssets(False), False)\n\n\n@view\n@external\ndef convertToAssets(_shares: uint256) -> uint256:\n    return self._sharesToAmount(_shares, token.totalSupply, self._getTotalAssets(True), False)\n\n\n@view\n@external\ndef convertToAssetsSafe(_shares: uint256) -> uint256:\n    return self._sharesToAmount(_shares, token.totalSupply, self._getTotalAssets(False), False)\n\n\n# amount -> shares\n\n\n@view\n@internal\ndef _amountToShares(\n    _amount: uint256,\n    _totalShares: uint256,\n    _totalBalance: uint256,\n    _shouldRoundUp: bool,\n) -> uint256:\n    if _amount == max_value(uint256) or _amount == 0:\n        return _amount\n\n    # first deposit, price per share = 1\n    if _totalShares == 0:\n        return _amount\n\n    # no underlying balance, price per share = 0\n    if _totalBalance == 0:\n        return 0\n\n    # calc shares\n    numerator: uint256 = _amount * _totalShares\n    shares: uint256 = numerator // _totalBalance\n\n    # rounding\n    if _shouldRoundUp and (numerator % _totalBalance != 0):\n        shares += 1\n\n    return shares\n\n\n# shares -> amount\n\n\n@view\n@internal\ndef _sharesToAmount(\n    _shares: uint256,\n    _totalShares: uint256,\n    _totalBalance: uint256,\n    _shouldRoundUp: bool,\n) -> uint256:\n    if _shares == max_value(uint256) or _shares == 0:\n        return _shares\n\n    # first deposit, price per share = 1\n    if _totalShares == 0:\n        return _shares\n\n    # calc amount\n    numerator: uint256 = _shares * _totalBalance\n    amount: uint256 = numerator // _totalShares\n\n    # rounding\n    if _shouldRoundUp and (numerator % _totalShares != 0):\n        amount += 1\n\n    return amount\n",
            "sha256sum": "4404360a1443d0d8fc4f990e19f2bcc78413322ddd906e276df625cc8181273e"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/vaults/EarnVault.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.3+commit.bff19ea2",
        "integrity": "c6fdf6e04d79c8f1adfe0287effde9a98c581054dad097e446fe37d03bbcfc1e"
      },
      "args": "0000000000000000000000006bb7a212910682dcfdbd5bcbb3e28fb4e8da10ee00000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000012000000000000000000000000044cf3c4f000dfd76a35d03298049d37be688d6f90000000000000000000000000000000000000000000000000000000000000e10000000000000000000000000000000000000000000000000000000000013c6800000000000000000000000009d3f593380875860cc18f5736373ae4b084ba2f90000000000000000000000000000000000000000000000000000000000000018556e64657273636f726520426c756520436869702047484f00000000000000000000000000000000000000000000000000000000000000000000000000000007756e647947484f00000000000000000000000000000000000000000000000000",
      "file": "contracts/vaults/EarnVault.vy"
    }
  }
}