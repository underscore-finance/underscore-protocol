{
  "contracts": {
    "RipeLego": {
      "address": "0x797002ed44B655084483398a55e78E669a96d626",
      "abi": [
        {
          "name": "RipeCollateralDeposit",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountDeposited",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultIdOrLock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "RipeCollateralWithdrawal",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "RipeBorrow",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountBorrowed",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "RipeRepay",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountRepaid",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "RipeClaimRewards",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "ripeClaimed",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "RipeSavingsGreenDeposit",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountDeposited",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultTokenAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "RipeSavingsGreenWithdrawal",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultTokenAmountBurned",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LegoPauseModified",
          "inputs": [
            {
              "name": "isPaused",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LegoFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "balance",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "SnapShotPriceConfigSet",
          "inputs": [
            {
              "name": "minSnapshotDelay",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "maxNumSnapshots",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "maxUpsideDeviation",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "staleTime",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetOpportunityAdded",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultAddr",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetOpportunityRemoved",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultAddr",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PricePerShareSnapShotAdded",
          "inputs": [
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "totalSupply",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "pricePerShare",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddys",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "undyToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "hatchery",
                  "type": "address"
                },
                {
                  "name": "lootDistributor",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                },
                {
                  "name": "walletBackpack",
                  "type": "address"
                },
                {
                  "name": "billing",
                  "type": "address"
                },
                {
                  "name": "vaultRegistry",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUndyHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isLegoAsset",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssetOpportunities",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isAssetOpportunity",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getNumLegoAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pause",
          "inputs": [
            {
              "name": "_shouldPause",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFundsMany",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_assets",
              "type": "address[]"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getWeightedPricePerShare",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLatestSnapshot",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_pricePerShare",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "totalSupply",
                  "type": "uint256"
                },
                {
                  "name": "pricePerShare",
                  "type": "uint256"
                },
                {
                  "name": "lastUpdate",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setSnapShotPriceConfig",
          "inputs": [
            {
              "name": "_config",
              "type": "tuple",
              "components": [
                {
                  "name": "minSnapshotDelay",
                  "type": "uint256"
                },
                {
                  "name": "maxNumSnapshots",
                  "type": "uint256"
                },
                {
                  "name": "maxUpsideDeviation",
                  "type": "uint256"
                },
                {
                  "name": "staleTime",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidPriceConfig",
          "inputs": [
            {
              "name": "_config",
              "type": "tuple",
              "components": [
                {
                  "name": "minSnapshotDelay",
                  "type": "uint256"
                },
                {
                  "name": "maxNumSnapshots",
                  "type": "uint256"
                },
                {
                  "name": "maxUpsideDeviation",
                  "type": "uint256"
                },
                {
                  "name": "staleTime",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "vaultToAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "underlyingAsset",
                  "type": "address"
                },
                {
                  "name": "decimals",
                  "type": "uint256"
                },
                {
                  "name": "lastAveragePricePerShare",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assetOpportunities",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAssetOpportunity",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssetOpportunities",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assets",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "snapShotData",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "lastSnapShot",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "totalSupply",
                      "type": "uint256"
                    },
                    {
                      "name": "pricePerShare",
                      "type": "uint256"
                    },
                    {
                      "name": "lastUpdate",
                      "type": "uint256"
                    }
                  ]
                },
                {
                  "name": "nextIndex",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "snapShots",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "totalSupply",
                  "type": "uint256"
                },
                {
                  "name": "pricePerShare",
                  "type": "uint256"
                },
                {
                  "name": "lastUpdate",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "snapShotPriceConfig",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "minSnapshotDelay",
                  "type": "uint256"
                },
                {
                  "name": "maxNumSnapshots",
                  "type": "uint256"
                },
                {
                  "name": "maxUpsideDeviation",
                  "type": "uint256"
                },
                {
                  "name": "staleTime",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isPaused",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasCapability",
          "inputs": [
            {
              "name": "_action",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRegistries",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isYieldLego",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isDexLego",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAsset",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingBalances",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenBalance",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAmount",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAmountSafe",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenBalance",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingData",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingData",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            },
            {
              "name": "_appraiser",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValueOfVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValueOfVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            },
            {
              "name": "_appraiser",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isRebasing",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPricePerShare",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPricePerShare",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_decimals",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getVaultTokenAmount",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_assetAmount",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isEligibleVaultForTrialFunds",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_underlyingAsset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isEligibleForYieldBonus",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalAssets",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalBorrows",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canRegisterVaultToken",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "registerVaultTokenLocally",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "underlyingAsset",
                  "type": "address"
                },
                {
                  "name": "decimals",
                  "type": "uint256"
                },
                {
                  "name": "lastAveragePricePerShare",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "deregisterVaultTokenLocally",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addPriceSnapshot",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositForYield",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositForYield",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawFromYield",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawFromYield",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_borrowAsset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_borrowAsset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_paymentAsset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_paymentAsset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasClaimableRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAccessForLego",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_action",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "string"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_tokenPath",
              "type": "address[]"
            },
            {
              "name": "_poolPath",
              "type": "address[]"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_tokenPath",
              "type": "address[]"
            },
            {
              "name": "_poolPath",
              "type": "address[]"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_tokenInAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_tokenInAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmMintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmMintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "RIPE_REGISTRY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "RIPE_GREEN_TOKEN",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "RIPE_SAVINGS_GREEN",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "RIPE_TOKEN",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_undyHq",
              "type": "address"
            },
            {
              "name": "_ripeRegistry",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "interfaces/WalletStructs.vyi": {
            "content": "# @version 0.4.3\n\nflag ActionType:\n    TRANSFER\n    EARN_DEPOSIT\n    EARN_WITHDRAW\n    EARN_REBALANCE\n    SWAP\n    MINT_REDEEM\n    CONFIRM_MINT_REDEEM\n    ADD_COLLATERAL\n    REMOVE_COLLATERAL\n    BORROW\n    REPAY_DEBT\n    REWARDS\n    ETH_TO_WETH\n    WETH_TO_ETH\n    ADD_LIQ\n    REMOVE_LIQ\n    ADD_LIQ_CONC\n    REMOVE_LIQ_CONC\n    PAY_CHEQUE\n\nstruct WalletAssetData:\n    assetBalance: uint256\n    usdValue: uint256\n    isYieldAsset: bool\n    lastPricePerShare: uint256\n\nstruct ActionData:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    billing: address\n    wallet: address\n    walletConfig: address\n    walletOwner: address\n    inEjectMode: bool\n    isFrozen: bool\n    lastTotalUsdValue: uint256\n    signer: address\n    isManager: bool\n    legoId: uint256\n    legoAddr: address\n    eth: address\n    weth: address\n\nstruct MiniAddys:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    appraiser: address",
            "sha256sum": "9a4b4f59b3a62043e51b425a665064aae419a3c0bd0514b6b29a9441ae364bb9"
          },
          "interfaces/LegoPartner.vyi": {
            "content": "# @version 0.4.3\n\nfrom interfaces import WalletStructs as ws\n\nMAX_TOKEN_PATH: constant(uint256) = 5\nMAX_RECOVER_ASSETS: constant(uint256) = 20\n\n@external\ndef addLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _tickLower: int24, _tickUpper: int24, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef addLiquidity(_pool: address, _tokenA: address, _tokenB: address, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _minLpAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (address, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef removeLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _liqToRemove: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef removeLiquidity(_pool: address, _tokenA: address, _tokenB: address, _lpToken: address, _lpAmount: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef mintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _tokenInAmount: uint256, _minAmountOut: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef swapTokens(_amountIn: uint256, _minAmountOut: uint256, _tokenPath: DynArray[address, MAX_TOKEN_PATH], _poolPath: DynArray[address, MAX_TOKEN_PATH - 1], _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256):\n    ...\n\n@external\ndef depositForYield(_asset: address, _amount: uint256, _vaultAddr: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef withdrawFromYield(_vaultToken: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef confirmMintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef borrow(_borrowAsset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef repayDebt(_paymentAsset: address, _paymentAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef claimRewards(_user: address, _rewardToken: address, _rewardAmount: uint256, _extraData: bytes32, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef removeCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef addCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@view\n@external\ndef getAccessForLego(_user: address, _action: ws.ActionType) -> (address, String[64], uint256):\n    ...\n\n@view\n@external\ndef hasCapability(_action: ws.ActionType) -> bool:\n    ...\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    ...\n\n@view\n@external\ndef isYieldLego() -> bool:\n    ...\n\n@view\n@external\ndef isDexLego() -> bool:\n    ...\n\n\n# common\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "81db71fe4440a3b4b563134c9b5caf1d5705772a5f291fe874c9b5fb3cfb1623"
          },
          "interfaces/LegoStructs.vyi": {
            "content": "# @version 0.4.3\n\nstruct VaultTokenInfo:\n    underlyingAsset: address\n    decimals: uint256\n    lastAveragePricePerShare: uint256\n\nstruct SnapShotPriceConfig:\n    minSnapshotDelay: uint256\n    maxNumSnapshots: uint256\n    maxUpsideDeviation: uint256\n    staleTime: uint256\n\nstruct SingleSnapShot:\n    totalSupply: uint256\n    pricePerShare: uint256\n    lastUpdate: uint256\n\nstruct SnapShotData:\n    lastSnapShot: SingleSnapShot\n    nextIndex: uint256\n",
            "sha256sum": "8ae48be17d812d57fbd671bbf0593e8abf175ad0924e47c5997823cac19ec806"
          },
          "interfaces/YieldLego.vyi": {
            "content": "# @version 0.4.3\n\nfrom interfaces import LegoStructs as ls\n\n\n###################\n# Underlying Data #\n###################\n\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    ...\n\n\n@view\n@external\ndef getUnderlyingBalances(_vaultToken: address, _vaultTokenBalance: uint256) -> (uint256, uint256):\n    ...\n\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    ...\n\n\n@view\n@external\ndef getUnderlyingAmountSafe(_vaultToken: address, _vaultTokenBalance: uint256) -> uint256:\n    ...\n\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> (address, uint256, uint256):\n    ...\n\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> uint256:\n    ...\n\n\n###############\n# Other Utils #\n###############\n\n\n@view\n@external\ndef isRebasing() -> bool:\n    ...\n\n\n@view\n@external\ndef getPricePerShare(_vaultToken: address, _decimals: uint256 = 0) -> uint256:\n    ...\n\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef canRegisterVaultToken(_asset: address, _vaultToken: address) -> bool:\n    ...\n\n\n@view\n@external\ndef isEligibleVaultForTrialFunds(_vaultToken: address, _underlyingAsset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef isEligibleForYieldBonus(_asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    ...\n\n\n###################\n# Yield Lego Data #\n###################\n\n\n@view\n@external\ndef isLegoAsset(_asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, 40]:\n    ...\n\n\n@view\n@external\ndef getAssets() -> DynArray[address, 20]:\n    ...\n\n\n@view\n@external\ndef isAssetOpportunity(_asset: address, _vaultAddr: address) -> bool:\n    ...\n\n\n@view\n@external\ndef getNumLegoAssets() -> uint256:\n    ...\n\n\n@view\n@external\ndef assets(_index: uint256) -> address:\n    ...\n\n\n@view\n@external\ndef indexOfAsset(_asset: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef numAssets() -> uint256:\n    ...\n\n\n@view\n@external\ndef assetOpportunities(_asset: address, _index: uint256) -> address:\n    ...\n\n\n@view\n@external\ndef indexOfAssetOpportunity(_asset: address, _vaultAddr: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef numAssetOpportunities(_asset: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef vaultToAsset(_vaultAddr: address) -> ls.VaultTokenInfo:\n    ...\n\n\n# price snapshots\n\n\n@external\ndef addPriceSnapshot(_vaultToken: address) -> bool:\n    ...\n\n\n@view\n@external\ndef snapShotPriceConfig() -> ls.SnapShotPriceConfig:\n    ...\n\n\n@view\n@external\ndef snapShotData(_vaultToken: address) -> ls.SnapShotData:\n    ...\n\n\n@view\n@external\ndef snapShots(_vaultToken: address, _index: uint256) -> ls.SingleSnapShot:\n    ...\n\n\n@view\n@external\ndef getWeightedPricePerShare(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef getLatestSnapshot(_vaultToken: address, _pricePerShare: uint256) -> ls.SingleSnapShot:\n    ...\n\n\n@external\ndef setSnapShotPriceConfig(_config: ls.SnapShotPriceConfig):\n    ...\n",
            "sha256sum": "045a6bbd3d556234cf4fe925a303002dc0ac3c482d344ffbaf4bc52a7e6ad2df"
          },
          "contracts/modules/Addys.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\ninterface UndyHq:\n    def isValidAddr(_addr: address) -> bool: view\n    def getAddr(_regId: uint256) -> address: view\n    def undyToken() -> address: view\n\ninterface Switchboard:\n    def isSwitchboardAddr(_addr: address) -> bool: view\n\ninterface LegoBook:\n    def isLegoAddr(_addr: address) -> bool: view\n\nstruct Addys:\n    hq: address\n    undyToken: address\n    ledger: address\n    missionControl: address\n    legoBook: address\n    switchboard: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    walletBackpack: address\n    billing: address\n    vaultRegistry: address\n\n# hq\nUNDY_HQ_FOR_ADDYS: immutable(address)\n\n# core addys\nLEDGER_ID: constant(uint256) = 1\nMISSION_CONTROL_ID: constant(uint256) = 2\nLEGO_BOOK_ID: constant(uint256) = 3\nSWITCHBOARD_ID: constant(uint256) = 4\nHATCHERY_ID: constant(uint256) = 5\nLOOT_DISTRIBUTOR_ID: constant(uint256) = 6\nAPPRAISER_ID: constant(uint256) = 7\nWALLET_BACKPACK_ID: constant(uint256) = 8\nBILLING_ID: constant(uint256) = 9\nVAULT_REGISTRY_ID: constant(uint256) = 10\n\n\n@deploy\ndef __init__(_undyHq: address):\n    assert _undyHq != empty(address) # dev: invalid undy hq\n    UNDY_HQ_FOR_ADDYS = _undyHq\n\n\n########\n# Core #\n########\n\n\n@view\n@external\ndef getAddys() -> Addys:\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _getAddys(_addys: Addys = empty(Addys)) -> Addys:\n    if _addys.hq != empty(address):\n        return _addys\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _generateAddys() -> Addys:\n    hq: address = UNDY_HQ_FOR_ADDYS\n    return Addys(\n        hq = hq,\n        undyToken = staticcall UndyHq(hq).undyToken(),\n        ledger = staticcall UndyHq(hq).getAddr(LEDGER_ID),\n        missionControl = staticcall UndyHq(hq).getAddr(MISSION_CONTROL_ID),\n        legoBook = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID),\n        switchboard = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID),\n        hatchery = staticcall UndyHq(hq).getAddr(HATCHERY_ID),\n        lootDistributor = staticcall UndyHq(hq).getAddr(LOOT_DISTRIBUTOR_ID),\n        appraiser = staticcall UndyHq(hq).getAddr(APPRAISER_ID),\n        walletBackpack = staticcall UndyHq(hq).getAddr(WALLET_BACKPACK_ID),\n        billing = staticcall UndyHq(hq).getAddr(BILLING_ID),\n        vaultRegistry = staticcall UndyHq(hq).getAddr(VAULT_REGISTRY_ID),\n    )\n\n\n##########\n# Tokens #\n##########\n\n\n@view\n@internal\ndef _getUndyToken() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).undyToken()\n\n\n###########\n# Helpers #\n###########\n\n\n# undy hq\n\n\n@view\n@external\ndef getUndyHq() -> address:\n    return self._getUndyHq()\n\n\n@view\n@internal\ndef _getUndyHq() -> address:\n    return UNDY_HQ_FOR_ADDYS\n\n\n# utils\n\n\n@view\n@internal\ndef _isValidUndyAddr(_addr: address, _hq: address = empty(address)) -> bool:\n    hq: address = _hq\n    if _hq == empty(address):\n        hq = UNDY_HQ_FOR_ADDYS\n    \n    # core departments\n    if staticcall UndyHq(hq).isValidAddr(_addr):\n        return True\n\n    # lego book\n    legoBook: address = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID)\n    if legoBook != empty(address) and staticcall LegoBook(legoBook).isLegoAddr(_addr):\n        return True\n\n    # switchboard config\n    switchboard: address = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID)\n    if switchboard != empty(address) and staticcall Switchboard(switchboard).isSwitchboardAddr(_addr):\n        return True\n\n    return False\n\n\n@view\n@internal\ndef _isSwitchboardAddr(_addr: address) -> bool:\n    switchboard: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n    if switchboard == empty(address):\n        return False\n    return staticcall Switchboard(switchboard).isSwitchboardAddr(_addr)\n\n\n@view\n@internal\ndef _isLegoBookAddr(_addr: address) -> bool:\n    legoBook: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n    if legoBook == empty(address):\n        return False\n    return staticcall LegoBook(legoBook).isLegoAddr(_addr)\n\n\n###############\n# Departments #\n###############\n\n\n# ledger\n\n\n@view\n@internal\ndef _getLedgerId() -> uint256:\n    return LEDGER_ID\n\n\n@view\n@internal\ndef _getLedgerAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEDGER_ID)\n\n\n# mission control\n\n\n@view\n@internal\ndef _getMissionControlId() -> uint256:\n    return MISSION_CONTROL_ID\n\n\n@view\n@internal\ndef _getMissionControlAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(MISSION_CONTROL_ID)\n\n\n# lego book\n\n\n@view\n@internal\ndef _getLegoBookId() -> uint256:\n    return LEGO_BOOK_ID\n\n\n@view\n@internal\ndef _getLegoBookAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n\n\n# switchboard\n\n\n@view\n@internal\ndef _getSwitchboardId() -> uint256:\n    return SWITCHBOARD_ID\n\n\n@view\n@internal\ndef _getSwitchboardAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n\n\n# hatchery\n\n\n@view\n@internal\ndef _getHatcheryId() -> uint256:\n    return HATCHERY_ID\n\n\n@view\n@internal\ndef _getHatcheryAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(HATCHERY_ID)\n\n\n# loot distributor\n\n\n@view\n@internal\ndef _getLootDistributorId() -> uint256:\n    return LOOT_DISTRIBUTOR_ID\n\n\n@view\n@internal\ndef _getLootDistributorAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LOOT_DISTRIBUTOR_ID)\n\n\n# appraiser\n\n\n@view\n@internal\ndef _getAppraiserId() -> uint256:\n    return APPRAISER_ID\n\n\n@view\n@internal\ndef _getAppraiserAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(APPRAISER_ID)\n\n\n# wallet backpack\n\n\n@view\n@internal\ndef _getWalletBackpackId() -> uint256:\n    return WALLET_BACKPACK_ID\n\n\n@view\n@internal\ndef _getWalletBackpackAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(WALLET_BACKPACK_ID)\n\n\n# billing\n\n\n@view\n@internal\ndef _getBillingId() -> uint256:\n    return BILLING_ID\n\n\n@view\n@internal\ndef _getBillingAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(BILLING_ID)\n\n\n# vault registry\n\n\n@view\n@internal\ndef _getVaultRegistryId() -> uint256:\n    return VAULT_REGISTRY_ID\n\n\n@view\n@internal\ndef _getVaultRegistryAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(VAULT_REGISTRY_ID)",
            "sha256sum": "4df6b72db9bb417d1af81660175be1450cfb7b3575f3d17a5b8a130bff87b781"
          },
          "contracts/modules/YieldLegoData.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nuses: addys\n\nimport contracts.modules.Addys as addys\n\nfrom interfaces import WalletStructs as ws\nfrom interfaces import LegoStructs as ls\nfrom ethereum.ercs import IERC20\nfrom ethereum.ercs import IERC20Detailed\n\nevent AssetOpportunityAdded:\n    asset: indexed(address)\n    vaultAddr: indexed(address)\n\nevent AssetOpportunityRemoved:\n    asset: indexed(address)\n    vaultAddr: indexed(address)\n\nevent LegoPauseModified:\n    isPaused: bool\n\nevent LegoFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    balance: uint256\n\nevent PricePerShareSnapShotAdded:\n    vaultToken: indexed(address)\n    totalSupply: uint256\n    pricePerShare: uint256\n\nevent SnapShotPriceConfigSet:\n    minSnapshotDelay: uint256\n    maxNumSnapshots: uint256\n    maxUpsideDeviation: uint256\n    staleTime: uint256\n\n# core\nvaultToAsset: public(HashMap[address, ls.VaultTokenInfo]) # vault addr -> data\n\n# asset opportunities\nassetOpportunities: public(HashMap[address, HashMap[uint256, address]]) # asset -> index -> vault addr\nindexOfAssetOpportunity: public(HashMap[address, HashMap[address, uint256]]) # asset -> vault addr -> index\nnumAssetOpportunities: public(HashMap[address, uint256]) # asset -> number of opportunities\n\n# lego assets (iterable)\nassets: public(HashMap[uint256, address]) # index -> asset\nindexOfAsset: public(HashMap[address, uint256]) # asset -> index\nnumAssets: public(uint256) # num assets\n\n# price snapshots\nsnapShotData: public(HashMap[address, ls.SnapShotData]) # vault token -> data\nsnapShots: public(HashMap[address, HashMap[uint256, ls.SingleSnapShot]]) # vault token -> index -> snapshot\nsnapShotPriceConfig: public(ls.SnapShotPriceConfig) # config\n\nisPaused: public(bool)\n\nMAX_VAULTS: constant(uint256) = 40\nMAX_ASSETS: constant(uint256) = 20\nMAX_RECOVER_ASSETS: constant(uint256) = 20\nONE_DAY_SECONDS: constant(uint256) = 60 * 60 * 24\nONE_WEEK_SECONDS: constant(uint256) = ONE_DAY_SECONDS * 7\nHUNDRED_PERCENT: constant(uint256) = 100_00\n\n\n@deploy\ndef __init__(_shouldPause: bool):\n    self.isPaused = _shouldPause\n    self.numAssets = 1 # not using 0 index\n\n    # default snapshot price config\n    self.snapShotPriceConfig = ls.SnapShotPriceConfig(\n        minSnapshotDelay = 60 * 10, # 10 minutes\n        maxNumSnapshots = 20,\n        maxUpsideDeviation = 10_00, # 10%\n        staleTime = 3 * ONE_DAY_SECONDS, # 3 days\n    )\n\n\n#########\n# Views #\n#########\n\n\n# is lego asset\n\n\n@view\n@external\ndef isLegoAsset(_asset: address) -> bool:\n    return self._isLegoAsset(_asset)\n\n\n@view\n@internal\ndef _isLegoAsset(_asset: address) -> bool:\n    return self.indexOfAsset[_asset] != 0\n\n\n# vault opportunities\n\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, MAX_VAULTS]:\n    numOpportunities: uint256 = self.numAssetOpportunities[_asset]\n    if numOpportunities == 0:\n        return []\n    opportunities: DynArray[address, MAX_VAULTS] = []\n    for i: uint256 in range(1, numOpportunities, bound=MAX_VAULTS):\n        opportunities.append(self.assetOpportunities[_asset][i])\n    return opportunities\n\n\n# all assets registered\n\n\n@view\n@external\ndef getAssets() -> DynArray[address, MAX_ASSETS]:\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return []\n    assets: DynArray[address, MAX_ASSETS] = []\n    for i: uint256 in range(1, numAssets, bound=MAX_ASSETS):\n        assets.append(self.assets[i])\n    return assets\n\n\n################\n# Registration #\n################\n\n\n@view\n@external\ndef isAssetOpportunity(_asset: address, _vaultAddr: address) -> bool:\n    return self._isAssetOpportunity(_asset, _vaultAddr)\n\n\n@view\n@internal\ndef _isAssetOpportunity(_asset: address, _vaultAddr: address) -> bool:\n    return self.indexOfAssetOpportunity[_asset][_vaultAddr] != 0\n\n\n# add asset opportunity\n\n\n@internal\ndef _addAssetOpportunity(_asset: address, _vaultAddr: address) -> ls.VaultTokenInfo:\n    if self.indexOfAssetOpportunity[_asset][_vaultAddr] != 0:\n        return self.vaultToAsset[_vaultAddr]\n\n    if empty(address) in [_asset, _vaultAddr]:\n        return empty(ls.VaultTokenInfo)\n\n    # add asset opportunity\n    aid: uint256 = self.numAssetOpportunities[_asset]\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.assetOpportunities[_asset][aid] = _vaultAddr\n    self.indexOfAssetOpportunity[_asset][_vaultAddr] = aid\n    self.numAssetOpportunities[_asset] = aid + 1\n\n    # add mapping\n    vaultInfo: ls.VaultTokenInfo = ls.VaultTokenInfo(\n        underlyingAsset = _asset,\n        decimals = convert(staticcall IERC20Detailed(_vaultAddr).decimals(), uint256),\n        lastAveragePricePerShare = 0,\n    )\n    self.vaultToAsset[_vaultAddr] = vaultInfo\n\n    # add asset\n    self._addAsset(_asset)\n\n    log AssetOpportunityAdded(asset=_asset, vaultAddr=_vaultAddr)\n    return vaultInfo\n\n\n# remove asset opportunity\n\n\n@internal\ndef _removeAssetOpportunity(_asset: address, _vaultAddr: address):\n    numOpportunities: uint256 = self.numAssetOpportunities[_asset]\n    if numOpportunities == 0:\n        return\n\n    targetIndex: uint256 = self.indexOfAssetOpportunity[_asset][_vaultAddr]\n    if targetIndex == 0:\n        return\n\n    # update data\n    lastIndex: uint256 = numOpportunities - 1\n    self.numAssetOpportunities[_asset] = lastIndex\n    self.indexOfAssetOpportunity[_asset][_vaultAddr] = 0\n\n    self.vaultToAsset[_vaultAddr] = empty(ls.VaultTokenInfo)\n\n    # shift to replace the removed one\n    if targetIndex != lastIndex:\n        lastVaultAddr: address = self.assetOpportunities[_asset][lastIndex]\n        self.assetOpportunities[_asset][targetIndex] = lastVaultAddr\n        self.indexOfAssetOpportunity[_asset][lastVaultAddr] = targetIndex\n\n    # remove asset\n    if lastIndex <= 1:\n        self._removeAsset(_asset)\n\n    log AssetOpportunityRemoved(asset=_asset, vaultAddr=_vaultAddr)\n\n\n# add asset\n\n\n@internal\ndef _addAsset(_asset: address):\n    if self.indexOfAsset[_asset] != 0:\n        return\n\n    aid: uint256 = self.numAssets\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.assets[aid] = _asset\n    self.indexOfAsset[_asset] = aid\n    self.numAssets = aid + 1\n\n\n# remove asset\n\n\n@internal\ndef _removeAsset(_asset: address):\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return\n\n    targetIndex: uint256 = self.indexOfAsset[_asset]\n    if targetIndex == 0:\n        return\n\n    # update data\n    lastIndex: uint256 = numAssets - 1\n    self.numAssets = lastIndex\n    self.indexOfAsset[_asset] = 0\n\n    # shift to replace the removed one\n    if targetIndex != lastIndex:\n        lastAsset: address = self.assets[lastIndex]\n        self.assets[targetIndex] = lastAsset\n        self.indexOfAsset[lastAsset] = targetIndex\n\n\n# num lego assets (true number, use `numAssets` for iteration)\n\n\n@view\n@external\ndef getNumLegoAssets() -> uint256:\n    return self._getNumLegoAssets()\n\n\n@view\n@internal\ndef _getNumLegoAssets() -> uint256:\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return 0\n    return numAssets - 1\n\n\n###########\n# General #\n###########\n\n\n# fill mini addys\n\n\n@view\n@internal\ndef _getMiniAddys(_miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> ws.MiniAddys:\n    if _miniAddys.ledger != empty(address):\n        return _miniAddys\n    return ws.MiniAddys(\n        ledger = addys._getLedgerAddr(),\n        missionControl = addys._getMissionControlAddr(),\n        legoBook = addys._getLegoBookAddr(),\n        appraiser = addys._getAppraiserAddr(),\n    )\n\n\n# activate\n\n\n@external\ndef pause(_shouldPause: bool):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert _shouldPause != self.isPaused # dev: no change\n    self.isPaused = _shouldPause\n    log LegoPauseModified(isPaused=_shouldPause)\n\n\n# recover funds\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    self._recoverFunds(_recipient, _asset)\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, MAX_RECOVER_ASSETS]):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    for a: address in _assets:\n        self._recoverFunds(_recipient, a)\n\n\n@internal\ndef _recoverFunds(_recipient: address, _asset: address):\n    assert empty(address) not in [_recipient, _asset] # dev: invalid recipient or asset\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    assert balance != 0 # dev: nothing to recover\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log LegoFundsRecovered(asset=_asset, recipient=_recipient, balance=balance)\n\n\n###################\n# Price Snapshots #\n###################\n\n\n# add price snapshot\n\n\n@internal\ndef _addPriceSnapshot(_vaultToken: address, _pricePerShare: uint256, _vaultTokenDecimals: uint256) -> bool:\n    config: ls.SnapShotPriceConfig = self.snapShotPriceConfig\n    if config.maxNumSnapshots == 0:\n        return False\n\n    data: ls.SnapShotData = self.snapShotData[_vaultToken]\n\n    # already have snapshot for this time\n    if data.lastSnapShot.lastUpdate == block.timestamp:\n        return False\n\n    # check if snapshot is too recent\n    if data.lastSnapShot.lastUpdate + config.minSnapshotDelay > block.timestamp:\n        return False\n\n    # create and store new snapshot\n    newSnapshot: ls.SingleSnapShot = self._getLatestSnapshot(_vaultToken, _pricePerShare, _vaultTokenDecimals, data.lastSnapShot, config)\n    data.lastSnapShot = newSnapshot\n    self.snapShots[_vaultToken][data.nextIndex] = newSnapshot\n\n    # update index\n    data.nextIndex += 1\n    if data.nextIndex >= config.maxNumSnapshots:\n        data.nextIndex = 0\n\n    # save snap shot data\n    self.snapShotData[_vaultToken] = data\n\n    # update cached weighted average price per share\n    self.vaultToAsset[_vaultToken].lastAveragePricePerShare = self._getWeightedPricePerShare(_vaultToken, _pricePerShare)\n\n    log PricePerShareSnapShotAdded(\n        vaultToken = _vaultToken,\n        totalSupply = newSnapshot.totalSupply,\n        pricePerShare = newSnapshot.pricePerShare,\n    )\n    return True\n\n\n# weighted price per share\n\n\n@view\n@external\ndef getWeightedPricePerShare(_vaultToken: address) -> uint256:\n    data: ls.SnapShotData = self.snapShotData[_vaultToken]\n    return self._getWeightedPricePerShare(_vaultToken, data.lastSnapShot.pricePerShare)\n\n\n@view\n@internal\ndef _getWeightedPricePerShare(_vaultToken: address, _lastPricePerShare: uint256) -> uint256:\n    config: ls.SnapShotPriceConfig = self.snapShotPriceConfig\n    if config.maxNumSnapshots == 0:\n        return 0\n\n    # calculate weighted average price using all valid snapshots\n    numerator: uint256 = 0\n    denominator: uint256 = 0\n    for i: uint256 in range(config.maxNumSnapshots, bound=max_value(uint256)):\n\n        snapShot: ls.SingleSnapShot = self.snapShots[_vaultToken][i]\n        if snapShot.pricePerShare == 0 or snapShot.totalSupply == 0 or snapShot.lastUpdate == 0:\n            continue\n\n        # too stale, skip\n        if config.staleTime != 0 and block.timestamp > snapShot.lastUpdate + config.staleTime:\n            continue\n\n        numerator += (snapShot.totalSupply * snapShot.pricePerShare)\n        denominator += snapShot.totalSupply\n\n    # weighted price per share\n    weightedPricePerShare: uint256 = 0\n    if numerator != 0:\n        weightedPricePerShare = numerator // denominator\n    else:\n        weightedPricePerShare = _lastPricePerShare\n\n    return weightedPricePerShare\n\n\n# latest snapshot\n\n\n@view\n@external\ndef getLatestSnapshot(_vaultToken: address, _pricePerShare: uint256) -> ls.SingleSnapShot:\n    data: ls.SnapShotData = self.snapShotData[_vaultToken]\n    config: ls.SnapShotPriceConfig = self.snapShotPriceConfig\n    vaultTokenDecimals: uint256 = self.vaultToAsset[_vaultToken].decimals\n    return self._getLatestSnapshot(_vaultToken, _pricePerShare, vaultTokenDecimals, data.lastSnapShot, config)\n\n\n@view\n@internal\ndef _getLatestSnapshot(\n    _vaultToken: address,\n    _pricePerShare: uint256,\n    _vaultTokenDecimals: uint256,\n    _lastSnapShot: ls.SingleSnapShot,\n    _config: ls.SnapShotPriceConfig,\n) -> ls.SingleSnapShot:\n\n    # total supply (adjusted)\n    totalSupply: uint256 = staticcall IERC20(_vaultToken).totalSupply() // (10 ** _vaultTokenDecimals)\n    if totalSupply == 0:\n        totalSupply = 1\n\n    # throttle upside (extra safety check)\n    pricePerShare: uint256 = self._throttleUpside(_pricePerShare, _lastSnapShot.pricePerShare, _config.maxUpsideDeviation)\n\n    return ls.SingleSnapShot(\n        totalSupply = totalSupply,\n        pricePerShare = pricePerShare,\n        lastUpdate = block.timestamp,\n    )\n\n\n@view\n@internal\ndef _throttleUpside(_newValue: uint256, _prevValue: uint256, _maxUpside: uint256) -> uint256:\n    if _maxUpside == 0 or _prevValue == 0 or _newValue == 0:\n        return _newValue\n    maxPricePerShare: uint256 = _prevValue + (_prevValue * _maxUpside // HUNDRED_PERCENT)\n    return min(_newValue, maxPricePerShare)\n\n\n# snapshot price config\n\n\n@external\ndef setSnapShotPriceConfig(_config: ls.SnapShotPriceConfig):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert self._isValidPriceConfig(_config) # dev: invalid config\n    self.snapShotPriceConfig = _config\n    log SnapShotPriceConfigSet(\n        minSnapshotDelay=_config.minSnapshotDelay,\n        maxNumSnapshots=_config.maxNumSnapshots,\n        maxUpsideDeviation=_config.maxUpsideDeviation,\n        staleTime=_config.staleTime\n    )\n\n\n@view\n@external\ndef isValidPriceConfig(_config: ls.SnapShotPriceConfig) -> bool:\n    return self._isValidPriceConfig(_config)\n\n\n@view\n@internal\ndef _isValidPriceConfig(_config: ls.SnapShotPriceConfig) -> bool:\n    if _config.minSnapshotDelay > ONE_WEEK_SECONDS:\n        return False\n    if _config.maxNumSnapshots == 0 or _config.maxNumSnapshots > 25:\n        return False\n    if _config.maxUpsideDeviation > HUNDRED_PERCENT:\n        return False\n    return _config.staleTime < ONE_WEEK_SECONDS",
            "sha256sum": "d695c6d3998cf2ed318a0da6f4f7918abf97661e10eb510ed996d815e65927e0"
          },
          "contracts/legos/RipeLego.vy": {
            "content": "#         _____   ____     _____       ______          ____            ______        _____           _____    \n#     ___|\\    \\ |    |___|\\    \\  ___|\\     \\        |    |       ___|\\     \\   ___|\\    \\     ____|\\    \\   \n#    |    |\\    \\|    |    |\\    \\|     \\     \\       |    |      |     \\     \\ /    /\\    \\   /     /\\    \\  \n#    |    | |    |    |    | |    |     ,_____/|      |    |      |     ,_____/|    |  |____| /     /  \\    \\ \n#    |    |/____/|    |    |/____/|     \\--'\\_|/      |    |  ____|     \\--'\\_|/    |    ____|     |    |    |\n#    |    |\\    \\|    |    ||    ||     /___/|        |    | |    |     /___/| |    |   |    |     |    |    |\n#    |    | |    |    |    ||____|/     \\____|\\       |    | |    |     \\____|\\|    |   |_,  |\\     \\  /    /|\n#    |____| |____|____|____|      |____ '     /|      |____|/____/|____ '     /|\\ ___\\___/  /| \\_____\\/____/ |\n#    |    | |    |    |    |      |    /_____/ |      |    |     ||    /_____/ | |   /____ / |\\ |    ||    | /\n#    |____| |____|____|____|      |____|     | /      |____|_____|/____|     | /\\|___|    | /  \\|____||____|/ \n#      \\(     )/   \\(   \\(          \\( |_____|/         \\(    )/    \\( |_____|/   \\( |____|/      \\(    )/    \n#       '     '     '    '           '    )/             '    '      '    )/       '   )/          '    '     \n#                                         '                               '            '                      \n#     \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n#     \u2551  ** Ripe Lego **                        \u2551\n#     \u2551  Integration with Ripe Protocol.        \u2551\n#     \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n#\n#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nimplements: Lego\nimplements: YieldLego\n\nexports: addys.__interface__\nexports: yld.__interface__\n\ninitializes: addys\ninitializes: yld[addys := addys]\n\nfrom interfaces import LegoPartner as Lego\nfrom interfaces import YieldLego as YieldLego\nfrom interfaces import WalletStructs as ws\nfrom interfaces import LegoStructs as ls\n\nimport contracts.modules.Addys as addys\nimport contracts.modules.YieldLegoData as yld\n\nfrom ethereum.ercs import IERC20\nfrom ethereum.ercs import IERC4626\n\ninterface RipeTeller:\n    def repay(_paymentAmount: uint256 = max_value(uint256), _user: address = msg.sender, _isPaymentSavingsGreen: bool = False, _shouldRefundSavingsGreen: bool = True) -> bool: nonpayable\n    def withdraw(_asset: address, _amount: uint256 = max_value(uint256), _user: address = msg.sender, _vaultAddr: address = empty(address), _vaultId: uint256 = 0) -> uint256: nonpayable\n    def deposit(_asset: address, _amount: uint256 = max_value(uint256), _user: address = msg.sender, _vaultAddr: address = empty(address), _vaultId: uint256 = 0) -> uint256: nonpayable\n    def depositIntoGovVault(_asset: address, _amount: uint256, _lockDuration: uint256, _user: address = msg.sender) -> uint256: nonpayable\n    def borrow(_greenAmount: uint256 = max_value(uint256), _user: address = msg.sender, _wantsSavingsGreen: bool = True, _shouldEnterStabPool: bool = False) -> uint256: nonpayable\n    def claimLoot(_user: address = msg.sender, _shouldStake: bool = True) -> uint256: nonpayable\n\ninterface Ledger:\n    def setVaultToken(_vaultToken: address, _legoId: uint256, _underlyingAsset: address, _decimals: uint256, _isRebasing: bool): nonpayable\n    def isRegisteredVaultToken(_vaultToken: address) -> bool: view\n    def isUserWallet(_user: address) -> bool: view\n\ninterface RipeRegistry:\n    def savingsGreen() -> address: view\n    def greenToken() -> address: view\n    def ripeToken() -> address: view\n\ninterface Appraiser:\n    def getUsdValue(_asset: address, _amount: uint256, _missionControl: address = empty(address), _legoBook: address = empty(address), _ledger: address = empty(address)) -> uint256: view\n    def updatePriceAndGetUsdValue(_asset: address, _amount: uint256, _missionControl: address = empty(address), _legoBook: address = empty(address)) -> uint256: nonpayable\n\ninterface Registry:\n    def getRegId(_addr: address) -> uint256: view\n    def getAddr(_regId: uint256) -> address: view\n\ninterface RipeMissionControl:\n    def doesUndyLegoHaveAccess(_wallet: address, _legoAddr: address) -> bool: view\n\nevent RipeCollateralDeposit:\n    sender: indexed(address)\n    asset: indexed(address)\n    assetAmountDeposited: uint256\n    vaultIdOrLock: uint256\n    usdValue: uint256\n    recipient: address\n\nevent RipeCollateralWithdrawal:\n    sender: indexed(address)\n    asset: indexed(address)\n    assetAmountReceived: uint256\n    vaultId: uint256\n    usdValue: uint256\n    recipient: address\n\nevent RipeBorrow:\n    sender: indexed(address)\n    asset: indexed(address)\n    assetAmountBorrowed: uint256\n    usdValue: uint256\n    recipient: address\n\nevent RipeRepay:\n    sender: indexed(address)\n    asset: indexed(address)\n    assetAmountRepaid: uint256\n    usdValue: uint256\n    recipient: address\n\nevent RipeClaimRewards:\n    sender: indexed(address)\n    asset: indexed(address)\n    ripeClaimed: uint256\n    usdValue: uint256\n    recipient: address\n\nevent RipeSavingsGreenDeposit:\n    sender: indexed(address)\n    asset: indexed(address)\n    vaultToken: indexed(address)\n    assetAmountDeposited: uint256\n    usdValue: uint256\n    vaultTokenAmountReceived: uint256\n    recipient: address\n\nevent RipeSavingsGreenWithdrawal:\n    sender: indexed(address)\n    asset: indexed(address)\n    vaultToken: indexed(address)\n    assetAmountReceived: uint256\n    usdValue: uint256\n    vaultTokenAmountBurned: uint256\n    recipient: address\n\n# ripe addrs\nRIPE_REGISTRY: public(immutable(address))\nRIPE_GREEN_TOKEN: public(immutable(address))\nRIPE_SAVINGS_GREEN: public(immutable(address))\nRIPE_TOKEN: public(immutable(address))\n\nRIPE_MISSION_CONTROL_ID: constant(uint256) = 5\nRIPE_TELLER_ID: constant(uint256) = 17\n\nLEGO_ACCESS_ABI: constant(String[64]) = \"setUndyLegoAccess(address)\"\nMAX_TOKEN_PATH: constant(uint256) = 5\n\n\n@deploy\ndef __init__(_undyHq: address, _ripeRegistry: address):\n    addys.__init__(_undyHq)\n    yld.__init__(False)\n\n    assert _ripeRegistry != empty(address) # dev: invalid ripe registry\n    RIPE_REGISTRY = _ripeRegistry\n    RIPE_GREEN_TOKEN = staticcall RipeRegistry(RIPE_REGISTRY).greenToken()\n    RIPE_SAVINGS_GREEN = staticcall RipeRegistry(RIPE_REGISTRY).savingsGreen()\n    RIPE_TOKEN = staticcall RipeRegistry(RIPE_REGISTRY).ripeToken()\n\n\n@view\n@external\ndef hasCapability(_action: ws.ActionType) -> bool:\n    return _action in (\n        ws.ActionType.EARN_DEPOSIT | \n        ws.ActionType.EARN_WITHDRAW |\n        ws.ActionType.ADD_COLLATERAL |\n        ws.ActionType.REMOVE_COLLATERAL |\n        ws.ActionType.BORROW |\n        ws.ActionType.REPAY_DEBT |\n        ws.ActionType.REWARDS\n    )\n\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    return [RIPE_REGISTRY]\n\n\n@view\n@external\ndef isYieldLego() -> bool:\n    return True # savings green\n\n\n@view\n@external\ndef isDexLego() -> bool:\n    return False\n\n\n###################\n# Underlying Data #\n###################\n\n\n# underlying asset\n\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    return self._getUnderlyingAsset(_vaultToken)\n\n\n@view\n@internal\ndef _getUnderlyingAsset(_vaultToken: address) -> address:\n    return yld.vaultToAsset[_vaultToken].underlyingAsset\n\n\n# underlying balances (both true and safe)\n\n\n@view\n@external\ndef getUnderlyingBalances(_vaultToken: address, _vaultTokenBalance: uint256) -> (uint256, uint256):\n    if _vaultTokenBalance == 0:\n        return 0, 0\n\n    trueUnderlying: uint256 = self._getUnderlyingAmount(_vaultToken, _vaultTokenBalance)\n    safeUnderlying: uint256 = self._getUnderlyingAmountSafe(_vaultToken, _vaultTokenBalance)\n    if safeUnderlying == 0:\n        safeUnderlying = trueUnderlying\n\n    return trueUnderlying, min(trueUnderlying, safeUnderlying)\n\n\n# underlying amount (true)\n\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    return self._getUnderlyingAmount(_vaultToken, _vaultTokenAmount)\n\n\n@view\n@internal\ndef _getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    return staticcall IERC4626(_vaultToken).convertToAssets(_vaultTokenAmount)\n\n\n# underlying amount (safe)\n\n\n@view\n@external\ndef getUnderlyingAmountSafe(_vaultToken: address, _vaultTokenBalance: uint256) -> uint256:\n    return self._getUnderlyingAmountSafe(_vaultToken, _vaultTokenBalance)\n\n\n@view\n@internal\ndef _getUnderlyingAmountSafe(_vaultToken: address, _vaultTokenBalance: uint256) -> uint256:\n    vaultInfo: ls.VaultTokenInfo = yld.vaultToAsset[_vaultToken]\n    if vaultInfo.decimals == 0:\n        return 0 # not registered\n\n    # safe underlying amount (using cached weighted average from snapshots)\n    return _vaultTokenBalance * vaultInfo.lastAveragePricePerShare // (10 ** vaultInfo.decimals)\n\n\n# underlying data (combined)\n\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> (address, uint256, uint256):\n    return self._getUnderlyingData(_vaultToken, _vaultTokenAmount, _appraiser)\n\n\n@view\n@internal\ndef _getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address) -> (address, uint256, uint256):\n    asset: address = self._getUnderlyingAsset(_vaultToken)\n    if asset == empty(address):\n        return empty(address), 0, 0 # invalid vault token\n    underlyingAmount: uint256 = self._getUnderlyingAmount(_vaultToken, _vaultTokenAmount)\n    usdValue: uint256 = self._getUsdValue(asset, underlyingAmount, _appraiser)\n    return asset, underlyingAmount, usdValue\n\n\n# usd value\n\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> uint256:\n    return self._getUsdValueOfVaultToken(_vaultToken, _vaultTokenAmount, _appraiser)\n\n\n@view\n@internal\ndef _getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address) -> uint256:\n    return self._getUnderlyingData(_vaultToken, _vaultTokenAmount, _appraiser)[2]\n\n\n@view\n@internal\ndef _getUsdValue(_asset: address, _amount: uint256, _appraiser: address) -> uint256:\n    appraiser: address = _appraiser\n    if _appraiser == empty(address):\n        appraiser = addys._getAppraiserAddr()\n    return staticcall Appraiser(appraiser).getUsdValue(_asset, _amount)\n\n\n###############\n# Other Utils #\n###############\n\n\n# basics\n\n\n@view\n@external\ndef isRebasing() -> bool:\n    return self._isRebasing()\n\n\n@view\n@internal\ndef _isRebasing() -> bool:\n    return False\n\n\n# price per share\n\n\n@view\n@external\ndef getPricePerShare(_vaultToken: address, _decimals: uint256 = 0) -> uint256:\n    decimals: uint256 = _decimals\n    if decimals == 0:\n        decimals = yld.vaultToAsset[_vaultToken].decimals\n    if decimals == 0:\n        return 0 # not registered\n    return self._getPricePerShare(_vaultToken, decimals)\n\n\n@view\n@internal\ndef _getPricePerShare(_vaultToken: address, _decimals: uint256) -> uint256:\n    return staticcall IERC4626(_vaultToken).convertToAssets(10 ** _decimals)\n\n\n# vault token amount\n\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    return staticcall IERC4626(_vaultToken).convertToShares(_assetAmount)\n\n\n# extras\n\n\n@view\n@external\ndef isEligibleVaultForTrialFunds(_vaultToken: address, _underlyingAsset: address) -> bool:\n    return False\n\n\n@view\n@external\ndef isEligibleForYieldBonus(_asset: address) -> bool:\n    return False\n\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    return staticcall IERC4626(_vaultToken).totalAssets()\n\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    # TODO: implement\n    return 0\n\n\n################\n# Registration #\n################\n\n\n# can vault be registered\n\n\n@view\n@external\ndef canRegisterVaultToken(_asset: address, _vaultToken: address) -> bool:\n    return self._canRegisterVaultToken(_asset, _vaultToken)\n\n\n@view\n@internal\ndef _canRegisterVaultToken(_asset: address, _vaultToken: address) -> bool:\n    if empty(address) in [_asset, _vaultToken]:\n        return False\n    return _asset == RIPE_GREEN_TOKEN and _vaultToken == RIPE_SAVINGS_GREEN\n\n\n# register vault token locally\n\n\n@external\ndef registerVaultTokenLocally(_asset: address, _vaultAddr: address) -> ls.VaultTokenInfo:\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert self._canRegisterVaultToken(_asset, _vaultAddr) # dev: cannot register vault token\n    assert not yld._isAssetOpportunity(_asset, _vaultAddr) # dev: already registered\n    vaultInfo: ls.VaultTokenInfo = self._registerVaultTokenLocally(_asset, _vaultAddr)\n    self._registerVaultTokenGlobally(_asset, _vaultAddr, vaultInfo.decimals, addys._getLedgerAddr(), addys._getLegoBookAddr())\n    return vaultInfo\n\n\n@internal\ndef _registerVaultTokenLocally(_asset: address, _vaultAddr: address) -> ls.VaultTokenInfo:\n    assert extcall IERC20(_asset).approve(_vaultAddr, max_value(uint256), default_return_value=True) # dev: max approval failed\n    vaultInfo: ls.VaultTokenInfo = yld._addAssetOpportunity(_asset, _vaultAddr)\n    assert vaultInfo.decimals != 0 # dev: invalid vault token\n    return vaultInfo\n\n\n# remove vault token locally\n\n\n@external\ndef deregisterVaultTokenLocally(_asset: address, _vaultAddr: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert yld._isAssetOpportunity(_asset, _vaultAddr) # dev: already registered\n    self._deregisterVaultTokenLocally(_asset, _vaultAddr)\n\n\n@internal\ndef _deregisterVaultTokenLocally(_asset: address, _vaultAddr: address):\n    assert extcall IERC20(_asset).approve(_vaultAddr, 0, default_return_value=True) # dev: max approval failed\n    yld._removeAssetOpportunity(_asset, _vaultAddr)\n\n\n# ledger registration\n\n\n@internal\ndef _registerVaultTokenGlobally(_underlyingAsset: address, _vaultToken: address, _decimals: uint256, _ledger: address, _legoBook: address):\n    if not staticcall Ledger(_ledger).isRegisteredVaultToken(_vaultToken):\n        legoId: uint256 = staticcall Registry(_legoBook).getRegId(self)\n        extcall Ledger(_ledger).setVaultToken(_vaultToken, legoId, _underlyingAsset, _decimals, self._isRebasing())\n\n\n#################\n# Yield Actions #\n#################\n\n\n# add price snapshot\n\n\n@external\ndef addPriceSnapshot(_vaultToken: address) -> bool:\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    vaultInfo: ls.VaultTokenInfo = yld.vaultToAsset[_vaultToken]\n    assert vaultInfo.decimals != 0 # dev: not registered\n    pricePerShare: uint256 = self._getPricePerShare(_vaultToken, vaultInfo.decimals)\n    return yld._addPriceSnapshot(_vaultToken, pricePerShare, vaultInfo.decimals)\n\n\n# deposit\n\n\n@external\ndef depositForYield(\n    _asset: address,\n    _amount: uint256,\n    _vaultAddr: address,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, address, uint256, uint256):\n    assert not yld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = yld._getMiniAddys(_miniAddys)\n    vaultInfo: ls.VaultTokenInfo = self._getVaultInfoOnDeposit(_asset, _vaultAddr, miniAddys.ledger, miniAddys.legoBook)\n\n    # pre balances\n    preLegoBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n\n    # transfer deposit asset to this contract\n    depositAmount: uint256 = min(_amount, staticcall IERC20(_asset).balanceOf(msg.sender))\n    assert depositAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_asset).transferFrom(msg.sender, self, depositAmount, default_return_value=True) # dev: transfer failed\n\n    # deposit assets into lego partner\n    vaultTokenAmountReceived: uint256 = extcall IERC4626(_vaultAddr).deposit(depositAmount, _recipient)\n    assert vaultTokenAmountReceived != 0 # dev: no vault tokens received\n\n    # refund if full deposit didn't get through\n    currentLegoBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    refundAssetAmount: uint256 = 0\n    if currentLegoBalance > preLegoBalance:\n        refundAssetAmount = currentLegoBalance - preLegoBalance\n        assert extcall IERC20(_asset).transfer(msg.sender, refundAssetAmount, default_return_value=True) # dev: transfer failed\n        depositAmount -= refundAssetAmount\n\n    usdValue: uint256 = extcall Appraiser(miniAddys.appraiser).updatePriceAndGetUsdValue(_asset, depositAmount, miniAddys.missionControl, miniAddys.legoBook)\n    log RipeSavingsGreenDeposit(\n        sender = msg.sender,\n        asset = _asset,\n        vaultToken = _vaultAddr,\n        assetAmountDeposited = depositAmount,\n        usdValue = usdValue,\n        vaultTokenAmountReceived = vaultTokenAmountReceived,\n        recipient = _recipient,\n    )\n\n    # add price snapshot\n    pricePerShare: uint256 = self._getPricePerShare(_vaultAddr, vaultInfo.decimals)\n    yld._addPriceSnapshot(_vaultAddr, pricePerShare, vaultInfo.decimals)\n\n    return depositAmount, _vaultAddr, vaultTokenAmountReceived, usdValue\n\n\n# vault info on deposit\n\n\n@internal\ndef _getVaultInfoOnDeposit(_asset: address, _vaultAddr: address, _ledger: address, _legoBook: address) -> ls.VaultTokenInfo:\n    vaultInfo: ls.VaultTokenInfo = yld.vaultToAsset[_vaultAddr]\n    if vaultInfo.decimals == 0:\n        assert self._canRegisterVaultToken(_asset, _vaultAddr) # dev: cannot register vault token\n        vaultInfo = self._registerVaultTokenLocally(_asset, _vaultAddr)\n        self._registerVaultTokenGlobally(_asset, _vaultAddr, vaultInfo.decimals, _ledger, _legoBook)\n    else:\n        assert vaultInfo.underlyingAsset == _asset # dev: asset mismatch\n    return vaultInfo\n\n\n# withdraw\n\n\n@external\ndef withdrawFromYield(\n    _vaultToken: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, address, uint256, uint256):\n    assert not yld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = yld._getMiniAddys(_miniAddys)\n    vaultInfo: ls.VaultTokenInfo = self._getVaultInfoOnWithdrawal(_vaultToken, miniAddys.ledger, miniAddys.legoBook)\n\n    # pre balances\n    preLegoVaultBalance: uint256 = staticcall IERC20(_vaultToken).balanceOf(self)\n\n    # transfer vaults tokens to this contract\n    vaultTokenAmount: uint256 = min(_amount, staticcall IERC20(_vaultToken).balanceOf(msg.sender))\n    assert vaultTokenAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_vaultToken).transferFrom(msg.sender, self, vaultTokenAmount, default_return_value=True) # dev: transfer failed\n\n    # withdraw assets from lego partner\n    assetAmountReceived: uint256 = extcall IERC4626(_vaultToken).redeem(vaultTokenAmount, _recipient, self)\n    assert assetAmountReceived != 0 # dev: no asset amount received\n\n    # refund if full withdrawal didn't happen\n    currentLegoVaultBalance: uint256 = staticcall IERC20(_vaultToken).balanceOf(self)\n    refundVaultTokenAmount: uint256 = 0\n    if currentLegoVaultBalance > preLegoVaultBalance:\n        refundVaultTokenAmount = currentLegoVaultBalance - preLegoVaultBalance\n        assert extcall IERC20(_vaultToken).transfer(msg.sender, refundVaultTokenAmount, default_return_value=True) # dev: transfer failed\n        vaultTokenAmount -= refundVaultTokenAmount\n\n    usdValue: uint256 = extcall Appraiser(miniAddys.appraiser).updatePriceAndGetUsdValue(vaultInfo.underlyingAsset, assetAmountReceived, miniAddys.missionControl, miniAddys.legoBook)\n    log RipeSavingsGreenWithdrawal(\n        sender = msg.sender,\n        asset = vaultInfo.underlyingAsset,\n        vaultToken = _vaultToken,\n        assetAmountReceived = assetAmountReceived,\n        usdValue = usdValue,\n        vaultTokenAmountBurned = vaultTokenAmount,\n        recipient = _recipient,\n    )\n\n    # add price snapshot\n    pricePerShare: uint256 = self._getPricePerShare(_vaultToken, vaultInfo.decimals)\n    yld._addPriceSnapshot(_vaultToken, pricePerShare, vaultInfo.decimals)\n\n    return vaultTokenAmount, vaultInfo.underlyingAsset, assetAmountReceived, usdValue\n\n\n# vault info on withdrawal\n\n\n@internal\ndef _getVaultInfoOnWithdrawal(_vaultAddr: address, _ledger: address, _legoBook: address) -> ls.VaultTokenInfo:\n    vaultInfo: ls.VaultTokenInfo = yld.vaultToAsset[_vaultAddr]\n    if vaultInfo.decimals == 0:\n        asset: address = staticcall IERC4626(_vaultAddr).asset()\n        assert self._canRegisterVaultToken(asset, _vaultAddr) # dev: cannot register vault token\n        vaultInfo = self._registerVaultTokenLocally(asset, _vaultAddr)\n        self._registerVaultTokenGlobally(asset, _vaultAddr, vaultInfo.decimals, _ledger, _legoBook)\n    return vaultInfo\n\n\n###################\n# Debt Management #\n###################\n\n\n# add collateral on Ripe\n\n\n@external\ndef addCollateral(\n    _asset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    assert not yld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = yld._getMiniAddys(_miniAddys)\n\n    # only allowing user wallets to do this\n    assert self._isUserWallet(msg.sender) # dev: not a user wallet\n    assert msg.sender == _recipient # dev: recipient must be caller\n\n    # pre balances\n    preLegoBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n\n    # transfer deposit asset to this contract\n    depositAmount: uint256 = min(_amount, staticcall IERC20(_asset).balanceOf(msg.sender))\n    assert depositAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_asset).transferFrom(msg.sender, self, depositAmount, default_return_value=True) # dev: transfer failed\n\n    vaultIdOrLock: uint256 = 0\n    if _extraData != empty(bytes32):\n        vaultIdOrLock = convert(_extraData, uint256)\n\n    # deposit into Ripe Protocol\n    teller: address = self._getRipeTellerAndApprove(_asset)\n    if _asset == RIPE_TOKEN:\n        depositAmount = extcall RipeTeller(teller).depositIntoGovVault(_asset, depositAmount, vaultIdOrLock, _recipient)\n    else:\n        depositAmount = extcall RipeTeller(teller).deposit(_asset, depositAmount, _recipient, empty(address), vaultIdOrLock)\n    self._resetTellerApproval(_asset, teller)\n\n    # refund if full deposit didn't get through\n    currentLegoBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    refundAssetAmount: uint256 = 0\n    if currentLegoBalance > preLegoBalance:\n        refundAssetAmount = currentLegoBalance - preLegoBalance\n        assert extcall IERC20(_asset).transfer(msg.sender, refundAssetAmount, default_return_value=True) # dev: transfer failed\n\n    usdValue: uint256 = extcall Appraiser(miniAddys.appraiser).updatePriceAndGetUsdValue(_asset, depositAmount, miniAddys.missionControl, miniAddys.legoBook)\n    log RipeCollateralDeposit(\n        sender = msg.sender,\n        asset = _asset,\n        assetAmountDeposited = depositAmount,\n        vaultIdOrLock = vaultIdOrLock,\n        usdValue = usdValue,\n        recipient = _recipient,\n    )\n    return depositAmount, usdValue\n\n\n# remove collateral on ripe\n\n\n@external\ndef removeCollateral(\n    _asset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    assert not yld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = yld._getMiniAddys(_miniAddys)\n\n    # only allowing user wallets to do this\n    assert self._isUserWallet(msg.sender) # dev: not a user wallet\n    assert msg.sender == _recipient # dev: recipient must be caller\n\n    vaultId: uint256 = 0\n    if _extraData != empty(bytes32):\n        vaultId = convert(_extraData, uint256)\n\n    # withdraw from Ripe Protocol\n    teller: address = staticcall Registry(RIPE_REGISTRY).getAddr(RIPE_TELLER_ID)\n    amountRemoved: uint256 = extcall RipeTeller(teller).withdraw(_asset, _amount, _recipient, empty(address), vaultId)\n    assert amountRemoved != 0 # dev: no asset amount received\n\n    usdValue: uint256 = extcall Appraiser(miniAddys.appraiser).updatePriceAndGetUsdValue(_asset, amountRemoved, miniAddys.missionControl, miniAddys.legoBook)\n    log RipeCollateralWithdrawal(\n        sender = msg.sender,\n        asset = _asset,\n        assetAmountReceived = amountRemoved,\n        vaultId = vaultId,\n        usdValue = usdValue,\n        recipient = _recipient,\n    )\n    return amountRemoved, usdValue\n\n\n# borrow\n\n\n@external\ndef borrow(\n    _borrowAsset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    assert not yld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = yld._getMiniAddys(_miniAddys)\n\n    # only allowing user wallets to do this\n    assert self._isUserWallet(msg.sender) # dev: not a user wallet\n    assert msg.sender == _recipient # dev: recipient must be caller\n\n    assert _borrowAsset in [RIPE_GREEN_TOKEN, RIPE_SAVINGS_GREEN] # dev: invalid borrow asset\n    wantsSavingsGreen: bool = _borrowAsset == RIPE_SAVINGS_GREEN\n\n    # borrow from Ripe\n    teller: address = staticcall Registry(RIPE_REGISTRY).getAddr(RIPE_TELLER_ID)\n    borrowAmount: uint256 = extcall RipeTeller(teller).borrow(_amount, _recipient, wantsSavingsGreen, False)\n    assert borrowAmount != 0 # dev: no borrow amount received\n\n    usdValue: uint256 = extcall Appraiser(miniAddys.appraiser).updatePriceAndGetUsdValue(_borrowAsset, borrowAmount, miniAddys.missionControl, miniAddys.legoBook)\n    log RipeBorrow(\n        sender = msg.sender,\n        asset = _borrowAsset,\n        assetAmountBorrowed = borrowAmount,\n        usdValue = usdValue,\n        recipient = _recipient,\n    )\n    return borrowAmount, usdValue\n\n\n# repay debt\n\n\n@external\ndef repayDebt(\n    _paymentAsset: address,\n    _paymentAmount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    assert not yld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = yld._getMiniAddys(_miniAddys)\n\n    # only allowing user wallets to do this\n    assert self._isUserWallet(msg.sender) # dev: not a user wallet\n    assert msg.sender == _recipient # dev: recipient must be caller\n\n    assert _paymentAsset in [RIPE_GREEN_TOKEN, RIPE_SAVINGS_GREEN] # dev: invalid payment asset\n    isPaymentSavingsGreen: bool = _paymentAsset == RIPE_SAVINGS_GREEN\n\n    # pre balances\n    preLegoBalance: uint256 = staticcall IERC20(_paymentAsset).balanceOf(self)\n\n    # transfer deposit asset to this contract\n    paymentAmount: uint256 = min(_paymentAmount, staticcall IERC20(_paymentAsset).balanceOf(msg.sender))\n    assert paymentAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_paymentAsset).transferFrom(msg.sender, self, paymentAmount, default_return_value=True) # dev: transfer failed\n\n    # deposit into Ripe Protocol\n    teller: address = self._getRipeTellerAndApprove(_paymentAsset)\n    extcall RipeTeller(teller).repay(paymentAmount, _recipient, isPaymentSavingsGreen, True)\n    self._resetTellerApproval(_paymentAsset, teller)\n\n    # refund if full deposit didn't get through\n    currentLegoBalance: uint256 = staticcall IERC20(_paymentAsset).balanceOf(self)\n    refundAssetAmount: uint256 = 0\n    if currentLegoBalance > preLegoBalance:\n        refundAssetAmount = currentLegoBalance - preLegoBalance\n        assert extcall IERC20(_paymentAsset).transfer(msg.sender, refundAssetAmount, default_return_value=True) # dev: transfer failed\n\n    usdValue: uint256 = extcall Appraiser(miniAddys.appraiser).updatePriceAndGetUsdValue(_paymentAsset, paymentAmount, miniAddys.missionControl, miniAddys.legoBook)\n    log RipeRepay(\n        sender = msg.sender,\n        asset = _paymentAsset,\n        assetAmountRepaid = paymentAmount,\n        usdValue = usdValue,\n        recipient = _recipient,\n    )\n    return paymentAmount, usdValue\n\n\n# shared utils\n\n\n@internal\ndef _getRipeTellerAndApprove(_asset: address) -> address:\n    teller: address = staticcall Registry(RIPE_REGISTRY).getAddr(RIPE_TELLER_ID)\n    # some vault tokens require max value approval (comp v3)\n    assert extcall IERC20(_asset).approve(teller, max_value(uint256), default_return_value = True) # dev: appr\n    return teller\n\n\n@internal\ndef _resetTellerApproval(_asset: address, _teller: address):\n    if _teller != empty(address):\n        assert extcall IERC20(_asset).approve(_teller, 0, default_return_value = True) # dev: approval failed\n\n\n@view\n@internal\ndef _isUserWallet(_user: address) -> bool:\n    return staticcall Ledger(addys._getLedgerAddr()).isUserWallet(_user)\n\n\n#################\n# Claim Rewards #\n#################\n\n\n@external\ndef claimRewards(\n    _user: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _extraData: bytes32,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    assert not yld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = yld._getMiniAddys(_miniAddys)\n\n    # NOTE: not checking isUserWallet -- Ripe's Endaoment needs to be able to call this\n    assert msg.sender == _user # dev: recipient must be caller\n\n    assert _rewardToken == RIPE_TOKEN # dev: invalid reward token\n\n    teller: address = staticcall Registry(RIPE_REGISTRY).getAddr(RIPE_TELLER_ID)\n    totalRipe: uint256 = extcall RipeTeller(teller).claimLoot(_user, True)\n    assert totalRipe != 0 # dev: no ripe tokens received\n\n    usdValue: uint256 = extcall Appraiser(miniAddys.appraiser).updatePriceAndGetUsdValue(_rewardToken, totalRipe, miniAddys.missionControl, miniAddys.legoBook)\n    log RipeClaimRewards(\n        sender = msg.sender,\n        asset = _rewardToken,\n        ripeClaimed = totalRipe,\n        usdValue = usdValue,\n        recipient = _user,\n    )\n    return 0, usdValue\n\n\n@view\n@external\ndef hasClaimableRewards(_user: address) -> bool:\n    # TODO: implement\n    return False\n\n\n@view\n@external\ndef getAccessForLego(_user: address, _action: ws.ActionType) -> (address, String[64], uint256):\n    ripeHq: address = RIPE_REGISTRY\n\n    mc: address = staticcall Registry(ripeHq).getAddr(RIPE_MISSION_CONTROL_ID)\n    if staticcall RipeMissionControl(mc).doesUndyLegoHaveAccess(_user, self):\n        return empty(address), empty(String[64]), 0\n\n    else:\n        teller: address = staticcall Registry(ripeHq).getAddr(RIPE_TELLER_ID)\n        return teller, LEGO_ACCESS_ABI, 1\n\n\n#########\n# Other #\n#########\n\n\n@external\ndef swapTokens(\n    _amountIn: uint256,\n    _minAmountOut: uint256,\n    _tokenPath: DynArray[address, MAX_TOKEN_PATH],\n    _poolPath: DynArray[address, MAX_TOKEN_PATH - 1],\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256):\n    return 0, 0, 0\n\n\n@external\ndef mintOrRedeemAsset(\n    _tokenIn: address,\n    _tokenOut: address,\n    _tokenInAmount: uint256,\n    _minAmountOut: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, bool, uint256):\n    return 0, 0, False, 0\n\n\n@external\ndef confirmMintOrRedeemAsset(\n    _tokenIn: address,\n    _tokenOut: address,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef addLiquidity(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _amountA: uint256,\n    _amountB: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _minLpAmount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (address, uint256, uint256, uint256, uint256):\n    return empty(address), 0, 0, 0, 0\n\n\n@external\ndef removeLiquidity(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpToken: address,\n    _lpAmount: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, uint256):\n    return 0, 0, 0, 0\n\n\n@external\ndef addLiquidityConcentrated(\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _tickLower: int24,\n    _tickUpper: int24,\n    _amountA: uint256,\n    _amountB: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, uint256, uint256):\n    return 0, 0, 0, 0, 0\n\n\n@external\ndef removeLiquidityConcentrated(\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _liqToRemove: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, bool, uint256):\n    return 0, 0, 0, False, 0",
            "sha256sum": "6e83e94998a1eab1f22ea735dd90b12777041193b81d25baa236c4cbe1039275"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/legos/RipeLego.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.3+commit.bff19ea2",
        "integrity": "0f7d1a1e4799d85d009b8a0427e735c6ea8ec0151c9ad02e367d304c14bdcf2f"
      },
      "args": "00000000000000000000000044cf3c4f000dfd76a35d03298049d37be688d6f90000000000000000000000006162df1b329e157479f8f1407e888260e0ec3d2b",
      "file": "contracts/legos/RipeLego.vy"
    },
    "AaveV3": {
      "address": "0x8B4fc1e68D4e1926cca5DD48F91156DE94EA87D7",
      "abi": [
        {
          "name": "AaveV3Deposit",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountDeposited",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultTokenAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AaveV3Withdrawal",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultTokenAmountBurned",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LegoPauseModified",
          "inputs": [
            {
              "name": "isPaused",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LegoFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "balance",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "SnapShotPriceConfigSet",
          "inputs": [
            {
              "name": "minSnapshotDelay",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "maxNumSnapshots",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "maxUpsideDeviation",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "staleTime",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetOpportunityAdded",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultAddr",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetOpportunityRemoved",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultAddr",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddys",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "undyToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "hatchery",
                  "type": "address"
                },
                {
                  "name": "lootDistributor",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                },
                {
                  "name": "walletBackpack",
                  "type": "address"
                },
                {
                  "name": "billing",
                  "type": "address"
                },
                {
                  "name": "vaultRegistry",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUndyHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isLegoAsset",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssetOpportunities",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isAssetOpportunity",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getNumLegoAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pause",
          "inputs": [
            {
              "name": "_shouldPause",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFundsMany",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_assets",
              "type": "address[]"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getWeightedPricePerShare",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLatestSnapshot",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_pricePerShare",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "totalSupply",
                  "type": "uint256"
                },
                {
                  "name": "pricePerShare",
                  "type": "uint256"
                },
                {
                  "name": "lastUpdate",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setSnapShotPriceConfig",
          "inputs": [
            {
              "name": "_config",
              "type": "tuple",
              "components": [
                {
                  "name": "minSnapshotDelay",
                  "type": "uint256"
                },
                {
                  "name": "maxNumSnapshots",
                  "type": "uint256"
                },
                {
                  "name": "maxUpsideDeviation",
                  "type": "uint256"
                },
                {
                  "name": "staleTime",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidPriceConfig",
          "inputs": [
            {
              "name": "_config",
              "type": "tuple",
              "components": [
                {
                  "name": "minSnapshotDelay",
                  "type": "uint256"
                },
                {
                  "name": "maxNumSnapshots",
                  "type": "uint256"
                },
                {
                  "name": "maxUpsideDeviation",
                  "type": "uint256"
                },
                {
                  "name": "staleTime",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "vaultToAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "underlyingAsset",
                  "type": "address"
                },
                {
                  "name": "decimals",
                  "type": "uint256"
                },
                {
                  "name": "lastAveragePricePerShare",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assetOpportunities",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAssetOpportunity",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssetOpportunities",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assets",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "snapShotData",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "lastSnapShot",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "totalSupply",
                      "type": "uint256"
                    },
                    {
                      "name": "pricePerShare",
                      "type": "uint256"
                    },
                    {
                      "name": "lastUpdate",
                      "type": "uint256"
                    }
                  ]
                },
                {
                  "name": "nextIndex",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "snapShots",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "totalSupply",
                  "type": "uint256"
                },
                {
                  "name": "pricePerShare",
                  "type": "uint256"
                },
                {
                  "name": "lastUpdate",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "snapShotPriceConfig",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "minSnapshotDelay",
                  "type": "uint256"
                },
                {
                  "name": "maxNumSnapshots",
                  "type": "uint256"
                },
                {
                  "name": "maxUpsideDeviation",
                  "type": "uint256"
                },
                {
                  "name": "staleTime",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isPaused",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasCapability",
          "inputs": [
            {
              "name": "_action",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRegistries",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isYieldLego",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isDexLego",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAsset",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingBalances",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenBalance",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAmount",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAmountSafe",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenBalance",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingData",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingData",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            },
            {
              "name": "_appraiser",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValueOfVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValueOfVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            },
            {
              "name": "_appraiser",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isRebasing",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPricePerShare",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPricePerShare",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_decimals",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getVaultTokenAmount",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_assetAmount",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isEligibleVaultForTrialFunds",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_underlyingAsset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isEligibleForYieldBonus",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalAssets",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalBorrows",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canRegisterVaultToken",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "registerVaultTokenLocally",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "underlyingAsset",
                  "type": "address"
                },
                {
                  "name": "decimals",
                  "type": "uint256"
                },
                {
                  "name": "lastAveragePricePerShare",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "deregisterVaultTokenLocally",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositForYield",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositForYield",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawFromYield",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawFromYield",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addPriceSnapshot",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAccessForLego",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_action",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "string"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasClaimableRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_tokenPath",
              "type": "address[]"
            },
            {
              "name": "_poolPath",
              "type": "address[]"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_tokenPath",
              "type": "address[]"
            },
            {
              "name": "_poolPath",
              "type": "address[]"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_tokenInAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_tokenInAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmMintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmMintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_borrowAsset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_borrowAsset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_paymentAsset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_paymentAsset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "AAVE_V3_POOL",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "AAVE_V3_ADDRESS_PROVIDER",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_undyHq",
              "type": "address"
            },
            {
              "name": "_aaveV3",
              "type": "address"
            },
            {
              "name": "_addressProvider",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "interfaces/WalletStructs.vyi": {
            "content": "# @version 0.4.3\n\nflag ActionType:\n    TRANSFER\n    EARN_DEPOSIT\n    EARN_WITHDRAW\n    EARN_REBALANCE\n    SWAP\n    MINT_REDEEM\n    CONFIRM_MINT_REDEEM\n    ADD_COLLATERAL\n    REMOVE_COLLATERAL\n    BORROW\n    REPAY_DEBT\n    REWARDS\n    ETH_TO_WETH\n    WETH_TO_ETH\n    ADD_LIQ\n    REMOVE_LIQ\n    ADD_LIQ_CONC\n    REMOVE_LIQ_CONC\n    PAY_CHEQUE\n\nstruct WalletAssetData:\n    assetBalance: uint256\n    usdValue: uint256\n    isYieldAsset: bool\n    lastPricePerShare: uint256\n\nstruct ActionData:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    billing: address\n    wallet: address\n    walletConfig: address\n    walletOwner: address\n    inEjectMode: bool\n    isFrozen: bool\n    lastTotalUsdValue: uint256\n    signer: address\n    isManager: bool\n    legoId: uint256\n    legoAddr: address\n    eth: address\n    weth: address\n\nstruct MiniAddys:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    appraiser: address",
            "sha256sum": "9a4b4f59b3a62043e51b425a665064aae419a3c0bd0514b6b29a9441ae364bb9"
          },
          "interfaces/LegoPartner.vyi": {
            "content": "# @version 0.4.3\n\nfrom interfaces import WalletStructs as ws\n\nMAX_TOKEN_PATH: constant(uint256) = 5\nMAX_RECOVER_ASSETS: constant(uint256) = 20\n\n@external\ndef addLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _tickLower: int24, _tickUpper: int24, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef addLiquidity(_pool: address, _tokenA: address, _tokenB: address, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _minLpAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (address, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef removeLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _liqToRemove: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef removeLiquidity(_pool: address, _tokenA: address, _tokenB: address, _lpToken: address, _lpAmount: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef mintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _tokenInAmount: uint256, _minAmountOut: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef swapTokens(_amountIn: uint256, _minAmountOut: uint256, _tokenPath: DynArray[address, MAX_TOKEN_PATH], _poolPath: DynArray[address, MAX_TOKEN_PATH - 1], _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256):\n    ...\n\n@external\ndef depositForYield(_asset: address, _amount: uint256, _vaultAddr: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef withdrawFromYield(_vaultToken: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef confirmMintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef borrow(_borrowAsset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef repayDebt(_paymentAsset: address, _paymentAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef claimRewards(_user: address, _rewardToken: address, _rewardAmount: uint256, _extraData: bytes32, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef removeCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef addCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@view\n@external\ndef getAccessForLego(_user: address, _action: ws.ActionType) -> (address, String[64], uint256):\n    ...\n\n@view\n@external\ndef hasCapability(_action: ws.ActionType) -> bool:\n    ...\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    ...\n\n@view\n@external\ndef isYieldLego() -> bool:\n    ...\n\n@view\n@external\ndef isDexLego() -> bool:\n    ...\n\n\n# common\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "81db71fe4440a3b4b563134c9b5caf1d5705772a5f291fe874c9b5fb3cfb1623"
          },
          "interfaces/LegoStructs.vyi": {
            "content": "# @version 0.4.3\n\nstruct VaultTokenInfo:\n    underlyingAsset: address\n    decimals: uint256\n    lastAveragePricePerShare: uint256\n\nstruct SnapShotPriceConfig:\n    minSnapshotDelay: uint256\n    maxNumSnapshots: uint256\n    maxUpsideDeviation: uint256\n    staleTime: uint256\n\nstruct SingleSnapShot:\n    totalSupply: uint256\n    pricePerShare: uint256\n    lastUpdate: uint256\n\nstruct SnapShotData:\n    lastSnapShot: SingleSnapShot\n    nextIndex: uint256\n",
            "sha256sum": "8ae48be17d812d57fbd671bbf0593e8abf175ad0924e47c5997823cac19ec806"
          },
          "interfaces/YieldLego.vyi": {
            "content": "# @version 0.4.3\n\nfrom interfaces import LegoStructs as ls\n\n\n###################\n# Underlying Data #\n###################\n\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    ...\n\n\n@view\n@external\ndef getUnderlyingBalances(_vaultToken: address, _vaultTokenBalance: uint256) -> (uint256, uint256):\n    ...\n\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    ...\n\n\n@view\n@external\ndef getUnderlyingAmountSafe(_vaultToken: address, _vaultTokenBalance: uint256) -> uint256:\n    ...\n\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> (address, uint256, uint256):\n    ...\n\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> uint256:\n    ...\n\n\n###############\n# Other Utils #\n###############\n\n\n@view\n@external\ndef isRebasing() -> bool:\n    ...\n\n\n@view\n@external\ndef getPricePerShare(_vaultToken: address, _decimals: uint256 = 0) -> uint256:\n    ...\n\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef canRegisterVaultToken(_asset: address, _vaultToken: address) -> bool:\n    ...\n\n\n@view\n@external\ndef isEligibleVaultForTrialFunds(_vaultToken: address, _underlyingAsset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef isEligibleForYieldBonus(_asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    ...\n\n\n###################\n# Yield Lego Data #\n###################\n\n\n@view\n@external\ndef isLegoAsset(_asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, 40]:\n    ...\n\n\n@view\n@external\ndef getAssets() -> DynArray[address, 20]:\n    ...\n\n\n@view\n@external\ndef isAssetOpportunity(_asset: address, _vaultAddr: address) -> bool:\n    ...\n\n\n@view\n@external\ndef getNumLegoAssets() -> uint256:\n    ...\n\n\n@view\n@external\ndef assets(_index: uint256) -> address:\n    ...\n\n\n@view\n@external\ndef indexOfAsset(_asset: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef numAssets() -> uint256:\n    ...\n\n\n@view\n@external\ndef assetOpportunities(_asset: address, _index: uint256) -> address:\n    ...\n\n\n@view\n@external\ndef indexOfAssetOpportunity(_asset: address, _vaultAddr: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef numAssetOpportunities(_asset: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef vaultToAsset(_vaultAddr: address) -> ls.VaultTokenInfo:\n    ...\n\n\n# price snapshots\n\n\n@external\ndef addPriceSnapshot(_vaultToken: address) -> bool:\n    ...\n\n\n@view\n@external\ndef snapShotPriceConfig() -> ls.SnapShotPriceConfig:\n    ...\n\n\n@view\n@external\ndef snapShotData(_vaultToken: address) -> ls.SnapShotData:\n    ...\n\n\n@view\n@external\ndef snapShots(_vaultToken: address, _index: uint256) -> ls.SingleSnapShot:\n    ...\n\n\n@view\n@external\ndef getWeightedPricePerShare(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef getLatestSnapshot(_vaultToken: address, _pricePerShare: uint256) -> ls.SingleSnapShot:\n    ...\n\n\n@external\ndef setSnapShotPriceConfig(_config: ls.SnapShotPriceConfig):\n    ...\n",
            "sha256sum": "045a6bbd3d556234cf4fe925a303002dc0ac3c482d344ffbaf4bc52a7e6ad2df"
          },
          "contracts/modules/Addys.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\ninterface UndyHq:\n    def isValidAddr(_addr: address) -> bool: view\n    def getAddr(_regId: uint256) -> address: view\n    def undyToken() -> address: view\n\ninterface Switchboard:\n    def isSwitchboardAddr(_addr: address) -> bool: view\n\ninterface LegoBook:\n    def isLegoAddr(_addr: address) -> bool: view\n\nstruct Addys:\n    hq: address\n    undyToken: address\n    ledger: address\n    missionControl: address\n    legoBook: address\n    switchboard: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    walletBackpack: address\n    billing: address\n    vaultRegistry: address\n\n# hq\nUNDY_HQ_FOR_ADDYS: immutable(address)\n\n# core addys\nLEDGER_ID: constant(uint256) = 1\nMISSION_CONTROL_ID: constant(uint256) = 2\nLEGO_BOOK_ID: constant(uint256) = 3\nSWITCHBOARD_ID: constant(uint256) = 4\nHATCHERY_ID: constant(uint256) = 5\nLOOT_DISTRIBUTOR_ID: constant(uint256) = 6\nAPPRAISER_ID: constant(uint256) = 7\nWALLET_BACKPACK_ID: constant(uint256) = 8\nBILLING_ID: constant(uint256) = 9\nVAULT_REGISTRY_ID: constant(uint256) = 10\n\n\n@deploy\ndef __init__(_undyHq: address):\n    assert _undyHq != empty(address) # dev: invalid undy hq\n    UNDY_HQ_FOR_ADDYS = _undyHq\n\n\n########\n# Core #\n########\n\n\n@view\n@external\ndef getAddys() -> Addys:\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _getAddys(_addys: Addys = empty(Addys)) -> Addys:\n    if _addys.hq != empty(address):\n        return _addys\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _generateAddys() -> Addys:\n    hq: address = UNDY_HQ_FOR_ADDYS\n    return Addys(\n        hq = hq,\n        undyToken = staticcall UndyHq(hq).undyToken(),\n        ledger = staticcall UndyHq(hq).getAddr(LEDGER_ID),\n        missionControl = staticcall UndyHq(hq).getAddr(MISSION_CONTROL_ID),\n        legoBook = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID),\n        switchboard = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID),\n        hatchery = staticcall UndyHq(hq).getAddr(HATCHERY_ID),\n        lootDistributor = staticcall UndyHq(hq).getAddr(LOOT_DISTRIBUTOR_ID),\n        appraiser = staticcall UndyHq(hq).getAddr(APPRAISER_ID),\n        walletBackpack = staticcall UndyHq(hq).getAddr(WALLET_BACKPACK_ID),\n        billing = staticcall UndyHq(hq).getAddr(BILLING_ID),\n        vaultRegistry = staticcall UndyHq(hq).getAddr(VAULT_REGISTRY_ID),\n    )\n\n\n##########\n# Tokens #\n##########\n\n\n@view\n@internal\ndef _getUndyToken() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).undyToken()\n\n\n###########\n# Helpers #\n###########\n\n\n# undy hq\n\n\n@view\n@external\ndef getUndyHq() -> address:\n    return self._getUndyHq()\n\n\n@view\n@internal\ndef _getUndyHq() -> address:\n    return UNDY_HQ_FOR_ADDYS\n\n\n# utils\n\n\n@view\n@internal\ndef _isValidUndyAddr(_addr: address, _hq: address = empty(address)) -> bool:\n    hq: address = _hq\n    if _hq == empty(address):\n        hq = UNDY_HQ_FOR_ADDYS\n    \n    # core departments\n    if staticcall UndyHq(hq).isValidAddr(_addr):\n        return True\n\n    # lego book\n    legoBook: address = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID)\n    if legoBook != empty(address) and staticcall LegoBook(legoBook).isLegoAddr(_addr):\n        return True\n\n    # switchboard config\n    switchboard: address = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID)\n    if switchboard != empty(address) and staticcall Switchboard(switchboard).isSwitchboardAddr(_addr):\n        return True\n\n    return False\n\n\n@view\n@internal\ndef _isSwitchboardAddr(_addr: address) -> bool:\n    switchboard: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n    if switchboard == empty(address):\n        return False\n    return staticcall Switchboard(switchboard).isSwitchboardAddr(_addr)\n\n\n@view\n@internal\ndef _isLegoBookAddr(_addr: address) -> bool:\n    legoBook: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n    if legoBook == empty(address):\n        return False\n    return staticcall LegoBook(legoBook).isLegoAddr(_addr)\n\n\n###############\n# Departments #\n###############\n\n\n# ledger\n\n\n@view\n@internal\ndef _getLedgerId() -> uint256:\n    return LEDGER_ID\n\n\n@view\n@internal\ndef _getLedgerAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEDGER_ID)\n\n\n# mission control\n\n\n@view\n@internal\ndef _getMissionControlId() -> uint256:\n    return MISSION_CONTROL_ID\n\n\n@view\n@internal\ndef _getMissionControlAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(MISSION_CONTROL_ID)\n\n\n# lego book\n\n\n@view\n@internal\ndef _getLegoBookId() -> uint256:\n    return LEGO_BOOK_ID\n\n\n@view\n@internal\ndef _getLegoBookAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n\n\n# switchboard\n\n\n@view\n@internal\ndef _getSwitchboardId() -> uint256:\n    return SWITCHBOARD_ID\n\n\n@view\n@internal\ndef _getSwitchboardAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n\n\n# hatchery\n\n\n@view\n@internal\ndef _getHatcheryId() -> uint256:\n    return HATCHERY_ID\n\n\n@view\n@internal\ndef _getHatcheryAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(HATCHERY_ID)\n\n\n# loot distributor\n\n\n@view\n@internal\ndef _getLootDistributorId() -> uint256:\n    return LOOT_DISTRIBUTOR_ID\n\n\n@view\n@internal\ndef _getLootDistributorAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LOOT_DISTRIBUTOR_ID)\n\n\n# appraiser\n\n\n@view\n@internal\ndef _getAppraiserId() -> uint256:\n    return APPRAISER_ID\n\n\n@view\n@internal\ndef _getAppraiserAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(APPRAISER_ID)\n\n\n# wallet backpack\n\n\n@view\n@internal\ndef _getWalletBackpackId() -> uint256:\n    return WALLET_BACKPACK_ID\n\n\n@view\n@internal\ndef _getWalletBackpackAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(WALLET_BACKPACK_ID)\n\n\n# billing\n\n\n@view\n@internal\ndef _getBillingId() -> uint256:\n    return BILLING_ID\n\n\n@view\n@internal\ndef _getBillingAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(BILLING_ID)\n\n\n# vault registry\n\n\n@view\n@internal\ndef _getVaultRegistryId() -> uint256:\n    return VAULT_REGISTRY_ID\n\n\n@view\n@internal\ndef _getVaultRegistryAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(VAULT_REGISTRY_ID)",
            "sha256sum": "4df6b72db9bb417d1af81660175be1450cfb7b3575f3d17a5b8a130bff87b781"
          },
          "contracts/modules/YieldLegoData.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nuses: addys\n\nimport contracts.modules.Addys as addys\n\nfrom interfaces import WalletStructs as ws\nfrom interfaces import LegoStructs as ls\nfrom ethereum.ercs import IERC20\nfrom ethereum.ercs import IERC20Detailed\n\nevent AssetOpportunityAdded:\n    asset: indexed(address)\n    vaultAddr: indexed(address)\n\nevent AssetOpportunityRemoved:\n    asset: indexed(address)\n    vaultAddr: indexed(address)\n\nevent LegoPauseModified:\n    isPaused: bool\n\nevent LegoFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    balance: uint256\n\nevent PricePerShareSnapShotAdded:\n    vaultToken: indexed(address)\n    totalSupply: uint256\n    pricePerShare: uint256\n\nevent SnapShotPriceConfigSet:\n    minSnapshotDelay: uint256\n    maxNumSnapshots: uint256\n    maxUpsideDeviation: uint256\n    staleTime: uint256\n\n# core\nvaultToAsset: public(HashMap[address, ls.VaultTokenInfo]) # vault addr -> data\n\n# asset opportunities\nassetOpportunities: public(HashMap[address, HashMap[uint256, address]]) # asset -> index -> vault addr\nindexOfAssetOpportunity: public(HashMap[address, HashMap[address, uint256]]) # asset -> vault addr -> index\nnumAssetOpportunities: public(HashMap[address, uint256]) # asset -> number of opportunities\n\n# lego assets (iterable)\nassets: public(HashMap[uint256, address]) # index -> asset\nindexOfAsset: public(HashMap[address, uint256]) # asset -> index\nnumAssets: public(uint256) # num assets\n\n# price snapshots\nsnapShotData: public(HashMap[address, ls.SnapShotData]) # vault token -> data\nsnapShots: public(HashMap[address, HashMap[uint256, ls.SingleSnapShot]]) # vault token -> index -> snapshot\nsnapShotPriceConfig: public(ls.SnapShotPriceConfig) # config\n\nisPaused: public(bool)\n\nMAX_VAULTS: constant(uint256) = 40\nMAX_ASSETS: constant(uint256) = 20\nMAX_RECOVER_ASSETS: constant(uint256) = 20\nONE_DAY_SECONDS: constant(uint256) = 60 * 60 * 24\nONE_WEEK_SECONDS: constant(uint256) = ONE_DAY_SECONDS * 7\nHUNDRED_PERCENT: constant(uint256) = 100_00\n\n\n@deploy\ndef __init__(_shouldPause: bool):\n    self.isPaused = _shouldPause\n    self.numAssets = 1 # not using 0 index\n\n    # default snapshot price config\n    self.snapShotPriceConfig = ls.SnapShotPriceConfig(\n        minSnapshotDelay = 60 * 10, # 10 minutes\n        maxNumSnapshots = 20,\n        maxUpsideDeviation = 10_00, # 10%\n        staleTime = 3 * ONE_DAY_SECONDS, # 3 days\n    )\n\n\n#########\n# Views #\n#########\n\n\n# is lego asset\n\n\n@view\n@external\ndef isLegoAsset(_asset: address) -> bool:\n    return self._isLegoAsset(_asset)\n\n\n@view\n@internal\ndef _isLegoAsset(_asset: address) -> bool:\n    return self.indexOfAsset[_asset] != 0\n\n\n# vault opportunities\n\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, MAX_VAULTS]:\n    numOpportunities: uint256 = self.numAssetOpportunities[_asset]\n    if numOpportunities == 0:\n        return []\n    opportunities: DynArray[address, MAX_VAULTS] = []\n    for i: uint256 in range(1, numOpportunities, bound=MAX_VAULTS):\n        opportunities.append(self.assetOpportunities[_asset][i])\n    return opportunities\n\n\n# all assets registered\n\n\n@view\n@external\ndef getAssets() -> DynArray[address, MAX_ASSETS]:\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return []\n    assets: DynArray[address, MAX_ASSETS] = []\n    for i: uint256 in range(1, numAssets, bound=MAX_ASSETS):\n        assets.append(self.assets[i])\n    return assets\n\n\n################\n# Registration #\n################\n\n\n@view\n@external\ndef isAssetOpportunity(_asset: address, _vaultAddr: address) -> bool:\n    return self._isAssetOpportunity(_asset, _vaultAddr)\n\n\n@view\n@internal\ndef _isAssetOpportunity(_asset: address, _vaultAddr: address) -> bool:\n    return self.indexOfAssetOpportunity[_asset][_vaultAddr] != 0\n\n\n# add asset opportunity\n\n\n@internal\ndef _addAssetOpportunity(_asset: address, _vaultAddr: address) -> ls.VaultTokenInfo:\n    if self.indexOfAssetOpportunity[_asset][_vaultAddr] != 0:\n        return self.vaultToAsset[_vaultAddr]\n\n    if empty(address) in [_asset, _vaultAddr]:\n        return empty(ls.VaultTokenInfo)\n\n    # add asset opportunity\n    aid: uint256 = self.numAssetOpportunities[_asset]\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.assetOpportunities[_asset][aid] = _vaultAddr\n    self.indexOfAssetOpportunity[_asset][_vaultAddr] = aid\n    self.numAssetOpportunities[_asset] = aid + 1\n\n    # add mapping\n    vaultInfo: ls.VaultTokenInfo = ls.VaultTokenInfo(\n        underlyingAsset = _asset,\n        decimals = convert(staticcall IERC20Detailed(_vaultAddr).decimals(), uint256),\n        lastAveragePricePerShare = 0,\n    )\n    self.vaultToAsset[_vaultAddr] = vaultInfo\n\n    # add asset\n    self._addAsset(_asset)\n\n    log AssetOpportunityAdded(asset=_asset, vaultAddr=_vaultAddr)\n    return vaultInfo\n\n\n# remove asset opportunity\n\n\n@internal\ndef _removeAssetOpportunity(_asset: address, _vaultAddr: address):\n    numOpportunities: uint256 = self.numAssetOpportunities[_asset]\n    if numOpportunities == 0:\n        return\n\n    targetIndex: uint256 = self.indexOfAssetOpportunity[_asset][_vaultAddr]\n    if targetIndex == 0:\n        return\n\n    # update data\n    lastIndex: uint256 = numOpportunities - 1\n    self.numAssetOpportunities[_asset] = lastIndex\n    self.indexOfAssetOpportunity[_asset][_vaultAddr] = 0\n\n    self.vaultToAsset[_vaultAddr] = empty(ls.VaultTokenInfo)\n\n    # shift to replace the removed one\n    if targetIndex != lastIndex:\n        lastVaultAddr: address = self.assetOpportunities[_asset][lastIndex]\n        self.assetOpportunities[_asset][targetIndex] = lastVaultAddr\n        self.indexOfAssetOpportunity[_asset][lastVaultAddr] = targetIndex\n\n    # remove asset\n    if lastIndex <= 1:\n        self._removeAsset(_asset)\n\n    log AssetOpportunityRemoved(asset=_asset, vaultAddr=_vaultAddr)\n\n\n# add asset\n\n\n@internal\ndef _addAsset(_asset: address):\n    if self.indexOfAsset[_asset] != 0:\n        return\n\n    aid: uint256 = self.numAssets\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.assets[aid] = _asset\n    self.indexOfAsset[_asset] = aid\n    self.numAssets = aid + 1\n\n\n# remove asset\n\n\n@internal\ndef _removeAsset(_asset: address):\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return\n\n    targetIndex: uint256 = self.indexOfAsset[_asset]\n    if targetIndex == 0:\n        return\n\n    # update data\n    lastIndex: uint256 = numAssets - 1\n    self.numAssets = lastIndex\n    self.indexOfAsset[_asset] = 0\n\n    # shift to replace the removed one\n    if targetIndex != lastIndex:\n        lastAsset: address = self.assets[lastIndex]\n        self.assets[targetIndex] = lastAsset\n        self.indexOfAsset[lastAsset] = targetIndex\n\n\n# num lego assets (true number, use `numAssets` for iteration)\n\n\n@view\n@external\ndef getNumLegoAssets() -> uint256:\n    return self._getNumLegoAssets()\n\n\n@view\n@internal\ndef _getNumLegoAssets() -> uint256:\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return 0\n    return numAssets - 1\n\n\n###########\n# General #\n###########\n\n\n# fill mini addys\n\n\n@view\n@internal\ndef _getMiniAddys(_miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> ws.MiniAddys:\n    if _miniAddys.ledger != empty(address):\n        return _miniAddys\n    return ws.MiniAddys(\n        ledger = addys._getLedgerAddr(),\n        missionControl = addys._getMissionControlAddr(),\n        legoBook = addys._getLegoBookAddr(),\n        appraiser = addys._getAppraiserAddr(),\n    )\n\n\n# activate\n\n\n@external\ndef pause(_shouldPause: bool):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert _shouldPause != self.isPaused # dev: no change\n    self.isPaused = _shouldPause\n    log LegoPauseModified(isPaused=_shouldPause)\n\n\n# recover funds\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    self._recoverFunds(_recipient, _asset)\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, MAX_RECOVER_ASSETS]):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    for a: address in _assets:\n        self._recoverFunds(_recipient, a)\n\n\n@internal\ndef _recoverFunds(_recipient: address, _asset: address):\n    assert empty(address) not in [_recipient, _asset] # dev: invalid recipient or asset\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    assert balance != 0 # dev: nothing to recover\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log LegoFundsRecovered(asset=_asset, recipient=_recipient, balance=balance)\n\n\n###################\n# Price Snapshots #\n###################\n\n\n# add price snapshot\n\n\n@internal\ndef _addPriceSnapshot(_vaultToken: address, _pricePerShare: uint256, _vaultTokenDecimals: uint256) -> bool:\n    config: ls.SnapShotPriceConfig = self.snapShotPriceConfig\n    if config.maxNumSnapshots == 0:\n        return False\n\n    data: ls.SnapShotData = self.snapShotData[_vaultToken]\n\n    # already have snapshot for this time\n    if data.lastSnapShot.lastUpdate == block.timestamp:\n        return False\n\n    # check if snapshot is too recent\n    if data.lastSnapShot.lastUpdate + config.minSnapshotDelay > block.timestamp:\n        return False\n\n    # create and store new snapshot\n    newSnapshot: ls.SingleSnapShot = self._getLatestSnapshot(_vaultToken, _pricePerShare, _vaultTokenDecimals, data.lastSnapShot, config)\n    data.lastSnapShot = newSnapshot\n    self.snapShots[_vaultToken][data.nextIndex] = newSnapshot\n\n    # update index\n    data.nextIndex += 1\n    if data.nextIndex >= config.maxNumSnapshots:\n        data.nextIndex = 0\n\n    # save snap shot data\n    self.snapShotData[_vaultToken] = data\n\n    # update cached weighted average price per share\n    self.vaultToAsset[_vaultToken].lastAveragePricePerShare = self._getWeightedPricePerShare(_vaultToken, _pricePerShare)\n\n    log PricePerShareSnapShotAdded(\n        vaultToken = _vaultToken,\n        totalSupply = newSnapshot.totalSupply,\n        pricePerShare = newSnapshot.pricePerShare,\n    )\n    return True\n\n\n# weighted price per share\n\n\n@view\n@external\ndef getWeightedPricePerShare(_vaultToken: address) -> uint256:\n    data: ls.SnapShotData = self.snapShotData[_vaultToken]\n    return self._getWeightedPricePerShare(_vaultToken, data.lastSnapShot.pricePerShare)\n\n\n@view\n@internal\ndef _getWeightedPricePerShare(_vaultToken: address, _lastPricePerShare: uint256) -> uint256:\n    config: ls.SnapShotPriceConfig = self.snapShotPriceConfig\n    if config.maxNumSnapshots == 0:\n        return 0\n\n    # calculate weighted average price using all valid snapshots\n    numerator: uint256 = 0\n    denominator: uint256 = 0\n    for i: uint256 in range(config.maxNumSnapshots, bound=max_value(uint256)):\n\n        snapShot: ls.SingleSnapShot = self.snapShots[_vaultToken][i]\n        if snapShot.pricePerShare == 0 or snapShot.totalSupply == 0 or snapShot.lastUpdate == 0:\n            continue\n\n        # too stale, skip\n        if config.staleTime != 0 and block.timestamp > snapShot.lastUpdate + config.staleTime:\n            continue\n\n        numerator += (snapShot.totalSupply * snapShot.pricePerShare)\n        denominator += snapShot.totalSupply\n\n    # weighted price per share\n    weightedPricePerShare: uint256 = 0\n    if numerator != 0:\n        weightedPricePerShare = numerator // denominator\n    else:\n        weightedPricePerShare = _lastPricePerShare\n\n    return weightedPricePerShare\n\n\n# latest snapshot\n\n\n@view\n@external\ndef getLatestSnapshot(_vaultToken: address, _pricePerShare: uint256) -> ls.SingleSnapShot:\n    data: ls.SnapShotData = self.snapShotData[_vaultToken]\n    config: ls.SnapShotPriceConfig = self.snapShotPriceConfig\n    vaultTokenDecimals: uint256 = self.vaultToAsset[_vaultToken].decimals\n    return self._getLatestSnapshot(_vaultToken, _pricePerShare, vaultTokenDecimals, data.lastSnapShot, config)\n\n\n@view\n@internal\ndef _getLatestSnapshot(\n    _vaultToken: address,\n    _pricePerShare: uint256,\n    _vaultTokenDecimals: uint256,\n    _lastSnapShot: ls.SingleSnapShot,\n    _config: ls.SnapShotPriceConfig,\n) -> ls.SingleSnapShot:\n\n    # total supply (adjusted)\n    totalSupply: uint256 = staticcall IERC20(_vaultToken).totalSupply() // (10 ** _vaultTokenDecimals)\n    if totalSupply == 0:\n        totalSupply = 1\n\n    # throttle upside (extra safety check)\n    pricePerShare: uint256 = self._throttleUpside(_pricePerShare, _lastSnapShot.pricePerShare, _config.maxUpsideDeviation)\n\n    return ls.SingleSnapShot(\n        totalSupply = totalSupply,\n        pricePerShare = pricePerShare,\n        lastUpdate = block.timestamp,\n    )\n\n\n@view\n@internal\ndef _throttleUpside(_newValue: uint256, _prevValue: uint256, _maxUpside: uint256) -> uint256:\n    if _maxUpside == 0 or _prevValue == 0 or _newValue == 0:\n        return _newValue\n    maxPricePerShare: uint256 = _prevValue + (_prevValue * _maxUpside // HUNDRED_PERCENT)\n    return min(_newValue, maxPricePerShare)\n\n\n# snapshot price config\n\n\n@external\ndef setSnapShotPriceConfig(_config: ls.SnapShotPriceConfig):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert self._isValidPriceConfig(_config) # dev: invalid config\n    self.snapShotPriceConfig = _config\n    log SnapShotPriceConfigSet(\n        minSnapshotDelay=_config.minSnapshotDelay,\n        maxNumSnapshots=_config.maxNumSnapshots,\n        maxUpsideDeviation=_config.maxUpsideDeviation,\n        staleTime=_config.staleTime\n    )\n\n\n@view\n@external\ndef isValidPriceConfig(_config: ls.SnapShotPriceConfig) -> bool:\n    return self._isValidPriceConfig(_config)\n\n\n@view\n@internal\ndef _isValidPriceConfig(_config: ls.SnapShotPriceConfig) -> bool:\n    if _config.minSnapshotDelay > ONE_WEEK_SECONDS:\n        return False\n    if _config.maxNumSnapshots == 0 or _config.maxNumSnapshots > 25:\n        return False\n    if _config.maxUpsideDeviation > HUNDRED_PERCENT:\n        return False\n    return _config.staleTime < ONE_WEEK_SECONDS",
            "sha256sum": "d695c6d3998cf2ed318a0da6f4f7918abf97661e10eb510ed996d815e65927e0"
          },
          "contracts/legos/yield/AaveV3.vy": {
            "content": "#     __   __ ___ _______ ___     ______       ___     _______ _______ _______ \n#    |  | |  |   |       |   |   |      |     |   |   |       |       |       |\n#    |  |_|  |   |    ___|   |   |  _    |    |   |   |    ___|    ___|   _   |\n#    |       |   |   |___|   |   | | |   |    |   |   |   |___|   | __|  | |  |\n#    |_     _|   |    ___|   |___| |_|   |    |   |___|    ___|   ||  |  |_|  |\n#      |   | |   |   |___|       |       |    |       |   |___|   |_| |       |\n#      |___| |___|_______|_______|______|     |_______|_______|_______|_______|\n#                                                                       \n#     \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n#     \u2551  ** Aave V3 Lego **                    \u2551\n#     \u2551  Integration with Aave Protocol (v3)   \u2551\n#     \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n#\n#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nimplements: Lego\nimplements: YieldLego\n\nexports: addys.__interface__\nexports: yld.__interface__\n\ninitializes: addys\ninitializes: yld[addys := addys]\n\nfrom interfaces import LegoPartner as Lego\nfrom interfaces import YieldLego as YieldLego\nfrom interfaces import WalletStructs as ws\nfrom interfaces import LegoStructs as ls\n\nimport contracts.modules.Addys as addys\nimport contracts.modules.YieldLegoData as yld\n\nfrom ethereum.ercs import IERC20\n\ninterface Appraiser:\n    def getUsdValue(_asset: address, _amount: uint256, _missionControl: address = empty(address), _legoBook: address = empty(address), _ledger: address = empty(address)) -> uint256: view\n    def updatePriceAndGetUsdValue(_asset: address, _amount: uint256, _missionControl: address = empty(address), _legoBook: address = empty(address)) -> uint256: nonpayable\n\ninterface Ledger:\n    def setVaultToken(_vaultToken: address, _legoId: uint256, _underlyingAsset: address, _decimals: uint256, _isRebasing: bool): nonpayable\n    def isRegisteredVaultToken(_vaultToken: address) -> bool: view\n\ninterface AaveV3Pool:\n    def supply(_asset: address, _amount: uint256, _onBehalfOf: address, _referralCode: uint16): nonpayable\n    def withdraw(_asset: address, _amount: uint256, _to: address): nonpayable\n\ninterface AaveProtocolDataProvider:\n    def getReserveTokensAddresses(_asset: address) -> (address, address, address): view\n    def getTotalDebt(_asset: address) -> uint256: view\n\ninterface AToken:\n    def UNDERLYING_ASSET_ADDRESS() -> address: view\n    def totalSupply() -> uint256: view\n\ninterface Registry:\n    def getRegId(_addr: address) -> uint256: view\n\ninterface AaveV3AddressProvider:\n    def getPoolDataProvider() -> address: view\n\nevent AaveV3Deposit:\n    sender: indexed(address)\n    asset: indexed(address)\n    vaultToken: indexed(address)\n    assetAmountDeposited: uint256\n    usdValue: uint256\n    vaultTokenAmountReceived: uint256\n    recipient: address\n\nevent AaveV3Withdrawal:\n    sender: indexed(address)\n    asset: indexed(address)\n    vaultToken: indexed(address)\n    assetAmountReceived: uint256\n    usdValue: uint256\n    vaultTokenAmountBurned: uint256\n    recipient: address\n\n# aave v3\nAAVE_V3_POOL: public(immutable(address))\nAAVE_V3_ADDRESS_PROVIDER: public(immutable(address))\n\nMAX_TOKEN_PATH: constant(uint256) = 5\n\n\n@deploy\ndef __init__(\n    _undyHq: address,\n    _aaveV3: address,\n    _addressProvider: address,\n):\n    addys.__init__(_undyHq)\n    yld.__init__(False)\n\n    assert empty(address) not in [_aaveV3, _addressProvider] # dev: invalid addrs\n    AAVE_V3_POOL = _aaveV3\n    AAVE_V3_ADDRESS_PROVIDER = _addressProvider\n\n\n@view\n@external\ndef hasCapability(_action: ws.ActionType) -> bool:\n    return _action in (\n        ws.ActionType.EARN_DEPOSIT | \n        ws.ActionType.EARN_WITHDRAW\n    )\n\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    return [AAVE_V3_POOL, AAVE_V3_ADDRESS_PROVIDER]\n\n\n@view\n@external\ndef isYieldLego() -> bool:\n    return True\n\n\n@view\n@external\ndef isDexLego() -> bool:\n    return False\n\n\n# helper\n\n\n@view\n@internal\ndef _getPoolDataProvider() -> address:\n    return staticcall AaveV3AddressProvider(AAVE_V3_ADDRESS_PROVIDER).getPoolDataProvider()\n\n\n###################\n# Underlying Data #\n###################\n\n\n# underlying asset\n\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    return self._getUnderlyingAsset(_vaultToken)\n\n\n@view\n@internal\ndef _getUnderlyingAsset(_vaultToken: address) -> address:\n    return yld.vaultToAsset[_vaultToken].underlyingAsset\n\n\n# underlying balances (both true and safe)\n\n\n@view\n@external\ndef getUnderlyingBalances(_vaultToken: address, _vaultTokenBalance: uint256) -> (uint256, uint256):\n    return _vaultTokenBalance, _vaultTokenBalance\n\n\n# underlying amount (true)\n\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    return self._getUnderlyingAmount(_vaultToken, _vaultTokenAmount)\n\n\n@view\n@internal\ndef _getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    # treated as 1:1\n    return _vaultTokenAmount\n\n\n# underlying amount (safe)\n\n\n@view\n@external\ndef getUnderlyingAmountSafe(_vaultToken: address, _vaultTokenBalance: uint256) -> uint256:\n    # treated as 1:1\n    return _vaultTokenBalance\n\n\n# underlying data (combined)\n\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> (address, uint256, uint256):\n    return self._getUnderlyingData(_vaultToken, _vaultTokenAmount, _appraiser)\n\n\n@view\n@internal\ndef _getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address) -> (address, uint256, uint256):\n    asset: address = self._getUnderlyingAsset(_vaultToken)\n    if asset == empty(address):\n        return empty(address), 0, 0 # invalid vault token\n    underlyingAmount: uint256 = self._getUnderlyingAmount(_vaultToken, _vaultTokenAmount)\n    usdValue: uint256 = self._getUsdValue(asset, underlyingAmount, _appraiser)\n    return asset, underlyingAmount, usdValue\n\n\n# usd value\n\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> uint256:\n    return self._getUsdValueOfVaultToken(_vaultToken, _vaultTokenAmount, _appraiser)\n\n\n@view\n@internal\ndef _getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address) -> uint256:\n    return self._getUnderlyingData(_vaultToken, _vaultTokenAmount, _appraiser)[2]\n\n\n@view\n@internal\ndef _getUsdValue(_asset: address, _amount: uint256, _appraiser: address) -> uint256:\n    appraiser: address = _appraiser\n    if _appraiser == empty(address):\n        appraiser = addys._getAppraiserAddr()\n    return staticcall Appraiser(appraiser).getUsdValue(_asset, _amount)\n\n\n###############\n# Other Utils #\n###############\n\n\n# basics\n\n\n@view\n@external\ndef isRebasing() -> bool:\n    return self._isRebasing()\n\n\n@view\n@internal\ndef _isRebasing() -> bool:\n    return True\n\n\n# price per share\n\n\n@view\n@external\ndef getPricePerShare(_vaultToken: address, _decimals: uint256 = 0) -> uint256:\n    decimals: uint256 = _decimals\n    if decimals == 0:\n        decimals = yld.vaultToAsset[_vaultToken].decimals\n    if decimals == 0:\n        return 0 # not registered\n    return self._getPricePerShare(_vaultToken, decimals)\n\n\n@view\n@internal\ndef _getPricePerShare(_vaultToken: address, _decimals: uint256) -> uint256:\n    return 10 ** _decimals # treated as 1:1\n\n\n# vault token amount\n\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    return _assetAmount # treated as 1:1\n\n\n# extras\n\n\n@view\n@external\ndef isEligibleVaultForTrialFunds(_vaultToken: address, _underlyingAsset: address) -> bool:\n    return False\n\n\n@view\n@external\ndef isEligibleForYieldBonus(_asset: address) -> bool:\n    return False\n\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    return staticcall AToken(_vaultToken).totalSupply()\n\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    asset: address = self._getUnderlyingAsset(_vaultToken)\n    if asset == empty(address):\n        return 0 # not registered\n    return staticcall AaveProtocolDataProvider(self._getPoolDataProvider()).getTotalDebt(asset)\n\n\n################\n# Registration #\n################\n\n\n# can vault be registered\n\n\n@view\n@external\ndef canRegisterVaultToken(_asset: address, _vaultToken: address) -> bool:\n    return self._canRegisterVaultToken(_asset, _vaultToken)\n\n\n@view\n@internal\ndef _canRegisterVaultToken(_asset: address, _vaultToken: address) -> bool:\n    if empty(address) in [_asset, _vaultToken]:\n        return False\n    if staticcall AToken(_vaultToken).UNDERLYING_ASSET_ADDRESS() != _asset:\n        return False\n    vaultToken: address = (staticcall AaveProtocolDataProvider(self._getPoolDataProvider()).getReserveTokensAddresses(_asset))[0]\n    return vaultToken == _vaultToken\n\n\n# register vault token locally\n\n\n@external\ndef registerVaultTokenLocally(_asset: address, _vaultAddr: address) -> ls.VaultTokenInfo:\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert self._canRegisterVaultToken(_asset, _vaultAddr) # dev: cannot register vault token\n    assert not yld._isAssetOpportunity(_asset, _vaultAddr) # dev: already registered\n    vaultInfo: ls.VaultTokenInfo = self._registerVaultTokenLocally(_asset, _vaultAddr)\n    self._registerVaultTokenGlobally(_asset, _vaultAddr, vaultInfo.decimals, addys._getLedgerAddr(), addys._getLegoBookAddr())\n    return vaultInfo\n\n\n@internal\ndef _registerVaultTokenLocally(_asset: address, _vaultAddr: address) -> ls.VaultTokenInfo:\n    assert extcall IERC20(_asset).approve(AAVE_V3_POOL, max_value(uint256), default_return_value=True) # dev: max approval failed\n    vaultInfo: ls.VaultTokenInfo = yld._addAssetOpportunity(_asset, _vaultAddr)\n    assert vaultInfo.decimals != 0 # dev: invalid vault token\n    return vaultInfo\n\n\n# remove vault token locally\n\n\n@external\ndef deregisterVaultTokenLocally(_asset: address, _vaultAddr: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert yld._isAssetOpportunity(_asset, _vaultAddr) # dev: already registered\n    self._deregisterVaultTokenLocally(_asset, _vaultAddr)\n\n\n@internal\ndef _deregisterVaultTokenLocally(_asset: address, _vaultAddr: address):\n    assert extcall IERC20(_asset).approve(AAVE_V3_POOL, 0, default_return_value=True) # dev: max approval failed\n    yld._removeAssetOpportunity(_asset, _vaultAddr)\n\n\n# ledger registration\n\n\n@internal\ndef _registerVaultTokenGlobally(_underlyingAsset: address, _vaultToken: address, _decimals: uint256, _ledger: address, _legoBook: address):\n    if not staticcall Ledger(_ledger).isRegisteredVaultToken(_vaultToken):\n        legoId: uint256 = staticcall Registry(_legoBook).getRegId(self)\n        extcall Ledger(_ledger).setVaultToken(_vaultToken, legoId, _underlyingAsset, _decimals, self._isRebasing())\n\n\n#################\n# Yield Actions #\n#################\n\n\n# deposit\n\n\n@external\ndef depositForYield(\n    _asset: address,\n    _amount: uint256,\n    _vaultAddr: address,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, address, uint256, uint256):\n    assert not yld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = yld._getMiniAddys(_miniAddys)\n    vaultInfo: ls.VaultTokenInfo = self._getVaultInfoOnDeposit(_asset, _vaultAddr, miniAddys.ledger, miniAddys.legoBook)\n\n    # pre balances\n    preRecipientVaultBalance: uint256 = staticcall IERC20(_vaultAddr).balanceOf(_recipient)\n    preLegoBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n\n    # transfer deposit asset to this contract\n    depositAmount: uint256 = min(_amount, staticcall IERC20(_asset).balanceOf(msg.sender))\n    assert depositAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_asset).transferFrom(msg.sender, self, depositAmount, default_return_value=True) # dev: transfer failed\n\n    # deposit assets into lego partner\n    extcall AaveV3Pool(AAVE_V3_POOL).supply(_asset, depositAmount, _recipient, 0)\n\n    # validate vault token transfer\n    vaultTokenAmountReceived: uint256 = staticcall IERC20(_vaultAddr).balanceOf(_recipient) - preRecipientVaultBalance\n    assert vaultTokenAmountReceived != 0 # dev: no vault tokens received\n\n    # refund if full deposit didn't get through\n    currentLegoBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    refundAssetAmount: uint256 = 0\n    if currentLegoBalance > preLegoBalance:\n        refundAssetAmount = currentLegoBalance - preLegoBalance\n        assert extcall IERC20(_asset).transfer(msg.sender, refundAssetAmount, default_return_value=True) # dev: transfer failed\n        depositAmount -= refundAssetAmount\n\n    usdValue: uint256 = extcall Appraiser(miniAddys.appraiser).updatePriceAndGetUsdValue(_asset, depositAmount, miniAddys.missionControl, miniAddys.legoBook)\n    log AaveV3Deposit(\n        sender = msg.sender,\n        asset = _asset,\n        vaultToken = _vaultAddr,\n        assetAmountDeposited = depositAmount,\n        usdValue = usdValue,\n        vaultTokenAmountReceived = vaultTokenAmountReceived,\n        recipient = _recipient,\n    )\n    return depositAmount, _vaultAddr, vaultTokenAmountReceived, usdValue\n\n\n# vault info on deposit\n\n\n@internal\ndef _getVaultInfoOnDeposit(_asset: address, _vaultAddr: address, _ledger: address, _legoBook: address) -> ls.VaultTokenInfo:\n    vaultInfo: ls.VaultTokenInfo = yld.vaultToAsset[_vaultAddr]\n    if vaultInfo.decimals == 0:\n        assert self._canRegisterVaultToken(_asset, _vaultAddr) # dev: cannot register vault token\n        vaultInfo = self._registerVaultTokenLocally(_asset, _vaultAddr)\n        self._registerVaultTokenGlobally(_asset, _vaultAddr, vaultInfo.decimals, _ledger, _legoBook)\n    else:\n        assert vaultInfo.underlyingAsset == _asset # dev: asset mismatch\n    return vaultInfo\n\n\n# withdraw\n\n\n@external\ndef withdrawFromYield(\n    _vaultToken: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, address, uint256, uint256):\n    assert not yld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = yld._getMiniAddys(_miniAddys)\n    vaultInfo: ls.VaultTokenInfo = self._getVaultInfoOnWithdrawal(_vaultToken, miniAddys.ledger, miniAddys.legoBook)\n\n    # pre balances\n    preRecipientAssetBalance: uint256 = staticcall IERC20(vaultInfo.underlyingAsset).balanceOf(_recipient)\n    preLegoVaultBalance: uint256 = staticcall IERC20(_vaultToken).balanceOf(self)\n\n    # transfer vaults tokens to this contract\n    vaultTokenAmount: uint256 = min(_amount, staticcall IERC20(_vaultToken).balanceOf(msg.sender))\n    assert vaultTokenAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_vaultToken).transferFrom(msg.sender, self, vaultTokenAmount, default_return_value=True) # dev: transfer failed\n\n    # withdraw assets from lego partner\n    extcall AaveV3Pool(AAVE_V3_POOL).withdraw(vaultInfo.underlyingAsset, max_value(uint256), _recipient)\n\n    # validate asset transfer\n    assetAmountReceived: uint256 = staticcall IERC20(vaultInfo.underlyingAsset).balanceOf(_recipient) - preRecipientAssetBalance\n    assert assetAmountReceived != 0 # dev: no asset amount received\n\n    # refund if full withdrawal didn't happen\n    currentLegoVaultBalance: uint256 = staticcall IERC20(_vaultToken).balanceOf(self)\n    refundVaultTokenAmount: uint256 = 0\n    if currentLegoVaultBalance > preLegoVaultBalance:\n        refundVaultTokenAmount = currentLegoVaultBalance - preLegoVaultBalance\n        assert extcall IERC20(_vaultToken).transfer(msg.sender, refundVaultTokenAmount, default_return_value=True) # dev: transfer failed\n        vaultTokenAmount -= refundVaultTokenAmount\n\n    usdValue: uint256 = extcall Appraiser(miniAddys.appraiser).updatePriceAndGetUsdValue(vaultInfo.underlyingAsset, assetAmountReceived, miniAddys.missionControl, miniAddys.legoBook)\n    log AaveV3Withdrawal(\n        sender = msg.sender,\n        asset = vaultInfo.underlyingAsset,\n        vaultToken = _vaultToken,\n        assetAmountReceived = assetAmountReceived,\n        usdValue = usdValue,\n        vaultTokenAmountBurned = vaultTokenAmount,\n        recipient = _recipient,\n    )\n    return vaultTokenAmount, vaultInfo.underlyingAsset, assetAmountReceived, usdValue\n\n\n# vault info on withdrawal\n\n\n@internal\ndef _getVaultInfoOnWithdrawal(_vaultAddr: address, _ledger: address, _legoBook: address) -> ls.VaultTokenInfo:\n    vaultInfo: ls.VaultTokenInfo = yld.vaultToAsset[_vaultAddr]\n    if vaultInfo.decimals == 0:\n        asset: address = staticcall AToken(_vaultAddr).UNDERLYING_ASSET_ADDRESS()\n        assert self._canRegisterVaultToken(asset, _vaultAddr) # dev: cannot register vault token\n        vaultInfo = self._registerVaultTokenLocally(asset, _vaultAddr)\n        self._registerVaultTokenGlobally(asset, _vaultAddr, vaultInfo.decimals, _ledger, _legoBook)\n    return vaultInfo\n\n\n#########\n# Other #\n#########\n\n\n@external\ndef addPriceSnapshot(_vaultToken: address) -> bool:\n    # no need for snapshots\n    return False\n\n\n@view\n@external\ndef getAccessForLego(_user: address, _action: ws.ActionType) -> (address, String[64], uint256):\n    return empty(address), empty(String[64]), 0\n\n\n@external\ndef claimRewards(\n    _user: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _extraData: bytes32,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@view\n@external\ndef hasClaimableRewards(_user: address) -> bool:\n    return False\n\n\n@external\ndef swapTokens(\n    _amountIn: uint256,\n    _minAmountOut: uint256,\n    _tokenPath: DynArray[address, MAX_TOKEN_PATH],\n    _poolPath: DynArray[address, MAX_TOKEN_PATH - 1],\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256):\n    return 0, 0, 0\n\n\n@external\ndef mintOrRedeemAsset(\n    _tokenIn: address,\n    _tokenOut: address,\n    _tokenInAmount: uint256,\n    _minAmountOut: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, bool, uint256):\n    return 0, 0, False, 0\n\n\n@external\ndef confirmMintOrRedeemAsset(\n    _tokenIn: address,\n    _tokenOut: address,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef addCollateral(\n    _asset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef removeCollateral(\n    _asset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef borrow(\n    _borrowAsset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef repayDebt(\n    _paymentAsset: address,\n    _paymentAmount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef addLiquidity(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _amountA: uint256,\n    _amountB: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _minLpAmount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (address, uint256, uint256, uint256, uint256):\n    return empty(address), 0, 0, 0, 0\n\n\n@external\ndef removeLiquidity(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpToken: address,\n    _lpAmount: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, uint256):\n    return 0, 0, 0, 0\n\n\n@external\ndef addLiquidityConcentrated(\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _tickLower: int24,\n    _tickUpper: int24,\n    _amountA: uint256,\n    _amountB: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, uint256, uint256):\n    return 0, 0, 0, 0, 0\n\n\n@external\ndef removeLiquidityConcentrated(\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _liqToRemove: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, bool, uint256):\n    return 0, 0, 0, False, 0",
            "sha256sum": "e3049599f0e3d87bfcc7770d20556b15b45cc0bed927822ed629305aa5f03b26"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/legos/yield/AaveV3.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.3+commit.bff19ea2",
        "integrity": "9945706871c45c001c940fa44e2a034bf009bf6693bc50875b3ae2a19e9941fa"
      },
      "args": "00000000000000000000000044cf3c4f000dfd76a35d03298049d37be688d6f9000000000000000000000000a238dd80c259a72e81d7e4664a9801593f98d1c5000000000000000000000000e20fcbdbffc4dd138ce8b2e6fbb6cb49777ad64d",
      "file": "contracts/legos/yield/AaveV3.vy"
    },
    "CompoundV3": {
      "address": "0xD781dd3a07b9b6EF2A6ed60b8821828cF6DC4a09",
      "abi": [
        {
          "name": "CompoundV3Deposit",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountDeposited",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultTokenAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "CompoundV3Withdrawal",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultTokenAmountBurned",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "CompoundV3RewardsAddrSet",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LegoPauseModified",
          "inputs": [
            {
              "name": "isPaused",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LegoFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "balance",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "SnapShotPriceConfigSet",
          "inputs": [
            {
              "name": "minSnapshotDelay",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "maxNumSnapshots",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "maxUpsideDeviation",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "staleTime",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetOpportunityAdded",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultAddr",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetOpportunityRemoved",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultAddr",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddys",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "undyToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "hatchery",
                  "type": "address"
                },
                {
                  "name": "lootDistributor",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                },
                {
                  "name": "walletBackpack",
                  "type": "address"
                },
                {
                  "name": "billing",
                  "type": "address"
                },
                {
                  "name": "vaultRegistry",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUndyHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isLegoAsset",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssetOpportunities",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isAssetOpportunity",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getNumLegoAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pause",
          "inputs": [
            {
              "name": "_shouldPause",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFundsMany",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_assets",
              "type": "address[]"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getWeightedPricePerShare",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLatestSnapshot",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_pricePerShare",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "totalSupply",
                  "type": "uint256"
                },
                {
                  "name": "pricePerShare",
                  "type": "uint256"
                },
                {
                  "name": "lastUpdate",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setSnapShotPriceConfig",
          "inputs": [
            {
              "name": "_config",
              "type": "tuple",
              "components": [
                {
                  "name": "minSnapshotDelay",
                  "type": "uint256"
                },
                {
                  "name": "maxNumSnapshots",
                  "type": "uint256"
                },
                {
                  "name": "maxUpsideDeviation",
                  "type": "uint256"
                },
                {
                  "name": "staleTime",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidPriceConfig",
          "inputs": [
            {
              "name": "_config",
              "type": "tuple",
              "components": [
                {
                  "name": "minSnapshotDelay",
                  "type": "uint256"
                },
                {
                  "name": "maxNumSnapshots",
                  "type": "uint256"
                },
                {
                  "name": "maxUpsideDeviation",
                  "type": "uint256"
                },
                {
                  "name": "staleTime",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "vaultToAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "underlyingAsset",
                  "type": "address"
                },
                {
                  "name": "decimals",
                  "type": "uint256"
                },
                {
                  "name": "lastAveragePricePerShare",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assetOpportunities",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAssetOpportunity",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssetOpportunities",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assets",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "snapShotData",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "lastSnapShot",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "totalSupply",
                      "type": "uint256"
                    },
                    {
                      "name": "pricePerShare",
                      "type": "uint256"
                    },
                    {
                      "name": "lastUpdate",
                      "type": "uint256"
                    }
                  ]
                },
                {
                  "name": "nextIndex",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "snapShots",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "totalSupply",
                  "type": "uint256"
                },
                {
                  "name": "pricePerShare",
                  "type": "uint256"
                },
                {
                  "name": "lastUpdate",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "snapShotPriceConfig",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "minSnapshotDelay",
                  "type": "uint256"
                },
                {
                  "name": "maxNumSnapshots",
                  "type": "uint256"
                },
                {
                  "name": "maxUpsideDeviation",
                  "type": "uint256"
                },
                {
                  "name": "staleTime",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isPaused",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasCapability",
          "inputs": [
            {
              "name": "_action",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRegistries",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isYieldLego",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isDexLego",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAsset",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingBalances",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenBalance",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAmount",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAmountSafe",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenBalance",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingData",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingData",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            },
            {
              "name": "_appraiser",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValueOfVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValueOfVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            },
            {
              "name": "_appraiser",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isRebasing",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPricePerShare",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPricePerShare",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_decimals",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getVaultTokenAmount",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_assetAmount",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isEligibleVaultForTrialFunds",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_underlyingAsset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isEligibleForYieldBonus",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalAssets",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalBorrows",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canRegisterVaultToken",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "registerVaultTokenLocally",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "underlyingAsset",
                  "type": "address"
                },
                {
                  "name": "decimals",
                  "type": "uint256"
                },
                {
                  "name": "lastAveragePricePerShare",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "deregisterVaultTokenLocally",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositForYield",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositForYield",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawFromYield",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawFromYield",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "hasClaimableRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setCompRewardsAddr",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addPriceSnapshot",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAccessForLego",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_action",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "string"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_tokenPath",
              "type": "address[]"
            },
            {
              "name": "_poolPath",
              "type": "address[]"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_tokenPath",
              "type": "address[]"
            },
            {
              "name": "_poolPath",
              "type": "address[]"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_tokenInAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_tokenInAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmMintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmMintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_borrowAsset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_borrowAsset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_paymentAsset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_paymentAsset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "compoundRewards",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "COMPOUND_V3_CONFIGURATOR",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_undyHq",
              "type": "address"
            },
            {
              "name": "_configurator",
              "type": "address"
            },
            {
              "name": "_compRewards",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "interfaces/WalletStructs.vyi": {
            "content": "# @version 0.4.3\n\nflag ActionType:\n    TRANSFER\n    EARN_DEPOSIT\n    EARN_WITHDRAW\n    EARN_REBALANCE\n    SWAP\n    MINT_REDEEM\n    CONFIRM_MINT_REDEEM\n    ADD_COLLATERAL\n    REMOVE_COLLATERAL\n    BORROW\n    REPAY_DEBT\n    REWARDS\n    ETH_TO_WETH\n    WETH_TO_ETH\n    ADD_LIQ\n    REMOVE_LIQ\n    ADD_LIQ_CONC\n    REMOVE_LIQ_CONC\n    PAY_CHEQUE\n\nstruct WalletAssetData:\n    assetBalance: uint256\n    usdValue: uint256\n    isYieldAsset: bool\n    lastPricePerShare: uint256\n\nstruct ActionData:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    billing: address\n    wallet: address\n    walletConfig: address\n    walletOwner: address\n    inEjectMode: bool\n    isFrozen: bool\n    lastTotalUsdValue: uint256\n    signer: address\n    isManager: bool\n    legoId: uint256\n    legoAddr: address\n    eth: address\n    weth: address\n\nstruct MiniAddys:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    appraiser: address",
            "sha256sum": "9a4b4f59b3a62043e51b425a665064aae419a3c0bd0514b6b29a9441ae364bb9"
          },
          "interfaces/LegoPartner.vyi": {
            "content": "# @version 0.4.3\n\nfrom interfaces import WalletStructs as ws\n\nMAX_TOKEN_PATH: constant(uint256) = 5\nMAX_RECOVER_ASSETS: constant(uint256) = 20\n\n@external\ndef addLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _tickLower: int24, _tickUpper: int24, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef addLiquidity(_pool: address, _tokenA: address, _tokenB: address, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _minLpAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (address, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef removeLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _liqToRemove: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef removeLiquidity(_pool: address, _tokenA: address, _tokenB: address, _lpToken: address, _lpAmount: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef mintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _tokenInAmount: uint256, _minAmountOut: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef swapTokens(_amountIn: uint256, _minAmountOut: uint256, _tokenPath: DynArray[address, MAX_TOKEN_PATH], _poolPath: DynArray[address, MAX_TOKEN_PATH - 1], _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256):\n    ...\n\n@external\ndef depositForYield(_asset: address, _amount: uint256, _vaultAddr: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef withdrawFromYield(_vaultToken: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef confirmMintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef borrow(_borrowAsset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef repayDebt(_paymentAsset: address, _paymentAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef claimRewards(_user: address, _rewardToken: address, _rewardAmount: uint256, _extraData: bytes32, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef removeCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef addCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@view\n@external\ndef getAccessForLego(_user: address, _action: ws.ActionType) -> (address, String[64], uint256):\n    ...\n\n@view\n@external\ndef hasCapability(_action: ws.ActionType) -> bool:\n    ...\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    ...\n\n@view\n@external\ndef isYieldLego() -> bool:\n    ...\n\n@view\n@external\ndef isDexLego() -> bool:\n    ...\n\n\n# common\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "81db71fe4440a3b4b563134c9b5caf1d5705772a5f291fe874c9b5fb3cfb1623"
          },
          "interfaces/LegoStructs.vyi": {
            "content": "# @version 0.4.3\n\nstruct VaultTokenInfo:\n    underlyingAsset: address\n    decimals: uint256\n    lastAveragePricePerShare: uint256\n\nstruct SnapShotPriceConfig:\n    minSnapshotDelay: uint256\n    maxNumSnapshots: uint256\n    maxUpsideDeviation: uint256\n    staleTime: uint256\n\nstruct SingleSnapShot:\n    totalSupply: uint256\n    pricePerShare: uint256\n    lastUpdate: uint256\n\nstruct SnapShotData:\n    lastSnapShot: SingleSnapShot\n    nextIndex: uint256\n",
            "sha256sum": "8ae48be17d812d57fbd671bbf0593e8abf175ad0924e47c5997823cac19ec806"
          },
          "interfaces/YieldLego.vyi": {
            "content": "# @version 0.4.3\n\nfrom interfaces import LegoStructs as ls\n\n\n###################\n# Underlying Data #\n###################\n\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    ...\n\n\n@view\n@external\ndef getUnderlyingBalances(_vaultToken: address, _vaultTokenBalance: uint256) -> (uint256, uint256):\n    ...\n\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    ...\n\n\n@view\n@external\ndef getUnderlyingAmountSafe(_vaultToken: address, _vaultTokenBalance: uint256) -> uint256:\n    ...\n\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> (address, uint256, uint256):\n    ...\n\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> uint256:\n    ...\n\n\n###############\n# Other Utils #\n###############\n\n\n@view\n@external\ndef isRebasing() -> bool:\n    ...\n\n\n@view\n@external\ndef getPricePerShare(_vaultToken: address, _decimals: uint256 = 0) -> uint256:\n    ...\n\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef canRegisterVaultToken(_asset: address, _vaultToken: address) -> bool:\n    ...\n\n\n@view\n@external\ndef isEligibleVaultForTrialFunds(_vaultToken: address, _underlyingAsset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef isEligibleForYieldBonus(_asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    ...\n\n\n###################\n# Yield Lego Data #\n###################\n\n\n@view\n@external\ndef isLegoAsset(_asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, 40]:\n    ...\n\n\n@view\n@external\ndef getAssets() -> DynArray[address, 20]:\n    ...\n\n\n@view\n@external\ndef isAssetOpportunity(_asset: address, _vaultAddr: address) -> bool:\n    ...\n\n\n@view\n@external\ndef getNumLegoAssets() -> uint256:\n    ...\n\n\n@view\n@external\ndef assets(_index: uint256) -> address:\n    ...\n\n\n@view\n@external\ndef indexOfAsset(_asset: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef numAssets() -> uint256:\n    ...\n\n\n@view\n@external\ndef assetOpportunities(_asset: address, _index: uint256) -> address:\n    ...\n\n\n@view\n@external\ndef indexOfAssetOpportunity(_asset: address, _vaultAddr: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef numAssetOpportunities(_asset: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef vaultToAsset(_vaultAddr: address) -> ls.VaultTokenInfo:\n    ...\n\n\n# price snapshots\n\n\n@external\ndef addPriceSnapshot(_vaultToken: address) -> bool:\n    ...\n\n\n@view\n@external\ndef snapShotPriceConfig() -> ls.SnapShotPriceConfig:\n    ...\n\n\n@view\n@external\ndef snapShotData(_vaultToken: address) -> ls.SnapShotData:\n    ...\n\n\n@view\n@external\ndef snapShots(_vaultToken: address, _index: uint256) -> ls.SingleSnapShot:\n    ...\n\n\n@view\n@external\ndef getWeightedPricePerShare(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef getLatestSnapshot(_vaultToken: address, _pricePerShare: uint256) -> ls.SingleSnapShot:\n    ...\n\n\n@external\ndef setSnapShotPriceConfig(_config: ls.SnapShotPriceConfig):\n    ...\n",
            "sha256sum": "045a6bbd3d556234cf4fe925a303002dc0ac3c482d344ffbaf4bc52a7e6ad2df"
          },
          "contracts/modules/Addys.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\ninterface UndyHq:\n    def isValidAddr(_addr: address) -> bool: view\n    def getAddr(_regId: uint256) -> address: view\n    def undyToken() -> address: view\n\ninterface Switchboard:\n    def isSwitchboardAddr(_addr: address) -> bool: view\n\ninterface LegoBook:\n    def isLegoAddr(_addr: address) -> bool: view\n\nstruct Addys:\n    hq: address\n    undyToken: address\n    ledger: address\n    missionControl: address\n    legoBook: address\n    switchboard: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    walletBackpack: address\n    billing: address\n    vaultRegistry: address\n\n# hq\nUNDY_HQ_FOR_ADDYS: immutable(address)\n\n# core addys\nLEDGER_ID: constant(uint256) = 1\nMISSION_CONTROL_ID: constant(uint256) = 2\nLEGO_BOOK_ID: constant(uint256) = 3\nSWITCHBOARD_ID: constant(uint256) = 4\nHATCHERY_ID: constant(uint256) = 5\nLOOT_DISTRIBUTOR_ID: constant(uint256) = 6\nAPPRAISER_ID: constant(uint256) = 7\nWALLET_BACKPACK_ID: constant(uint256) = 8\nBILLING_ID: constant(uint256) = 9\nVAULT_REGISTRY_ID: constant(uint256) = 10\n\n\n@deploy\ndef __init__(_undyHq: address):\n    assert _undyHq != empty(address) # dev: invalid undy hq\n    UNDY_HQ_FOR_ADDYS = _undyHq\n\n\n########\n# Core #\n########\n\n\n@view\n@external\ndef getAddys() -> Addys:\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _getAddys(_addys: Addys = empty(Addys)) -> Addys:\n    if _addys.hq != empty(address):\n        return _addys\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _generateAddys() -> Addys:\n    hq: address = UNDY_HQ_FOR_ADDYS\n    return Addys(\n        hq = hq,\n        undyToken = staticcall UndyHq(hq).undyToken(),\n        ledger = staticcall UndyHq(hq).getAddr(LEDGER_ID),\n        missionControl = staticcall UndyHq(hq).getAddr(MISSION_CONTROL_ID),\n        legoBook = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID),\n        switchboard = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID),\n        hatchery = staticcall UndyHq(hq).getAddr(HATCHERY_ID),\n        lootDistributor = staticcall UndyHq(hq).getAddr(LOOT_DISTRIBUTOR_ID),\n        appraiser = staticcall UndyHq(hq).getAddr(APPRAISER_ID),\n        walletBackpack = staticcall UndyHq(hq).getAddr(WALLET_BACKPACK_ID),\n        billing = staticcall UndyHq(hq).getAddr(BILLING_ID),\n        vaultRegistry = staticcall UndyHq(hq).getAddr(VAULT_REGISTRY_ID),\n    )\n\n\n##########\n# Tokens #\n##########\n\n\n@view\n@internal\ndef _getUndyToken() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).undyToken()\n\n\n###########\n# Helpers #\n###########\n\n\n# undy hq\n\n\n@view\n@external\ndef getUndyHq() -> address:\n    return self._getUndyHq()\n\n\n@view\n@internal\ndef _getUndyHq() -> address:\n    return UNDY_HQ_FOR_ADDYS\n\n\n# utils\n\n\n@view\n@internal\ndef _isValidUndyAddr(_addr: address, _hq: address = empty(address)) -> bool:\n    hq: address = _hq\n    if _hq == empty(address):\n        hq = UNDY_HQ_FOR_ADDYS\n    \n    # core departments\n    if staticcall UndyHq(hq).isValidAddr(_addr):\n        return True\n\n    # lego book\n    legoBook: address = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID)\n    if legoBook != empty(address) and staticcall LegoBook(legoBook).isLegoAddr(_addr):\n        return True\n\n    # switchboard config\n    switchboard: address = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID)\n    if switchboard != empty(address) and staticcall Switchboard(switchboard).isSwitchboardAddr(_addr):\n        return True\n\n    return False\n\n\n@view\n@internal\ndef _isSwitchboardAddr(_addr: address) -> bool:\n    switchboard: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n    if switchboard == empty(address):\n        return False\n    return staticcall Switchboard(switchboard).isSwitchboardAddr(_addr)\n\n\n@view\n@internal\ndef _isLegoBookAddr(_addr: address) -> bool:\n    legoBook: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n    if legoBook == empty(address):\n        return False\n    return staticcall LegoBook(legoBook).isLegoAddr(_addr)\n\n\n###############\n# Departments #\n###############\n\n\n# ledger\n\n\n@view\n@internal\ndef _getLedgerId() -> uint256:\n    return LEDGER_ID\n\n\n@view\n@internal\ndef _getLedgerAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEDGER_ID)\n\n\n# mission control\n\n\n@view\n@internal\ndef _getMissionControlId() -> uint256:\n    return MISSION_CONTROL_ID\n\n\n@view\n@internal\ndef _getMissionControlAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(MISSION_CONTROL_ID)\n\n\n# lego book\n\n\n@view\n@internal\ndef _getLegoBookId() -> uint256:\n    return LEGO_BOOK_ID\n\n\n@view\n@internal\ndef _getLegoBookAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n\n\n# switchboard\n\n\n@view\n@internal\ndef _getSwitchboardId() -> uint256:\n    return SWITCHBOARD_ID\n\n\n@view\n@internal\ndef _getSwitchboardAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n\n\n# hatchery\n\n\n@view\n@internal\ndef _getHatcheryId() -> uint256:\n    return HATCHERY_ID\n\n\n@view\n@internal\ndef _getHatcheryAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(HATCHERY_ID)\n\n\n# loot distributor\n\n\n@view\n@internal\ndef _getLootDistributorId() -> uint256:\n    return LOOT_DISTRIBUTOR_ID\n\n\n@view\n@internal\ndef _getLootDistributorAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LOOT_DISTRIBUTOR_ID)\n\n\n# appraiser\n\n\n@view\n@internal\ndef _getAppraiserId() -> uint256:\n    return APPRAISER_ID\n\n\n@view\n@internal\ndef _getAppraiserAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(APPRAISER_ID)\n\n\n# wallet backpack\n\n\n@view\n@internal\ndef _getWalletBackpackId() -> uint256:\n    return WALLET_BACKPACK_ID\n\n\n@view\n@internal\ndef _getWalletBackpackAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(WALLET_BACKPACK_ID)\n\n\n# billing\n\n\n@view\n@internal\ndef _getBillingId() -> uint256:\n    return BILLING_ID\n\n\n@view\n@internal\ndef _getBillingAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(BILLING_ID)\n\n\n# vault registry\n\n\n@view\n@internal\ndef _getVaultRegistryId() -> uint256:\n    return VAULT_REGISTRY_ID\n\n\n@view\n@internal\ndef _getVaultRegistryAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(VAULT_REGISTRY_ID)",
            "sha256sum": "4df6b72db9bb417d1af81660175be1450cfb7b3575f3d17a5b8a130bff87b781"
          },
          "contracts/modules/YieldLegoData.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nuses: addys\n\nimport contracts.modules.Addys as addys\n\nfrom interfaces import WalletStructs as ws\nfrom interfaces import LegoStructs as ls\nfrom ethereum.ercs import IERC20\nfrom ethereum.ercs import IERC20Detailed\n\nevent AssetOpportunityAdded:\n    asset: indexed(address)\n    vaultAddr: indexed(address)\n\nevent AssetOpportunityRemoved:\n    asset: indexed(address)\n    vaultAddr: indexed(address)\n\nevent LegoPauseModified:\n    isPaused: bool\n\nevent LegoFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    balance: uint256\n\nevent PricePerShareSnapShotAdded:\n    vaultToken: indexed(address)\n    totalSupply: uint256\n    pricePerShare: uint256\n\nevent SnapShotPriceConfigSet:\n    minSnapshotDelay: uint256\n    maxNumSnapshots: uint256\n    maxUpsideDeviation: uint256\n    staleTime: uint256\n\n# core\nvaultToAsset: public(HashMap[address, ls.VaultTokenInfo]) # vault addr -> data\n\n# asset opportunities\nassetOpportunities: public(HashMap[address, HashMap[uint256, address]]) # asset -> index -> vault addr\nindexOfAssetOpportunity: public(HashMap[address, HashMap[address, uint256]]) # asset -> vault addr -> index\nnumAssetOpportunities: public(HashMap[address, uint256]) # asset -> number of opportunities\n\n# lego assets (iterable)\nassets: public(HashMap[uint256, address]) # index -> asset\nindexOfAsset: public(HashMap[address, uint256]) # asset -> index\nnumAssets: public(uint256) # num assets\n\n# price snapshots\nsnapShotData: public(HashMap[address, ls.SnapShotData]) # vault token -> data\nsnapShots: public(HashMap[address, HashMap[uint256, ls.SingleSnapShot]]) # vault token -> index -> snapshot\nsnapShotPriceConfig: public(ls.SnapShotPriceConfig) # config\n\nisPaused: public(bool)\n\nMAX_VAULTS: constant(uint256) = 40\nMAX_ASSETS: constant(uint256) = 20\nMAX_RECOVER_ASSETS: constant(uint256) = 20\nONE_DAY_SECONDS: constant(uint256) = 60 * 60 * 24\nONE_WEEK_SECONDS: constant(uint256) = ONE_DAY_SECONDS * 7\nHUNDRED_PERCENT: constant(uint256) = 100_00\n\n\n@deploy\ndef __init__(_shouldPause: bool):\n    self.isPaused = _shouldPause\n    self.numAssets = 1 # not using 0 index\n\n    # default snapshot price config\n    self.snapShotPriceConfig = ls.SnapShotPriceConfig(\n        minSnapshotDelay = 60 * 10, # 10 minutes\n        maxNumSnapshots = 20,\n        maxUpsideDeviation = 10_00, # 10%\n        staleTime = 3 * ONE_DAY_SECONDS, # 3 days\n    )\n\n\n#########\n# Views #\n#########\n\n\n# is lego asset\n\n\n@view\n@external\ndef isLegoAsset(_asset: address) -> bool:\n    return self._isLegoAsset(_asset)\n\n\n@view\n@internal\ndef _isLegoAsset(_asset: address) -> bool:\n    return self.indexOfAsset[_asset] != 0\n\n\n# vault opportunities\n\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, MAX_VAULTS]:\n    numOpportunities: uint256 = self.numAssetOpportunities[_asset]\n    if numOpportunities == 0:\n        return []\n    opportunities: DynArray[address, MAX_VAULTS] = []\n    for i: uint256 in range(1, numOpportunities, bound=MAX_VAULTS):\n        opportunities.append(self.assetOpportunities[_asset][i])\n    return opportunities\n\n\n# all assets registered\n\n\n@view\n@external\ndef getAssets() -> DynArray[address, MAX_ASSETS]:\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return []\n    assets: DynArray[address, MAX_ASSETS] = []\n    for i: uint256 in range(1, numAssets, bound=MAX_ASSETS):\n        assets.append(self.assets[i])\n    return assets\n\n\n################\n# Registration #\n################\n\n\n@view\n@external\ndef isAssetOpportunity(_asset: address, _vaultAddr: address) -> bool:\n    return self._isAssetOpportunity(_asset, _vaultAddr)\n\n\n@view\n@internal\ndef _isAssetOpportunity(_asset: address, _vaultAddr: address) -> bool:\n    return self.indexOfAssetOpportunity[_asset][_vaultAddr] != 0\n\n\n# add asset opportunity\n\n\n@internal\ndef _addAssetOpportunity(_asset: address, _vaultAddr: address) -> ls.VaultTokenInfo:\n    if self.indexOfAssetOpportunity[_asset][_vaultAddr] != 0:\n        return self.vaultToAsset[_vaultAddr]\n\n    if empty(address) in [_asset, _vaultAddr]:\n        return empty(ls.VaultTokenInfo)\n\n    # add asset opportunity\n    aid: uint256 = self.numAssetOpportunities[_asset]\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.assetOpportunities[_asset][aid] = _vaultAddr\n    self.indexOfAssetOpportunity[_asset][_vaultAddr] = aid\n    self.numAssetOpportunities[_asset] = aid + 1\n\n    # add mapping\n    vaultInfo: ls.VaultTokenInfo = ls.VaultTokenInfo(\n        underlyingAsset = _asset,\n        decimals = convert(staticcall IERC20Detailed(_vaultAddr).decimals(), uint256),\n        lastAveragePricePerShare = 0,\n    )\n    self.vaultToAsset[_vaultAddr] = vaultInfo\n\n    # add asset\n    self._addAsset(_asset)\n\n    log AssetOpportunityAdded(asset=_asset, vaultAddr=_vaultAddr)\n    return vaultInfo\n\n\n# remove asset opportunity\n\n\n@internal\ndef _removeAssetOpportunity(_asset: address, _vaultAddr: address):\n    numOpportunities: uint256 = self.numAssetOpportunities[_asset]\n    if numOpportunities == 0:\n        return\n\n    targetIndex: uint256 = self.indexOfAssetOpportunity[_asset][_vaultAddr]\n    if targetIndex == 0:\n        return\n\n    # update data\n    lastIndex: uint256 = numOpportunities - 1\n    self.numAssetOpportunities[_asset] = lastIndex\n    self.indexOfAssetOpportunity[_asset][_vaultAddr] = 0\n\n    self.vaultToAsset[_vaultAddr] = empty(ls.VaultTokenInfo)\n\n    # shift to replace the removed one\n    if targetIndex != lastIndex:\n        lastVaultAddr: address = self.assetOpportunities[_asset][lastIndex]\n        self.assetOpportunities[_asset][targetIndex] = lastVaultAddr\n        self.indexOfAssetOpportunity[_asset][lastVaultAddr] = targetIndex\n\n    # remove asset\n    if lastIndex <= 1:\n        self._removeAsset(_asset)\n\n    log AssetOpportunityRemoved(asset=_asset, vaultAddr=_vaultAddr)\n\n\n# add asset\n\n\n@internal\ndef _addAsset(_asset: address):\n    if self.indexOfAsset[_asset] != 0:\n        return\n\n    aid: uint256 = self.numAssets\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.assets[aid] = _asset\n    self.indexOfAsset[_asset] = aid\n    self.numAssets = aid + 1\n\n\n# remove asset\n\n\n@internal\ndef _removeAsset(_asset: address):\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return\n\n    targetIndex: uint256 = self.indexOfAsset[_asset]\n    if targetIndex == 0:\n        return\n\n    # update data\n    lastIndex: uint256 = numAssets - 1\n    self.numAssets = lastIndex\n    self.indexOfAsset[_asset] = 0\n\n    # shift to replace the removed one\n    if targetIndex != lastIndex:\n        lastAsset: address = self.assets[lastIndex]\n        self.assets[targetIndex] = lastAsset\n        self.indexOfAsset[lastAsset] = targetIndex\n\n\n# num lego assets (true number, use `numAssets` for iteration)\n\n\n@view\n@external\ndef getNumLegoAssets() -> uint256:\n    return self._getNumLegoAssets()\n\n\n@view\n@internal\ndef _getNumLegoAssets() -> uint256:\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return 0\n    return numAssets - 1\n\n\n###########\n# General #\n###########\n\n\n# fill mini addys\n\n\n@view\n@internal\ndef _getMiniAddys(_miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> ws.MiniAddys:\n    if _miniAddys.ledger != empty(address):\n        return _miniAddys\n    return ws.MiniAddys(\n        ledger = addys._getLedgerAddr(),\n        missionControl = addys._getMissionControlAddr(),\n        legoBook = addys._getLegoBookAddr(),\n        appraiser = addys._getAppraiserAddr(),\n    )\n\n\n# activate\n\n\n@external\ndef pause(_shouldPause: bool):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert _shouldPause != self.isPaused # dev: no change\n    self.isPaused = _shouldPause\n    log LegoPauseModified(isPaused=_shouldPause)\n\n\n# recover funds\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    self._recoverFunds(_recipient, _asset)\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, MAX_RECOVER_ASSETS]):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    for a: address in _assets:\n        self._recoverFunds(_recipient, a)\n\n\n@internal\ndef _recoverFunds(_recipient: address, _asset: address):\n    assert empty(address) not in [_recipient, _asset] # dev: invalid recipient or asset\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    assert balance != 0 # dev: nothing to recover\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log LegoFundsRecovered(asset=_asset, recipient=_recipient, balance=balance)\n\n\n###################\n# Price Snapshots #\n###################\n\n\n# add price snapshot\n\n\n@internal\ndef _addPriceSnapshot(_vaultToken: address, _pricePerShare: uint256, _vaultTokenDecimals: uint256) -> bool:\n    config: ls.SnapShotPriceConfig = self.snapShotPriceConfig\n    if config.maxNumSnapshots == 0:\n        return False\n\n    data: ls.SnapShotData = self.snapShotData[_vaultToken]\n\n    # already have snapshot for this time\n    if data.lastSnapShot.lastUpdate == block.timestamp:\n        return False\n\n    # check if snapshot is too recent\n    if data.lastSnapShot.lastUpdate + config.minSnapshotDelay > block.timestamp:\n        return False\n\n    # create and store new snapshot\n    newSnapshot: ls.SingleSnapShot = self._getLatestSnapshot(_vaultToken, _pricePerShare, _vaultTokenDecimals, data.lastSnapShot, config)\n    data.lastSnapShot = newSnapshot\n    self.snapShots[_vaultToken][data.nextIndex] = newSnapshot\n\n    # update index\n    data.nextIndex += 1\n    if data.nextIndex >= config.maxNumSnapshots:\n        data.nextIndex = 0\n\n    # save snap shot data\n    self.snapShotData[_vaultToken] = data\n\n    # update cached weighted average price per share\n    self.vaultToAsset[_vaultToken].lastAveragePricePerShare = self._getWeightedPricePerShare(_vaultToken, _pricePerShare)\n\n    log PricePerShareSnapShotAdded(\n        vaultToken = _vaultToken,\n        totalSupply = newSnapshot.totalSupply,\n        pricePerShare = newSnapshot.pricePerShare,\n    )\n    return True\n\n\n# weighted price per share\n\n\n@view\n@external\ndef getWeightedPricePerShare(_vaultToken: address) -> uint256:\n    data: ls.SnapShotData = self.snapShotData[_vaultToken]\n    return self._getWeightedPricePerShare(_vaultToken, data.lastSnapShot.pricePerShare)\n\n\n@view\n@internal\ndef _getWeightedPricePerShare(_vaultToken: address, _lastPricePerShare: uint256) -> uint256:\n    config: ls.SnapShotPriceConfig = self.snapShotPriceConfig\n    if config.maxNumSnapshots == 0:\n        return 0\n\n    # calculate weighted average price using all valid snapshots\n    numerator: uint256 = 0\n    denominator: uint256 = 0\n    for i: uint256 in range(config.maxNumSnapshots, bound=max_value(uint256)):\n\n        snapShot: ls.SingleSnapShot = self.snapShots[_vaultToken][i]\n        if snapShot.pricePerShare == 0 or snapShot.totalSupply == 0 or snapShot.lastUpdate == 0:\n            continue\n\n        # too stale, skip\n        if config.staleTime != 0 and block.timestamp > snapShot.lastUpdate + config.staleTime:\n            continue\n\n        numerator += (snapShot.totalSupply * snapShot.pricePerShare)\n        denominator += snapShot.totalSupply\n\n    # weighted price per share\n    weightedPricePerShare: uint256 = 0\n    if numerator != 0:\n        weightedPricePerShare = numerator // denominator\n    else:\n        weightedPricePerShare = _lastPricePerShare\n\n    return weightedPricePerShare\n\n\n# latest snapshot\n\n\n@view\n@external\ndef getLatestSnapshot(_vaultToken: address, _pricePerShare: uint256) -> ls.SingleSnapShot:\n    data: ls.SnapShotData = self.snapShotData[_vaultToken]\n    config: ls.SnapShotPriceConfig = self.snapShotPriceConfig\n    vaultTokenDecimals: uint256 = self.vaultToAsset[_vaultToken].decimals\n    return self._getLatestSnapshot(_vaultToken, _pricePerShare, vaultTokenDecimals, data.lastSnapShot, config)\n\n\n@view\n@internal\ndef _getLatestSnapshot(\n    _vaultToken: address,\n    _pricePerShare: uint256,\n    _vaultTokenDecimals: uint256,\n    _lastSnapShot: ls.SingleSnapShot,\n    _config: ls.SnapShotPriceConfig,\n) -> ls.SingleSnapShot:\n\n    # total supply (adjusted)\n    totalSupply: uint256 = staticcall IERC20(_vaultToken).totalSupply() // (10 ** _vaultTokenDecimals)\n    if totalSupply == 0:\n        totalSupply = 1\n\n    # throttle upside (extra safety check)\n    pricePerShare: uint256 = self._throttleUpside(_pricePerShare, _lastSnapShot.pricePerShare, _config.maxUpsideDeviation)\n\n    return ls.SingleSnapShot(\n        totalSupply = totalSupply,\n        pricePerShare = pricePerShare,\n        lastUpdate = block.timestamp,\n    )\n\n\n@view\n@internal\ndef _throttleUpside(_newValue: uint256, _prevValue: uint256, _maxUpside: uint256) -> uint256:\n    if _maxUpside == 0 or _prevValue == 0 or _newValue == 0:\n        return _newValue\n    maxPricePerShare: uint256 = _prevValue + (_prevValue * _maxUpside // HUNDRED_PERCENT)\n    return min(_newValue, maxPricePerShare)\n\n\n# snapshot price config\n\n\n@external\ndef setSnapShotPriceConfig(_config: ls.SnapShotPriceConfig):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert self._isValidPriceConfig(_config) # dev: invalid config\n    self.snapShotPriceConfig = _config\n    log SnapShotPriceConfigSet(\n        minSnapshotDelay=_config.minSnapshotDelay,\n        maxNumSnapshots=_config.maxNumSnapshots,\n        maxUpsideDeviation=_config.maxUpsideDeviation,\n        staleTime=_config.staleTime\n    )\n\n\n@view\n@external\ndef isValidPriceConfig(_config: ls.SnapShotPriceConfig) -> bool:\n    return self._isValidPriceConfig(_config)\n\n\n@view\n@internal\ndef _isValidPriceConfig(_config: ls.SnapShotPriceConfig) -> bool:\n    if _config.minSnapshotDelay > ONE_WEEK_SECONDS:\n        return False\n    if _config.maxNumSnapshots == 0 or _config.maxNumSnapshots > 25:\n        return False\n    if _config.maxUpsideDeviation > HUNDRED_PERCENT:\n        return False\n    return _config.staleTime < ONE_WEEK_SECONDS",
            "sha256sum": "d695c6d3998cf2ed318a0da6f4f7918abf97661e10eb510ed996d815e65927e0"
          },
          "contracts/legos/yield/CompoundV3.vy": {
            "content": "#     __   __ ___ _______ ___     ______       ___     _______ _______ _______ \n#    |  | |  |   |       |   |   |      |     |   |   |       |       |       |\n#    |  |_|  |   |    ___|   |   |  _    |    |   |   |    ___|    ___|   _   |\n#    |       |   |   |___|   |   | | |   |    |   |   |   |___|   | __|  | |  |\n#    |_     _|   |    ___|   |___| |_|   |    |   |___|    ___|   ||  |  |_|  |\n#      |   | |   |   |___|       |       |    |       |   |___|   |_| |       |\n#      |___| |___|_______|_______|______|     |_______|_______|_______|_______|\n#                                                                       \n#     \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n#     \u2551  ** Compound V3 Lego **                   \u2551\n#     \u2551  Integration with Compound Protocol (v3)  \u2551\n#     \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n#\n#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nimplements: Lego\nimplements: YieldLego\n\nexports: addys.__interface__\nexports: yld.__interface__\n\ninitializes: addys\ninitializes: yld[addys := addys]\n\nfrom interfaces import LegoPartner as Lego\nfrom interfaces import YieldLego as YieldLego\nfrom interfaces import WalletStructs as ws\nfrom interfaces import LegoStructs as ls\n\nimport contracts.modules.Addys as addys\nimport contracts.modules.YieldLegoData as yld\n\nfrom ethereum.ercs import IERC20\n\ninterface CompoundV3:\n    def withdrawTo(_recipient: address, _asset: address, _amount: uint256): nonpayable\n    def supplyTo(_recipient: address, _asset: address, _amount: uint256): nonpayable\n    def totalSupply() -> uint256: view\n    def totalBorrow() -> uint256: view\n    def baseToken() -> address: view\n\ninterface Appraiser:\n    def getUsdValue(_asset: address, _amount: uint256, _missionControl: address = empty(address), _legoBook: address = empty(address), _ledger: address = empty(address)) -> uint256: view\n    def updatePriceAndGetUsdValue(_asset: address, _amount: uint256, _missionControl: address = empty(address), _legoBook: address = empty(address)) -> uint256: nonpayable\n\ninterface Ledger:\n    def setVaultToken(_vaultToken: address, _legoId: uint256, _underlyingAsset: address, _decimals: uint256, _isRebasing: bool): nonpayable\n    def isRegisteredVaultToken(_vaultToken: address) -> bool: view\n\ninterface CompoundV3Rewards:\n    def getRewardOwed(_comet: address, _user: address) -> RewardOwed: nonpayable\n    def claim(_comet: address, _user: address, _shouldAccrue: bool): nonpayable\n\ninterface CompoundV3Configurator:\n    def factory(_cometAsset: address) -> address: view\n\ninterface Registry:\n    def getRegId(_addr: address) -> uint256: view\n\nstruct RewardOwed:\n    token: address\n    owed: uint256\n\nevent CompoundV3Deposit:\n    sender: indexed(address)\n    asset: indexed(address)\n    vaultToken: indexed(address)\n    assetAmountDeposited: uint256\n    usdValue: uint256\n    vaultTokenAmountReceived: uint256\n    recipient: address\n\nevent CompoundV3Withdrawal:\n    sender: indexed(address)\n    asset: indexed(address)\n    vaultToken: indexed(address)\n    assetAmountReceived: uint256\n    usdValue: uint256\n    vaultTokenAmountBurned: uint256\n    recipient: address\n\nevent CompoundV3RewardsAddrSet:\n    addr: address\n\n# rewards contract\ncompoundRewards: public(address)\n\n# compound v3\nCOMPOUND_V3_CONFIGURATOR: public(immutable(address))\n\nMAX_TOKEN_PATH: constant(uint256) = 5\n\n\n@deploy\ndef __init__(\n    _undyHq: address,\n    _configurator: address,\n    _compRewards: address,\n):\n    addys.__init__(_undyHq)\n    yld.__init__(False)\n\n    assert _configurator != empty(address) # dev: invalid configurator\n    COMPOUND_V3_CONFIGURATOR = _configurator\n    self.compoundRewards = _compRewards\n\n\n@view\n@external\ndef hasCapability(_action: ws.ActionType) -> bool:\n    return _action in (\n        ws.ActionType.EARN_DEPOSIT | \n        ws.ActionType.EARN_WITHDRAW |\n        ws.ActionType.REWARDS\n    )\n\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    return [COMPOUND_V3_CONFIGURATOR]\n\n\n@view\n@external\ndef isYieldLego() -> bool:\n    return True\n\n\n@view\n@external\ndef isDexLego() -> bool:\n    return False\n\n\n###################\n# Underlying Data #\n###################\n\n\n# underlying asset\n\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    return self._getUnderlyingAsset(_vaultToken)\n\n\n@view\n@internal\ndef _getUnderlyingAsset(_vaultToken: address) -> address:\n    return yld.vaultToAsset[_vaultToken].underlyingAsset\n\n\n# underlying balances (both true and safe)\n\n\n@view\n@external\ndef getUnderlyingBalances(_vaultToken: address, _vaultTokenBalance: uint256) -> (uint256, uint256):\n    return _vaultTokenBalance, _vaultTokenBalance\n\n\n# underlying amount (true)\n\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    return self._getUnderlyingAmount(_vaultToken, _vaultTokenAmount)\n\n\n@view\n@internal\ndef _getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    # treated as 1:1\n    return _vaultTokenAmount\n\n\n# underlying amount (safe)\n\n\n@view\n@external\ndef getUnderlyingAmountSafe(_vaultToken: address, _vaultTokenBalance: uint256) -> uint256:\n    # treated as 1:1\n    return _vaultTokenBalance\n\n\n# underlying data (combined)\n\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> (address, uint256, uint256):\n    return self._getUnderlyingData(_vaultToken, _vaultTokenAmount, _appraiser)\n\n\n@view\n@internal\ndef _getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address) -> (address, uint256, uint256):\n    asset: address = self._getUnderlyingAsset(_vaultToken)\n    if asset == empty(address):\n        return empty(address), 0, 0 # invalid vault token\n    underlyingAmount: uint256 = self._getUnderlyingAmount(_vaultToken, _vaultTokenAmount)\n    usdValue: uint256 = self._getUsdValue(asset, underlyingAmount, _appraiser)\n    return asset, underlyingAmount, usdValue\n\n\n# usd value\n\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> uint256:\n    return self._getUsdValueOfVaultToken(_vaultToken, _vaultTokenAmount, _appraiser)\n\n\n@view\n@internal\ndef _getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address) -> uint256:\n    return self._getUnderlyingData(_vaultToken, _vaultTokenAmount, _appraiser)[2]\n\n\n@view\n@internal\ndef _getUsdValue(_asset: address, _amount: uint256, _appraiser: address) -> uint256:\n    appraiser: address = _appraiser\n    if _appraiser == empty(address):\n        appraiser = addys._getAppraiserAddr()\n    return staticcall Appraiser(appraiser).getUsdValue(_asset, _amount)\n\n\n###############\n# Other Utils #\n###############\n\n\n# basics\n\n\n@view\n@external\ndef isRebasing() -> bool:\n    return self._isRebasing()\n\n\n@view\n@internal\ndef _isRebasing() -> bool:\n    return True\n\n\n# price per share\n\n\n@view\n@external\ndef getPricePerShare(_vaultToken: address, _decimals: uint256 = 0) -> uint256:\n    decimals: uint256 = _decimals\n    if decimals == 0:\n        decimals = yld.vaultToAsset[_vaultToken].decimals\n    if decimals == 0:\n        return 0 # not registered\n    return self._getPricePerShare(_vaultToken, decimals)\n\n\n@view\n@internal\ndef _getPricePerShare(_vaultToken: address, _decimals: uint256) -> uint256:\n    return 10 ** _decimals # treated as 1:1\n\n\n# vault token amount\n\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    return _assetAmount # treated as 1:1\n\n\n# extras\n\n\n@view\n@external\ndef isEligibleVaultForTrialFunds(_vaultToken: address, _underlyingAsset: address) -> bool:\n    return False\n\n\n@view\n@external\ndef isEligibleForYieldBonus(_asset: address) -> bool:\n    return False\n\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    return staticcall CompoundV3(_vaultToken).totalSupply()\n\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    return staticcall CompoundV3(_vaultToken).totalBorrow()\n\n\n################\n# Registration #\n################\n\n\n# can vault be registered\n\n\n@view\n@external\ndef canRegisterVaultToken(_asset: address, _vaultToken: address) -> bool:\n    return self._canRegisterVaultToken(_asset, _vaultToken)\n\n\n@view\n@internal\ndef _canRegisterVaultToken(_asset: address, _vaultToken: address) -> bool:\n    if empty(address) in [_asset, _vaultToken]:\n        return False\n    if staticcall CompoundV3(_vaultToken).baseToken() != _asset:\n        return False\n    return staticcall CompoundV3Configurator(COMPOUND_V3_CONFIGURATOR).factory(_vaultToken) != empty(address)\n\n\n# register vault token locally\n\n\n@external\ndef registerVaultTokenLocally(_asset: address, _vaultAddr: address) -> ls.VaultTokenInfo:\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert self._canRegisterVaultToken(_asset, _vaultAddr) # dev: cannot register vault token\n    assert not yld._isAssetOpportunity(_asset, _vaultAddr) # dev: already registered\n    vaultInfo: ls.VaultTokenInfo = self._registerVaultTokenLocally(_asset, _vaultAddr)\n    self._registerVaultTokenGlobally(_asset, _vaultAddr, vaultInfo.decimals, addys._getLedgerAddr(), addys._getLegoBookAddr())\n    return vaultInfo\n\n\n@internal\ndef _registerVaultTokenLocally(_asset: address, _vaultAddr: address) -> ls.VaultTokenInfo:\n    assert extcall IERC20(_asset).approve(_vaultAddr, max_value(uint256), default_return_value=True) # dev: max approval failed\n    vaultInfo: ls.VaultTokenInfo = yld._addAssetOpportunity(_asset, _vaultAddr)\n    assert vaultInfo.decimals != 0 # dev: invalid vault token\n    return vaultInfo\n\n\n# remove vault token locally\n\n\n@external\ndef deregisterVaultTokenLocally(_asset: address, _vaultAddr: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert yld._isAssetOpportunity(_asset, _vaultAddr) # dev: already registered\n    self._deregisterVaultTokenLocally(_asset, _vaultAddr)\n\n\n@internal\ndef _deregisterVaultTokenLocally(_asset: address, _vaultAddr: address):\n    assert extcall IERC20(_asset).approve(_vaultAddr, 0, default_return_value=True) # dev: max approval failed\n    yld._removeAssetOpportunity(_asset, _vaultAddr)\n\n\n# ledger registration\n\n\n@internal\ndef _registerVaultTokenGlobally(_underlyingAsset: address, _vaultToken: address, _decimals: uint256, _ledger: address, _legoBook: address):\n    if not staticcall Ledger(_ledger).isRegisteredVaultToken(_vaultToken):\n        legoId: uint256 = staticcall Registry(_legoBook).getRegId(self)\n        extcall Ledger(_ledger).setVaultToken(_vaultToken, legoId, _underlyingAsset, _decimals, self._isRebasing())\n\n\n#################\n# Yield Actions #\n#################\n\n\n# deposit\n\n\n@external\ndef depositForYield(\n    _asset: address,\n    _amount: uint256,\n    _vaultAddr: address,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, address, uint256, uint256):\n    assert not yld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = yld._getMiniAddys(_miniAddys)\n    vaultInfo: ls.VaultTokenInfo = self._getVaultInfoOnDeposit(_asset, _vaultAddr, miniAddys.ledger, miniAddys.legoBook)\n\n    # pre balances\n    preRecipientVaultBalance: uint256 = staticcall IERC20(_vaultAddr).balanceOf(_recipient)\n    preLegoBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n\n    # transfer deposit asset to this contract\n    depositAmount: uint256 = min(_amount, staticcall IERC20(_asset).balanceOf(msg.sender))\n    assert depositAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_asset).transferFrom(msg.sender, self, depositAmount, default_return_value=True) # dev: transfer failed\n\n    # deposit assets into lego partner\n    extcall CompoundV3(_vaultAddr).supplyTo(_recipient, _asset, depositAmount) # dev: could not deposit into compound v3\n\n    # validate vault token transfer\n    vaultTokenAmountReceived: uint256 = staticcall IERC20(_vaultAddr).balanceOf(_recipient) - preRecipientVaultBalance\n    assert vaultTokenAmountReceived != 0 # dev: no vault tokens received\n\n    # refund if full deposit didn't get through\n    currentLegoBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    refundAssetAmount: uint256 = 0\n    if currentLegoBalance > preLegoBalance:\n        refundAssetAmount = currentLegoBalance - preLegoBalance\n        assert extcall IERC20(_asset).transfer(msg.sender, refundAssetAmount, default_return_value=True) # dev: transfer failed\n        depositAmount -= refundAssetAmount\n\n    usdValue: uint256 = extcall Appraiser(miniAddys.appraiser).updatePriceAndGetUsdValue(_asset, depositAmount, miniAddys.missionControl, miniAddys.legoBook)\n    log CompoundV3Deposit(\n        sender = msg.sender,\n        asset = _asset,\n        vaultToken = _vaultAddr,\n        assetAmountDeposited = depositAmount,\n        usdValue = usdValue,\n        vaultTokenAmountReceived = vaultTokenAmountReceived,\n        recipient = _recipient,\n    )\n    return depositAmount, _vaultAddr, vaultTokenAmountReceived, usdValue\n\n\n# vault info on deposit\n\n\n@internal\ndef _getVaultInfoOnDeposit(_asset: address, _vaultAddr: address, _ledger: address, _legoBook: address) -> ls.VaultTokenInfo:\n    vaultInfo: ls.VaultTokenInfo = yld.vaultToAsset[_vaultAddr]\n    if vaultInfo.decimals == 0:\n        assert self._canRegisterVaultToken(_asset, _vaultAddr) # dev: cannot register vault token\n        vaultInfo = self._registerVaultTokenLocally(_asset, _vaultAddr)\n        self._registerVaultTokenGlobally(_asset, _vaultAddr, vaultInfo.decimals, _ledger, _legoBook)\n    else:\n        assert vaultInfo.underlyingAsset == _asset # dev: asset mismatch\n    return vaultInfo\n\n\n# withdraw\n\n\n@external\ndef withdrawFromYield(\n    _vaultToken: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, address, uint256, uint256):\n    assert not yld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = yld._getMiniAddys(_miniAddys)\n    vaultInfo: ls.VaultTokenInfo = self._getVaultInfoOnWithdrawal(_vaultToken, miniAddys.ledger, miniAddys.legoBook)\n\n    # pre balances\n    preRecipientAssetBalance: uint256 = staticcall IERC20(vaultInfo.underlyingAsset).balanceOf(_recipient)\n    preLegoVaultBalance: uint256 = staticcall IERC20(_vaultToken).balanceOf(self)\n\n    # transfer vaults tokens to this contract\n    vaultTokenAmount: uint256 = min(_amount, staticcall IERC20(_vaultToken).balanceOf(msg.sender))\n    assert vaultTokenAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_vaultToken).transferFrom(msg.sender, self, vaultTokenAmount, default_return_value=True) # dev: transfer failed\n\n    # withdraw assets from lego partner\n    extcall CompoundV3(_vaultToken).withdrawTo(_recipient, vaultInfo.underlyingAsset, max_value(uint256)) # dev: could not withdraw from compound v3\n\n    # validate asset transfer\n    assetAmountReceived: uint256 = staticcall IERC20(vaultInfo.underlyingAsset).balanceOf(_recipient) - preRecipientAssetBalance\n    assert assetAmountReceived != 0 # dev: no asset amount received\n\n    # refund if full withdrawal didn't happen\n    currentLegoVaultBalance: uint256 = staticcall IERC20(_vaultToken).balanceOf(self)\n    refundVaultTokenAmount: uint256 = 0\n    if currentLegoVaultBalance > preLegoVaultBalance:\n        refundVaultTokenAmount = currentLegoVaultBalance - preLegoVaultBalance\n        assert extcall IERC20(_vaultToken).transfer(msg.sender, refundVaultTokenAmount, default_return_value=True) # dev: transfer failed\n        vaultTokenAmount -= refundVaultTokenAmount\n\n    usdValue: uint256 = extcall Appraiser(miniAddys.appraiser).updatePriceAndGetUsdValue(vaultInfo.underlyingAsset, assetAmountReceived, miniAddys.missionControl, miniAddys.legoBook)\n    log CompoundV3Withdrawal(\n        sender = msg.sender,\n        asset = vaultInfo.underlyingAsset,\n        vaultToken = _vaultToken,\n        assetAmountReceived = assetAmountReceived,\n        usdValue = usdValue,\n        vaultTokenAmountBurned = vaultTokenAmount,\n        recipient = _recipient,\n    )\n    return vaultTokenAmount, vaultInfo.underlyingAsset, assetAmountReceived, usdValue\n\n\n# vault info on withdrawal\n\n\n@internal\ndef _getVaultInfoOnWithdrawal(_vaultAddr: address, _ledger: address, _legoBook: address) -> ls.VaultTokenInfo:\n    vaultInfo: ls.VaultTokenInfo = yld.vaultToAsset[_vaultAddr]\n    if vaultInfo.decimals == 0:\n        asset: address = staticcall CompoundV3(_vaultAddr).baseToken()\n        assert self._canRegisterVaultToken(asset, _vaultAddr) # dev: cannot register vault token\n        vaultInfo = self._registerVaultTokenLocally(asset, _vaultAddr)\n        self._registerVaultTokenGlobally(asset, _vaultAddr, vaultInfo.decimals, _ledger, _legoBook)\n    return vaultInfo\n\n\n#################\n# Claim Rewards #\n#################\n\n\n@external\ndef claimRewards(\n    _user: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _extraData: bytes32,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    assert not yld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = yld._getMiniAddys(_miniAddys)\n\n    assert msg.sender == _user # dev: recipient must be caller\n    preBalance: uint256 = staticcall IERC20(_rewardToken).balanceOf(_user)\n\n    market: address = empty(address)\n    if _extraData != empty(bytes32):\n        market = convert(_extraData, address)\n\n    compRewards: address = self.compoundRewards\n    assert compRewards != empty(address) # dev: no comp rewards addr set\n    if market != empty(address):\n        extcall CompoundV3Rewards(compRewards).claim(market, _user, True)\n    else:\n        self._hasClaimableOrShouldClaim(_user, True, compRewards)\n\n    rewardAmount: uint256 = staticcall IERC20(_rewardToken).balanceOf(_user) - preBalance\n    assert rewardAmount != 0 # dev: no rewards received\n    usdValue: uint256 = extcall Appraiser(miniAddys.appraiser).updatePriceAndGetUsdValue(_rewardToken, rewardAmount, miniAddys.missionControl, miniAddys.legoBook)\n    return rewardAmount, usdValue\n\n\n# sadly, this is not a view function because of `getRewardOwed()`\n@external\ndef hasClaimableRewards(_user: address) -> bool:\n    return self._hasClaimableOrShouldClaim(_user, False, self.compoundRewards)\n\n\n@internal\ndef _hasClaimableOrShouldClaim(_user: address, _shouldClaim: bool, _compRewardsAddr: address) -> bool:\n    numAssets: uint256 = yld.numAssets\n    if numAssets == 0:\n        return False\n\n    for i: uint256 in range(1, numAssets, bound=max_value(uint256)):\n        asset: address = yld.assets[i]\n        comet: address = yld.assetOpportunities[asset][1] # only a single \"vault token\" (comet) per asset\n\n        rewardOwed: RewardOwed = extcall CompoundV3Rewards(_compRewardsAddr).getRewardOwed(comet, _user)\n        if rewardOwed.owed != 0:\n            if _shouldClaim:\n                extcall CompoundV3Rewards(_compRewardsAddr).claim(comet, _user, True)\n            else:\n                return True\n\n    return False\n\n\n# set rewards addr\n\n\n@external\ndef setCompRewardsAddr(_addr: address) -> bool:\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert _addr != empty(address) # dev: invalid addr\n    self.compoundRewards = _addr\n    log CompoundV3RewardsAddrSet(addr=_addr)\n    return True\n\n\n#########\n# Other #\n#########\n\n\n@external\ndef addPriceSnapshot(_vaultToken: address) -> bool:\n    # no need for snapshots\n    return False\n\n\n@view\n@external\ndef getAccessForLego(_user: address, _action: ws.ActionType) -> (address, String[64], uint256):\n    return empty(address), empty(String[64]), 0\n\n\n@external\ndef swapTokens(\n    _amountIn: uint256,\n    _minAmountOut: uint256,\n    _tokenPath: DynArray[address, MAX_TOKEN_PATH],\n    _poolPath: DynArray[address, MAX_TOKEN_PATH - 1],\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256):\n    return 0, 0, 0\n\n\n@external\ndef mintOrRedeemAsset(\n    _tokenIn: address,\n    _tokenOut: address,\n    _tokenInAmount: uint256,\n    _minAmountOut: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, bool, uint256):\n    return 0, 0, False, 0\n\n\n@external\ndef confirmMintOrRedeemAsset(\n    _tokenIn: address,\n    _tokenOut: address,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef addCollateral(\n    _asset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef removeCollateral(\n    _asset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef borrow(\n    _borrowAsset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef repayDebt(\n    _paymentAsset: address,\n    _paymentAmount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef addLiquidity(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _amountA: uint256,\n    _amountB: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _minLpAmount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (address, uint256, uint256, uint256, uint256):\n    return empty(address), 0, 0, 0, 0\n\n\n@external\ndef removeLiquidity(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpToken: address,\n    _lpAmount: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, uint256):\n    return 0, 0, 0, 0\n\n\n@external\ndef addLiquidityConcentrated(\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _tickLower: int24,\n    _tickUpper: int24,\n    _amountA: uint256,\n    _amountB: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, uint256, uint256):\n    return 0, 0, 0, 0, 0\n\n\n@external\ndef removeLiquidityConcentrated(\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _liqToRemove: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, bool, uint256):\n    return 0, 0, 0, False, 0",
            "sha256sum": "f7824048dcaa0e139470a756db64cb8f49ac1f7702ec3f345491393a6c0f7065"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/legos/yield/CompoundV3.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.3+commit.bff19ea2",
        "integrity": "0df9dcf5557c9edf73334bfa2897b48d87d688608af81bafa1b5d72319cf8647"
      },
      "args": "00000000000000000000000044cf3c4f000dfd76a35d03298049d37be688d6f900000000000000000000000045939657d1ca34a8fa39a924b71d28fe8431e581000000000000000000000000123964802e6ababbe1bc9547d72ef1b69b00a6b1",
      "file": "contracts/legos/yield/CompoundV3.vy"
    },
    "Euler": {
      "address": "0x713A20A92F1a2683FdA89e8a9b6F4f3382B2F336",
      "abi": [
        {
          "name": "EulerDeposit",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountDeposited",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultTokenAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "EulerWithdrawal",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultTokenAmountBurned",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "EulerRewardsAddrSet",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LegoPauseModified",
          "inputs": [
            {
              "name": "isPaused",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LegoFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "balance",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "SnapShotPriceConfigSet",
          "inputs": [
            {
              "name": "minSnapshotDelay",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "maxNumSnapshots",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "maxUpsideDeviation",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "staleTime",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetOpportunityAdded",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultAddr",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetOpportunityRemoved",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultAddr",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PricePerShareSnapShotAdded",
          "inputs": [
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "totalSupply",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "pricePerShare",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddys",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "undyToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "hatchery",
                  "type": "address"
                },
                {
                  "name": "lootDistributor",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                },
                {
                  "name": "walletBackpack",
                  "type": "address"
                },
                {
                  "name": "billing",
                  "type": "address"
                },
                {
                  "name": "vaultRegistry",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUndyHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isLegoAsset",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssetOpportunities",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isAssetOpportunity",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getNumLegoAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pause",
          "inputs": [
            {
              "name": "_shouldPause",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFundsMany",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_assets",
              "type": "address[]"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getWeightedPricePerShare",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLatestSnapshot",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_pricePerShare",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "totalSupply",
                  "type": "uint256"
                },
                {
                  "name": "pricePerShare",
                  "type": "uint256"
                },
                {
                  "name": "lastUpdate",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setSnapShotPriceConfig",
          "inputs": [
            {
              "name": "_config",
              "type": "tuple",
              "components": [
                {
                  "name": "minSnapshotDelay",
                  "type": "uint256"
                },
                {
                  "name": "maxNumSnapshots",
                  "type": "uint256"
                },
                {
                  "name": "maxUpsideDeviation",
                  "type": "uint256"
                },
                {
                  "name": "staleTime",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidPriceConfig",
          "inputs": [
            {
              "name": "_config",
              "type": "tuple",
              "components": [
                {
                  "name": "minSnapshotDelay",
                  "type": "uint256"
                },
                {
                  "name": "maxNumSnapshots",
                  "type": "uint256"
                },
                {
                  "name": "maxUpsideDeviation",
                  "type": "uint256"
                },
                {
                  "name": "staleTime",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "vaultToAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "underlyingAsset",
                  "type": "address"
                },
                {
                  "name": "decimals",
                  "type": "uint256"
                },
                {
                  "name": "lastAveragePricePerShare",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assetOpportunities",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAssetOpportunity",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssetOpportunities",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assets",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "snapShotData",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "lastSnapShot",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "totalSupply",
                      "type": "uint256"
                    },
                    {
                      "name": "pricePerShare",
                      "type": "uint256"
                    },
                    {
                      "name": "lastUpdate",
                      "type": "uint256"
                    }
                  ]
                },
                {
                  "name": "nextIndex",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "snapShots",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "totalSupply",
                  "type": "uint256"
                },
                {
                  "name": "pricePerShare",
                  "type": "uint256"
                },
                {
                  "name": "lastUpdate",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "snapShotPriceConfig",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "minSnapshotDelay",
                  "type": "uint256"
                },
                {
                  "name": "maxNumSnapshots",
                  "type": "uint256"
                },
                {
                  "name": "maxUpsideDeviation",
                  "type": "uint256"
                },
                {
                  "name": "staleTime",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isPaused",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasCapability",
          "inputs": [
            {
              "name": "_action",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRegistries",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isYieldLego",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isDexLego",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAsset",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingBalances",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenBalance",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAmount",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAmountSafe",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenBalance",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingData",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingData",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            },
            {
              "name": "_appraiser",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValueOfVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValueOfVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            },
            {
              "name": "_appraiser",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isRebasing",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPricePerShare",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPricePerShare",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_decimals",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getVaultTokenAmount",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_assetAmount",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isEligibleVaultForTrialFunds",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_underlyingAsset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isEligibleForYieldBonus",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalAssets",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalBorrows",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canRegisterVaultToken",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "registerVaultTokenLocally",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "underlyingAsset",
                  "type": "address"
                },
                {
                  "name": "decimals",
                  "type": "uint256"
                },
                {
                  "name": "lastAveragePricePerShare",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "deregisterVaultTokenLocally",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addPriceSnapshot",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositForYield",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositForYield",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawFromYield",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawFromYield",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasClaimableRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setEulerRewardsAddr",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAccessForLego",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_action",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "string"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_tokenPath",
              "type": "address[]"
            },
            {
              "name": "_poolPath",
              "type": "address[]"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_tokenPath",
              "type": "address[]"
            },
            {
              "name": "_poolPath",
              "type": "address[]"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_tokenInAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_tokenInAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmMintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmMintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_borrowAsset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_borrowAsset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_paymentAsset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_paymentAsset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "eulerRewards",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "EULER_EVAULT_FACTORY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "EULER_EARN_FACTORY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_undyHq",
              "type": "address"
            },
            {
              "name": "_evaultFactory",
              "type": "address"
            },
            {
              "name": "_earnFactory",
              "type": "address"
            },
            {
              "name": "_eulerRewardsAddr",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "interfaces/WalletStructs.vyi": {
            "content": "# @version 0.4.3\n\nflag ActionType:\n    TRANSFER\n    EARN_DEPOSIT\n    EARN_WITHDRAW\n    EARN_REBALANCE\n    SWAP\n    MINT_REDEEM\n    CONFIRM_MINT_REDEEM\n    ADD_COLLATERAL\n    REMOVE_COLLATERAL\n    BORROW\n    REPAY_DEBT\n    REWARDS\n    ETH_TO_WETH\n    WETH_TO_ETH\n    ADD_LIQ\n    REMOVE_LIQ\n    ADD_LIQ_CONC\n    REMOVE_LIQ_CONC\n    PAY_CHEQUE\n\nstruct WalletAssetData:\n    assetBalance: uint256\n    usdValue: uint256\n    isYieldAsset: bool\n    lastPricePerShare: uint256\n\nstruct ActionData:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    billing: address\n    wallet: address\n    walletConfig: address\n    walletOwner: address\n    inEjectMode: bool\n    isFrozen: bool\n    lastTotalUsdValue: uint256\n    signer: address\n    isManager: bool\n    legoId: uint256\n    legoAddr: address\n    eth: address\n    weth: address\n\nstruct MiniAddys:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    appraiser: address",
            "sha256sum": "9a4b4f59b3a62043e51b425a665064aae419a3c0bd0514b6b29a9441ae364bb9"
          },
          "interfaces/LegoPartner.vyi": {
            "content": "# @version 0.4.3\n\nfrom interfaces import WalletStructs as ws\n\nMAX_TOKEN_PATH: constant(uint256) = 5\nMAX_RECOVER_ASSETS: constant(uint256) = 20\n\n@external\ndef addLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _tickLower: int24, _tickUpper: int24, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef addLiquidity(_pool: address, _tokenA: address, _tokenB: address, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _minLpAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (address, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef removeLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _liqToRemove: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef removeLiquidity(_pool: address, _tokenA: address, _tokenB: address, _lpToken: address, _lpAmount: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef mintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _tokenInAmount: uint256, _minAmountOut: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef swapTokens(_amountIn: uint256, _minAmountOut: uint256, _tokenPath: DynArray[address, MAX_TOKEN_PATH], _poolPath: DynArray[address, MAX_TOKEN_PATH - 1], _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256):\n    ...\n\n@external\ndef depositForYield(_asset: address, _amount: uint256, _vaultAddr: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef withdrawFromYield(_vaultToken: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef confirmMintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef borrow(_borrowAsset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef repayDebt(_paymentAsset: address, _paymentAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef claimRewards(_user: address, _rewardToken: address, _rewardAmount: uint256, _extraData: bytes32, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef removeCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef addCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@view\n@external\ndef getAccessForLego(_user: address, _action: ws.ActionType) -> (address, String[64], uint256):\n    ...\n\n@view\n@external\ndef hasCapability(_action: ws.ActionType) -> bool:\n    ...\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    ...\n\n@view\n@external\ndef isYieldLego() -> bool:\n    ...\n\n@view\n@external\ndef isDexLego() -> bool:\n    ...\n\n\n# common\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "81db71fe4440a3b4b563134c9b5caf1d5705772a5f291fe874c9b5fb3cfb1623"
          },
          "interfaces/LegoStructs.vyi": {
            "content": "# @version 0.4.3\n\nstruct VaultTokenInfo:\n    underlyingAsset: address\n    decimals: uint256\n    lastAveragePricePerShare: uint256\n\nstruct SnapShotPriceConfig:\n    minSnapshotDelay: uint256\n    maxNumSnapshots: uint256\n    maxUpsideDeviation: uint256\n    staleTime: uint256\n\nstruct SingleSnapShot:\n    totalSupply: uint256\n    pricePerShare: uint256\n    lastUpdate: uint256\n\nstruct SnapShotData:\n    lastSnapShot: SingleSnapShot\n    nextIndex: uint256\n",
            "sha256sum": "8ae48be17d812d57fbd671bbf0593e8abf175ad0924e47c5997823cac19ec806"
          },
          "interfaces/YieldLego.vyi": {
            "content": "# @version 0.4.3\n\nfrom interfaces import LegoStructs as ls\n\n\n###################\n# Underlying Data #\n###################\n\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    ...\n\n\n@view\n@external\ndef getUnderlyingBalances(_vaultToken: address, _vaultTokenBalance: uint256) -> (uint256, uint256):\n    ...\n\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    ...\n\n\n@view\n@external\ndef getUnderlyingAmountSafe(_vaultToken: address, _vaultTokenBalance: uint256) -> uint256:\n    ...\n\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> (address, uint256, uint256):\n    ...\n\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> uint256:\n    ...\n\n\n###############\n# Other Utils #\n###############\n\n\n@view\n@external\ndef isRebasing() -> bool:\n    ...\n\n\n@view\n@external\ndef getPricePerShare(_vaultToken: address, _decimals: uint256 = 0) -> uint256:\n    ...\n\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef canRegisterVaultToken(_asset: address, _vaultToken: address) -> bool:\n    ...\n\n\n@view\n@external\ndef isEligibleVaultForTrialFunds(_vaultToken: address, _underlyingAsset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef isEligibleForYieldBonus(_asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    ...\n\n\n###################\n# Yield Lego Data #\n###################\n\n\n@view\n@external\ndef isLegoAsset(_asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, 40]:\n    ...\n\n\n@view\n@external\ndef getAssets() -> DynArray[address, 20]:\n    ...\n\n\n@view\n@external\ndef isAssetOpportunity(_asset: address, _vaultAddr: address) -> bool:\n    ...\n\n\n@view\n@external\ndef getNumLegoAssets() -> uint256:\n    ...\n\n\n@view\n@external\ndef assets(_index: uint256) -> address:\n    ...\n\n\n@view\n@external\ndef indexOfAsset(_asset: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef numAssets() -> uint256:\n    ...\n\n\n@view\n@external\ndef assetOpportunities(_asset: address, _index: uint256) -> address:\n    ...\n\n\n@view\n@external\ndef indexOfAssetOpportunity(_asset: address, _vaultAddr: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef numAssetOpportunities(_asset: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef vaultToAsset(_vaultAddr: address) -> ls.VaultTokenInfo:\n    ...\n\n\n# price snapshots\n\n\n@external\ndef addPriceSnapshot(_vaultToken: address) -> bool:\n    ...\n\n\n@view\n@external\ndef snapShotPriceConfig() -> ls.SnapShotPriceConfig:\n    ...\n\n\n@view\n@external\ndef snapShotData(_vaultToken: address) -> ls.SnapShotData:\n    ...\n\n\n@view\n@external\ndef snapShots(_vaultToken: address, _index: uint256) -> ls.SingleSnapShot:\n    ...\n\n\n@view\n@external\ndef getWeightedPricePerShare(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef getLatestSnapshot(_vaultToken: address, _pricePerShare: uint256) -> ls.SingleSnapShot:\n    ...\n\n\n@external\ndef setSnapShotPriceConfig(_config: ls.SnapShotPriceConfig):\n    ...\n",
            "sha256sum": "045a6bbd3d556234cf4fe925a303002dc0ac3c482d344ffbaf4bc52a7e6ad2df"
          },
          "contracts/modules/Addys.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\ninterface UndyHq:\n    def isValidAddr(_addr: address) -> bool: view\n    def getAddr(_regId: uint256) -> address: view\n    def undyToken() -> address: view\n\ninterface Switchboard:\n    def isSwitchboardAddr(_addr: address) -> bool: view\n\ninterface LegoBook:\n    def isLegoAddr(_addr: address) -> bool: view\n\nstruct Addys:\n    hq: address\n    undyToken: address\n    ledger: address\n    missionControl: address\n    legoBook: address\n    switchboard: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    walletBackpack: address\n    billing: address\n    vaultRegistry: address\n\n# hq\nUNDY_HQ_FOR_ADDYS: immutable(address)\n\n# core addys\nLEDGER_ID: constant(uint256) = 1\nMISSION_CONTROL_ID: constant(uint256) = 2\nLEGO_BOOK_ID: constant(uint256) = 3\nSWITCHBOARD_ID: constant(uint256) = 4\nHATCHERY_ID: constant(uint256) = 5\nLOOT_DISTRIBUTOR_ID: constant(uint256) = 6\nAPPRAISER_ID: constant(uint256) = 7\nWALLET_BACKPACK_ID: constant(uint256) = 8\nBILLING_ID: constant(uint256) = 9\nVAULT_REGISTRY_ID: constant(uint256) = 10\n\n\n@deploy\ndef __init__(_undyHq: address):\n    assert _undyHq != empty(address) # dev: invalid undy hq\n    UNDY_HQ_FOR_ADDYS = _undyHq\n\n\n########\n# Core #\n########\n\n\n@view\n@external\ndef getAddys() -> Addys:\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _getAddys(_addys: Addys = empty(Addys)) -> Addys:\n    if _addys.hq != empty(address):\n        return _addys\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _generateAddys() -> Addys:\n    hq: address = UNDY_HQ_FOR_ADDYS\n    return Addys(\n        hq = hq,\n        undyToken = staticcall UndyHq(hq).undyToken(),\n        ledger = staticcall UndyHq(hq).getAddr(LEDGER_ID),\n        missionControl = staticcall UndyHq(hq).getAddr(MISSION_CONTROL_ID),\n        legoBook = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID),\n        switchboard = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID),\n        hatchery = staticcall UndyHq(hq).getAddr(HATCHERY_ID),\n        lootDistributor = staticcall UndyHq(hq).getAddr(LOOT_DISTRIBUTOR_ID),\n        appraiser = staticcall UndyHq(hq).getAddr(APPRAISER_ID),\n        walletBackpack = staticcall UndyHq(hq).getAddr(WALLET_BACKPACK_ID),\n        billing = staticcall UndyHq(hq).getAddr(BILLING_ID),\n        vaultRegistry = staticcall UndyHq(hq).getAddr(VAULT_REGISTRY_ID),\n    )\n\n\n##########\n# Tokens #\n##########\n\n\n@view\n@internal\ndef _getUndyToken() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).undyToken()\n\n\n###########\n# Helpers #\n###########\n\n\n# undy hq\n\n\n@view\n@external\ndef getUndyHq() -> address:\n    return self._getUndyHq()\n\n\n@view\n@internal\ndef _getUndyHq() -> address:\n    return UNDY_HQ_FOR_ADDYS\n\n\n# utils\n\n\n@view\n@internal\ndef _isValidUndyAddr(_addr: address, _hq: address = empty(address)) -> bool:\n    hq: address = _hq\n    if _hq == empty(address):\n        hq = UNDY_HQ_FOR_ADDYS\n    \n    # core departments\n    if staticcall UndyHq(hq).isValidAddr(_addr):\n        return True\n\n    # lego book\n    legoBook: address = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID)\n    if legoBook != empty(address) and staticcall LegoBook(legoBook).isLegoAddr(_addr):\n        return True\n\n    # switchboard config\n    switchboard: address = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID)\n    if switchboard != empty(address) and staticcall Switchboard(switchboard).isSwitchboardAddr(_addr):\n        return True\n\n    return False\n\n\n@view\n@internal\ndef _isSwitchboardAddr(_addr: address) -> bool:\n    switchboard: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n    if switchboard == empty(address):\n        return False\n    return staticcall Switchboard(switchboard).isSwitchboardAddr(_addr)\n\n\n@view\n@internal\ndef _isLegoBookAddr(_addr: address) -> bool:\n    legoBook: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n    if legoBook == empty(address):\n        return False\n    return staticcall LegoBook(legoBook).isLegoAddr(_addr)\n\n\n###############\n# Departments #\n###############\n\n\n# ledger\n\n\n@view\n@internal\ndef _getLedgerId() -> uint256:\n    return LEDGER_ID\n\n\n@view\n@internal\ndef _getLedgerAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEDGER_ID)\n\n\n# mission control\n\n\n@view\n@internal\ndef _getMissionControlId() -> uint256:\n    return MISSION_CONTROL_ID\n\n\n@view\n@internal\ndef _getMissionControlAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(MISSION_CONTROL_ID)\n\n\n# lego book\n\n\n@view\n@internal\ndef _getLegoBookId() -> uint256:\n    return LEGO_BOOK_ID\n\n\n@view\n@internal\ndef _getLegoBookAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n\n\n# switchboard\n\n\n@view\n@internal\ndef _getSwitchboardId() -> uint256:\n    return SWITCHBOARD_ID\n\n\n@view\n@internal\ndef _getSwitchboardAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n\n\n# hatchery\n\n\n@view\n@internal\ndef _getHatcheryId() -> uint256:\n    return HATCHERY_ID\n\n\n@view\n@internal\ndef _getHatcheryAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(HATCHERY_ID)\n\n\n# loot distributor\n\n\n@view\n@internal\ndef _getLootDistributorId() -> uint256:\n    return LOOT_DISTRIBUTOR_ID\n\n\n@view\n@internal\ndef _getLootDistributorAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LOOT_DISTRIBUTOR_ID)\n\n\n# appraiser\n\n\n@view\n@internal\ndef _getAppraiserId() -> uint256:\n    return APPRAISER_ID\n\n\n@view\n@internal\ndef _getAppraiserAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(APPRAISER_ID)\n\n\n# wallet backpack\n\n\n@view\n@internal\ndef _getWalletBackpackId() -> uint256:\n    return WALLET_BACKPACK_ID\n\n\n@view\n@internal\ndef _getWalletBackpackAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(WALLET_BACKPACK_ID)\n\n\n# billing\n\n\n@view\n@internal\ndef _getBillingId() -> uint256:\n    return BILLING_ID\n\n\n@view\n@internal\ndef _getBillingAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(BILLING_ID)\n\n\n# vault registry\n\n\n@view\n@internal\ndef _getVaultRegistryId() -> uint256:\n    return VAULT_REGISTRY_ID\n\n\n@view\n@internal\ndef _getVaultRegistryAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(VAULT_REGISTRY_ID)",
            "sha256sum": "4df6b72db9bb417d1af81660175be1450cfb7b3575f3d17a5b8a130bff87b781"
          },
          "contracts/modules/YieldLegoData.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nuses: addys\n\nimport contracts.modules.Addys as addys\n\nfrom interfaces import WalletStructs as ws\nfrom interfaces import LegoStructs as ls\nfrom ethereum.ercs import IERC20\nfrom ethereum.ercs import IERC20Detailed\n\nevent AssetOpportunityAdded:\n    asset: indexed(address)\n    vaultAddr: indexed(address)\n\nevent AssetOpportunityRemoved:\n    asset: indexed(address)\n    vaultAddr: indexed(address)\n\nevent LegoPauseModified:\n    isPaused: bool\n\nevent LegoFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    balance: uint256\n\nevent PricePerShareSnapShotAdded:\n    vaultToken: indexed(address)\n    totalSupply: uint256\n    pricePerShare: uint256\n\nevent SnapShotPriceConfigSet:\n    minSnapshotDelay: uint256\n    maxNumSnapshots: uint256\n    maxUpsideDeviation: uint256\n    staleTime: uint256\n\n# core\nvaultToAsset: public(HashMap[address, ls.VaultTokenInfo]) # vault addr -> data\n\n# asset opportunities\nassetOpportunities: public(HashMap[address, HashMap[uint256, address]]) # asset -> index -> vault addr\nindexOfAssetOpportunity: public(HashMap[address, HashMap[address, uint256]]) # asset -> vault addr -> index\nnumAssetOpportunities: public(HashMap[address, uint256]) # asset -> number of opportunities\n\n# lego assets (iterable)\nassets: public(HashMap[uint256, address]) # index -> asset\nindexOfAsset: public(HashMap[address, uint256]) # asset -> index\nnumAssets: public(uint256) # num assets\n\n# price snapshots\nsnapShotData: public(HashMap[address, ls.SnapShotData]) # vault token -> data\nsnapShots: public(HashMap[address, HashMap[uint256, ls.SingleSnapShot]]) # vault token -> index -> snapshot\nsnapShotPriceConfig: public(ls.SnapShotPriceConfig) # config\n\nisPaused: public(bool)\n\nMAX_VAULTS: constant(uint256) = 40\nMAX_ASSETS: constant(uint256) = 20\nMAX_RECOVER_ASSETS: constant(uint256) = 20\nONE_DAY_SECONDS: constant(uint256) = 60 * 60 * 24\nONE_WEEK_SECONDS: constant(uint256) = ONE_DAY_SECONDS * 7\nHUNDRED_PERCENT: constant(uint256) = 100_00\n\n\n@deploy\ndef __init__(_shouldPause: bool):\n    self.isPaused = _shouldPause\n    self.numAssets = 1 # not using 0 index\n\n    # default snapshot price config\n    self.snapShotPriceConfig = ls.SnapShotPriceConfig(\n        minSnapshotDelay = 60 * 10, # 10 minutes\n        maxNumSnapshots = 20,\n        maxUpsideDeviation = 10_00, # 10%\n        staleTime = 3 * ONE_DAY_SECONDS, # 3 days\n    )\n\n\n#########\n# Views #\n#########\n\n\n# is lego asset\n\n\n@view\n@external\ndef isLegoAsset(_asset: address) -> bool:\n    return self._isLegoAsset(_asset)\n\n\n@view\n@internal\ndef _isLegoAsset(_asset: address) -> bool:\n    return self.indexOfAsset[_asset] != 0\n\n\n# vault opportunities\n\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, MAX_VAULTS]:\n    numOpportunities: uint256 = self.numAssetOpportunities[_asset]\n    if numOpportunities == 0:\n        return []\n    opportunities: DynArray[address, MAX_VAULTS] = []\n    for i: uint256 in range(1, numOpportunities, bound=MAX_VAULTS):\n        opportunities.append(self.assetOpportunities[_asset][i])\n    return opportunities\n\n\n# all assets registered\n\n\n@view\n@external\ndef getAssets() -> DynArray[address, MAX_ASSETS]:\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return []\n    assets: DynArray[address, MAX_ASSETS] = []\n    for i: uint256 in range(1, numAssets, bound=MAX_ASSETS):\n        assets.append(self.assets[i])\n    return assets\n\n\n################\n# Registration #\n################\n\n\n@view\n@external\ndef isAssetOpportunity(_asset: address, _vaultAddr: address) -> bool:\n    return self._isAssetOpportunity(_asset, _vaultAddr)\n\n\n@view\n@internal\ndef _isAssetOpportunity(_asset: address, _vaultAddr: address) -> bool:\n    return self.indexOfAssetOpportunity[_asset][_vaultAddr] != 0\n\n\n# add asset opportunity\n\n\n@internal\ndef _addAssetOpportunity(_asset: address, _vaultAddr: address) -> ls.VaultTokenInfo:\n    if self.indexOfAssetOpportunity[_asset][_vaultAddr] != 0:\n        return self.vaultToAsset[_vaultAddr]\n\n    if empty(address) in [_asset, _vaultAddr]:\n        return empty(ls.VaultTokenInfo)\n\n    # add asset opportunity\n    aid: uint256 = self.numAssetOpportunities[_asset]\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.assetOpportunities[_asset][aid] = _vaultAddr\n    self.indexOfAssetOpportunity[_asset][_vaultAddr] = aid\n    self.numAssetOpportunities[_asset] = aid + 1\n\n    # add mapping\n    vaultInfo: ls.VaultTokenInfo = ls.VaultTokenInfo(\n        underlyingAsset = _asset,\n        decimals = convert(staticcall IERC20Detailed(_vaultAddr).decimals(), uint256),\n        lastAveragePricePerShare = 0,\n    )\n    self.vaultToAsset[_vaultAddr] = vaultInfo\n\n    # add asset\n    self._addAsset(_asset)\n\n    log AssetOpportunityAdded(asset=_asset, vaultAddr=_vaultAddr)\n    return vaultInfo\n\n\n# remove asset opportunity\n\n\n@internal\ndef _removeAssetOpportunity(_asset: address, _vaultAddr: address):\n    numOpportunities: uint256 = self.numAssetOpportunities[_asset]\n    if numOpportunities == 0:\n        return\n\n    targetIndex: uint256 = self.indexOfAssetOpportunity[_asset][_vaultAddr]\n    if targetIndex == 0:\n        return\n\n    # update data\n    lastIndex: uint256 = numOpportunities - 1\n    self.numAssetOpportunities[_asset] = lastIndex\n    self.indexOfAssetOpportunity[_asset][_vaultAddr] = 0\n\n    self.vaultToAsset[_vaultAddr] = empty(ls.VaultTokenInfo)\n\n    # shift to replace the removed one\n    if targetIndex != lastIndex:\n        lastVaultAddr: address = self.assetOpportunities[_asset][lastIndex]\n        self.assetOpportunities[_asset][targetIndex] = lastVaultAddr\n        self.indexOfAssetOpportunity[_asset][lastVaultAddr] = targetIndex\n\n    # remove asset\n    if lastIndex <= 1:\n        self._removeAsset(_asset)\n\n    log AssetOpportunityRemoved(asset=_asset, vaultAddr=_vaultAddr)\n\n\n# add asset\n\n\n@internal\ndef _addAsset(_asset: address):\n    if self.indexOfAsset[_asset] != 0:\n        return\n\n    aid: uint256 = self.numAssets\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.assets[aid] = _asset\n    self.indexOfAsset[_asset] = aid\n    self.numAssets = aid + 1\n\n\n# remove asset\n\n\n@internal\ndef _removeAsset(_asset: address):\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return\n\n    targetIndex: uint256 = self.indexOfAsset[_asset]\n    if targetIndex == 0:\n        return\n\n    # update data\n    lastIndex: uint256 = numAssets - 1\n    self.numAssets = lastIndex\n    self.indexOfAsset[_asset] = 0\n\n    # shift to replace the removed one\n    if targetIndex != lastIndex:\n        lastAsset: address = self.assets[lastIndex]\n        self.assets[targetIndex] = lastAsset\n        self.indexOfAsset[lastAsset] = targetIndex\n\n\n# num lego assets (true number, use `numAssets` for iteration)\n\n\n@view\n@external\ndef getNumLegoAssets() -> uint256:\n    return self._getNumLegoAssets()\n\n\n@view\n@internal\ndef _getNumLegoAssets() -> uint256:\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return 0\n    return numAssets - 1\n\n\n###########\n# General #\n###########\n\n\n# fill mini addys\n\n\n@view\n@internal\ndef _getMiniAddys(_miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> ws.MiniAddys:\n    if _miniAddys.ledger != empty(address):\n        return _miniAddys\n    return ws.MiniAddys(\n        ledger = addys._getLedgerAddr(),\n        missionControl = addys._getMissionControlAddr(),\n        legoBook = addys._getLegoBookAddr(),\n        appraiser = addys._getAppraiserAddr(),\n    )\n\n\n# activate\n\n\n@external\ndef pause(_shouldPause: bool):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert _shouldPause != self.isPaused # dev: no change\n    self.isPaused = _shouldPause\n    log LegoPauseModified(isPaused=_shouldPause)\n\n\n# recover funds\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    self._recoverFunds(_recipient, _asset)\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, MAX_RECOVER_ASSETS]):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    for a: address in _assets:\n        self._recoverFunds(_recipient, a)\n\n\n@internal\ndef _recoverFunds(_recipient: address, _asset: address):\n    assert empty(address) not in [_recipient, _asset] # dev: invalid recipient or asset\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    assert balance != 0 # dev: nothing to recover\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log LegoFundsRecovered(asset=_asset, recipient=_recipient, balance=balance)\n\n\n###################\n# Price Snapshots #\n###################\n\n\n# add price snapshot\n\n\n@internal\ndef _addPriceSnapshot(_vaultToken: address, _pricePerShare: uint256, _vaultTokenDecimals: uint256) -> bool:\n    config: ls.SnapShotPriceConfig = self.snapShotPriceConfig\n    if config.maxNumSnapshots == 0:\n        return False\n\n    data: ls.SnapShotData = self.snapShotData[_vaultToken]\n\n    # already have snapshot for this time\n    if data.lastSnapShot.lastUpdate == block.timestamp:\n        return False\n\n    # check if snapshot is too recent\n    if data.lastSnapShot.lastUpdate + config.minSnapshotDelay > block.timestamp:\n        return False\n\n    # create and store new snapshot\n    newSnapshot: ls.SingleSnapShot = self._getLatestSnapshot(_vaultToken, _pricePerShare, _vaultTokenDecimals, data.lastSnapShot, config)\n    data.lastSnapShot = newSnapshot\n    self.snapShots[_vaultToken][data.nextIndex] = newSnapshot\n\n    # update index\n    data.nextIndex += 1\n    if data.nextIndex >= config.maxNumSnapshots:\n        data.nextIndex = 0\n\n    # save snap shot data\n    self.snapShotData[_vaultToken] = data\n\n    # update cached weighted average price per share\n    self.vaultToAsset[_vaultToken].lastAveragePricePerShare = self._getWeightedPricePerShare(_vaultToken, _pricePerShare)\n\n    log PricePerShareSnapShotAdded(\n        vaultToken = _vaultToken,\n        totalSupply = newSnapshot.totalSupply,\n        pricePerShare = newSnapshot.pricePerShare,\n    )\n    return True\n\n\n# weighted price per share\n\n\n@view\n@external\ndef getWeightedPricePerShare(_vaultToken: address) -> uint256:\n    data: ls.SnapShotData = self.snapShotData[_vaultToken]\n    return self._getWeightedPricePerShare(_vaultToken, data.lastSnapShot.pricePerShare)\n\n\n@view\n@internal\ndef _getWeightedPricePerShare(_vaultToken: address, _lastPricePerShare: uint256) -> uint256:\n    config: ls.SnapShotPriceConfig = self.snapShotPriceConfig\n    if config.maxNumSnapshots == 0:\n        return 0\n\n    # calculate weighted average price using all valid snapshots\n    numerator: uint256 = 0\n    denominator: uint256 = 0\n    for i: uint256 in range(config.maxNumSnapshots, bound=max_value(uint256)):\n\n        snapShot: ls.SingleSnapShot = self.snapShots[_vaultToken][i]\n        if snapShot.pricePerShare == 0 or snapShot.totalSupply == 0 or snapShot.lastUpdate == 0:\n            continue\n\n        # too stale, skip\n        if config.staleTime != 0 and block.timestamp > snapShot.lastUpdate + config.staleTime:\n            continue\n\n        numerator += (snapShot.totalSupply * snapShot.pricePerShare)\n        denominator += snapShot.totalSupply\n\n    # weighted price per share\n    weightedPricePerShare: uint256 = 0\n    if numerator != 0:\n        weightedPricePerShare = numerator // denominator\n    else:\n        weightedPricePerShare = _lastPricePerShare\n\n    return weightedPricePerShare\n\n\n# latest snapshot\n\n\n@view\n@external\ndef getLatestSnapshot(_vaultToken: address, _pricePerShare: uint256) -> ls.SingleSnapShot:\n    data: ls.SnapShotData = self.snapShotData[_vaultToken]\n    config: ls.SnapShotPriceConfig = self.snapShotPriceConfig\n    vaultTokenDecimals: uint256 = self.vaultToAsset[_vaultToken].decimals\n    return self._getLatestSnapshot(_vaultToken, _pricePerShare, vaultTokenDecimals, data.lastSnapShot, config)\n\n\n@view\n@internal\ndef _getLatestSnapshot(\n    _vaultToken: address,\n    _pricePerShare: uint256,\n    _vaultTokenDecimals: uint256,\n    _lastSnapShot: ls.SingleSnapShot,\n    _config: ls.SnapShotPriceConfig,\n) -> ls.SingleSnapShot:\n\n    # total supply (adjusted)\n    totalSupply: uint256 = staticcall IERC20(_vaultToken).totalSupply() // (10 ** _vaultTokenDecimals)\n    if totalSupply == 0:\n        totalSupply = 1\n\n    # throttle upside (extra safety check)\n    pricePerShare: uint256 = self._throttleUpside(_pricePerShare, _lastSnapShot.pricePerShare, _config.maxUpsideDeviation)\n\n    return ls.SingleSnapShot(\n        totalSupply = totalSupply,\n        pricePerShare = pricePerShare,\n        lastUpdate = block.timestamp,\n    )\n\n\n@view\n@internal\ndef _throttleUpside(_newValue: uint256, _prevValue: uint256, _maxUpside: uint256) -> uint256:\n    if _maxUpside == 0 or _prevValue == 0 or _newValue == 0:\n        return _newValue\n    maxPricePerShare: uint256 = _prevValue + (_prevValue * _maxUpside // HUNDRED_PERCENT)\n    return min(_newValue, maxPricePerShare)\n\n\n# snapshot price config\n\n\n@external\ndef setSnapShotPriceConfig(_config: ls.SnapShotPriceConfig):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert self._isValidPriceConfig(_config) # dev: invalid config\n    self.snapShotPriceConfig = _config\n    log SnapShotPriceConfigSet(\n        minSnapshotDelay=_config.minSnapshotDelay,\n        maxNumSnapshots=_config.maxNumSnapshots,\n        maxUpsideDeviation=_config.maxUpsideDeviation,\n        staleTime=_config.staleTime\n    )\n\n\n@view\n@external\ndef isValidPriceConfig(_config: ls.SnapShotPriceConfig) -> bool:\n    return self._isValidPriceConfig(_config)\n\n\n@view\n@internal\ndef _isValidPriceConfig(_config: ls.SnapShotPriceConfig) -> bool:\n    if _config.minSnapshotDelay > ONE_WEEK_SECONDS:\n        return False\n    if _config.maxNumSnapshots == 0 or _config.maxNumSnapshots > 25:\n        return False\n    if _config.maxUpsideDeviation > HUNDRED_PERCENT:\n        return False\n    return _config.staleTime < ONE_WEEK_SECONDS",
            "sha256sum": "d695c6d3998cf2ed318a0da6f4f7918abf97661e10eb510ed996d815e65927e0"
          },
          "contracts/legos/yield/Euler.vy": {
            "content": "#     __   __ ___ _______ ___     ______       ___     _______ _______ _______ \n#    |  | |  |   |       |   |   |      |     |   |   |       |       |       |\n#    |  |_|  |   |    ___|   |   |  _    |    |   |   |    ___|    ___|   _   |\n#    |       |   |   |___|   |   | | |   |    |   |   |   |___|   | __|  | |  |\n#    |_     _|   |    ___|   |___| |_|   |    |   |___|    ___|   ||  |  |_|  |\n#      |   | |   |   |___|       |       |    |       |   |___|   |_| |       |\n#      |___| |___|_______|_______|______|     |_______|_______|_______|_______|\n#                                                                       \n#     \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n#     \u2551  ** Euler Lego **                       \u2551\n#     \u2551  Integration with Euler Protocol.       \u2551\n#     \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n#\n#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nimplements: Lego\nimplements: YieldLego\n\nexports: addys.__interface__\nexports: yld.__interface__\n\ninitializes: addys\ninitializes: yld[addys := addys]\n\nfrom interfaces import LegoPartner as Lego\nfrom interfaces import YieldLego as YieldLego\nfrom interfaces import WalletStructs as ws\nfrom interfaces import LegoStructs as ls\n\nimport contracts.modules.Addys as addys\nimport contracts.modules.YieldLegoData as yld\n\nfrom ethereum.ercs import IERC20\nfrom ethereum.ercs import IERC4626\n\ninterface Appraiser:\n    def getUsdValue(_asset: address, _amount: uint256, _missionControl: address = empty(address), _legoBook: address = empty(address), _ledger: address = empty(address)) -> uint256: view\n    def updatePriceAndGetUsdValue(_asset: address, _amount: uint256, _missionControl: address = empty(address), _legoBook: address = empty(address)) -> uint256: nonpayable\n\ninterface Ledger:\n    def setVaultToken(_vaultToken: address, _legoId: uint256, _underlyingAsset: address, _decimals: uint256, _isRebasing: bool): nonpayable\n    def isRegisteredVaultToken(_vaultToken: address) -> bool: view\n\ninterface EulerRewardsDistributor:\n    def claim(_users: DynArray[address, 10], _rewardTokens: DynArray[address, 10], _claimAmounts: DynArray[uint256, 10], _proofs: DynArray[bytes32, 10]): nonpayable\n    def operators(_user: address, _operator: address) -> bool: view\n\ninterface EulerEarnFactory:\n    def isValidDeployment(_vault: address) -> bool: view\n\ninterface EulerEvaultFactory:\n    def isProxy(_vault: address) -> bool: view\n\ninterface Registry:\n    def getRegId(_addr: address) -> uint256: view\n\ninterface EulerVault:\n    def totalBorrows() -> uint256: view\n\nevent EulerDeposit:\n    sender: indexed(address)\n    asset: indexed(address)\n    vaultToken: indexed(address)\n    assetAmountDeposited: uint256\n    usdValue: uint256\n    vaultTokenAmountReceived: uint256\n    recipient: address\n\nevent EulerWithdrawal:\n    sender: indexed(address)\n    asset: indexed(address)\n    vaultToken: indexed(address)\n    assetAmountReceived: uint256\n    usdValue: uint256\n    vaultTokenAmountBurned: uint256\n    recipient: address\n\nevent EulerRewardsAddrSet:\n    addr: address\n\n# rewards contract\neulerRewards: public(address)\n\n# euler\nEULER_EVAULT_FACTORY: public(immutable(address))\nEULER_EARN_FACTORY: public(immutable(address))\n\nMAX_TOKEN_PATH: constant(uint256) = 5\nLEGO_ACCESS_ABI: constant(String[64]) = \"toggleOperator(address,address)\"\n\n\n@deploy\ndef __init__(\n    _undyHq: address,\n    _evaultFactory: address,\n    _earnFactory: address,\n    _eulerRewardsAddr: address,\n):\n    addys.__init__(_undyHq)\n    yld.__init__(False)\n\n    assert empty(address) not in [_evaultFactory, _earnFactory] # dev: invalid addrs\n    EULER_EVAULT_FACTORY = _evaultFactory\n    EULER_EARN_FACTORY = _earnFactory\n    self.eulerRewards = _eulerRewardsAddr\n\n\n@view\n@external\ndef hasCapability(_action: ws.ActionType) -> bool:\n    return _action in (\n        ws.ActionType.EARN_DEPOSIT | \n        ws.ActionType.EARN_WITHDRAW |\n        ws.ActionType.REWARDS\n    )\n\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    return [EULER_EVAULT_FACTORY, EULER_EARN_FACTORY]\n\n\n@view\n@external\ndef isYieldLego() -> bool:\n    return True\n\n\n@view\n@external\ndef isDexLego() -> bool:\n    return False\n\n\n###################\n# Underlying Data #\n###################\n\n\n# underlying asset\n\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    return self._getUnderlyingAsset(_vaultToken)\n\n\n@view\n@internal\ndef _getUnderlyingAsset(_vaultToken: address) -> address:\n    return yld.vaultToAsset[_vaultToken].underlyingAsset\n\n\n# underlying balances (both true and safe)\n\n\n@view\n@external\ndef getUnderlyingBalances(_vaultToken: address, _vaultTokenBalance: uint256) -> (uint256, uint256):\n    if _vaultTokenBalance == 0:\n        return 0, 0\n\n    trueUnderlying: uint256 = self._getUnderlyingAmount(_vaultToken, _vaultTokenBalance)\n    safeUnderlying: uint256 = self._getUnderlyingAmountSafe(_vaultToken, _vaultTokenBalance)\n    if safeUnderlying == 0:\n        safeUnderlying = trueUnderlying\n\n    return trueUnderlying, min(trueUnderlying, safeUnderlying)\n\n\n# underlying amount (true)\n\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    return self._getUnderlyingAmount(_vaultToken, _vaultTokenAmount)\n\n\n@view\n@internal\ndef _getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    return staticcall IERC4626(_vaultToken).convertToAssets(_vaultTokenAmount)\n\n\n# underlying amount (safe)\n\n\n@view\n@external\ndef getUnderlyingAmountSafe(_vaultToken: address, _vaultTokenBalance: uint256) -> uint256:\n    return self._getUnderlyingAmountSafe(_vaultToken, _vaultTokenBalance)\n\n\n@view\n@internal\ndef _getUnderlyingAmountSafe(_vaultToken: address, _vaultTokenBalance: uint256) -> uint256:\n    vaultInfo: ls.VaultTokenInfo = yld.vaultToAsset[_vaultToken]\n    if vaultInfo.decimals == 0:\n        return 0 # not registered\n\n    # safe underlying amount (using cached weighted average from snapshots)\n    return _vaultTokenBalance * vaultInfo.lastAveragePricePerShare // (10 ** vaultInfo.decimals)\n\n\n# underlying data (combined)\n\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> (address, uint256, uint256):\n    return self._getUnderlyingData(_vaultToken, _vaultTokenAmount, _appraiser)\n\n\n@view\n@internal\ndef _getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address) -> (address, uint256, uint256):\n    asset: address = self._getUnderlyingAsset(_vaultToken)\n    if asset == empty(address):\n        return empty(address), 0, 0 # invalid vault token\n    underlyingAmount: uint256 = self._getUnderlyingAmount(_vaultToken, _vaultTokenAmount)\n    usdValue: uint256 = self._getUsdValue(asset, underlyingAmount, _appraiser)\n    return asset, underlyingAmount, usdValue\n\n\n# usd value\n\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> uint256:\n    return self._getUsdValueOfVaultToken(_vaultToken, _vaultTokenAmount, _appraiser)\n\n\n@view\n@internal\ndef _getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address) -> uint256:\n    return self._getUnderlyingData(_vaultToken, _vaultTokenAmount, _appraiser)[2]\n\n\n@view\n@internal\ndef _getUsdValue(_asset: address, _amount: uint256, _appraiser: address) -> uint256:\n    appraiser: address = _appraiser\n    if _appraiser == empty(address):\n        appraiser = addys._getAppraiserAddr()\n    return staticcall Appraiser(appraiser).getUsdValue(_asset, _amount)\n\n\n###############\n# Other Utils #\n###############\n\n\n# basics\n\n\n@view\n@external\ndef isRebasing() -> bool:\n    return self._isRebasing()\n\n\n@view\n@internal\ndef _isRebasing() -> bool:\n    return False\n\n\n# price per share\n\n\n@view\n@external\ndef getPricePerShare(_vaultToken: address, _decimals: uint256 = 0) -> uint256:\n    decimals: uint256 = _decimals\n    if decimals == 0:\n        decimals = yld.vaultToAsset[_vaultToken].decimals\n    if decimals == 0:\n        return 0 # not registered\n    return self._getPricePerShare(_vaultToken, decimals)\n\n\n@view\n@internal\ndef _getPricePerShare(_vaultToken: address, _decimals: uint256) -> uint256:\n    return staticcall IERC4626(_vaultToken).convertToAssets(10 ** _decimals)\n\n\n# vault token amount\n\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    return staticcall IERC4626(_vaultToken).convertToShares(_assetAmount)\n\n\n# extras\n\n\n@view\n@external\ndef isEligibleVaultForTrialFunds(_vaultToken: address, _underlyingAsset: address) -> bool:\n    return False\n\n\n@view\n@external\ndef isEligibleForYieldBonus(_asset: address) -> bool:\n    return False\n\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    return staticcall IERC4626(_vaultToken).totalAssets()\n\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    return staticcall EulerVault(_vaultToken).totalBorrows()\n\n\n################\n# Registration #\n################\n\n\n# can vault be registered\n\n\n@view\n@external\ndef canRegisterVaultToken(_asset: address, _vaultToken: address) -> bool:\n    return self._canRegisterVaultToken(_asset, _vaultToken)\n\n\n@view\n@internal\ndef _canRegisterVaultToken(_asset: address, _vaultToken: address) -> bool:\n    if empty(address) in [_asset, _vaultToken]:\n        return False\n    if staticcall IERC4626(_vaultToken).asset() != _asset:\n        return False\n    return staticcall EulerEvaultFactory(EULER_EVAULT_FACTORY).isProxy(_vaultToken) or staticcall EulerEarnFactory(EULER_EARN_FACTORY).isValidDeployment(_vaultToken)\n\n\n# register vault token locally\n\n\n@external\ndef registerVaultTokenLocally(_asset: address, _vaultAddr: address) -> ls.VaultTokenInfo:\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert self._canRegisterVaultToken(_asset, _vaultAddr) # dev: cannot register vault token\n    assert not yld._isAssetOpportunity(_asset, _vaultAddr) # dev: already registered\n    vaultInfo: ls.VaultTokenInfo = self._registerVaultTokenLocally(_asset, _vaultAddr)\n    self._registerVaultTokenGlobally(_asset, _vaultAddr, vaultInfo.decimals, addys._getLedgerAddr(), addys._getLegoBookAddr())\n    return vaultInfo\n\n\n@internal\ndef _registerVaultTokenLocally(_asset: address, _vaultAddr: address) -> ls.VaultTokenInfo:\n    assert extcall IERC20(_asset).approve(_vaultAddr, max_value(uint256), default_return_value=True) # dev: max approval failed\n    vaultInfo: ls.VaultTokenInfo = yld._addAssetOpportunity(_asset, _vaultAddr)\n    assert vaultInfo.decimals != 0 # dev: invalid vault token\n    return vaultInfo\n\n\n# remove vault token locally\n\n\n@external\ndef deregisterVaultTokenLocally(_asset: address, _vaultAddr: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert yld._isAssetOpportunity(_asset, _vaultAddr) # dev: already registered\n    self._deregisterVaultTokenLocally(_asset, _vaultAddr)\n\n\n@internal\ndef _deregisterVaultTokenLocally(_asset: address, _vaultAddr: address):\n    assert extcall IERC20(_asset).approve(_vaultAddr, 0, default_return_value=True) # dev: max approval failed\n    yld._removeAssetOpportunity(_asset, _vaultAddr)\n\n\n# ledger registration\n\n\n@internal\ndef _registerVaultTokenGlobally(_underlyingAsset: address, _vaultToken: address, _decimals: uint256, _ledger: address, _legoBook: address):\n    if not staticcall Ledger(_ledger).isRegisteredVaultToken(_vaultToken):\n        legoId: uint256 = staticcall Registry(_legoBook).getRegId(self)\n        extcall Ledger(_ledger).setVaultToken(_vaultToken, legoId, _underlyingAsset, _decimals, self._isRebasing())\n\n\n#################\n# Yield Actions #\n#################\n\n\n# add price snapshot\n\n\n@external\ndef addPriceSnapshot(_vaultToken: address) -> bool:\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    vaultInfo: ls.VaultTokenInfo = yld.vaultToAsset[_vaultToken]\n    assert vaultInfo.decimals != 0 # dev: not registered\n    pricePerShare: uint256 = self._getPricePerShare(_vaultToken, vaultInfo.decimals)\n    return yld._addPriceSnapshot(_vaultToken, pricePerShare, vaultInfo.decimals)\n\n\n# deposit\n\n\n@external\ndef depositForYield(\n    _asset: address,\n    _amount: uint256,\n    _vaultAddr: address,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, address, uint256, uint256):\n    assert not yld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = yld._getMiniAddys(_miniAddys)\n    vaultInfo: ls.VaultTokenInfo = self._getVaultInfoOnDeposit(_asset, _vaultAddr, miniAddys.ledger, miniAddys.legoBook)\n\n    # pre balances\n    preLegoBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n\n    # transfer deposit asset to this contract\n    depositAmount: uint256 = min(_amount, staticcall IERC20(_asset).balanceOf(msg.sender))\n    assert depositAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_asset).transferFrom(msg.sender, self, depositAmount, default_return_value=True) # dev: transfer failed\n\n    # deposit assets into lego partner\n    vaultTokenAmountReceived: uint256 = extcall IERC4626(_vaultAddr).deposit(depositAmount, _recipient)\n    assert vaultTokenAmountReceived != 0 # dev: no vault tokens received\n\n    # refund if full deposit didn't get through\n    currentLegoBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    refundAssetAmount: uint256 = 0\n    if currentLegoBalance > preLegoBalance:\n        refundAssetAmount = currentLegoBalance - preLegoBalance\n        assert extcall IERC20(_asset).transfer(msg.sender, refundAssetAmount, default_return_value=True) # dev: transfer failed\n        depositAmount -= refundAssetAmount\n\n    usdValue: uint256 = extcall Appraiser(miniAddys.appraiser).updatePriceAndGetUsdValue(_asset, depositAmount, miniAddys.missionControl, miniAddys.legoBook)\n    log EulerDeposit(\n        sender = msg.sender,\n        asset = _asset,\n        vaultToken = _vaultAddr,\n        assetAmountDeposited = depositAmount,\n        usdValue = usdValue,\n        vaultTokenAmountReceived = vaultTokenAmountReceived,\n        recipient = _recipient,\n    )\n\n    # add price snapshot\n    pricePerShare: uint256 = self._getPricePerShare(_vaultAddr, vaultInfo.decimals)\n    yld._addPriceSnapshot(_vaultAddr, pricePerShare, vaultInfo.decimals)\n\n    return depositAmount, _vaultAddr, vaultTokenAmountReceived, usdValue\n\n\n# vault info on deposit\n\n\n@internal\ndef _getVaultInfoOnDeposit(_asset: address, _vaultAddr: address, _ledger: address, _legoBook: address) -> ls.VaultTokenInfo:\n    vaultInfo: ls.VaultTokenInfo = yld.vaultToAsset[_vaultAddr]\n    if vaultInfo.decimals == 0:\n        assert self._canRegisterVaultToken(_asset, _vaultAddr) # dev: cannot register vault token\n        vaultInfo = self._registerVaultTokenLocally(_asset, _vaultAddr)\n        self._registerVaultTokenGlobally(_asset, _vaultAddr, vaultInfo.decimals, _ledger, _legoBook)\n    else:\n        assert vaultInfo.underlyingAsset == _asset # dev: asset mismatch\n    return vaultInfo\n\n\n# withdraw\n\n\n@external\ndef withdrawFromYield(\n    _vaultToken: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, address, uint256, uint256):\n    assert not yld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = yld._getMiniAddys(_miniAddys)\n    vaultInfo: ls.VaultTokenInfo = self._getVaultInfoOnWithdrawal(_vaultToken, miniAddys.ledger, miniAddys.legoBook)\n\n    # pre balances\n    preLegoVaultBalance: uint256 = staticcall IERC20(_vaultToken).balanceOf(self)\n\n    # transfer vaults tokens to this contract\n    vaultTokenAmount: uint256 = min(_amount, staticcall IERC20(_vaultToken).balanceOf(msg.sender))\n    assert vaultTokenAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_vaultToken).transferFrom(msg.sender, self, vaultTokenAmount, default_return_value=True) # dev: transfer failed\n\n    # withdraw assets from lego partner\n    assetAmountReceived: uint256 = extcall IERC4626(_vaultToken).redeem(vaultTokenAmount, _recipient, self)\n    assert assetAmountReceived != 0 # dev: no asset amount received\n\n    # refund if full withdrawal didn't happen\n    currentLegoVaultBalance: uint256 = staticcall IERC20(_vaultToken).balanceOf(self)\n    refundVaultTokenAmount: uint256 = 0\n    if currentLegoVaultBalance > preLegoVaultBalance:\n        refundVaultTokenAmount = currentLegoVaultBalance - preLegoVaultBalance\n        assert extcall IERC20(_vaultToken).transfer(msg.sender, refundVaultTokenAmount, default_return_value=True) # dev: transfer failed\n        vaultTokenAmount -= refundVaultTokenAmount\n\n    usdValue: uint256 = extcall Appraiser(miniAddys.appraiser).updatePriceAndGetUsdValue(vaultInfo.underlyingAsset, assetAmountReceived, miniAddys.missionControl, miniAddys.legoBook)\n    log EulerWithdrawal(\n        sender = msg.sender,\n        asset = vaultInfo.underlyingAsset,\n        vaultToken = _vaultToken,\n        assetAmountReceived = assetAmountReceived,\n        usdValue = usdValue,\n        vaultTokenAmountBurned = vaultTokenAmount,\n        recipient = _recipient,\n    )\n\n    # add price snapshot\n    pricePerShare: uint256 = self._getPricePerShare(_vaultToken, vaultInfo.decimals)\n    yld._addPriceSnapshot(_vaultToken, pricePerShare, vaultInfo.decimals)\n\n    return vaultTokenAmount, vaultInfo.underlyingAsset, assetAmountReceived, usdValue\n\n\n# vault info on withdrawal\n\n\n@internal\ndef _getVaultInfoOnWithdrawal(_vaultAddr: address, _ledger: address, _legoBook: address) -> ls.VaultTokenInfo:\n    vaultInfo: ls.VaultTokenInfo = yld.vaultToAsset[_vaultAddr]\n    if vaultInfo.decimals == 0:\n        asset: address = staticcall IERC4626(_vaultAddr).asset()\n        assert self._canRegisterVaultToken(asset, _vaultAddr) # dev: cannot register vault token\n        vaultInfo = self._registerVaultTokenLocally(asset, _vaultAddr)\n        self._registerVaultTokenGlobally(asset, _vaultAddr, vaultInfo.decimals, _ledger, _legoBook)\n    return vaultInfo\n\n\n#################\n# Claim Rewards #\n#################\n\n\n@external\ndef claimRewards(\n    _user: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _extraData: bytes32,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    assert not yld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = yld._getMiniAddys(_miniAddys)\n\n    assert msg.sender == _user # dev: recipient must be caller\n    preBalance: uint256 = staticcall IERC20(_rewardToken).balanceOf(_user)\n\n    eulerRewards: address = self.eulerRewards\n    assert eulerRewards != empty(address) # dev: no eulerRewards rewards addr set\n    extcall EulerRewardsDistributor(eulerRewards).claim([_user], [_rewardToken], [_rewardAmount], [_extraData])\n    rewardAmount: uint256 = staticcall IERC20(_rewardToken).balanceOf(_user) - preBalance\n    assert rewardAmount != 0 # dev: no rewards received\n\n    usdValue: uint256 = extcall Appraiser(miniAddys.appraiser).updatePriceAndGetUsdValue(_rewardToken, rewardAmount, miniAddys.missionControl, miniAddys.legoBook)\n    return rewardAmount, usdValue\n\n\n@view\n@external\ndef hasClaimableRewards(_user: address) -> bool:\n    # as far as we can tell, this must be done offchain\n    return False\n\n\n# set rewards addr\n\n\n@external\ndef setEulerRewardsAddr(_addr: address) -> bool:\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert _addr != empty(address) # dev: invalid addr\n    self.eulerRewards = _addr\n    log EulerRewardsAddrSet(addr=_addr)\n    return True\n\n\n# access control\n\n\n@view\n@external\ndef getAccessForLego(_user: address, _action: ws.ActionType) -> (address, String[64], uint256):\n    if _action != ws.ActionType.REWARDS:\n        return empty(address), empty(String[64]), 0\n\n    eulerRewards: address = self.eulerRewards\n    if staticcall EulerRewardsDistributor(eulerRewards).operators(_user, self):\n        return empty(address), empty(String[64]), 0\n    else:\n        return eulerRewards, LEGO_ACCESS_ABI, 2\n\n\n#########\n# Other #\n#########\n\n\n@external\ndef swapTokens(\n    _amountIn: uint256,\n    _minAmountOut: uint256,\n    _tokenPath: DynArray[address, MAX_TOKEN_PATH],\n    _poolPath: DynArray[address, MAX_TOKEN_PATH - 1],\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256):\n    return 0, 0, 0\n\n\n@external\ndef mintOrRedeemAsset(\n    _tokenIn: address,\n    _tokenOut: address,\n    _tokenInAmount: uint256,\n    _minAmountOut: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, bool, uint256):\n    return 0, 0, False, 0\n\n\n@external\ndef confirmMintOrRedeemAsset(\n    _tokenIn: address,\n    _tokenOut: address,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef addCollateral(\n    _asset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef removeCollateral(\n    _asset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef borrow(\n    _borrowAsset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef repayDebt(\n    _paymentAsset: address,\n    _paymentAmount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef addLiquidity(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _amountA: uint256,\n    _amountB: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _minLpAmount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (address, uint256, uint256, uint256, uint256):\n    return empty(address), 0, 0, 0, 0\n\n\n@external\ndef removeLiquidity(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpToken: address,\n    _lpAmount: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, uint256):\n    return 0, 0, 0, 0\n\n\n@external\ndef addLiquidityConcentrated(\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _tickLower: int24,\n    _tickUpper: int24,\n    _amountA: uint256,\n    _amountB: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, uint256, uint256):\n    return 0, 0, 0, 0, 0\n\n\n@external\ndef removeLiquidityConcentrated(\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _liqToRemove: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, bool, uint256):\n    return 0, 0, 0, False, 0",
            "sha256sum": "01db31b0c5e5571e5fa6f55e51566d1907ff4f554a0057e964e3da2b5d543dd8"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/legos/yield/Euler.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.3+commit.bff19ea2",
        "integrity": "07def23337d943c3328c74b907dd18e6be86da784ccb076bc0333f7aead207ff"
      },
      "args": "00000000000000000000000044cf3c4f000dfd76a35d03298049d37be688d6f90000000000000000000000007f321498a801a191a93c840750ed637149ddf8d000000000000000000000000072bbdb652f2aec9056115644efccdd1986f51f150000000000000000000000003ef3d8ba38ebe18db133cec108f4d14ce00dd9ae",
      "file": "contracts/legos/yield/Euler.vy"
    },
    "Fluid": {
      "address": "0x33069eDf8c108D8bd2ea21d05f5E7F1E8DD0Eb66",
      "abi": [
        {
          "name": "FluidDeposit",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountDeposited",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultTokenAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "FluidWithdrawal",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultTokenAmountBurned",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LegoPauseModified",
          "inputs": [
            {
              "name": "isPaused",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LegoFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "balance",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "SnapShotPriceConfigSet",
          "inputs": [
            {
              "name": "minSnapshotDelay",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "maxNumSnapshots",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "maxUpsideDeviation",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "staleTime",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetOpportunityAdded",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultAddr",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetOpportunityRemoved",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultAddr",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PricePerShareSnapShotAdded",
          "inputs": [
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "totalSupply",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "pricePerShare",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddys",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "undyToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "hatchery",
                  "type": "address"
                },
                {
                  "name": "lootDistributor",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                },
                {
                  "name": "walletBackpack",
                  "type": "address"
                },
                {
                  "name": "billing",
                  "type": "address"
                },
                {
                  "name": "vaultRegistry",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUndyHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isLegoAsset",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssetOpportunities",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isAssetOpportunity",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getNumLegoAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pause",
          "inputs": [
            {
              "name": "_shouldPause",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFundsMany",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_assets",
              "type": "address[]"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getWeightedPricePerShare",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLatestSnapshot",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_pricePerShare",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "totalSupply",
                  "type": "uint256"
                },
                {
                  "name": "pricePerShare",
                  "type": "uint256"
                },
                {
                  "name": "lastUpdate",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setSnapShotPriceConfig",
          "inputs": [
            {
              "name": "_config",
              "type": "tuple",
              "components": [
                {
                  "name": "minSnapshotDelay",
                  "type": "uint256"
                },
                {
                  "name": "maxNumSnapshots",
                  "type": "uint256"
                },
                {
                  "name": "maxUpsideDeviation",
                  "type": "uint256"
                },
                {
                  "name": "staleTime",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidPriceConfig",
          "inputs": [
            {
              "name": "_config",
              "type": "tuple",
              "components": [
                {
                  "name": "minSnapshotDelay",
                  "type": "uint256"
                },
                {
                  "name": "maxNumSnapshots",
                  "type": "uint256"
                },
                {
                  "name": "maxUpsideDeviation",
                  "type": "uint256"
                },
                {
                  "name": "staleTime",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "vaultToAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "underlyingAsset",
                  "type": "address"
                },
                {
                  "name": "decimals",
                  "type": "uint256"
                },
                {
                  "name": "lastAveragePricePerShare",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assetOpportunities",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAssetOpportunity",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssetOpportunities",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assets",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "snapShotData",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "lastSnapShot",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "totalSupply",
                      "type": "uint256"
                    },
                    {
                      "name": "pricePerShare",
                      "type": "uint256"
                    },
                    {
                      "name": "lastUpdate",
                      "type": "uint256"
                    }
                  ]
                },
                {
                  "name": "nextIndex",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "snapShots",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "totalSupply",
                  "type": "uint256"
                },
                {
                  "name": "pricePerShare",
                  "type": "uint256"
                },
                {
                  "name": "lastUpdate",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "snapShotPriceConfig",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "minSnapshotDelay",
                  "type": "uint256"
                },
                {
                  "name": "maxNumSnapshots",
                  "type": "uint256"
                },
                {
                  "name": "maxUpsideDeviation",
                  "type": "uint256"
                },
                {
                  "name": "staleTime",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isPaused",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasCapability",
          "inputs": [
            {
              "name": "_action",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRegistries",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isYieldLego",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isDexLego",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAsset",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingBalances",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenBalance",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAmount",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAmountSafe",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenBalance",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingData",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingData",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            },
            {
              "name": "_appraiser",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValueOfVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValueOfVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            },
            {
              "name": "_appraiser",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isRebasing",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPricePerShare",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPricePerShare",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_decimals",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getVaultTokenAmount",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_assetAmount",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isEligibleVaultForTrialFunds",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_underlyingAsset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isEligibleForYieldBonus",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalAssets",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalBorrows",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canRegisterVaultToken",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "registerVaultTokenLocally",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "underlyingAsset",
                  "type": "address"
                },
                {
                  "name": "decimals",
                  "type": "uint256"
                },
                {
                  "name": "lastAveragePricePerShare",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "deregisterVaultTokenLocally",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addPriceSnapshot",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositForYield",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositForYield",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawFromYield",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawFromYield",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAccessForLego",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_action",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "string"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasClaimableRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_tokenPath",
              "type": "address[]"
            },
            {
              "name": "_poolPath",
              "type": "address[]"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_tokenPath",
              "type": "address[]"
            },
            {
              "name": "_poolPath",
              "type": "address[]"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_tokenInAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_tokenInAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmMintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmMintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_borrowAsset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_borrowAsset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_paymentAsset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_paymentAsset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "FLUID_RESOLVER",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_undyHq",
              "type": "address"
            },
            {
              "name": "_fluidResolver",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "interfaces/WalletStructs.vyi": {
            "content": "# @version 0.4.3\n\nflag ActionType:\n    TRANSFER\n    EARN_DEPOSIT\n    EARN_WITHDRAW\n    EARN_REBALANCE\n    SWAP\n    MINT_REDEEM\n    CONFIRM_MINT_REDEEM\n    ADD_COLLATERAL\n    REMOVE_COLLATERAL\n    BORROW\n    REPAY_DEBT\n    REWARDS\n    ETH_TO_WETH\n    WETH_TO_ETH\n    ADD_LIQ\n    REMOVE_LIQ\n    ADD_LIQ_CONC\n    REMOVE_LIQ_CONC\n    PAY_CHEQUE\n\nstruct WalletAssetData:\n    assetBalance: uint256\n    usdValue: uint256\n    isYieldAsset: bool\n    lastPricePerShare: uint256\n\nstruct ActionData:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    billing: address\n    wallet: address\n    walletConfig: address\n    walletOwner: address\n    inEjectMode: bool\n    isFrozen: bool\n    lastTotalUsdValue: uint256\n    signer: address\n    isManager: bool\n    legoId: uint256\n    legoAddr: address\n    eth: address\n    weth: address\n\nstruct MiniAddys:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    appraiser: address",
            "sha256sum": "9a4b4f59b3a62043e51b425a665064aae419a3c0bd0514b6b29a9441ae364bb9"
          },
          "interfaces/LegoPartner.vyi": {
            "content": "# @version 0.4.3\n\nfrom interfaces import WalletStructs as ws\n\nMAX_TOKEN_PATH: constant(uint256) = 5\nMAX_RECOVER_ASSETS: constant(uint256) = 20\n\n@external\ndef addLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _tickLower: int24, _tickUpper: int24, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef addLiquidity(_pool: address, _tokenA: address, _tokenB: address, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _minLpAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (address, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef removeLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _liqToRemove: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef removeLiquidity(_pool: address, _tokenA: address, _tokenB: address, _lpToken: address, _lpAmount: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef mintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _tokenInAmount: uint256, _minAmountOut: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef swapTokens(_amountIn: uint256, _minAmountOut: uint256, _tokenPath: DynArray[address, MAX_TOKEN_PATH], _poolPath: DynArray[address, MAX_TOKEN_PATH - 1], _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256):\n    ...\n\n@external\ndef depositForYield(_asset: address, _amount: uint256, _vaultAddr: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef withdrawFromYield(_vaultToken: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef confirmMintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef borrow(_borrowAsset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef repayDebt(_paymentAsset: address, _paymentAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef claimRewards(_user: address, _rewardToken: address, _rewardAmount: uint256, _extraData: bytes32, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef removeCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef addCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@view\n@external\ndef getAccessForLego(_user: address, _action: ws.ActionType) -> (address, String[64], uint256):\n    ...\n\n@view\n@external\ndef hasCapability(_action: ws.ActionType) -> bool:\n    ...\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    ...\n\n@view\n@external\ndef isYieldLego() -> bool:\n    ...\n\n@view\n@external\ndef isDexLego() -> bool:\n    ...\n\n\n# common\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "81db71fe4440a3b4b563134c9b5caf1d5705772a5f291fe874c9b5fb3cfb1623"
          },
          "interfaces/LegoStructs.vyi": {
            "content": "# @version 0.4.3\n\nstruct VaultTokenInfo:\n    underlyingAsset: address\n    decimals: uint256\n    lastAveragePricePerShare: uint256\n\nstruct SnapShotPriceConfig:\n    minSnapshotDelay: uint256\n    maxNumSnapshots: uint256\n    maxUpsideDeviation: uint256\n    staleTime: uint256\n\nstruct SingleSnapShot:\n    totalSupply: uint256\n    pricePerShare: uint256\n    lastUpdate: uint256\n\nstruct SnapShotData:\n    lastSnapShot: SingleSnapShot\n    nextIndex: uint256\n",
            "sha256sum": "8ae48be17d812d57fbd671bbf0593e8abf175ad0924e47c5997823cac19ec806"
          },
          "interfaces/YieldLego.vyi": {
            "content": "# @version 0.4.3\n\nfrom interfaces import LegoStructs as ls\n\n\n###################\n# Underlying Data #\n###################\n\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    ...\n\n\n@view\n@external\ndef getUnderlyingBalances(_vaultToken: address, _vaultTokenBalance: uint256) -> (uint256, uint256):\n    ...\n\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    ...\n\n\n@view\n@external\ndef getUnderlyingAmountSafe(_vaultToken: address, _vaultTokenBalance: uint256) -> uint256:\n    ...\n\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> (address, uint256, uint256):\n    ...\n\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> uint256:\n    ...\n\n\n###############\n# Other Utils #\n###############\n\n\n@view\n@external\ndef isRebasing() -> bool:\n    ...\n\n\n@view\n@external\ndef getPricePerShare(_vaultToken: address, _decimals: uint256 = 0) -> uint256:\n    ...\n\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef canRegisterVaultToken(_asset: address, _vaultToken: address) -> bool:\n    ...\n\n\n@view\n@external\ndef isEligibleVaultForTrialFunds(_vaultToken: address, _underlyingAsset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef isEligibleForYieldBonus(_asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    ...\n\n\n###################\n# Yield Lego Data #\n###################\n\n\n@view\n@external\ndef isLegoAsset(_asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, 40]:\n    ...\n\n\n@view\n@external\ndef getAssets() -> DynArray[address, 20]:\n    ...\n\n\n@view\n@external\ndef isAssetOpportunity(_asset: address, _vaultAddr: address) -> bool:\n    ...\n\n\n@view\n@external\ndef getNumLegoAssets() -> uint256:\n    ...\n\n\n@view\n@external\ndef assets(_index: uint256) -> address:\n    ...\n\n\n@view\n@external\ndef indexOfAsset(_asset: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef numAssets() -> uint256:\n    ...\n\n\n@view\n@external\ndef assetOpportunities(_asset: address, _index: uint256) -> address:\n    ...\n\n\n@view\n@external\ndef indexOfAssetOpportunity(_asset: address, _vaultAddr: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef numAssetOpportunities(_asset: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef vaultToAsset(_vaultAddr: address) -> ls.VaultTokenInfo:\n    ...\n\n\n# price snapshots\n\n\n@external\ndef addPriceSnapshot(_vaultToken: address) -> bool:\n    ...\n\n\n@view\n@external\ndef snapShotPriceConfig() -> ls.SnapShotPriceConfig:\n    ...\n\n\n@view\n@external\ndef snapShotData(_vaultToken: address) -> ls.SnapShotData:\n    ...\n\n\n@view\n@external\ndef snapShots(_vaultToken: address, _index: uint256) -> ls.SingleSnapShot:\n    ...\n\n\n@view\n@external\ndef getWeightedPricePerShare(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef getLatestSnapshot(_vaultToken: address, _pricePerShare: uint256) -> ls.SingleSnapShot:\n    ...\n\n\n@external\ndef setSnapShotPriceConfig(_config: ls.SnapShotPriceConfig):\n    ...\n",
            "sha256sum": "045a6bbd3d556234cf4fe925a303002dc0ac3c482d344ffbaf4bc52a7e6ad2df"
          },
          "contracts/modules/Addys.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\ninterface UndyHq:\n    def isValidAddr(_addr: address) -> bool: view\n    def getAddr(_regId: uint256) -> address: view\n    def undyToken() -> address: view\n\ninterface Switchboard:\n    def isSwitchboardAddr(_addr: address) -> bool: view\n\ninterface LegoBook:\n    def isLegoAddr(_addr: address) -> bool: view\n\nstruct Addys:\n    hq: address\n    undyToken: address\n    ledger: address\n    missionControl: address\n    legoBook: address\n    switchboard: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    walletBackpack: address\n    billing: address\n    vaultRegistry: address\n\n# hq\nUNDY_HQ_FOR_ADDYS: immutable(address)\n\n# core addys\nLEDGER_ID: constant(uint256) = 1\nMISSION_CONTROL_ID: constant(uint256) = 2\nLEGO_BOOK_ID: constant(uint256) = 3\nSWITCHBOARD_ID: constant(uint256) = 4\nHATCHERY_ID: constant(uint256) = 5\nLOOT_DISTRIBUTOR_ID: constant(uint256) = 6\nAPPRAISER_ID: constant(uint256) = 7\nWALLET_BACKPACK_ID: constant(uint256) = 8\nBILLING_ID: constant(uint256) = 9\nVAULT_REGISTRY_ID: constant(uint256) = 10\n\n\n@deploy\ndef __init__(_undyHq: address):\n    assert _undyHq != empty(address) # dev: invalid undy hq\n    UNDY_HQ_FOR_ADDYS = _undyHq\n\n\n########\n# Core #\n########\n\n\n@view\n@external\ndef getAddys() -> Addys:\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _getAddys(_addys: Addys = empty(Addys)) -> Addys:\n    if _addys.hq != empty(address):\n        return _addys\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _generateAddys() -> Addys:\n    hq: address = UNDY_HQ_FOR_ADDYS\n    return Addys(\n        hq = hq,\n        undyToken = staticcall UndyHq(hq).undyToken(),\n        ledger = staticcall UndyHq(hq).getAddr(LEDGER_ID),\n        missionControl = staticcall UndyHq(hq).getAddr(MISSION_CONTROL_ID),\n        legoBook = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID),\n        switchboard = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID),\n        hatchery = staticcall UndyHq(hq).getAddr(HATCHERY_ID),\n        lootDistributor = staticcall UndyHq(hq).getAddr(LOOT_DISTRIBUTOR_ID),\n        appraiser = staticcall UndyHq(hq).getAddr(APPRAISER_ID),\n        walletBackpack = staticcall UndyHq(hq).getAddr(WALLET_BACKPACK_ID),\n        billing = staticcall UndyHq(hq).getAddr(BILLING_ID),\n        vaultRegistry = staticcall UndyHq(hq).getAddr(VAULT_REGISTRY_ID),\n    )\n\n\n##########\n# Tokens #\n##########\n\n\n@view\n@internal\ndef _getUndyToken() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).undyToken()\n\n\n###########\n# Helpers #\n###########\n\n\n# undy hq\n\n\n@view\n@external\ndef getUndyHq() -> address:\n    return self._getUndyHq()\n\n\n@view\n@internal\ndef _getUndyHq() -> address:\n    return UNDY_HQ_FOR_ADDYS\n\n\n# utils\n\n\n@view\n@internal\ndef _isValidUndyAddr(_addr: address, _hq: address = empty(address)) -> bool:\n    hq: address = _hq\n    if _hq == empty(address):\n        hq = UNDY_HQ_FOR_ADDYS\n    \n    # core departments\n    if staticcall UndyHq(hq).isValidAddr(_addr):\n        return True\n\n    # lego book\n    legoBook: address = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID)\n    if legoBook != empty(address) and staticcall LegoBook(legoBook).isLegoAddr(_addr):\n        return True\n\n    # switchboard config\n    switchboard: address = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID)\n    if switchboard != empty(address) and staticcall Switchboard(switchboard).isSwitchboardAddr(_addr):\n        return True\n\n    return False\n\n\n@view\n@internal\ndef _isSwitchboardAddr(_addr: address) -> bool:\n    switchboard: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n    if switchboard == empty(address):\n        return False\n    return staticcall Switchboard(switchboard).isSwitchboardAddr(_addr)\n\n\n@view\n@internal\ndef _isLegoBookAddr(_addr: address) -> bool:\n    legoBook: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n    if legoBook == empty(address):\n        return False\n    return staticcall LegoBook(legoBook).isLegoAddr(_addr)\n\n\n###############\n# Departments #\n###############\n\n\n# ledger\n\n\n@view\n@internal\ndef _getLedgerId() -> uint256:\n    return LEDGER_ID\n\n\n@view\n@internal\ndef _getLedgerAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEDGER_ID)\n\n\n# mission control\n\n\n@view\n@internal\ndef _getMissionControlId() -> uint256:\n    return MISSION_CONTROL_ID\n\n\n@view\n@internal\ndef _getMissionControlAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(MISSION_CONTROL_ID)\n\n\n# lego book\n\n\n@view\n@internal\ndef _getLegoBookId() -> uint256:\n    return LEGO_BOOK_ID\n\n\n@view\n@internal\ndef _getLegoBookAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n\n\n# switchboard\n\n\n@view\n@internal\ndef _getSwitchboardId() -> uint256:\n    return SWITCHBOARD_ID\n\n\n@view\n@internal\ndef _getSwitchboardAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n\n\n# hatchery\n\n\n@view\n@internal\ndef _getHatcheryId() -> uint256:\n    return HATCHERY_ID\n\n\n@view\n@internal\ndef _getHatcheryAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(HATCHERY_ID)\n\n\n# loot distributor\n\n\n@view\n@internal\ndef _getLootDistributorId() -> uint256:\n    return LOOT_DISTRIBUTOR_ID\n\n\n@view\n@internal\ndef _getLootDistributorAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LOOT_DISTRIBUTOR_ID)\n\n\n# appraiser\n\n\n@view\n@internal\ndef _getAppraiserId() -> uint256:\n    return APPRAISER_ID\n\n\n@view\n@internal\ndef _getAppraiserAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(APPRAISER_ID)\n\n\n# wallet backpack\n\n\n@view\n@internal\ndef _getWalletBackpackId() -> uint256:\n    return WALLET_BACKPACK_ID\n\n\n@view\n@internal\ndef _getWalletBackpackAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(WALLET_BACKPACK_ID)\n\n\n# billing\n\n\n@view\n@internal\ndef _getBillingId() -> uint256:\n    return BILLING_ID\n\n\n@view\n@internal\ndef _getBillingAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(BILLING_ID)\n\n\n# vault registry\n\n\n@view\n@internal\ndef _getVaultRegistryId() -> uint256:\n    return VAULT_REGISTRY_ID\n\n\n@view\n@internal\ndef _getVaultRegistryAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(VAULT_REGISTRY_ID)",
            "sha256sum": "4df6b72db9bb417d1af81660175be1450cfb7b3575f3d17a5b8a130bff87b781"
          },
          "contracts/modules/YieldLegoData.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nuses: addys\n\nimport contracts.modules.Addys as addys\n\nfrom interfaces import WalletStructs as ws\nfrom interfaces import LegoStructs as ls\nfrom ethereum.ercs import IERC20\nfrom ethereum.ercs import IERC20Detailed\n\nevent AssetOpportunityAdded:\n    asset: indexed(address)\n    vaultAddr: indexed(address)\n\nevent AssetOpportunityRemoved:\n    asset: indexed(address)\n    vaultAddr: indexed(address)\n\nevent LegoPauseModified:\n    isPaused: bool\n\nevent LegoFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    balance: uint256\n\nevent PricePerShareSnapShotAdded:\n    vaultToken: indexed(address)\n    totalSupply: uint256\n    pricePerShare: uint256\n\nevent SnapShotPriceConfigSet:\n    minSnapshotDelay: uint256\n    maxNumSnapshots: uint256\n    maxUpsideDeviation: uint256\n    staleTime: uint256\n\n# core\nvaultToAsset: public(HashMap[address, ls.VaultTokenInfo]) # vault addr -> data\n\n# asset opportunities\nassetOpportunities: public(HashMap[address, HashMap[uint256, address]]) # asset -> index -> vault addr\nindexOfAssetOpportunity: public(HashMap[address, HashMap[address, uint256]]) # asset -> vault addr -> index\nnumAssetOpportunities: public(HashMap[address, uint256]) # asset -> number of opportunities\n\n# lego assets (iterable)\nassets: public(HashMap[uint256, address]) # index -> asset\nindexOfAsset: public(HashMap[address, uint256]) # asset -> index\nnumAssets: public(uint256) # num assets\n\n# price snapshots\nsnapShotData: public(HashMap[address, ls.SnapShotData]) # vault token -> data\nsnapShots: public(HashMap[address, HashMap[uint256, ls.SingleSnapShot]]) # vault token -> index -> snapshot\nsnapShotPriceConfig: public(ls.SnapShotPriceConfig) # config\n\nisPaused: public(bool)\n\nMAX_VAULTS: constant(uint256) = 40\nMAX_ASSETS: constant(uint256) = 20\nMAX_RECOVER_ASSETS: constant(uint256) = 20\nONE_DAY_SECONDS: constant(uint256) = 60 * 60 * 24\nONE_WEEK_SECONDS: constant(uint256) = ONE_DAY_SECONDS * 7\nHUNDRED_PERCENT: constant(uint256) = 100_00\n\n\n@deploy\ndef __init__(_shouldPause: bool):\n    self.isPaused = _shouldPause\n    self.numAssets = 1 # not using 0 index\n\n    # default snapshot price config\n    self.snapShotPriceConfig = ls.SnapShotPriceConfig(\n        minSnapshotDelay = 60 * 10, # 10 minutes\n        maxNumSnapshots = 20,\n        maxUpsideDeviation = 10_00, # 10%\n        staleTime = 3 * ONE_DAY_SECONDS, # 3 days\n    )\n\n\n#########\n# Views #\n#########\n\n\n# is lego asset\n\n\n@view\n@external\ndef isLegoAsset(_asset: address) -> bool:\n    return self._isLegoAsset(_asset)\n\n\n@view\n@internal\ndef _isLegoAsset(_asset: address) -> bool:\n    return self.indexOfAsset[_asset] != 0\n\n\n# vault opportunities\n\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, MAX_VAULTS]:\n    numOpportunities: uint256 = self.numAssetOpportunities[_asset]\n    if numOpportunities == 0:\n        return []\n    opportunities: DynArray[address, MAX_VAULTS] = []\n    for i: uint256 in range(1, numOpportunities, bound=MAX_VAULTS):\n        opportunities.append(self.assetOpportunities[_asset][i])\n    return opportunities\n\n\n# all assets registered\n\n\n@view\n@external\ndef getAssets() -> DynArray[address, MAX_ASSETS]:\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return []\n    assets: DynArray[address, MAX_ASSETS] = []\n    for i: uint256 in range(1, numAssets, bound=MAX_ASSETS):\n        assets.append(self.assets[i])\n    return assets\n\n\n################\n# Registration #\n################\n\n\n@view\n@external\ndef isAssetOpportunity(_asset: address, _vaultAddr: address) -> bool:\n    return self._isAssetOpportunity(_asset, _vaultAddr)\n\n\n@view\n@internal\ndef _isAssetOpportunity(_asset: address, _vaultAddr: address) -> bool:\n    return self.indexOfAssetOpportunity[_asset][_vaultAddr] != 0\n\n\n# add asset opportunity\n\n\n@internal\ndef _addAssetOpportunity(_asset: address, _vaultAddr: address) -> ls.VaultTokenInfo:\n    if self.indexOfAssetOpportunity[_asset][_vaultAddr] != 0:\n        return self.vaultToAsset[_vaultAddr]\n\n    if empty(address) in [_asset, _vaultAddr]:\n        return empty(ls.VaultTokenInfo)\n\n    # add asset opportunity\n    aid: uint256 = self.numAssetOpportunities[_asset]\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.assetOpportunities[_asset][aid] = _vaultAddr\n    self.indexOfAssetOpportunity[_asset][_vaultAddr] = aid\n    self.numAssetOpportunities[_asset] = aid + 1\n\n    # add mapping\n    vaultInfo: ls.VaultTokenInfo = ls.VaultTokenInfo(\n        underlyingAsset = _asset,\n        decimals = convert(staticcall IERC20Detailed(_vaultAddr).decimals(), uint256),\n        lastAveragePricePerShare = 0,\n    )\n    self.vaultToAsset[_vaultAddr] = vaultInfo\n\n    # add asset\n    self._addAsset(_asset)\n\n    log AssetOpportunityAdded(asset=_asset, vaultAddr=_vaultAddr)\n    return vaultInfo\n\n\n# remove asset opportunity\n\n\n@internal\ndef _removeAssetOpportunity(_asset: address, _vaultAddr: address):\n    numOpportunities: uint256 = self.numAssetOpportunities[_asset]\n    if numOpportunities == 0:\n        return\n\n    targetIndex: uint256 = self.indexOfAssetOpportunity[_asset][_vaultAddr]\n    if targetIndex == 0:\n        return\n\n    # update data\n    lastIndex: uint256 = numOpportunities - 1\n    self.numAssetOpportunities[_asset] = lastIndex\n    self.indexOfAssetOpportunity[_asset][_vaultAddr] = 0\n\n    self.vaultToAsset[_vaultAddr] = empty(ls.VaultTokenInfo)\n\n    # shift to replace the removed one\n    if targetIndex != lastIndex:\n        lastVaultAddr: address = self.assetOpportunities[_asset][lastIndex]\n        self.assetOpportunities[_asset][targetIndex] = lastVaultAddr\n        self.indexOfAssetOpportunity[_asset][lastVaultAddr] = targetIndex\n\n    # remove asset\n    if lastIndex <= 1:\n        self._removeAsset(_asset)\n\n    log AssetOpportunityRemoved(asset=_asset, vaultAddr=_vaultAddr)\n\n\n# add asset\n\n\n@internal\ndef _addAsset(_asset: address):\n    if self.indexOfAsset[_asset] != 0:\n        return\n\n    aid: uint256 = self.numAssets\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.assets[aid] = _asset\n    self.indexOfAsset[_asset] = aid\n    self.numAssets = aid + 1\n\n\n# remove asset\n\n\n@internal\ndef _removeAsset(_asset: address):\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return\n\n    targetIndex: uint256 = self.indexOfAsset[_asset]\n    if targetIndex == 0:\n        return\n\n    # update data\n    lastIndex: uint256 = numAssets - 1\n    self.numAssets = lastIndex\n    self.indexOfAsset[_asset] = 0\n\n    # shift to replace the removed one\n    if targetIndex != lastIndex:\n        lastAsset: address = self.assets[lastIndex]\n        self.assets[targetIndex] = lastAsset\n        self.indexOfAsset[lastAsset] = targetIndex\n\n\n# num lego assets (true number, use `numAssets` for iteration)\n\n\n@view\n@external\ndef getNumLegoAssets() -> uint256:\n    return self._getNumLegoAssets()\n\n\n@view\n@internal\ndef _getNumLegoAssets() -> uint256:\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return 0\n    return numAssets - 1\n\n\n###########\n# General #\n###########\n\n\n# fill mini addys\n\n\n@view\n@internal\ndef _getMiniAddys(_miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> ws.MiniAddys:\n    if _miniAddys.ledger != empty(address):\n        return _miniAddys\n    return ws.MiniAddys(\n        ledger = addys._getLedgerAddr(),\n        missionControl = addys._getMissionControlAddr(),\n        legoBook = addys._getLegoBookAddr(),\n        appraiser = addys._getAppraiserAddr(),\n    )\n\n\n# activate\n\n\n@external\ndef pause(_shouldPause: bool):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert _shouldPause != self.isPaused # dev: no change\n    self.isPaused = _shouldPause\n    log LegoPauseModified(isPaused=_shouldPause)\n\n\n# recover funds\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    self._recoverFunds(_recipient, _asset)\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, MAX_RECOVER_ASSETS]):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    for a: address in _assets:\n        self._recoverFunds(_recipient, a)\n\n\n@internal\ndef _recoverFunds(_recipient: address, _asset: address):\n    assert empty(address) not in [_recipient, _asset] # dev: invalid recipient or asset\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    assert balance != 0 # dev: nothing to recover\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log LegoFundsRecovered(asset=_asset, recipient=_recipient, balance=balance)\n\n\n###################\n# Price Snapshots #\n###################\n\n\n# add price snapshot\n\n\n@internal\ndef _addPriceSnapshot(_vaultToken: address, _pricePerShare: uint256, _vaultTokenDecimals: uint256) -> bool:\n    config: ls.SnapShotPriceConfig = self.snapShotPriceConfig\n    if config.maxNumSnapshots == 0:\n        return False\n\n    data: ls.SnapShotData = self.snapShotData[_vaultToken]\n\n    # already have snapshot for this time\n    if data.lastSnapShot.lastUpdate == block.timestamp:\n        return False\n\n    # check if snapshot is too recent\n    if data.lastSnapShot.lastUpdate + config.minSnapshotDelay > block.timestamp:\n        return False\n\n    # create and store new snapshot\n    newSnapshot: ls.SingleSnapShot = self._getLatestSnapshot(_vaultToken, _pricePerShare, _vaultTokenDecimals, data.lastSnapShot, config)\n    data.lastSnapShot = newSnapshot\n    self.snapShots[_vaultToken][data.nextIndex] = newSnapshot\n\n    # update index\n    data.nextIndex += 1\n    if data.nextIndex >= config.maxNumSnapshots:\n        data.nextIndex = 0\n\n    # save snap shot data\n    self.snapShotData[_vaultToken] = data\n\n    # update cached weighted average price per share\n    self.vaultToAsset[_vaultToken].lastAveragePricePerShare = self._getWeightedPricePerShare(_vaultToken, _pricePerShare)\n\n    log PricePerShareSnapShotAdded(\n        vaultToken = _vaultToken,\n        totalSupply = newSnapshot.totalSupply,\n        pricePerShare = newSnapshot.pricePerShare,\n    )\n    return True\n\n\n# weighted price per share\n\n\n@view\n@external\ndef getWeightedPricePerShare(_vaultToken: address) -> uint256:\n    data: ls.SnapShotData = self.snapShotData[_vaultToken]\n    return self._getWeightedPricePerShare(_vaultToken, data.lastSnapShot.pricePerShare)\n\n\n@view\n@internal\ndef _getWeightedPricePerShare(_vaultToken: address, _lastPricePerShare: uint256) -> uint256:\n    config: ls.SnapShotPriceConfig = self.snapShotPriceConfig\n    if config.maxNumSnapshots == 0:\n        return 0\n\n    # calculate weighted average price using all valid snapshots\n    numerator: uint256 = 0\n    denominator: uint256 = 0\n    for i: uint256 in range(config.maxNumSnapshots, bound=max_value(uint256)):\n\n        snapShot: ls.SingleSnapShot = self.snapShots[_vaultToken][i]\n        if snapShot.pricePerShare == 0 or snapShot.totalSupply == 0 or snapShot.lastUpdate == 0:\n            continue\n\n        # too stale, skip\n        if config.staleTime != 0 and block.timestamp > snapShot.lastUpdate + config.staleTime:\n            continue\n\n        numerator += (snapShot.totalSupply * snapShot.pricePerShare)\n        denominator += snapShot.totalSupply\n\n    # weighted price per share\n    weightedPricePerShare: uint256 = 0\n    if numerator != 0:\n        weightedPricePerShare = numerator // denominator\n    else:\n        weightedPricePerShare = _lastPricePerShare\n\n    return weightedPricePerShare\n\n\n# latest snapshot\n\n\n@view\n@external\ndef getLatestSnapshot(_vaultToken: address, _pricePerShare: uint256) -> ls.SingleSnapShot:\n    data: ls.SnapShotData = self.snapShotData[_vaultToken]\n    config: ls.SnapShotPriceConfig = self.snapShotPriceConfig\n    vaultTokenDecimals: uint256 = self.vaultToAsset[_vaultToken].decimals\n    return self._getLatestSnapshot(_vaultToken, _pricePerShare, vaultTokenDecimals, data.lastSnapShot, config)\n\n\n@view\n@internal\ndef _getLatestSnapshot(\n    _vaultToken: address,\n    _pricePerShare: uint256,\n    _vaultTokenDecimals: uint256,\n    _lastSnapShot: ls.SingleSnapShot,\n    _config: ls.SnapShotPriceConfig,\n) -> ls.SingleSnapShot:\n\n    # total supply (adjusted)\n    totalSupply: uint256 = staticcall IERC20(_vaultToken).totalSupply() // (10 ** _vaultTokenDecimals)\n    if totalSupply == 0:\n        totalSupply = 1\n\n    # throttle upside (extra safety check)\n    pricePerShare: uint256 = self._throttleUpside(_pricePerShare, _lastSnapShot.pricePerShare, _config.maxUpsideDeviation)\n\n    return ls.SingleSnapShot(\n        totalSupply = totalSupply,\n        pricePerShare = pricePerShare,\n        lastUpdate = block.timestamp,\n    )\n\n\n@view\n@internal\ndef _throttleUpside(_newValue: uint256, _prevValue: uint256, _maxUpside: uint256) -> uint256:\n    if _maxUpside == 0 or _prevValue == 0 or _newValue == 0:\n        return _newValue\n    maxPricePerShare: uint256 = _prevValue + (_prevValue * _maxUpside // HUNDRED_PERCENT)\n    return min(_newValue, maxPricePerShare)\n\n\n# snapshot price config\n\n\n@external\ndef setSnapShotPriceConfig(_config: ls.SnapShotPriceConfig):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert self._isValidPriceConfig(_config) # dev: invalid config\n    self.snapShotPriceConfig = _config\n    log SnapShotPriceConfigSet(\n        minSnapshotDelay=_config.minSnapshotDelay,\n        maxNumSnapshots=_config.maxNumSnapshots,\n        maxUpsideDeviation=_config.maxUpsideDeviation,\n        staleTime=_config.staleTime\n    )\n\n\n@view\n@external\ndef isValidPriceConfig(_config: ls.SnapShotPriceConfig) -> bool:\n    return self._isValidPriceConfig(_config)\n\n\n@view\n@internal\ndef _isValidPriceConfig(_config: ls.SnapShotPriceConfig) -> bool:\n    if _config.minSnapshotDelay > ONE_WEEK_SECONDS:\n        return False\n    if _config.maxNumSnapshots == 0 or _config.maxNumSnapshots > 25:\n        return False\n    if _config.maxUpsideDeviation > HUNDRED_PERCENT:\n        return False\n    return _config.staleTime < ONE_WEEK_SECONDS",
            "sha256sum": "d695c6d3998cf2ed318a0da6f4f7918abf97661e10eb510ed996d815e65927e0"
          },
          "contracts/legos/yield/Fluid.vy": {
            "content": "#     __   __ ___ _______ ___     ______       ___     _______ _______ _______ \n#    |  | |  |   |       |   |   |      |     |   |   |       |       |       |\n#    |  |_|  |   |    ___|   |   |  _    |    |   |   |    ___|    ___|   _   |\n#    |       |   |   |___|   |   | | |   |    |   |   |   |___|   | __|  | |  |\n#    |_     _|   |    ___|   |___| |_|   |    |   |___|    ___|   ||  |  |_|  |\n#      |   | |   |   |___|       |       |    |       |   |___|   |_| |       |\n#      |___| |___|_______|_______|______|     |_______|_______|_______|_______|\n#                                                                       \n#     \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n#     \u2551  ** Fluid Lego **                       \u2551\n#     \u2551  Integration with Fluid Protocol.       \u2551\n#     \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n#\n#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nimplements: Lego\nimplements: YieldLego\n\nexports: addys.__interface__\nexports: yld.__interface__\n\ninitializes: addys\ninitializes: yld[addys := addys]\n\nfrom interfaces import LegoPartner as Lego\nfrom interfaces import YieldLego as YieldLego\nfrom interfaces import WalletStructs as ws\nfrom interfaces import LegoStructs as ls\n\nimport contracts.modules.Addys as addys\nimport contracts.modules.YieldLegoData as yld\n\nfrom ethereum.ercs import IERC20\nfrom ethereum.ercs import IERC4626\n\ninterface Appraiser:\n    def getUsdValue(_asset: address, _amount: uint256, _missionControl: address = empty(address), _legoBook: address = empty(address), _ledger: address = empty(address)) -> uint256: view\n    def updatePriceAndGetUsdValue(_asset: address, _amount: uint256, _missionControl: address = empty(address), _legoBook: address = empty(address)) -> uint256: nonpayable\n\ninterface Ledger:\n    def setVaultToken(_vaultToken: address, _legoId: uint256, _underlyingAsset: address, _decimals: uint256, _isRebasing: bool): nonpayable\n    def isRegisteredVaultToken(_vaultToken: address) -> bool: view\n\ninterface FluidLendingResolver:\n    def getAllFTokens() -> DynArray[address, MAX_FTOKENS]: view\n\ninterface Registry:\n    def getRegId(_addr: address) -> uint256: view\n\nevent FluidDeposit:\n    sender: indexed(address)\n    asset: indexed(address)\n    vaultToken: indexed(address)\n    assetAmountDeposited: uint256\n    usdValue: uint256\n    vaultTokenAmountReceived: uint256\n    recipient: address\n\nevent FluidWithdrawal:\n    sender: indexed(address)\n    asset: indexed(address)\n    vaultToken: indexed(address)\n    assetAmountReceived: uint256\n    usdValue: uint256\n    vaultTokenAmountBurned: uint256\n    recipient: address\n\n# fluid\nFLUID_RESOLVER: public(immutable(address))\n\nMAX_FTOKENS: constant(uint256) = 50\nMAX_TOKEN_PATH: constant(uint256) = 5\n\n\n@deploy\ndef __init__(\n    _undyHq: address,\n    _fluidResolver: address,\n):\n    addys.__init__(_undyHq)\n    yld.__init__(False)\n\n    assert _fluidResolver != empty(address) # dev: invalid addrs\n    FLUID_RESOLVER = _fluidResolver\n\n\n@view\n@external\ndef hasCapability(_action: ws.ActionType) -> bool:\n    return _action in (\n        ws.ActionType.EARN_DEPOSIT | \n        ws.ActionType.EARN_WITHDRAW\n    )\n\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    return [FLUID_RESOLVER]\n\n\n@view\n@external\ndef isYieldLego() -> bool:\n    return True\n\n\n@view\n@external\ndef isDexLego() -> bool:\n    return False\n\n\n###################\n# Underlying Data #\n###################\n\n\n# underlying asset\n\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    return self._getUnderlyingAsset(_vaultToken)\n\n\n@view\n@internal\ndef _getUnderlyingAsset(_vaultToken: address) -> address:\n    return yld.vaultToAsset[_vaultToken].underlyingAsset\n\n\n# underlying balances (both true and safe)\n\n\n@view\n@external\ndef getUnderlyingBalances(_vaultToken: address, _vaultTokenBalance: uint256) -> (uint256, uint256):\n    if _vaultTokenBalance == 0:\n        return 0, 0\n\n    trueUnderlying: uint256 = self._getUnderlyingAmount(_vaultToken, _vaultTokenBalance)\n    safeUnderlying: uint256 = self._getUnderlyingAmountSafe(_vaultToken, _vaultTokenBalance)\n    if safeUnderlying == 0:\n        safeUnderlying = trueUnderlying\n\n    return trueUnderlying, min(trueUnderlying, safeUnderlying)\n\n\n# underlying amount (true)\n\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    return self._getUnderlyingAmount(_vaultToken, _vaultTokenAmount)\n\n\n@view\n@internal\ndef _getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    return staticcall IERC4626(_vaultToken).convertToAssets(_vaultTokenAmount)\n\n\n# underlying amount (safe)\n\n\n@view\n@external\ndef getUnderlyingAmountSafe(_vaultToken: address, _vaultTokenBalance: uint256) -> uint256:\n    return self._getUnderlyingAmountSafe(_vaultToken, _vaultTokenBalance)\n\n\n@view\n@internal\ndef _getUnderlyingAmountSafe(_vaultToken: address, _vaultTokenBalance: uint256) -> uint256:\n    vaultInfo: ls.VaultTokenInfo = yld.vaultToAsset[_vaultToken]\n    if vaultInfo.decimals == 0:\n        return 0 # not registered\n\n    # safe underlying amount (using cached weighted average from snapshots)\n    return _vaultTokenBalance * vaultInfo.lastAveragePricePerShare // (10 ** vaultInfo.decimals)\n\n\n# underlying data (combined)\n\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> (address, uint256, uint256):\n    return self._getUnderlyingData(_vaultToken, _vaultTokenAmount, _appraiser)\n\n\n@view\n@internal\ndef _getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address) -> (address, uint256, uint256):\n    asset: address = self._getUnderlyingAsset(_vaultToken)\n    if asset == empty(address):\n        return empty(address), 0, 0 # invalid vault token\n    underlyingAmount: uint256 = self._getUnderlyingAmount(_vaultToken, _vaultTokenAmount)\n    usdValue: uint256 = self._getUsdValue(asset, underlyingAmount, _appraiser)\n    return asset, underlyingAmount, usdValue\n\n\n# usd value\n\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> uint256:\n    return self._getUsdValueOfVaultToken(_vaultToken, _vaultTokenAmount, _appraiser)\n\n\n@view\n@internal\ndef _getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address) -> uint256:\n    return self._getUnderlyingData(_vaultToken, _vaultTokenAmount, _appraiser)[2]\n\n\n@view\n@internal\ndef _getUsdValue(_asset: address, _amount: uint256, _appraiser: address) -> uint256:\n    appraiser: address = _appraiser\n    if _appraiser == empty(address):\n        appraiser = addys._getAppraiserAddr()\n    return staticcall Appraiser(appraiser).getUsdValue(_asset, _amount)\n\n\n###############\n# Other Utils #\n###############\n\n\n# basics\n\n\n@view\n@external\ndef isRebasing() -> bool:\n    return self._isRebasing()\n\n\n@view\n@internal\ndef _isRebasing() -> bool:\n    return False\n\n\n# price per share\n\n\n@view\n@external\ndef getPricePerShare(_vaultToken: address, _decimals: uint256 = 0) -> uint256:\n    decimals: uint256 = _decimals\n    if decimals == 0:\n        decimals = yld.vaultToAsset[_vaultToken].decimals\n    if decimals == 0:\n        return 0 # not registered\n    return self._getPricePerShare(_vaultToken, decimals)\n\n\n@view\n@internal\ndef _getPricePerShare(_vaultToken: address, _decimals: uint256) -> uint256:\n    return staticcall IERC4626(_vaultToken).convertToAssets(10 ** _decimals)\n\n\n# vault token amount\n\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    return staticcall IERC4626(_vaultToken).convertToShares(_assetAmount)\n\n\n# extras\n\n\n@view\n@external\ndef isEligibleVaultForTrialFunds(_vaultToken: address, _underlyingAsset: address) -> bool:\n    return False\n\n\n@view\n@external\ndef isEligibleForYieldBonus(_asset: address) -> bool:\n    return False\n\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    return staticcall IERC4626(_vaultToken).totalAssets()\n\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    # TODO: implement\n    return 0\n\n\n################\n# Registration #\n################\n\n\n# can vault be registered\n\n\n@view\n@external\ndef canRegisterVaultToken(_asset: address, _vaultToken: address) -> bool:\n    return self._canRegisterVaultToken(_asset, _vaultToken)\n\n\n@view\n@internal\ndef _canRegisterVaultToken(_asset: address, _vaultToken: address) -> bool:\n    if empty(address) in [_asset, _vaultToken]:\n        return False\n    if staticcall IERC4626(_vaultToken).asset() != _asset:\n        return False\n    fTokens: DynArray[address, MAX_FTOKENS] = staticcall FluidLendingResolver(FLUID_RESOLVER).getAllFTokens()\n    return _vaultToken in fTokens\n\n\n# register vault token locally\n\n\n@external\ndef registerVaultTokenLocally(_asset: address, _vaultAddr: address) -> ls.VaultTokenInfo:\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert self._canRegisterVaultToken(_asset, _vaultAddr) # dev: cannot register vault token\n    assert not yld._isAssetOpportunity(_asset, _vaultAddr) # dev: already registered\n    vaultInfo: ls.VaultTokenInfo = self._registerVaultTokenLocally(_asset, _vaultAddr)\n    self._registerVaultTokenGlobally(_asset, _vaultAddr, vaultInfo.decimals, addys._getLedgerAddr(), addys._getLegoBookAddr())\n    return vaultInfo\n\n\n@internal\ndef _registerVaultTokenLocally(_asset: address, _vaultAddr: address) -> ls.VaultTokenInfo:\n    assert extcall IERC20(_asset).approve(_vaultAddr, max_value(uint256), default_return_value=True) # dev: max approval failed\n    vaultInfo: ls.VaultTokenInfo = yld._addAssetOpportunity(_asset, _vaultAddr)\n    assert vaultInfo.decimals != 0 # dev: invalid vault token\n    return vaultInfo\n\n\n# remove vault token locally\n\n\n@external\ndef deregisterVaultTokenLocally(_asset: address, _vaultAddr: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert yld._isAssetOpportunity(_asset, _vaultAddr) # dev: already registered\n    self._deregisterVaultTokenLocally(_asset, _vaultAddr)\n\n\n@internal\ndef _deregisterVaultTokenLocally(_asset: address, _vaultAddr: address):\n    assert extcall IERC20(_asset).approve(_vaultAddr, 0, default_return_value=True) # dev: max approval failed\n    yld._removeAssetOpportunity(_asset, _vaultAddr)\n\n\n# ledger registration\n\n\n@internal\ndef _registerVaultTokenGlobally(_underlyingAsset: address, _vaultToken: address, _decimals: uint256, _ledger: address, _legoBook: address):\n    if not staticcall Ledger(_ledger).isRegisteredVaultToken(_vaultToken):\n        legoId: uint256 = staticcall Registry(_legoBook).getRegId(self)\n        extcall Ledger(_ledger).setVaultToken(_vaultToken, legoId, _underlyingAsset, _decimals, self._isRebasing())\n\n\n#################\n# Yield Actions #\n#################\n\n\n# add price snapshot\n\n\n@external\ndef addPriceSnapshot(_vaultToken: address) -> bool:\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    vaultInfo: ls.VaultTokenInfo = yld.vaultToAsset[_vaultToken]\n    assert vaultInfo.decimals != 0 # dev: not registered\n    pricePerShare: uint256 = self._getPricePerShare(_vaultToken, vaultInfo.decimals)\n    return yld._addPriceSnapshot(_vaultToken, pricePerShare, vaultInfo.decimals)\n\n\n# deposit\n\n\n@external\ndef depositForYield(\n    _asset: address,\n    _amount: uint256,\n    _vaultAddr: address,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, address, uint256, uint256):\n    assert not yld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = yld._getMiniAddys(_miniAddys)\n    vaultInfo: ls.VaultTokenInfo = self._getVaultInfoOnDeposit(_asset, _vaultAddr, miniAddys.ledger, miniAddys.legoBook)\n\n    # pre balances\n    preLegoBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n\n    # transfer deposit asset to this contract\n    depositAmount: uint256 = min(_amount, staticcall IERC20(_asset).balanceOf(msg.sender))\n    assert depositAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_asset).transferFrom(msg.sender, self, depositAmount, default_return_value=True) # dev: transfer failed\n\n    # deposit assets into lego partner\n    vaultTokenAmountReceived: uint256 = extcall IERC4626(_vaultAddr).deposit(depositAmount, _recipient)\n    assert vaultTokenAmountReceived != 0 # dev: no vault tokens received\n\n    # refund if full deposit didn't get through\n    currentLegoBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    refundAssetAmount: uint256 = 0\n    if currentLegoBalance > preLegoBalance:\n        refundAssetAmount = currentLegoBalance - preLegoBalance\n        assert extcall IERC20(_asset).transfer(msg.sender, refundAssetAmount, default_return_value=True) # dev: transfer failed\n        depositAmount -= refundAssetAmount\n\n    usdValue: uint256 = extcall Appraiser(miniAddys.appraiser).updatePriceAndGetUsdValue(_asset, depositAmount, miniAddys.missionControl, miniAddys.legoBook)\n    log FluidDeposit(\n        sender = msg.sender,\n        asset = _asset,\n        vaultToken = _vaultAddr,\n        assetAmountDeposited = depositAmount,\n        usdValue = usdValue,\n        vaultTokenAmountReceived = vaultTokenAmountReceived,\n        recipient = _recipient,\n    )\n\n    # add price snapshot\n    pricePerShare: uint256 = self._getPricePerShare(_vaultAddr, vaultInfo.decimals)\n    yld._addPriceSnapshot(_vaultAddr, pricePerShare, vaultInfo.decimals)\n\n    return depositAmount, _vaultAddr, vaultTokenAmountReceived, usdValue\n\n\n# vault info on deposit\n\n\n@internal\ndef _getVaultInfoOnDeposit(_asset: address, _vaultAddr: address, _ledger: address, _legoBook: address) -> ls.VaultTokenInfo:\n    vaultInfo: ls.VaultTokenInfo = yld.vaultToAsset[_vaultAddr]\n    if vaultInfo.decimals == 0:\n        assert self._canRegisterVaultToken(_asset, _vaultAddr) # dev: cannot register vault token\n        vaultInfo = self._registerVaultTokenLocally(_asset, _vaultAddr)\n        self._registerVaultTokenGlobally(_asset, _vaultAddr, vaultInfo.decimals, _ledger, _legoBook)\n    else:\n        assert vaultInfo.underlyingAsset == _asset # dev: asset mismatch\n    return vaultInfo\n\n\n# withdraw\n\n\n@external\ndef withdrawFromYield(\n    _vaultToken: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, address, uint256, uint256):\n    assert not yld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = yld._getMiniAddys(_miniAddys)\n    vaultInfo: ls.VaultTokenInfo = self._getVaultInfoOnWithdrawal(_vaultToken, miniAddys.ledger, miniAddys.legoBook)\n\n    # pre balances\n    preLegoVaultBalance: uint256 = staticcall IERC20(_vaultToken).balanceOf(self)\n\n    # transfer vaults tokens to this contract\n    vaultTokenAmount: uint256 = min(_amount, staticcall IERC20(_vaultToken).balanceOf(msg.sender))\n    assert vaultTokenAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_vaultToken).transferFrom(msg.sender, self, vaultTokenAmount, default_return_value=True) # dev: transfer failed\n\n    # withdraw assets from lego partner\n    assetAmountReceived: uint256 = extcall IERC4626(_vaultToken).redeem(vaultTokenAmount, _recipient, self)\n    assert assetAmountReceived != 0 # dev: no asset amount received\n\n    # refund if full withdrawal didn't happen\n    currentLegoVaultBalance: uint256 = staticcall IERC20(_vaultToken).balanceOf(self)\n    refundVaultTokenAmount: uint256 = 0\n    if currentLegoVaultBalance > preLegoVaultBalance:\n        refundVaultTokenAmount = currentLegoVaultBalance - preLegoVaultBalance\n        assert extcall IERC20(_vaultToken).transfer(msg.sender, refundVaultTokenAmount, default_return_value=True) # dev: transfer failed\n        vaultTokenAmount -= refundVaultTokenAmount\n\n    usdValue: uint256 = extcall Appraiser(miniAddys.appraiser).updatePriceAndGetUsdValue(vaultInfo.underlyingAsset, assetAmountReceived, miniAddys.missionControl, miniAddys.legoBook)\n    log FluidWithdrawal(\n        sender = msg.sender,\n        asset = vaultInfo.underlyingAsset,\n        vaultToken = _vaultToken,\n        assetAmountReceived = assetAmountReceived,\n        usdValue = usdValue,\n        vaultTokenAmountBurned = vaultTokenAmount,\n        recipient = _recipient,\n    )\n\n    # add price snapshot\n    pricePerShare: uint256 = self._getPricePerShare(_vaultToken, vaultInfo.decimals)\n    yld._addPriceSnapshot(_vaultToken, pricePerShare, vaultInfo.decimals)\n\n    return vaultTokenAmount, vaultInfo.underlyingAsset, assetAmountReceived, usdValue\n\n\n# vault info on withdrawal\n\n\n@internal\ndef _getVaultInfoOnWithdrawal(_vaultAddr: address, _ledger: address, _legoBook: address) -> ls.VaultTokenInfo:\n    vaultInfo: ls.VaultTokenInfo = yld.vaultToAsset[_vaultAddr]\n    if vaultInfo.decimals == 0:\n        asset: address = staticcall IERC4626(_vaultAddr).asset()\n        assert self._canRegisterVaultToken(asset, _vaultAddr) # dev: cannot register vault token\n        vaultInfo = self._registerVaultTokenLocally(asset, _vaultAddr)\n        self._registerVaultTokenGlobally(asset, _vaultAddr, vaultInfo.decimals, _ledger, _legoBook)\n    return vaultInfo\n\n\n#########\n# Other #\n#########\n\n\n@view\n@external\ndef getAccessForLego(_user: address, _action: ws.ActionType) -> (address, String[64], uint256):\n    return empty(address), empty(String[64]), 0\n\n\n@external\ndef claimRewards(\n    _user: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _extraData: bytes32,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@view\n@external\ndef hasClaimableRewards(_user: address) -> bool:\n    return False\n\n\n@external\ndef swapTokens(\n    _amountIn: uint256,\n    _minAmountOut: uint256,\n    _tokenPath: DynArray[address, MAX_TOKEN_PATH],\n    _poolPath: DynArray[address, MAX_TOKEN_PATH - 1],\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256):\n    return 0, 0, 0\n\n\n@external\ndef mintOrRedeemAsset(\n    _tokenIn: address,\n    _tokenOut: address,\n    _tokenInAmount: uint256,\n    _minAmountOut: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, bool, uint256):\n    return 0, 0, False, 0\n\n\n@external\ndef confirmMintOrRedeemAsset(\n    _tokenIn: address,\n    _tokenOut: address,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef addCollateral(\n    _asset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef removeCollateral(\n    _asset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef borrow(\n    _borrowAsset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef repayDebt(\n    _paymentAsset: address,\n    _paymentAmount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef addLiquidity(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _amountA: uint256,\n    _amountB: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _minLpAmount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (address, uint256, uint256, uint256, uint256):\n    return empty(address), 0, 0, 0, 0\n\n\n@external\ndef removeLiquidity(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpToken: address,\n    _lpAmount: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, uint256):\n    return 0, 0, 0, 0\n\n\n@external\ndef addLiquidityConcentrated(\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _tickLower: int24,\n    _tickUpper: int24,\n    _amountA: uint256,\n    _amountB: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, uint256, uint256):\n    return 0, 0, 0, 0, 0\n\n\n@external\ndef removeLiquidityConcentrated(\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _liqToRemove: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, bool, uint256):\n    return 0, 0, 0, False, 0",
            "sha256sum": "fd40a2e470be98daaed5c249f6926132178aa187f4de4adfd5df77e764f7f151"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/legos/yield/Fluid.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.3+commit.bff19ea2",
        "integrity": "79125164abf4288ce3f624cc7e65ba756b466d53146adede84b7fe001db9a365"
      },
      "args": "00000000000000000000000044cf3c4f000dfd76a35d03298049d37be688d6f90000000000000000000000003af6fbec4a2fe517f56e402c65e3f4c3e18c1d86",
      "file": "contracts/legos/yield/Fluid.vy"
    },
    "Moonwell": {
      "address": "0x26645a6D07b0A3944A5aC75187Ffa57Ccf0FeC1C",
      "abi": [
        {
          "name": "MoonwellDeposit",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountDeposited",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultTokenAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "MoonwellWithdrawal",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultTokenAmountBurned",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LegoPauseModified",
          "inputs": [
            {
              "name": "isPaused",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LegoFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "balance",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "SnapShotPriceConfigSet",
          "inputs": [
            {
              "name": "minSnapshotDelay",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "maxNumSnapshots",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "maxUpsideDeviation",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "staleTime",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetOpportunityAdded",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultAddr",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetOpportunityRemoved",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultAddr",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PricePerShareSnapShotAdded",
          "inputs": [
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "totalSupply",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "pricePerShare",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddys",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "undyToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "hatchery",
                  "type": "address"
                },
                {
                  "name": "lootDistributor",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                },
                {
                  "name": "walletBackpack",
                  "type": "address"
                },
                {
                  "name": "billing",
                  "type": "address"
                },
                {
                  "name": "vaultRegistry",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUndyHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isLegoAsset",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssetOpportunities",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isAssetOpportunity",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getNumLegoAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pause",
          "inputs": [
            {
              "name": "_shouldPause",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFundsMany",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_assets",
              "type": "address[]"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getWeightedPricePerShare",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLatestSnapshot",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_pricePerShare",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "totalSupply",
                  "type": "uint256"
                },
                {
                  "name": "pricePerShare",
                  "type": "uint256"
                },
                {
                  "name": "lastUpdate",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setSnapShotPriceConfig",
          "inputs": [
            {
              "name": "_config",
              "type": "tuple",
              "components": [
                {
                  "name": "minSnapshotDelay",
                  "type": "uint256"
                },
                {
                  "name": "maxNumSnapshots",
                  "type": "uint256"
                },
                {
                  "name": "maxUpsideDeviation",
                  "type": "uint256"
                },
                {
                  "name": "staleTime",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidPriceConfig",
          "inputs": [
            {
              "name": "_config",
              "type": "tuple",
              "components": [
                {
                  "name": "minSnapshotDelay",
                  "type": "uint256"
                },
                {
                  "name": "maxNumSnapshots",
                  "type": "uint256"
                },
                {
                  "name": "maxUpsideDeviation",
                  "type": "uint256"
                },
                {
                  "name": "staleTime",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "vaultToAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "underlyingAsset",
                  "type": "address"
                },
                {
                  "name": "decimals",
                  "type": "uint256"
                },
                {
                  "name": "lastAveragePricePerShare",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assetOpportunities",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAssetOpportunity",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssetOpportunities",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assets",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "snapShotData",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "lastSnapShot",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "totalSupply",
                      "type": "uint256"
                    },
                    {
                      "name": "pricePerShare",
                      "type": "uint256"
                    },
                    {
                      "name": "lastUpdate",
                      "type": "uint256"
                    }
                  ]
                },
                {
                  "name": "nextIndex",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "snapShots",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "totalSupply",
                  "type": "uint256"
                },
                {
                  "name": "pricePerShare",
                  "type": "uint256"
                },
                {
                  "name": "lastUpdate",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "snapShotPriceConfig",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "minSnapshotDelay",
                  "type": "uint256"
                },
                {
                  "name": "maxNumSnapshots",
                  "type": "uint256"
                },
                {
                  "name": "maxUpsideDeviation",
                  "type": "uint256"
                },
                {
                  "name": "staleTime",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isPaused",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "payable",
          "type": "fallback"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasCapability",
          "inputs": [
            {
              "name": "_action",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRegistries",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isYieldLego",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isDexLego",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAsset",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingBalances",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenBalance",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAmount",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAmountSafe",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenBalance",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingData",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingData",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            },
            {
              "name": "_appraiser",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValueOfVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValueOfVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            },
            {
              "name": "_appraiser",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isRebasing",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPricePerShare",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPricePerShare",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_decimals",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getVaultTokenAmount",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_assetAmount",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isEligibleVaultForTrialFunds",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_underlyingAsset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isEligibleForYieldBonus",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalAssets",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalBorrows",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canRegisterVaultToken",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "registerVaultTokenLocally",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "underlyingAsset",
                  "type": "address"
                },
                {
                  "name": "decimals",
                  "type": "uint256"
                },
                {
                  "name": "lastAveragePricePerShare",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "deregisterVaultTokenLocally",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addPriceSnapshot",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositForYield",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositForYield",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawFromYield",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawFromYield",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasClaimableRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAccessForLego",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_action",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "string"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_tokenPath",
              "type": "address[]"
            },
            {
              "name": "_poolPath",
              "type": "address[]"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_tokenPath",
              "type": "address[]"
            },
            {
              "name": "_poolPath",
              "type": "address[]"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_tokenInAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_tokenInAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmMintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmMintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_borrowAsset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_borrowAsset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_paymentAsset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_paymentAsset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MOONWELL_COMPTROLLER",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "WETH",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_undyHq",
              "type": "address"
            },
            {
              "name": "_moonwellComptroller",
              "type": "address"
            },
            {
              "name": "_weth",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "interfaces/WalletStructs.vyi": {
            "content": "# @version 0.4.3\n\nflag ActionType:\n    TRANSFER\n    EARN_DEPOSIT\n    EARN_WITHDRAW\n    EARN_REBALANCE\n    SWAP\n    MINT_REDEEM\n    CONFIRM_MINT_REDEEM\n    ADD_COLLATERAL\n    REMOVE_COLLATERAL\n    BORROW\n    REPAY_DEBT\n    REWARDS\n    ETH_TO_WETH\n    WETH_TO_ETH\n    ADD_LIQ\n    REMOVE_LIQ\n    ADD_LIQ_CONC\n    REMOVE_LIQ_CONC\n    PAY_CHEQUE\n\nstruct WalletAssetData:\n    assetBalance: uint256\n    usdValue: uint256\n    isYieldAsset: bool\n    lastPricePerShare: uint256\n\nstruct ActionData:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    billing: address\n    wallet: address\n    walletConfig: address\n    walletOwner: address\n    inEjectMode: bool\n    isFrozen: bool\n    lastTotalUsdValue: uint256\n    signer: address\n    isManager: bool\n    legoId: uint256\n    legoAddr: address\n    eth: address\n    weth: address\n\nstruct MiniAddys:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    appraiser: address",
            "sha256sum": "9a4b4f59b3a62043e51b425a665064aae419a3c0bd0514b6b29a9441ae364bb9"
          },
          "interfaces/LegoPartner.vyi": {
            "content": "# @version 0.4.3\n\nfrom interfaces import WalletStructs as ws\n\nMAX_TOKEN_PATH: constant(uint256) = 5\nMAX_RECOVER_ASSETS: constant(uint256) = 20\n\n@external\ndef addLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _tickLower: int24, _tickUpper: int24, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef addLiquidity(_pool: address, _tokenA: address, _tokenB: address, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _minLpAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (address, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef removeLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _liqToRemove: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef removeLiquidity(_pool: address, _tokenA: address, _tokenB: address, _lpToken: address, _lpAmount: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef mintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _tokenInAmount: uint256, _minAmountOut: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef swapTokens(_amountIn: uint256, _minAmountOut: uint256, _tokenPath: DynArray[address, MAX_TOKEN_PATH], _poolPath: DynArray[address, MAX_TOKEN_PATH - 1], _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256):\n    ...\n\n@external\ndef depositForYield(_asset: address, _amount: uint256, _vaultAddr: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef withdrawFromYield(_vaultToken: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef confirmMintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef borrow(_borrowAsset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef repayDebt(_paymentAsset: address, _paymentAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef claimRewards(_user: address, _rewardToken: address, _rewardAmount: uint256, _extraData: bytes32, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef removeCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef addCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@view\n@external\ndef getAccessForLego(_user: address, _action: ws.ActionType) -> (address, String[64], uint256):\n    ...\n\n@view\n@external\ndef hasCapability(_action: ws.ActionType) -> bool:\n    ...\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    ...\n\n@view\n@external\ndef isYieldLego() -> bool:\n    ...\n\n@view\n@external\ndef isDexLego() -> bool:\n    ...\n\n\n# common\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "81db71fe4440a3b4b563134c9b5caf1d5705772a5f291fe874c9b5fb3cfb1623"
          },
          "interfaces/LegoStructs.vyi": {
            "content": "# @version 0.4.3\n\nstruct VaultTokenInfo:\n    underlyingAsset: address\n    decimals: uint256\n    lastAveragePricePerShare: uint256\n\nstruct SnapShotPriceConfig:\n    minSnapshotDelay: uint256\n    maxNumSnapshots: uint256\n    maxUpsideDeviation: uint256\n    staleTime: uint256\n\nstruct SingleSnapShot:\n    totalSupply: uint256\n    pricePerShare: uint256\n    lastUpdate: uint256\n\nstruct SnapShotData:\n    lastSnapShot: SingleSnapShot\n    nextIndex: uint256\n",
            "sha256sum": "8ae48be17d812d57fbd671bbf0593e8abf175ad0924e47c5997823cac19ec806"
          },
          "interfaces/YieldLego.vyi": {
            "content": "# @version 0.4.3\n\nfrom interfaces import LegoStructs as ls\n\n\n###################\n# Underlying Data #\n###################\n\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    ...\n\n\n@view\n@external\ndef getUnderlyingBalances(_vaultToken: address, _vaultTokenBalance: uint256) -> (uint256, uint256):\n    ...\n\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    ...\n\n\n@view\n@external\ndef getUnderlyingAmountSafe(_vaultToken: address, _vaultTokenBalance: uint256) -> uint256:\n    ...\n\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> (address, uint256, uint256):\n    ...\n\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> uint256:\n    ...\n\n\n###############\n# Other Utils #\n###############\n\n\n@view\n@external\ndef isRebasing() -> bool:\n    ...\n\n\n@view\n@external\ndef getPricePerShare(_vaultToken: address, _decimals: uint256 = 0) -> uint256:\n    ...\n\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef canRegisterVaultToken(_asset: address, _vaultToken: address) -> bool:\n    ...\n\n\n@view\n@external\ndef isEligibleVaultForTrialFunds(_vaultToken: address, _underlyingAsset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef isEligibleForYieldBonus(_asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    ...\n\n\n###################\n# Yield Lego Data #\n###################\n\n\n@view\n@external\ndef isLegoAsset(_asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, 40]:\n    ...\n\n\n@view\n@external\ndef getAssets() -> DynArray[address, 20]:\n    ...\n\n\n@view\n@external\ndef isAssetOpportunity(_asset: address, _vaultAddr: address) -> bool:\n    ...\n\n\n@view\n@external\ndef getNumLegoAssets() -> uint256:\n    ...\n\n\n@view\n@external\ndef assets(_index: uint256) -> address:\n    ...\n\n\n@view\n@external\ndef indexOfAsset(_asset: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef numAssets() -> uint256:\n    ...\n\n\n@view\n@external\ndef assetOpportunities(_asset: address, _index: uint256) -> address:\n    ...\n\n\n@view\n@external\ndef indexOfAssetOpportunity(_asset: address, _vaultAddr: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef numAssetOpportunities(_asset: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef vaultToAsset(_vaultAddr: address) -> ls.VaultTokenInfo:\n    ...\n\n\n# price snapshots\n\n\n@external\ndef addPriceSnapshot(_vaultToken: address) -> bool:\n    ...\n\n\n@view\n@external\ndef snapShotPriceConfig() -> ls.SnapShotPriceConfig:\n    ...\n\n\n@view\n@external\ndef snapShotData(_vaultToken: address) -> ls.SnapShotData:\n    ...\n\n\n@view\n@external\ndef snapShots(_vaultToken: address, _index: uint256) -> ls.SingleSnapShot:\n    ...\n\n\n@view\n@external\ndef getWeightedPricePerShare(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef getLatestSnapshot(_vaultToken: address, _pricePerShare: uint256) -> ls.SingleSnapShot:\n    ...\n\n\n@external\ndef setSnapShotPriceConfig(_config: ls.SnapShotPriceConfig):\n    ...\n",
            "sha256sum": "045a6bbd3d556234cf4fe925a303002dc0ac3c482d344ffbaf4bc52a7e6ad2df"
          },
          "contracts/modules/Addys.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\ninterface UndyHq:\n    def isValidAddr(_addr: address) -> bool: view\n    def getAddr(_regId: uint256) -> address: view\n    def undyToken() -> address: view\n\ninterface Switchboard:\n    def isSwitchboardAddr(_addr: address) -> bool: view\n\ninterface LegoBook:\n    def isLegoAddr(_addr: address) -> bool: view\n\nstruct Addys:\n    hq: address\n    undyToken: address\n    ledger: address\n    missionControl: address\n    legoBook: address\n    switchboard: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    walletBackpack: address\n    billing: address\n    vaultRegistry: address\n\n# hq\nUNDY_HQ_FOR_ADDYS: immutable(address)\n\n# core addys\nLEDGER_ID: constant(uint256) = 1\nMISSION_CONTROL_ID: constant(uint256) = 2\nLEGO_BOOK_ID: constant(uint256) = 3\nSWITCHBOARD_ID: constant(uint256) = 4\nHATCHERY_ID: constant(uint256) = 5\nLOOT_DISTRIBUTOR_ID: constant(uint256) = 6\nAPPRAISER_ID: constant(uint256) = 7\nWALLET_BACKPACK_ID: constant(uint256) = 8\nBILLING_ID: constant(uint256) = 9\nVAULT_REGISTRY_ID: constant(uint256) = 10\n\n\n@deploy\ndef __init__(_undyHq: address):\n    assert _undyHq != empty(address) # dev: invalid undy hq\n    UNDY_HQ_FOR_ADDYS = _undyHq\n\n\n########\n# Core #\n########\n\n\n@view\n@external\ndef getAddys() -> Addys:\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _getAddys(_addys: Addys = empty(Addys)) -> Addys:\n    if _addys.hq != empty(address):\n        return _addys\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _generateAddys() -> Addys:\n    hq: address = UNDY_HQ_FOR_ADDYS\n    return Addys(\n        hq = hq,\n        undyToken = staticcall UndyHq(hq).undyToken(),\n        ledger = staticcall UndyHq(hq).getAddr(LEDGER_ID),\n        missionControl = staticcall UndyHq(hq).getAddr(MISSION_CONTROL_ID),\n        legoBook = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID),\n        switchboard = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID),\n        hatchery = staticcall UndyHq(hq).getAddr(HATCHERY_ID),\n        lootDistributor = staticcall UndyHq(hq).getAddr(LOOT_DISTRIBUTOR_ID),\n        appraiser = staticcall UndyHq(hq).getAddr(APPRAISER_ID),\n        walletBackpack = staticcall UndyHq(hq).getAddr(WALLET_BACKPACK_ID),\n        billing = staticcall UndyHq(hq).getAddr(BILLING_ID),\n        vaultRegistry = staticcall UndyHq(hq).getAddr(VAULT_REGISTRY_ID),\n    )\n\n\n##########\n# Tokens #\n##########\n\n\n@view\n@internal\ndef _getUndyToken() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).undyToken()\n\n\n###########\n# Helpers #\n###########\n\n\n# undy hq\n\n\n@view\n@external\ndef getUndyHq() -> address:\n    return self._getUndyHq()\n\n\n@view\n@internal\ndef _getUndyHq() -> address:\n    return UNDY_HQ_FOR_ADDYS\n\n\n# utils\n\n\n@view\n@internal\ndef _isValidUndyAddr(_addr: address, _hq: address = empty(address)) -> bool:\n    hq: address = _hq\n    if _hq == empty(address):\n        hq = UNDY_HQ_FOR_ADDYS\n    \n    # core departments\n    if staticcall UndyHq(hq).isValidAddr(_addr):\n        return True\n\n    # lego book\n    legoBook: address = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID)\n    if legoBook != empty(address) and staticcall LegoBook(legoBook).isLegoAddr(_addr):\n        return True\n\n    # switchboard config\n    switchboard: address = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID)\n    if switchboard != empty(address) and staticcall Switchboard(switchboard).isSwitchboardAddr(_addr):\n        return True\n\n    return False\n\n\n@view\n@internal\ndef _isSwitchboardAddr(_addr: address) -> bool:\n    switchboard: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n    if switchboard == empty(address):\n        return False\n    return staticcall Switchboard(switchboard).isSwitchboardAddr(_addr)\n\n\n@view\n@internal\ndef _isLegoBookAddr(_addr: address) -> bool:\n    legoBook: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n    if legoBook == empty(address):\n        return False\n    return staticcall LegoBook(legoBook).isLegoAddr(_addr)\n\n\n###############\n# Departments #\n###############\n\n\n# ledger\n\n\n@view\n@internal\ndef _getLedgerId() -> uint256:\n    return LEDGER_ID\n\n\n@view\n@internal\ndef _getLedgerAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEDGER_ID)\n\n\n# mission control\n\n\n@view\n@internal\ndef _getMissionControlId() -> uint256:\n    return MISSION_CONTROL_ID\n\n\n@view\n@internal\ndef _getMissionControlAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(MISSION_CONTROL_ID)\n\n\n# lego book\n\n\n@view\n@internal\ndef _getLegoBookId() -> uint256:\n    return LEGO_BOOK_ID\n\n\n@view\n@internal\ndef _getLegoBookAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n\n\n# switchboard\n\n\n@view\n@internal\ndef _getSwitchboardId() -> uint256:\n    return SWITCHBOARD_ID\n\n\n@view\n@internal\ndef _getSwitchboardAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n\n\n# hatchery\n\n\n@view\n@internal\ndef _getHatcheryId() -> uint256:\n    return HATCHERY_ID\n\n\n@view\n@internal\ndef _getHatcheryAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(HATCHERY_ID)\n\n\n# loot distributor\n\n\n@view\n@internal\ndef _getLootDistributorId() -> uint256:\n    return LOOT_DISTRIBUTOR_ID\n\n\n@view\n@internal\ndef _getLootDistributorAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LOOT_DISTRIBUTOR_ID)\n\n\n# appraiser\n\n\n@view\n@internal\ndef _getAppraiserId() -> uint256:\n    return APPRAISER_ID\n\n\n@view\n@internal\ndef _getAppraiserAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(APPRAISER_ID)\n\n\n# wallet backpack\n\n\n@view\n@internal\ndef _getWalletBackpackId() -> uint256:\n    return WALLET_BACKPACK_ID\n\n\n@view\n@internal\ndef _getWalletBackpackAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(WALLET_BACKPACK_ID)\n\n\n# billing\n\n\n@view\n@internal\ndef _getBillingId() -> uint256:\n    return BILLING_ID\n\n\n@view\n@internal\ndef _getBillingAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(BILLING_ID)\n\n\n# vault registry\n\n\n@view\n@internal\ndef _getVaultRegistryId() -> uint256:\n    return VAULT_REGISTRY_ID\n\n\n@view\n@internal\ndef _getVaultRegistryAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(VAULT_REGISTRY_ID)",
            "sha256sum": "4df6b72db9bb417d1af81660175be1450cfb7b3575f3d17a5b8a130bff87b781"
          },
          "contracts/modules/YieldLegoData.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nuses: addys\n\nimport contracts.modules.Addys as addys\n\nfrom interfaces import WalletStructs as ws\nfrom interfaces import LegoStructs as ls\nfrom ethereum.ercs import IERC20\nfrom ethereum.ercs import IERC20Detailed\n\nevent AssetOpportunityAdded:\n    asset: indexed(address)\n    vaultAddr: indexed(address)\n\nevent AssetOpportunityRemoved:\n    asset: indexed(address)\n    vaultAddr: indexed(address)\n\nevent LegoPauseModified:\n    isPaused: bool\n\nevent LegoFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    balance: uint256\n\nevent PricePerShareSnapShotAdded:\n    vaultToken: indexed(address)\n    totalSupply: uint256\n    pricePerShare: uint256\n\nevent SnapShotPriceConfigSet:\n    minSnapshotDelay: uint256\n    maxNumSnapshots: uint256\n    maxUpsideDeviation: uint256\n    staleTime: uint256\n\n# core\nvaultToAsset: public(HashMap[address, ls.VaultTokenInfo]) # vault addr -> data\n\n# asset opportunities\nassetOpportunities: public(HashMap[address, HashMap[uint256, address]]) # asset -> index -> vault addr\nindexOfAssetOpportunity: public(HashMap[address, HashMap[address, uint256]]) # asset -> vault addr -> index\nnumAssetOpportunities: public(HashMap[address, uint256]) # asset -> number of opportunities\n\n# lego assets (iterable)\nassets: public(HashMap[uint256, address]) # index -> asset\nindexOfAsset: public(HashMap[address, uint256]) # asset -> index\nnumAssets: public(uint256) # num assets\n\n# price snapshots\nsnapShotData: public(HashMap[address, ls.SnapShotData]) # vault token -> data\nsnapShots: public(HashMap[address, HashMap[uint256, ls.SingleSnapShot]]) # vault token -> index -> snapshot\nsnapShotPriceConfig: public(ls.SnapShotPriceConfig) # config\n\nisPaused: public(bool)\n\nMAX_VAULTS: constant(uint256) = 40\nMAX_ASSETS: constant(uint256) = 20\nMAX_RECOVER_ASSETS: constant(uint256) = 20\nONE_DAY_SECONDS: constant(uint256) = 60 * 60 * 24\nONE_WEEK_SECONDS: constant(uint256) = ONE_DAY_SECONDS * 7\nHUNDRED_PERCENT: constant(uint256) = 100_00\n\n\n@deploy\ndef __init__(_shouldPause: bool):\n    self.isPaused = _shouldPause\n    self.numAssets = 1 # not using 0 index\n\n    # default snapshot price config\n    self.snapShotPriceConfig = ls.SnapShotPriceConfig(\n        minSnapshotDelay = 60 * 10, # 10 minutes\n        maxNumSnapshots = 20,\n        maxUpsideDeviation = 10_00, # 10%\n        staleTime = 3 * ONE_DAY_SECONDS, # 3 days\n    )\n\n\n#########\n# Views #\n#########\n\n\n# is lego asset\n\n\n@view\n@external\ndef isLegoAsset(_asset: address) -> bool:\n    return self._isLegoAsset(_asset)\n\n\n@view\n@internal\ndef _isLegoAsset(_asset: address) -> bool:\n    return self.indexOfAsset[_asset] != 0\n\n\n# vault opportunities\n\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, MAX_VAULTS]:\n    numOpportunities: uint256 = self.numAssetOpportunities[_asset]\n    if numOpportunities == 0:\n        return []\n    opportunities: DynArray[address, MAX_VAULTS] = []\n    for i: uint256 in range(1, numOpportunities, bound=MAX_VAULTS):\n        opportunities.append(self.assetOpportunities[_asset][i])\n    return opportunities\n\n\n# all assets registered\n\n\n@view\n@external\ndef getAssets() -> DynArray[address, MAX_ASSETS]:\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return []\n    assets: DynArray[address, MAX_ASSETS] = []\n    for i: uint256 in range(1, numAssets, bound=MAX_ASSETS):\n        assets.append(self.assets[i])\n    return assets\n\n\n################\n# Registration #\n################\n\n\n@view\n@external\ndef isAssetOpportunity(_asset: address, _vaultAddr: address) -> bool:\n    return self._isAssetOpportunity(_asset, _vaultAddr)\n\n\n@view\n@internal\ndef _isAssetOpportunity(_asset: address, _vaultAddr: address) -> bool:\n    return self.indexOfAssetOpportunity[_asset][_vaultAddr] != 0\n\n\n# add asset opportunity\n\n\n@internal\ndef _addAssetOpportunity(_asset: address, _vaultAddr: address) -> ls.VaultTokenInfo:\n    if self.indexOfAssetOpportunity[_asset][_vaultAddr] != 0:\n        return self.vaultToAsset[_vaultAddr]\n\n    if empty(address) in [_asset, _vaultAddr]:\n        return empty(ls.VaultTokenInfo)\n\n    # add asset opportunity\n    aid: uint256 = self.numAssetOpportunities[_asset]\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.assetOpportunities[_asset][aid] = _vaultAddr\n    self.indexOfAssetOpportunity[_asset][_vaultAddr] = aid\n    self.numAssetOpportunities[_asset] = aid + 1\n\n    # add mapping\n    vaultInfo: ls.VaultTokenInfo = ls.VaultTokenInfo(\n        underlyingAsset = _asset,\n        decimals = convert(staticcall IERC20Detailed(_vaultAddr).decimals(), uint256),\n        lastAveragePricePerShare = 0,\n    )\n    self.vaultToAsset[_vaultAddr] = vaultInfo\n\n    # add asset\n    self._addAsset(_asset)\n\n    log AssetOpportunityAdded(asset=_asset, vaultAddr=_vaultAddr)\n    return vaultInfo\n\n\n# remove asset opportunity\n\n\n@internal\ndef _removeAssetOpportunity(_asset: address, _vaultAddr: address):\n    numOpportunities: uint256 = self.numAssetOpportunities[_asset]\n    if numOpportunities == 0:\n        return\n\n    targetIndex: uint256 = self.indexOfAssetOpportunity[_asset][_vaultAddr]\n    if targetIndex == 0:\n        return\n\n    # update data\n    lastIndex: uint256 = numOpportunities - 1\n    self.numAssetOpportunities[_asset] = lastIndex\n    self.indexOfAssetOpportunity[_asset][_vaultAddr] = 0\n\n    self.vaultToAsset[_vaultAddr] = empty(ls.VaultTokenInfo)\n\n    # shift to replace the removed one\n    if targetIndex != lastIndex:\n        lastVaultAddr: address = self.assetOpportunities[_asset][lastIndex]\n        self.assetOpportunities[_asset][targetIndex] = lastVaultAddr\n        self.indexOfAssetOpportunity[_asset][lastVaultAddr] = targetIndex\n\n    # remove asset\n    if lastIndex <= 1:\n        self._removeAsset(_asset)\n\n    log AssetOpportunityRemoved(asset=_asset, vaultAddr=_vaultAddr)\n\n\n# add asset\n\n\n@internal\ndef _addAsset(_asset: address):\n    if self.indexOfAsset[_asset] != 0:\n        return\n\n    aid: uint256 = self.numAssets\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.assets[aid] = _asset\n    self.indexOfAsset[_asset] = aid\n    self.numAssets = aid + 1\n\n\n# remove asset\n\n\n@internal\ndef _removeAsset(_asset: address):\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return\n\n    targetIndex: uint256 = self.indexOfAsset[_asset]\n    if targetIndex == 0:\n        return\n\n    # update data\n    lastIndex: uint256 = numAssets - 1\n    self.numAssets = lastIndex\n    self.indexOfAsset[_asset] = 0\n\n    # shift to replace the removed one\n    if targetIndex != lastIndex:\n        lastAsset: address = self.assets[lastIndex]\n        self.assets[targetIndex] = lastAsset\n        self.indexOfAsset[lastAsset] = targetIndex\n\n\n# num lego assets (true number, use `numAssets` for iteration)\n\n\n@view\n@external\ndef getNumLegoAssets() -> uint256:\n    return self._getNumLegoAssets()\n\n\n@view\n@internal\ndef _getNumLegoAssets() -> uint256:\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return 0\n    return numAssets - 1\n\n\n###########\n# General #\n###########\n\n\n# fill mini addys\n\n\n@view\n@internal\ndef _getMiniAddys(_miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> ws.MiniAddys:\n    if _miniAddys.ledger != empty(address):\n        return _miniAddys\n    return ws.MiniAddys(\n        ledger = addys._getLedgerAddr(),\n        missionControl = addys._getMissionControlAddr(),\n        legoBook = addys._getLegoBookAddr(),\n        appraiser = addys._getAppraiserAddr(),\n    )\n\n\n# activate\n\n\n@external\ndef pause(_shouldPause: bool):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert _shouldPause != self.isPaused # dev: no change\n    self.isPaused = _shouldPause\n    log LegoPauseModified(isPaused=_shouldPause)\n\n\n# recover funds\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    self._recoverFunds(_recipient, _asset)\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, MAX_RECOVER_ASSETS]):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    for a: address in _assets:\n        self._recoverFunds(_recipient, a)\n\n\n@internal\ndef _recoverFunds(_recipient: address, _asset: address):\n    assert empty(address) not in [_recipient, _asset] # dev: invalid recipient or asset\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    assert balance != 0 # dev: nothing to recover\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log LegoFundsRecovered(asset=_asset, recipient=_recipient, balance=balance)\n\n\n###################\n# Price Snapshots #\n###################\n\n\n# add price snapshot\n\n\n@internal\ndef _addPriceSnapshot(_vaultToken: address, _pricePerShare: uint256, _vaultTokenDecimals: uint256) -> bool:\n    config: ls.SnapShotPriceConfig = self.snapShotPriceConfig\n    if config.maxNumSnapshots == 0:\n        return False\n\n    data: ls.SnapShotData = self.snapShotData[_vaultToken]\n\n    # already have snapshot for this time\n    if data.lastSnapShot.lastUpdate == block.timestamp:\n        return False\n\n    # check if snapshot is too recent\n    if data.lastSnapShot.lastUpdate + config.minSnapshotDelay > block.timestamp:\n        return False\n\n    # create and store new snapshot\n    newSnapshot: ls.SingleSnapShot = self._getLatestSnapshot(_vaultToken, _pricePerShare, _vaultTokenDecimals, data.lastSnapShot, config)\n    data.lastSnapShot = newSnapshot\n    self.snapShots[_vaultToken][data.nextIndex] = newSnapshot\n\n    # update index\n    data.nextIndex += 1\n    if data.nextIndex >= config.maxNumSnapshots:\n        data.nextIndex = 0\n\n    # save snap shot data\n    self.snapShotData[_vaultToken] = data\n\n    # update cached weighted average price per share\n    self.vaultToAsset[_vaultToken].lastAveragePricePerShare = self._getWeightedPricePerShare(_vaultToken, _pricePerShare)\n\n    log PricePerShareSnapShotAdded(\n        vaultToken = _vaultToken,\n        totalSupply = newSnapshot.totalSupply,\n        pricePerShare = newSnapshot.pricePerShare,\n    )\n    return True\n\n\n# weighted price per share\n\n\n@view\n@external\ndef getWeightedPricePerShare(_vaultToken: address) -> uint256:\n    data: ls.SnapShotData = self.snapShotData[_vaultToken]\n    return self._getWeightedPricePerShare(_vaultToken, data.lastSnapShot.pricePerShare)\n\n\n@view\n@internal\ndef _getWeightedPricePerShare(_vaultToken: address, _lastPricePerShare: uint256) -> uint256:\n    config: ls.SnapShotPriceConfig = self.snapShotPriceConfig\n    if config.maxNumSnapshots == 0:\n        return 0\n\n    # calculate weighted average price using all valid snapshots\n    numerator: uint256 = 0\n    denominator: uint256 = 0\n    for i: uint256 in range(config.maxNumSnapshots, bound=max_value(uint256)):\n\n        snapShot: ls.SingleSnapShot = self.snapShots[_vaultToken][i]\n        if snapShot.pricePerShare == 0 or snapShot.totalSupply == 0 or snapShot.lastUpdate == 0:\n            continue\n\n        # too stale, skip\n        if config.staleTime != 0 and block.timestamp > snapShot.lastUpdate + config.staleTime:\n            continue\n\n        numerator += (snapShot.totalSupply * snapShot.pricePerShare)\n        denominator += snapShot.totalSupply\n\n    # weighted price per share\n    weightedPricePerShare: uint256 = 0\n    if numerator != 0:\n        weightedPricePerShare = numerator // denominator\n    else:\n        weightedPricePerShare = _lastPricePerShare\n\n    return weightedPricePerShare\n\n\n# latest snapshot\n\n\n@view\n@external\ndef getLatestSnapshot(_vaultToken: address, _pricePerShare: uint256) -> ls.SingleSnapShot:\n    data: ls.SnapShotData = self.snapShotData[_vaultToken]\n    config: ls.SnapShotPriceConfig = self.snapShotPriceConfig\n    vaultTokenDecimals: uint256 = self.vaultToAsset[_vaultToken].decimals\n    return self._getLatestSnapshot(_vaultToken, _pricePerShare, vaultTokenDecimals, data.lastSnapShot, config)\n\n\n@view\n@internal\ndef _getLatestSnapshot(\n    _vaultToken: address,\n    _pricePerShare: uint256,\n    _vaultTokenDecimals: uint256,\n    _lastSnapShot: ls.SingleSnapShot,\n    _config: ls.SnapShotPriceConfig,\n) -> ls.SingleSnapShot:\n\n    # total supply (adjusted)\n    totalSupply: uint256 = staticcall IERC20(_vaultToken).totalSupply() // (10 ** _vaultTokenDecimals)\n    if totalSupply == 0:\n        totalSupply = 1\n\n    # throttle upside (extra safety check)\n    pricePerShare: uint256 = self._throttleUpside(_pricePerShare, _lastSnapShot.pricePerShare, _config.maxUpsideDeviation)\n\n    return ls.SingleSnapShot(\n        totalSupply = totalSupply,\n        pricePerShare = pricePerShare,\n        lastUpdate = block.timestamp,\n    )\n\n\n@view\n@internal\ndef _throttleUpside(_newValue: uint256, _prevValue: uint256, _maxUpside: uint256) -> uint256:\n    if _maxUpside == 0 or _prevValue == 0 or _newValue == 0:\n        return _newValue\n    maxPricePerShare: uint256 = _prevValue + (_prevValue * _maxUpside // HUNDRED_PERCENT)\n    return min(_newValue, maxPricePerShare)\n\n\n# snapshot price config\n\n\n@external\ndef setSnapShotPriceConfig(_config: ls.SnapShotPriceConfig):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert self._isValidPriceConfig(_config) # dev: invalid config\n    self.snapShotPriceConfig = _config\n    log SnapShotPriceConfigSet(\n        minSnapshotDelay=_config.minSnapshotDelay,\n        maxNumSnapshots=_config.maxNumSnapshots,\n        maxUpsideDeviation=_config.maxUpsideDeviation,\n        staleTime=_config.staleTime\n    )\n\n\n@view\n@external\ndef isValidPriceConfig(_config: ls.SnapShotPriceConfig) -> bool:\n    return self._isValidPriceConfig(_config)\n\n\n@view\n@internal\ndef _isValidPriceConfig(_config: ls.SnapShotPriceConfig) -> bool:\n    if _config.minSnapshotDelay > ONE_WEEK_SECONDS:\n        return False\n    if _config.maxNumSnapshots == 0 or _config.maxNumSnapshots > 25:\n        return False\n    if _config.maxUpsideDeviation > HUNDRED_PERCENT:\n        return False\n    return _config.staleTime < ONE_WEEK_SECONDS",
            "sha256sum": "d695c6d3998cf2ed318a0da6f4f7918abf97661e10eb510ed996d815e65927e0"
          },
          "contracts/legos/yield/Moonwell.vy": {
            "content": "#     __   __ ___ _______ ___     ______       ___     _______ _______ _______ \n#    |  | |  |   |       |   |   |      |     |   |   |       |       |       |\n#    |  |_|  |   |    ___|   |   |  _    |    |   |   |    ___|    ___|   _   |\n#    |       |   |   |___|   |   | | |   |    |   |   |   |___|   | __|  | |  |\n#    |_     _|   |    ___|   |___| |_|   |    |   |___|    ___|   ||  |  |_|  |\n#      |   | |   |   |___|       |       |    |       |   |___|   |_| |       |\n#      |___| |___|_______|_______|______|     |_______|_______|_______|_______|\n#                                                                       \n#     \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n#     \u2551  ** Moonwell Lego **                    \u2551\n#     \u2551  Integration with Moonwell Protocol.    \u2551\n#     \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n#\n#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nimplements: Lego\nimplements: YieldLego\n\nexports: addys.__interface__\nexports: yld.__interface__\n\ninitializes: addys\ninitializes: yld[addys := addys]\n\nfrom interfaces import LegoPartner as Lego\nfrom interfaces import YieldLego as YieldLego\nfrom interfaces import WalletStructs as ws\nfrom interfaces import LegoStructs as ls\n\nimport contracts.modules.Addys as addys\nimport contracts.modules.YieldLegoData as yld\n\nfrom ethereum.ercs import IERC20\n\ninterface CompoundV2:\n    def redeem(_ctokenAmount: uint256) -> uint256: nonpayable\n    def mint(_amount: uint256) -> uint256: nonpayable\n    def exchangeRateStored() -> uint256: view\n    def totalBorrows() -> uint256: view\n    def totalSupply() -> uint256: view\n    def underlying() -> address: view\n\ninterface MoonwellComptroller:\n    def getAllMarkets() -> DynArray[address, MAX_MARKETS]: view\n    def claimReward(_holder: address): nonpayable\n    def rewardDistributor() -> address: view\n\ninterface Appraiser:\n    def getUsdValue(_asset: address, _amount: uint256, _missionControl: address = empty(address), _legoBook: address = empty(address), _ledger: address = empty(address)) -> uint256: view\n    def updatePriceAndGetUsdValue(_asset: address, _amount: uint256, _missionControl: address = empty(address), _legoBook: address = empty(address)) -> uint256: nonpayable\n\ninterface Ledger:\n    def setVaultToken(_vaultToken: address, _legoId: uint256, _underlyingAsset: address, _decimals: uint256, _isRebasing: bool): nonpayable\n    def isRegisteredVaultToken(_vaultToken: address) -> bool: view\n\ninterface MoonwellRewardDistributor:\n    def getOutstandingRewardsForUser(_user: address) -> DynArray[RewardWithMToken, MAX_MARKETS]: view\n\ninterface Registry:\n    def getRegId(_addr: address) -> uint256: view\n\ninterface WethContract:\n    def deposit(): payable\n\nstruct RewardWithMToken:\n    mToken: address\n    rewards: DynArray[RewardInfo, MAX_ASSETS]\n\nstruct RewardInfo:\n    emissionToken: address\n    totalAmount: uint256\n    supplySide: uint256\n    borrowSide: uint256\n\nevent MoonwellDeposit:\n    sender: indexed(address)\n    asset: indexed(address)\n    vaultToken: indexed(address)\n    assetAmountDeposited: uint256\n    usdValue: uint256\n    vaultTokenAmountReceived: uint256\n    recipient: address\n\nevent MoonwellWithdrawal:\n    sender: indexed(address)\n    asset: indexed(address)\n    vaultToken: indexed(address)\n    assetAmountReceived: uint256\n    usdValue: uint256\n    vaultTokenAmountBurned: uint256\n    recipient: address\n\n# moonwell\nMOONWELL_COMPTROLLER: public(immutable(address))\nWETH: public(immutable(address))\n\nMAX_MARKETS: constant(uint256) = 50\nMAX_ASSETS: constant(uint256) = 25\nMAX_TOKEN_PATH: constant(uint256) = 5\n\n\n@deploy\ndef __init__(\n    _undyHq: address,\n    _moonwellComptroller: address,\n    _weth: address,\n):\n    addys.__init__(_undyHq)\n    yld.__init__(False)\n\n    assert empty(address) not in [_moonwellComptroller, _weth] # dev: invalid addrs\n    MOONWELL_COMPTROLLER = _moonwellComptroller\n    WETH = _weth\n\n\n@payable\n@external\ndef __default__():\n    pass\n\n\n@view\n@external\ndef hasCapability(_action: ws.ActionType) -> bool:\n    return _action in (\n        ws.ActionType.EARN_DEPOSIT | \n        ws.ActionType.EARN_WITHDRAW |\n        ws.ActionType.REWARDS\n    )\n\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    return [MOONWELL_COMPTROLLER]\n\n\n@view\n@external\ndef isYieldLego() -> bool:\n    return True\n\n\n@view\n@external\ndef isDexLego() -> bool:\n    return False\n\n\n###################\n# Underlying Data #\n###################\n\n\n# underlying asset\n\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    return self._getUnderlyingAsset(_vaultToken)\n\n\n@view\n@internal\ndef _getUnderlyingAsset(_vaultToken: address) -> address:\n    return yld.vaultToAsset[_vaultToken].underlyingAsset\n\n\n# underlying balances (both true and safe)\n\n\n@view\n@external\ndef getUnderlyingBalances(_vaultToken: address, _vaultTokenBalance: uint256) -> (uint256, uint256):\n    if _vaultTokenBalance == 0:\n        return 0, 0\n\n    trueUnderlying: uint256 = self._getUnderlyingAmount(_vaultToken, _vaultTokenBalance)\n    safeUnderlying: uint256 = self._getUnderlyingAmountSafe(_vaultToken, _vaultTokenBalance)\n    if safeUnderlying == 0:\n        safeUnderlying = trueUnderlying\n\n    return trueUnderlying, min(trueUnderlying, safeUnderlying)\n\n\n# underlying amount (true)\n\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    return self._getUnderlyingAmount(_vaultToken, _vaultTokenAmount)\n\n\n@view\n@internal\ndef _getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    return _vaultTokenAmount * staticcall CompoundV2(_vaultToken).exchangeRateStored() // (10 ** 18)\n\n\n# underlying amount (safe)\n\n\n@view\n@external\ndef getUnderlyingAmountSafe(_vaultToken: address, _vaultTokenBalance: uint256) -> uint256:\n    return self._getUnderlyingAmountSafe(_vaultToken, _vaultTokenBalance)\n\n\n@view\n@internal\ndef _getUnderlyingAmountSafe(_vaultToken: address, _vaultTokenBalance: uint256) -> uint256:\n    vaultInfo: ls.VaultTokenInfo = yld.vaultToAsset[_vaultToken]\n    if vaultInfo.decimals == 0:\n        return 0 # not registered\n\n    # safe underlying amount (using cached weighted average from snapshots)\n    return _vaultTokenBalance * vaultInfo.lastAveragePricePerShare // (10 ** vaultInfo.decimals)\n\n\n# underlying data (combined)\n\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> (address, uint256, uint256):\n    return self._getUnderlyingData(_vaultToken, _vaultTokenAmount, _appraiser)\n\n\n@view\n@internal\ndef _getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address) -> (address, uint256, uint256):\n    asset: address = self._getUnderlyingAsset(_vaultToken)\n    if asset == empty(address):\n        return empty(address), 0, 0 # invalid vault token\n    underlyingAmount: uint256 = self._getUnderlyingAmount(_vaultToken, _vaultTokenAmount)\n    usdValue: uint256 = self._getUsdValue(asset, underlyingAmount, _appraiser)\n    return asset, underlyingAmount, usdValue\n\n\n# usd value\n\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> uint256:\n    return self._getUsdValueOfVaultToken(_vaultToken, _vaultTokenAmount, _appraiser)\n\n\n@view\n@internal\ndef _getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address) -> uint256:\n    return self._getUnderlyingData(_vaultToken, _vaultTokenAmount, _appraiser)[2]\n\n\n@view\n@internal\ndef _getUsdValue(_asset: address, _amount: uint256, _appraiser: address) -> uint256:\n    appraiser: address = _appraiser\n    if _appraiser == empty(address):\n        appraiser = addys._getAppraiserAddr()\n    return staticcall Appraiser(appraiser).getUsdValue(_asset, _amount)\n\n\n###############\n# Other Utils #\n###############\n\n\n# basics\n\n\n@view\n@external\ndef isRebasing() -> bool:\n    return self._isRebasing()\n\n\n@view\n@internal\ndef _isRebasing() -> bool:\n    return False\n\n\n# price per share\n\n\n@view\n@external\ndef getPricePerShare(_vaultToken: address, _decimals: uint256 = 0) -> uint256:\n    decimals: uint256 = _decimals\n    if decimals == 0:\n        decimals = yld.vaultToAsset[_vaultToken].decimals\n    if decimals == 0:\n        return 0 # not registered\n    return self._getPricePerShare(_vaultToken, decimals)\n\n\n@view\n@internal\ndef _getPricePerShare(_vaultToken: address, _decimals: uint256) -> uint256:\n    return (10 ** _decimals) * staticcall CompoundV2(_vaultToken).exchangeRateStored() // (10 ** 18)\n\n\n# vault token amount\n\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    return _assetAmount * (10 ** 18) // staticcall CompoundV2(_vaultToken).exchangeRateStored()\n\n\n# extras\n\n\n@view\n@external\ndef isEligibleVaultForTrialFunds(_vaultToken: address, _underlyingAsset: address) -> bool:\n    return False\n\n\n@view\n@external\ndef isEligibleForYieldBonus(_asset: address) -> bool:\n    return False\n\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    return staticcall CompoundV2(_vaultToken).totalSupply() * staticcall CompoundV2(_vaultToken).exchangeRateStored() // (10 ** 18)\n\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    return staticcall CompoundV2(_vaultToken).totalBorrows()\n\n\n################\n# Registration #\n################\n\n\n# can vault be registered\n\n\n@view\n@external\ndef canRegisterVaultToken(_asset: address, _vaultToken: address) -> bool:\n    return self._canRegisterVaultToken(_asset, _vaultToken)\n\n\n@view\n@internal\ndef _canRegisterVaultToken(_asset: address, _vaultToken: address) -> bool:\n    if empty(address) in [_asset, _vaultToken]:\n        return False\n    if staticcall CompoundV2(_vaultToken).underlying() != _asset:\n        return False\n    compMarkets: DynArray[address, MAX_MARKETS] = staticcall MoonwellComptroller(MOONWELL_COMPTROLLER).getAllMarkets()\n    return _vaultToken in compMarkets\n\n\n# register vault token locally\n\n\n@external\ndef registerVaultTokenLocally(_asset: address, _vaultAddr: address) -> ls.VaultTokenInfo:\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert self._canRegisterVaultToken(_asset, _vaultAddr) # dev: cannot register vault token\n    assert not yld._isAssetOpportunity(_asset, _vaultAddr) # dev: already registered\n    vaultInfo: ls.VaultTokenInfo = self._registerVaultTokenLocally(_asset, _vaultAddr)\n    self._registerVaultTokenGlobally(_asset, _vaultAddr, vaultInfo.decimals, addys._getLedgerAddr(), addys._getLegoBookAddr())\n    return vaultInfo\n\n\n@internal\ndef _registerVaultTokenLocally(_asset: address, _vaultAddr: address) -> ls.VaultTokenInfo:\n    assert extcall IERC20(_asset).approve(_vaultAddr, max_value(uint256), default_return_value=True) # dev: max approval failed\n    vaultInfo: ls.VaultTokenInfo = yld._addAssetOpportunity(_asset, _vaultAddr)\n    assert vaultInfo.decimals != 0 # dev: invalid vault token\n    return vaultInfo\n\n\n# remove vault token locally\n\n\n@external\ndef deregisterVaultTokenLocally(_asset: address, _vaultAddr: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert yld._isAssetOpportunity(_asset, _vaultAddr) # dev: already registered\n    self._deregisterVaultTokenLocally(_asset, _vaultAddr)\n\n\n@internal\ndef _deregisterVaultTokenLocally(_asset: address, _vaultAddr: address):\n    assert extcall IERC20(_asset).approve(_vaultAddr, 0, default_return_value=True) # dev: max approval failed\n    yld._removeAssetOpportunity(_asset, _vaultAddr)\n\n\n# ledger registration\n\n\n@internal\ndef _registerVaultTokenGlobally(_underlyingAsset: address, _vaultToken: address, _decimals: uint256, _ledger: address, _legoBook: address):\n    if not staticcall Ledger(_ledger).isRegisteredVaultToken(_vaultToken):\n        legoId: uint256 = staticcall Registry(_legoBook).getRegId(self)\n        extcall Ledger(_ledger).setVaultToken(_vaultToken, legoId, _underlyingAsset, _decimals, self._isRebasing())\n\n\n#################\n# Yield Actions #\n#################\n\n\n# add price snapshot\n\n\n@external\ndef addPriceSnapshot(_vaultToken: address) -> bool:\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    vaultInfo: ls.VaultTokenInfo = yld.vaultToAsset[_vaultToken]\n    assert vaultInfo.decimals != 0 # dev: not registered\n    pricePerShare: uint256 = self._getPricePerShare(_vaultToken, vaultInfo.decimals)\n    return yld._addPriceSnapshot(_vaultToken, pricePerShare, vaultInfo.decimals)\n\n\n# deposit\n\n\n@external\ndef depositForYield(\n    _asset: address,\n    _amount: uint256,\n    _vaultAddr: address,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, address, uint256, uint256):\n    assert not yld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = yld._getMiniAddys(_miniAddys)\n    vaultInfo: ls.VaultTokenInfo = self._getVaultInfoOnDeposit(_asset, _vaultAddr, miniAddys.ledger, miniAddys.legoBook)\n\n    # pre balances\n    preLegoVaultBalance: uint256 = staticcall IERC20(_vaultAddr).balanceOf(self)\n    preLegoBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n\n    # transfer deposit asset to this contract\n    depositAmount: uint256 = min(_amount, staticcall IERC20(_asset).balanceOf(msg.sender))\n    assert depositAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_asset).transferFrom(msg.sender, self, depositAmount, default_return_value=True) # dev: transfer failed\n\n    # deposit assets into lego partner\n    assert extcall CompoundV2(_vaultAddr).mint(depositAmount) == 0 # dev: could not deposit into moonwell\n\n    # validate received vault tokens, transfer back to user\n    vaultTokenAmountReceived: uint256 = staticcall IERC20(_vaultAddr).balanceOf(self) - preLegoVaultBalance\n    assert vaultTokenAmountReceived != 0 # dev: no vault tokens received\n    assert extcall IERC20(_vaultAddr).transfer(_recipient, vaultTokenAmountReceived, default_return_value=True) # dev: transfer failed\n\n    # refund if full deposit didn't get through\n    currentLegoBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    refundAssetAmount: uint256 = 0\n    if currentLegoBalance > preLegoBalance:\n        refundAssetAmount = currentLegoBalance - preLegoBalance\n        assert extcall IERC20(_asset).transfer(msg.sender, refundAssetAmount, default_return_value=True) # dev: transfer failed\n        depositAmount -= refundAssetAmount\n\n    usdValue: uint256 = extcall Appraiser(miniAddys.appraiser).updatePriceAndGetUsdValue(_asset, depositAmount, miniAddys.missionControl, miniAddys.legoBook)\n    log MoonwellDeposit(\n        sender = msg.sender,\n        asset = _asset,\n        vaultToken = _vaultAddr,\n        assetAmountDeposited = depositAmount,\n        usdValue = usdValue,\n        vaultTokenAmountReceived = vaultTokenAmountReceived,\n        recipient = _recipient,\n    )\n\n    # add price snapshot\n    pricePerShare: uint256 = self._getPricePerShare(_vaultAddr, vaultInfo.decimals)\n    yld._addPriceSnapshot(_vaultAddr, pricePerShare, vaultInfo.decimals)\n\n    return depositAmount, _vaultAddr, vaultTokenAmountReceived, usdValue\n\n\n# vault info on deposit\n\n\n@internal\ndef _getVaultInfoOnDeposit(_asset: address, _vaultAddr: address, _ledger: address, _legoBook: address) -> ls.VaultTokenInfo:\n    vaultInfo: ls.VaultTokenInfo = yld.vaultToAsset[_vaultAddr]\n    if vaultInfo.decimals == 0:\n        assert self._canRegisterVaultToken(_asset, _vaultAddr) # dev: cannot register vault token\n        vaultInfo = self._registerVaultTokenLocally(_asset, _vaultAddr)\n        self._registerVaultTokenGlobally(_asset, _vaultAddr, vaultInfo.decimals, _ledger, _legoBook)\n    else:\n        assert vaultInfo.underlyingAsset == _asset # dev: asset mismatch\n    return vaultInfo\n\n\n# withdraw\n\n\n@external\ndef withdrawFromYield(\n    _vaultToken: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, address, uint256, uint256):\n    assert not yld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = yld._getMiniAddys(_miniAddys)\n    vaultInfo: ls.VaultTokenInfo = self._getVaultInfoOnWithdrawal(_vaultToken, miniAddys.ledger, miniAddys.legoBook)\n\n    # pre balances\n    preLegoBalance: uint256 = staticcall IERC20(vaultInfo.underlyingAsset).balanceOf(self)\n    preLegoVaultBalance: uint256 = staticcall IERC20(_vaultToken).balanceOf(self)\n\n    # transfer vaults tokens to this contract\n    vaultTokenAmount: uint256 = min(_amount, staticcall IERC20(_vaultToken).balanceOf(msg.sender))\n    assert vaultTokenAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_vaultToken).transferFrom(msg.sender, self, vaultTokenAmount, default_return_value=True) # dev: transfer failed\n\n    # withdraw assets from lego partner\n    assert extcall CompoundV2(_vaultToken).redeem(max_value(uint256)) == 0 # dev: could not withdraw from moonwell\n\n    # when withdrawing weth, they give eth\n    if vaultInfo.underlyingAsset == WETH:\n        extcall WethContract(WETH).deposit(value=self.balance)\n\n    # validate received asset , transfer back to user\n    assetAmountReceived: uint256 = staticcall IERC20(vaultInfo.underlyingAsset).balanceOf(self) - preLegoBalance\n    assert assetAmountReceived != 0 # dev: no asset amount received\n    assert extcall IERC20(vaultInfo.underlyingAsset).transfer(_recipient, assetAmountReceived, default_return_value=True) # dev: transfer failed\n\n    # refund if full withdrawal didn't happen\n    currentLegoVaultBalance: uint256 = staticcall IERC20(_vaultToken).balanceOf(self)\n    refundVaultTokenAmount: uint256 = 0\n    if currentLegoVaultBalance > preLegoVaultBalance:\n        refundVaultTokenAmount = currentLegoVaultBalance - preLegoVaultBalance\n        assert extcall IERC20(_vaultToken).transfer(msg.sender, refundVaultTokenAmount, default_return_value=True) # dev: transfer failed\n        vaultTokenAmount -= refundVaultTokenAmount\n\n    usdValue: uint256 = extcall Appraiser(miniAddys.appraiser).updatePriceAndGetUsdValue(vaultInfo.underlyingAsset, assetAmountReceived, miniAddys.missionControl, miniAddys.legoBook)\n    log MoonwellWithdrawal(\n        sender = msg.sender,\n        asset = vaultInfo.underlyingAsset,\n        vaultToken = _vaultToken,\n        assetAmountReceived = assetAmountReceived,\n        usdValue = usdValue,\n        vaultTokenAmountBurned = vaultTokenAmount,\n        recipient = _recipient,\n    )\n\n    # add price snapshot\n    pricePerShare: uint256 = self._getPricePerShare(_vaultToken, vaultInfo.decimals)\n    yld._addPriceSnapshot(_vaultToken, pricePerShare, vaultInfo.decimals)\n\n    return vaultTokenAmount, vaultInfo.underlyingAsset, assetAmountReceived, usdValue\n\n\n# vault info on withdrawal\n\n\n@internal\ndef _getVaultInfoOnWithdrawal(_vaultAddr: address, _ledger: address, _legoBook: address) -> ls.VaultTokenInfo:\n    vaultInfo: ls.VaultTokenInfo = yld.vaultToAsset[_vaultAddr]\n    if vaultInfo.decimals == 0:\n        asset: address = staticcall CompoundV2(_vaultAddr).underlying()\n        assert self._canRegisterVaultToken(asset, _vaultAddr) # dev: cannot register vault token\n        vaultInfo = self._registerVaultTokenLocally(asset, _vaultAddr)\n        self._registerVaultTokenGlobally(asset, _vaultAddr, vaultInfo.decimals, _ledger, _legoBook)\n    return vaultInfo\n\n\n#################\n# Claim Rewards #\n#################\n\n\n@external\ndef claimRewards(\n    _user: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _extraData: bytes32,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    assert not yld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = yld._getMiniAddys(_miniAddys)\n\n    assert msg.sender == _user # dev: recipient must be caller\n    preBalance: uint256 = staticcall IERC20(_rewardToken).balanceOf(_user)\n\n    # claim rewards\n    extcall MoonwellComptroller(MOONWELL_COMPTROLLER).claimReward(_user)\n    rewardAmount: uint256 = staticcall IERC20(_rewardToken).balanceOf(_user) - preBalance\n    assert rewardAmount != 0 # dev: no rewards received\n\n    usdValue: uint256 = extcall Appraiser(miniAddys.appraiser).updatePriceAndGetUsdValue(_rewardToken, rewardAmount, miniAddys.missionControl, miniAddys.legoBook)\n    return rewardAmount, usdValue\n\n\n@view\n@external\ndef hasClaimableRewards(_user: address) -> bool:\n    rewardDistributor: address = staticcall MoonwellComptroller(MOONWELL_COMPTROLLER).rewardDistributor()\n    rewardsWithMToken: DynArray[RewardWithMToken, MAX_MARKETS] = staticcall MoonwellRewardDistributor(rewardDistributor).getOutstandingRewardsForUser(_user)\n    for i: uint256 in range(len(rewardsWithMToken), bound=MAX_MARKETS):\n        rewardsInfo: DynArray[RewardInfo, MAX_ASSETS] = rewardsWithMToken[i].rewards\n        for j: uint256 in range(len(rewardsInfo), bound=MAX_ASSETS):\n            if rewardsInfo[j].totalAmount > 0:\n                return True\n    return False\n\n\n#########\n# Other #\n#########\n\n\n@view\n@external\ndef getAccessForLego(_user: address, _action: ws.ActionType) -> (address, String[64], uint256):\n    return empty(address), empty(String[64]), 0\n\n\n@external\ndef swapTokens(\n    _amountIn: uint256,\n    _minAmountOut: uint256,\n    _tokenPath: DynArray[address, MAX_TOKEN_PATH],\n    _poolPath: DynArray[address, MAX_TOKEN_PATH - 1],\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256):\n    return 0, 0, 0\n\n\n@external\ndef mintOrRedeemAsset(\n    _tokenIn: address,\n    _tokenOut: address,\n    _tokenInAmount: uint256,\n    _minAmountOut: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, bool, uint256):\n    return 0, 0, False, 0\n\n\n@external\ndef confirmMintOrRedeemAsset(\n    _tokenIn: address,\n    _tokenOut: address,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef addCollateral(\n    _asset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef removeCollateral(\n    _asset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef borrow(\n    _borrowAsset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef repayDebt(\n    _paymentAsset: address,\n    _paymentAmount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef addLiquidity(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _amountA: uint256,\n    _amountB: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _minLpAmount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (address, uint256, uint256, uint256, uint256):\n    return empty(address), 0, 0, 0, 0\n\n\n@external\ndef removeLiquidity(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpToken: address,\n    _lpAmount: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, uint256):\n    return 0, 0, 0, 0\n\n\n@external\ndef addLiquidityConcentrated(\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _tickLower: int24,\n    _tickUpper: int24,\n    _amountA: uint256,\n    _amountB: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, uint256, uint256):\n    return 0, 0, 0, 0, 0\n\n\n@external\ndef removeLiquidityConcentrated(\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _liqToRemove: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, bool, uint256):\n    return 0, 0, 0, False, 0",
            "sha256sum": "c9db78834dc15e568df62ca7aeb3b473da9bd2cc55f853b71a82a25b0b8a6de9"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/legos/yield/Moonwell.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.3+commit.bff19ea2",
        "integrity": "357fd175bb170550313d930b3d804ca787f9c7f853d71cb5862fb3686d30031e"
      },
      "args": "00000000000000000000000044cf3c4f000dfd76a35d03298049d37be688d6f9000000000000000000000000fbb21d0380bee3312b33c4353c8936a0f13ef26c0000000000000000000000004200000000000000000000000000000000000006",
      "file": "contracts/legos/yield/Moonwell.vy"
    },
    "Morpho": {
      "address": "0x7035201951b4F4c82994602b96aC0Be5b41401F4",
      "abi": [
        {
          "name": "MorphoDeposit",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountDeposited",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultTokenAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "MorphoWithdrawal",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultTokenAmountBurned",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "MorphoRewardsAddrSet",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LegoPauseModified",
          "inputs": [
            {
              "name": "isPaused",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LegoFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "balance",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "SnapShotPriceConfigSet",
          "inputs": [
            {
              "name": "minSnapshotDelay",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "maxNumSnapshots",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "maxUpsideDeviation",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "staleTime",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetOpportunityAdded",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultAddr",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetOpportunityRemoved",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultAddr",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PricePerShareSnapShotAdded",
          "inputs": [
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "totalSupply",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "pricePerShare",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddys",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "undyToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "hatchery",
                  "type": "address"
                },
                {
                  "name": "lootDistributor",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                },
                {
                  "name": "walletBackpack",
                  "type": "address"
                },
                {
                  "name": "billing",
                  "type": "address"
                },
                {
                  "name": "vaultRegistry",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUndyHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isLegoAsset",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssetOpportunities",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isAssetOpportunity",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getNumLegoAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pause",
          "inputs": [
            {
              "name": "_shouldPause",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFundsMany",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_assets",
              "type": "address[]"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getWeightedPricePerShare",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLatestSnapshot",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_pricePerShare",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "totalSupply",
                  "type": "uint256"
                },
                {
                  "name": "pricePerShare",
                  "type": "uint256"
                },
                {
                  "name": "lastUpdate",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setSnapShotPriceConfig",
          "inputs": [
            {
              "name": "_config",
              "type": "tuple",
              "components": [
                {
                  "name": "minSnapshotDelay",
                  "type": "uint256"
                },
                {
                  "name": "maxNumSnapshots",
                  "type": "uint256"
                },
                {
                  "name": "maxUpsideDeviation",
                  "type": "uint256"
                },
                {
                  "name": "staleTime",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidPriceConfig",
          "inputs": [
            {
              "name": "_config",
              "type": "tuple",
              "components": [
                {
                  "name": "minSnapshotDelay",
                  "type": "uint256"
                },
                {
                  "name": "maxNumSnapshots",
                  "type": "uint256"
                },
                {
                  "name": "maxUpsideDeviation",
                  "type": "uint256"
                },
                {
                  "name": "staleTime",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "vaultToAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "underlyingAsset",
                  "type": "address"
                },
                {
                  "name": "decimals",
                  "type": "uint256"
                },
                {
                  "name": "lastAveragePricePerShare",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assetOpportunities",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAssetOpportunity",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssetOpportunities",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assets",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "snapShotData",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "lastSnapShot",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "totalSupply",
                      "type": "uint256"
                    },
                    {
                      "name": "pricePerShare",
                      "type": "uint256"
                    },
                    {
                      "name": "lastUpdate",
                      "type": "uint256"
                    }
                  ]
                },
                {
                  "name": "nextIndex",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "snapShots",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "totalSupply",
                  "type": "uint256"
                },
                {
                  "name": "pricePerShare",
                  "type": "uint256"
                },
                {
                  "name": "lastUpdate",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "snapShotPriceConfig",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "minSnapshotDelay",
                  "type": "uint256"
                },
                {
                  "name": "maxNumSnapshots",
                  "type": "uint256"
                },
                {
                  "name": "maxUpsideDeviation",
                  "type": "uint256"
                },
                {
                  "name": "staleTime",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isPaused",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasCapability",
          "inputs": [
            {
              "name": "_action",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRegistries",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isYieldLego",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isDexLego",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAsset",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingBalances",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenBalance",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAmount",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAmountSafe",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenBalance",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingData",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingData",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            },
            {
              "name": "_appraiser",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValueOfVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValueOfVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            },
            {
              "name": "_appraiser",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isRebasing",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPricePerShare",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPricePerShare",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_decimals",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getVaultTokenAmount",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_assetAmount",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isEligibleVaultForTrialFunds",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_underlyingAsset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isEligibleForYieldBonus",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalAssets",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalBorrows",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canRegisterVaultToken",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "registerVaultTokenLocally",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "underlyingAsset",
                  "type": "address"
                },
                {
                  "name": "decimals",
                  "type": "uint256"
                },
                {
                  "name": "lastAveragePricePerShare",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "deregisterVaultTokenLocally",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addPriceSnapshot",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositForYield",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositForYield",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawFromYield",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawFromYield",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasClaimableRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setMorphoRewardsAddr",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAccessForLego",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_action",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "string"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_tokenPath",
              "type": "address[]"
            },
            {
              "name": "_poolPath",
              "type": "address[]"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_tokenPath",
              "type": "address[]"
            },
            {
              "name": "_poolPath",
              "type": "address[]"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_tokenInAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_tokenInAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmMintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmMintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_borrowAsset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_borrowAsset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_paymentAsset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_paymentAsset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "morphoRewards",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MORPHO_FACTORY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MORPHO_FACTORY_LEGACY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_undyHq",
              "type": "address"
            },
            {
              "name": "_morphoFactory",
              "type": "address"
            },
            {
              "name": "_morphoFactoryLegacy",
              "type": "address"
            },
            {
              "name": "_morphoRewardsAddr",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "interfaces/WalletStructs.vyi": {
            "content": "# @version 0.4.3\n\nflag ActionType:\n    TRANSFER\n    EARN_DEPOSIT\n    EARN_WITHDRAW\n    EARN_REBALANCE\n    SWAP\n    MINT_REDEEM\n    CONFIRM_MINT_REDEEM\n    ADD_COLLATERAL\n    REMOVE_COLLATERAL\n    BORROW\n    REPAY_DEBT\n    REWARDS\n    ETH_TO_WETH\n    WETH_TO_ETH\n    ADD_LIQ\n    REMOVE_LIQ\n    ADD_LIQ_CONC\n    REMOVE_LIQ_CONC\n    PAY_CHEQUE\n\nstruct WalletAssetData:\n    assetBalance: uint256\n    usdValue: uint256\n    isYieldAsset: bool\n    lastPricePerShare: uint256\n\nstruct ActionData:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    billing: address\n    wallet: address\n    walletConfig: address\n    walletOwner: address\n    inEjectMode: bool\n    isFrozen: bool\n    lastTotalUsdValue: uint256\n    signer: address\n    isManager: bool\n    legoId: uint256\n    legoAddr: address\n    eth: address\n    weth: address\n\nstruct MiniAddys:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    appraiser: address",
            "sha256sum": "9a4b4f59b3a62043e51b425a665064aae419a3c0bd0514b6b29a9441ae364bb9"
          },
          "interfaces/LegoPartner.vyi": {
            "content": "# @version 0.4.3\n\nfrom interfaces import WalletStructs as ws\n\nMAX_TOKEN_PATH: constant(uint256) = 5\nMAX_RECOVER_ASSETS: constant(uint256) = 20\n\n@external\ndef addLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _tickLower: int24, _tickUpper: int24, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef addLiquidity(_pool: address, _tokenA: address, _tokenB: address, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _minLpAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (address, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef removeLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _liqToRemove: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef removeLiquidity(_pool: address, _tokenA: address, _tokenB: address, _lpToken: address, _lpAmount: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef mintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _tokenInAmount: uint256, _minAmountOut: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef swapTokens(_amountIn: uint256, _minAmountOut: uint256, _tokenPath: DynArray[address, MAX_TOKEN_PATH], _poolPath: DynArray[address, MAX_TOKEN_PATH - 1], _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256):\n    ...\n\n@external\ndef depositForYield(_asset: address, _amount: uint256, _vaultAddr: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef withdrawFromYield(_vaultToken: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef confirmMintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef borrow(_borrowAsset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef repayDebt(_paymentAsset: address, _paymentAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef claimRewards(_user: address, _rewardToken: address, _rewardAmount: uint256, _extraData: bytes32, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef removeCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef addCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@view\n@external\ndef getAccessForLego(_user: address, _action: ws.ActionType) -> (address, String[64], uint256):\n    ...\n\n@view\n@external\ndef hasCapability(_action: ws.ActionType) -> bool:\n    ...\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    ...\n\n@view\n@external\ndef isYieldLego() -> bool:\n    ...\n\n@view\n@external\ndef isDexLego() -> bool:\n    ...\n\n\n# common\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "81db71fe4440a3b4b563134c9b5caf1d5705772a5f291fe874c9b5fb3cfb1623"
          },
          "interfaces/LegoStructs.vyi": {
            "content": "# @version 0.4.3\n\nstruct VaultTokenInfo:\n    underlyingAsset: address\n    decimals: uint256\n    lastAveragePricePerShare: uint256\n\nstruct SnapShotPriceConfig:\n    minSnapshotDelay: uint256\n    maxNumSnapshots: uint256\n    maxUpsideDeviation: uint256\n    staleTime: uint256\n\nstruct SingleSnapShot:\n    totalSupply: uint256\n    pricePerShare: uint256\n    lastUpdate: uint256\n\nstruct SnapShotData:\n    lastSnapShot: SingleSnapShot\n    nextIndex: uint256\n",
            "sha256sum": "8ae48be17d812d57fbd671bbf0593e8abf175ad0924e47c5997823cac19ec806"
          },
          "interfaces/YieldLego.vyi": {
            "content": "# @version 0.4.3\n\nfrom interfaces import LegoStructs as ls\n\n\n###################\n# Underlying Data #\n###################\n\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    ...\n\n\n@view\n@external\ndef getUnderlyingBalances(_vaultToken: address, _vaultTokenBalance: uint256) -> (uint256, uint256):\n    ...\n\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    ...\n\n\n@view\n@external\ndef getUnderlyingAmountSafe(_vaultToken: address, _vaultTokenBalance: uint256) -> uint256:\n    ...\n\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> (address, uint256, uint256):\n    ...\n\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> uint256:\n    ...\n\n\n###############\n# Other Utils #\n###############\n\n\n@view\n@external\ndef isRebasing() -> bool:\n    ...\n\n\n@view\n@external\ndef getPricePerShare(_vaultToken: address, _decimals: uint256 = 0) -> uint256:\n    ...\n\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef canRegisterVaultToken(_asset: address, _vaultToken: address) -> bool:\n    ...\n\n\n@view\n@external\ndef isEligibleVaultForTrialFunds(_vaultToken: address, _underlyingAsset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef isEligibleForYieldBonus(_asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    ...\n\n\n###################\n# Yield Lego Data #\n###################\n\n\n@view\n@external\ndef isLegoAsset(_asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, 40]:\n    ...\n\n\n@view\n@external\ndef getAssets() -> DynArray[address, 20]:\n    ...\n\n\n@view\n@external\ndef isAssetOpportunity(_asset: address, _vaultAddr: address) -> bool:\n    ...\n\n\n@view\n@external\ndef getNumLegoAssets() -> uint256:\n    ...\n\n\n@view\n@external\ndef assets(_index: uint256) -> address:\n    ...\n\n\n@view\n@external\ndef indexOfAsset(_asset: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef numAssets() -> uint256:\n    ...\n\n\n@view\n@external\ndef assetOpportunities(_asset: address, _index: uint256) -> address:\n    ...\n\n\n@view\n@external\ndef indexOfAssetOpportunity(_asset: address, _vaultAddr: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef numAssetOpportunities(_asset: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef vaultToAsset(_vaultAddr: address) -> ls.VaultTokenInfo:\n    ...\n\n\n# price snapshots\n\n\n@external\ndef addPriceSnapshot(_vaultToken: address) -> bool:\n    ...\n\n\n@view\n@external\ndef snapShotPriceConfig() -> ls.SnapShotPriceConfig:\n    ...\n\n\n@view\n@external\ndef snapShotData(_vaultToken: address) -> ls.SnapShotData:\n    ...\n\n\n@view\n@external\ndef snapShots(_vaultToken: address, _index: uint256) -> ls.SingleSnapShot:\n    ...\n\n\n@view\n@external\ndef getWeightedPricePerShare(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef getLatestSnapshot(_vaultToken: address, _pricePerShare: uint256) -> ls.SingleSnapShot:\n    ...\n\n\n@external\ndef setSnapShotPriceConfig(_config: ls.SnapShotPriceConfig):\n    ...\n",
            "sha256sum": "045a6bbd3d556234cf4fe925a303002dc0ac3c482d344ffbaf4bc52a7e6ad2df"
          },
          "contracts/modules/Addys.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\ninterface UndyHq:\n    def isValidAddr(_addr: address) -> bool: view\n    def getAddr(_regId: uint256) -> address: view\n    def undyToken() -> address: view\n\ninterface Switchboard:\n    def isSwitchboardAddr(_addr: address) -> bool: view\n\ninterface LegoBook:\n    def isLegoAddr(_addr: address) -> bool: view\n\nstruct Addys:\n    hq: address\n    undyToken: address\n    ledger: address\n    missionControl: address\n    legoBook: address\n    switchboard: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    walletBackpack: address\n    billing: address\n    vaultRegistry: address\n\n# hq\nUNDY_HQ_FOR_ADDYS: immutable(address)\n\n# core addys\nLEDGER_ID: constant(uint256) = 1\nMISSION_CONTROL_ID: constant(uint256) = 2\nLEGO_BOOK_ID: constant(uint256) = 3\nSWITCHBOARD_ID: constant(uint256) = 4\nHATCHERY_ID: constant(uint256) = 5\nLOOT_DISTRIBUTOR_ID: constant(uint256) = 6\nAPPRAISER_ID: constant(uint256) = 7\nWALLET_BACKPACK_ID: constant(uint256) = 8\nBILLING_ID: constant(uint256) = 9\nVAULT_REGISTRY_ID: constant(uint256) = 10\n\n\n@deploy\ndef __init__(_undyHq: address):\n    assert _undyHq != empty(address) # dev: invalid undy hq\n    UNDY_HQ_FOR_ADDYS = _undyHq\n\n\n########\n# Core #\n########\n\n\n@view\n@external\ndef getAddys() -> Addys:\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _getAddys(_addys: Addys = empty(Addys)) -> Addys:\n    if _addys.hq != empty(address):\n        return _addys\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _generateAddys() -> Addys:\n    hq: address = UNDY_HQ_FOR_ADDYS\n    return Addys(\n        hq = hq,\n        undyToken = staticcall UndyHq(hq).undyToken(),\n        ledger = staticcall UndyHq(hq).getAddr(LEDGER_ID),\n        missionControl = staticcall UndyHq(hq).getAddr(MISSION_CONTROL_ID),\n        legoBook = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID),\n        switchboard = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID),\n        hatchery = staticcall UndyHq(hq).getAddr(HATCHERY_ID),\n        lootDistributor = staticcall UndyHq(hq).getAddr(LOOT_DISTRIBUTOR_ID),\n        appraiser = staticcall UndyHq(hq).getAddr(APPRAISER_ID),\n        walletBackpack = staticcall UndyHq(hq).getAddr(WALLET_BACKPACK_ID),\n        billing = staticcall UndyHq(hq).getAddr(BILLING_ID),\n        vaultRegistry = staticcall UndyHq(hq).getAddr(VAULT_REGISTRY_ID),\n    )\n\n\n##########\n# Tokens #\n##########\n\n\n@view\n@internal\ndef _getUndyToken() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).undyToken()\n\n\n###########\n# Helpers #\n###########\n\n\n# undy hq\n\n\n@view\n@external\ndef getUndyHq() -> address:\n    return self._getUndyHq()\n\n\n@view\n@internal\ndef _getUndyHq() -> address:\n    return UNDY_HQ_FOR_ADDYS\n\n\n# utils\n\n\n@view\n@internal\ndef _isValidUndyAddr(_addr: address, _hq: address = empty(address)) -> bool:\n    hq: address = _hq\n    if _hq == empty(address):\n        hq = UNDY_HQ_FOR_ADDYS\n    \n    # core departments\n    if staticcall UndyHq(hq).isValidAddr(_addr):\n        return True\n\n    # lego book\n    legoBook: address = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID)\n    if legoBook != empty(address) and staticcall LegoBook(legoBook).isLegoAddr(_addr):\n        return True\n\n    # switchboard config\n    switchboard: address = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID)\n    if switchboard != empty(address) and staticcall Switchboard(switchboard).isSwitchboardAddr(_addr):\n        return True\n\n    return False\n\n\n@view\n@internal\ndef _isSwitchboardAddr(_addr: address) -> bool:\n    switchboard: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n    if switchboard == empty(address):\n        return False\n    return staticcall Switchboard(switchboard).isSwitchboardAddr(_addr)\n\n\n@view\n@internal\ndef _isLegoBookAddr(_addr: address) -> bool:\n    legoBook: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n    if legoBook == empty(address):\n        return False\n    return staticcall LegoBook(legoBook).isLegoAddr(_addr)\n\n\n###############\n# Departments #\n###############\n\n\n# ledger\n\n\n@view\n@internal\ndef _getLedgerId() -> uint256:\n    return LEDGER_ID\n\n\n@view\n@internal\ndef _getLedgerAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEDGER_ID)\n\n\n# mission control\n\n\n@view\n@internal\ndef _getMissionControlId() -> uint256:\n    return MISSION_CONTROL_ID\n\n\n@view\n@internal\ndef _getMissionControlAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(MISSION_CONTROL_ID)\n\n\n# lego book\n\n\n@view\n@internal\ndef _getLegoBookId() -> uint256:\n    return LEGO_BOOK_ID\n\n\n@view\n@internal\ndef _getLegoBookAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n\n\n# switchboard\n\n\n@view\n@internal\ndef _getSwitchboardId() -> uint256:\n    return SWITCHBOARD_ID\n\n\n@view\n@internal\ndef _getSwitchboardAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n\n\n# hatchery\n\n\n@view\n@internal\ndef _getHatcheryId() -> uint256:\n    return HATCHERY_ID\n\n\n@view\n@internal\ndef _getHatcheryAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(HATCHERY_ID)\n\n\n# loot distributor\n\n\n@view\n@internal\ndef _getLootDistributorId() -> uint256:\n    return LOOT_DISTRIBUTOR_ID\n\n\n@view\n@internal\ndef _getLootDistributorAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LOOT_DISTRIBUTOR_ID)\n\n\n# appraiser\n\n\n@view\n@internal\ndef _getAppraiserId() -> uint256:\n    return APPRAISER_ID\n\n\n@view\n@internal\ndef _getAppraiserAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(APPRAISER_ID)\n\n\n# wallet backpack\n\n\n@view\n@internal\ndef _getWalletBackpackId() -> uint256:\n    return WALLET_BACKPACK_ID\n\n\n@view\n@internal\ndef _getWalletBackpackAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(WALLET_BACKPACK_ID)\n\n\n# billing\n\n\n@view\n@internal\ndef _getBillingId() -> uint256:\n    return BILLING_ID\n\n\n@view\n@internal\ndef _getBillingAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(BILLING_ID)\n\n\n# vault registry\n\n\n@view\n@internal\ndef _getVaultRegistryId() -> uint256:\n    return VAULT_REGISTRY_ID\n\n\n@view\n@internal\ndef _getVaultRegistryAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(VAULT_REGISTRY_ID)",
            "sha256sum": "4df6b72db9bb417d1af81660175be1450cfb7b3575f3d17a5b8a130bff87b781"
          },
          "contracts/modules/YieldLegoData.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nuses: addys\n\nimport contracts.modules.Addys as addys\n\nfrom interfaces import WalletStructs as ws\nfrom interfaces import LegoStructs as ls\nfrom ethereum.ercs import IERC20\nfrom ethereum.ercs import IERC20Detailed\n\nevent AssetOpportunityAdded:\n    asset: indexed(address)\n    vaultAddr: indexed(address)\n\nevent AssetOpportunityRemoved:\n    asset: indexed(address)\n    vaultAddr: indexed(address)\n\nevent LegoPauseModified:\n    isPaused: bool\n\nevent LegoFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    balance: uint256\n\nevent PricePerShareSnapShotAdded:\n    vaultToken: indexed(address)\n    totalSupply: uint256\n    pricePerShare: uint256\n\nevent SnapShotPriceConfigSet:\n    minSnapshotDelay: uint256\n    maxNumSnapshots: uint256\n    maxUpsideDeviation: uint256\n    staleTime: uint256\n\n# core\nvaultToAsset: public(HashMap[address, ls.VaultTokenInfo]) # vault addr -> data\n\n# asset opportunities\nassetOpportunities: public(HashMap[address, HashMap[uint256, address]]) # asset -> index -> vault addr\nindexOfAssetOpportunity: public(HashMap[address, HashMap[address, uint256]]) # asset -> vault addr -> index\nnumAssetOpportunities: public(HashMap[address, uint256]) # asset -> number of opportunities\n\n# lego assets (iterable)\nassets: public(HashMap[uint256, address]) # index -> asset\nindexOfAsset: public(HashMap[address, uint256]) # asset -> index\nnumAssets: public(uint256) # num assets\n\n# price snapshots\nsnapShotData: public(HashMap[address, ls.SnapShotData]) # vault token -> data\nsnapShots: public(HashMap[address, HashMap[uint256, ls.SingleSnapShot]]) # vault token -> index -> snapshot\nsnapShotPriceConfig: public(ls.SnapShotPriceConfig) # config\n\nisPaused: public(bool)\n\nMAX_VAULTS: constant(uint256) = 40\nMAX_ASSETS: constant(uint256) = 20\nMAX_RECOVER_ASSETS: constant(uint256) = 20\nONE_DAY_SECONDS: constant(uint256) = 60 * 60 * 24\nONE_WEEK_SECONDS: constant(uint256) = ONE_DAY_SECONDS * 7\nHUNDRED_PERCENT: constant(uint256) = 100_00\n\n\n@deploy\ndef __init__(_shouldPause: bool):\n    self.isPaused = _shouldPause\n    self.numAssets = 1 # not using 0 index\n\n    # default snapshot price config\n    self.snapShotPriceConfig = ls.SnapShotPriceConfig(\n        minSnapshotDelay = 60 * 10, # 10 minutes\n        maxNumSnapshots = 20,\n        maxUpsideDeviation = 10_00, # 10%\n        staleTime = 3 * ONE_DAY_SECONDS, # 3 days\n    )\n\n\n#########\n# Views #\n#########\n\n\n# is lego asset\n\n\n@view\n@external\ndef isLegoAsset(_asset: address) -> bool:\n    return self._isLegoAsset(_asset)\n\n\n@view\n@internal\ndef _isLegoAsset(_asset: address) -> bool:\n    return self.indexOfAsset[_asset] != 0\n\n\n# vault opportunities\n\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, MAX_VAULTS]:\n    numOpportunities: uint256 = self.numAssetOpportunities[_asset]\n    if numOpportunities == 0:\n        return []\n    opportunities: DynArray[address, MAX_VAULTS] = []\n    for i: uint256 in range(1, numOpportunities, bound=MAX_VAULTS):\n        opportunities.append(self.assetOpportunities[_asset][i])\n    return opportunities\n\n\n# all assets registered\n\n\n@view\n@external\ndef getAssets() -> DynArray[address, MAX_ASSETS]:\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return []\n    assets: DynArray[address, MAX_ASSETS] = []\n    for i: uint256 in range(1, numAssets, bound=MAX_ASSETS):\n        assets.append(self.assets[i])\n    return assets\n\n\n################\n# Registration #\n################\n\n\n@view\n@external\ndef isAssetOpportunity(_asset: address, _vaultAddr: address) -> bool:\n    return self._isAssetOpportunity(_asset, _vaultAddr)\n\n\n@view\n@internal\ndef _isAssetOpportunity(_asset: address, _vaultAddr: address) -> bool:\n    return self.indexOfAssetOpportunity[_asset][_vaultAddr] != 0\n\n\n# add asset opportunity\n\n\n@internal\ndef _addAssetOpportunity(_asset: address, _vaultAddr: address) -> ls.VaultTokenInfo:\n    if self.indexOfAssetOpportunity[_asset][_vaultAddr] != 0:\n        return self.vaultToAsset[_vaultAddr]\n\n    if empty(address) in [_asset, _vaultAddr]:\n        return empty(ls.VaultTokenInfo)\n\n    # add asset opportunity\n    aid: uint256 = self.numAssetOpportunities[_asset]\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.assetOpportunities[_asset][aid] = _vaultAddr\n    self.indexOfAssetOpportunity[_asset][_vaultAddr] = aid\n    self.numAssetOpportunities[_asset] = aid + 1\n\n    # add mapping\n    vaultInfo: ls.VaultTokenInfo = ls.VaultTokenInfo(\n        underlyingAsset = _asset,\n        decimals = convert(staticcall IERC20Detailed(_vaultAddr).decimals(), uint256),\n        lastAveragePricePerShare = 0,\n    )\n    self.vaultToAsset[_vaultAddr] = vaultInfo\n\n    # add asset\n    self._addAsset(_asset)\n\n    log AssetOpportunityAdded(asset=_asset, vaultAddr=_vaultAddr)\n    return vaultInfo\n\n\n# remove asset opportunity\n\n\n@internal\ndef _removeAssetOpportunity(_asset: address, _vaultAddr: address):\n    numOpportunities: uint256 = self.numAssetOpportunities[_asset]\n    if numOpportunities == 0:\n        return\n\n    targetIndex: uint256 = self.indexOfAssetOpportunity[_asset][_vaultAddr]\n    if targetIndex == 0:\n        return\n\n    # update data\n    lastIndex: uint256 = numOpportunities - 1\n    self.numAssetOpportunities[_asset] = lastIndex\n    self.indexOfAssetOpportunity[_asset][_vaultAddr] = 0\n\n    self.vaultToAsset[_vaultAddr] = empty(ls.VaultTokenInfo)\n\n    # shift to replace the removed one\n    if targetIndex != lastIndex:\n        lastVaultAddr: address = self.assetOpportunities[_asset][lastIndex]\n        self.assetOpportunities[_asset][targetIndex] = lastVaultAddr\n        self.indexOfAssetOpportunity[_asset][lastVaultAddr] = targetIndex\n\n    # remove asset\n    if lastIndex <= 1:\n        self._removeAsset(_asset)\n\n    log AssetOpportunityRemoved(asset=_asset, vaultAddr=_vaultAddr)\n\n\n# add asset\n\n\n@internal\ndef _addAsset(_asset: address):\n    if self.indexOfAsset[_asset] != 0:\n        return\n\n    aid: uint256 = self.numAssets\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.assets[aid] = _asset\n    self.indexOfAsset[_asset] = aid\n    self.numAssets = aid + 1\n\n\n# remove asset\n\n\n@internal\ndef _removeAsset(_asset: address):\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return\n\n    targetIndex: uint256 = self.indexOfAsset[_asset]\n    if targetIndex == 0:\n        return\n\n    # update data\n    lastIndex: uint256 = numAssets - 1\n    self.numAssets = lastIndex\n    self.indexOfAsset[_asset] = 0\n\n    # shift to replace the removed one\n    if targetIndex != lastIndex:\n        lastAsset: address = self.assets[lastIndex]\n        self.assets[targetIndex] = lastAsset\n        self.indexOfAsset[lastAsset] = targetIndex\n\n\n# num lego assets (true number, use `numAssets` for iteration)\n\n\n@view\n@external\ndef getNumLegoAssets() -> uint256:\n    return self._getNumLegoAssets()\n\n\n@view\n@internal\ndef _getNumLegoAssets() -> uint256:\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return 0\n    return numAssets - 1\n\n\n###########\n# General #\n###########\n\n\n# fill mini addys\n\n\n@view\n@internal\ndef _getMiniAddys(_miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> ws.MiniAddys:\n    if _miniAddys.ledger != empty(address):\n        return _miniAddys\n    return ws.MiniAddys(\n        ledger = addys._getLedgerAddr(),\n        missionControl = addys._getMissionControlAddr(),\n        legoBook = addys._getLegoBookAddr(),\n        appraiser = addys._getAppraiserAddr(),\n    )\n\n\n# activate\n\n\n@external\ndef pause(_shouldPause: bool):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert _shouldPause != self.isPaused # dev: no change\n    self.isPaused = _shouldPause\n    log LegoPauseModified(isPaused=_shouldPause)\n\n\n# recover funds\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    self._recoverFunds(_recipient, _asset)\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, MAX_RECOVER_ASSETS]):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    for a: address in _assets:\n        self._recoverFunds(_recipient, a)\n\n\n@internal\ndef _recoverFunds(_recipient: address, _asset: address):\n    assert empty(address) not in [_recipient, _asset] # dev: invalid recipient or asset\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    assert balance != 0 # dev: nothing to recover\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log LegoFundsRecovered(asset=_asset, recipient=_recipient, balance=balance)\n\n\n###################\n# Price Snapshots #\n###################\n\n\n# add price snapshot\n\n\n@internal\ndef _addPriceSnapshot(_vaultToken: address, _pricePerShare: uint256, _vaultTokenDecimals: uint256) -> bool:\n    config: ls.SnapShotPriceConfig = self.snapShotPriceConfig\n    if config.maxNumSnapshots == 0:\n        return False\n\n    data: ls.SnapShotData = self.snapShotData[_vaultToken]\n\n    # already have snapshot for this time\n    if data.lastSnapShot.lastUpdate == block.timestamp:\n        return False\n\n    # check if snapshot is too recent\n    if data.lastSnapShot.lastUpdate + config.minSnapshotDelay > block.timestamp:\n        return False\n\n    # create and store new snapshot\n    newSnapshot: ls.SingleSnapShot = self._getLatestSnapshot(_vaultToken, _pricePerShare, _vaultTokenDecimals, data.lastSnapShot, config)\n    data.lastSnapShot = newSnapshot\n    self.snapShots[_vaultToken][data.nextIndex] = newSnapshot\n\n    # update index\n    data.nextIndex += 1\n    if data.nextIndex >= config.maxNumSnapshots:\n        data.nextIndex = 0\n\n    # save snap shot data\n    self.snapShotData[_vaultToken] = data\n\n    # update cached weighted average price per share\n    self.vaultToAsset[_vaultToken].lastAveragePricePerShare = self._getWeightedPricePerShare(_vaultToken, _pricePerShare)\n\n    log PricePerShareSnapShotAdded(\n        vaultToken = _vaultToken,\n        totalSupply = newSnapshot.totalSupply,\n        pricePerShare = newSnapshot.pricePerShare,\n    )\n    return True\n\n\n# weighted price per share\n\n\n@view\n@external\ndef getWeightedPricePerShare(_vaultToken: address) -> uint256:\n    data: ls.SnapShotData = self.snapShotData[_vaultToken]\n    return self._getWeightedPricePerShare(_vaultToken, data.lastSnapShot.pricePerShare)\n\n\n@view\n@internal\ndef _getWeightedPricePerShare(_vaultToken: address, _lastPricePerShare: uint256) -> uint256:\n    config: ls.SnapShotPriceConfig = self.snapShotPriceConfig\n    if config.maxNumSnapshots == 0:\n        return 0\n\n    # calculate weighted average price using all valid snapshots\n    numerator: uint256 = 0\n    denominator: uint256 = 0\n    for i: uint256 in range(config.maxNumSnapshots, bound=max_value(uint256)):\n\n        snapShot: ls.SingleSnapShot = self.snapShots[_vaultToken][i]\n        if snapShot.pricePerShare == 0 or snapShot.totalSupply == 0 or snapShot.lastUpdate == 0:\n            continue\n\n        # too stale, skip\n        if config.staleTime != 0 and block.timestamp > snapShot.lastUpdate + config.staleTime:\n            continue\n\n        numerator += (snapShot.totalSupply * snapShot.pricePerShare)\n        denominator += snapShot.totalSupply\n\n    # weighted price per share\n    weightedPricePerShare: uint256 = 0\n    if numerator != 0:\n        weightedPricePerShare = numerator // denominator\n    else:\n        weightedPricePerShare = _lastPricePerShare\n\n    return weightedPricePerShare\n\n\n# latest snapshot\n\n\n@view\n@external\ndef getLatestSnapshot(_vaultToken: address, _pricePerShare: uint256) -> ls.SingleSnapShot:\n    data: ls.SnapShotData = self.snapShotData[_vaultToken]\n    config: ls.SnapShotPriceConfig = self.snapShotPriceConfig\n    vaultTokenDecimals: uint256 = self.vaultToAsset[_vaultToken].decimals\n    return self._getLatestSnapshot(_vaultToken, _pricePerShare, vaultTokenDecimals, data.lastSnapShot, config)\n\n\n@view\n@internal\ndef _getLatestSnapshot(\n    _vaultToken: address,\n    _pricePerShare: uint256,\n    _vaultTokenDecimals: uint256,\n    _lastSnapShot: ls.SingleSnapShot,\n    _config: ls.SnapShotPriceConfig,\n) -> ls.SingleSnapShot:\n\n    # total supply (adjusted)\n    totalSupply: uint256 = staticcall IERC20(_vaultToken).totalSupply() // (10 ** _vaultTokenDecimals)\n    if totalSupply == 0:\n        totalSupply = 1\n\n    # throttle upside (extra safety check)\n    pricePerShare: uint256 = self._throttleUpside(_pricePerShare, _lastSnapShot.pricePerShare, _config.maxUpsideDeviation)\n\n    return ls.SingleSnapShot(\n        totalSupply = totalSupply,\n        pricePerShare = pricePerShare,\n        lastUpdate = block.timestamp,\n    )\n\n\n@view\n@internal\ndef _throttleUpside(_newValue: uint256, _prevValue: uint256, _maxUpside: uint256) -> uint256:\n    if _maxUpside == 0 or _prevValue == 0 or _newValue == 0:\n        return _newValue\n    maxPricePerShare: uint256 = _prevValue + (_prevValue * _maxUpside // HUNDRED_PERCENT)\n    return min(_newValue, maxPricePerShare)\n\n\n# snapshot price config\n\n\n@external\ndef setSnapShotPriceConfig(_config: ls.SnapShotPriceConfig):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert self._isValidPriceConfig(_config) # dev: invalid config\n    self.snapShotPriceConfig = _config\n    log SnapShotPriceConfigSet(\n        minSnapshotDelay=_config.minSnapshotDelay,\n        maxNumSnapshots=_config.maxNumSnapshots,\n        maxUpsideDeviation=_config.maxUpsideDeviation,\n        staleTime=_config.staleTime\n    )\n\n\n@view\n@external\ndef isValidPriceConfig(_config: ls.SnapShotPriceConfig) -> bool:\n    return self._isValidPriceConfig(_config)\n\n\n@view\n@internal\ndef _isValidPriceConfig(_config: ls.SnapShotPriceConfig) -> bool:\n    if _config.minSnapshotDelay > ONE_WEEK_SECONDS:\n        return False\n    if _config.maxNumSnapshots == 0 or _config.maxNumSnapshots > 25:\n        return False\n    if _config.maxUpsideDeviation > HUNDRED_PERCENT:\n        return False\n    return _config.staleTime < ONE_WEEK_SECONDS",
            "sha256sum": "d695c6d3998cf2ed318a0da6f4f7918abf97661e10eb510ed996d815e65927e0"
          },
          "contracts/legos/yield/Morpho.vy": {
            "content": "#     __   __ ___ _______ ___     ______       ___     _______ _______ _______ \n#    |  | |  |   |       |   |   |      |     |   |   |       |       |       |\n#    |  |_|  |   |    ___|   |   |  _    |    |   |   |    ___|    ___|   _   |\n#    |       |   |   |___|   |   | | |   |    |   |   |   |___|   | __|  | |  |\n#    |_     _|   |    ___|   |___| |_|   |    |   |___|    ___|   ||  |  |_|  |\n#      |   | |   |   |___|       |       |    |       |   |___|   |_| |       |\n#      |___| |___|_______|_______|______|     |_______|_______|_______|_______|\n#                                                                       \n#     \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n#     \u2551  ** Morpho Lego **                      \u2551\n#     \u2551  Integration with Morpho Protocol.      \u2551\n#     \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n#\n#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nimplements: Lego\nimplements: YieldLego\n\nexports: addys.__interface__\nexports: yld.__interface__\n\ninitializes: addys\ninitializes: yld[addys := addys]\n\nfrom interfaces import LegoPartner as Lego\nfrom interfaces import YieldLego as YieldLego\nfrom interfaces import WalletStructs as ws\nfrom interfaces import LegoStructs as ls\n\nimport contracts.modules.Addys as addys\nimport contracts.modules.YieldLegoData as yld\n\nfrom ethereum.ercs import IERC20\nfrom ethereum.ercs import IERC4626\n\ninterface Appraiser:\n    def getUsdValue(_asset: address, _amount: uint256, _missionControl: address = empty(address), _legoBook: address = empty(address), _ledger: address = empty(address)) -> uint256: view\n    def updatePriceAndGetUsdValue(_asset: address, _amount: uint256, _missionControl: address = empty(address), _legoBook: address = empty(address)) -> uint256: nonpayable\n\ninterface Ledger:\n    def setVaultToken(_vaultToken: address, _legoId: uint256, _underlyingAsset: address, _decimals: uint256, _isRebasing: bool): nonpayable\n    def isRegisteredVaultToken(_vaultToken: address) -> bool: view\n\ninterface MorphoRewardsDistributor:\n    def claim(_user: address, _rewardToken: address, _claimable: uint256, _proof: bytes32) -> uint256: nonpayable\n\ninterface MetaMorphoFactory:\n    def isMetaMorpho(_vault: address) -> bool: view\n\ninterface Registry:\n    def getRegId(_addr: address) -> uint256: view\n\nevent MorphoDeposit:\n    sender: indexed(address)\n    asset: indexed(address)\n    vaultToken: indexed(address)\n    assetAmountDeposited: uint256\n    usdValue: uint256\n    vaultTokenAmountReceived: uint256\n    recipient: address\n\nevent MorphoWithdrawal:\n    sender: indexed(address)\n    asset: indexed(address)\n    vaultToken: indexed(address)\n    assetAmountReceived: uint256\n    usdValue: uint256\n    vaultTokenAmountBurned: uint256\n    recipient: address\n\nevent MorphoRewardsAddrSet:\n    addr: address\n\n# rewards contract\nmorphoRewards: public(address)\n\n# morpho\nMORPHO_FACTORY: public(immutable(address))\nMORPHO_FACTORY_LEGACY: public(immutable(address))\n\nMAX_TOKEN_PATH: constant(uint256) = 5\n\n\n@deploy\ndef __init__(\n    _undyHq: address,\n    _morphoFactory: address,\n    _morphoFactoryLegacy: address,\n    _morphoRewardsAddr: address,\n):\n    addys.__init__(_undyHq)\n    yld.__init__(False)\n\n    assert empty(address) not in [_morphoFactory, _morphoFactoryLegacy] # dev: invalid addrs\n    MORPHO_FACTORY = _morphoFactory\n    MORPHO_FACTORY_LEGACY = _morphoFactoryLegacy\n    self.morphoRewards = _morphoRewardsAddr\n\n\n@view\n@external\ndef hasCapability(_action: ws.ActionType) -> bool:\n    return _action in (\n        ws.ActionType.EARN_DEPOSIT | \n        ws.ActionType.EARN_WITHDRAW |\n        ws.ActionType.REWARDS\n    )\n\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    return [MORPHO_FACTORY, MORPHO_FACTORY_LEGACY]\n\n\n@view\n@external\ndef isYieldLego() -> bool:\n    return True\n\n\n@view\n@external\ndef isDexLego() -> bool:\n    return False\n\n\n###################\n# Underlying Data #\n###################\n\n\n# underlying asset\n\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    return self._getUnderlyingAsset(_vaultToken)\n\n\n@view\n@internal\ndef _getUnderlyingAsset(_vaultToken: address) -> address:\n    return yld.vaultToAsset[_vaultToken].underlyingAsset\n\n\n# underlying balances (both true and safe)\n\n\n@view\n@external\ndef getUnderlyingBalances(_vaultToken: address, _vaultTokenBalance: uint256) -> (uint256, uint256):\n    if _vaultTokenBalance == 0:\n        return 0, 0\n\n    trueUnderlying: uint256 = self._getUnderlyingAmount(_vaultToken, _vaultTokenBalance)\n    safeUnderlying: uint256 = self._getUnderlyingAmountSafe(_vaultToken, _vaultTokenBalance)\n    if safeUnderlying == 0:\n        safeUnderlying = trueUnderlying\n\n    return trueUnderlying, min(trueUnderlying, safeUnderlying)\n\n\n# underlying amount (true)\n\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    return self._getUnderlyingAmount(_vaultToken, _vaultTokenAmount)\n\n\n@view\n@internal\ndef _getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    return staticcall IERC4626(_vaultToken).convertToAssets(_vaultTokenAmount)\n\n\n# underlying amount (safe)\n\n\n@view\n@external\ndef getUnderlyingAmountSafe(_vaultToken: address, _vaultTokenBalance: uint256) -> uint256:\n    return self._getUnderlyingAmountSafe(_vaultToken, _vaultTokenBalance)\n\n\n@view\n@internal\ndef _getUnderlyingAmountSafe(_vaultToken: address, _vaultTokenBalance: uint256) -> uint256:\n    vaultInfo: ls.VaultTokenInfo = yld.vaultToAsset[_vaultToken]\n    if vaultInfo.decimals == 0:\n        return 0 # not registered\n\n    # safe underlying amount (using cached weighted average from snapshots)\n    return _vaultTokenBalance * vaultInfo.lastAveragePricePerShare // (10 ** vaultInfo.decimals)\n\n\n# underlying data (combined)\n\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> (address, uint256, uint256):\n    return self._getUnderlyingData(_vaultToken, _vaultTokenAmount, _appraiser)\n\n\n@view\n@internal\ndef _getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address) -> (address, uint256, uint256):\n    asset: address = self._getUnderlyingAsset(_vaultToken)\n    if asset == empty(address):\n        return empty(address), 0, 0 # invalid vault token\n    underlyingAmount: uint256 = self._getUnderlyingAmount(_vaultToken, _vaultTokenAmount)\n    usdValue: uint256 = self._getUsdValue(asset, underlyingAmount, _appraiser)\n    return asset, underlyingAmount, usdValue\n\n\n# usd value\n\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> uint256:\n    return self._getUsdValueOfVaultToken(_vaultToken, _vaultTokenAmount, _appraiser)\n\n\n@view\n@internal\ndef _getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address) -> uint256:\n    return self._getUnderlyingData(_vaultToken, _vaultTokenAmount, _appraiser)[2]\n\n\n@view\n@internal\ndef _getUsdValue(_asset: address, _amount: uint256, _appraiser: address) -> uint256:\n    appraiser: address = _appraiser\n    if _appraiser == empty(address):\n        appraiser = addys._getAppraiserAddr()\n    return staticcall Appraiser(appraiser).getUsdValue(_asset, _amount)\n\n\n###############\n# Other Utils #\n###############\n\n\n# basics\n\n\n@view\n@external\ndef isRebasing() -> bool:\n    return self._isRebasing()\n\n\n@view\n@internal\ndef _isRebasing() -> bool:\n    return False\n\n\n# price per share\n\n\n@view\n@external\ndef getPricePerShare(_vaultToken: address, _decimals: uint256 = 0) -> uint256:\n    decimals: uint256 = _decimals\n    if decimals == 0:\n        decimals = yld.vaultToAsset[_vaultToken].decimals\n    if decimals == 0:\n        return 0 # not registered\n    return self._getPricePerShare(_vaultToken, decimals)\n\n\n@view\n@internal\ndef _getPricePerShare(_vaultToken: address, _decimals: uint256) -> uint256:\n    return staticcall IERC4626(_vaultToken).convertToAssets(10 ** _decimals)\n\n\n# vault token amount\n\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    return staticcall IERC4626(_vaultToken).convertToShares(_assetAmount)\n\n\n# extras\n\n\n@view\n@external\ndef isEligibleVaultForTrialFunds(_vaultToken: address, _underlyingAsset: address) -> bool:\n    return False\n\n\n@view\n@external\ndef isEligibleForYieldBonus(_asset: address) -> bool:\n    return False\n\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    return staticcall IERC4626(_vaultToken).totalAssets()\n\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    # TODO: implement\n    return 0\n\n\n################\n# Registration #\n################\n\n\n# can vault be registered\n\n\n@view\n@external\ndef canRegisterVaultToken(_asset: address, _vaultToken: address) -> bool:\n    return self._canRegisterVaultToken(_asset, _vaultToken)\n\n\n@view\n@internal\ndef _canRegisterVaultToken(_asset: address, _vaultToken: address) -> bool:\n    if empty(address) in [_asset, _vaultToken]:\n        return False\n    if staticcall IERC4626(_vaultToken).asset() != _asset:\n        return False\n    return staticcall MetaMorphoFactory(MORPHO_FACTORY).isMetaMorpho(_vaultToken) or staticcall MetaMorphoFactory(MORPHO_FACTORY_LEGACY).isMetaMorpho(_vaultToken)\n\n\n# register vault token locally\n\n\n@external\ndef registerVaultTokenLocally(_asset: address, _vaultAddr: address) -> ls.VaultTokenInfo:\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert self._canRegisterVaultToken(_asset, _vaultAddr) # dev: cannot register vault token\n    assert not yld._isAssetOpportunity(_asset, _vaultAddr) # dev: already registered\n    vaultInfo: ls.VaultTokenInfo = self._registerVaultTokenLocally(_asset, _vaultAddr)\n    self._registerVaultTokenGlobally(_asset, _vaultAddr, vaultInfo.decimals, addys._getLedgerAddr(), addys._getLegoBookAddr())\n    return vaultInfo\n\n\n@internal\ndef _registerVaultTokenLocally(_asset: address, _vaultAddr: address) -> ls.VaultTokenInfo:\n    assert extcall IERC20(_asset).approve(_vaultAddr, max_value(uint256), default_return_value=True) # dev: max approval failed\n    vaultInfo: ls.VaultTokenInfo = yld._addAssetOpportunity(_asset, _vaultAddr)\n    assert vaultInfo.decimals != 0 # dev: invalid vault token\n    return vaultInfo\n\n\n# remove vault token locally\n\n\n@external\ndef deregisterVaultTokenLocally(_asset: address, _vaultAddr: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert yld._isAssetOpportunity(_asset, _vaultAddr) # dev: already registered\n    self._deregisterVaultTokenLocally(_asset, _vaultAddr)\n\n\n@internal\ndef _deregisterVaultTokenLocally(_asset: address, _vaultAddr: address):\n    assert extcall IERC20(_asset).approve(_vaultAddr, 0, default_return_value=True) # dev: max approval failed\n    yld._removeAssetOpportunity(_asset, _vaultAddr)\n\n\n# ledger registration\n\n\n@internal\ndef _registerVaultTokenGlobally(_underlyingAsset: address, _vaultToken: address, _decimals: uint256, _ledger: address, _legoBook: address):\n    if not staticcall Ledger(_ledger).isRegisteredVaultToken(_vaultToken):\n        legoId: uint256 = staticcall Registry(_legoBook).getRegId(self)\n        extcall Ledger(_ledger).setVaultToken(_vaultToken, legoId, _underlyingAsset, _decimals, self._isRebasing())\n\n\n#################\n# Yield Actions #\n#################\n\n\n# add price snapshot\n\n\n@external\ndef addPriceSnapshot(_vaultToken: address) -> bool:\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    vaultInfo: ls.VaultTokenInfo = yld.vaultToAsset[_vaultToken]\n    assert vaultInfo.decimals != 0 # dev: not registered\n    pricePerShare: uint256 = self._getPricePerShare(_vaultToken, vaultInfo.decimals)\n    return yld._addPriceSnapshot(_vaultToken, pricePerShare, vaultInfo.decimals)\n\n\n# deposit\n\n\n@external\ndef depositForYield(\n    _asset: address,\n    _amount: uint256,\n    _vaultAddr: address,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, address, uint256, uint256):\n    assert not yld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = yld._getMiniAddys(_miniAddys)\n    vaultInfo: ls.VaultTokenInfo = self._getVaultInfoOnDeposit(_asset, _vaultAddr, miniAddys.ledger, miniAddys.legoBook)\n\n    # pre balances\n    preLegoBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n\n    # transfer deposit asset to this contract\n    depositAmount: uint256 = min(_amount, staticcall IERC20(_asset).balanceOf(msg.sender))\n    assert depositAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_asset).transferFrom(msg.sender, self, depositAmount, default_return_value=True) # dev: transfer failed\n\n    # deposit assets into lego partner\n    vaultTokenAmountReceived: uint256 = extcall IERC4626(_vaultAddr).deposit(depositAmount, _recipient)\n    assert vaultTokenAmountReceived != 0 # dev: no vault tokens received\n\n    # refund if full deposit didn't get through\n    currentLegoBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    refundAssetAmount: uint256 = 0\n    if currentLegoBalance > preLegoBalance:\n        refundAssetAmount = currentLegoBalance - preLegoBalance\n        assert extcall IERC20(_asset).transfer(msg.sender, refundAssetAmount, default_return_value=True) # dev: transfer failed\n        depositAmount -= refundAssetAmount\n\n    usdValue: uint256 = extcall Appraiser(miniAddys.appraiser).updatePriceAndGetUsdValue(_asset, depositAmount, miniAddys.missionControl, miniAddys.legoBook)\n    log MorphoDeposit(\n        sender = msg.sender,\n        asset = _asset,\n        vaultToken = _vaultAddr,\n        assetAmountDeposited = depositAmount,\n        usdValue = usdValue,\n        vaultTokenAmountReceived = vaultTokenAmountReceived,\n        recipient = _recipient,\n    )\n\n    # add price snapshot\n    pricePerShare: uint256 = self._getPricePerShare(_vaultAddr, vaultInfo.decimals)\n    yld._addPriceSnapshot(_vaultAddr, pricePerShare, vaultInfo.decimals)\n\n    return depositAmount, _vaultAddr, vaultTokenAmountReceived, usdValue\n\n\n# vault info on deposit\n\n\n@internal\ndef _getVaultInfoOnDeposit(_asset: address, _vaultAddr: address, _ledger: address, _legoBook: address) -> ls.VaultTokenInfo:\n    vaultInfo: ls.VaultTokenInfo = yld.vaultToAsset[_vaultAddr]\n    if vaultInfo.decimals == 0:\n        assert self._canRegisterVaultToken(_asset, _vaultAddr) # dev: cannot register vault token\n        vaultInfo = self._registerVaultTokenLocally(_asset, _vaultAddr)\n        self._registerVaultTokenGlobally(_asset, _vaultAddr, vaultInfo.decimals, _ledger, _legoBook)\n    else:\n        assert vaultInfo.underlyingAsset == _asset # dev: asset mismatch\n    return vaultInfo\n\n\n# withdraw\n\n\n@external\ndef withdrawFromYield(\n    _vaultToken: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, address, uint256, uint256):\n    assert not yld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = yld._getMiniAddys(_miniAddys)\n    vaultInfo: ls.VaultTokenInfo = self._getVaultInfoOnWithdrawal(_vaultToken, miniAddys.ledger, miniAddys.legoBook)\n\n    # pre balances\n    preLegoVaultBalance: uint256 = staticcall IERC20(_vaultToken).balanceOf(self)\n\n    # transfer vaults tokens to this contract\n    vaultTokenAmount: uint256 = min(_amount, staticcall IERC20(_vaultToken).balanceOf(msg.sender))\n    assert vaultTokenAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_vaultToken).transferFrom(msg.sender, self, vaultTokenAmount, default_return_value=True) # dev: transfer failed\n\n    # withdraw assets from lego partner\n    assetAmountReceived: uint256 = extcall IERC4626(_vaultToken).redeem(vaultTokenAmount, _recipient, self)\n    assert assetAmountReceived != 0 # dev: no asset amount received\n\n    # refund if full withdrawal didn't happen\n    currentLegoVaultBalance: uint256 = staticcall IERC20(_vaultToken).balanceOf(self)\n    refundVaultTokenAmount: uint256 = 0\n    if currentLegoVaultBalance > preLegoVaultBalance:\n        refundVaultTokenAmount = currentLegoVaultBalance - preLegoVaultBalance\n        assert extcall IERC20(_vaultToken).transfer(msg.sender, refundVaultTokenAmount, default_return_value=True) # dev: transfer failed\n        vaultTokenAmount -= refundVaultTokenAmount\n\n    usdValue: uint256 = extcall Appraiser(miniAddys.appraiser).updatePriceAndGetUsdValue(vaultInfo.underlyingAsset, assetAmountReceived, miniAddys.missionControl, miniAddys.legoBook)\n    log MorphoWithdrawal(\n        sender = msg.sender,\n        asset = vaultInfo.underlyingAsset,\n        vaultToken = _vaultToken,\n        assetAmountReceived = assetAmountReceived,\n        usdValue = usdValue,\n        vaultTokenAmountBurned = vaultTokenAmount,\n        recipient = _recipient,\n    )\n\n    # add price snapshot\n    pricePerShare: uint256 = self._getPricePerShare(_vaultToken, vaultInfo.decimals)\n    yld._addPriceSnapshot(_vaultToken, pricePerShare, vaultInfo.decimals)\n\n    return vaultTokenAmount, vaultInfo.underlyingAsset, assetAmountReceived, usdValue\n\n\n# vault info on withdrawal\n\n\n@internal\ndef _getVaultInfoOnWithdrawal(_vaultAddr: address, _ledger: address, _legoBook: address) -> ls.VaultTokenInfo:\n    vaultInfo: ls.VaultTokenInfo = yld.vaultToAsset[_vaultAddr]\n    if vaultInfo.decimals == 0:\n        asset: address = staticcall IERC4626(_vaultAddr).asset()\n        assert self._canRegisterVaultToken(asset, _vaultAddr) # dev: cannot register vault token\n        vaultInfo = self._registerVaultTokenLocally(asset, _vaultAddr)\n        self._registerVaultTokenGlobally(asset, _vaultAddr, vaultInfo.decimals, _ledger, _legoBook)\n    return vaultInfo\n\n\n#################\n# Claim Rewards #\n#################\n\n\n@external\ndef claimRewards(\n    _user: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _extraData: bytes32,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    assert not yld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = yld._getMiniAddys(_miniAddys)\n\n    assert msg.sender == _user # dev: recipient must be caller\n    morphoRewards: address = self.morphoRewards\n    assert morphoRewards != empty(address) # dev: no morpho rewards addr set\n\n    rewardAmount: uint256 = extcall MorphoRewardsDistributor(morphoRewards).claim(_user, _rewardToken, _rewardAmount, _extraData)\n    usdValue: uint256 = extcall Appraiser(miniAddys.appraiser).updatePriceAndGetUsdValue(_rewardToken, rewardAmount, miniAddys.missionControl, miniAddys.legoBook)\n    return rewardAmount, usdValue\n\n\n@view\n@external\ndef hasClaimableRewards(_user: address) -> bool:\n    # as far as we can tell, this must be done offchain\n    return False\n\n\n# set rewards addr\n\n\n@external\ndef setMorphoRewardsAddr(_addr: address) -> bool:\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert _addr != empty(address) # dev: invalid addr\n    self.morphoRewards = _addr\n    log MorphoRewardsAddrSet(addr=_addr)\n    return True\n\n\n#########\n# Other #\n#########\n\n\n@view\n@external\ndef getAccessForLego(_user: address, _action: ws.ActionType) -> (address, String[64], uint256):\n    return empty(address), empty(String[64]), 0\n\n\n@external\ndef swapTokens(\n    _amountIn: uint256,\n    _minAmountOut: uint256,\n    _tokenPath: DynArray[address, MAX_TOKEN_PATH],\n    _poolPath: DynArray[address, MAX_TOKEN_PATH - 1],\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256):\n    return 0, 0, 0\n\n\n@external\ndef mintOrRedeemAsset(\n    _tokenIn: address,\n    _tokenOut: address,\n    _tokenInAmount: uint256,\n    _minAmountOut: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, bool, uint256):\n    return 0, 0, False, 0\n\n\n@external\ndef confirmMintOrRedeemAsset(\n    _tokenIn: address,\n    _tokenOut: address,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef addCollateral(\n    _asset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef removeCollateral(\n    _asset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef borrow(\n    _borrowAsset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef repayDebt(\n    _paymentAsset: address,\n    _paymentAmount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef addLiquidity(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _amountA: uint256,\n    _amountB: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _minLpAmount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (address, uint256, uint256, uint256, uint256):\n    return empty(address), 0, 0, 0, 0\n\n\n@external\ndef removeLiquidity(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpToken: address,\n    _lpAmount: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, uint256):\n    return 0, 0, 0, 0\n\n\n@external\ndef addLiquidityConcentrated(\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _tickLower: int24,\n    _tickUpper: int24,\n    _amountA: uint256,\n    _amountB: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, uint256, uint256):\n    return 0, 0, 0, 0, 0\n\n\n@external\ndef removeLiquidityConcentrated(\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _liqToRemove: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, bool, uint256):\n    return 0, 0, 0, False, 0",
            "sha256sum": "f7299046d3a422c938adfc0a07c006102c1b94ddd829a35093a0eef78a5cfefd"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/legos/yield/Morpho.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.3+commit.bff19ea2",
        "integrity": "1d50b707a17481231ead72733ba98a4820fd80f7da46ffc1bd72976b13f4dd70"
      },
      "args": "00000000000000000000000044cf3c4f000dfd76a35d03298049d37be688d6f9000000000000000000000000ff62a7c278c62ed665133147129245053bbf5918000000000000000000000000a9c3d3a366466fa809d1ae982fb2c46e5fc41101000000000000000000000000330eefa8a787552dc5cad3c3ca644844b1e61ddb",
      "file": "contracts/legos/yield/Morpho.vy"
    },
    "AeroClassic": {
      "address": "0xaeA97242dF5C40dd81BB36815D2cADd95270f2b4",
      "abi": [
        {
          "name": "AerodromeSwap",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenIn",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenOut",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amountIn",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "amountOut",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "numTokens",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AerodromeLiquidityAdded",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenA",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenB",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amountA",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "amountB",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "lpAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AerodromeLiquidityRemoved",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": false
            },
            {
              "name": "pool",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenA",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenB",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amountA",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "amountB",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "lpToken",
              "type": "address",
              "indexed": false
            },
            {
              "name": "lpAmountBurned",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LegoPauseModified",
          "inputs": [
            {
              "name": "isPaused",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LegoFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "balance",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddys",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "undyToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "hatchery",
                  "type": "address"
                },
                {
                  "name": "lootDistributor",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                },
                {
                  "name": "walletBackpack",
                  "type": "address"
                },
                {
                  "name": "billing",
                  "type": "address"
                },
                {
                  "name": "vaultRegistry",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUndyHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pause",
          "inputs": [
            {
              "name": "_shouldPause",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFundsMany",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_assets",
              "type": "address[]"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "legoId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isPaused",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasCapability",
          "inputs": [
            {
              "name": "_action",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRegistries",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isYieldLego",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isDexLego",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_tokenPath",
              "type": "address[]"
            },
            {
              "name": "_poolPath",
              "type": "address[]"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_tokenPath",
              "type": "address[]"
            },
            {
              "name": "_poolPath",
              "type": "address[]"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLpToken",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPoolForLpToken",
          "inputs": [
            {
              "name": "_lpToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getCoreRouterPool",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getDeepestLiqPool",
          "inputs": [
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "fee",
                  "type": "uint256"
                },
                {
                  "name": "liquidity",
                  "type": "uint256"
                },
                {
                  "name": "numCoins",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getBestSwapAmountOut",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountIn",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getSwapAmountOut",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountIn",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getBestSwapAmountIn",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountOut",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getSwapAmountIn",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountOut",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddLiqAmountsIn",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_availAmountA",
              "type": "uint256"
            },
            {
              "name": "_availAmountB",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRemoveLiqAmountsOut",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPrice",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_decimals",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPriceUnsafe",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_targetToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPriceUnsafe",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_targetToken",
              "type": "address"
            },
            {
              "name": "_appraiser",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositForYield",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositForYield",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawFromYield",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawFromYield",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_tokenInAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_tokenInAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmMintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmMintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_borrowAsset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_borrowAsset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_paymentAsset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_paymentAsset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAccessForLego",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_action",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "string"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "AERODROME_FACTORY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "AERODROME_ROUTER",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "coreRouterPool",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_undyHq",
              "type": "address"
            },
            {
              "name": "_aerodromeFactory",
              "type": "address"
            },
            {
              "name": "_aerodromeRouter",
              "type": "address"
            },
            {
              "name": "_coreRouterPool",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "interfaces/WalletStructs.vyi": {
            "content": "# @version 0.4.3\n\nflag ActionType:\n    TRANSFER\n    EARN_DEPOSIT\n    EARN_WITHDRAW\n    EARN_REBALANCE\n    SWAP\n    MINT_REDEEM\n    CONFIRM_MINT_REDEEM\n    ADD_COLLATERAL\n    REMOVE_COLLATERAL\n    BORROW\n    REPAY_DEBT\n    REWARDS\n    ETH_TO_WETH\n    WETH_TO_ETH\n    ADD_LIQ\n    REMOVE_LIQ\n    ADD_LIQ_CONC\n    REMOVE_LIQ_CONC\n    PAY_CHEQUE\n\nstruct WalletAssetData:\n    assetBalance: uint256\n    usdValue: uint256\n    isYieldAsset: bool\n    lastPricePerShare: uint256\n\nstruct ActionData:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    billing: address\n    wallet: address\n    walletConfig: address\n    walletOwner: address\n    inEjectMode: bool\n    isFrozen: bool\n    lastTotalUsdValue: uint256\n    signer: address\n    isManager: bool\n    legoId: uint256\n    legoAddr: address\n    eth: address\n    weth: address\n\nstruct MiniAddys:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    appraiser: address",
            "sha256sum": "9a4b4f59b3a62043e51b425a665064aae419a3c0bd0514b6b29a9441ae364bb9"
          },
          "interfaces/LegoPartner.vyi": {
            "content": "# @version 0.4.3\n\nfrom interfaces import WalletStructs as ws\n\nMAX_TOKEN_PATH: constant(uint256) = 5\nMAX_RECOVER_ASSETS: constant(uint256) = 20\n\n@external\ndef addLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _tickLower: int24, _tickUpper: int24, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef addLiquidity(_pool: address, _tokenA: address, _tokenB: address, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _minLpAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (address, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef removeLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _liqToRemove: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef removeLiquidity(_pool: address, _tokenA: address, _tokenB: address, _lpToken: address, _lpAmount: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef mintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _tokenInAmount: uint256, _minAmountOut: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef swapTokens(_amountIn: uint256, _minAmountOut: uint256, _tokenPath: DynArray[address, MAX_TOKEN_PATH], _poolPath: DynArray[address, MAX_TOKEN_PATH - 1], _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256):\n    ...\n\n@external\ndef depositForYield(_asset: address, _amount: uint256, _vaultAddr: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef withdrawFromYield(_vaultToken: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef confirmMintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef borrow(_borrowAsset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef repayDebt(_paymentAsset: address, _paymentAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef claimRewards(_user: address, _rewardToken: address, _rewardAmount: uint256, _extraData: bytes32, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef removeCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef addCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@view\n@external\ndef getAccessForLego(_user: address, _action: ws.ActionType) -> (address, String[64], uint256):\n    ...\n\n@view\n@external\ndef hasCapability(_action: ws.ActionType) -> bool:\n    ...\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    ...\n\n@view\n@external\ndef isYieldLego() -> bool:\n    ...\n\n@view\n@external\ndef isDexLego() -> bool:\n    ...\n\n\n# common\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "81db71fe4440a3b4b563134c9b5caf1d5705772a5f291fe874c9b5fb3cfb1623"
          },
          "interfaces/DexLego.vyi": {
            "content": "# @version 0.4.3\n\n# used in smart contracts\n\n\n@view\n@external\ndef getLpToken(_pool: address) -> address:\n    ...\n\n\n# helper functions for server\n\n\n@view\n@external\ndef getPoolForLpToken(_lpToken: address) -> address:\n    ...\n\n\n@view\n@external\ndef getSwapAmountOut(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n) -> uint256:\n    ...\n\n\n@view\n@external\ndef getSwapAmountIn(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountOut: uint256,\n) -> uint256:\n    ...\n\n\n@view\n@external\ndef getAddLiqAmountsIn(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _availAmountA: uint256,\n    _availAmountB: uint256,\n) -> (uint256, uint256, uint256):\n    ...\n\n\n@view\n@external\ndef getRemoveLiqAmountsOut(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpAmount: uint256,\n) -> (uint256, uint256):\n    ...\n\n\n@view\n@external\ndef getPriceUnsafe(_pool: address, _targetToken: address, _appraiser: address = empty(address)) -> uint256:\n    ...\n\n\n@view\n@external\ndef getBestSwapAmountOut(_tokenIn: address, _tokenOut: address, _amountIn: uint256) -> (address, uint256):\n    ...\n\n\n@view\n@external\ndef getBestSwapAmountIn(_tokenIn: address, _tokenOut: address, _amountOut: uint256) -> (address, uint256):\n    ...\n\n\n@view\n@external\ndef getCoreRouterPool() -> address:\n    ...\n\n\n@view\n@external\ndef getPrice(_asset: address, _decimals: uint256) -> uint256:\n    ...\n",
            "sha256sum": "6248ad46926f00481cb3469bfc7af8fe36669c2ca0dd98e9a0befdda0fc43fd7"
          },
          "contracts/modules/Addys.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\ninterface UndyHq:\n    def isValidAddr(_addr: address) -> bool: view\n    def getAddr(_regId: uint256) -> address: view\n    def undyToken() -> address: view\n\ninterface Switchboard:\n    def isSwitchboardAddr(_addr: address) -> bool: view\n\ninterface LegoBook:\n    def isLegoAddr(_addr: address) -> bool: view\n\nstruct Addys:\n    hq: address\n    undyToken: address\n    ledger: address\n    missionControl: address\n    legoBook: address\n    switchboard: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    walletBackpack: address\n    billing: address\n    vaultRegistry: address\n\n# hq\nUNDY_HQ_FOR_ADDYS: immutable(address)\n\n# core addys\nLEDGER_ID: constant(uint256) = 1\nMISSION_CONTROL_ID: constant(uint256) = 2\nLEGO_BOOK_ID: constant(uint256) = 3\nSWITCHBOARD_ID: constant(uint256) = 4\nHATCHERY_ID: constant(uint256) = 5\nLOOT_DISTRIBUTOR_ID: constant(uint256) = 6\nAPPRAISER_ID: constant(uint256) = 7\nWALLET_BACKPACK_ID: constant(uint256) = 8\nBILLING_ID: constant(uint256) = 9\nVAULT_REGISTRY_ID: constant(uint256) = 10\n\n\n@deploy\ndef __init__(_undyHq: address):\n    assert _undyHq != empty(address) # dev: invalid undy hq\n    UNDY_HQ_FOR_ADDYS = _undyHq\n\n\n########\n# Core #\n########\n\n\n@view\n@external\ndef getAddys() -> Addys:\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _getAddys(_addys: Addys = empty(Addys)) -> Addys:\n    if _addys.hq != empty(address):\n        return _addys\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _generateAddys() -> Addys:\n    hq: address = UNDY_HQ_FOR_ADDYS\n    return Addys(\n        hq = hq,\n        undyToken = staticcall UndyHq(hq).undyToken(),\n        ledger = staticcall UndyHq(hq).getAddr(LEDGER_ID),\n        missionControl = staticcall UndyHq(hq).getAddr(MISSION_CONTROL_ID),\n        legoBook = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID),\n        switchboard = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID),\n        hatchery = staticcall UndyHq(hq).getAddr(HATCHERY_ID),\n        lootDistributor = staticcall UndyHq(hq).getAddr(LOOT_DISTRIBUTOR_ID),\n        appraiser = staticcall UndyHq(hq).getAddr(APPRAISER_ID),\n        walletBackpack = staticcall UndyHq(hq).getAddr(WALLET_BACKPACK_ID),\n        billing = staticcall UndyHq(hq).getAddr(BILLING_ID),\n        vaultRegistry = staticcall UndyHq(hq).getAddr(VAULT_REGISTRY_ID),\n    )\n\n\n##########\n# Tokens #\n##########\n\n\n@view\n@internal\ndef _getUndyToken() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).undyToken()\n\n\n###########\n# Helpers #\n###########\n\n\n# undy hq\n\n\n@view\n@external\ndef getUndyHq() -> address:\n    return self._getUndyHq()\n\n\n@view\n@internal\ndef _getUndyHq() -> address:\n    return UNDY_HQ_FOR_ADDYS\n\n\n# utils\n\n\n@view\n@internal\ndef _isValidUndyAddr(_addr: address, _hq: address = empty(address)) -> bool:\n    hq: address = _hq\n    if _hq == empty(address):\n        hq = UNDY_HQ_FOR_ADDYS\n    \n    # core departments\n    if staticcall UndyHq(hq).isValidAddr(_addr):\n        return True\n\n    # lego book\n    legoBook: address = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID)\n    if legoBook != empty(address) and staticcall LegoBook(legoBook).isLegoAddr(_addr):\n        return True\n\n    # switchboard config\n    switchboard: address = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID)\n    if switchboard != empty(address) and staticcall Switchboard(switchboard).isSwitchboardAddr(_addr):\n        return True\n\n    return False\n\n\n@view\n@internal\ndef _isSwitchboardAddr(_addr: address) -> bool:\n    switchboard: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n    if switchboard == empty(address):\n        return False\n    return staticcall Switchboard(switchboard).isSwitchboardAddr(_addr)\n\n\n@view\n@internal\ndef _isLegoBookAddr(_addr: address) -> bool:\n    legoBook: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n    if legoBook == empty(address):\n        return False\n    return staticcall LegoBook(legoBook).isLegoAddr(_addr)\n\n\n###############\n# Departments #\n###############\n\n\n# ledger\n\n\n@view\n@internal\ndef _getLedgerId() -> uint256:\n    return LEDGER_ID\n\n\n@view\n@internal\ndef _getLedgerAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEDGER_ID)\n\n\n# mission control\n\n\n@view\n@internal\ndef _getMissionControlId() -> uint256:\n    return MISSION_CONTROL_ID\n\n\n@view\n@internal\ndef _getMissionControlAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(MISSION_CONTROL_ID)\n\n\n# lego book\n\n\n@view\n@internal\ndef _getLegoBookId() -> uint256:\n    return LEGO_BOOK_ID\n\n\n@view\n@internal\ndef _getLegoBookAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n\n\n# switchboard\n\n\n@view\n@internal\ndef _getSwitchboardId() -> uint256:\n    return SWITCHBOARD_ID\n\n\n@view\n@internal\ndef _getSwitchboardAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n\n\n# hatchery\n\n\n@view\n@internal\ndef _getHatcheryId() -> uint256:\n    return HATCHERY_ID\n\n\n@view\n@internal\ndef _getHatcheryAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(HATCHERY_ID)\n\n\n# loot distributor\n\n\n@view\n@internal\ndef _getLootDistributorId() -> uint256:\n    return LOOT_DISTRIBUTOR_ID\n\n\n@view\n@internal\ndef _getLootDistributorAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LOOT_DISTRIBUTOR_ID)\n\n\n# appraiser\n\n\n@view\n@internal\ndef _getAppraiserId() -> uint256:\n    return APPRAISER_ID\n\n\n@view\n@internal\ndef _getAppraiserAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(APPRAISER_ID)\n\n\n# wallet backpack\n\n\n@view\n@internal\ndef _getWalletBackpackId() -> uint256:\n    return WALLET_BACKPACK_ID\n\n\n@view\n@internal\ndef _getWalletBackpackAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(WALLET_BACKPACK_ID)\n\n\n# billing\n\n\n@view\n@internal\ndef _getBillingId() -> uint256:\n    return BILLING_ID\n\n\n@view\n@internal\ndef _getBillingAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(BILLING_ID)\n\n\n# vault registry\n\n\n@view\n@internal\ndef _getVaultRegistryId() -> uint256:\n    return VAULT_REGISTRY_ID\n\n\n@view\n@internal\ndef _getVaultRegistryAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(VAULT_REGISTRY_ID)",
            "sha256sum": "4df6b72db9bb417d1af81660175be1450cfb7b3575f3d17a5b8a130bff87b781"
          },
          "contracts/modules/DexLegoData.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nuses: addys\n\nimport contracts.modules.Addys as addys\n\nfrom interfaces import WalletStructs as ws\nfrom ethereum.ercs import IERC20\n\nevent LegoPauseModified:\n    isPaused: bool\n\nevent LegoFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    balance: uint256\n\n# config\nlegoId: public(uint256)\nisPaused: public(bool)\n\nMAX_RECOVER_ASSETS: constant(uint256) = 20\n\n\n@deploy\ndef __init__(_shouldPause: bool):\n    self.isPaused = _shouldPause\n\n\n###########\n# General #\n###########\n\n\n# fill mini addys\n\n\n@view\n@internal\ndef _getMiniAddys(_miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> ws.MiniAddys:\n    if _miniAddys.ledger != empty(address):\n        return _miniAddys\n    return ws.MiniAddys(\n        ledger = addys._getLedgerAddr(),\n        missionControl = addys._getMissionControlAddr(),\n        legoBook = addys._getLegoBookAddr(),\n        appraiser = addys._getAppraiserAddr(),\n    )\n\n\n# activate\n\n\n@external\ndef pause(_shouldPause: bool):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert _shouldPause != self.isPaused # dev: no change\n    self.isPaused = _shouldPause\n    log LegoPauseModified(isPaused=_shouldPause)\n\n\n# recover funds\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    self._recoverFunds(_recipient, _asset)\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, MAX_RECOVER_ASSETS]):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    for a: address in _assets:\n        self._recoverFunds(_recipient, a)\n\n\n@internal\ndef _recoverFunds(_recipient: address, _asset: address):\n    assert empty(address) not in [_recipient, _asset] # dev: invalid recipient or asset\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    assert balance != 0 # dev: nothing to recover\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log LegoFundsRecovered(asset=_asset, recipient=_recipient, balance=balance)",
            "sha256sum": "75b15af2475ab409d4b5fd057509d14c20564ebd7fcb0850e3b61397d8e3af48"
          },
          "contracts/legos/dexes/AeroClassic.vy": {
            "content": "#     _____  _____  __  __    ____   _____  _____  _____ \n#    |  _  \\/   __\\/  \\/  \\  /  _/  /   __\\/   __\\/  _  \\\n#    |  |  ||   __|>-    -<  |  |---|   __||  |_ ||  |  |\n#    |_____/\\_____/\\__/\\__/  \\_____/\\_____/\\_____/\\_____/\n#                                                                       \n#     \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n#     \u2551  ** Aero Classic Lego **                \u2551\n#     \u2551  Integration with Aerodrome Classic.    \u2551\n#     \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n#\n#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nimplements: Lego\nimplements: DexLego\n\nexports: addys.__interface__\nexports: dld.__interface__\n\ninitializes: addys\ninitializes: dld[addys := addys]\n\nfrom interfaces import LegoPartner as Lego\nfrom interfaces import DexLego as DexLego\nfrom interfaces import WalletStructs as ws\n\nimport contracts.modules.Addys as addys\nimport contracts.modules.DexLegoData as dld\n\nfrom ethereum.ercs import IERC20\nfrom ethereum.ercs import IERC20Detailed\n\ninterface AeroRouter:\n    def addLiquidity(_tokenA: address, _tokenB: address, _isStable: bool, _amountADesired: uint256, _amountBDesired: uint256, _amountAMin: uint256, _amountBMin: uint256, _recipient: address, _deadline: uint256) -> (uint256, uint256, uint256): nonpayable\n    def removeLiquidity(_tokenA: address, _tokenB: address, _isStable: bool, _lpAmount: uint256, _amountAMin: uint256, _amountBMin: uint256, _recipient: address, _deadline: uint256) -> (uint256, uint256): nonpayable\n    def quoteAddLiquidity(_tokenA: address, _tokenB: address, _isStable: bool, _factory: address, _amountADesired: uint256, _amountBDesired: uint256) -> (uint256, uint256, uint256): view\n    def swapExactTokensForTokens(_amountIn: uint256, _amountOutMin: uint256, _path: DynArray[Route, 10], _to: address, _deadline: uint256) -> DynArray[uint256, 10]: nonpayable\n    def quoteRemoveLiquidity(_tokenA: address, _tokenB: address, _isStable: bool, _factory: address, _liquidity: uint256) -> (uint256, uint256): view\n\ninterface AeroClassicPool:\n    def swap(_amount0Out: uint256, _amount1Out: uint256, _recipient: address, _data: Bytes[256]): nonpayable\n    def getAmountOut(_amountIn: uint256, _tokenIn: address) -> uint256: view\n    def getReserves() -> (uint256, uint256, uint256): view\n    def tokens() -> (address, address): view\n    def stable() -> bool: view\n\ninterface Appraiser:\n    def getNormalAssetPrice(_asset: address, _missionControl: address = empty(address), _legoBook: address = empty(address), _ledger: address = empty(address)) -> uint256: view\n    def updatePriceAndGetUsdValue(_asset: address, _amount: uint256, _missionControl: address = empty(address), _legoBook: address = empty(address)) -> uint256: nonpayable\n\ninterface AeroFactory:\n    def getPool(_tokenA: address, _tokenB: address, _isStable: bool) -> address: view\n    def getFee(_pool: address, _isStable: bool) -> uint256: view\n\nstruct BestPool:\n    pool: address\n    fee: uint256\n    liquidity: uint256\n    numCoins: uint256\n\nstruct Route:\n    from_: address\n    to: address \n    stable: bool\n    factory: address\n\nevent AerodromeSwap:\n    sender: indexed(address)\n    tokenIn: indexed(address)\n    tokenOut: indexed(address)\n    amountIn: uint256\n    amountOut: uint256\n    usdValue: uint256\n    numTokens: uint256\n    recipient: address\n\nevent AerodromeLiquidityAdded:\n    sender: indexed(address)\n    tokenA: indexed(address)\n    tokenB: indexed(address)\n    amountA: uint256\n    amountB: uint256\n    lpAmountReceived: uint256\n    usdValue: uint256\n    recipient: address\n\nevent AerodromeLiquidityRemoved:\n    sender: address\n    pool: indexed(address)\n    tokenA: indexed(address)\n    tokenB: indexed(address)\n    amountA: uint256\n    amountB: uint256\n    lpToken: address\n    lpAmountBurned: uint256\n    usdValue: uint256\n    recipient: address\n\n# aero\nAERODROME_FACTORY: public(immutable(address))\nAERODROME_ROUTER: public(immutable(address))\ncoreRouterPool: public(address)\n\nMAX_TOKEN_PATH: constant(uint256) = 5\nEIGHTEEN_DECIMALS: constant(uint256) = 10 ** 18\n\n\n@deploy\ndef __init__(\n    _undyHq: address,\n    _aerodromeFactory: address,\n    _aerodromeRouter: address,\n    _coreRouterPool: address,\n):\n    addys.__init__(_undyHq)\n    dld.__init__(False)\n\n    assert empty(address) not in [_aerodromeFactory, _aerodromeRouter, _coreRouterPool] # dev: invalid addrs\n    AERODROME_FACTORY = _aerodromeFactory\n    AERODROME_ROUTER = _aerodromeRouter\n    self.coreRouterPool = _coreRouterPool\n\n\n@view\n@external\ndef hasCapability(_action: ws.ActionType) -> bool:\n    return _action in (\n        ws.ActionType.SWAP |\n        ws.ActionType.ADD_LIQ | \n        ws.ActionType.REMOVE_LIQ\n    )\n\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    return [AERODROME_FACTORY, AERODROME_ROUTER]\n\n\n@view\n@external\ndef isYieldLego() -> bool:\n    return False\n\n\n@view\n@external\ndef isDexLego() -> bool:\n    return True\n\n\n#########\n# Swaps #\n#########\n\n\n@external\ndef swapTokens(\n    _amountIn: uint256,\n    _minAmountOut: uint256,\n    _tokenPath: DynArray[address, MAX_TOKEN_PATH],\n    _poolPath: DynArray[address, MAX_TOKEN_PATH - 1],\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256):\n    assert not dld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = dld._getMiniAddys(_miniAddys)\n\n    # validate inputs\n    numTokens: uint256 = len(_tokenPath)\n    numPools: uint256 = len(_poolPath)\n    assert numTokens >= 2 # dev: invalid path\n    assert numPools == numTokens - 1 # dev: invalid path\n\n    # get first token and last token\n    tokenIn: address = _tokenPath[0]\n    tokenOut: address = _tokenPath[numTokens - 1]\n\n    # pre balances\n    preLegoBalance: uint256 = staticcall IERC20(tokenIn).balanceOf(self)\n\n    # transfer deposit asset to this contract\n    amountIn: uint256 = min(_amountIn, staticcall IERC20(tokenIn).balanceOf(msg.sender))\n    assert amountIn != 0 # dev: nothing to transfer\n    assert extcall IERC20(tokenIn).transferFrom(msg.sender, self, amountIn, default_return_value=True) # dev: transfer failed\n\n    # adjust min amount out\n    minAmountOut: uint256 = _minAmountOut\n    if amountIn < _amountIn and _amountIn != max_value(uint256):\n        minAmountOut = _minAmountOut * amountIn // _amountIn\n\n    # transfer initial amount to first pool\n    assert extcall IERC20(tokenIn).transfer(_poolPath[0], amountIn, default_return_value=True) # dev: transfer failed\n\n    # iterate through swap routes\n    tempAmountIn: uint256 = amountIn\n    aeroFactory: address = AERODROME_FACTORY\n    for i: uint256 in range(numTokens - 1, bound=MAX_TOKEN_PATH):\n        tempTokenIn: address = _tokenPath[i]\n        tempTokenOut: address = _tokenPath[i + 1]\n        tempPool: address = _poolPath[i]\n\n        # transfer to next pool (or to recipient if last swap)\n        recipient: address = _recipient\n        if i < numTokens - 2:\n            recipient = _poolPath[i + 1]\n\n        # swap\n        tempAmountIn = self._swapTokensInPool(tempPool, tempTokenIn, tempTokenOut, tempAmountIn, recipient, aeroFactory)\n\n    # final amount\n    amountOut: uint256 = tempAmountIn\n    assert amountOut >= minAmountOut # dev: min amount out not met\n\n    # refund if full swap didn't get through\n    currentLegoBalance: uint256 = staticcall IERC20(tokenIn).balanceOf(self)\n    refundAssetAmount: uint256 = 0\n    if currentLegoBalance > preLegoBalance:\n        refundAssetAmount = currentLegoBalance - preLegoBalance\n        assert extcall IERC20(tokenIn).transfer(msg.sender, refundAssetAmount, default_return_value=True) # dev: transfer failed\n        amountIn -= refundAssetAmount\n\n    # get usd values\n    usdValue: uint256 = extcall Appraiser(miniAddys.appraiser).updatePriceAndGetUsdValue(tokenIn, amountIn, miniAddys.missionControl, miniAddys.legoBook)\n    if usdValue == 0:\n        usdValue = extcall Appraiser(miniAddys.appraiser).updatePriceAndGetUsdValue(tokenOut, amountOut, miniAddys.missionControl, miniAddys.legoBook)\n\n    log AerodromeSwap(\n        sender = msg.sender,\n        tokenIn = tokenIn,\n        tokenOut = tokenOut,\n        amountIn = amountIn,\n        amountOut = amountOut,\n        usdValue = usdValue,\n        numTokens = numTokens,\n        recipient = _recipient,\n    )\n    return amountIn, amountOut, usdValue\n\n\n# swap in pool\n\n\n@internal\ndef _swapTokensInPool(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n    _recipient: address,\n    _aeroFactory: address,\n) -> uint256:\n    token0: address = empty(address)\n    token1: address = empty(address)\n    token0, token1 = staticcall AeroClassicPool(_pool).tokens()\n\n    tokens: address[2] = [token0, token1]\n    assert _tokenIn in tokens # dev: invalid tokenIn\n    assert _tokenOut in tokens # dev: invalid tokenOut\n    assert _tokenIn != _tokenOut # dev: invalid tokens\n\n    # verify actual aerodrome pool\n    assert staticcall AeroFactory(_aeroFactory).getPool(_tokenIn, _tokenOut, staticcall AeroClassicPool(_pool).stable()) == _pool # dev: invalid pool\n\n    zeroForOne: bool = _tokenIn == token0\n    amountOut: uint256 = staticcall AeroClassicPool(_pool).getAmountOut(_amountIn, _tokenIn)\n    assert amountOut != 0 # dev: no tokens swapped\n\n    # put in correct order\n    amount0Out: uint256 = amountOut\n    amount1Out: uint256 = 0\n    if zeroForOne:\n        amount0Out = 0\n        amount1Out = amountOut\n\n    extcall AeroClassicPool(_pool).swap(amount0Out, amount1Out, _recipient, b\"\")\n    return amountOut\n\n\n#############\n# Liquidity #\n#############\n\n\n# add liquidity\n\n\n@external\ndef addLiquidity(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _amountA: uint256,\n    _amountB: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _minLpAmount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (address, uint256, uint256, uint256, uint256):\n    assert not dld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = dld._getMiniAddys(_miniAddys)\n\n    # validate tokens\n    token0: address = empty(address)\n    token1: address = empty(address)\n    token0, token1 = staticcall AeroClassicPool(_pool).tokens()\n\n    tokens: address[2] = [token0, token1]\n    assert _tokenA in tokens # dev: invalid tokenA\n    assert _tokenB in tokens # dev: invalid tokenB\n    assert _tokenA != _tokenB # dev: invalid tokens\n\n    # pre balances\n    preLegoBalanceA: uint256 = staticcall IERC20(_tokenA).balanceOf(self)\n    preLegoBalanceB: uint256 = staticcall IERC20(_tokenB).balanceOf(self)\n\n    # token a\n    liqAmountA: uint256 = min(_amountA, staticcall IERC20(_tokenA).balanceOf(msg.sender))\n    assert liqAmountA != 0 # dev: nothing to transfer\n    assert extcall IERC20(_tokenA).transferFrom(msg.sender, self, liqAmountA, default_return_value=True) # dev: transfer failed\n\n    # token b\n    liqAmountB: uint256 = min(_amountB, staticcall IERC20(_tokenB).balanceOf(msg.sender))\n    assert liqAmountB != 0 # dev: nothing to transfer\n    assert extcall IERC20(_tokenB).transferFrom(msg.sender, self, liqAmountB, default_return_value=True) # dev: transfer failed\n\n    # approvals\n    router: address = AERODROME_ROUTER\n    assert extcall IERC20(_tokenA).approve(router, liqAmountA, default_return_value=True) # dev: approval failed\n    assert extcall IERC20(_tokenB).approve(router, liqAmountB, default_return_value=True) # dev: approval failed\n\n    # add liquidity\n    lpAmountReceived: uint256 = 0\n    liqAmountA, liqAmountB, lpAmountReceived = extcall AeroRouter(router).addLiquidity(\n        _tokenA,\n        _tokenB,\n        staticcall AeroClassicPool(_pool).stable(),\n        liqAmountA,\n        liqAmountB,\n        _minAmountA,\n        _minAmountB,\n        _recipient,\n        block.timestamp,\n    )\n    assert lpAmountReceived != 0 # dev: no liquidity added\n    if _minLpAmount != 0:\n        assert lpAmountReceived >= _minLpAmount # dev: insufficient liquidity added\n\n    # reset approvals\n    assert extcall IERC20(_tokenA).approve(router, 0, default_return_value=True) # dev: approval failed\n    assert extcall IERC20(_tokenB).approve(router, 0, default_return_value=True) # dev: approval failed\n\n    # refund if full liquidity was not added\n    currentLegoBalanceA: uint256 = staticcall IERC20(_tokenA).balanceOf(self)\n    refundAssetAmountA: uint256 = 0\n    if currentLegoBalanceA > preLegoBalanceA:\n        refundAssetAmountA = currentLegoBalanceA - preLegoBalanceA\n        assert extcall IERC20(_tokenA).transfer(msg.sender, refundAssetAmountA, default_return_value=True) # dev: transfer failed\n\n    currentLegoBalanceB: uint256 = staticcall IERC20(_tokenB).balanceOf(self)\n    refundAssetAmountB: uint256 = 0\n    if currentLegoBalanceB > preLegoBalanceB:\n        refundAssetAmountB = currentLegoBalanceB - preLegoBalanceB\n        assert extcall IERC20(_tokenB).transfer(msg.sender, refundAssetAmountB, default_return_value=True) # dev: transfer failed\n\n    usdValue: uint256 = self._getUsdValue(_tokenA, liqAmountA, _tokenB, liqAmountB, miniAddys)\n    log AerodromeLiquidityAdded(\n        sender = msg.sender,\n        tokenA = _tokenA,\n        tokenB = _tokenB,\n        amountA = liqAmountA,\n        amountB = liqAmountB,\n        lpAmountReceived = lpAmountReceived,\n        usdValue = usdValue,\n        recipient = _recipient,\n    )\n    return _pool, lpAmountReceived, liqAmountA, liqAmountB, usdValue\n\n\n# remove liquidity\n\n\n@external\ndef removeLiquidity(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpToken: address,\n    _lpAmount: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, uint256):\n    assert not dld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = dld._getMiniAddys(_miniAddys)\n\n    # validate tokens\n    token0: address = empty(address)\n    token1: address = empty(address)\n    token0, token1 = staticcall AeroClassicPool(_pool).tokens()\n\n    tokens: address[2] = [token0, token1]\n    assert _tokenA in tokens # dev: invalid tokenA\n    assert _tokenB in tokens # dev: invalid tokenB\n    assert _tokenA != _tokenB # dev: invalid tokens\n\n    # pre balance\n    preLegoBalance: uint256 = staticcall IERC20(_lpToken).balanceOf(self)\n\n    # lp token\n    lpAmount: uint256 = min(_lpAmount, staticcall IERC20(_lpToken).balanceOf(msg.sender))\n    assert lpAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_lpToken).transferFrom(msg.sender, self, lpAmount, default_return_value=True) # dev: transfer failed\n\n    # approvals\n    router: address = AERODROME_ROUTER\n    assert extcall IERC20(_lpToken).approve(router, lpAmount, default_return_value=True) # dev: approval failed\n\n    # remove liquidity\n    amountA: uint256 = 0\n    amountB: uint256 = 0\n    amountA, amountB = extcall AeroRouter(router).removeLiquidity(\n        _tokenA,\n        _tokenB,\n        staticcall AeroClassicPool(_pool).stable(),\n        lpAmount,\n        _minAmountA,\n        _minAmountB,\n        _recipient,\n        block.timestamp,\n    )\n    assert amountA != 0 # dev: no amountA removed\n    assert amountB != 0 # dev: no amountB removed\n\n    # reset approvals\n    assert extcall IERC20(_lpToken).approve(router, 0, default_return_value=True) # dev: approval failed\n\n    # refund if full liquidity was not removed\n    currentLegoBalance: uint256 = staticcall IERC20(_lpToken).balanceOf(self)\n    refundedLpAmount: uint256 = 0\n    if currentLegoBalance > preLegoBalance:\n        refundedLpAmount = currentLegoBalance - preLegoBalance\n        assert extcall IERC20(_lpToken).transfer(msg.sender, refundedLpAmount, default_return_value=True) # dev: transfer failed\n        lpAmount -= refundedLpAmount\n\n    usdValue: uint256 = self._getUsdValue(_tokenA, amountA, _tokenB, amountB, miniAddys)\n    log AerodromeLiquidityRemoved(\n        sender = msg.sender,\n        pool = _pool,\n        tokenA = _tokenA,\n        tokenB = _tokenB,\n        amountA = amountA,\n        amountB = amountB,\n        lpToken = _lpToken,\n        lpAmountBurned = lpAmount,\n        usdValue = usdValue,\n        recipient = _recipient,\n    )\n    return amountA, amountB, lpAmount, usdValue\n\n\n# get usd value on liquidity actions\n\n\n@internal\ndef _getUsdValue(\n    _tokenA: address,\n    _amountA: uint256,\n    _tokenB: address,\n    _amountB: uint256,\n    _miniAddys: ws.MiniAddys,\n) -> uint256:\n\n    usdValueA: uint256 = 0\n    if _amountA != 0:\n        usdValueA = extcall Appraiser(_miniAddys.appraiser).updatePriceAndGetUsdValue(_tokenA, _amountA, _miniAddys.missionControl, _miniAddys.legoBook)\n\n    usdValueB: uint256 = 0\n    if _amountB != 0:\n        usdValueB = extcall Appraiser(_miniAddys.appraiser).updatePriceAndGetUsdValue(_tokenB, _amountB, _miniAddys.missionControl, _miniAddys.legoBook)\n\n    return usdValueA + usdValueB\n\n\n#############\n# Utilities #\n#############\n\n\n@view\n@external\ndef getLpToken(_pool: address) -> address:\n    # in uniswap v2, the lp token is the pool address\n    return _pool\n\n\n@view\n@external\ndef getPoolForLpToken(_lpToken: address) -> address:\n    # in uniswap v2, the pool is the lp token address\n    return _lpToken\n\n\n@view\n@external\ndef getCoreRouterPool() -> address:\n    return self.coreRouterPool\n\n\n@view\n@external\ndef getDeepestLiqPool(_tokenA: address, _tokenB: address) -> BestPool:\n    factory: address = AERODROME_FACTORY\n    reserve0: uint256 = 0\n    reserve1: uint256 = 0\n    na: uint256 = 0\n\n    # get pool options\n    stablePool: address = staticcall AeroFactory(factory).getPool(_tokenA, _tokenB, True)\n    volatilePool: address = staticcall AeroFactory(factory).getPool(_tokenA, _tokenB, False)\n\n    # no pools found\n    if stablePool == empty(address) and volatilePool == empty(address):\n        return empty(BestPool)\n\n    # stable pool\n    stableLiquidity: uint256 = 0\n    if stablePool != empty(address):\n        reserve0, reserve1, na = staticcall AeroClassicPool(stablePool).getReserves()\n        stableLiquidity = reserve0 + reserve1\n\n    # volatile pool\n    volatileLiquidity: uint256 = 0\n    if volatilePool != empty(address):\n        reserve0, reserve1, na = staticcall AeroClassicPool(volatilePool).getReserves()\n        volatileLiquidity = reserve0 + reserve1\n\n    # best pool determined by liquidity\n    bestPoolAddr: address = stablePool\n    bestLiquidity: uint256 = stableLiquidity\n    isStable: bool = True\n    if volatileLiquidity > stableLiquidity:\n        bestPoolAddr = volatilePool\n        bestLiquidity = volatileLiquidity\n        isStable = False\n\n    return BestPool(\n        pool=bestPoolAddr,\n        fee=staticcall AeroFactory(factory).getFee(bestPoolAddr, isStable),\n        liquidity=bestLiquidity,\n        numCoins=2,\n    )\n\n\n@view\n@external\ndef getBestSwapAmountOut(_tokenIn: address, _tokenOut: address, _amountIn: uint256) -> (address, uint256):\n    factory: address = AERODROME_FACTORY\n    stablePool: address = staticcall AeroFactory(factory).getPool(_tokenIn, _tokenOut, True)\n    volatilePool: address = staticcall AeroFactory(factory).getPool(_tokenIn, _tokenOut, False)\n    if stablePool == empty(address) and volatilePool == empty(address):\n        return empty(address), 0\n\n    # stable pool\n    stableAmountOut: uint256 = 0\n    if stablePool != empty(address):\n        stableAmountOut = staticcall AeroClassicPool(stablePool).getAmountOut(_amountIn, _tokenIn)\n\n    # volatile pool\n    volatileAmountOut: uint256 = 0\n    if volatilePool != empty(address):\n        volatileAmountOut = staticcall AeroClassicPool(volatilePool).getAmountOut(_amountIn, _tokenIn)\n\n    if stableAmountOut == 0 and volatileAmountOut == 0:\n        return empty(address), 0\n\n    pool: address = stablePool\n    amountOut: uint256 = stableAmountOut\n    if volatileAmountOut > stableAmountOut:\n        pool = volatilePool\n        amountOut = volatileAmountOut\n\n    return pool, amountOut\n\n\n@view\n@external\ndef getSwapAmountOut(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n) -> uint256:\n    return staticcall AeroClassicPool(_pool).getAmountOut(_amountIn, _tokenIn)\n\n\n@view\n@external\ndef getBestSwapAmountIn(_tokenIn: address, _tokenOut: address, _amountOut: uint256) -> (address, uint256):\n    # TODO: implement stable pools\n    pool: address = staticcall AeroFactory(AERODROME_FACTORY).getPool(_tokenIn, _tokenOut, False)\n    if pool == empty(address):\n        return empty(address), max_value(uint256)\n\n    token0: address = empty(address)\n    token1: address = empty(address)\n    token0, token1 = staticcall AeroClassicPool(pool).tokens()\n    return pool, self._getAmountInForVolatilePools(pool, token0 == _tokenIn, _amountOut)\n\n\n@view\n@external\ndef getSwapAmountIn(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountOut: uint256,\n) -> uint256:\n    if not staticcall AeroClassicPool(_pool).stable():\n        token0: address = empty(address)\n        token1: address = empty(address)\n        token0, token1 = staticcall AeroClassicPool(_pool).tokens()\n        return self._getAmountInForVolatilePools(_pool, token0 == _tokenIn, _amountOut)\n    else:\n        return max_value(uint256) # TODO: implement stable pools\n\n\n@view\n@external\ndef getAddLiqAmountsIn(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _availAmountA: uint256,\n    _availAmountB: uint256,\n) -> (uint256, uint256, uint256):\n    return staticcall AeroRouter(AERODROME_ROUTER).quoteAddLiquidity(_tokenA, _tokenB, staticcall AeroClassicPool(_pool).stable(), AERODROME_FACTORY, _availAmountA, _availAmountB)\n\n\n@view\n@external\ndef getRemoveLiqAmountsOut(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpAmount: uint256,\n) -> (uint256, uint256):\n    return staticcall AeroRouter(AERODROME_ROUTER).quoteRemoveLiquidity(_tokenA, _tokenB, staticcall AeroClassicPool(_pool).stable(), AERODROME_FACTORY, _lpAmount)\n\n\n@view\n@external\ndef getPrice(_asset: address, _decimals: uint256) -> uint256:\n    return 0 # TODO: implement price\n\n\n@view\n@external\ndef getPriceUnsafe(_pool: address, _targetToken: address, _appraiser: address = empty(address)) -> uint256:\n    if not staticcall AeroClassicPool(_pool).stable():\n        return self._getPriceUnsafeVolatilePool(_pool, _targetToken, _appraiser)\n    else:\n        return 0 # TODO: implement stable pools\n\n\n# internal utils\n\n\n@view\n@internal\ndef _getPriceUnsafeVolatilePool(_pool: address, _targetToken: address, _appraiser: address) -> uint256:\n    token0: address = empty(address)\n    token1: address = empty(address)\n    token0, token1 = staticcall AeroClassicPool(_pool).tokens()\n\n    # appraiser\n    appraiser: address = _appraiser\n    if _appraiser == empty(address):\n        appraiser = addys._getAppraiserAddr()\n\n    # alt price\n    altPrice: uint256 = 0\n    if _targetToken == token0:\n        altPrice = staticcall Appraiser(appraiser).getNormalAssetPrice(token1)\n    else:\n        altPrice = staticcall Appraiser(appraiser).getNormalAssetPrice(token0)\n\n    # return early if no alt price\n    if altPrice == 0:\n        return 0\n\n    # reserves\n    reserve0: uint256 = 0\n    reserve1: uint256 = 0\n    na: uint256 = 0\n    reserve0, reserve1, na = staticcall AeroClassicPool(_pool).getReserves()\n\n    # avoid division by zero\n    if reserve0 == 0 or reserve1 == 0:\n        return 0  \n\n    # price of token0 in token1\n    priceZeroToOne: uint256 = reserve1 * EIGHTEEN_DECIMALS // reserve0\n\n    # adjust for decimals: price should be in 18 decimals\n    decimals0: uint256 = convert(staticcall IERC20Detailed(token0).decimals(), uint256)\n    decimals1: uint256 = convert(staticcall IERC20Detailed(token1).decimals(), uint256)\n    if decimals0 > decimals1:\n        scaleFactor: uint256 = 10 ** (decimals0 - decimals1)\n        priceZeroToOne = priceZeroToOne * scaleFactor\n    elif decimals1 > decimals0:\n        scaleFactor: uint256 = 10 ** (decimals1 - decimals0)\n        priceZeroToOne = priceZeroToOne // scaleFactor\n\n    # if _targetToken is token1, make price inverse\n    priceToOther: uint256 = priceZeroToOne\n    if _targetToken == token1:\n        priceToOther = EIGHTEEN_DECIMALS * EIGHTEEN_DECIMALS // priceZeroToOne\n\n    return altPrice * priceToOther // EIGHTEEN_DECIMALS\n\n\n@view\n@internal\ndef _getAmountInForVolatilePools(_pool: address, _zeroForOne: bool, _amountOut: uint256) -> uint256:\n    if _amountOut == 0 or _amountOut == max_value(uint256):\n        return max_value(uint256)\n\n    reserve0: uint256 = 0\n    reserve1: uint256 = 0\n    na: uint256 = 0\n    reserve0, reserve1, na = staticcall AeroClassicPool(_pool).getReserves()\n    if reserve0 == 0 or reserve1 == 0:\n        return max_value(uint256)\n\n    # determine which token is which\n    reserveIn: uint256 = reserve0\n    reserveOut: uint256 = reserve1\n    if not _zeroForOne:\n        reserveIn = reserve1\n        reserveOut = reserve0\n\n    if _amountOut > reserveOut:\n        return max_value(uint256)\n\n    fee: uint256 = staticcall AeroFactory(AERODROME_FACTORY).getFee(_pool, False)\n    numerator: uint256 = reserveIn * _amountOut * 100_00\n    denominator: uint256 = (reserveOut - _amountOut) * (100_00 - fee)\n    return (numerator // denominator) + 1\n\n\n#########\n# Other #\n#########\n\n\n@external\ndef depositForYield(\n    _asset: address,\n    _amount: uint256,\n    _vaultAddr: address,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, address, uint256, uint256):\n    return 0, empty(address), 0, 0\n\n\n@external\ndef withdrawFromYield(\n    _vaultToken: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, address, uint256, uint256):\n    return 0, empty(address), 0, 0\n\n\n@external\ndef mintOrRedeemAsset(\n    _tokenIn: address,\n    _tokenOut: address,\n    _tokenInAmount: uint256,\n    _minAmountOut: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, bool, uint256):\n    return 0, 0, False, 0\n\n\n@external\ndef confirmMintOrRedeemAsset(\n    _tokenIn: address,\n    _tokenOut: address,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef addCollateral(\n    _asset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef removeCollateral(\n    _asset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef borrow(\n    _borrowAsset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef repayDebt(\n    _paymentAsset: address,\n    _paymentAmount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef claimRewards(\n    _user: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _extraData: bytes32,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n@external\ndef addLiquidityConcentrated(\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _tickLower: int24,\n    _tickUpper: int24,\n    _amountA: uint256,\n    _amountB: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, uint256, uint256):\n    return 0, 0, 0, 0, 0\n\n\n@external\ndef removeLiquidityConcentrated(\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _liqToRemove: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, bool, uint256):\n    return 0, 0, 0, False, 0\n\n\n\n@view\n@external\ndef getAccessForLego(_user: address, _action: ws.ActionType) -> (address, String[64], uint256):\n    return empty(address), empty(String[64]), 0\n",
            "sha256sum": "eeef89b7162bdf6ffab936890944beb16f6995a99ac64a0b31d092d628133f46"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/legos/dexes/AeroClassic.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.3+commit.bff19ea2",
        "integrity": "2d3a59b109fd6d95e949f55a249f3b0700fb76d31d1bd1190b244019d74f0f8f"
      },
      "args": "00000000000000000000000044cf3c4f000dfd76a35d03298049d37be688d6f9000000000000000000000000420dd381b31aef6683db6b902084cb0ffece40da000000000000000000000000cf77a3ba9a5ca399b7c97c74d54e5b1beb874e43000000000000000000000000cdac0d6c6c59727a65f871236188350531885c43",
      "file": "contracts/legos/dexes/AeroClassic.vy"
    },
    "AeroSlipstream": {
      "address": "0x4cAB685a4603d0B0d512A1721B65BDDe45F39FD1",
      "abi": [
        {
          "name": "AeroSlipStreamSwap",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenIn",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenOut",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amountIn",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "amountOut",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "numTokens",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AeroSlipStreamLiquidityAdded",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenA",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenB",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amountA",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "amountB",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "liquidityAdded",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "nftTokenId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AeroSlipStreamLiquidityRemoved",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": false
            },
            {
              "name": "pool",
              "type": "address",
              "indexed": true
            },
            {
              "name": "nftTokenId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "tokenA",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenB",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amountA",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "amountB",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "liquidityRemoved",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AeroSlipStreamNftRecovered",
          "inputs": [
            {
              "name": "collection",
              "type": "address",
              "indexed": true
            },
            {
              "name": "nftTokenId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LegoPauseModified",
          "inputs": [
            {
              "name": "isPaused",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LegoFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "balance",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddys",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "undyToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "hatchery",
                  "type": "address"
                },
                {
                  "name": "lootDistributor",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                },
                {
                  "name": "walletBackpack",
                  "type": "address"
                },
                {
                  "name": "billing",
                  "type": "address"
                },
                {
                  "name": "vaultRegistry",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUndyHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pause",
          "inputs": [
            {
              "name": "_shouldPause",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFundsMany",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_assets",
              "type": "address[]"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "legoId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isPaused",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasCapability",
          "inputs": [
            {
              "name": "_action",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "onERC721Received",
          "inputs": [
            {
              "name": "_operator",
              "type": "address"
            },
            {
              "name": "_owner",
              "type": "address"
            },
            {
              "name": "_tokenId",
              "type": "uint256"
            },
            {
              "name": "_data",
              "type": "bytes"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bytes4"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRegistries",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isYieldLego",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isDexLego",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_tokenPath",
              "type": "address[]"
            },
            {
              "name": "_poolPath",
              "type": "address[]"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_tokenPath",
              "type": "address[]"
            },
            {
              "name": "_poolPath",
              "type": "address[]"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "uniswapV3SwapCallback",
          "inputs": [
            {
              "name": "_amount0Delta",
              "type": "int256"
            },
            {
              "name": "_amount1Delta",
              "type": "int256"
            },
            {
              "name": "_data",
              "type": "bytes"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLpToken",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPoolForLpToken",
          "inputs": [
            {
              "name": "_lpToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getCoreRouterPool",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getDeepestLiqPool",
          "inputs": [
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "fee",
                  "type": "uint256"
                },
                {
                  "name": "liquidity",
                  "type": "uint256"
                },
                {
                  "name": "numCoins",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getBestSwapAmountOut",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountIn",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getSwapAmountOut",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountIn",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getBestSwapAmountIn",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountOut",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getSwapAmountIn",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountOut",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddLiqAmountsIn",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_availAmountA",
              "type": "uint256"
            },
            {
              "name": "_availAmountB",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRemoveLiqAmountsOut",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPrice",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_decimals",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPriceUnsafe",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_targetToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPriceUnsafe",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_targetToken",
              "type": "address"
            },
            {
              "name": "_appraiser",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverNft",
          "inputs": [
            {
              "name": "_collection",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositForYield",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositForYield",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawFromYield",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawFromYield",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_tokenInAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_tokenInAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmMintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmMintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_borrowAsset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_borrowAsset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_paymentAsset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_paymentAsset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAccessForLego",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_action",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "string"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "AERO_SLIPSTREAM_FACTORY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "AERO_SLIPSTREAM_NFT_MANAGER",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "AERO_SLIPSTREAM_QUOTER",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "coreRouterPool",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_undyHq",
              "type": "address"
            },
            {
              "name": "_aeroFactory",
              "type": "address"
            },
            {
              "name": "_aeroNftPositionManager",
              "type": "address"
            },
            {
              "name": "_aeroQuoter",
              "type": "address"
            },
            {
              "name": "_coreRouterPool",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "interfaces/WalletStructs.vyi": {
            "content": "# @version 0.4.3\n\nflag ActionType:\n    TRANSFER\n    EARN_DEPOSIT\n    EARN_WITHDRAW\n    EARN_REBALANCE\n    SWAP\n    MINT_REDEEM\n    CONFIRM_MINT_REDEEM\n    ADD_COLLATERAL\n    REMOVE_COLLATERAL\n    BORROW\n    REPAY_DEBT\n    REWARDS\n    ETH_TO_WETH\n    WETH_TO_ETH\n    ADD_LIQ\n    REMOVE_LIQ\n    ADD_LIQ_CONC\n    REMOVE_LIQ_CONC\n    PAY_CHEQUE\n\nstruct WalletAssetData:\n    assetBalance: uint256\n    usdValue: uint256\n    isYieldAsset: bool\n    lastPricePerShare: uint256\n\nstruct ActionData:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    billing: address\n    wallet: address\n    walletConfig: address\n    walletOwner: address\n    inEjectMode: bool\n    isFrozen: bool\n    lastTotalUsdValue: uint256\n    signer: address\n    isManager: bool\n    legoId: uint256\n    legoAddr: address\n    eth: address\n    weth: address\n\nstruct MiniAddys:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    appraiser: address",
            "sha256sum": "9a4b4f59b3a62043e51b425a665064aae419a3c0bd0514b6b29a9441ae364bb9"
          },
          "interfaces/LegoPartner.vyi": {
            "content": "# @version 0.4.3\n\nfrom interfaces import WalletStructs as ws\n\nMAX_TOKEN_PATH: constant(uint256) = 5\nMAX_RECOVER_ASSETS: constant(uint256) = 20\n\n@external\ndef addLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _tickLower: int24, _tickUpper: int24, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef addLiquidity(_pool: address, _tokenA: address, _tokenB: address, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _minLpAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (address, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef removeLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _liqToRemove: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef removeLiquidity(_pool: address, _tokenA: address, _tokenB: address, _lpToken: address, _lpAmount: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef mintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _tokenInAmount: uint256, _minAmountOut: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef swapTokens(_amountIn: uint256, _minAmountOut: uint256, _tokenPath: DynArray[address, MAX_TOKEN_PATH], _poolPath: DynArray[address, MAX_TOKEN_PATH - 1], _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256):\n    ...\n\n@external\ndef depositForYield(_asset: address, _amount: uint256, _vaultAddr: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef withdrawFromYield(_vaultToken: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef confirmMintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef borrow(_borrowAsset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef repayDebt(_paymentAsset: address, _paymentAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef claimRewards(_user: address, _rewardToken: address, _rewardAmount: uint256, _extraData: bytes32, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef removeCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef addCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@view\n@external\ndef getAccessForLego(_user: address, _action: ws.ActionType) -> (address, String[64], uint256):\n    ...\n\n@view\n@external\ndef hasCapability(_action: ws.ActionType) -> bool:\n    ...\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    ...\n\n@view\n@external\ndef isYieldLego() -> bool:\n    ...\n\n@view\n@external\ndef isDexLego() -> bool:\n    ...\n\n\n# common\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "81db71fe4440a3b4b563134c9b5caf1d5705772a5f291fe874c9b5fb3cfb1623"
          },
          "contracts/modules/Addys.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\ninterface UndyHq:\n    def isValidAddr(_addr: address) -> bool: view\n    def getAddr(_regId: uint256) -> address: view\n    def undyToken() -> address: view\n\ninterface Switchboard:\n    def isSwitchboardAddr(_addr: address) -> bool: view\n\ninterface LegoBook:\n    def isLegoAddr(_addr: address) -> bool: view\n\nstruct Addys:\n    hq: address\n    undyToken: address\n    ledger: address\n    missionControl: address\n    legoBook: address\n    switchboard: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    walletBackpack: address\n    billing: address\n    vaultRegistry: address\n\n# hq\nUNDY_HQ_FOR_ADDYS: immutable(address)\n\n# core addys\nLEDGER_ID: constant(uint256) = 1\nMISSION_CONTROL_ID: constant(uint256) = 2\nLEGO_BOOK_ID: constant(uint256) = 3\nSWITCHBOARD_ID: constant(uint256) = 4\nHATCHERY_ID: constant(uint256) = 5\nLOOT_DISTRIBUTOR_ID: constant(uint256) = 6\nAPPRAISER_ID: constant(uint256) = 7\nWALLET_BACKPACK_ID: constant(uint256) = 8\nBILLING_ID: constant(uint256) = 9\nVAULT_REGISTRY_ID: constant(uint256) = 10\n\n\n@deploy\ndef __init__(_undyHq: address):\n    assert _undyHq != empty(address) # dev: invalid undy hq\n    UNDY_HQ_FOR_ADDYS = _undyHq\n\n\n########\n# Core #\n########\n\n\n@view\n@external\ndef getAddys() -> Addys:\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _getAddys(_addys: Addys = empty(Addys)) -> Addys:\n    if _addys.hq != empty(address):\n        return _addys\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _generateAddys() -> Addys:\n    hq: address = UNDY_HQ_FOR_ADDYS\n    return Addys(\n        hq = hq,\n        undyToken = staticcall UndyHq(hq).undyToken(),\n        ledger = staticcall UndyHq(hq).getAddr(LEDGER_ID),\n        missionControl = staticcall UndyHq(hq).getAddr(MISSION_CONTROL_ID),\n        legoBook = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID),\n        switchboard = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID),\n        hatchery = staticcall UndyHq(hq).getAddr(HATCHERY_ID),\n        lootDistributor = staticcall UndyHq(hq).getAddr(LOOT_DISTRIBUTOR_ID),\n        appraiser = staticcall UndyHq(hq).getAddr(APPRAISER_ID),\n        walletBackpack = staticcall UndyHq(hq).getAddr(WALLET_BACKPACK_ID),\n        billing = staticcall UndyHq(hq).getAddr(BILLING_ID),\n        vaultRegistry = staticcall UndyHq(hq).getAddr(VAULT_REGISTRY_ID),\n    )\n\n\n##########\n# Tokens #\n##########\n\n\n@view\n@internal\ndef _getUndyToken() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).undyToken()\n\n\n###########\n# Helpers #\n###########\n\n\n# undy hq\n\n\n@view\n@external\ndef getUndyHq() -> address:\n    return self._getUndyHq()\n\n\n@view\n@internal\ndef _getUndyHq() -> address:\n    return UNDY_HQ_FOR_ADDYS\n\n\n# utils\n\n\n@view\n@internal\ndef _isValidUndyAddr(_addr: address, _hq: address = empty(address)) -> bool:\n    hq: address = _hq\n    if _hq == empty(address):\n        hq = UNDY_HQ_FOR_ADDYS\n    \n    # core departments\n    if staticcall UndyHq(hq).isValidAddr(_addr):\n        return True\n\n    # lego book\n    legoBook: address = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID)\n    if legoBook != empty(address) and staticcall LegoBook(legoBook).isLegoAddr(_addr):\n        return True\n\n    # switchboard config\n    switchboard: address = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID)\n    if switchboard != empty(address) and staticcall Switchboard(switchboard).isSwitchboardAddr(_addr):\n        return True\n\n    return False\n\n\n@view\n@internal\ndef _isSwitchboardAddr(_addr: address) -> bool:\n    switchboard: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n    if switchboard == empty(address):\n        return False\n    return staticcall Switchboard(switchboard).isSwitchboardAddr(_addr)\n\n\n@view\n@internal\ndef _isLegoBookAddr(_addr: address) -> bool:\n    legoBook: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n    if legoBook == empty(address):\n        return False\n    return staticcall LegoBook(legoBook).isLegoAddr(_addr)\n\n\n###############\n# Departments #\n###############\n\n\n# ledger\n\n\n@view\n@internal\ndef _getLedgerId() -> uint256:\n    return LEDGER_ID\n\n\n@view\n@internal\ndef _getLedgerAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEDGER_ID)\n\n\n# mission control\n\n\n@view\n@internal\ndef _getMissionControlId() -> uint256:\n    return MISSION_CONTROL_ID\n\n\n@view\n@internal\ndef _getMissionControlAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(MISSION_CONTROL_ID)\n\n\n# lego book\n\n\n@view\n@internal\ndef _getLegoBookId() -> uint256:\n    return LEGO_BOOK_ID\n\n\n@view\n@internal\ndef _getLegoBookAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n\n\n# switchboard\n\n\n@view\n@internal\ndef _getSwitchboardId() -> uint256:\n    return SWITCHBOARD_ID\n\n\n@view\n@internal\ndef _getSwitchboardAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n\n\n# hatchery\n\n\n@view\n@internal\ndef _getHatcheryId() -> uint256:\n    return HATCHERY_ID\n\n\n@view\n@internal\ndef _getHatcheryAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(HATCHERY_ID)\n\n\n# loot distributor\n\n\n@view\n@internal\ndef _getLootDistributorId() -> uint256:\n    return LOOT_DISTRIBUTOR_ID\n\n\n@view\n@internal\ndef _getLootDistributorAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LOOT_DISTRIBUTOR_ID)\n\n\n# appraiser\n\n\n@view\n@internal\ndef _getAppraiserId() -> uint256:\n    return APPRAISER_ID\n\n\n@view\n@internal\ndef _getAppraiserAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(APPRAISER_ID)\n\n\n# wallet backpack\n\n\n@view\n@internal\ndef _getWalletBackpackId() -> uint256:\n    return WALLET_BACKPACK_ID\n\n\n@view\n@internal\ndef _getWalletBackpackAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(WALLET_BACKPACK_ID)\n\n\n# billing\n\n\n@view\n@internal\ndef _getBillingId() -> uint256:\n    return BILLING_ID\n\n\n@view\n@internal\ndef _getBillingAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(BILLING_ID)\n\n\n# vault registry\n\n\n@view\n@internal\ndef _getVaultRegistryId() -> uint256:\n    return VAULT_REGISTRY_ID\n\n\n@view\n@internal\ndef _getVaultRegistryAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(VAULT_REGISTRY_ID)",
            "sha256sum": "4df6b72db9bb417d1af81660175be1450cfb7b3575f3d17a5b8a130bff87b781"
          },
          "contracts/modules/DexLegoData.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nuses: addys\n\nimport contracts.modules.Addys as addys\n\nfrom interfaces import WalletStructs as ws\nfrom ethereum.ercs import IERC20\n\nevent LegoPauseModified:\n    isPaused: bool\n\nevent LegoFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    balance: uint256\n\n# config\nlegoId: public(uint256)\nisPaused: public(bool)\n\nMAX_RECOVER_ASSETS: constant(uint256) = 20\n\n\n@deploy\ndef __init__(_shouldPause: bool):\n    self.isPaused = _shouldPause\n\n\n###########\n# General #\n###########\n\n\n# fill mini addys\n\n\n@view\n@internal\ndef _getMiniAddys(_miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> ws.MiniAddys:\n    if _miniAddys.ledger != empty(address):\n        return _miniAddys\n    return ws.MiniAddys(\n        ledger = addys._getLedgerAddr(),\n        missionControl = addys._getMissionControlAddr(),\n        legoBook = addys._getLegoBookAddr(),\n        appraiser = addys._getAppraiserAddr(),\n    )\n\n\n# activate\n\n\n@external\ndef pause(_shouldPause: bool):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert _shouldPause != self.isPaused # dev: no change\n    self.isPaused = _shouldPause\n    log LegoPauseModified(isPaused=_shouldPause)\n\n\n# recover funds\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    self._recoverFunds(_recipient, _asset)\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, MAX_RECOVER_ASSETS]):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    for a: address in _assets:\n        self._recoverFunds(_recipient, a)\n\n\n@internal\ndef _recoverFunds(_recipient: address, _asset: address):\n    assert empty(address) not in [_recipient, _asset] # dev: invalid recipient or asset\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    assert balance != 0 # dev: nothing to recover\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log LegoFundsRecovered(asset=_asset, recipient=_recipient, balance=balance)",
            "sha256sum": "75b15af2475ab409d4b5fd057509d14c20564ebd7fcb0850e3b61397d8e3af48"
          },
          "contracts/legos/dexes/AeroSlipstream.vy": {
            "content": "#     _____  _____  __  __    ____   _____  _____  _____ \n#    |  _  \\/   __\\/  \\/  \\  /  _/  /   __\\/   __\\/  _  \\\n#    |  |  ||   __|>-    -<  |  |---|   __||  |_ ||  |  |\n#    |_____/\\_____/\\__/\\__/  \\_____/\\_____/\\_____/\\_____/\n#                                                                       \n#     \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n#     \u2551  ** Aero Slipstream Lego **             \u2551\n#     \u2551  Integration with Aerodrome Slipstream. \u2551\n#     \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n#\n#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nimplements: Lego\nimplements: IUniswapV3Callback\n\nexports: addys.__interface__\nexports: dld.__interface__\n\ninitializes: addys\ninitializes: dld[addys := addys]\n\nfrom interfaces import LegoPartner as Lego\nfrom interfaces import WalletStructs as ws\n\nimport contracts.modules.Addys as addys\nimport contracts.modules.DexLegoData as dld\n\nfrom ethereum.ercs import IERC20\nfrom ethereum.ercs import IERC20Detailed\nfrom ethereum.ercs import IERC721\n\n# `getSwapAmountOut()` and `getSwapAmountIn()` cannot be view functions, sadly\n# keeping here to uncomment to test all other functions\n# implements: DexLego\n# from interfaces import DexLego as DexLego\n\ninterface AeroSlipStreamPool:\n    def swap(_recipient: address, _zeroForOne: bool, _amountSpecified: int256, _sqrtPriceLimitX96: uint160, _data: Bytes[256]) -> (int256, int256): nonpayable\n    def slot0() -> (uint160, int24, uint16, uint16, uint16, bool): view\n    def tickSpacing() -> int24: view\n    def liquidity() -> uint128: view\n    def token0() -> address: view\n    def token1() -> address: view\n    def fee() -> uint24: view\n\ninterface AeroNftPositionManager:\n    def increaseLiquidity(_params: IncreaseLiquidityParams) -> (uint128, uint256, uint256): nonpayable\n    def decreaseLiquidity(_params: DecreaseLiquidityParams) -> (uint256, uint256): nonpayable\n    def mint(_params: MintParams) -> (uint256, uint128, uint256, uint256): nonpayable\n    def collect(_params: CollectParams) -> (uint256, uint256): nonpayable\n    def positions(_tokenId: uint256) -> PositionData: view\n    def burn(_tokenId: uint256): nonpayable\n\ninterface Appraiser:\n    def getNormalAssetPrice(_asset: address, _missionControl: address = empty(address), _legoBook: address = empty(address), _ledger: address = empty(address)) -> uint256: view\n    def updatePriceAndGetUsdValue(_asset: address, _amount: uint256, _missionControl: address = empty(address), _legoBook: address = empty(address)) -> uint256: nonpayable\n\ninterface AeroQuoter:\n    def quoteExactOutputSingle(_params: QuoteExactOutputSingleParams) -> (uint256, uint160, uint32, uint256): nonpayable\n    def quoteExactInputSingle(_params: QuoteExactInputSingleParams) -> (uint256, uint160, uint32, uint256): nonpayable\n\ninterface IUniswapV3Callback:\n    def uniswapV3SwapCallback(_amount0Delta: int256, _amount1Delta: int256, _data: Bytes[256]): nonpayable\n\ninterface AeroSlipStreamFactory:\n    def getPool(_tokenA: address, _tokenB: address, _tickSpacing: int24) -> address: view\n\nstruct PoolSwapData:\n    pool: address\n    tokenIn: address\n    amountIn: uint256\n\nstruct BestPool:\n    pool: address\n    fee: uint256\n    liquidity: uint256\n    numCoins: uint256\n\nstruct QuoteExactInputSingleParams:\n    tokenIn: address\n    tokenOut: address\n    amountIn: uint256\n    tickSpacing: int24\n    sqrtPriceLimitX96: uint160\n\nstruct QuoteExactOutputSingleParams:\n    tokenIn: address\n    tokenOut: address\n    amount: uint256\n    tickSpacing: int24\n    sqrtPriceLimitX96: uint160\n\nstruct MintParams:\n    token0: address\n    token1: address\n    tickSpacing: int24\n    tickLower: int24\n    tickUpper: int24\n    amount0Desired: uint256\n    amount1Desired: uint256\n    amount0Min: uint256\n    amount1Min: uint256\n    recipient: address\n    deadline: uint256\n    sqrtPriceX96: uint160\n\nstruct IncreaseLiquidityParams:\n    tokenId: uint256\n    amount0Desired: uint256\n    amount1Desired: uint256\n    amount0Min: uint256\n    amount1Min: uint256\n    deadline: uint256\n\nstruct DecreaseLiquidityParams:\n    tokenId: uint256\n    liquidity: uint128\n    amount0Min: uint256\n    amount1Min: uint256\n    deadline: uint256\n\nstruct CollectParams:\n    tokenId: uint256\n    recipient: address\n    amount0Max: uint128\n    amount1Max: uint128\n\nstruct PositionData:\n    nonce: uint96\n    operator: address\n    token0: address\n    token1: address\n    tickSpacing: uint24\n    tickLower: int24\n    tickUpper: int24\n    liquidity: uint128\n    feeGrowthInside0LastX128: uint256\n    feeGrowthInside1LastX128: uint256\n    tokensOwed0: uint128\n    tokensOwed1: uint128\n\nevent AeroSlipStreamSwap:\n    sender: indexed(address)\n    tokenIn: indexed(address)\n    tokenOut: indexed(address)\n    amountIn: uint256\n    amountOut: uint256\n    usdValue: uint256\n    numTokens: uint256\n    recipient: address\n\nevent AeroSlipStreamLiquidityAdded:\n    sender: indexed(address)\n    tokenA: indexed(address)\n    tokenB: indexed(address)\n    amountA: uint256\n    amountB: uint256\n    liquidityAdded: uint256\n    nftTokenId: uint256\n    usdValue: uint256\n    recipient: address\n\nevent AeroSlipStreamLiquidityRemoved:\n    sender: address\n    pool: indexed(address)\n    nftTokenId: uint256\n    tokenA: indexed(address)\n    tokenB: indexed(address)\n    amountA: uint256\n    amountB: uint256\n    liquidityRemoved: uint256\n    usdValue: uint256\n    recipient: address\n\nevent AeroSlipStreamNftRecovered:\n    collection: indexed(address)\n    nftTokenId: uint256\n    recipient: indexed(address)\n\n# transient storage\npoolSwapData: transient(PoolSwapData)\n\n# aero\nAERO_SLIPSTREAM_FACTORY: public(immutable(address))\nAERO_SLIPSTREAM_NFT_MANAGER: public(immutable(address))\nAERO_SLIPSTREAM_QUOTER: public(immutable(address))\ncoreRouterPool: public(address)\n\nTICK_SPACING: constant(int24[5]) = [1, 50, 100, 200, 2000]\nMIN_SQRT_RATIO_PLUS_ONE: constant(uint160) = 4295128740\nMAX_SQRT_RATIO_MINUS_ONE: constant(uint160) = 1461446703485210103287273052203988822378723970341\nTICK_LOWER: constant(int24) = -887272\nTICK_UPPER: constant(int24) = 887272\nERC721_RECEIVE_DATA: constant(Bytes[1024]) = b\"UE721\"\nEIGHTEEN_DECIMALS: constant(uint256) = 10 ** 18\nUNISWAP_Q96: constant(uint256) = 2 ** 96  # uniswap's fixed point scaling factor\nMAX_TOKEN_PATH: constant(uint256) = 5\n\n\n@deploy\ndef __init__(\n    _undyHq: address,\n    _aeroFactory: address,\n    _aeroNftPositionManager: address,\n    _aeroQuoter: address,\n    _coreRouterPool: address,\n):\n    addys.__init__(_undyHq)\n    dld.__init__(False)\n\n    assert empty(address) not in [_aeroFactory, _aeroNftPositionManager, _aeroQuoter, _coreRouterPool] # dev: invalid addrs\n    AERO_SLIPSTREAM_FACTORY = _aeroFactory\n    AERO_SLIPSTREAM_NFT_MANAGER = _aeroNftPositionManager\n    AERO_SLIPSTREAM_QUOTER = _aeroQuoter\n    self.coreRouterPool = _coreRouterPool\n\n\n@view\n@external\ndef hasCapability(_action: ws.ActionType) -> bool:\n    return _action in (\n        ws.ActionType.SWAP |\n        ws.ActionType.ADD_LIQ_CONC | \n        ws.ActionType.REMOVE_LIQ_CONC\n    )\n\n\n@view\n@external\ndef onERC721Received(_operator: address, _owner: address, _tokenId: uint256, _data: Bytes[1024]) -> bytes4:\n    # must implement method for safe NFT transfers\n    assert _data == ERC721_RECEIVE_DATA # dev: did not receive from within Underscore wallet\n    return method_id(\"onERC721Received(address,address,uint256,bytes)\", output_type=bytes4)\n\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    return [AERO_SLIPSTREAM_FACTORY, AERO_SLIPSTREAM_NFT_MANAGER, AERO_SLIPSTREAM_QUOTER]\n\n\n@view\n@external\ndef isYieldLego() -> bool:\n    return False\n\n\n@view\n@external\ndef isDexLego() -> bool:\n    return True\n\n\n#########\n# Swaps #\n#########\n\n\n@external\ndef swapTokens(\n    _amountIn: uint256,\n    _minAmountOut: uint256,\n    _tokenPath: DynArray[address, MAX_TOKEN_PATH],\n    _poolPath: DynArray[address, MAX_TOKEN_PATH - 1],\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256):\n    assert not dld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = dld._getMiniAddys(_miniAddys)\n\n    # validate inputs\n    numTokens: uint256 = len(_tokenPath)\n    numPools: uint256 = len(_poolPath)\n    assert numTokens >= 2 # dev: invalid path\n    assert numPools == numTokens - 1 # dev: invalid path\n\n    # get first token and last token\n    tokenIn: address = _tokenPath[0]\n    tokenOut: address = _tokenPath[numTokens - 1]\n\n    # pre balances\n    preLegoBalance: uint256 = staticcall IERC20(tokenIn).balanceOf(self)\n\n    # transfer deposit asset to this contract\n    amountIn: uint256 = min(_amountIn, staticcall IERC20(tokenIn).balanceOf(msg.sender))\n    assert amountIn != 0 # dev: nothing to transfer\n    assert extcall IERC20(tokenIn).transferFrom(msg.sender, self, amountIn, default_return_value=True) # dev: transfer failed\n\n    # adjust min amount out\n    minAmountOut: uint256 = _minAmountOut\n    if amountIn < _amountIn and _amountIn != max_value(uint256):\n        minAmountOut = _minAmountOut * amountIn // _amountIn\n\n    # iterate through swap routes\n    aeroFactory: address = AERO_SLIPSTREAM_FACTORY\n    tempAmountIn: uint256 = amountIn\n    for i: uint256 in range(numTokens - 1, bound=MAX_TOKEN_PATH):\n        tempTokenIn: address = _tokenPath[i]\n        tempTokenOut: address = _tokenPath[i + 1]\n        tempPool: address = _poolPath[i]\n\n        # transfer to self (or to recipient if last swap)\n        recipient: address = _recipient\n        if i < numTokens - 2:\n            recipient = self\n\n        # swap\n        tempAmountIn = self._swapTokensInPool(tempPool, tempTokenIn, tempTokenOut, tempAmountIn, recipient, aeroFactory)\n\n    # final amount\n    amountOut: uint256 = tempAmountIn\n    assert amountOut >= minAmountOut # dev: min amount out not met\n\n    # refund if full swap didn't get through\n    currentLegoBalance: uint256 = staticcall IERC20(tokenIn).balanceOf(self)\n    refundAssetAmount: uint256 = 0\n    if currentLegoBalance > preLegoBalance:\n        refundAssetAmount = currentLegoBalance - preLegoBalance\n        assert extcall IERC20(tokenIn).transfer(msg.sender, refundAssetAmount, default_return_value=True) # dev: transfer failed\n        amountIn -= refundAssetAmount\n\n    # get usd values\n    usdValue: uint256 = extcall Appraiser(miniAddys.appraiser).updatePriceAndGetUsdValue(tokenIn, amountIn, miniAddys.missionControl, miniAddys.legoBook)\n    if usdValue == 0:\n        usdValue = extcall Appraiser(miniAddys.appraiser).updatePriceAndGetUsdValue(tokenOut, amountOut, miniAddys.missionControl, miniAddys.legoBook)\n\n    log AeroSlipStreamSwap(\n        sender = msg.sender,\n        tokenIn = tokenIn,\n        tokenOut = tokenOut,\n        amountIn = amountIn,\n        amountOut = amountOut,\n        usdValue = usdValue,\n        numTokens = numTokens,\n        recipient = _recipient,\n    )\n    return amountIn, amountOut, usdValue\n\n\n# swap in pool\n\n\n@internal\ndef _swapTokensInPool(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n    _recipient: address,\n    _aeroFactory: address,\n) -> uint256:\n    tokens: address[2] = [staticcall AeroSlipStreamPool(_pool).token0(), staticcall AeroSlipStreamPool(_pool).token1()]\n    assert _tokenIn in tokens # dev: invalid tokenIn\n    assert _tokenOut in tokens # dev: invalid tokenOut\n    assert _tokenIn != _tokenOut # dev: invalid tokens\n\n    # verify actual aero pool\n    assert staticcall AeroSlipStreamFactory(_aeroFactory).getPool(_tokenIn, _tokenOut, staticcall AeroSlipStreamPool(_pool).tickSpacing()) == _pool # dev: invalid pool\n\n    # save in transient storage (for use in callback)\n    self.poolSwapData = PoolSwapData(\n        pool=_pool,\n        tokenIn=_tokenIn,\n        amountIn=_amountIn,\n    )\n\n    zeroForOne: bool = _tokenIn == tokens[0]\n    sqrtPriceLimitX96: uint160 = MAX_SQRT_RATIO_MINUS_ONE\n    if zeroForOne:\n        sqrtPriceLimitX96 = MIN_SQRT_RATIO_PLUS_ONE\n\n    # perform swap\n    amount0: int256 = 0\n    amount1: int256 = 0\n    amount0, amount1 = extcall AeroSlipStreamPool(_pool).swap(_recipient, zeroForOne, convert(_amountIn, int256), sqrtPriceLimitX96, b\"\")\n\n    # check swap results\n    toAmount: uint256 = 0\n    if zeroForOne:\n        toAmount = convert(-amount1, uint256)\n    else:\n        toAmount = convert(-amount0, uint256)\n\n    assert toAmount != 0 # dev: no tokens swapped\n    return toAmount\n\n\n# callback\n\n\n@external\ndef uniswapV3SwapCallback(_amount0Delta: int256, _amount1Delta: int256, _data: Bytes[256]):\n    poolSwapData: PoolSwapData = self.poolSwapData\n    assert msg.sender == poolSwapData.pool # dev: no perms\n\n    # transfer tokens to pool\n    assert extcall IERC20(poolSwapData.tokenIn).transfer(poolSwapData.pool, poolSwapData.amountIn, default_return_value=True) # dev: transfer failed\n    self.poolSwapData = empty(PoolSwapData)\n\n\n#################\n# Add Liquidity #\n#################\n\n\n@external\ndef addLiquidityConcentrated(\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _tickLower: int24,\n    _tickUpper: int24,\n    _amountA: uint256,\n    _amountB: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, uint256, uint256):\n    assert not dld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = dld._getMiniAddys(_miniAddys)\n\n    # validate tokens\n    tokens: address[2] = [staticcall AeroSlipStreamPool(_pool).token0(), staticcall AeroSlipStreamPool(_pool).token1()]\n    assert _tokenA in tokens # dev: invalid tokenA\n    assert _tokenB in tokens # dev: invalid tokenB\n    assert _tokenA != _tokenB # dev: invalid tokens\n\n    # pre balances\n    preLegoBalanceA: uint256 = staticcall IERC20(_tokenA).balanceOf(self)\n    preLegoBalanceB: uint256 = staticcall IERC20(_tokenB).balanceOf(self)\n\n    # token a\n    liqAmountA: uint256 = min(_amountA, staticcall IERC20(_tokenA).balanceOf(msg.sender))\n    assert liqAmountA != 0 # dev: nothing to transfer\n    assert extcall IERC20(_tokenA).transferFrom(msg.sender, self, liqAmountA, default_return_value=True) # dev: transfer failed\n\n    # token b\n    liqAmountB: uint256 = min(_amountB, staticcall IERC20(_tokenB).balanceOf(msg.sender))\n    assert liqAmountB != 0 # dev: nothing to transfer\n    assert extcall IERC20(_tokenB).transferFrom(msg.sender, self, liqAmountB, default_return_value=True) # dev: transfer failed\n\n    # approvals\n    nftPositionManager: address = AERO_SLIPSTREAM_NFT_MANAGER\n    assert extcall IERC20(_tokenA).approve(nftPositionManager, liqAmountA, default_return_value=True) # dev: approval failed\n    assert extcall IERC20(_tokenB).approve(nftPositionManager, liqAmountB, default_return_value=True) # dev: approval failed\n\n    # organized the index of tokens\n    token0: address = _tokenA\n    token1: address = _tokenB\n    amount0: uint256 = liqAmountA\n    amount1: uint256 = liqAmountB\n    minAmount0: uint256 = _minAmountA\n    minAmount1: uint256 = _minAmountB\n    if tokens[0] != _tokenA:\n        token0 = _tokenB\n        token1 = _tokenA\n        amount0 = liqAmountB\n        amount1 = liqAmountA\n        minAmount0 = _minAmountB\n        minAmount1 = _minAmountA\n\n    # add liquidity\n    nftTokenId: uint256 = _nftTokenId\n    liquidityAdded: uint256 = 0\n    liquidityAddedInt128: uint128 = 0\n    if _nftTokenId == 0:\n        nftTokenId, liquidityAddedInt128, amount0, amount1 = self._mintNewPosition(nftPositionManager, _pool, token0, token1, _tickLower, _tickUpper, amount0, amount1, minAmount0, minAmount1, _recipient)\n    else:\n        liquidityAddedInt128, amount0, amount1 = self._increaseExistingPosition(nftPositionManager, _nftTokenId, amount0, amount1, minAmount0, minAmount1, _recipient)\n\n    liquidityAdded = convert(liquidityAddedInt128, uint256)\n    assert liquidityAdded != 0 # dev: no liquidity added\n\n    # reset approvals\n    assert extcall IERC20(_tokenA).approve(nftPositionManager, 0, default_return_value=True) # dev: approval failed\n    assert extcall IERC20(_tokenB).approve(nftPositionManager, 0, default_return_value=True) # dev: approval failed\n\n    # refund if full liquidity was not added\n    currentLegoBalanceA: uint256 = staticcall IERC20(_tokenA).balanceOf(self)\n    refundAssetAmountA: uint256 = 0\n    if currentLegoBalanceA > preLegoBalanceA:\n        refundAssetAmountA = currentLegoBalanceA - preLegoBalanceA\n        assert extcall IERC20(_tokenA).transfer(msg.sender, refundAssetAmountA, default_return_value=True) # dev: transfer failed\n\n    currentLegoBalanceB: uint256 = staticcall IERC20(_tokenB).balanceOf(self)\n    refundAssetAmountB: uint256 = 0\n    if currentLegoBalanceB > preLegoBalanceB:\n        refundAssetAmountB = currentLegoBalanceB - preLegoBalanceB\n        assert extcall IERC20(_tokenB).transfer(msg.sender, refundAssetAmountB, default_return_value=True) # dev: transfer failed\n\n    # a/b amounts\n    liqAmountA = amount0\n    liqAmountB = amount1\n    if tokens[0] != _tokenA:\n        liqAmountA = amount1\n        liqAmountB = amount0\n\n    usdValue: uint256 = self._getUsdValue(_tokenA, liqAmountA, _tokenB, liqAmountB, miniAddys)\n    log AeroSlipStreamLiquidityAdded(\n        sender = msg.sender,\n        tokenA = _tokenA,\n        tokenB = _tokenB,\n        amountA = liqAmountA,\n        amountB = liqAmountB,\n        liquidityAdded = liquidityAdded,\n        nftTokenId = nftTokenId,\n        usdValue = usdValue,\n        recipient = _recipient,\n    )\n    return liquidityAdded, liqAmountA, liqAmountB, nftTokenId, usdValue\n\n\n# mint new position\n\n\n@internal\ndef _mintNewPosition(\n    _nftPositionManager: address,\n    _pool: address,\n    _token0: address,\n    _token1: address,\n    _tickLower: int24,\n    _tickUpper: int24,\n    _amount0: uint256,\n    _amount1: uint256,\n    _minAmount0: uint256,\n    _minAmount1: uint256,\n    _recipient: address,\n) -> (uint256, uint128, uint256, uint256):\n    tickSpacing: int24 = staticcall AeroSlipStreamPool(_pool).tickSpacing()\n\n    tickLower: int24 = 0\n    tickUpper: int24 = 0\n    tickLower, tickUpper = self._getTicks(tickSpacing, _tickLower, _tickUpper)\n\n    # mint new position\n    params: MintParams = MintParams(\n        token0=_token0,\n        token1=_token1,\n        tickSpacing=tickSpacing,\n        tickLower=tickLower,\n        tickUpper=tickUpper,\n        amount0Desired=_amount0,\n        amount1Desired=_amount1,\n        amount0Min=_minAmount0,\n        amount1Min=_minAmount1,\n        recipient=_recipient,\n        deadline=block.timestamp,\n        sqrtPriceX96=0,\n    )\n    return extcall AeroNftPositionManager(_nftPositionManager).mint(params)\n\n\n# get ticks\n\n\n@view\n@internal\ndef _getTicks(_tickSpacing: int24, _tickLower: int24, _tickUpper: int24) -> (int24, int24):\n    tickLower: int24 = _tickLower\n    if _tickLower == min_value(int24):\n        tickLower = (TICK_LOWER // _tickSpacing) * _tickSpacing\n\n    tickUpper: int24 = _tickUpper\n    if _tickUpper == max_value(int24):\n        tickUpper = (TICK_UPPER // _tickSpacing) * _tickSpacing\n\n    return tickLower, tickUpper\n\n\n# increase existing position\n\n\n@internal\ndef _increaseExistingPosition(\n    _nftPositionManager: address,\n    _tokenId: uint256,\n    _amount0: uint256,\n    _amount1: uint256,\n    _minAmount0: uint256,\n    _minAmount1: uint256,\n    _recipient: address,\n) -> (uint128, uint256, uint256):\n    assert staticcall IERC721(_nftPositionManager).ownerOf(_tokenId) == self # dev: nft not here\n\n    liquidityAddedInt128: uint128 = 0\n    amount0: uint256 = 0\n    amount1: uint256 = 0\n    params: IncreaseLiquidityParams = IncreaseLiquidityParams(\n        tokenId=_tokenId,\n        amount0Desired=_amount0,\n        amount1Desired=_amount1,\n        amount0Min=_minAmount0,\n        amount1Min=_minAmount1,\n        deadline=block.timestamp,\n    )\n    liquidityAddedInt128, amount0, amount1 = extcall AeroNftPositionManager(_nftPositionManager).increaseLiquidity(params)\n\n    # collect fees (if applicable) -- must be done before transferring nft\n    positionData: PositionData = staticcall AeroNftPositionManager(_nftPositionManager).positions(_tokenId)\n    self._collectFees(_nftPositionManager, _tokenId, _recipient, positionData)\n\n    # transfer nft to recipient\n    extcall IERC721(_nftPositionManager).safeTransferFrom(self, _recipient, _tokenId)\n\n    return liquidityAddedInt128, amount0, amount1\n\n\n# collect fees\n\n\n@internal\ndef _collectFees(_nftPositionManager: address, _tokenId: uint256, _recipient: address, _positionData: PositionData) -> (uint256, uint256):\n    if _positionData.tokensOwed0 == 0 and _positionData.tokensOwed1 == 0:\n        return 0, 0\n\n    params: CollectParams = CollectParams(\n        tokenId=_tokenId,\n        recipient=_recipient,\n        amount0Max=max_value(uint128),\n        amount1Max=max_value(uint128),\n    )\n    return extcall AeroNftPositionManager(_nftPositionManager).collect(params)\n\n\n####################\n# Remove Liquidity #\n####################\n\n\n@external\ndef removeLiquidityConcentrated(\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _liqToRemove: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, bool, uint256):\n    assert not dld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = dld._getMiniAddys(_miniAddys)\n\n    # make sure nft is here\n    nftPositionManager: address = AERO_SLIPSTREAM_NFT_MANAGER\n    assert staticcall IERC721(nftPositionManager).ownerOf(_nftTokenId) == self # dev: nft not here\n\n    # get position data\n    positionData: PositionData = staticcall AeroNftPositionManager(nftPositionManager).positions(_nftTokenId)\n    originalLiquidity: uint128 = positionData.liquidity\n\n    # validate tokens\n    tokens: address[2] = [positionData.token0, positionData.token1]\n    assert _tokenA in tokens # dev: invalid tokenA\n    assert _tokenB in tokens # dev: invalid tokenB\n    assert _tokenA != _tokenB # dev: invalid tokens\n\n    # organized the index of tokens\n    minAmount0: uint256 = _minAmountA\n    minAmount1: uint256 = _minAmountB\n    if _tokenA != tokens[0]:\n        minAmount0 = _minAmountB\n        minAmount1 = _minAmountA\n\n    # decrease liquidity\n    liqToRemove: uint256 = min(_liqToRemove, convert(positionData.liquidity, uint256))\n    assert liqToRemove != 0 # dev: no liquidity to remove\n\n    params: DecreaseLiquidityParams = DecreaseLiquidityParams(\n        tokenId=_nftTokenId,\n        liquidity=convert(liqToRemove, uint128),\n        amount0Min=minAmount0,\n        amount1Min=minAmount1,\n        deadline=block.timestamp,\n    )\n    amount0: uint256 = 0\n    amount1: uint256 = 0\n    amount0, amount1 = extcall AeroNftPositionManager(nftPositionManager).decreaseLiquidity(params)\n    assert amount0 != 0 and amount1 != 0 # dev: no liquidity removed\n\n    # a/b amounts\n    amountA: uint256 = amount0\n    amountB: uint256 = amount1\n    if _tokenA != tokens[0]:\n        amountA = amount1\n        amountB = amount0\n\n    # get latest position data -- collect withdrawn tokens AND any fees (if applicable)\n    positionData = staticcall AeroNftPositionManager(nftPositionManager).positions(_nftTokenId)\n    self._collectFees(nftPositionManager, _nftTokenId, _recipient, positionData)\n\n    # burn nft (if applicable)\n    isDepleted: bool = False\n    if positionData.liquidity == 0:\n        isDepleted = True\n        extcall AeroNftPositionManager(nftPositionManager).burn(_nftTokenId)\n\n    # transfer nft to recipient\n    else:\n        extcall IERC721(nftPositionManager).safeTransferFrom(self, _recipient, _nftTokenId)\n\n    usdValue: uint256 = self._getUsdValue(_tokenA, amountA, _tokenB, amountB, miniAddys)\n    liquidityRemoved: uint256 = convert(originalLiquidity - positionData.liquidity, uint256)\n    log AeroSlipStreamLiquidityRemoved(\n        sender = msg.sender,\n        pool = _pool,\n        nftTokenId = _nftTokenId,\n        tokenA = _tokenA,\n        tokenB = _tokenB,\n        amountA = amountA,\n        amountB = amountB,\n        liquidityRemoved = liquidityRemoved,\n        usdValue = usdValue,\n        recipient = _recipient,\n    )\n    return amountA, amountB, liquidityRemoved, isDepleted, usdValue\n\n\n# get usd value on liquidity actions\n\n\n@internal\ndef _getUsdValue(\n    _tokenA: address,\n    _amountA: uint256,\n    _tokenB: address,\n    _amountB: uint256,\n    _miniAddys: ws.MiniAddys,\n) -> uint256:\n\n    usdValueA: uint256 = 0\n    if _amountA != 0:\n        usdValueA = extcall Appraiser(_miniAddys.appraiser).updatePriceAndGetUsdValue(_tokenA, _amountA, _miniAddys.missionControl, _miniAddys.legoBook)\n\n    usdValueB: uint256 = 0\n    if _amountB != 0:\n        usdValueB = extcall Appraiser(_miniAddys.appraiser).updatePriceAndGetUsdValue(_tokenB, _amountB, _miniAddys.missionControl, _miniAddys.legoBook)\n\n    return usdValueA + usdValueB\n\n\n#############\n# Utilities #\n#############\n\n\n@view\n@external\ndef getLpToken(_pool: address) -> address:\n    # no lp tokens for aero slipstream (uni v3)\n    return empty(address)\n\n\n@view\n@external\ndef getPoolForLpToken(_lpToken: address) -> address:\n    # no lp tokens for aero slipstream (uni v3)\n    return empty(address)\n\n\n@view\n@external\ndef getCoreRouterPool() -> address:\n    return self.coreRouterPool\n\n\n@view\n@external\ndef getDeepestLiqPool(_tokenA: address, _tokenB: address) -> BestPool:\n    bestPoolAddr: address = empty(address)\n    na: int24 = 0\n    bestPoolAddr, na = self._getDeepestLiqPool(_tokenA, _tokenB)\n\n    if bestPoolAddr == empty(address):\n        return empty(BestPool)\n\n    # get token balances\n    tokenABal: uint256 = staticcall IERC20(_tokenA).balanceOf(bestPoolAddr)\n    tokenBBal: uint256 = staticcall IERC20(_tokenB).balanceOf(bestPoolAddr)\n\n    return BestPool(\n        pool=bestPoolAddr,\n        fee=convert(staticcall AeroSlipStreamPool(bestPoolAddr).fee() // 100, uint256), # normalize to have 100_00 denominator\n        liquidity=tokenABal + tokenBBal, # not exactly \"liquidity\" but this comparable to \"reserves\"\n        numCoins=2,\n    )\n\n\n# annoying that this cannot be view function, thanks uni v3\n@external\ndef getBestSwapAmountOut(_tokenIn: address, _tokenOut: address, _amountIn: uint256) -> (address, uint256):\n    bestPoolAddr: address = empty(address)\n    bestTickSpacing: int24 = 0\n    bestPoolAddr, bestTickSpacing = self._getDeepestLiqPool(_tokenIn, _tokenOut)\n    if bestPoolAddr == empty(address):\n        return empty(address), 0\n\n    amountOut: uint256 = 0\n    na1: uint160 = 0\n    na2: uint32 = 0\n    na3: uint256 = 0\n    amountOut, na1, na2, na3 = extcall AeroQuoter(AERO_SLIPSTREAM_QUOTER).quoteExactInputSingle(\n        QuoteExactInputSingleParams(\n            tokenIn=_tokenIn,\n            tokenOut=_tokenOut,\n            amountIn=_amountIn,\n            tickSpacing=bestTickSpacing,\n            sqrtPriceLimitX96=0,\n        )\n    )\n    return bestPoolAddr, amountOut\n\n\n# annoying that this cannot be view function, thanks uni v3\n@external\ndef getSwapAmountOut(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n) -> uint256:\n    amountOut: uint256 = 0\n    na1: uint160 = 0\n    na2: uint32 = 0\n    na3: uint256 = 0\n    amountOut, na1, na2, na3 = extcall AeroQuoter(AERO_SLIPSTREAM_QUOTER).quoteExactInputSingle(\n        QuoteExactInputSingleParams(\n            tokenIn=_tokenIn,\n            tokenOut=_tokenOut,\n            amountIn=_amountIn,\n            tickSpacing=staticcall AeroSlipStreamPool(_pool).tickSpacing(),\n            sqrtPriceLimitX96=0,\n        )\n    )\n    return amountOut\n\n\n# annoying that this cannot be view function, thanks uni v3\n@external\ndef getBestSwapAmountIn(_tokenIn: address, _tokenOut: address, _amountOut: uint256) -> (address, uint256):\n    if _amountOut == 0 or _amountOut == max_value(uint256):\n        return empty(address), max_value(uint256)\n\n    bestPoolAddr: address = empty(address)\n    bestTickSpacing: int24 = 0\n    bestPoolAddr, bestTickSpacing = self._getDeepestLiqPool(_tokenIn, _tokenOut)\n    if bestPoolAddr == empty(address):\n        return empty(address), 0\n\n    amountIn: uint256 = 0\n    na1: uint160 = 0\n    na2: uint32 = 0\n    na3: uint256 = 0\n    amountIn, na1, na2, na3 = extcall AeroQuoter(AERO_SLIPSTREAM_QUOTER).quoteExactOutputSingle(\n        QuoteExactOutputSingleParams(\n            tokenIn=_tokenIn,\n            tokenOut=_tokenOut,\n            amount=_amountOut,\n            tickSpacing=bestTickSpacing,\n            sqrtPriceLimitX96=0,\n        )\n    )\n    return bestPoolAddr, amountIn\n\n\n# annoying that this cannot be view function, thanks uni v3\n@external\ndef getSwapAmountIn(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountOut: uint256,\n) -> uint256:\n    if _amountOut == 0 or _amountOut == max_value(uint256):\n        return max_value(uint256)\n\n    amountIn: uint256 = 0\n    na1: uint160 = 0\n    na2: uint32 = 0\n    na3: uint256 = 0\n    amountIn, na1, na2, na3 = extcall AeroQuoter(AERO_SLIPSTREAM_QUOTER).quoteExactOutputSingle(\n        QuoteExactOutputSingleParams(\n            tokenIn=_tokenIn,\n            tokenOut=_tokenOut,\n            amount=_amountOut,\n            tickSpacing=staticcall AeroSlipStreamPool(_pool).tickSpacing(),\n            sqrtPriceLimitX96=0,\n        )\n    )\n    return amountIn\n\n\n@view\n@external\ndef getAddLiqAmountsIn(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _availAmountA: uint256,\n    _availAmountB: uint256,\n) -> (uint256, uint256, uint256):\n    token0: address = staticcall AeroSlipStreamPool(_pool).token0()\n\n    # get correct numerator and denominator\n    numerator: uint256 = 0\n    denominator: uint256 = 0\n    sqrtPriceX96Squared: uint256 = self._getSqrtPriceX96(_pool) ** 2\n    if _tokenA == token0:\n        numerator = sqrtPriceX96Squared\n        denominator = UNISWAP_Q96 ** 2\n    else:\n        numerator = UNISWAP_Q96 ** 2\n        denominator = sqrtPriceX96Squared\n\n    # calculate optimal amounts\n    amountA: uint256 = _availAmountA\n    amountB: uint256 = _availAmountA * numerator // denominator\n    if amountB > _availAmountB:\n        maybeAmountA: uint256 = _availAmountB * denominator // numerator\n        if maybeAmountA <= _availAmountA:\n            amountA = maybeAmountA\n            amountB = _availAmountB\n    return amountA, amountB, 0\n\n\n@view\n@external\ndef getRemoveLiqAmountsOut(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpAmount: uint256,\n) -> (uint256, uint256):\n    token0: address = staticcall AeroSlipStreamPool(_pool).token0()\n\n    # calculate expected amounts out\n    sqrtPriceX96: uint256 = self._getSqrtPriceX96(_pool)\n    amount0Out: uint256 = _lpAmount * UNISWAP_Q96 // sqrtPriceX96\n    amount1Out: uint256 = _lpAmount * sqrtPriceX96 // UNISWAP_Q96\n\n    # return amounts out\n    if _tokenA == token0:\n        return amount0Out, amount1Out\n    else:\n        return amount1Out, amount0Out\n\n\n@view\n@external\ndef getPrice(_asset: address, _decimals: uint256) -> uint256:\n    return 0 # TODO: implement price\n\n\n@view\n@external\ndef getPriceUnsafe(_pool: address, _targetToken: address, _appraiser: address = empty(address)) -> uint256:\n    token0: address = staticcall AeroSlipStreamPool(_pool).token0()\n    token1: address = staticcall AeroSlipStreamPool(_pool).token1()\n\n    # appraiser\n    appraiser: address = _appraiser\n    if _appraiser == empty(address):\n        appraiser = addys._getAppraiserAddr()\n\n    # alt price\n    altPrice: uint256 = 0\n    if _targetToken == token0:\n        altPrice = staticcall Appraiser(appraiser).getNormalAssetPrice(token1)\n    else:\n        altPrice = staticcall Appraiser(appraiser).getNormalAssetPrice(token0)\n\n    # return early if no alt price\n    if altPrice == 0:\n        return 0\n\n    # price of token0 in token1\n    sqrtPriceX96: uint256 = self._getSqrtPriceX96(_pool)\n    numerator: uint256 = sqrtPriceX96 ** 2 * EIGHTEEN_DECIMALS\n    priceZeroToOne: uint256 = numerator // (UNISWAP_Q96 ** 2)\n\n    # adjust for decimals: price should be in 18 decimals\n    decimals0: uint256 = convert(staticcall IERC20Detailed(token0).decimals(), uint256)\n    decimals1: uint256 = convert(staticcall IERC20Detailed(token1).decimals(), uint256)\n    if decimals0 > decimals1:\n        scaleFactor: uint256 = 10 ** (decimals0 - decimals1)\n        priceZeroToOne = priceZeroToOne * scaleFactor\n    elif decimals1 > decimals0:\n        scaleFactor: uint256 = 10 ** (decimals1 - decimals0)\n        priceZeroToOne = priceZeroToOne // scaleFactor\n\n    # if _targetToken is token1, make price inverse\n    priceToOther: uint256 = priceZeroToOne\n    if _targetToken == token1:\n        priceToOther = EIGHTEEN_DECIMALS * EIGHTEEN_DECIMALS // priceZeroToOne\n\n    return altPrice * priceToOther // EIGHTEEN_DECIMALS\n\n\n# internal utils\n\n\n@view\n@internal\ndef _getDeepestLiqPool(_tokenA: address, _tokenB: address) -> (address, int24):\n    bestPoolAddr: address = empty(address)\n    bestTickSpacing: int24 = 0\n    bestLiquidity: uint128 = 0\n\n    factory: address = AERO_SLIPSTREAM_FACTORY\n    for i: uint256 in range(5):\n        tickSpacing: int24 = TICK_SPACING[i]\n        pool: address = staticcall AeroSlipStreamFactory(factory).getPool(_tokenA, _tokenB, tickSpacing)\n        if pool == empty(address):\n            continue\n        liquidity: uint128 = staticcall AeroSlipStreamPool(pool).liquidity()\n        if liquidity > bestLiquidity:\n            bestPoolAddr = pool\n            bestTickSpacing = tickSpacing\n            bestLiquidity = liquidity\n\n    return bestPoolAddr, bestTickSpacing\n\n\n@view\n@internal\ndef _getSqrtPriceX96(_pool: address) -> uint256:\n    sqrtPriceX96: uint160 = 0\n    tick: int24 = 0\n    observationIndex: uint16 = 0\n    observationCardinality: uint16 = 0\n    observationCardinalityNext: uint16 = 0\n    unlocked: bool = False\n    sqrtPriceX96, tick, observationIndex, observationCardinality, observationCardinalityNext, unlocked = staticcall AeroSlipStreamPool(_pool).slot0()\n    return convert(sqrtPriceX96, uint256)\n\n\n# nft recovery\n\n\n@external\ndef recoverNft(_collection: address, _nftTokenId: uint256, _recipient: address) -> bool:\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n\n    if staticcall IERC721(_collection).ownerOf(_nftTokenId) != self:\n        return False\n\n    extcall IERC721(_collection).safeTransferFrom(self, _recipient, _nftTokenId)\n    log AeroSlipStreamNftRecovered(collection=_collection, nftTokenId=_nftTokenId, recipient=_recipient)\n    return True\n\n\n#########\n# Other #\n#########\n\n\n@external\ndef depositForYield(\n    _asset: address,\n    _amount: uint256,\n    _vaultAddr: address,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, address, uint256, uint256):\n    return 0, empty(address), 0, 0\n\n\n@external\ndef withdrawFromYield(\n    _vaultToken: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, address, uint256, uint256):\n    return 0, empty(address), 0, 0\n\n\n@external\ndef mintOrRedeemAsset(\n    _tokenIn: address,\n    _tokenOut: address,\n    _tokenInAmount: uint256,\n    _minAmountOut: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, bool, uint256):\n    return 0, 0, False, 0\n\n\n@external\ndef confirmMintOrRedeemAsset(\n    _tokenIn: address,\n    _tokenOut: address,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef addCollateral(\n    _asset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef removeCollateral(\n    _asset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef borrow(\n    _borrowAsset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef repayDebt(\n    _paymentAsset: address,\n    _paymentAmount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef claimRewards(\n    _user: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _extraData: bytes32,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n@external\ndef addLiquidity(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _amountA: uint256,\n    _amountB: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _minLpAmount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (address, uint256, uint256, uint256, uint256):\n    return empty(address), 0, 0, 0, 0\n\n\n@external\ndef removeLiquidity(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpToken: address,\n    _lpAmount: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, uint256):\n    return 0, 0, 0, 0\n\n\n@view\n@external\ndef getAccessForLego(_user: address, _action: ws.ActionType) -> (address, String[64], uint256):\n    return empty(address), empty(String[64]), 0\n",
            "sha256sum": "e227e3edbe97ff51db4d8d42e6765db2bf98f38c9d165d95eed9a4af23f157da"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/legos/dexes/AeroSlipstream.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.3+commit.bff19ea2",
        "integrity": "f03b5c40781b78af541b21f4ae46e7e0c611715836bc3d43178c794f42030a8b"
      },
      "args": "00000000000000000000000044cf3c4f000dfd76a35d03298049d37be688d6f90000000000000000000000005e7bb104d84c7cb9b682aac2f3d509f5f406809a000000000000000000000000827922686190790b37229fd06084350e74485b72000000000000000000000000254cf9e1e6e233aa1ac962cb9b05b2cfeaae15b0000000000000000000000000b2cc224c1c9fee385f8ad6a55b4d94e92359dc59",
      "file": "contracts/legos/dexes/AeroSlipstream.vy"
    },
    "Curve": {
      "address": "0x4e085F8f98f7133B441CEBd54Eab25CB14472b52",
      "abi": [
        {
          "name": "CurveSwap",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenIn",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenOut",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amountIn",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "amountOut",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "numTokens",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "CurveLiquidityAdded",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenA",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenB",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amountA",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "amountB",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "lpAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "CurveLiquidityRemoved",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": false
            },
            {
              "name": "pool",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenA",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenB",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amountA",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "amountB",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "lpToken",
              "type": "address",
              "indexed": false
            },
            {
              "name": "lpAmountBurned",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LegoPauseModified",
          "inputs": [
            {
              "name": "isPaused",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LegoFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "balance",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddys",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "undyToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "hatchery",
                  "type": "address"
                },
                {
                  "name": "lootDistributor",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                },
                {
                  "name": "walletBackpack",
                  "type": "address"
                },
                {
                  "name": "billing",
                  "type": "address"
                },
                {
                  "name": "vaultRegistry",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUndyHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pause",
          "inputs": [
            {
              "name": "_shouldPause",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFundsMany",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_assets",
              "type": "address[]"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "legoId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isPaused",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasCapability",
          "inputs": [
            {
              "name": "_action",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRegistries",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isYieldLego",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isDexLego",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_tokenPath",
              "type": "address[]"
            },
            {
              "name": "_poolPath",
              "type": "address[]"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_tokenPath",
              "type": "address[]"
            },
            {
              "name": "_poolPath",
              "type": "address[]"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLpToken",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPoolForLpToken",
          "inputs": [
            {
              "name": "_lpToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getCoreRouterPool",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getDeepestLiqPool",
          "inputs": [
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "fee",
                  "type": "uint256"
                },
                {
                  "name": "liquidity",
                  "type": "uint256"
                },
                {
                  "name": "numCoins",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getBestSwapAmountOut",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountIn",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getSwapAmountOut",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountIn",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getBestSwapAmountIn",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountOut",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getSwapAmountIn",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountOut",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddLiqAmountsIn",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_availAmountA",
              "type": "uint256"
            },
            {
              "name": "_availAmountB",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRemoveLiqAmountsOut",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPrice",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_decimals",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPriceUnsafe",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_targetToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPriceUnsafe",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_targetToken",
              "type": "address"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAccessForLego",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_action",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "string"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "CURVE_META_REGISTRY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "CURVE_REGISTRIES",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "StableSwapNg",
                  "type": "address"
                },
                {
                  "name": "TwoCryptoNg",
                  "type": "address"
                },
                {
                  "name": "TricryptoNg",
                  "type": "address"
                },
                {
                  "name": "TwoCrypto",
                  "type": "address"
                },
                {
                  "name": "MetaPool",
                  "type": "address"
                },
                {
                  "name": "RateProvider",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_undyHq",
              "type": "address"
            },
            {
              "name": "_curveAddressProvider",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "interfaces/WalletStructs.vyi": {
            "content": "# @version 0.4.3\n\nflag ActionType:\n    TRANSFER\n    EARN_DEPOSIT\n    EARN_WITHDRAW\n    EARN_REBALANCE\n    SWAP\n    MINT_REDEEM\n    CONFIRM_MINT_REDEEM\n    ADD_COLLATERAL\n    REMOVE_COLLATERAL\n    BORROW\n    REPAY_DEBT\n    REWARDS\n    ETH_TO_WETH\n    WETH_TO_ETH\n    ADD_LIQ\n    REMOVE_LIQ\n    ADD_LIQ_CONC\n    REMOVE_LIQ_CONC\n    PAY_CHEQUE\n\nstruct WalletAssetData:\n    assetBalance: uint256\n    usdValue: uint256\n    isYieldAsset: bool\n    lastPricePerShare: uint256\n\nstruct ActionData:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    billing: address\n    wallet: address\n    walletConfig: address\n    walletOwner: address\n    inEjectMode: bool\n    isFrozen: bool\n    lastTotalUsdValue: uint256\n    signer: address\n    isManager: bool\n    legoId: uint256\n    legoAddr: address\n    eth: address\n    weth: address\n\nstruct MiniAddys:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    appraiser: address",
            "sha256sum": "9a4b4f59b3a62043e51b425a665064aae419a3c0bd0514b6b29a9441ae364bb9"
          },
          "interfaces/LegoPartner.vyi": {
            "content": "# @version 0.4.3\n\nfrom interfaces import WalletStructs as ws\n\nMAX_TOKEN_PATH: constant(uint256) = 5\nMAX_RECOVER_ASSETS: constant(uint256) = 20\n\n@external\ndef addLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _tickLower: int24, _tickUpper: int24, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef addLiquidity(_pool: address, _tokenA: address, _tokenB: address, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _minLpAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (address, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef removeLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _liqToRemove: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef removeLiquidity(_pool: address, _tokenA: address, _tokenB: address, _lpToken: address, _lpAmount: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef mintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _tokenInAmount: uint256, _minAmountOut: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef swapTokens(_amountIn: uint256, _minAmountOut: uint256, _tokenPath: DynArray[address, MAX_TOKEN_PATH], _poolPath: DynArray[address, MAX_TOKEN_PATH - 1], _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256):\n    ...\n\n@external\ndef depositForYield(_asset: address, _amount: uint256, _vaultAddr: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef withdrawFromYield(_vaultToken: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef confirmMintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef borrow(_borrowAsset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef repayDebt(_paymentAsset: address, _paymentAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef claimRewards(_user: address, _rewardToken: address, _rewardAmount: uint256, _extraData: bytes32, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef removeCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef addCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@view\n@external\ndef getAccessForLego(_user: address, _action: ws.ActionType) -> (address, String[64], uint256):\n    ...\n\n@view\n@external\ndef hasCapability(_action: ws.ActionType) -> bool:\n    ...\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    ...\n\n@view\n@external\ndef isYieldLego() -> bool:\n    ...\n\n@view\n@external\ndef isDexLego() -> bool:\n    ...\n\n\n# common\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "81db71fe4440a3b4b563134c9b5caf1d5705772a5f291fe874c9b5fb3cfb1623"
          },
          "interfaces/DexLego.vyi": {
            "content": "# @version 0.4.3\n\n# used in smart contracts\n\n\n@view\n@external\ndef getLpToken(_pool: address) -> address:\n    ...\n\n\n# helper functions for server\n\n\n@view\n@external\ndef getPoolForLpToken(_lpToken: address) -> address:\n    ...\n\n\n@view\n@external\ndef getSwapAmountOut(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n) -> uint256:\n    ...\n\n\n@view\n@external\ndef getSwapAmountIn(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountOut: uint256,\n) -> uint256:\n    ...\n\n\n@view\n@external\ndef getAddLiqAmountsIn(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _availAmountA: uint256,\n    _availAmountB: uint256,\n) -> (uint256, uint256, uint256):\n    ...\n\n\n@view\n@external\ndef getRemoveLiqAmountsOut(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpAmount: uint256,\n) -> (uint256, uint256):\n    ...\n\n\n@view\n@external\ndef getPriceUnsafe(_pool: address, _targetToken: address, _appraiser: address = empty(address)) -> uint256:\n    ...\n\n\n@view\n@external\ndef getBestSwapAmountOut(_tokenIn: address, _tokenOut: address, _amountIn: uint256) -> (address, uint256):\n    ...\n\n\n@view\n@external\ndef getBestSwapAmountIn(_tokenIn: address, _tokenOut: address, _amountOut: uint256) -> (address, uint256):\n    ...\n\n\n@view\n@external\ndef getCoreRouterPool() -> address:\n    ...\n\n\n@view\n@external\ndef getPrice(_asset: address, _decimals: uint256) -> uint256:\n    ...\n",
            "sha256sum": "6248ad46926f00481cb3469bfc7af8fe36669c2ca0dd98e9a0befdda0fc43fd7"
          },
          "contracts/modules/Addys.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\ninterface UndyHq:\n    def isValidAddr(_addr: address) -> bool: view\n    def getAddr(_regId: uint256) -> address: view\n    def undyToken() -> address: view\n\ninterface Switchboard:\n    def isSwitchboardAddr(_addr: address) -> bool: view\n\ninterface LegoBook:\n    def isLegoAddr(_addr: address) -> bool: view\n\nstruct Addys:\n    hq: address\n    undyToken: address\n    ledger: address\n    missionControl: address\n    legoBook: address\n    switchboard: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    walletBackpack: address\n    billing: address\n    vaultRegistry: address\n\n# hq\nUNDY_HQ_FOR_ADDYS: immutable(address)\n\n# core addys\nLEDGER_ID: constant(uint256) = 1\nMISSION_CONTROL_ID: constant(uint256) = 2\nLEGO_BOOK_ID: constant(uint256) = 3\nSWITCHBOARD_ID: constant(uint256) = 4\nHATCHERY_ID: constant(uint256) = 5\nLOOT_DISTRIBUTOR_ID: constant(uint256) = 6\nAPPRAISER_ID: constant(uint256) = 7\nWALLET_BACKPACK_ID: constant(uint256) = 8\nBILLING_ID: constant(uint256) = 9\nVAULT_REGISTRY_ID: constant(uint256) = 10\n\n\n@deploy\ndef __init__(_undyHq: address):\n    assert _undyHq != empty(address) # dev: invalid undy hq\n    UNDY_HQ_FOR_ADDYS = _undyHq\n\n\n########\n# Core #\n########\n\n\n@view\n@external\ndef getAddys() -> Addys:\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _getAddys(_addys: Addys = empty(Addys)) -> Addys:\n    if _addys.hq != empty(address):\n        return _addys\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _generateAddys() -> Addys:\n    hq: address = UNDY_HQ_FOR_ADDYS\n    return Addys(\n        hq = hq,\n        undyToken = staticcall UndyHq(hq).undyToken(),\n        ledger = staticcall UndyHq(hq).getAddr(LEDGER_ID),\n        missionControl = staticcall UndyHq(hq).getAddr(MISSION_CONTROL_ID),\n        legoBook = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID),\n        switchboard = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID),\n        hatchery = staticcall UndyHq(hq).getAddr(HATCHERY_ID),\n        lootDistributor = staticcall UndyHq(hq).getAddr(LOOT_DISTRIBUTOR_ID),\n        appraiser = staticcall UndyHq(hq).getAddr(APPRAISER_ID),\n        walletBackpack = staticcall UndyHq(hq).getAddr(WALLET_BACKPACK_ID),\n        billing = staticcall UndyHq(hq).getAddr(BILLING_ID),\n        vaultRegistry = staticcall UndyHq(hq).getAddr(VAULT_REGISTRY_ID),\n    )\n\n\n##########\n# Tokens #\n##########\n\n\n@view\n@internal\ndef _getUndyToken() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).undyToken()\n\n\n###########\n# Helpers #\n###########\n\n\n# undy hq\n\n\n@view\n@external\ndef getUndyHq() -> address:\n    return self._getUndyHq()\n\n\n@view\n@internal\ndef _getUndyHq() -> address:\n    return UNDY_HQ_FOR_ADDYS\n\n\n# utils\n\n\n@view\n@internal\ndef _isValidUndyAddr(_addr: address, _hq: address = empty(address)) -> bool:\n    hq: address = _hq\n    if _hq == empty(address):\n        hq = UNDY_HQ_FOR_ADDYS\n    \n    # core departments\n    if staticcall UndyHq(hq).isValidAddr(_addr):\n        return True\n\n    # lego book\n    legoBook: address = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID)\n    if legoBook != empty(address) and staticcall LegoBook(legoBook).isLegoAddr(_addr):\n        return True\n\n    # switchboard config\n    switchboard: address = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID)\n    if switchboard != empty(address) and staticcall Switchboard(switchboard).isSwitchboardAddr(_addr):\n        return True\n\n    return False\n\n\n@view\n@internal\ndef _isSwitchboardAddr(_addr: address) -> bool:\n    switchboard: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n    if switchboard == empty(address):\n        return False\n    return staticcall Switchboard(switchboard).isSwitchboardAddr(_addr)\n\n\n@view\n@internal\ndef _isLegoBookAddr(_addr: address) -> bool:\n    legoBook: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n    if legoBook == empty(address):\n        return False\n    return staticcall LegoBook(legoBook).isLegoAddr(_addr)\n\n\n###############\n# Departments #\n###############\n\n\n# ledger\n\n\n@view\n@internal\ndef _getLedgerId() -> uint256:\n    return LEDGER_ID\n\n\n@view\n@internal\ndef _getLedgerAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEDGER_ID)\n\n\n# mission control\n\n\n@view\n@internal\ndef _getMissionControlId() -> uint256:\n    return MISSION_CONTROL_ID\n\n\n@view\n@internal\ndef _getMissionControlAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(MISSION_CONTROL_ID)\n\n\n# lego book\n\n\n@view\n@internal\ndef _getLegoBookId() -> uint256:\n    return LEGO_BOOK_ID\n\n\n@view\n@internal\ndef _getLegoBookAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n\n\n# switchboard\n\n\n@view\n@internal\ndef _getSwitchboardId() -> uint256:\n    return SWITCHBOARD_ID\n\n\n@view\n@internal\ndef _getSwitchboardAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n\n\n# hatchery\n\n\n@view\n@internal\ndef _getHatcheryId() -> uint256:\n    return HATCHERY_ID\n\n\n@view\n@internal\ndef _getHatcheryAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(HATCHERY_ID)\n\n\n# loot distributor\n\n\n@view\n@internal\ndef _getLootDistributorId() -> uint256:\n    return LOOT_DISTRIBUTOR_ID\n\n\n@view\n@internal\ndef _getLootDistributorAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LOOT_DISTRIBUTOR_ID)\n\n\n# appraiser\n\n\n@view\n@internal\ndef _getAppraiserId() -> uint256:\n    return APPRAISER_ID\n\n\n@view\n@internal\ndef _getAppraiserAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(APPRAISER_ID)\n\n\n# wallet backpack\n\n\n@view\n@internal\ndef _getWalletBackpackId() -> uint256:\n    return WALLET_BACKPACK_ID\n\n\n@view\n@internal\ndef _getWalletBackpackAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(WALLET_BACKPACK_ID)\n\n\n# billing\n\n\n@view\n@internal\ndef _getBillingId() -> uint256:\n    return BILLING_ID\n\n\n@view\n@internal\ndef _getBillingAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(BILLING_ID)\n\n\n# vault registry\n\n\n@view\n@internal\ndef _getVaultRegistryId() -> uint256:\n    return VAULT_REGISTRY_ID\n\n\n@view\n@internal\ndef _getVaultRegistryAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(VAULT_REGISTRY_ID)",
            "sha256sum": "4df6b72db9bb417d1af81660175be1450cfb7b3575f3d17a5b8a130bff87b781"
          },
          "contracts/modules/DexLegoData.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nuses: addys\n\nimport contracts.modules.Addys as addys\n\nfrom interfaces import WalletStructs as ws\nfrom ethereum.ercs import IERC20\n\nevent LegoPauseModified:\n    isPaused: bool\n\nevent LegoFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    balance: uint256\n\n# config\nlegoId: public(uint256)\nisPaused: public(bool)\n\nMAX_RECOVER_ASSETS: constant(uint256) = 20\n\n\n@deploy\ndef __init__(_shouldPause: bool):\n    self.isPaused = _shouldPause\n\n\n###########\n# General #\n###########\n\n\n# fill mini addys\n\n\n@view\n@internal\ndef _getMiniAddys(_miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> ws.MiniAddys:\n    if _miniAddys.ledger != empty(address):\n        return _miniAddys\n    return ws.MiniAddys(\n        ledger = addys._getLedgerAddr(),\n        missionControl = addys._getMissionControlAddr(),\n        legoBook = addys._getLegoBookAddr(),\n        appraiser = addys._getAppraiserAddr(),\n    )\n\n\n# activate\n\n\n@external\ndef pause(_shouldPause: bool):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert _shouldPause != self.isPaused # dev: no change\n    self.isPaused = _shouldPause\n    log LegoPauseModified(isPaused=_shouldPause)\n\n\n# recover funds\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    self._recoverFunds(_recipient, _asset)\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, MAX_RECOVER_ASSETS]):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    for a: address in _assets:\n        self._recoverFunds(_recipient, a)\n\n\n@internal\ndef _recoverFunds(_recipient: address, _asset: address):\n    assert empty(address) not in [_recipient, _asset] # dev: invalid recipient or asset\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    assert balance != 0 # dev: nothing to recover\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log LegoFundsRecovered(asset=_asset, recipient=_recipient, balance=balance)",
            "sha256sum": "75b15af2475ab409d4b5fd057509d14c20564ebd7fcb0850e3b61397d8e3af48"
          },
          "contracts/legos/dexes/Curve.vy": {
            "content": "#     _____  _____  __  __    ____   _____  _____  _____ \n#    |  _  \\/   __\\/  \\/  \\  /  _/  /   __\\/   __\\/  _  \\\n#    |  |  ||   __|>-    -<  |  |---|   __||  |_ ||  |  |\n#    |_____/\\_____/\\__/\\__/  \\_____/\\_____/\\_____/\\_____/\n#                                                                       \n#     \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n#     \u2551  ** Curve Lego **              \u2551\n#     \u2551  Integration with Curve DEX.   \u2551\n#     \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n#\n#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n# pragma optimize codesize\n\nimplements: DexLego\n\nexports: addys.__interface__\nexports: dld.__interface__\n\ninitializes: addys\ninitializes: dld[addys := addys]\n\nfrom interfaces import LegoPartner as Lego\nfrom interfaces import DexLego as DexLego\nfrom interfaces import WalletStructs as ws\n\nimport contracts.modules.Addys as addys\nimport contracts.modules.DexLegoData as dld\n\nfrom ethereum.ercs import IERC20\nfrom ethereum.ercs import IERC20Detailed\n\ninterface CurveMetaRegistry:\n    def get_coin_indices(_pool: address, _from: address, _to: address) -> (int128, int128, bool): view\n    def find_pools_for_coins(_from: address, _to: address) -> DynArray[address, MAX_POOLS]: view\n    def get_registry_handlers_from_pool(_pool: address) -> address[10]: view\n    def get_pool_from_lp_token(_lpToken: address) -> address: view\n    def get_base_registry(_addr: address) -> address: view\n    def get_balances(_pool: address) -> uint256[8]: view\n    def get_coins(_pool: address) -> address[8]: view\n    def get_n_coins(_pool: address) -> uint256: view\n    def get_lp_token(_pool: address) -> address: view\n    def is_registered(_pool: address) -> bool: view\n    def is_meta(_pool: address) -> bool: view\n\ninterface TwoCryptoPool:\n    def remove_liquidity_one_coin(_lpBurnAmount: uint256, _index: uint256, _minAmountOut: uint256, _useEth: bool = False, _recipient: address = msg.sender) -> uint256: nonpayable\n    def exchange(_i: uint256, _j: uint256, _dx: uint256, _min_dy: uint256, _use_eth: bool = False, _receiver: address = msg.sender) -> uint256: payable\n    def remove_liquidity(_lpBurnAmount: uint256, _minAmountsOut: uint256[2], _useEth: bool = False, _recipient: address = msg.sender): nonpayable\n    def add_liquidity(_amounts: uint256[2], _minLpAmount: uint256, _useEth: bool = False, _recipient: address = msg.sender) -> uint256: payable\n    def calc_withdraw_one_coin(_burnAmount: uint256, _index: uint256) -> uint256: view\n    def calc_token_amount(_amounts: uint256[2]) -> uint256: view\n\ninterface TwoCryptoNgPool:\n    def remove_liquidity_one_coin(_lpBurnAmount: uint256, _index: uint256, _minAmountOut: uint256, _recipient: address = msg.sender) -> uint256: nonpayable\n    def remove_liquidity(_lpBurnAmount: uint256, _minAmountsOut: uint256[2], _recipient: address = msg.sender) -> uint256[2]: nonpayable\n    def exchange(i: uint256, j: uint256, dx: uint256, min_dy: uint256, receiver: address = msg.sender) -> uint256: nonpayable\n    def add_liquidity(_amounts: uint256[2], _minLpAmount: uint256, _recipient: address = msg.sender) -> uint256: nonpayable\n    def calc_withdraw_one_coin(_burnAmount: uint256, _index: uint256) -> uint256: view\n    def calc_token_amount(_amounts: uint256[2], _isDeposit: bool) -> uint256: view\n\ninterface StableNgTwo:\n    def remove_liquidity(_lpBurnAmount: uint256, _minAmountsOut: DynArray[uint256, 2], _recipient: address = msg.sender, _claimAdminFees: bool = True) -> DynArray[uint256, 2]: nonpayable\n    def remove_liquidity_one_coin(_lpBurnAmount: uint256, _index: int128, _minAmountOut: uint256, _recipient: address = msg.sender) -> uint256: nonpayable\n    def add_liquidity(_amounts: DynArray[uint256, 2], _minLpAmount: uint256, _recipient: address = msg.sender) -> uint256: nonpayable\n    def calc_token_amount(_amounts: DynArray[uint256, 2], _isDeposit: bool) -> uint256: view\n    def calc_withdraw_one_coin(_burnAmount: uint256, _index: int128) -> uint256: view\n\ninterface TriCryptoPool:\n    def remove_liquidity(_lpBurnAmount: uint256, _minAmountsOut: uint256[3], _useEth: bool = False, _recipient: address = msg.sender, _claimAdminFees: bool = True) -> uint256[3]: nonpayable\n    def remove_liquidity_one_coin(_lpBurnAmount: uint256, _index: uint256, _minAmountOut: uint256, _useEth: bool = False, _recipient: address = msg.sender) -> uint256: nonpayable\n    def add_liquidity(_amounts: uint256[3], _minLpAmount: uint256, _useEth: bool = False, _recipient: address = msg.sender) -> uint256: payable\n    def calc_withdraw_one_coin(_burnAmount: uint256, _index: uint256) -> uint256: view\n    def calc_token_amount(_amounts: uint256[3], _isDeposit: bool) -> uint256: view\n\ninterface MetaPoolTwo:\n    def remove_liquidity(_lpBurnAmount: uint256, _minAmountsOut: uint256[2], _recipient: address = msg.sender) -> uint256[2]: nonpayable\n    def add_liquidity(_amounts: uint256[2], _minLpAmount: uint256, _recipient: address = msg.sender) -> uint256: nonpayable\n    def calc_token_amount(_amounts: uint256[2], _isDeposit: bool) -> uint256: view\n\ninterface MetaPoolThree:\n    def remove_liquidity(_lpBurnAmount: uint256, _minAmountsOut: uint256[3], _recipient: address = msg.sender) -> uint256[3]: nonpayable\n    def add_liquidity(_amounts: uint256[3], _minLpAmount: uint256, _recipient: address = msg.sender) -> uint256: nonpayable\n    def calc_token_amount(_amounts: uint256[3], _isDeposit: bool) -> uint256: view\n\ninterface MetaPoolFour:\n    def remove_liquidity(_lpBurnAmount: uint256, _minAmountsOut: uint256[4], _recipient: address = msg.sender) -> uint256[4]: nonpayable\n    def add_liquidity(_amounts: uint256[4], _minLpAmount: uint256, _recipient: address = msg.sender) -> uint256: nonpayable\n    def calc_token_amount(_amounts: uint256[4], _isDeposit: bool) -> uint256: view\n\ninterface Appraiser:\n    def getNormalAssetPrice(_asset: address, _missionControl: address = empty(address), _legoBook: address = empty(address), _ledger: address = empty(address)) -> uint256: view\n    def updatePriceAndGetUsdValue(_asset: address, _amount: uint256, _missionControl: address = empty(address), _legoBook: address = empty(address)) -> uint256: nonpayable\n\ninterface MetaPoolCommon:\n    def remove_liquidity_one_coin(_lpBurnAmount: uint256, _index: int128, _minAmountOut: uint256, _recipient: address = msg.sender) -> uint256: nonpayable\n    def calc_withdraw_one_coin(_burnAmount: uint256, _index: int128) -> uint256: view\n\ninterface StableNgThree:\n    def add_liquidity(_amounts: DynArray[uint256, 3], _minLpAmount: uint256, _recipient: address = msg.sender) -> uint256: nonpayable\n    def calc_token_amount(_amounts: DynArray[uint256, 3], _isDeposit: bool) -> uint256: view\n\ninterface StableNgFour:\n    def add_liquidity(_amounts: DynArray[uint256, 4], _minLpAmount: uint256, _recipient: address = msg.sender) -> uint256: nonpayable\n    def calc_token_amount(_amounts: DynArray[uint256, 4], _isDeposit: bool) -> uint256: view\n\ninterface CommonCurvePool:\n    def exchange(_i: int128, _j: int128, _dx: uint256, _min_dy: uint256, _receiver: address = msg.sender) -> uint256: nonpayable\n    def fee() -> uint256: view\n\ninterface CurveRateProvider:\n    def get_quotes(_tokenIn: address, _tokenOut: address, _amountIn: uint256) -> DynArray[Quote, MAX_QUOTES]: view\n    def get_aggregated_rate(_tokenIn: address, _tokenOut: address) -> uint256: view\n\ninterface CryptoLegacyPool:\n    def exchange(_i: uint256, _j: uint256, _dx: uint256, _min_dy: uint256, _use_eth: bool = False) -> uint256: payable\n\ninterface OracleRegistry:\n    def getUsdValue(_asset: address, _amount: uint256, _shouldRaise: bool = False) -> uint256: view\n\ninterface CurveAddressProvider:\n    def get_address(_id: uint256) -> address: view\n\nflag PoolType:\n    STABLESWAP_NG\n    TWO_CRYPTO_NG\n    TRICRYPTO_NG\n    TWO_CRYPTO\n    METAPOOL\n    CRYPTO\n\nstruct Quote:\n    source_token_index: uint256\n    dest_token_index: uint256\n    is_underlying: bool\n    amount_out: uint256\n    pool: address\n    source_token_pool_balance: uint256\n    dest_token_pool_balance: uint256\n    pool_type: uint8\n\nstruct PoolData:\n    pool: address\n    indexTokenA: uint256\n    indexTokenB: uint256\n    poolType: PoolType\n    numCoins: uint256\n\nstruct BestPool:\n    pool: address\n    fee: uint256\n    liquidity: uint256\n    numCoins: uint256\n\nstruct CurveRegistries:\n    StableSwapNg: address\n    TwoCryptoNg: address\n    TricryptoNg: address\n    TwoCrypto: address\n    MetaPool: address\n    RateProvider: address\n\nevent CurveSwap:\n    sender: indexed(address)\n    tokenIn: indexed(address)\n    tokenOut: indexed(address)\n    amountIn: uint256\n    amountOut: uint256\n    usdValue: uint256\n    numTokens: uint256\n    recipient: address\n\nevent CurveLiquidityAdded:\n    sender: indexed(address)\n    tokenA: indexed(address)\n    tokenB: indexed(address)\n    amountA: uint256\n    amountB: uint256\n    lpAmountReceived: uint256\n    usdValue: uint256\n    recipient: address\n\nevent CurveLiquidityRemoved:\n    sender: address\n    pool: indexed(address)\n    tokenA: indexed(address)\n    tokenB: indexed(address)\n    amountA: uint256\n    amountB: uint256\n    lpToken: address\n    lpAmountBurned: uint256\n    usdValue: uint256\n    recipient: address\n\n# curve\nCURVE_META_REGISTRY: public(immutable(address))\nCURVE_REGISTRIES: public(immutable(CurveRegistries))\n\n# curve address provider ids\nMETAPOOL_FACTORY_ID: constant(uint256) = 3\nTWO_CRYPTO_FACTORY_ID: constant(uint256) = 6\nMETA_REGISTRY_ID: constant(uint256) = 7\nTRICRYPTO_NG_FACTORY_ID: constant(uint256) = 11\nSTABLESWAP_NG_FACTORY_ID: constant(uint256) = 12\nTWO_CRYPTO_NG_FACTORY_ID: constant(uint256) = 13\nRATE_PROVIDER_ID: constant(uint256) = 18\n\nMAX_POOLS: constant(uint256) = 50\nMAX_QUOTES: constant(uint256) = 100\nMAX_TOKEN_PATH: constant(uint256) = 5\n\n\n@deploy\ndef __init__(_undyHq: address, _curveAddressProvider: address):\n    addys.__init__(_undyHq)\n    dld.__init__(False)\n\n    CURVE_META_REGISTRY = staticcall CurveAddressProvider(_curveAddressProvider).get_address(META_REGISTRY_ID)\n    CURVE_REGISTRIES = CurveRegistries(\n        StableSwapNg= staticcall CurveAddressProvider(_curveAddressProvider).get_address(STABLESWAP_NG_FACTORY_ID),\n        TwoCryptoNg= staticcall CurveAddressProvider(_curveAddressProvider).get_address(TWO_CRYPTO_NG_FACTORY_ID),\n        TricryptoNg= staticcall CurveAddressProvider(_curveAddressProvider).get_address(TRICRYPTO_NG_FACTORY_ID),\n        TwoCrypto= staticcall CurveAddressProvider(_curveAddressProvider).get_address(TWO_CRYPTO_FACTORY_ID),\n        MetaPool= staticcall CurveAddressProvider(_curveAddressProvider).get_address(METAPOOL_FACTORY_ID),\n        RateProvider= staticcall CurveAddressProvider(_curveAddressProvider).get_address(RATE_PROVIDER_ID),\n    )\n\n\n@view\n@external\ndef hasCapability(_action: ws.ActionType) -> bool:\n    return _action in (\n        ws.ActionType.SWAP |\n        ws.ActionType.ADD_LIQ | \n        ws.ActionType.REMOVE_LIQ\n    )\n\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    return [CURVE_META_REGISTRY]\n\n\n@view\n@external\ndef isYieldLego() -> bool:\n    return False\n\n\n@view\n@external\ndef isDexLego() -> bool:\n    return True\n\n\n#########\n# Swaps #\n#########\n\n\n@external\ndef swapTokens(\n    _amountIn: uint256,\n    _minAmountOut: uint256,\n    _tokenPath: DynArray[address, MAX_TOKEN_PATH],\n    _poolPath: DynArray[address, MAX_TOKEN_PATH - 1],\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256):\n    assert not dld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = dld._getMiniAddys(_miniAddys)\n\n    # validate inputs\n    numTokens: uint256 = len(_tokenPath)\n    numPools: uint256 = len(_poolPath)\n    assert numTokens >= 2 # dev: invalid path\n    assert numPools == numTokens - 1 # dev: invalid path\n\n    # get first token and last token\n    tokenIn: address = _tokenPath[0]\n    tokenOut: address = _tokenPath[numTokens - 1]\n\n    # pre balances\n    preLegoBalance: uint256 = staticcall IERC20(tokenIn).balanceOf(self)\n\n    # transfer deposit asset to this contract\n    amountIn: uint256 = min(_amountIn, staticcall IERC20(tokenIn).balanceOf(msg.sender))\n    assert amountIn != 0 # dev: nothing to transfer\n    assert extcall IERC20(tokenIn).transferFrom(msg.sender, self, amountIn, default_return_value=True) # dev: transfer failed\n\n    # adjust min amount out\n    minAmountOut: uint256 = _minAmountOut\n    if amountIn < _amountIn and _amountIn != max_value(uint256):\n        minAmountOut = _minAmountOut * amountIn // _amountIn\n\n    # iterate through swap routes\n    tempAmountIn: uint256 = amountIn\n    curveMetaRegistry: address = CURVE_META_REGISTRY\n    for i: uint256 in range(numTokens - 1, bound=MAX_TOKEN_PATH):\n        tempTokenIn: address = _tokenPath[i]\n        tempTokenOut: address = _tokenPath[i + 1]\n        tempPool: address = _poolPath[i]\n\n        # transfer to self (or to recipient if last swap)\n        recipient: address = _recipient\n        if i < numTokens - 2:\n            recipient = self\n\n        # swap\n        tempAmountIn = self._swapTokensInPool(tempPool, tempTokenIn, tempTokenOut, tempAmountIn, recipient, curveMetaRegistry)\n\n    # final amount\n    amountOut: uint256 = tempAmountIn\n    assert amountOut >= minAmountOut # dev: min amount out not met\n\n    # refund if full swap didn't get through\n    currentLegoBalance: uint256 = staticcall IERC20(tokenIn).balanceOf(self)\n    refundAssetAmount: uint256 = 0\n    if currentLegoBalance > preLegoBalance:\n        refundAssetAmount = currentLegoBalance - preLegoBalance\n        assert extcall IERC20(tokenIn).transfer(msg.sender, refundAssetAmount, default_return_value=True) # dev: transfer failed\n        amountIn -= refundAssetAmount\n\n    # get usd values\n    usdValue: uint256 = extcall Appraiser(miniAddys.appraiser).updatePriceAndGetUsdValue(tokenIn, amountIn, miniAddys.missionControl, miniAddys.legoBook)\n    if usdValue == 0:\n        usdValue = extcall Appraiser(miniAddys.appraiser).updatePriceAndGetUsdValue(tokenOut, amountOut, miniAddys.missionControl, miniAddys.legoBook)\n\n    log CurveSwap(\n        sender = msg.sender,\n        tokenIn = tokenIn,\n        tokenOut = tokenOut,\n        amountIn = amountIn,\n        amountOut = amountOut,\n        usdValue = usdValue,\n        numTokens = numTokens,\n        recipient = _recipient,\n    )\n    return amountIn, amountOut, usdValue\n\n\n# swap in pool\n\n\n@internal\ndef _swapTokensInPool(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n    _recipient: address,\n    _curveMetaRegistry: address,\n) -> uint256:\n    amountOut: uint256 = 0\n    p: PoolData = self._getPoolData(_pool, _tokenIn, _tokenOut, _curveMetaRegistry)\n    assert extcall IERC20(_tokenIn).approve(_pool, _amountIn, default_return_value=True) # dev: approval failed\n\n    # stable ng\n    if p.poolType == PoolType.STABLESWAP_NG:\n        amountOut = extcall CommonCurvePool(_pool).exchange(convert(p.indexTokenA, int128), convert(p.indexTokenB, int128), _amountIn, 0, _recipient)\n\n    # two crypto ng\n    elif p.poolType == PoolType.TWO_CRYPTO_NG:\n        amountOut = extcall TwoCryptoNgPool(_pool).exchange(p.indexTokenA, p.indexTokenB, _amountIn, 0, _recipient)\n\n    # two crypto + tricrypto ng pools\n    elif p.poolType == PoolType.TRICRYPTO_NG or p.poolType == PoolType.TWO_CRYPTO:\n        amountOut = extcall TwoCryptoPool(_pool).exchange(p.indexTokenA, p.indexTokenB, _amountIn, 0, False, _recipient)\n\n    # meta pools\n    elif p.poolType == PoolType.METAPOOL:\n        if staticcall CurveMetaRegistry(_curveMetaRegistry).is_meta(_pool):\n            raise \"Not Implemented\"\n        else:\n            amountOut = extcall CommonCurvePool(_pool).exchange(convert(p.indexTokenA, int128), convert(p.indexTokenB, int128), _amountIn, 0, _recipient)\n\n    # crypto v1\n    else:\n        amountOut = extcall CryptoLegacyPool(_pool).exchange(p.indexTokenA, p.indexTokenB, _amountIn, 0, False)\n        if _recipient != self:\n            assert extcall IERC20(_tokenOut).transfer(_recipient, amountOut, default_return_value=True) # dev: transfer failed\n\n    assert extcall IERC20(_tokenIn).approve(_pool, 0, default_return_value=True) # dev: approval failed\n    assert amountOut != 0 # dev: no tokens swapped\n    return amountOut\n\n\n#################\n# Add Liquidity #\n#################\n\n\n@external\ndef addLiquidity(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _amountA: uint256,\n    _amountB: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _minLpAmount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (address, uint256, uint256, uint256, uint256):\n    assert not dld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = dld._getMiniAddys(_miniAddys)\n\n    assert empty(address) not in [_tokenA, _tokenB] # dev: invalid tokens\n    assert _tokenA != _tokenB # dev: invalid tokens\n\n    # pre balances\n    preLegoBalanceA: uint256 = staticcall IERC20(_tokenA).balanceOf(self)\n    preLegoBalanceB: uint256 = staticcall IERC20(_tokenB).balanceOf(self)\n\n    # token a\n    liqAmountA: uint256 = min(_amountA, staticcall IERC20(_tokenA).balanceOf(msg.sender))\n    if liqAmountA != 0:\n        assert extcall IERC20(_tokenA).transferFrom(msg.sender, self, liqAmountA, default_return_value=True) # dev: transfer failed\n        assert extcall IERC20(_tokenA).approve(_pool, liqAmountA, default_return_value=True) # dev: approval failed\n\n    # token b\n    liqAmountB: uint256 = min(_amountB, staticcall IERC20(_tokenB).balanceOf(msg.sender))\n    if liqAmountB != 0:\n        assert extcall IERC20(_tokenB).transferFrom(msg.sender, self, liqAmountB, default_return_value=True) # dev: transfer failed\n        assert extcall IERC20(_tokenB).approve(_pool, liqAmountB, default_return_value=True) # dev: approval failed\n\n    assert liqAmountA != 0 or liqAmountB != 0 # dev: need at least one token amount\n\n    # pool data\n    metaRegistry: address = CURVE_META_REGISTRY\n    p: PoolData = self._getPoolData(_pool, _tokenA, _tokenB, metaRegistry)\n\n    # add liquidity\n    lpAmountReceived: uint256 = 0\n    if p.poolType == PoolType.STABLESWAP_NG:\n        lpAmountReceived = self._addLiquidityStableNg(p, liqAmountA, liqAmountB, _minLpAmount, _recipient)\n    elif p.poolType == PoolType.TWO_CRYPTO_NG:\n        lpAmountReceived = self._addLiquidityTwoCryptoNg(p, liqAmountA, liqAmountB, _minLpAmount, _recipient)\n    elif p.poolType == PoolType.TWO_CRYPTO:\n        lpAmountReceived = self._addLiquidityTwoCrypto(p, liqAmountA, liqAmountB, _minLpAmount, _recipient)\n    elif p.poolType == PoolType.TRICRYPTO_NG:\n        lpAmountReceived = self._addLiquidityTricrypto(p, liqAmountA, liqAmountB, _minLpAmount, _recipient)\n    elif p.poolType == PoolType.METAPOOL and not staticcall CurveMetaRegistry(metaRegistry).is_meta(p.pool):\n        lpAmountReceived = self._addLiquidityMetaPool(p, liqAmountA, liqAmountB, _minLpAmount, _recipient)\n    assert lpAmountReceived != 0 # dev: no liquidity added\n\n    # handle token a refunds / approvals\n    refundAssetAmountA: uint256 = 0\n    if liqAmountA != 0:\n        assert extcall IERC20(_tokenA).approve(_pool, 0, default_return_value=True) # dev: approval failed\n\n        currentLegoBalanceA: uint256 = staticcall IERC20(_tokenA).balanceOf(self)\n        if currentLegoBalanceA > preLegoBalanceA:\n            refundAssetAmountA = currentLegoBalanceA - preLegoBalanceA\n            assert extcall IERC20(_tokenA).transfer(msg.sender, refundAssetAmountA, default_return_value=True) # dev: transfer failed\n            liqAmountA -= refundAssetAmountA\n\n    # handle token b refunds / approvals\n    refundAssetAmountB: uint256 = 0\n    if liqAmountB != 0:\n        assert extcall IERC20(_tokenB).approve(_pool, 0, default_return_value=True) # dev: approval failed\n\n        currentLegoBalanceB: uint256 = staticcall IERC20(_tokenB).balanceOf(self)\n        if currentLegoBalanceB > preLegoBalanceB:\n            refundAssetAmountB = currentLegoBalanceB - preLegoBalanceB\n            assert extcall IERC20(_tokenB).transfer(msg.sender, refundAssetAmountB, default_return_value=True) # dev: transfer failed\n            liqAmountB -= refundAssetAmountB\n\n    usdValue: uint256 = self._getUsdValue(_tokenA, liqAmountA, _tokenB, liqAmountB, miniAddys)\n    log CurveLiquidityAdded(\n        sender = msg.sender,\n        tokenA = _tokenA,\n        tokenB = _tokenB,\n        amountA = liqAmountA,\n        amountB = liqAmountB,\n        lpAmountReceived = lpAmountReceived,\n        usdValue = usdValue,\n        recipient = _recipient,\n    )\n    lpToken: address = staticcall CurveMetaRegistry(metaRegistry).get_lp_token(_pool)\n    return lpToken, lpAmountReceived, liqAmountA, liqAmountB, usdValue\n\n\n@internal\ndef _addLiquidityStableNg(\n    _p: PoolData,\n    _liqAmountA: uint256,\n    _liqAmountB: uint256,\n    _minLpAmount: uint256,\n    _recipient: address,\n) -> uint256:\n    lpAmountReceived: uint256 = 0\n\n    if _p.numCoins == 2:\n        amounts: DynArray[uint256, 2] = [0, 0]\n        amounts[_p.indexTokenA] = _liqAmountA\n        amounts[_p.indexTokenB] = _liqAmountB\n        lpAmountReceived = extcall StableNgTwo(_p.pool).add_liquidity(amounts, _minLpAmount, _recipient)\n\n    elif _p.numCoins == 3:\n        amounts: DynArray[uint256, 3] = [0, 0, 0]\n        amounts[_p.indexTokenA] = _liqAmountA\n        amounts[_p.indexTokenB] = _liqAmountB\n        lpAmountReceived = extcall StableNgThree(_p.pool).add_liquidity(amounts, _minLpAmount, _recipient)\n\n    elif _p.numCoins == 4:\n        amounts: DynArray[uint256, 4] = [0, 0, 0, 0]\n        amounts[_p.indexTokenA] = _liqAmountA\n        amounts[_p.indexTokenB] = _liqAmountB\n        lpAmountReceived = extcall StableNgFour(_p.pool).add_liquidity(amounts, _minLpAmount, _recipient)\n\n    return lpAmountReceived\n\n\n@internal\ndef _addLiquidityTwoCryptoNg(\n    _p: PoolData,\n    _liqAmountA: uint256,\n    _liqAmountB: uint256,\n    _minLpAmount: uint256,\n    _recipient: address,\n) -> uint256:\n    amounts: uint256[2] = [0, 0]\n    amounts[_p.indexTokenA] = _liqAmountA\n    amounts[_p.indexTokenB] = _liqAmountB\n    return extcall TwoCryptoNgPool(_p.pool).add_liquidity(amounts, _minLpAmount, _recipient)\n\n\n@internal\ndef _addLiquidityTwoCrypto(\n    _p: PoolData,\n    _liqAmountA: uint256,\n    _liqAmountB: uint256,\n    _minLpAmount: uint256,\n    _recipient: address,\n) -> uint256:\n    amounts: uint256[2] = [0, 0]\n    amounts[_p.indexTokenA] = _liqAmountA\n    amounts[_p.indexTokenB] = _liqAmountB\n    return extcall TwoCryptoPool(_p.pool).add_liquidity(amounts, _minLpAmount, False, _recipient)\n\n\n@internal\ndef _addLiquidityTricrypto(\n    _p: PoolData,\n    _liqAmountA: uint256,\n    _liqAmountB: uint256,\n    _minLpAmount: uint256,\n    _recipient: address,\n) -> uint256:\n    amounts: uint256[3] = [0, 0, 0]\n    amounts[_p.indexTokenA] = _liqAmountA\n    amounts[_p.indexTokenB] = _liqAmountB\n    return extcall TriCryptoPool(_p.pool).add_liquidity(amounts, _minLpAmount, False, _recipient)\n\n\n@internal\ndef _addLiquidityMetaPool(\n    _p: PoolData,\n    _liqAmountA: uint256,\n    _liqAmountB: uint256,\n    _minLpAmount: uint256,\n    _recipient: address,\n) -> uint256:\n    lpAmountReceived: uint256 = 0\n\n    if _p.numCoins == 2:\n        amounts: uint256[2] = [0, 0]\n        amounts[_p.indexTokenA] = _liqAmountA\n        amounts[_p.indexTokenB] = _liqAmountB\n        lpAmountReceived = extcall MetaPoolTwo(_p.pool).add_liquidity(amounts, _minLpAmount, _recipient)\n\n    elif _p.numCoins == 3:\n        amounts: uint256[3] = [0, 0, 0]\n        amounts[_p.indexTokenA] = _liqAmountA\n        amounts[_p.indexTokenB] = _liqAmountB\n        lpAmountReceived = extcall MetaPoolThree(_p.pool).add_liquidity(amounts, _minLpAmount, _recipient)\n\n    elif _p.numCoins == 4:\n        amounts: uint256[4] = [0, 0, 0, 0]\n        amounts[_p.indexTokenA] = _liqAmountA\n        amounts[_p.indexTokenB] = _liqAmountB\n        lpAmountReceived = extcall MetaPoolFour(_p.pool).add_liquidity(amounts, _minLpAmount, _recipient)\n\n    return lpAmountReceived\n\n\n####################\n# Remove Liquidity #\n####################\n\n\n@external\ndef removeLiquidity(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpToken: address,\n    _lpAmount: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, uint256):\n    assert not dld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = dld._getMiniAddys(_miniAddys)\n\n    # if one of the tokens is empty, it means they only want to remove liquidity for one token\n    assert _tokenA != empty(address) or _tokenB != empty(address) # dev: invalid tokens\n    assert _tokenA != _tokenB # dev: invalid tokens\n\n    isEmptyTokenA: bool = _tokenA == empty(address)\n    isOneCoinRemoval: bool = isEmptyTokenA or _tokenB == empty(address)\n\n    # pre balance\n    preLegoBalance: uint256 = staticcall IERC20(_lpToken).balanceOf(self)\n\n    # lp token amount\n    lpAmount: uint256 = min(_lpAmount, staticcall IERC20(_lpToken).balanceOf(msg.sender))\n    assert lpAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_lpToken).transferFrom(msg.sender, self, lpAmount, default_return_value=True) # dev: transfer failed\n\n    # approvals\n    assert extcall IERC20(_lpToken).approve(_pool, lpAmount, default_return_value=True) # dev: approval failed\n\n    # pool data\n    metaRegistry: address = CURVE_META_REGISTRY\n    p: PoolData = self._getPoolData(_pool, _tokenA, _tokenB, metaRegistry)\n\n    # remove liquidity\n    amountA: uint256 = 0\n    amountB: uint256 = 0\n    if p.poolType == PoolType.STABLESWAP_NG:\n        if isOneCoinRemoval:\n            amountA, amountB = self._removeLiquidityStableNgOneCoin(p, isEmptyTokenA, lpAmount, _minAmountA, _minAmountB, _recipient)\n        else:\n            amountA, amountB = self._removeLiquidityStableNg(p, lpAmount, _minAmountA, _minAmountB, _recipient)\n    elif p.poolType == PoolType.TWO_CRYPTO_NG:\n        if isOneCoinRemoval:\n            amountA, amountB = self._removeLiquidityTwoCryptoNgOneCoin(p, isEmptyTokenA, lpAmount, _minAmountA, _minAmountB, _recipient)\n        else:\n            amountA, amountB = self._removeLiquidityTwoCryptoNg(p, lpAmount, _minAmountA, _minAmountB, _recipient)\n    elif p.poolType == PoolType.TWO_CRYPTO:\n        if isOneCoinRemoval:\n            amountA, amountB = self._removeLiquidityTwoCryptoOneCoin(p, isEmptyTokenA, lpAmount, _minAmountA, _minAmountB, _recipient)\n        else:\n            amountA, amountB = self._removeLiquidityTwoCrypto(p, lpAmount, _tokenA, _tokenB, _minAmountA, _minAmountB, _recipient)\n    elif p.poolType == PoolType.TRICRYPTO_NG:\n        if isOneCoinRemoval:\n            amountA, amountB = self._removeLiquidityTricryptoOneCoin(p, isEmptyTokenA, lpAmount, _minAmountA, _minAmountB, _recipient)\n        else:\n            amountA, amountB = self._removeLiquidityTricrypto(p, lpAmount, _minAmountA, _minAmountB, _recipient)\n    elif p.poolType == PoolType.METAPOOL and not staticcall CurveMetaRegistry(metaRegistry).is_meta(p.pool):\n        if isOneCoinRemoval:\n            amountA, amountB = self._removeLiquidityMetaPoolOneCoin(p, isEmptyTokenA, lpAmount, _minAmountA, _minAmountB, _recipient)\n        else:\n            amountA, amountB = self._removeLiquidityMetaPool(p, lpAmount, _minAmountA, _minAmountB, _recipient)\n    assert amountA != 0 or amountB != 0 # dev: nothing removed\n\n    # reset approvals\n    assert extcall IERC20(_lpToken).approve(_pool, 0, default_return_value=True) # dev: approval failed\n\n    # refund if full liquidity was not removed\n    currentLegoBalance: uint256 = staticcall IERC20(_lpToken).balanceOf(self)\n    refundedLpAmount: uint256 = 0\n    if currentLegoBalance > preLegoBalance:\n        refundedLpAmount = currentLegoBalance - preLegoBalance\n        assert extcall IERC20(_lpToken).transfer(msg.sender, refundedLpAmount, default_return_value=True) # dev: transfer failed\n        lpAmount -= refundedLpAmount\n\n    usdValue: uint256 = self._getUsdValue(_tokenA, amountA, _tokenB, amountB, miniAddys)\n    log CurveLiquidityRemoved(\n        sender = msg.sender,\n        pool = _pool,\n        tokenA = _tokenA,\n        tokenB = _tokenB,\n        amountA = amountA,\n        amountB = amountB,\n        lpToken = _lpToken,\n        lpAmountBurned = lpAmount,\n        usdValue = usdValue,\n        recipient = _recipient,\n    )\n    return amountA, amountB, lpAmount, usdValue\n\n\n# stable ng\n\n\n@internal\ndef _removeLiquidityStableNgOneCoin(\n    _p: PoolData,\n    _isEmptyTokenA: bool,\n    _lpAmount: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _recipient: address,\n) -> (uint256, uint256):\n    tokenIndex: uint256 = 0\n    minAmountOut: uint256 = 0\n    tokenIndex, minAmountOut = self._getTokenIndexAndMinAmountOut(_isEmptyTokenA, _p.indexTokenA, _p.indexTokenB, _minAmountA, _minAmountB)\n    amountOut: uint256 = extcall StableNgTwo(_p.pool).remove_liquidity_one_coin(_lpAmount, convert(tokenIndex, int128), minAmountOut, _recipient)\n    return self._getTokenAmounts(_isEmptyTokenA, amountOut)\n\n\n@internal\ndef _removeLiquidityStableNg(\n    _p: PoolData,\n    _lpAmount: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _recipient: address,\n) -> (uint256, uint256):\n\n    # only supporting 2-coin pools, can't give minAmountsOut for other coins\n    assert _p.numCoins == 2 # dev: invalid pool\n\n    minAmountsOut: DynArray[uint256, 2] = [0, 0]\n    minAmountsOut[_p.indexTokenA] = _minAmountA\n    minAmountsOut[_p.indexTokenB] = _minAmountB\n\n    # remove liquidity\n    amountsOut: DynArray[uint256, 2] = extcall StableNgTwo(_p.pool).remove_liquidity(_lpAmount, minAmountsOut, _recipient, False)\n    return amountsOut[_p.indexTokenA], amountsOut[_p.indexTokenB]\n\n\n# two crypto ng\n\n\n@internal\ndef _removeLiquidityTwoCryptoNgOneCoin(\n    _p: PoolData,\n    _isEmptyTokenA: bool,\n    _lpAmount: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _recipient: address,\n) -> (uint256, uint256):\n    tokenIndex: uint256 = 0\n    minAmountOut: uint256 = 0\n    tokenIndex, minAmountOut = self._getTokenIndexAndMinAmountOut(_isEmptyTokenA, _p.indexTokenA, _p.indexTokenB, _minAmountA, _minAmountB)\n    amountOut: uint256 = extcall TwoCryptoNgPool(_p.pool).remove_liquidity_one_coin(_lpAmount, tokenIndex, minAmountOut, _recipient)\n    return self._getTokenAmounts(_isEmptyTokenA, amountOut)\n\n\n@internal\ndef _removeLiquidityTwoCryptoNg(\n    _p: PoolData,\n    _lpAmount: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _recipient: address,\n) -> (uint256, uint256):\n\n    # only supporting 2-coin pools, can't give minAmountsOut for other coins\n    assert _p.numCoins == 2 # dev: invalid pool\n\n    minAmountsOut: uint256[2] = [0, 0]\n    minAmountsOut[_p.indexTokenA] = _minAmountA\n    minAmountsOut[_p.indexTokenB] = _minAmountB\n\n    # remove liquidity\n    amountsOut: uint256[2] = extcall TwoCryptoNgPool(_p.pool).remove_liquidity(_lpAmount, minAmountsOut, _recipient)\n    return amountsOut[_p.indexTokenA], amountsOut[_p.indexTokenB]\n\n\n# two crypto\n\n\n@internal\ndef _removeLiquidityTwoCryptoOneCoin(\n    _p: PoolData,\n    _isEmptyTokenA: bool,\n    _lpAmount: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _recipient: address,\n) -> (uint256, uint256):\n    tokenIndex: uint256 = 0\n    minAmountOut: uint256 = 0\n    tokenIndex, minAmountOut = self._getTokenIndexAndMinAmountOut(_isEmptyTokenA, _p.indexTokenA, _p.indexTokenB, _minAmountA, _minAmountB)\n    amountOut: uint256 = extcall TwoCryptoPool(_p.pool).remove_liquidity_one_coin(_lpAmount, tokenIndex, minAmountOut, False, _recipient)\n    return self._getTokenAmounts(_isEmptyTokenA, amountOut)\n\n\n@internal\ndef _removeLiquidityTwoCrypto(\n    _p: PoolData,\n    _lpAmount: uint256,\n    _tokenA: address,\n    _tokenB: address,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _recipient: address,\n) -> (uint256, uint256):\n\n    # only supporting 2-coin pools\n    assert _p.numCoins == 2 # dev: invalid pool\n\n    # pre balances\n    preBalTokenA: uint256 = staticcall IERC20(_tokenA).balanceOf(_recipient)\n    preBalTokenB: uint256 = staticcall IERC20(_tokenB).balanceOf(_recipient)\n\n    # organize min amounts out\n    minAmountsOut: uint256[2] = [0, 0]\n    minAmountsOut[_p.indexTokenA] = _minAmountA\n    minAmountsOut[_p.indexTokenB] = _minAmountB\n\n    # remove liquidity\n    extcall TwoCryptoPool(_p.pool).remove_liquidity(_lpAmount, minAmountsOut, False, _recipient)\n\n    # get amounts\n    amountA: uint256 = 0\n    postBalTokenA: uint256 = staticcall IERC20(_tokenA).balanceOf(_recipient)\n    if postBalTokenA > preBalTokenA:\n        amountA = postBalTokenA - preBalTokenA\n\n    amountB: uint256 = 0\n    postBalTokenB: uint256 = staticcall IERC20(_tokenB).balanceOf(_recipient)\n    if postBalTokenB > preBalTokenB:\n        amountB = postBalTokenB - preBalTokenB\n\n    return amountA, amountB\n\n\n# tricrypto ng\n\n\n@internal\ndef _removeLiquidityTricryptoOneCoin(\n    _p: PoolData,\n    _isEmptyTokenA: bool,\n    _lpAmount: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _recipient: address,\n) -> (uint256, uint256):\n    tokenIndex: uint256 = 0\n    minAmountOut: uint256 = 0\n    tokenIndex, minAmountOut = self._getTokenIndexAndMinAmountOut(_isEmptyTokenA, _p.indexTokenA, _p.indexTokenB, _minAmountA, _minAmountB)\n    amountOut: uint256 = extcall TriCryptoPool(_p.pool).remove_liquidity_one_coin(_lpAmount, tokenIndex, minAmountOut, False, _recipient)\n    return self._getTokenAmounts(_isEmptyTokenA, amountOut)\n\n\n@internal\ndef _removeLiquidityTricrypto(\n    _p: PoolData,\n    _lpAmount: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _recipient: address,\n) -> (uint256, uint256):\n    minAmountsOut: uint256[3] = [0, 0, 0]\n    minAmountsOut[_p.indexTokenA] = _minAmountA\n    minAmountsOut[_p.indexTokenB] = _minAmountB\n\n    # NOTE: user can only specify two min amounts out, the third will be set to zero\n\n    # remove liquidity\n    amountsOut: uint256[3] = extcall TriCryptoPool(_p.pool).remove_liquidity(_lpAmount, minAmountsOut, False, _recipient, False)\n    return amountsOut[_p.indexTokenA], amountsOut[_p.indexTokenB]\n\n\n# meta pool\n\n\n@internal\ndef _removeLiquidityMetaPoolOneCoin(\n    _p: PoolData,\n    _isEmptyTokenA: bool,\n    _lpAmount: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _recipient: address,\n) -> (uint256, uint256):\n    tokenIndex: uint256 = 0\n    minAmountOut: uint256 = 0\n    tokenIndex, minAmountOut = self._getTokenIndexAndMinAmountOut(_isEmptyTokenA, _p.indexTokenA, _p.indexTokenB, _minAmountA, _minAmountB)\n    amountOut: uint256 = extcall MetaPoolCommon(_p.pool).remove_liquidity_one_coin(_lpAmount, convert(tokenIndex, int128), minAmountOut, _recipient)\n    return self._getTokenAmounts(_isEmptyTokenA, amountOut)\n\n\n@internal\ndef _removeLiquidityMetaPool(\n    _p: PoolData,\n    _lpAmount: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _recipient: address,\n) -> (uint256, uint256):\n    amountA: uint256 = 0\n    amountB: uint256 = 0\n\n    # NOTE: user can only specify two min amounts out, the third/fourth will be set to zero\n\n    if _p.numCoins == 2:\n        minAmountsOut: uint256[2] = [0, 0]\n        minAmountsOut[_p.indexTokenA] = _minAmountA\n        minAmountsOut[_p.indexTokenB] = _minAmountB\n        amountsOut: uint256[2] = extcall MetaPoolTwo(_p.pool).remove_liquidity(_lpAmount, minAmountsOut, _recipient)\n        amountA = amountsOut[_p.indexTokenA]\n        amountB = amountsOut[_p.indexTokenB]\n\n    elif _p.numCoins == 3:\n        minAmountsOut: uint256[3] = [0, 0, 0]\n        minAmountsOut[_p.indexTokenA] = _minAmountA\n        minAmountsOut[_p.indexTokenB] = _minAmountB\n        amountsOut: uint256[3] = extcall MetaPoolThree(_p.pool).remove_liquidity(_lpAmount, minAmountsOut, _recipient)\n        amountA = amountsOut[_p.indexTokenA]\n        amountB = amountsOut[_p.indexTokenB]\n\n    elif _p.numCoins == 4:\n        minAmountsOut: uint256[4] = [0, 0, 0, 0]\n        minAmountsOut[_p.indexTokenA] = _minAmountA\n        minAmountsOut[_p.indexTokenB] = _minAmountB\n        amountsOut: uint256[4] = extcall MetaPoolFour(_p.pool).remove_liquidity(_lpAmount, minAmountsOut, _recipient)\n        amountA = amountsOut[_p.indexTokenA]\n        amountB = amountsOut[_p.indexTokenB]\n\n    else:\n        raise \"meta pool: pools beyond 4-coin are not supported\"\n\n    return amountA, amountB\n\n\n# utils\n\n\n@pure\n@internal\ndef _getTokenIndexAndMinAmountOut(\n    _isEmptyTokenA: bool,\n    _indexTokenA: uint256,\n    _indexTokenB: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n) -> (uint256, uint256):\n    tokenIndex: uint256 = _indexTokenA\n    minAmountOut: uint256 = _minAmountA\n    if _isEmptyTokenA:\n        tokenIndex = _indexTokenB\n        minAmountOut = _minAmountB\n    return tokenIndex, minAmountOut\n\n\n@pure\n@internal\ndef _getTokenAmounts(_isEmptyTokenA: bool, _amountOut: uint256) -> (uint256, uint256):\n    amountA: uint256 = 0\n    amountB: uint256 = 0\n    if _isEmptyTokenA:\n        amountB = _amountOut\n    else:\n        amountA = _amountOut\n    return amountA, amountB\n\n\n\n# get usd value on liquidity actions\n\n\n@internal\ndef _getUsdValue(\n    _tokenA: address,\n    _amountA: uint256,\n    _tokenB: address,\n    _amountB: uint256,\n    _miniAddys: ws.MiniAddys,\n) -> uint256:\n\n    usdValueA: uint256 = 0\n    if _amountA != 0:\n        usdValueA = extcall Appraiser(_miniAddys.appraiser).updatePriceAndGetUsdValue(_tokenA, _amountA, _miniAddys.missionControl, _miniAddys.legoBook)\n\n    usdValueB: uint256 = 0\n    if _amountB != 0:\n        usdValueB = extcall Appraiser(_miniAddys.appraiser).updatePriceAndGetUsdValue(_tokenB, _amountB, _miniAddys.missionControl, _miniAddys.legoBook)\n\n    return usdValueA + usdValueB\n\n\n#############\n# Utilities #\n#############\n\n\n@view\n@external\ndef getLpToken(_pool: address) -> address:\n    return staticcall CurveMetaRegistry(CURVE_META_REGISTRY).get_lp_token(_pool)\n\n\n@view\n@external\ndef getPoolForLpToken(_lpToken: address) -> address:\n    return staticcall CurveMetaRegistry(CURVE_META_REGISTRY).get_pool_from_lp_token(_lpToken)\n\n\n@view\n@external\ndef getCoreRouterPool() -> address:\n    return empty(address)\n\n\n@view\n@external\ndef getDeepestLiqPool(_tokenA: address, _tokenB: address) -> BestPool:\n    metaRegistry: address = CURVE_META_REGISTRY\n\n    # all pools with tokens\n    allPools: DynArray[address, MAX_POOLS] = staticcall CurveMetaRegistry(metaRegistry).find_pools_for_coins(_tokenA, _tokenB)\n    if len(allPools) == 0:\n        return empty(BestPool)\n\n    # get deepest liquidity pool\n    bestPoolAddr: address = empty(address)\n    na1: int128 = 0\n    na2: int128 = 0\n    bestLiquidity: uint256 = 0\n    bestPoolAddr, na1, na2, bestLiquidity = self._getDeepestLiqPool(_tokenA, _tokenB, allPools, metaRegistry)\n\n    if bestPoolAddr == empty(address):\n        return empty(BestPool)\n\n    return BestPool(\n        pool=bestPoolAddr,\n        fee=staticcall CommonCurvePool(bestPoolAddr).fee() // 1000000, # normalize to have 100_00 denominator\n        liquidity=bestLiquidity,\n        numCoins=staticcall CurveMetaRegistry(metaRegistry).get_n_coins(bestPoolAddr),\n    )\n\n\n@view\n@external\ndef getBestSwapAmountOut(_tokenIn: address, _tokenOut: address, _amountIn: uint256) -> (address, uint256):\n    return self._getBestSwapAmountOut(_tokenIn, _tokenOut, _amountIn)\n\n\n@view\n@internal\ndef _getBestSwapAmountOut(_tokenIn: address, _tokenOut: address, _amountIn: uint256) -> (address, uint256):\n    bestPool: address = empty(address)\n    bestAmountOut: uint256 = 0\n\n    quotes: DynArray[Quote, MAX_QUOTES] = staticcall CurveRateProvider(CURVE_REGISTRIES.RateProvider).get_quotes(_tokenIn, _tokenOut, _amountIn)\n    for quote: Quote in quotes:\n        if quote.amount_out > bestAmountOut:\n            bestAmountOut = quote.amount_out\n            bestPool = quote.pool\n\n    return bestPool, bestAmountOut\n\n\n@view\n@external\ndef getSwapAmountOut(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n) -> uint256:\n    quotes: DynArray[Quote, MAX_QUOTES] = staticcall CurveRateProvider(CURVE_REGISTRIES.RateProvider).get_quotes(_tokenIn, _tokenOut, _amountIn)\n    bestAmountOut: uint256 = 0\n    for quote: Quote in quotes:\n        if _pool == quote.pool:\n            return quote.amount_out\n    return 0\n\n\n@view\n@external\ndef getBestSwapAmountIn(_tokenIn: address, _tokenOut: address, _amountOut: uint256) -> (address, uint256):\n    if _amountOut == 0 or _amountOut == max_value(uint256):\n        return empty(address), max_value(uint256)\n\n    expAmountIn: uint256 = self._getSwapAmountIn(empty(address), _tokenIn, _tokenOut, _amountOut)\n    if expAmountIn == 0:\n        return empty(address), 0\n\n    # NOTE: this isn't perfect, but it's good enough\n\n    bestPool: address = empty(address)\n    na: uint256 = 0\n    bestPool, na = self._getBestSwapAmountOut(_tokenIn, _tokenOut, expAmountIn)\n    return bestPool, expAmountIn\n\n\n@view\n@external\ndef getSwapAmountIn(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountOut: uint256,\n) -> uint256:\n    if _amountOut == 0 or _amountOut == max_value(uint256):\n        return max_value(uint256)\n    return self._getSwapAmountIn(_pool, _tokenIn, _tokenOut, _amountOut)\n\n\n@view\n@internal\ndef _getSwapAmountIn(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountOut: uint256,\n) -> uint256:\n    rate: uint256 = staticcall CurveRateProvider(CURVE_REGISTRIES.RateProvider).get_aggregated_rate(_tokenIn, _tokenOut)\n    if rate == 0:\n        return 0\n    decimalsTokenIn: uint256 = convert(staticcall IERC20Detailed(_tokenIn).decimals(), uint256)\n    return _amountOut * (10 ** decimalsTokenIn) // rate\n\n\n@view\n@external\ndef getAddLiqAmountsIn(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _availAmountA: uint256,\n    _availAmountB: uint256,\n) -> (uint256, uint256, uint256):\n    metaRegistry: address = CURVE_META_REGISTRY\n    p: PoolData = self._getPoolData(_pool, _tokenA, _tokenB, metaRegistry)\n\n    balances: uint256[8] = staticcall CurveMetaRegistry(metaRegistry).get_balances(_pool)\n    reserveA: uint256 = balances[p.indexTokenA]\n    reserveB: uint256 = balances[p.indexTokenB]\n\n    # insufficient liquidity\n    if reserveA == 0 or reserveB == 0:\n        return 0, 0, 0\n\n    # calculate optimal amounts\n    amountA: uint256 = 0\n    amountB: uint256 = 0\n    amountA, amountB = self._getCorrectRatioAmounts(_availAmountA, _availAmountB, reserveA, reserveB)\n\n    expectedLpAmount: uint256 = 0\n    if p.poolType == PoolType.STABLESWAP_NG:\n        expectedLpAmount = self._getAddLiqAmountsInStableNg(p, amountA, amountB)\n    elif p.poolType == PoolType.TWO_CRYPTO_NG:\n        expectedLpAmount = self._getAddLiqAmountsInCryptoNg(p, amountA, amountB)\n    elif p.poolType == PoolType.TWO_CRYPTO:\n        expectedLpAmount = self._getAddLiqAmountsInTwoCrypto(p, amountA, amountB)\n    elif p.poolType == PoolType.TRICRYPTO_NG:\n        expectedLpAmount = self._getAddLiqAmountsInTricrypto(p, amountA, amountB)\n    elif p.poolType == PoolType.METAPOOL and not staticcall CurveMetaRegistry(metaRegistry).is_meta(p.pool):\n        expectedLpAmount = self._getAddLiqAmountsInMetaPool(p, amountA, amountB)\n\n    if expectedLpAmount == 0:\n        return 0, 0, 0\n\n    return amountA, amountB, expectedLpAmount\n\n\n@view\n@external\ndef getRemoveLiqAmountsOut(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpAmount: uint256,\n) -> (uint256, uint256):\n    metaRegistry: address = CURVE_META_REGISTRY\n    p: PoolData = self._getPoolData(_pool, _tokenA, _tokenB, metaRegistry)\n\n    # NOTE: in this case, allowing 0x0 for one token, signifying desire to withdraw just one token\n\n    # normal scenario, 2-coin pool\n    if _tokenA != empty(address) and _tokenB != empty(address):\n        return self._getRemoveLiqAmountsOutTwoCoinPool(p, _tokenA, _tokenB, _lpAmount, metaRegistry)\n\n    # withdraw just one token\n    amountOut: uint256 = 0\n    tokenIndex: uint256 = p.indexTokenA\n    if _tokenA == empty(address):\n        tokenIndex = p.indexTokenB\n\n    # perform calculation\n    if p.poolType == PoolType.STABLESWAP_NG:\n        amountOut = staticcall StableNgTwo(p.pool).calc_withdraw_one_coin(_lpAmount, convert(tokenIndex, int128))\n    elif p.poolType == PoolType.TWO_CRYPTO_NG:\n        amountOut = staticcall TwoCryptoNgPool(p.pool).calc_withdraw_one_coin(_lpAmount, tokenIndex)\n    elif p.poolType == PoolType.TWO_CRYPTO:\n        amountOut = staticcall TwoCryptoPool(p.pool).calc_withdraw_one_coin(_lpAmount, tokenIndex)\n    elif p.poolType == PoolType.TRICRYPTO_NG:\n        amountOut = staticcall TriCryptoPool(p.pool).calc_withdraw_one_coin(_lpAmount, tokenIndex)\n    elif p.poolType == PoolType.METAPOOL and not staticcall CurveMetaRegistry(metaRegistry).is_meta(p.pool):\n        amountOut = staticcall MetaPoolCommon(p.pool).calc_withdraw_one_coin(_lpAmount, convert(tokenIndex, int128))\n\n    # get in correct order\n    amountA: uint256 = amountOut\n    amountB: uint256 = 0\n    if _tokenA == empty(address):\n        amountA = 0\n        amountB = amountOut\n\n    return amountA, amountB\n\n\n@view\n@external\ndef getPrice(_asset: address, _decimals: uint256) -> uint256:\n    return 0 # TODO: implement price\n\n\n@view\n@external\ndef getPriceUnsafe(_pool: address, _targetToken: address, _oracleRegistry: address = empty(address)) -> uint256:\n    return 0\n\n\n# internal utils\n\n\n@view\n@internal\ndef _getDeepestLiqPool(_tokenA: address, _tokenB: address, _allPools: DynArray[address, MAX_POOLS], _metaRegistry: address) -> (address, int128, int128, uint256):\n    bestPoolAddr: address = empty(address)\n    bestTokenAIndex: int128 = 0\n    bestTokenBIndex: int128 = 0\n    bestLiquidity: uint256 = 0\n\n    for i: uint256 in range(len(_allPools), bound=MAX_POOLS):\n        pool: address = _allPools[i]\n        if pool == empty(address):\n            continue\n\n        # balances\n        balances: uint256[8] = staticcall CurveMetaRegistry(_metaRegistry).get_balances(pool)\n        if balances[0] == 0:\n            continue\n\n        # token indexes \n        indexTokenA: int128 = 0\n        indexTokenB: int128 = 0\n        na: bool = False\n        indexTokenA, indexTokenB, na = staticcall CurveMetaRegistry(_metaRegistry).get_coin_indices(pool, _tokenA, _tokenB)\n\n        # compare liquidity\n        liquidity: uint256 = balances[indexTokenA] + balances[indexTokenB]\n        if liquidity > bestLiquidity:\n            bestPoolAddr = pool\n            bestTokenAIndex = indexTokenA\n            bestTokenBIndex = indexTokenB\n            bestLiquidity = liquidity\n\n    return bestPoolAddr, bestTokenAIndex, bestTokenBIndex, bestLiquidity\n\n\n@view\n@internal\ndef _getPoolData(_pool: address, _tokenA: address, _tokenB: address, _metaRegistry: address) -> PoolData:\n    assert staticcall CurveMetaRegistry(_metaRegistry).is_registered(_pool) # dev: invalid pool\n    coins: address[8] = staticcall CurveMetaRegistry(_metaRegistry).get_coins(_pool)\n\n    # validate tokens\n    if _tokenA != empty(address):\n        assert _tokenA in coins # dev: invalid tokens\n    if _tokenB != empty(address):\n        assert _tokenB in coins # dev: invalid tokens\n\n    # get indices\n    indexTokenA: uint256 = max_value(uint256)\n    indexTokenB: uint256 = max_value(uint256)\n    numCoins: uint256 = 0\n    for coin: address in coins:\n        if coin == empty(address):\n            break\n        if coin == _tokenA:\n            indexTokenA = numCoins\n        elif coin == _tokenB:\n            indexTokenB = numCoins\n        numCoins += 1\n\n    return PoolData(\n        pool=_pool,\n        indexTokenA=indexTokenA,\n        indexTokenB=indexTokenB,\n        poolType=self._getPoolType(_pool, _metaRegistry),\n        numCoins=numCoins,\n    )\n\n\n@view\n@internal\ndef _getPoolType(_pool: address, _metaRegistry: address) -> PoolType:\n    # check what type of pool this is based on where it's registered on Curve\n    registryHandlers: address[10] = staticcall CurveMetaRegistry(_metaRegistry).get_registry_handlers_from_pool(_pool)\n    baseRegistry: address = staticcall CurveMetaRegistry(_metaRegistry).get_base_registry(registryHandlers[0])\n\n    curveRegistries: CurveRegistries = CURVE_REGISTRIES\n    poolType: PoolType = empty(PoolType)\n    if baseRegistry == curveRegistries.StableSwapNg:\n        poolType = PoolType.STABLESWAP_NG\n    elif baseRegistry == curveRegistries.TwoCryptoNg:\n        poolType = PoolType.TWO_CRYPTO_NG\n    elif baseRegistry == curveRegistries.TricryptoNg:\n        poolType = PoolType.TRICRYPTO_NG\n    elif baseRegistry == curveRegistries.TwoCrypto:\n        poolType = PoolType.TWO_CRYPTO\n    elif baseRegistry == curveRegistries.MetaPool:\n        poolType = PoolType.METAPOOL\n    else:\n        poolType = PoolType.CRYPTO\n    return poolType\n\n\n@view\n@internal\ndef _getAddLiqAmountsInStableNg(\n    _p: PoolData,\n    _liqAmountA: uint256,\n    _liqAmountB: uint256,\n) -> uint256:\n    expLpAmount: uint256 = 0\n\n    if _p.numCoins == 2:\n        amounts: DynArray[uint256, 2] = [0, 0]\n        amounts[_p.indexTokenA] = _liqAmountA\n        amounts[_p.indexTokenB] = _liqAmountB\n        expLpAmount = staticcall StableNgTwo(_p.pool).calc_token_amount(amounts, True)\n\n    elif _p.numCoins == 3:\n        amounts: DynArray[uint256, 3] = [0, 0, 0]\n        amounts[_p.indexTokenA] = _liqAmountA\n        amounts[_p.indexTokenB] = _liqAmountB\n        expLpAmount = staticcall StableNgThree(_p.pool).calc_token_amount(amounts, True)\n\n    elif _p.numCoins == 4:\n        amounts: DynArray[uint256, 4] = [0, 0, 0, 0]\n        amounts[_p.indexTokenA] = _liqAmountA\n        amounts[_p.indexTokenB] = _liqAmountB\n        expLpAmount = staticcall StableNgFour(_p.pool).calc_token_amount(amounts, True)\n\n    return expLpAmount\n\n\n@view\n@internal\ndef _getAddLiqAmountsInCryptoNg(\n    _p: PoolData,\n    _liqAmountA: uint256,\n    _liqAmountB: uint256,\n) -> uint256:\n    amounts: uint256[2] = [0, 0]\n    amounts[_p.indexTokenA] = _liqAmountA\n    amounts[_p.indexTokenB] = _liqAmountB\n    return staticcall TwoCryptoNgPool(_p.pool).calc_token_amount(amounts, True)\n\n\n@view\n@internal\ndef _getAddLiqAmountsInTwoCrypto(\n    _p: PoolData,\n    _liqAmountA: uint256,\n    _liqAmountB: uint256,\n) -> uint256:\n    amounts: uint256[2] = [0, 0]\n    amounts[_p.indexTokenA] = _liqAmountA\n    amounts[_p.indexTokenB] = _liqAmountB\n    return staticcall TwoCryptoPool(_p.pool).calc_token_amount(amounts)\n\n\n@view\n@internal\ndef _getAddLiqAmountsInTricrypto(\n    _p: PoolData,\n    _liqAmountA: uint256,\n    _liqAmountB: uint256,\n) -> uint256:\n    amounts: uint256[3] = [0, 0, 0]\n    amounts[_p.indexTokenA] = _liqAmountA\n    amounts[_p.indexTokenB] = _liqAmountB\n    return staticcall TriCryptoPool(_p.pool).calc_token_amount(amounts, True)\n\n\n@view\n@internal\ndef _getAddLiqAmountsInMetaPool(\n    _p: PoolData,\n    _liqAmountA: uint256,\n    _liqAmountB: uint256,\n) -> uint256:\n    expLpAmount: uint256 = 0\n\n    if _p.numCoins == 2:\n        amounts: uint256[2] = [0, 0]\n        amounts[_p.indexTokenA] = _liqAmountA\n        amounts[_p.indexTokenB] = _liqAmountB\n        expLpAmount = staticcall MetaPoolTwo(_p.pool).calc_token_amount(amounts, True)\n\n    elif _p.numCoins == 3:\n        amounts: uint256[3] = [0, 0, 0]\n        amounts[_p.indexTokenA] = _liqAmountA\n        amounts[_p.indexTokenB] = _liqAmountB\n        expLpAmount = staticcall MetaPoolThree(_p.pool).calc_token_amount(amounts, True)\n\n    elif _p.numCoins == 4:\n        amounts: uint256[4] = [0, 0, 0, 0]\n        amounts[_p.indexTokenA] = _liqAmountA\n        amounts[_p.indexTokenB] = _liqAmountB\n        expLpAmount = staticcall MetaPoolFour(_p.pool).calc_token_amount(amounts, True)\n\n    return expLpAmount\n\n\n@view\n@internal\ndef _getRemoveLiqAmountsOutTwoCoinPool(\n    _p: PoolData,\n    _tokenA: address,\n    _tokenB: address,\n    _lpAmount: uint256,\n    _metaRegistry: address,\n) -> (uint256, uint256):\n\n    # only supporting 2-coin pools\n    if _p.numCoins > 2:\n        return max_value(uint256), max_value(uint256)\n\n    # get balances\n    balances: uint256[8] = staticcall CurveMetaRegistry(_metaRegistry).get_balances(_p.pool)\n    reserveA: uint256 = balances[_p.indexTokenA]\n    reserveB: uint256 = balances[_p.indexTokenB]\n\n    # insufficient liquidity\n    if reserveA == 0 or reserveB == 0:\n        return max_value(uint256), max_value(uint256)\n\n    # calculate expected amounts out\n    lpToken: address = staticcall CurveMetaRegistry(_metaRegistry).get_lp_token(_p.pool)\n    totalSupply: uint256 = staticcall IERC20(lpToken).totalSupply()\n    expectedAmountA: uint256 = _lpAmount * reserveA // totalSupply\n    expectedAmountB: uint256 = _lpAmount * reserveB // totalSupply\n    return expectedAmountA, expectedAmountB\n\n\n@view\n@internal\ndef _getCorrectRatioAmounts(\n    _availAmountA: uint256,\n    _availAmountB: uint256,\n    _reserveA: uint256,\n    _reserveB: uint256,\n) -> (uint256, uint256):\n    amountA: uint256 = _availAmountA\n    amountB: uint256 = self._quote(_availAmountA, _reserveA, _reserveB)\n    if amountB > _availAmountB:\n        maybeAmountA: uint256 = self._quote(_availAmountB, _reserveB, _reserveA)\n        if maybeAmountA <= _availAmountA:\n            amountA = maybeAmountA\n            amountB = _availAmountB\n    return amountA, amountB\n\n\n@view\n@internal\ndef _quote(_amountA: uint256, _reserveA: uint256, _reserveB: uint256) -> uint256:\n    return (_amountA * _reserveB) // _reserveA\n\n\n@view\n@external\ndef getAccessForLego(_user: address, _action: ws.ActionType) -> (address, String[64], uint256):\n    return empty(address), empty(String[64]), 0\n",
            "sha256sum": "37e6f17f9c63eee4966e8490a56b0eb33aeba2afb6687405b857a3e659769d49"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/legos/dexes/Curve.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.3+commit.bff19ea2",
        "integrity": "926cedd26ac0c8ab64d6ce965e090fc082231419211084407e000415ea4e9e8d"
      },
      "args": "00000000000000000000000044cf3c4f000dfd76a35d03298049d37be688d6f90000000000000000000000005ffe7fb82894076ecb99a30d6a32e969e6e35e98",
      "file": "contracts/legos/dexes/Curve.vy"
    },
    "UniswapV2": {
      "address": "0x810f6D4102a7196C4C9518615F331746414D4691",
      "abi": [
        {
          "name": "UniswapV2Swap",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenIn",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenOut",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amountIn",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "amountOut",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "numTokens",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UniswapV2LiquidityAdded",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenA",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenB",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amountA",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "amountB",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "lpAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UniswapV2LiquidityRemoved",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": false
            },
            {
              "name": "pool",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenA",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenB",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amountA",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "amountB",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "lpToken",
              "type": "address",
              "indexed": false
            },
            {
              "name": "lpAmountBurned",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LegoPauseModified",
          "inputs": [
            {
              "name": "isPaused",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LegoFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "balance",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddys",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "undyToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "hatchery",
                  "type": "address"
                },
                {
                  "name": "lootDistributor",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                },
                {
                  "name": "walletBackpack",
                  "type": "address"
                },
                {
                  "name": "billing",
                  "type": "address"
                },
                {
                  "name": "vaultRegistry",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUndyHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pause",
          "inputs": [
            {
              "name": "_shouldPause",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFundsMany",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_assets",
              "type": "address[]"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "legoId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isPaused",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasCapability",
          "inputs": [
            {
              "name": "_action",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRegistries",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isYieldLego",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isDexLego",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_tokenPath",
              "type": "address[]"
            },
            {
              "name": "_poolPath",
              "type": "address[]"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_tokenPath",
              "type": "address[]"
            },
            {
              "name": "_poolPath",
              "type": "address[]"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLpToken",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPoolForLpToken",
          "inputs": [
            {
              "name": "_lpToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getCoreRouterPool",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getDeepestLiqPool",
          "inputs": [
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "fee",
                  "type": "uint256"
                },
                {
                  "name": "liquidity",
                  "type": "uint256"
                },
                {
                  "name": "numCoins",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getBestSwapAmountOut",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountIn",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getSwapAmountOut",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountIn",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getBestSwapAmountIn",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountOut",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getSwapAmountIn",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountOut",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddLiqAmountsIn",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_availAmountA",
              "type": "uint256"
            },
            {
              "name": "_availAmountB",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRemoveLiqAmountsOut",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPrice",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_decimals",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPriceUnsafe",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_targetToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPriceUnsafe",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_targetToken",
              "type": "address"
            },
            {
              "name": "_appraiser",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositForYield",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositForYield",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawFromYield",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawFromYield",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_tokenInAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_tokenInAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmMintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmMintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_borrowAsset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_borrowAsset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_paymentAsset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_paymentAsset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAccessForLego",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_action",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "string"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "UNISWAP_V2_FACTORY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "UNISWAP_V2_ROUTER",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "coreRouterPool",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_undyHq",
              "type": "address"
            },
            {
              "name": "_uniswapV2Factory",
              "type": "address"
            },
            {
              "name": "_uniswapV2Router",
              "type": "address"
            },
            {
              "name": "_coreRouterPool",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "interfaces/WalletStructs.vyi": {
            "content": "# @version 0.4.3\n\nflag ActionType:\n    TRANSFER\n    EARN_DEPOSIT\n    EARN_WITHDRAW\n    EARN_REBALANCE\n    SWAP\n    MINT_REDEEM\n    CONFIRM_MINT_REDEEM\n    ADD_COLLATERAL\n    REMOVE_COLLATERAL\n    BORROW\n    REPAY_DEBT\n    REWARDS\n    ETH_TO_WETH\n    WETH_TO_ETH\n    ADD_LIQ\n    REMOVE_LIQ\n    ADD_LIQ_CONC\n    REMOVE_LIQ_CONC\n    PAY_CHEQUE\n\nstruct WalletAssetData:\n    assetBalance: uint256\n    usdValue: uint256\n    isYieldAsset: bool\n    lastPricePerShare: uint256\n\nstruct ActionData:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    billing: address\n    wallet: address\n    walletConfig: address\n    walletOwner: address\n    inEjectMode: bool\n    isFrozen: bool\n    lastTotalUsdValue: uint256\n    signer: address\n    isManager: bool\n    legoId: uint256\n    legoAddr: address\n    eth: address\n    weth: address\n\nstruct MiniAddys:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    appraiser: address",
            "sha256sum": "9a4b4f59b3a62043e51b425a665064aae419a3c0bd0514b6b29a9441ae364bb9"
          },
          "interfaces/LegoPartner.vyi": {
            "content": "# @version 0.4.3\n\nfrom interfaces import WalletStructs as ws\n\nMAX_TOKEN_PATH: constant(uint256) = 5\nMAX_RECOVER_ASSETS: constant(uint256) = 20\n\n@external\ndef addLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _tickLower: int24, _tickUpper: int24, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef addLiquidity(_pool: address, _tokenA: address, _tokenB: address, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _minLpAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (address, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef removeLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _liqToRemove: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef removeLiquidity(_pool: address, _tokenA: address, _tokenB: address, _lpToken: address, _lpAmount: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef mintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _tokenInAmount: uint256, _minAmountOut: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef swapTokens(_amountIn: uint256, _minAmountOut: uint256, _tokenPath: DynArray[address, MAX_TOKEN_PATH], _poolPath: DynArray[address, MAX_TOKEN_PATH - 1], _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256):\n    ...\n\n@external\ndef depositForYield(_asset: address, _amount: uint256, _vaultAddr: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef withdrawFromYield(_vaultToken: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef confirmMintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef borrow(_borrowAsset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef repayDebt(_paymentAsset: address, _paymentAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef claimRewards(_user: address, _rewardToken: address, _rewardAmount: uint256, _extraData: bytes32, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef removeCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef addCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@view\n@external\ndef getAccessForLego(_user: address, _action: ws.ActionType) -> (address, String[64], uint256):\n    ...\n\n@view\n@external\ndef hasCapability(_action: ws.ActionType) -> bool:\n    ...\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    ...\n\n@view\n@external\ndef isYieldLego() -> bool:\n    ...\n\n@view\n@external\ndef isDexLego() -> bool:\n    ...\n\n\n# common\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "81db71fe4440a3b4b563134c9b5caf1d5705772a5f291fe874c9b5fb3cfb1623"
          },
          "interfaces/DexLego.vyi": {
            "content": "# @version 0.4.3\n\n# used in smart contracts\n\n\n@view\n@external\ndef getLpToken(_pool: address) -> address:\n    ...\n\n\n# helper functions for server\n\n\n@view\n@external\ndef getPoolForLpToken(_lpToken: address) -> address:\n    ...\n\n\n@view\n@external\ndef getSwapAmountOut(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n) -> uint256:\n    ...\n\n\n@view\n@external\ndef getSwapAmountIn(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountOut: uint256,\n) -> uint256:\n    ...\n\n\n@view\n@external\ndef getAddLiqAmountsIn(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _availAmountA: uint256,\n    _availAmountB: uint256,\n) -> (uint256, uint256, uint256):\n    ...\n\n\n@view\n@external\ndef getRemoveLiqAmountsOut(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpAmount: uint256,\n) -> (uint256, uint256):\n    ...\n\n\n@view\n@external\ndef getPriceUnsafe(_pool: address, _targetToken: address, _appraiser: address = empty(address)) -> uint256:\n    ...\n\n\n@view\n@external\ndef getBestSwapAmountOut(_tokenIn: address, _tokenOut: address, _amountIn: uint256) -> (address, uint256):\n    ...\n\n\n@view\n@external\ndef getBestSwapAmountIn(_tokenIn: address, _tokenOut: address, _amountOut: uint256) -> (address, uint256):\n    ...\n\n\n@view\n@external\ndef getCoreRouterPool() -> address:\n    ...\n\n\n@view\n@external\ndef getPrice(_asset: address, _decimals: uint256) -> uint256:\n    ...\n",
            "sha256sum": "6248ad46926f00481cb3469bfc7af8fe36669c2ca0dd98e9a0befdda0fc43fd7"
          },
          "contracts/modules/Addys.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\ninterface UndyHq:\n    def isValidAddr(_addr: address) -> bool: view\n    def getAddr(_regId: uint256) -> address: view\n    def undyToken() -> address: view\n\ninterface Switchboard:\n    def isSwitchboardAddr(_addr: address) -> bool: view\n\ninterface LegoBook:\n    def isLegoAddr(_addr: address) -> bool: view\n\nstruct Addys:\n    hq: address\n    undyToken: address\n    ledger: address\n    missionControl: address\n    legoBook: address\n    switchboard: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    walletBackpack: address\n    billing: address\n    vaultRegistry: address\n\n# hq\nUNDY_HQ_FOR_ADDYS: immutable(address)\n\n# core addys\nLEDGER_ID: constant(uint256) = 1\nMISSION_CONTROL_ID: constant(uint256) = 2\nLEGO_BOOK_ID: constant(uint256) = 3\nSWITCHBOARD_ID: constant(uint256) = 4\nHATCHERY_ID: constant(uint256) = 5\nLOOT_DISTRIBUTOR_ID: constant(uint256) = 6\nAPPRAISER_ID: constant(uint256) = 7\nWALLET_BACKPACK_ID: constant(uint256) = 8\nBILLING_ID: constant(uint256) = 9\nVAULT_REGISTRY_ID: constant(uint256) = 10\n\n\n@deploy\ndef __init__(_undyHq: address):\n    assert _undyHq != empty(address) # dev: invalid undy hq\n    UNDY_HQ_FOR_ADDYS = _undyHq\n\n\n########\n# Core #\n########\n\n\n@view\n@external\ndef getAddys() -> Addys:\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _getAddys(_addys: Addys = empty(Addys)) -> Addys:\n    if _addys.hq != empty(address):\n        return _addys\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _generateAddys() -> Addys:\n    hq: address = UNDY_HQ_FOR_ADDYS\n    return Addys(\n        hq = hq,\n        undyToken = staticcall UndyHq(hq).undyToken(),\n        ledger = staticcall UndyHq(hq).getAddr(LEDGER_ID),\n        missionControl = staticcall UndyHq(hq).getAddr(MISSION_CONTROL_ID),\n        legoBook = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID),\n        switchboard = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID),\n        hatchery = staticcall UndyHq(hq).getAddr(HATCHERY_ID),\n        lootDistributor = staticcall UndyHq(hq).getAddr(LOOT_DISTRIBUTOR_ID),\n        appraiser = staticcall UndyHq(hq).getAddr(APPRAISER_ID),\n        walletBackpack = staticcall UndyHq(hq).getAddr(WALLET_BACKPACK_ID),\n        billing = staticcall UndyHq(hq).getAddr(BILLING_ID),\n        vaultRegistry = staticcall UndyHq(hq).getAddr(VAULT_REGISTRY_ID),\n    )\n\n\n##########\n# Tokens #\n##########\n\n\n@view\n@internal\ndef _getUndyToken() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).undyToken()\n\n\n###########\n# Helpers #\n###########\n\n\n# undy hq\n\n\n@view\n@external\ndef getUndyHq() -> address:\n    return self._getUndyHq()\n\n\n@view\n@internal\ndef _getUndyHq() -> address:\n    return UNDY_HQ_FOR_ADDYS\n\n\n# utils\n\n\n@view\n@internal\ndef _isValidUndyAddr(_addr: address, _hq: address = empty(address)) -> bool:\n    hq: address = _hq\n    if _hq == empty(address):\n        hq = UNDY_HQ_FOR_ADDYS\n    \n    # core departments\n    if staticcall UndyHq(hq).isValidAddr(_addr):\n        return True\n\n    # lego book\n    legoBook: address = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID)\n    if legoBook != empty(address) and staticcall LegoBook(legoBook).isLegoAddr(_addr):\n        return True\n\n    # switchboard config\n    switchboard: address = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID)\n    if switchboard != empty(address) and staticcall Switchboard(switchboard).isSwitchboardAddr(_addr):\n        return True\n\n    return False\n\n\n@view\n@internal\ndef _isSwitchboardAddr(_addr: address) -> bool:\n    switchboard: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n    if switchboard == empty(address):\n        return False\n    return staticcall Switchboard(switchboard).isSwitchboardAddr(_addr)\n\n\n@view\n@internal\ndef _isLegoBookAddr(_addr: address) -> bool:\n    legoBook: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n    if legoBook == empty(address):\n        return False\n    return staticcall LegoBook(legoBook).isLegoAddr(_addr)\n\n\n###############\n# Departments #\n###############\n\n\n# ledger\n\n\n@view\n@internal\ndef _getLedgerId() -> uint256:\n    return LEDGER_ID\n\n\n@view\n@internal\ndef _getLedgerAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEDGER_ID)\n\n\n# mission control\n\n\n@view\n@internal\ndef _getMissionControlId() -> uint256:\n    return MISSION_CONTROL_ID\n\n\n@view\n@internal\ndef _getMissionControlAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(MISSION_CONTROL_ID)\n\n\n# lego book\n\n\n@view\n@internal\ndef _getLegoBookId() -> uint256:\n    return LEGO_BOOK_ID\n\n\n@view\n@internal\ndef _getLegoBookAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n\n\n# switchboard\n\n\n@view\n@internal\ndef _getSwitchboardId() -> uint256:\n    return SWITCHBOARD_ID\n\n\n@view\n@internal\ndef _getSwitchboardAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n\n\n# hatchery\n\n\n@view\n@internal\ndef _getHatcheryId() -> uint256:\n    return HATCHERY_ID\n\n\n@view\n@internal\ndef _getHatcheryAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(HATCHERY_ID)\n\n\n# loot distributor\n\n\n@view\n@internal\ndef _getLootDistributorId() -> uint256:\n    return LOOT_DISTRIBUTOR_ID\n\n\n@view\n@internal\ndef _getLootDistributorAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LOOT_DISTRIBUTOR_ID)\n\n\n# appraiser\n\n\n@view\n@internal\ndef _getAppraiserId() -> uint256:\n    return APPRAISER_ID\n\n\n@view\n@internal\ndef _getAppraiserAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(APPRAISER_ID)\n\n\n# wallet backpack\n\n\n@view\n@internal\ndef _getWalletBackpackId() -> uint256:\n    return WALLET_BACKPACK_ID\n\n\n@view\n@internal\ndef _getWalletBackpackAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(WALLET_BACKPACK_ID)\n\n\n# billing\n\n\n@view\n@internal\ndef _getBillingId() -> uint256:\n    return BILLING_ID\n\n\n@view\n@internal\ndef _getBillingAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(BILLING_ID)\n\n\n# vault registry\n\n\n@view\n@internal\ndef _getVaultRegistryId() -> uint256:\n    return VAULT_REGISTRY_ID\n\n\n@view\n@internal\ndef _getVaultRegistryAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(VAULT_REGISTRY_ID)",
            "sha256sum": "4df6b72db9bb417d1af81660175be1450cfb7b3575f3d17a5b8a130bff87b781"
          },
          "contracts/modules/DexLegoData.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nuses: addys\n\nimport contracts.modules.Addys as addys\n\nfrom interfaces import WalletStructs as ws\nfrom ethereum.ercs import IERC20\n\nevent LegoPauseModified:\n    isPaused: bool\n\nevent LegoFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    balance: uint256\n\n# config\nlegoId: public(uint256)\nisPaused: public(bool)\n\nMAX_RECOVER_ASSETS: constant(uint256) = 20\n\n\n@deploy\ndef __init__(_shouldPause: bool):\n    self.isPaused = _shouldPause\n\n\n###########\n# General #\n###########\n\n\n# fill mini addys\n\n\n@view\n@internal\ndef _getMiniAddys(_miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> ws.MiniAddys:\n    if _miniAddys.ledger != empty(address):\n        return _miniAddys\n    return ws.MiniAddys(\n        ledger = addys._getLedgerAddr(),\n        missionControl = addys._getMissionControlAddr(),\n        legoBook = addys._getLegoBookAddr(),\n        appraiser = addys._getAppraiserAddr(),\n    )\n\n\n# activate\n\n\n@external\ndef pause(_shouldPause: bool):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert _shouldPause != self.isPaused # dev: no change\n    self.isPaused = _shouldPause\n    log LegoPauseModified(isPaused=_shouldPause)\n\n\n# recover funds\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    self._recoverFunds(_recipient, _asset)\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, MAX_RECOVER_ASSETS]):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    for a: address in _assets:\n        self._recoverFunds(_recipient, a)\n\n\n@internal\ndef _recoverFunds(_recipient: address, _asset: address):\n    assert empty(address) not in [_recipient, _asset] # dev: invalid recipient or asset\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    assert balance != 0 # dev: nothing to recover\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log LegoFundsRecovered(asset=_asset, recipient=_recipient, balance=balance)",
            "sha256sum": "75b15af2475ab409d4b5fd057509d14c20564ebd7fcb0850e3b61397d8e3af48"
          },
          "contracts/legos/dexes/UniswapV2.vy": {
            "content": "#     _____  _____  __  __    ____   _____  _____  _____ \n#    |  _  \\/   __\\/  \\/  \\  /  _/  /   __\\/   __\\/  _  \\\n#    |  |  ||   __|>-    -<  |  |---|   __||  |_ ||  |  |\n#    |_____/\\_____/\\__/\\__/  \\_____/\\_____/\\_____/\\_____/\n#                                                                       \n#     \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n#     \u2551  ** Uniswap V2 Lego **           \u2551\n#     \u2551  Integration with Uniswap V2.    \u2551\n#     \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n#\n#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nimplements: Lego\nimplements: DexLego\n\nexports: addys.__interface__\nexports: dld.__interface__\n\ninitializes: addys\ninitializes: dld[addys := addys]\n\nfrom interfaces import LegoPartner as Lego\nfrom interfaces import DexLego as DexLego\nfrom interfaces import WalletStructs as ws\n\nimport contracts.modules.Addys as addys\nimport contracts.modules.DexLegoData as dld\n\nfrom ethereum.ercs import IERC20\nfrom ethereum.ercs import IERC20Detailed\n\ninterface IUniswapV2Pair:\n    def swap(_amount0Out: uint256, _amount1Out: uint256, _recipient: address, _data: Bytes[256]): nonpayable\n    def getReserves() -> (uint112, uint112, uint32): view\n    def token0() -> address: view\n    def token1() -> address: view\n\ninterface Appraiser:\n    def getNormalAssetPrice(_asset: address, _missionControl: address = empty(address), _legoBook: address = empty(address), _ledger: address = empty(address)) -> uint256: view\n    def updatePriceAndGetUsdValue(_asset: address, _amount: uint256, _missionControl: address = empty(address), _legoBook: address = empty(address)) -> uint256: nonpayable\n\ninterface UniV2Router:\n    def addLiquidity(_tokenA: address, _tokenB: address, _amountADesired: uint256, _amountBDesired: uint256, _amountAMin: uint256, _amountBMin: uint256, _recipient: address, _deadline: uint256) -> (uint256, uint256, uint256): nonpayable\n    def removeLiquidity(_tokenA: address, _tokenB: address, _lpAmount: uint256, _amountAMin: uint256, _amountBMin: uint256, _recipient: address, _deadline: uint256) -> (uint256, uint256): nonpayable\n\ninterface UniV2Factory:\n    def getPair(_tokenA: address, _tokenB: address) -> address: view\n\nstruct BestPool:\n    pool: address\n    fee: uint256\n    liquidity: uint256\n    numCoins: uint256\n\nstruct Route:\n    from_: address\n    to: address \n    stable: bool\n    factory: address\n\nevent UniswapV2Swap:\n    sender: indexed(address)\n    tokenIn: indexed(address)\n    tokenOut: indexed(address)\n    amountIn: uint256\n    amountOut: uint256\n    usdValue: uint256\n    numTokens: uint256\n    recipient: address\n\nevent UniswapV2LiquidityAdded:\n    sender: indexed(address)\n    tokenA: indexed(address)\n    tokenB: indexed(address)\n    amountA: uint256\n    amountB: uint256\n    lpAmountReceived: uint256\n    usdValue: uint256\n    recipient: address\n\nevent UniswapV2LiquidityRemoved:\n    sender: address\n    pool: indexed(address)\n    tokenA: indexed(address)\n    tokenB: indexed(address)\n    amountA: uint256\n    amountB: uint256\n    lpToken: address\n    lpAmountBurned: uint256\n    usdValue: uint256\n    recipient: address\n\n# uniswap v2\nUNISWAP_V2_FACTORY: public(immutable(address))\nUNISWAP_V2_ROUTER: public(immutable(address))\ncoreRouterPool: public(address)\n\nEIGHTEEN_DECIMALS: constant(uint256) = 10 ** 18\nMAX_TOKEN_PATH: constant(uint256) = 5\n\n\n@deploy\ndef __init__(\n    _undyHq: address,\n    _uniswapV2Factory: address,\n    _uniswapV2Router: address,\n    _coreRouterPool: address,\n):\n    addys.__init__(_undyHq)\n    dld.__init__(False)\n\n    assert empty(address) not in [_uniswapV2Factory, _uniswapV2Router, _coreRouterPool] # dev: invalid addrs\n    UNISWAP_V2_FACTORY = _uniswapV2Factory\n    UNISWAP_V2_ROUTER = _uniswapV2Router\n    self.coreRouterPool = _coreRouterPool\n\n\n@view\n@external\ndef hasCapability(_action: ws.ActionType) -> bool:\n    return _action in (\n        ws.ActionType.SWAP |\n        ws.ActionType.ADD_LIQ | \n        ws.ActionType.REMOVE_LIQ\n    )\n\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    return [UNISWAP_V2_FACTORY, UNISWAP_V2_ROUTER]\n\n\n@view\n@external\ndef isYieldLego() -> bool:\n    return False\n\n\n@view\n@external\ndef isDexLego() -> bool:\n    return True\n\n\n#########\n# Swaps #\n#########\n\n\n@external\ndef swapTokens(\n    _amountIn: uint256,\n    _minAmountOut: uint256,\n    _tokenPath: DynArray[address, MAX_TOKEN_PATH],\n    _poolPath: DynArray[address, MAX_TOKEN_PATH - 1],\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256):\n    assert not dld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = dld._getMiniAddys(_miniAddys)\n\n    # validate inputs\n    numTokens: uint256 = len(_tokenPath)\n    numPools: uint256 = len(_poolPath)\n    assert numTokens >= 2 # dev: invalid path\n    assert numPools == numTokens - 1 # dev: invalid path\n\n    # get first token and last token\n    tokenIn: address = _tokenPath[0]\n    tokenOut: address = _tokenPath[numTokens - 1]\n\n    # pre balances\n    preLegoBalance: uint256 = staticcall IERC20(tokenIn).balanceOf(self)\n\n    # transfer deposit asset to this contract\n    amountIn: uint256 = min(_amountIn, staticcall IERC20(tokenIn).balanceOf(msg.sender))\n    assert amountIn != 0 # dev: nothing to transfer\n    assert extcall IERC20(tokenIn).transferFrom(msg.sender, self, amountIn, default_return_value=True) # dev: transfer failed\n\n    # adjust min amount out\n    minAmountOut: uint256 = _minAmountOut\n    if amountIn < _amountIn and _amountIn != max_value(uint256):\n        minAmountOut = _minAmountOut * amountIn // _amountIn\n\n    # transfer initial amount to first pool\n    assert extcall IERC20(tokenIn).transfer(_poolPath[0], amountIn, default_return_value=True) # dev: transfer failed\n\n    # iterate through swap routes\n    tempAmountIn: uint256 = amountIn\n    uniswapV2Factory: address = UNISWAP_V2_FACTORY\n    for i: uint256 in range(numTokens - 1, bound=MAX_TOKEN_PATH):\n        tempTokenIn: address = _tokenPath[i]\n        tempTokenOut: address = _tokenPath[i + 1]\n        tempPool: address = _poolPath[i]\n\n        # transfer to next pool (or to recipient if last swap)\n        recipient: address = _recipient\n        if i < numTokens - 2:\n            recipient = _poolPath[i + 1]\n\n        # swap\n        tempAmountIn = self._swapTokensInPool(tempPool, tempTokenIn, tempTokenOut, tempAmountIn, recipient, uniswapV2Factory)\n\n    # final amount\n    amountOut: uint256 = tempAmountIn\n    assert amountOut >= minAmountOut # dev: min amount out not met\n\n    # refund if full swap didn't get through\n    currentLegoBalance: uint256 = staticcall IERC20(tokenIn).balanceOf(self)\n    refundAssetAmount: uint256 = 0\n    if currentLegoBalance > preLegoBalance:\n        refundAssetAmount = currentLegoBalance - preLegoBalance\n        assert extcall IERC20(tokenIn).transfer(msg.sender, refundAssetAmount, default_return_value=True) # dev: transfer failed\n        amountIn -= refundAssetAmount\n\n    # get usd values\n    usdValue: uint256 = extcall Appraiser(miniAddys.appraiser).updatePriceAndGetUsdValue(tokenIn, amountIn, miniAddys.missionControl, miniAddys.legoBook)\n    if usdValue == 0:\n        usdValue = extcall Appraiser(miniAddys.appraiser).updatePriceAndGetUsdValue(tokenOut, amountOut, miniAddys.missionControl, miniAddys.legoBook)\n\n    log UniswapV2Swap(\n        sender = msg.sender,\n        tokenIn = tokenIn,\n        tokenOut = tokenOut,\n        amountIn = amountIn,\n        amountOut = amountOut,\n        usdValue = usdValue,\n        numTokens = numTokens,\n        recipient = _recipient,\n    )\n    return amountIn, amountOut, usdValue\n\n\n# swap in pool\n\n\n@internal\ndef _swapTokensInPool(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n    _recipient: address,\n    _uniswapV2Factory: address,\n) -> uint256:\n    tokens: address[2] = [staticcall IUniswapV2Pair(_pool).token0(), staticcall IUniswapV2Pair(_pool).token1()]\n    assert _tokenIn in tokens # dev: invalid tokenIn\n    assert _tokenOut in tokens # dev: invalid tokenOut\n    assert _tokenIn != _tokenOut # dev: invalid tokens\n\n    # verify actual uniswap v2 pool\n    assert staticcall UniV2Factory(_uniswapV2Factory).getPair(_tokenIn, _tokenOut) == _pool # dev: invalid pool\n\n    zeroForOne: bool = _tokenIn == tokens[0]\n    amountOut: uint256 = self._getAmountOut(_pool, zeroForOne, _amountIn)\n    assert amountOut != 0 # dev: no tokens swapped\n\n    # put in correct order\n    amount0Out: uint256 = amountOut\n    amount1Out: uint256 = 0\n    if zeroForOne:\n        amount0Out = 0\n        amount1Out = amountOut\n\n    # perform swap\n    extcall IUniswapV2Pair(_pool).swap(amount0Out, amount1Out, _recipient, b\"\")\n    return amountOut\n\n\n#############\n# Liquidity #\n#############\n\n\n# add liquidity\n\n\n@external\ndef addLiquidity(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _amountA: uint256,\n    _amountB: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _minLpAmount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (address, uint256, uint256, uint256, uint256):\n    assert not dld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = dld._getMiniAddys(_miniAddys)\n\n    # validate tokens\n    tokens: address[2] = [staticcall IUniswapV2Pair(_pool).token0(), staticcall IUniswapV2Pair(_pool).token1()]\n    assert _tokenA in tokens # dev: invalid tokenA\n    assert _tokenB in tokens # dev: invalid tokenB\n    assert _tokenA != _tokenB # dev: invalid tokens\n\n    # pre balances\n    preLegoBalanceA: uint256 = staticcall IERC20(_tokenA).balanceOf(self)\n    preLegoBalanceB: uint256 = staticcall IERC20(_tokenB).balanceOf(self)\n\n    # token a\n    liqAmountA: uint256 = min(_amountA, staticcall IERC20(_tokenA).balanceOf(msg.sender))\n    assert liqAmountA != 0 # dev: nothing to transfer\n    assert extcall IERC20(_tokenA).transferFrom(msg.sender, self, liqAmountA, default_return_value=True) # dev: transfer failed\n\n    # token b\n    liqAmountB: uint256 = min(_amountB, staticcall IERC20(_tokenB).balanceOf(msg.sender))\n    assert liqAmountB != 0 # dev: nothing to transfer\n    assert extcall IERC20(_tokenB).transferFrom(msg.sender, self, liqAmountB, default_return_value=True) # dev: transfer failed\n\n    # approvals\n    router: address = UNISWAP_V2_ROUTER\n    assert extcall IERC20(_tokenA).approve(router, liqAmountA, default_return_value=True) # dev: approval failed\n    assert extcall IERC20(_tokenB).approve(router, liqAmountB, default_return_value=True) # dev: approval failed\n\n    # add liquidity\n    lpAmountReceived: uint256 = 0\n    liqAmountA, liqAmountB, lpAmountReceived = extcall UniV2Router(router).addLiquidity(\n        _tokenA,\n        _tokenB,\n        liqAmountA,\n        liqAmountB,\n        _minAmountA,\n        _minAmountB,\n        _recipient,\n        block.timestamp,\n    )\n    assert lpAmountReceived != 0 # dev: no liquidity added\n\n    # reset approvals\n    assert extcall IERC20(_tokenA).approve(router, 0, default_return_value=True) # dev: approval failed\n    assert extcall IERC20(_tokenB).approve(router, 0, default_return_value=True) # dev: approval failed\n\n    # refund if full liquidity was not added\n    currentLegoBalanceA: uint256 = staticcall IERC20(_tokenA).balanceOf(self)\n    refundAssetAmountA: uint256 = 0\n    if currentLegoBalanceA > preLegoBalanceA:\n        refundAssetAmountA = currentLegoBalanceA - preLegoBalanceA\n        assert extcall IERC20(_tokenA).transfer(msg.sender, refundAssetAmountA, default_return_value=True) # dev: transfer failed\n\n    currentLegoBalanceB: uint256 = staticcall IERC20(_tokenB).balanceOf(self)\n    refundAssetAmountB: uint256 = 0\n    if currentLegoBalanceB > preLegoBalanceB:\n        refundAssetAmountB = currentLegoBalanceB - preLegoBalanceB\n        assert extcall IERC20(_tokenB).transfer(msg.sender, refundAssetAmountB, default_return_value=True) # dev: transfer failed\n\n    usdValue: uint256 = self._getUsdValue(_tokenA, liqAmountA, _tokenB, liqAmountB, miniAddys)\n    log UniswapV2LiquidityAdded(\n        sender = msg.sender,\n        tokenA = _tokenA,\n        tokenB = _tokenB,\n        amountA = liqAmountA,\n        amountB = liqAmountB,\n        lpAmountReceived = lpAmountReceived,\n        usdValue = usdValue,\n        recipient = _recipient,\n    )\n    return _pool, lpAmountReceived, liqAmountA, liqAmountB, usdValue\n\n\n# remove liquidity\n\n\n@external\ndef removeLiquidity(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpToken: address,\n    _lpAmount: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, uint256):\n    assert not dld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = dld._getMiniAddys(_miniAddys)\n\n    # validate tokens\n    tokens: address[2] = [staticcall IUniswapV2Pair(_pool).token0(), staticcall IUniswapV2Pair(_pool).token1()]\n    assert _tokenA in tokens # dev: invalid tokenA\n    assert _tokenB in tokens # dev: invalid tokenB\n    assert _tokenA != _tokenB # dev: invalid tokens\n\n    # pre balance\n    preLegoBalance: uint256 = staticcall IERC20(_lpToken).balanceOf(self)\n\n    # lp token\n    lpAmount: uint256 = min(_lpAmount, staticcall IERC20(_lpToken).balanceOf(msg.sender))\n    assert lpAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_lpToken).transferFrom(msg.sender, self, lpAmount, default_return_value=True) # dev: transfer failed\n\n    # approvals\n    router: address = UNISWAP_V2_ROUTER\n    assert extcall IERC20(_lpToken).approve(router, lpAmount, default_return_value=True) # dev: approval failed\n\n    # remove liquidity\n    amountA: uint256 = 0\n    amountB: uint256 = 0\n    amountA, amountB = extcall UniV2Router(router).removeLiquidity(\n        _tokenA,\n        _tokenB,\n        lpAmount,\n        _minAmountA,\n        _minAmountB,\n        _recipient,\n        block.timestamp,\n    )\n    assert amountA != 0 # dev: no amountA removed\n    assert amountB != 0 # dev: no amountB removed\n\n    # reset approvals\n    assert extcall IERC20(_lpToken).approve(router, 0, default_return_value=True) # dev: approval failed\n\n    # refund if full liquidity was not removed\n    currentLegoBalance: uint256 = staticcall IERC20(_lpToken).balanceOf(self)\n    refundedLpAmount: uint256 = 0\n    if currentLegoBalance > preLegoBalance:\n        refundedLpAmount = currentLegoBalance - preLegoBalance\n        assert extcall IERC20(_lpToken).transfer(msg.sender, refundedLpAmount, default_return_value=True) # dev: transfer failed\n        lpAmount -= refundedLpAmount\n\n    usdValue: uint256 = self._getUsdValue(_tokenA, amountA, _tokenB, amountB, miniAddys)\n    log UniswapV2LiquidityRemoved(\n        sender = msg.sender,\n        pool = _pool,\n        tokenA = _tokenA,\n        tokenB = _tokenB,\n        amountA = amountA,\n        amountB = amountB,\n        lpToken = _lpToken,\n        lpAmountBurned = lpAmount,\n        usdValue = usdValue,\n        recipient = _recipient,\n    )\n    return amountA, amountB, lpAmount, usdValue\n\n\n# get usd value on liquidity actions\n\n\n@internal\ndef _getUsdValue(\n    _tokenA: address,\n    _amountA: uint256,\n    _tokenB: address,\n    _amountB: uint256,\n    _miniAddys: ws.MiniAddys,\n) -> uint256:\n\n    usdValueA: uint256 = 0\n    if _amountA != 0:\n        usdValueA = extcall Appraiser(_miniAddys.appraiser).updatePriceAndGetUsdValue(_tokenA, _amountA, _miniAddys.missionControl, _miniAddys.legoBook)\n\n    usdValueB: uint256 = 0\n    if _amountB != 0:\n        usdValueB = extcall Appraiser(_miniAddys.appraiser).updatePriceAndGetUsdValue(_tokenB, _amountB, _miniAddys.missionControl, _miniAddys.legoBook)\n\n    return usdValueA + usdValueB\n\n\n#############\n# Utilities #\n#############\n\n\n@view\n@external\ndef getLpToken(_pool: address) -> address:\n    # in uniswap v2, the lp token is the pool address\n    return _pool\n\n\n@view\n@external\ndef getPoolForLpToken(_lpToken: address) -> address:\n    # in uniswap v2, the pool is the lp token address\n    return _lpToken\n\n\n@view\n@external\ndef getCoreRouterPool() -> address:\n    return self.coreRouterPool\n\n\n@view\n@external\ndef getDeepestLiqPool(_tokenA: address, _tokenB: address) -> BestPool:\n    pool: address = staticcall UniV2Factory(UNISWAP_V2_FACTORY).getPair(_tokenA, _tokenB)\n    if pool == empty(address):\n        return empty(BestPool)\n\n    # get reserves\n    reserve0: uint112 = 0\n    reserve1: uint112 = 0\n    na: uint32 = 0\n    reserve0, reserve1, na = staticcall IUniswapV2Pair(pool).getReserves()\n\n    return BestPool(\n        pool=pool,\n        fee=30, # 0.3%, denominator is 100_00\n        liquidity=convert(reserve0 + reserve1, uint256),\n        numCoins=2,\n    )\n\n\n@view\n@external\ndef getBestSwapAmountOut(_tokenIn: address, _tokenOut: address, _amountIn: uint256) -> (address, uint256):\n    pool: address = staticcall UniV2Factory(UNISWAP_V2_FACTORY).getPair(_tokenIn, _tokenOut)\n    if pool == empty(address):\n        return empty(address), 0\n    token0: address = staticcall IUniswapV2Pair(pool).token0()\n    return pool, self._getAmountOut(pool, _tokenIn == token0, _amountIn)\n\n\n@view\n@external\ndef getSwapAmountOut(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n) -> uint256:\n    token0: address = staticcall IUniswapV2Pair(_pool).token0()\n    return self._getAmountOut(_pool, _tokenIn == token0, _amountIn)\n\n\n@view\n@external\ndef getBestSwapAmountIn(_tokenIn: address, _tokenOut: address, _amountOut: uint256) -> (address, uint256):\n    pool: address = staticcall UniV2Factory(UNISWAP_V2_FACTORY).getPair(_tokenIn, _tokenOut)\n    if pool == empty(address):\n        return empty(address), 0\n    token0: address = staticcall IUniswapV2Pair(pool).token0()\n    return pool, self._getAmountIn(pool, _tokenIn == token0, _amountOut)\n\n\n@view\n@external\ndef getSwapAmountIn(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountOut: uint256,\n) -> uint256:\n    token0: address = staticcall IUniswapV2Pair(_pool).token0()\n    return self._getAmountIn(_pool, _tokenIn == token0, _amountOut)\n\n\n@view\n@external\ndef getAddLiqAmountsIn(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _availAmountA: uint256,\n    _availAmountB: uint256,\n) -> (uint256, uint256, uint256):\n    token0: address = staticcall IUniswapV2Pair(_pool).token0()\n\n    reserveA: uint256 = 0\n    reserveB: uint256 = 0\n    reserveA, reserveB = self._getReserves(_pool, _tokenA == token0)\n\n    # insufficient liquidity\n    if reserveA == 0 or reserveB == 0:\n        return 0, 0, 0\n\n    # calculate optimal amounts\n    amountA: uint256 = _availAmountA\n    amountB: uint256 = self._quote(_availAmountA, reserveA, reserveB)\n    if amountB > _availAmountB:\n        maybeAmountA: uint256 = self._quote(_availAmountB, reserveB, reserveA)\n        if maybeAmountA <= _availAmountA:\n            amountA = maybeAmountA\n            amountB = _availAmountB\n    return amountA, amountB, 0\n\n\n@view\n@external\ndef getRemoveLiqAmountsOut(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpAmount: uint256,\n) -> (uint256, uint256):\n    token0: address = staticcall IUniswapV2Pair(_pool).token0()\n\n    reserveA: uint256 = 0\n    reserveB: uint256 = 0\n    reserveA, reserveB = self._getReserves(_pool, _tokenA == token0)\n\n    # insufficient liquidity\n    if reserveA == 0 or reserveB == 0:\n        return max_value(uint256), max_value(uint256)\n\n    # calculate expected amounts out\n    totalSupply: uint256 = staticcall IERC20(_pool).totalSupply()\n    expectedAmountA: uint256 = _lpAmount * reserveA // totalSupply\n    expectedAmountB: uint256 = _lpAmount * reserveB // totalSupply\n    return expectedAmountA, expectedAmountB\n\n\n@view\n@external\ndef getPrice(_asset: address, _decimals: uint256) -> uint256:\n    return 0 # TODO: implement price\n\n\n@view\n@external\ndef getPriceUnsafe(_pool: address, _targetToken: address, _appraiser: address = empty(address)) -> uint256:\n    token0: address = staticcall IUniswapV2Pair(_pool).token0()\n    token1: address = staticcall IUniswapV2Pair(_pool).token1()\n\n    # appraiser\n    appraiser: address = _appraiser\n    if _appraiser == empty(address):\n        appraiser = addys._getAppraiserAddr()\n\n    # alt price\n    altPrice: uint256 = 0\n    if _targetToken == token0:\n        altPrice = staticcall Appraiser(appraiser).getNormalAssetPrice(token1)\n    else:\n        altPrice = staticcall Appraiser(appraiser).getNormalAssetPrice(token0)\n\n    # return early if no alt price\n    if altPrice == 0:\n        return 0\n\n    # reserves\n    reserve0: uint112 = 0\n    reserve1: uint112 = 0\n    na: uint32 = 0\n    reserve0, reserve1, na = staticcall IUniswapV2Pair(_pool).getReserves()\n\n    # avoid division by zero\n    if reserve0 == 0 or reserve1 == 0:\n        return 0  \n\n    # price of token0 in token1\n    priceZeroToOne: uint256 = convert(reserve1, uint256) * EIGHTEEN_DECIMALS // convert(reserve0, uint256)\n\n    # adjust for decimals: price should be in 18 decimals\n    decimals0: uint256 = convert(staticcall IERC20Detailed(token0).decimals(), uint256)\n    decimals1: uint256 = convert(staticcall IERC20Detailed(token1).decimals(), uint256)\n    if decimals0 > decimals1:\n        scaleFactor: uint256 = 10 ** (decimals0 - decimals1)\n        priceZeroToOne = priceZeroToOne * scaleFactor\n    elif decimals1 > decimals0:\n        scaleFactor: uint256 = 10 ** (decimals1 - decimals0)\n        priceZeroToOne = priceZeroToOne // scaleFactor\n\n    # if _targetToken is token1, make price inverse\n    priceToOther: uint256 = priceZeroToOne\n    if _targetToken == token1:\n        priceToOther = EIGHTEEN_DECIMALS * EIGHTEEN_DECIMALS // priceZeroToOne\n\n    return altPrice * priceToOther // EIGHTEEN_DECIMALS\n\n\n# internal utils\n\n\n@view\n@internal\ndef _quote(_amountA: uint256, _reserveA: uint256, _reserveB: uint256) -> uint256:\n    return (_amountA * _reserveB) // _reserveA\n\n\n@view\n@internal\ndef _getReserves(_pool: address, _isTokenAZeroIndex: bool) -> (uint256, uint256):\n    reserve0: uint112 = 0\n    reserve1: uint112 = 0\n    na: uint32 = 0\n    reserve0, reserve1, na = staticcall IUniswapV2Pair(_pool).getReserves()\n\n    # determine which token is which\n    reserveA: uint256 = convert(reserve0, uint256)\n    reserveB: uint256 = convert(reserve1, uint256)\n    if not _isTokenAZeroIndex:\n        reserveA = convert(reserve1, uint256)\n        reserveB = convert(reserve0, uint256)\n\n    return reserveA, reserveB\n\n\n@view\n@internal\ndef _getAmountOut(\n    _pool: address,\n    _zeroForOne: bool,\n    _amountIn: uint256,\n) -> uint256:\n    if _amountIn == 0:\n        return 0\n\n    # get reserves\n    reserveIn: uint256 = 0\n    reserveOut: uint256 = 0\n    reserveIn, reserveOut = self._getReserves(_pool, _zeroForOne)\n    if reserveIn == 0 or reserveOut == 0:\n        return 0\n\n    # calculate amount out\n    amountInWithFee: uint256 = _amountIn * 997 # 1000 - 3 (0.3% fee)\n    numerator: uint256 = amountInWithFee * reserveOut\n    denominator: uint256 = (reserveIn * 1000) + amountInWithFee\n    return numerator // denominator\n\n\n@view\n@internal\ndef _getAmountIn(_pool: address, _zeroForOne: bool, _amountOut: uint256) -> uint256:\n    if _amountOut == 0 or _amountOut == max_value(uint256):\n        return max_value(uint256)\n\n    reserveIn: uint256 = 0\n    reserveOut: uint256 = 0\n    reserveIn, reserveOut = self._getReserves(_pool, _zeroForOne)\n    if reserveIn == 0 or reserveOut == 0:\n        return max_value(uint256)\n\n    if _amountOut > reserveOut:\n        return max_value(uint256)\n\n    numerator: uint256 = reserveIn * _amountOut * 1000\n    denominator: uint256 = (reserveOut - _amountOut) * 997\n    return (numerator // denominator) + 1\n\n\n#########\n# Other #\n#########\n\n\n@external\ndef depositForYield(\n    _asset: address,\n    _amount: uint256,\n    _vaultAddr: address,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, address, uint256, uint256):\n    return 0, empty(address), 0, 0\n\n\n@external\ndef withdrawFromYield(\n    _vaultToken: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, address, uint256, uint256):\n    return 0, empty(address), 0, 0\n\n\n@external\ndef mintOrRedeemAsset(\n    _tokenIn: address,\n    _tokenOut: address,\n    _tokenInAmount: uint256,\n    _minAmountOut: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, bool, uint256):\n    return 0, 0, False, 0\n\n\n@external\ndef confirmMintOrRedeemAsset(\n    _tokenIn: address,\n    _tokenOut: address,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef addCollateral(\n    _asset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef removeCollateral(\n    _asset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef borrow(\n    _borrowAsset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef repayDebt(\n    _paymentAsset: address,\n    _paymentAmount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef claimRewards(\n    _user: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _extraData: bytes32,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n@external\ndef addLiquidityConcentrated(\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _tickLower: int24,\n    _tickUpper: int24,\n    _amountA: uint256,\n    _amountB: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, uint256, uint256):\n    return 0, 0, 0, 0, 0\n\n\n@external\ndef removeLiquidityConcentrated(\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _liqToRemove: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, bool, uint256):\n    return 0, 0, 0, False, 0\n\n\n\n@view\n@external\ndef getAccessForLego(_user: address, _action: ws.ActionType) -> (address, String[64], uint256):\n    return empty(address), empty(String[64]), 0\n",
            "sha256sum": "cad677f0a046048df9b22130c6d14a7d1408fca3f5ac2c14248a25c7f2985c13"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/legos/dexes/UniswapV2.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.3+commit.bff19ea2",
        "integrity": "ea0777fb654bd0620d33b479743e50eaf87dbdbade19d773c1605f639fe3dab1"
      },
      "args": "00000000000000000000000044cf3c4f000dfd76a35d03298049d37be688d6f90000000000000000000000008909dc15e40173ff4699343b6eb8132c65e18ec60000000000000000000000004752ba5dbc23f44d87826276bf6fd6b1c372ad2400000000000000000000000088a43bbdf9d098eec7bceda4e2494615dfd9bb9c",
      "file": "contracts/legos/dexes/UniswapV2.vy"
    },
    "UniswapV3": {
      "address": "0xd6751EA9F70Acf948E1C2c2352256469790EF97d",
      "abi": [
        {
          "name": "UniswapV3Swap",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenIn",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenOut",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amountIn",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "amountOut",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "numTokens",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UniswapV3LiquidityAdded",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenA",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenB",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amountA",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "amountB",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "liquidityAdded",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "nftTokenId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UniswapV3LiquidityRemoved",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": false
            },
            {
              "name": "pool",
              "type": "address",
              "indexed": true
            },
            {
              "name": "nftTokenId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "tokenA",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenB",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amountA",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "amountB",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "liquidityRemoved",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UniswapV3NftRecovered",
          "inputs": [
            {
              "name": "collection",
              "type": "address",
              "indexed": true
            },
            {
              "name": "nftTokenId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LegoPauseModified",
          "inputs": [
            {
              "name": "isPaused",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LegoFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "balance",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddys",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "undyToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "hatchery",
                  "type": "address"
                },
                {
                  "name": "lootDistributor",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                },
                {
                  "name": "walletBackpack",
                  "type": "address"
                },
                {
                  "name": "billing",
                  "type": "address"
                },
                {
                  "name": "vaultRegistry",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUndyHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pause",
          "inputs": [
            {
              "name": "_shouldPause",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFundsMany",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_assets",
              "type": "address[]"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "legoId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isPaused",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasCapability",
          "inputs": [
            {
              "name": "_action",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "onERC721Received",
          "inputs": [
            {
              "name": "_operator",
              "type": "address"
            },
            {
              "name": "_owner",
              "type": "address"
            },
            {
              "name": "_tokenId",
              "type": "uint256"
            },
            {
              "name": "_data",
              "type": "bytes"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bytes4"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRegistries",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isYieldLego",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isDexLego",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_tokenPath",
              "type": "address[]"
            },
            {
              "name": "_poolPath",
              "type": "address[]"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_tokenPath",
              "type": "address[]"
            },
            {
              "name": "_poolPath",
              "type": "address[]"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "uniswapV3SwapCallback",
          "inputs": [
            {
              "name": "_amount0Delta",
              "type": "int256"
            },
            {
              "name": "_amount1Delta",
              "type": "int256"
            },
            {
              "name": "_data",
              "type": "bytes"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLpToken",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPoolForLpToken",
          "inputs": [
            {
              "name": "_lpToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getCoreRouterPool",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getDeepestLiqPool",
          "inputs": [
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "fee",
                  "type": "uint256"
                },
                {
                  "name": "liquidity",
                  "type": "uint256"
                },
                {
                  "name": "numCoins",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getBestSwapAmountOut",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountIn",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getSwapAmountOut",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountIn",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getBestSwapAmountIn",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountOut",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getSwapAmountIn",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountOut",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddLiqAmountsIn",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_availAmountA",
              "type": "uint256"
            },
            {
              "name": "_availAmountB",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRemoveLiqAmountsOut",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPrice",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_decimals",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPriceUnsafe",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_targetToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPriceUnsafe",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_targetToken",
              "type": "address"
            },
            {
              "name": "_appraiser",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverNft",
          "inputs": [
            {
              "name": "_collection",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositForYield",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositForYield",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawFromYield",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawFromYield",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_tokenInAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_tokenInAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmMintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmMintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_borrowAsset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_borrowAsset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_paymentAsset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_paymentAsset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAccessForLego",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_action",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "string"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "UNIV3_FACTORY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "UNIV3_NFT_MANAGER",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "UNIV3_QUOTER",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "coreRouterPool",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_undyHq",
              "type": "address"
            },
            {
              "name": "_uniswapV3Factory",
              "type": "address"
            },
            {
              "name": "_uniNftPositionManager",
              "type": "address"
            },
            {
              "name": "_uniV3Quoter",
              "type": "address"
            },
            {
              "name": "_coreRouterPool",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "interfaces/WalletStructs.vyi": {
            "content": "# @version 0.4.3\n\nflag ActionType:\n    TRANSFER\n    EARN_DEPOSIT\n    EARN_WITHDRAW\n    EARN_REBALANCE\n    SWAP\n    MINT_REDEEM\n    CONFIRM_MINT_REDEEM\n    ADD_COLLATERAL\n    REMOVE_COLLATERAL\n    BORROW\n    REPAY_DEBT\n    REWARDS\n    ETH_TO_WETH\n    WETH_TO_ETH\n    ADD_LIQ\n    REMOVE_LIQ\n    ADD_LIQ_CONC\n    REMOVE_LIQ_CONC\n    PAY_CHEQUE\n\nstruct WalletAssetData:\n    assetBalance: uint256\n    usdValue: uint256\n    isYieldAsset: bool\n    lastPricePerShare: uint256\n\nstruct ActionData:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    billing: address\n    wallet: address\n    walletConfig: address\n    walletOwner: address\n    inEjectMode: bool\n    isFrozen: bool\n    lastTotalUsdValue: uint256\n    signer: address\n    isManager: bool\n    legoId: uint256\n    legoAddr: address\n    eth: address\n    weth: address\n\nstruct MiniAddys:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    appraiser: address",
            "sha256sum": "9a4b4f59b3a62043e51b425a665064aae419a3c0bd0514b6b29a9441ae364bb9"
          },
          "interfaces/LegoPartner.vyi": {
            "content": "# @version 0.4.3\n\nfrom interfaces import WalletStructs as ws\n\nMAX_TOKEN_PATH: constant(uint256) = 5\nMAX_RECOVER_ASSETS: constant(uint256) = 20\n\n@external\ndef addLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _tickLower: int24, _tickUpper: int24, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef addLiquidity(_pool: address, _tokenA: address, _tokenB: address, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _minLpAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (address, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef removeLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _liqToRemove: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef removeLiquidity(_pool: address, _tokenA: address, _tokenB: address, _lpToken: address, _lpAmount: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef mintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _tokenInAmount: uint256, _minAmountOut: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef swapTokens(_amountIn: uint256, _minAmountOut: uint256, _tokenPath: DynArray[address, MAX_TOKEN_PATH], _poolPath: DynArray[address, MAX_TOKEN_PATH - 1], _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256):\n    ...\n\n@external\ndef depositForYield(_asset: address, _amount: uint256, _vaultAddr: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef withdrawFromYield(_vaultToken: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef confirmMintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef borrow(_borrowAsset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef repayDebt(_paymentAsset: address, _paymentAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef claimRewards(_user: address, _rewardToken: address, _rewardAmount: uint256, _extraData: bytes32, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef removeCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef addCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@view\n@external\ndef getAccessForLego(_user: address, _action: ws.ActionType) -> (address, String[64], uint256):\n    ...\n\n@view\n@external\ndef hasCapability(_action: ws.ActionType) -> bool:\n    ...\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    ...\n\n@view\n@external\ndef isYieldLego() -> bool:\n    ...\n\n@view\n@external\ndef isDexLego() -> bool:\n    ...\n\n\n# common\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "81db71fe4440a3b4b563134c9b5caf1d5705772a5f291fe874c9b5fb3cfb1623"
          },
          "contracts/modules/Addys.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\ninterface UndyHq:\n    def isValidAddr(_addr: address) -> bool: view\n    def getAddr(_regId: uint256) -> address: view\n    def undyToken() -> address: view\n\ninterface Switchboard:\n    def isSwitchboardAddr(_addr: address) -> bool: view\n\ninterface LegoBook:\n    def isLegoAddr(_addr: address) -> bool: view\n\nstruct Addys:\n    hq: address\n    undyToken: address\n    ledger: address\n    missionControl: address\n    legoBook: address\n    switchboard: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    walletBackpack: address\n    billing: address\n    vaultRegistry: address\n\n# hq\nUNDY_HQ_FOR_ADDYS: immutable(address)\n\n# core addys\nLEDGER_ID: constant(uint256) = 1\nMISSION_CONTROL_ID: constant(uint256) = 2\nLEGO_BOOK_ID: constant(uint256) = 3\nSWITCHBOARD_ID: constant(uint256) = 4\nHATCHERY_ID: constant(uint256) = 5\nLOOT_DISTRIBUTOR_ID: constant(uint256) = 6\nAPPRAISER_ID: constant(uint256) = 7\nWALLET_BACKPACK_ID: constant(uint256) = 8\nBILLING_ID: constant(uint256) = 9\nVAULT_REGISTRY_ID: constant(uint256) = 10\n\n\n@deploy\ndef __init__(_undyHq: address):\n    assert _undyHq != empty(address) # dev: invalid undy hq\n    UNDY_HQ_FOR_ADDYS = _undyHq\n\n\n########\n# Core #\n########\n\n\n@view\n@external\ndef getAddys() -> Addys:\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _getAddys(_addys: Addys = empty(Addys)) -> Addys:\n    if _addys.hq != empty(address):\n        return _addys\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _generateAddys() -> Addys:\n    hq: address = UNDY_HQ_FOR_ADDYS\n    return Addys(\n        hq = hq,\n        undyToken = staticcall UndyHq(hq).undyToken(),\n        ledger = staticcall UndyHq(hq).getAddr(LEDGER_ID),\n        missionControl = staticcall UndyHq(hq).getAddr(MISSION_CONTROL_ID),\n        legoBook = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID),\n        switchboard = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID),\n        hatchery = staticcall UndyHq(hq).getAddr(HATCHERY_ID),\n        lootDistributor = staticcall UndyHq(hq).getAddr(LOOT_DISTRIBUTOR_ID),\n        appraiser = staticcall UndyHq(hq).getAddr(APPRAISER_ID),\n        walletBackpack = staticcall UndyHq(hq).getAddr(WALLET_BACKPACK_ID),\n        billing = staticcall UndyHq(hq).getAddr(BILLING_ID),\n        vaultRegistry = staticcall UndyHq(hq).getAddr(VAULT_REGISTRY_ID),\n    )\n\n\n##########\n# Tokens #\n##########\n\n\n@view\n@internal\ndef _getUndyToken() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).undyToken()\n\n\n###########\n# Helpers #\n###########\n\n\n# undy hq\n\n\n@view\n@external\ndef getUndyHq() -> address:\n    return self._getUndyHq()\n\n\n@view\n@internal\ndef _getUndyHq() -> address:\n    return UNDY_HQ_FOR_ADDYS\n\n\n# utils\n\n\n@view\n@internal\ndef _isValidUndyAddr(_addr: address, _hq: address = empty(address)) -> bool:\n    hq: address = _hq\n    if _hq == empty(address):\n        hq = UNDY_HQ_FOR_ADDYS\n    \n    # core departments\n    if staticcall UndyHq(hq).isValidAddr(_addr):\n        return True\n\n    # lego book\n    legoBook: address = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID)\n    if legoBook != empty(address) and staticcall LegoBook(legoBook).isLegoAddr(_addr):\n        return True\n\n    # switchboard config\n    switchboard: address = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID)\n    if switchboard != empty(address) and staticcall Switchboard(switchboard).isSwitchboardAddr(_addr):\n        return True\n\n    return False\n\n\n@view\n@internal\ndef _isSwitchboardAddr(_addr: address) -> bool:\n    switchboard: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n    if switchboard == empty(address):\n        return False\n    return staticcall Switchboard(switchboard).isSwitchboardAddr(_addr)\n\n\n@view\n@internal\ndef _isLegoBookAddr(_addr: address) -> bool:\n    legoBook: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n    if legoBook == empty(address):\n        return False\n    return staticcall LegoBook(legoBook).isLegoAddr(_addr)\n\n\n###############\n# Departments #\n###############\n\n\n# ledger\n\n\n@view\n@internal\ndef _getLedgerId() -> uint256:\n    return LEDGER_ID\n\n\n@view\n@internal\ndef _getLedgerAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEDGER_ID)\n\n\n# mission control\n\n\n@view\n@internal\ndef _getMissionControlId() -> uint256:\n    return MISSION_CONTROL_ID\n\n\n@view\n@internal\ndef _getMissionControlAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(MISSION_CONTROL_ID)\n\n\n# lego book\n\n\n@view\n@internal\ndef _getLegoBookId() -> uint256:\n    return LEGO_BOOK_ID\n\n\n@view\n@internal\ndef _getLegoBookAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n\n\n# switchboard\n\n\n@view\n@internal\ndef _getSwitchboardId() -> uint256:\n    return SWITCHBOARD_ID\n\n\n@view\n@internal\ndef _getSwitchboardAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n\n\n# hatchery\n\n\n@view\n@internal\ndef _getHatcheryId() -> uint256:\n    return HATCHERY_ID\n\n\n@view\n@internal\ndef _getHatcheryAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(HATCHERY_ID)\n\n\n# loot distributor\n\n\n@view\n@internal\ndef _getLootDistributorId() -> uint256:\n    return LOOT_DISTRIBUTOR_ID\n\n\n@view\n@internal\ndef _getLootDistributorAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LOOT_DISTRIBUTOR_ID)\n\n\n# appraiser\n\n\n@view\n@internal\ndef _getAppraiserId() -> uint256:\n    return APPRAISER_ID\n\n\n@view\n@internal\ndef _getAppraiserAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(APPRAISER_ID)\n\n\n# wallet backpack\n\n\n@view\n@internal\ndef _getWalletBackpackId() -> uint256:\n    return WALLET_BACKPACK_ID\n\n\n@view\n@internal\ndef _getWalletBackpackAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(WALLET_BACKPACK_ID)\n\n\n# billing\n\n\n@view\n@internal\ndef _getBillingId() -> uint256:\n    return BILLING_ID\n\n\n@view\n@internal\ndef _getBillingAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(BILLING_ID)\n\n\n# vault registry\n\n\n@view\n@internal\ndef _getVaultRegistryId() -> uint256:\n    return VAULT_REGISTRY_ID\n\n\n@view\n@internal\ndef _getVaultRegistryAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(VAULT_REGISTRY_ID)",
            "sha256sum": "4df6b72db9bb417d1af81660175be1450cfb7b3575f3d17a5b8a130bff87b781"
          },
          "contracts/modules/DexLegoData.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nuses: addys\n\nimport contracts.modules.Addys as addys\n\nfrom interfaces import WalletStructs as ws\nfrom ethereum.ercs import IERC20\n\nevent LegoPauseModified:\n    isPaused: bool\n\nevent LegoFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    balance: uint256\n\n# config\nlegoId: public(uint256)\nisPaused: public(bool)\n\nMAX_RECOVER_ASSETS: constant(uint256) = 20\n\n\n@deploy\ndef __init__(_shouldPause: bool):\n    self.isPaused = _shouldPause\n\n\n###########\n# General #\n###########\n\n\n# fill mini addys\n\n\n@view\n@internal\ndef _getMiniAddys(_miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> ws.MiniAddys:\n    if _miniAddys.ledger != empty(address):\n        return _miniAddys\n    return ws.MiniAddys(\n        ledger = addys._getLedgerAddr(),\n        missionControl = addys._getMissionControlAddr(),\n        legoBook = addys._getLegoBookAddr(),\n        appraiser = addys._getAppraiserAddr(),\n    )\n\n\n# activate\n\n\n@external\ndef pause(_shouldPause: bool):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert _shouldPause != self.isPaused # dev: no change\n    self.isPaused = _shouldPause\n    log LegoPauseModified(isPaused=_shouldPause)\n\n\n# recover funds\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    self._recoverFunds(_recipient, _asset)\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, MAX_RECOVER_ASSETS]):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    for a: address in _assets:\n        self._recoverFunds(_recipient, a)\n\n\n@internal\ndef _recoverFunds(_recipient: address, _asset: address):\n    assert empty(address) not in [_recipient, _asset] # dev: invalid recipient or asset\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    assert balance != 0 # dev: nothing to recover\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log LegoFundsRecovered(asset=_asset, recipient=_recipient, balance=balance)",
            "sha256sum": "75b15af2475ab409d4b5fd057509d14c20564ebd7fcb0850e3b61397d8e3af48"
          },
          "contracts/legos/dexes/UniswapV3.vy": {
            "content": "#     _____  _____  __  __    ____   _____  _____  _____ \n#    |  _  \\/   __\\/  \\/  \\  /  _/  /   __\\/   __\\/  _  \\\n#    |  |  ||   __|>-    -<  |  |---|   __||  |_ ||  |  |\n#    |_____/\\_____/\\__/\\__/  \\_____/\\_____/\\_____/\\_____/\n#                                                                       \n#     \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n#     \u2551  ** Uniswap V3 Lego **           \u2551\n#     \u2551  Integration with Uniswap V3.    \u2551\n#     \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n#\n#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nimplements: Lego\nimplements: IUniswapV3Callback\n\nexports: addys.__interface__\nexports: dld.__interface__\n\ninitializes: addys\ninitializes: dld[addys := addys]\n\nfrom interfaces import LegoPartner as Lego\nfrom interfaces import WalletStructs as ws\n\nimport contracts.modules.Addys as addys\nimport contracts.modules.DexLegoData as dld\n\nfrom ethereum.ercs import IERC20\nfrom ethereum.ercs import IERC20Detailed\nfrom ethereum.ercs import IERC721\n\n# `getSwapAmountOut()` and `getSwapAmountIn()` cannot be view functions, sadly\n# keeping here to uncomment to test all other functions\n# implements: DexLego\n# from interfaces import DexLego as DexLego\n\ninterface UniV3Pool:\n    def slot0() -> (uint160, int24, uint16, uint16, uint16, uint8, bool): view\n    def swap(_recipient: address, _zeroForOne: bool, _amountSpecified: int256, _sqrtPriceLimitX96: uint160, _data: Bytes[256]) -> (int256, int256): nonpayable\n    def liquidity() -> uint128: view\n    def tickSpacing() -> int24: view\n    def token0() -> address: view\n    def token1() -> address: view\n    def fee() -> uint24: view\n\ninterface UniV3NftPositionManager:\n    def increaseLiquidity(_params: IncreaseLiquidityParams) -> (uint128, uint256, uint256): nonpayable\n    def decreaseLiquidity(_params: DecreaseLiquidityParams) -> (uint256, uint256): nonpayable\n    def mint(_params: MintParams) -> (uint256, uint128, uint256, uint256): nonpayable\n    def collect(_params: CollectParams) -> (uint256, uint256): nonpayable\n    def positions(_tokenId: uint256) -> PositionData: view\n    def burn(_tokenId: uint256): nonpayable\n\ninterface UniV3Quoter:\n    def quoteExactOutputSingle(_params: QuoteExactOutputSingleParams) -> (uint256, uint160, uint32, uint256): nonpayable\n    def quoteExactInputSingle(_params: QuoteExactInputSingleParams) -> (uint256, uint160, uint32, uint256): nonpayable\n    def quoteExactInput(_path: Bytes[1024], _amountIn: uint256) -> uint256: nonpayable\n\ninterface Appraiser:\n    def getNormalAssetPrice(_asset: address, _missionControl: address = empty(address), _legoBook: address = empty(address), _ledger: address = empty(address)) -> uint256: view\n    def updatePriceAndGetUsdValue(_asset: address, _amount: uint256, _missionControl: address = empty(address), _legoBook: address = empty(address)) -> uint256: nonpayable\n\ninterface IUniswapV3Callback:\n    def uniswapV3SwapCallback(_amount0Delta: int256, _amount1Delta: int256, _data: Bytes[256]): nonpayable\n\ninterface UniV3Factory:\n    def getPool(_tokenA: address, _tokenB: address, _fee: uint24) -> address: view\n\nstruct QuoteExactInputSingleParams:\n    tokenIn: address\n    tokenOut: address\n    amountIn: uint256\n    fee: uint24\n    sqrtPriceLimitX96: uint160\n\nstruct QuoteExactOutputSingleParams:\n    tokenIn: address\n    tokenOut: address\n    amount: uint256\n    fee: uint24\n    sqrtPriceLimitX96: uint160\n\nstruct BestPool:\n    pool: address\n    fee: uint256\n    liquidity: uint256\n    numCoins: uint256\n\nstruct MintParams:\n    token0: address\n    token1: address\n    fee: uint24\n    tickLower: int24\n    tickUpper: int24\n    amount0Desired: uint256\n    amount1Desired: uint256\n    amount0Min: uint256\n    amount1Min: uint256\n    recipient: address\n    deadline: uint256\n\nstruct IncreaseLiquidityParams:\n    tokenId: uint256\n    amount0Desired: uint256\n    amount1Desired: uint256\n    amount0Min: uint256\n    amount1Min: uint256\n    deadline: uint256\n\nstruct DecreaseLiquidityParams:\n    tokenId: uint256\n    liquidity: uint128\n    amount0Min: uint256\n    amount1Min: uint256\n    deadline: uint256\n\nstruct CollectParams:\n    tokenId: uint256\n    recipient: address\n    amount0Max: uint128\n    amount1Max: uint128\n\nstruct PositionData:\n    nonce: uint96\n    operator: address\n    token0: address\n    token1: address\n    fee: uint24\n    tickLower: int24\n    tickUpper: int24\n    liquidity: uint128\n    feeGrowthInside0LastX128: uint256\n    feeGrowthInside1LastX128: uint256\n    tokensOwed0: uint128\n    tokensOwed1: uint128\n\nstruct PoolSwapData:\n    pool: address\n    tokenIn: address\n    amountIn: uint256\n\nevent UniswapV3Swap:\n    sender: indexed(address)\n    tokenIn: indexed(address)\n    tokenOut: indexed(address)\n    amountIn: uint256\n    amountOut: uint256\n    usdValue: uint256\n    numTokens: uint256\n    recipient: address\n\nevent UniswapV3LiquidityAdded:\n    sender: indexed(address)\n    tokenA: indexed(address)\n    tokenB: indexed(address)\n    amountA: uint256\n    amountB: uint256\n    liquidityAdded: uint256\n    nftTokenId: uint256\n    usdValue: uint256\n    recipient: address\n\nevent UniswapV3LiquidityRemoved:\n    sender: address\n    pool: indexed(address)\n    nftTokenId: uint256\n    tokenA: indexed(address)\n    tokenB: indexed(address)\n    amountA: uint256\n    amountB: uint256\n    liquidityRemoved: uint256\n    usdValue: uint256\n    recipient: address\n\nevent UniswapV3NftRecovered:\n    collection: indexed(address)\n    nftTokenId: uint256\n    recipient: indexed(address)\n\n# transient storage\npoolSwapData: transient(PoolSwapData)\n\n# uniswap v3\nUNIV3_FACTORY: public(immutable(address))\nUNIV3_NFT_MANAGER: public(immutable(address))\nUNIV3_QUOTER: public(immutable(address))\ncoreRouterPool: public(address)\n\nFEE_TIERS: constant(uint24[4]) = [100, 500, 3000, 10000] # 0.01%, 0.05%, 0.3%, 1%\nMIN_SQRT_RATIO_PLUS_ONE: constant(uint160) = 4295128740\nMAX_SQRT_RATIO_MINUS_ONE: constant(uint160) = 1461446703485210103287273052203988822378723970341\nTICK_LOWER: constant(int24) = -887272\nTICK_UPPER: constant(int24) = 887272\nERC721_RECEIVE_DATA: constant(Bytes[1024]) = b\"UE721\"\nEIGHTEEN_DECIMALS: constant(uint256) = 10 ** 18\nUNISWAP_Q96: constant(uint256) = 2 ** 96  # uniswap's fixed point scaling factor\nMAX_TOKEN_PATH: constant(uint256) = 5\n\n\n@deploy\ndef __init__(\n    _undyHq: address,\n    _uniswapV3Factory: address,\n    _uniNftPositionManager: address,\n    _uniV3Quoter: address,\n    _coreRouterPool: address,\n):\n    addys.__init__(_undyHq)\n    dld.__init__(False)\n\n    assert empty(address) not in [_uniswapV3Factory, _uniNftPositionManager, _uniV3Quoter, _coreRouterPool] # dev: invalid addrs\n    UNIV3_FACTORY = _uniswapV3Factory\n    UNIV3_NFT_MANAGER = _uniNftPositionManager\n    UNIV3_QUOTER = _uniV3Quoter\n    self.coreRouterPool = _coreRouterPool\n\n\n@view\n@external\ndef hasCapability(_action: ws.ActionType) -> bool:\n    return _action in (\n        ws.ActionType.SWAP |\n        ws.ActionType.ADD_LIQ_CONC | \n        ws.ActionType.REMOVE_LIQ_CONC\n    )\n\n\n@view\n@external\ndef onERC721Received(_operator: address, _owner: address, _tokenId: uint256, _data: Bytes[1024]) -> bytes4:\n    # must implement method for safe NFT transfers\n    assert _data == ERC721_RECEIVE_DATA # dev: did not receive from within Underscore wallet\n    return method_id(\"onERC721Received(address,address,uint256,bytes)\", output_type=bytes4)\n\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    return [UNIV3_FACTORY, UNIV3_NFT_MANAGER, UNIV3_QUOTER]\n\n\n@view\n@external\ndef isYieldLego() -> bool:\n    return False\n\n\n@view\n@external\ndef isDexLego() -> bool:\n    return True\n\n\n#########\n# Swaps #\n#########\n\n\n@external\ndef swapTokens(\n    _amountIn: uint256,\n    _minAmountOut: uint256,\n    _tokenPath: DynArray[address, MAX_TOKEN_PATH],\n    _poolPath: DynArray[address, MAX_TOKEN_PATH - 1],\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256):\n    assert not dld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = dld._getMiniAddys(_miniAddys)\n\n    # validate inputs\n    numTokens: uint256 = len(_tokenPath)\n    numPools: uint256 = len(_poolPath)\n    assert numTokens >= 2 # dev: invalid path\n    assert numPools == numTokens - 1 # dev: invalid path\n\n    # get first token and last token\n    tokenIn: address = _tokenPath[0]\n    tokenOut: address = _tokenPath[numTokens - 1]\n\n    # pre balances\n    preLegoBalance: uint256 = staticcall IERC20(tokenIn).balanceOf(self)\n\n    # transfer deposit asset to this contract\n    amountIn: uint256 = min(_amountIn, staticcall IERC20(tokenIn).balanceOf(msg.sender))\n    assert amountIn != 0 # dev: nothing to transfer\n    assert extcall IERC20(tokenIn).transferFrom(msg.sender, self, amountIn, default_return_value=True) # dev: transfer failed\n\n    # adjust min amount out\n    minAmountOut: uint256 = _minAmountOut\n    if amountIn < _amountIn and _amountIn != max_value(uint256):\n        minAmountOut = _minAmountOut * amountIn // _amountIn\n\n    # iterate through swap routes\n    tempAmountIn: uint256 = amountIn\n    uniswapV3Factory: address = UNIV3_FACTORY\n    for i: uint256 in range(numTokens - 1, bound=MAX_TOKEN_PATH):\n        tempTokenIn: address = _tokenPath[i]\n        tempTokenOut: address = _tokenPath[i + 1]\n        tempPool: address = _poolPath[i]\n\n        # transfer to self (or to recipient if last swap)\n        recipient: address = _recipient\n        if i < numTokens - 2:\n            recipient = self\n\n        # swap\n        tempAmountIn = self._swapTokensInPool(tempPool, tempTokenIn, tempTokenOut, tempAmountIn, recipient, uniswapV3Factory)\n\n    # final amount\n    amountOut: uint256 = tempAmountIn\n    assert amountOut >= minAmountOut # dev: min amount out not met\n\n    # refund if full swap didn't get through\n    currentLegoBalance: uint256 = staticcall IERC20(tokenIn).balanceOf(self)\n    refundAssetAmount: uint256 = 0\n    if currentLegoBalance > preLegoBalance:\n        refundAssetAmount = currentLegoBalance - preLegoBalance\n        assert extcall IERC20(tokenIn).transfer(msg.sender, refundAssetAmount, default_return_value=True) # dev: transfer failed\n        amountIn -= refundAssetAmount\n\n    # get usd values\n    usdValue: uint256 = extcall Appraiser(miniAddys.appraiser).updatePriceAndGetUsdValue(tokenIn, amountIn, miniAddys.missionControl, miniAddys.legoBook)\n    if usdValue == 0:\n        usdValue = extcall Appraiser(miniAddys.appraiser).updatePriceAndGetUsdValue(tokenOut, amountOut, miniAddys.missionControl, miniAddys.legoBook)\n\n    log UniswapV3Swap(\n        sender = msg.sender,\n        tokenIn = tokenIn,\n        tokenOut = tokenOut,\n        amountIn = amountIn,\n        amountOut = amountOut,\n        usdValue = usdValue,\n        numTokens = numTokens,\n        recipient = _recipient,\n    )\n    return amountIn, amountOut, usdValue\n\n\n# swap in pool\n\n\n@internal\ndef _swapTokensInPool(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n    _recipient: address,\n    _uniswapV3Factory: address,\n) -> uint256:\n    tokens: address[2] = [staticcall UniV3Pool(_pool).token0(), staticcall UniV3Pool(_pool).token1()]\n    assert _tokenIn in tokens # dev: invalid tokenIn\n    assert _tokenOut in tokens # dev: invalid tokenOut\n    assert _tokenIn != _tokenOut # dev: invalid tokens\n\n    # verify actual uniswap v3 pool\n    assert staticcall UniV3Factory(_uniswapV3Factory).getPool(_tokenIn, _tokenOut, staticcall UniV3Pool(_pool).fee()) == _pool # dev: invalid pool\n\n    # save in transient storage (for use in callback)\n    self.poolSwapData = PoolSwapData(\n        pool=_pool,\n        tokenIn=_tokenIn,\n        amountIn=_amountIn,\n    )\n\n    zeroForOne: bool = _tokenIn == tokens[0]\n    sqrtPriceLimitX96: uint160 = MAX_SQRT_RATIO_MINUS_ONE\n    if zeroForOne:\n        sqrtPriceLimitX96 = MIN_SQRT_RATIO_PLUS_ONE\n\n    # perform swap\n    amount0: int256 = 0\n    amount1: int256 = 0\n    amount0, amount1 = extcall UniV3Pool(_pool).swap(_recipient, zeroForOne, convert(_amountIn, int256), sqrtPriceLimitX96, b\"\")\n\n    toAmount: uint256 = 0\n    if zeroForOne:\n        toAmount = convert(-amount1, uint256)\n    else:\n        toAmount = convert(-amount0, uint256)\n\n    assert toAmount != 0 # dev: no tokens swapped\n    return toAmount\n\n\n# callback\n\n\n@external\ndef uniswapV3SwapCallback(_amount0Delta: int256, _amount1Delta: int256, _data: Bytes[256]):\n    poolSwapData: PoolSwapData = self.poolSwapData\n    assert msg.sender == poolSwapData.pool # dev: no perms\n\n    # transfer tokens to pool\n    assert extcall IERC20(poolSwapData.tokenIn).transfer(poolSwapData.pool, poolSwapData.amountIn, default_return_value=True) # dev: transfer failed\n    self.poolSwapData = empty(PoolSwapData)\n\n\n#################\n# Add Liquidity #\n#################\n\n\n@external\ndef addLiquidityConcentrated(\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _tickLower: int24,\n    _tickUpper: int24,\n    _amountA: uint256,\n    _amountB: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, uint256, uint256):\n    assert not dld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = dld._getMiniAddys(_miniAddys)\n\n    # validate tokens\n    tokens: address[2] = [staticcall UniV3Pool(_pool).token0(), staticcall UniV3Pool(_pool).token1()]\n    assert _tokenA in tokens # dev: invalid tokenA\n    assert _tokenB in tokens # dev: invalid tokenB\n    assert _tokenA != _tokenB # dev: invalid tokens\n\n    # pre balances\n    preLegoBalanceA: uint256 = staticcall IERC20(_tokenA).balanceOf(self)\n    preLegoBalanceB: uint256 = staticcall IERC20(_tokenB).balanceOf(self)\n\n    # token a\n    liqAmountA: uint256 = min(_amountA, staticcall IERC20(_tokenA).balanceOf(msg.sender))\n    assert liqAmountA != 0 # dev: nothing to transfer\n    assert extcall IERC20(_tokenA).transferFrom(msg.sender, self, liqAmountA, default_return_value=True) # dev: transfer failed\n\n    # token b\n    liqAmountB: uint256 = min(_amountB, staticcall IERC20(_tokenB).balanceOf(msg.sender))\n    assert liqAmountB != 0 # dev: nothing to transfer\n    assert extcall IERC20(_tokenB).transferFrom(msg.sender, self, liqAmountB, default_return_value=True) # dev: transfer failed\n\n    # approvals\n    nftPositionManager: address = UNIV3_NFT_MANAGER\n    assert extcall IERC20(_tokenA).approve(nftPositionManager, liqAmountA, default_return_value=True) # dev: approval failed\n    assert extcall IERC20(_tokenB).approve(nftPositionManager, liqAmountB, default_return_value=True) # dev: approval failed\n\n    # organized the index of tokens\n    token0: address = _tokenA\n    token1: address = _tokenB\n    amount0: uint256 = liqAmountA\n    amount1: uint256 = liqAmountB\n    minAmount0: uint256 = _minAmountA\n    minAmount1: uint256 = _minAmountB\n    if tokens[0] != _tokenA:\n        token0 = _tokenB\n        token1 = _tokenA\n        amount0 = liqAmountB\n        amount1 = liqAmountA\n        minAmount0 = _minAmountB\n        minAmount1 = _minAmountA\n\n    # add liquidity\n    nftTokenId: uint256 = _nftTokenId\n    liquidityAdded: uint256 = 0\n    liquidityAddedInt128: uint128 = 0\n    if _nftTokenId == 0:\n        nftTokenId, liquidityAddedInt128, amount0, amount1 = self._mintNewPosition(nftPositionManager, _pool, token0, token1, _tickLower, _tickUpper, amount0, amount1, minAmount0, minAmount1, _recipient)\n    else:\n        liquidityAddedInt128, amount0, amount1 = self._increaseExistingPosition(nftPositionManager, _nftTokenId, amount0, amount1, minAmount0, minAmount1, _recipient)\n\n    liquidityAdded = convert(liquidityAddedInt128, uint256)\n    assert liquidityAdded != 0 # dev: no liquidity added\n\n    # reset approvals\n    assert extcall IERC20(_tokenA).approve(nftPositionManager, 0, default_return_value=True) # dev: approval failed\n    assert extcall IERC20(_tokenB).approve(nftPositionManager, 0, default_return_value=True) # dev: approval failed\n\n    # refund if full liquidity was not added\n    currentLegoBalanceA: uint256 = staticcall IERC20(_tokenA).balanceOf(self)\n    refundAssetAmountA: uint256 = 0\n    if currentLegoBalanceA > preLegoBalanceA:\n        refundAssetAmountA = currentLegoBalanceA - preLegoBalanceA\n        assert extcall IERC20(_tokenA).transfer(msg.sender, refundAssetAmountA, default_return_value=True) # dev: transfer failed\n\n    currentLegoBalanceB: uint256 = staticcall IERC20(_tokenB).balanceOf(self)\n    refundAssetAmountB: uint256 = 0\n    if currentLegoBalanceB > preLegoBalanceB:\n        refundAssetAmountB = currentLegoBalanceB - preLegoBalanceB\n        assert extcall IERC20(_tokenB).transfer(msg.sender, refundAssetAmountB, default_return_value=True) # dev: transfer failed\n\n    # a/b amounts\n    liqAmountA = amount0\n    liqAmountB = amount1\n    if tokens[0] != _tokenA:\n        liqAmountA = amount1\n        liqAmountB = amount0\n\n    usdValue: uint256 = self._getUsdValue(_tokenA, liqAmountA, _tokenB, liqAmountB, miniAddys)\n    log UniswapV3LiquidityAdded(\n        sender = msg.sender,\n        tokenA = _tokenA,\n        tokenB = _tokenB,\n        amountA = liqAmountA,\n        amountB = liqAmountB,\n        liquidityAdded = liquidityAdded,\n        nftTokenId = nftTokenId,\n        usdValue = usdValue,\n        recipient = _recipient,\n    )\n    return liquidityAdded, liqAmountA, liqAmountB, nftTokenId, usdValue\n\n\n# mint new position\n\n\n@internal\ndef _mintNewPosition(\n    _nftPositionManager: address,\n    _pool: address,\n    _token0: address,\n    _token1: address,\n    _tickLower: int24,\n    _tickUpper: int24,\n    _amount0: uint256,\n    _amount1: uint256,\n    _minAmount0: uint256,\n    _minAmount1: uint256,\n    _recipient: address,\n) -> (uint256, uint128, uint256, uint256):\n    tickLower: int24 = 0\n    tickUpper: int24 = 0\n    tickLower, tickUpper = self._getTicks(_pool, _tickLower, _tickUpper)\n\n    # mint new position\n    params: MintParams = MintParams(\n        token0=_token0,\n        token1=_token1,\n        fee=staticcall UniV3Pool(_pool).fee(),\n        tickLower=tickLower,\n        tickUpper=tickUpper,\n        amount0Desired=_amount0,\n        amount1Desired=_amount1,\n        amount0Min=_minAmount0,\n        amount1Min=_minAmount1,\n        recipient=_recipient,\n        deadline=block.timestamp,\n    )\n    return extcall UniV3NftPositionManager(_nftPositionManager).mint(params)\n\n\n# get ticks\n\n\n@view\n@internal\ndef _getTicks(_pool: address, _tickLower: int24, _tickUpper: int24) -> (int24, int24):\n    tickSpacing: int24 = 0\n    if _tickLower == min_value(int24) or _tickUpper == max_value(int24):\n        tickSpacing = staticcall UniV3Pool(_pool).tickSpacing()\n\n    tickLower: int24 = _tickLower\n    if _tickLower == min_value(int24):\n        tickLower = (TICK_LOWER // tickSpacing) * tickSpacing\n\n    tickUpper: int24 = _tickUpper\n    if _tickUpper == max_value(int24):\n        tickUpper = (TICK_UPPER // tickSpacing) * tickSpacing\n\n    return tickLower, tickUpper\n\n\n# increase existing position\n\n\n@internal\ndef _increaseExistingPosition(\n    _nftPositionManager: address,\n    _tokenId: uint256,\n    _amount0: uint256,\n    _amount1: uint256,\n    _minAmount0: uint256,\n    _minAmount1: uint256,\n    _recipient: address,\n) -> (uint128, uint256, uint256):\n    assert staticcall IERC721(_nftPositionManager).ownerOf(_tokenId) == self # dev: nft not here\n\n    liquidityAddedInt128: uint128 = 0\n    amount0: uint256 = 0\n    amount1: uint256 = 0\n    params: IncreaseLiquidityParams = IncreaseLiquidityParams(\n        tokenId=_tokenId,\n        amount0Desired=_amount0,\n        amount1Desired=_amount1,\n        amount0Min=_minAmount0,\n        amount1Min=_minAmount1,\n        deadline=block.timestamp,\n    )\n    liquidityAddedInt128, amount0, amount1 = extcall UniV3NftPositionManager(_nftPositionManager).increaseLiquidity(params)\n\n    # collect fees (if applicable) -- must be done before transferring nft\n    positionData: PositionData = staticcall UniV3NftPositionManager(_nftPositionManager).positions(_tokenId)\n    self._collectFees(_nftPositionManager, _tokenId, _recipient, positionData)\n\n    # transfer nft to recipient\n    extcall IERC721(_nftPositionManager).safeTransferFrom(self, _recipient, _tokenId)\n\n    return liquidityAddedInt128, amount0, amount1\n\n\n# collect fees\n\n\n@internal\ndef _collectFees(_nftPositionManager: address, _tokenId: uint256, _recipient: address, _positionData: PositionData) -> (uint256, uint256):\n    if _positionData.tokensOwed0 == 0 and _positionData.tokensOwed1 == 0:\n        return 0, 0\n\n    params: CollectParams = CollectParams(\n        tokenId=_tokenId,\n        recipient=_recipient,\n        amount0Max=max_value(uint128),\n        amount1Max=max_value(uint128),\n    )\n    return extcall UniV3NftPositionManager(_nftPositionManager).collect(params)\n\n\n####################\n# Remove Liquidity #\n####################\n\n\n@external\ndef removeLiquidityConcentrated(\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _liqToRemove: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, bool, uint256):\n    assert not dld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = dld._getMiniAddys(_miniAddys)\n\n    # make sure nft is here\n    nftPositionManager: address = UNIV3_NFT_MANAGER\n    assert staticcall IERC721(nftPositionManager).ownerOf(_nftTokenId) == self # dev: nft not here\n\n    # get position data\n    positionData: PositionData = staticcall UniV3NftPositionManager(nftPositionManager).positions(_nftTokenId)\n    originalLiquidity: uint128 = positionData.liquidity\n\n    # validate tokens\n    tokens: address[2] = [positionData.token0, positionData.token1]\n    assert _tokenA in tokens # dev: invalid tokenA\n    assert _tokenB in tokens # dev: invalid tokenB\n    assert _tokenA != _tokenB # dev: invalid tokens\n\n    # organized the index of tokens\n    minAmount0: uint256 = _minAmountA\n    minAmount1: uint256 = _minAmountB\n    if _tokenA != tokens[0]:\n        minAmount0 = _minAmountB\n        minAmount1 = _minAmountA\n\n    # decrease liquidity\n    liqToRemove: uint256 = min(_liqToRemove, convert(positionData.liquidity, uint256))\n    assert liqToRemove != 0 # dev: no liquidity to remove\n\n    params: DecreaseLiquidityParams = DecreaseLiquidityParams(\n        tokenId=_nftTokenId,\n        liquidity=convert(liqToRemove, uint128),\n        amount0Min=minAmount0,\n        amount1Min=minAmount1,\n        deadline=block.timestamp,\n    )\n    amount0: uint256 = 0\n    amount1: uint256 = 0\n    amount0, amount1 = extcall UniV3NftPositionManager(nftPositionManager).decreaseLiquidity(params)\n    assert amount0 != 0 and amount1 != 0 # dev: no liquidity removed\n\n    # a/b amounts\n    amountA: uint256 = amount0\n    amountB: uint256 = amount1\n    if _tokenA != tokens[0]:\n        amountA = amount1\n        amountB = amount0\n\n    # get latest position data -- collect withdrawn tokens AND any fees (if applicable)\n    positionData = staticcall UniV3NftPositionManager(nftPositionManager).positions(_nftTokenId)\n    self._collectFees(nftPositionManager, _nftTokenId, _recipient, positionData)\n\n    # burn nft (if applicable)\n    isDepleted: bool = False\n    if positionData.liquidity == 0:\n        isDepleted = True\n        extcall UniV3NftPositionManager(nftPositionManager).burn(_nftTokenId)\n\n    # transfer nft to recipient\n    else:\n        extcall IERC721(nftPositionManager).safeTransferFrom(self, _recipient, _nftTokenId)\n\n    usdValue: uint256 = self._getUsdValue(_tokenA, amountA, _tokenB, amountB, miniAddys)\n    liquidityRemoved: uint256 = convert(originalLiquidity - positionData.liquidity, uint256)\n    log UniswapV3LiquidityRemoved(\n        sender = msg.sender,\n        pool = _pool,\n        nftTokenId = _nftTokenId,\n        tokenA = _tokenA,\n        tokenB = _tokenB,\n        amountA = amountA,\n        amountB = amountB,\n        liquidityRemoved = liquidityRemoved,\n        usdValue = usdValue,\n        recipient = _recipient,\n    )\n    return amountA, amountB, liquidityRemoved, isDepleted, usdValue\n\n\n# get usd value on liquidity actions\n\n\n@internal\ndef _getUsdValue(\n    _tokenA: address,\n    _amountA: uint256,\n    _tokenB: address,\n    _amountB: uint256,\n    _miniAddys: ws.MiniAddys,\n) -> uint256:\n\n    usdValueA: uint256 = 0\n    if _amountA != 0:\n        usdValueA = extcall Appraiser(_miniAddys.appraiser).updatePriceAndGetUsdValue(_tokenA, _amountA, _miniAddys.missionControl, _miniAddys.legoBook)\n\n    usdValueB: uint256 = 0\n    if _amountB != 0:\n        usdValueB = extcall Appraiser(_miniAddys.appraiser).updatePriceAndGetUsdValue(_tokenB, _amountB, _miniAddys.missionControl, _miniAddys.legoBook)\n\n    return usdValueA + usdValueB\n\n\n#############\n# Utilities #\n#############\n\n\n@view\n@external\ndef getLpToken(_pool: address) -> address:\n    # no lp tokens for uniswap v3\n    return empty(address)\n\n\n@view\n@external\ndef getPoolForLpToken(_lpToken: address) -> address:\n    # no lp tokens for uniswap v3\n    return empty(address)\n\n\n@view\n@external\ndef getCoreRouterPool() -> address:\n    return self.coreRouterPool\n\n\n@view\n@external\ndef getDeepestLiqPool(_tokenA: address, _tokenB: address) -> BestPool:\n    bestPoolAddr: address = empty(address)\n    bestFeeTier: uint24 = 0\n    bestPoolAddr, bestFeeTier = self._getDeepestLiqPool(_tokenA, _tokenB)\n\n    if bestPoolAddr == empty(address):\n        return empty(BestPool)\n\n    # get token balances\n    tokenABal: uint256 = staticcall IERC20(_tokenA).balanceOf(bestPoolAddr)\n    tokenBBal: uint256 = staticcall IERC20(_tokenB).balanceOf(bestPoolAddr)\n\n    return BestPool(\n        pool=bestPoolAddr,\n        fee=convert(bestFeeTier // 100, uint256), # normalize to have 100_00 denominator\n        liquidity=tokenABal + tokenBBal, # not exactly \"liquidity\" but this comparable to \"reserves\"\n        numCoins=2,\n    )\n\n\n# annoying that this cannot be view function, thanks uni v3\n@external\ndef getBestSwapAmountOut(_tokenIn: address, _tokenOut: address, _amountIn: uint256) -> (address, uint256):\n    bestPoolAddr: address = empty(address)\n    bestFeeTier: uint24 = 0\n    bestPoolAddr, bestFeeTier = self._getDeepestLiqPool(_tokenIn, _tokenOut)\n\n    if bestPoolAddr == empty(address):\n        return empty(address), 0\n\n    amountOut: uint256 = 0\n    na1: uint160 = 0\n    na2: uint32 = 0\n    na3: uint256 = 0\n    amountOut, na1, na2, na3 = extcall UniV3Quoter(UNIV3_QUOTER).quoteExactInputSingle(\n        QuoteExactInputSingleParams(\n            tokenIn=_tokenIn,\n            tokenOut=_tokenOut,\n            amountIn=_amountIn,\n            fee=bestFeeTier,\n            sqrtPriceLimitX96=0,\n        )\n    )\n    return bestPoolAddr, amountOut\n\n\n# annoying that this cannot be view function, thanks uni v3\n@external\ndef getSwapAmountOut(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n) -> uint256:\n    amountOut: uint256 = 0\n    na1: uint160 = 0\n    na2: uint32 = 0\n    na3: uint256 = 0\n    amountOut, na1, na2, na3 = extcall UniV3Quoter(UNIV3_QUOTER).quoteExactInputSingle(\n        QuoteExactInputSingleParams(\n            tokenIn=_tokenIn,\n            tokenOut=_tokenOut,\n            amountIn=_amountIn,\n            fee=staticcall UniV3Pool(_pool).fee(),\n            sqrtPriceLimitX96=0,\n        )\n    )\n    return amountOut\n\n\n# annoying that this cannot be view function, thanks uni v3\n@external\ndef getBestSwapAmountIn(_tokenIn: address, _tokenOut: address, _amountOut: uint256) -> (address, uint256):\n    if _amountOut == 0 or _amountOut == max_value(uint256):\n        return empty(address), max_value(uint256)\n\n    bestPoolAddr: address = empty(address)\n    bestFeeTier: uint24 = 0\n    bestPoolAddr, bestFeeTier = self._getDeepestLiqPool(_tokenIn, _tokenOut)\n    if bestPoolAddr == empty(address):\n        return empty(address), 0\n\n    amountIn: uint256 = 0\n    na1: uint160 = 0\n    na2: uint32 = 0\n    na3: uint256 = 0\n    amountIn, na1, na2, na3 = extcall UniV3Quoter(UNIV3_QUOTER).quoteExactOutputSingle(\n        QuoteExactOutputSingleParams(\n            tokenIn=_tokenIn,\n            tokenOut=_tokenOut,\n            amount=_amountOut,\n            fee=bestFeeTier,\n            sqrtPriceLimitX96=0,\n        )\n    )\n    return bestPoolAddr, amountIn\n\n\n# annoying that this cannot be view function, thanks uni v3\n@external\ndef getSwapAmountIn(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountOut: uint256,\n) -> uint256:\n    if _amountOut == 0 or _amountOut == max_value(uint256):\n        return max_value(uint256)\n\n    amountIn: uint256 = 0\n    na1: uint160 = 0\n    na2: uint32 = 0\n    na3: uint256 = 0\n    amountIn, na1, na2, na3 = extcall UniV3Quoter(UNIV3_QUOTER).quoteExactOutputSingle(\n        QuoteExactOutputSingleParams(\n            tokenIn=_tokenIn,\n            tokenOut=_tokenOut,\n            amount=_amountOut,\n            fee=staticcall UniV3Pool(_pool).fee(),\n            sqrtPriceLimitX96=0,\n        )\n    )\n    return amountIn\n\n\n@view\n@external\ndef getAddLiqAmountsIn(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _availAmountA: uint256,\n    _availAmountB: uint256,\n) -> (uint256, uint256, uint256):\n    token0: address = staticcall UniV3Pool(_pool).token0()\n\n    # get correct numerator and denominator\n    numerator: uint256 = 0\n    denominator: uint256 = 0\n    sqrtPriceX96Squared: uint256 = self._getSqrtPriceX96(_pool) ** 2\n    if _tokenA == token0:\n        numerator = sqrtPriceX96Squared\n        denominator = UNISWAP_Q96 ** 2\n    else:\n        numerator = UNISWAP_Q96 ** 2\n        denominator = sqrtPriceX96Squared\n\n    # calculate optimal amounts\n    amountA: uint256 = _availAmountA\n    amountB: uint256 = _availAmountA * numerator // denominator\n    if amountB > _availAmountB:\n        maybeAmountA: uint256 = _availAmountB * denominator // numerator\n        if maybeAmountA <= _availAmountA:\n            amountA = maybeAmountA\n            amountB = _availAmountB\n    return amountA, amountB, 0\n\n\n@view\n@external\ndef getRemoveLiqAmountsOut(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpAmount: uint256,\n) -> (uint256, uint256):\n    token0: address = staticcall UniV3Pool(_pool).token0()\n\n    # calculate expected amounts out\n    sqrtPriceX96: uint256 = self._getSqrtPriceX96(_pool)\n    amount0Out: uint256 = _lpAmount * UNISWAP_Q96 // sqrtPriceX96\n    amount1Out: uint256 = _lpAmount * sqrtPriceX96 // UNISWAP_Q96\n\n    # return amounts out\n    if _tokenA == token0:\n        return amount0Out, amount1Out\n    else:\n        return amount1Out, amount0Out\n\n\n@view\n@external\ndef getPrice(_asset: address, _decimals: uint256) -> uint256:\n    return 0 # TODO: implement price\n\n\n@view\n@external\ndef getPriceUnsafe(_pool: address, _targetToken: address, _appraiser: address = empty(address)) -> uint256:\n    token0: address = staticcall UniV3Pool(_pool).token0()\n    token1: address = staticcall UniV3Pool(_pool).token1()\n\n    # appraiser\n    appraiser: address = _appraiser\n    if _appraiser == empty(address):\n        appraiser = addys._getAppraiserAddr()\n\n    # alt price\n    altPrice: uint256 = 0\n    if _targetToken == token0:\n        altPrice = staticcall Appraiser(appraiser).getNormalAssetPrice(token1)\n    else:\n        altPrice = staticcall Appraiser(appraiser).getNormalAssetPrice(token0)\n\n    # return early if no alt price\n    if altPrice == 0:\n        return 0\n\n    # price of token0 in token1\n    sqrtPriceX96: uint256 = self._getSqrtPriceX96(_pool)\n    numerator: uint256 = sqrtPriceX96 ** 2 * EIGHTEEN_DECIMALS\n    priceZeroToOne: uint256 = numerator // (UNISWAP_Q96 ** 2)\n\n    # adjust for decimals: price should be in 18 decimals\n    decimals0: uint256 = convert(staticcall IERC20Detailed(token0).decimals(), uint256)\n    decimals1: uint256 = convert(staticcall IERC20Detailed(token1).decimals(), uint256)\n    if decimals0 > decimals1:\n        scaleFactor: uint256 = 10 ** (decimals0 - decimals1)\n        priceZeroToOne = priceZeroToOne * scaleFactor\n    elif decimals1 > decimals0:\n        scaleFactor: uint256 = 10 ** (decimals1 - decimals0)\n        priceZeroToOne = priceZeroToOne // scaleFactor\n\n    # if _targetToken is token1, make price inverse\n    priceToOther: uint256 = priceZeroToOne\n    if _targetToken == token1:\n        priceToOther = EIGHTEEN_DECIMALS * EIGHTEEN_DECIMALS // priceZeroToOne\n\n    return altPrice * priceToOther // EIGHTEEN_DECIMALS\n\n\n# internal utils\n\n\n@view\n@internal\ndef _getDeepestLiqPool(_tokenA: address, _tokenB: address) -> (address, uint24):\n    bestPoolAddr: address = empty(address)\n    bestFeeTier: uint24 = 0\n    bestLiquidity: uint128 = 0\n\n    factory: address = UNIV3_FACTORY\n    for i: uint256 in range(4):\n        fee: uint24 = FEE_TIERS[i]\n        pool: address = staticcall UniV3Factory(factory).getPool(_tokenA, _tokenB, fee)\n        if pool == empty(address):\n            continue\n        liquidity: uint128 = staticcall UniV3Pool(pool).liquidity()\n        if liquidity > bestLiquidity:\n            bestPoolAddr = pool\n            bestFeeTier = fee\n            bestLiquidity = liquidity\n\n    return bestPoolAddr, bestFeeTier\n\n\n@view\n@internal\ndef _getSqrtPriceX96(_pool: address) -> uint256:\n    sqrtPriceX96: uint160 = 0\n    tick: int24 = 0\n    observationIndex: uint16 = 0\n    observationCardinality: uint16 = 0\n    observationCardinalityNext: uint16 = 0\n    feeProtocol: uint8 = 0\n    unlocked: bool = False\n    sqrtPriceX96, tick, observationIndex, observationCardinality, observationCardinalityNext, feeProtocol, unlocked = staticcall UniV3Pool(_pool).slot0()\n    return convert(sqrtPriceX96, uint256)\n\n\n# nft recovery\n\n\n@external\ndef recoverNft(_collection: address, _nftTokenId: uint256, _recipient: address) -> bool:\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n\n    if staticcall IERC721(_collection).ownerOf(_nftTokenId) != self:\n        return False\n\n    extcall IERC721(_collection).safeTransferFrom(self, _recipient, _nftTokenId)\n    log UniswapV3NftRecovered(collection=_collection, nftTokenId=_nftTokenId, recipient=_recipient)\n    return True\n\n\n#########\n# Other #\n#########\n\n\n@external\ndef depositForYield(\n    _asset: address,\n    _amount: uint256,\n    _vaultAddr: address,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, address, uint256, uint256):\n    return 0, empty(address), 0, 0\n\n\n@external\ndef withdrawFromYield(\n    _vaultToken: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, address, uint256, uint256):\n    return 0, empty(address), 0, 0\n\n\n@external\ndef mintOrRedeemAsset(\n    _tokenIn: address,\n    _tokenOut: address,\n    _tokenInAmount: uint256,\n    _minAmountOut: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, bool, uint256):\n    return 0, 0, False, 0\n\n\n@external\ndef confirmMintOrRedeemAsset(\n    _tokenIn: address,\n    _tokenOut: address,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef addCollateral(\n    _asset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef removeCollateral(\n    _asset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef borrow(\n    _borrowAsset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef repayDebt(\n    _paymentAsset: address,\n    _paymentAmount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef claimRewards(\n    _user: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _extraData: bytes32,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n@external\ndef addLiquidity(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _amountA: uint256,\n    _amountB: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _minLpAmount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (address, uint256, uint256, uint256, uint256):\n    return empty(address), 0, 0, 0, 0\n\n\n@external\ndef removeLiquidity(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpToken: address,\n    _lpAmount: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, uint256):\n    return 0, 0, 0, 0\n\n@view\n@external\ndef getAccessForLego(_user: address, _action: ws.ActionType) -> (address, String[64], uint256):\n    return empty(address), empty(String[64]), 0\n",
            "sha256sum": "e9ac4353ff2240662d8d51f1d0ce4fa3887eaf2c587771d9e59ed9ea0e85b896"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/legos/dexes/UniswapV3.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.3+commit.bff19ea2",
        "integrity": "674c0df02d36ee90694bb3b92c85cffe1b5224176f96999b425b0cd469a2889f"
      },
      "args": "00000000000000000000000044cf3c4f000dfd76a35d03298049d37be688d6f900000000000000000000000033128a8fc17869897dce68ed026d694621f6fdfd00000000000000000000000003a520b32c04bf3beef7beb72e919cf822ed34f10000000000000000000000003d4e44eb1374240ce5f1b871ab261cd16335b76a000000000000000000000000d0b53d9277642d899df5c87a3966a349a798f224",
      "file": "contracts/legos/dexes/UniswapV3.vy"
    },
    "UnderscoreLego": {
      "address": "0xc01F6256795144B0c50A37E5c487925d302c881B",
      "abi": [
        {
          "name": "UnderscoreEarnVaultDeposit",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountDeposited",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultTokenAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UnderscoreEarnVaultWithdrawal",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultTokenAmountBurned",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LegoPauseModified",
          "inputs": [
            {
              "name": "isPaused",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LegoFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "balance",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "SnapShotPriceConfigSet",
          "inputs": [
            {
              "name": "minSnapshotDelay",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "maxNumSnapshots",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "maxUpsideDeviation",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "staleTime",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetOpportunityAdded",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultAddr",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetOpportunityRemoved",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultAddr",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PricePerShareSnapShotAdded",
          "inputs": [
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "totalSupply",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "pricePerShare",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddys",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "undyToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "hatchery",
                  "type": "address"
                },
                {
                  "name": "lootDistributor",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                },
                {
                  "name": "walletBackpack",
                  "type": "address"
                },
                {
                  "name": "billing",
                  "type": "address"
                },
                {
                  "name": "vaultRegistry",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUndyHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isLegoAsset",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssetOpportunities",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isAssetOpportunity",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getNumLegoAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pause",
          "inputs": [
            {
              "name": "_shouldPause",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFundsMany",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_assets",
              "type": "address[]"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getWeightedPricePerShare",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLatestSnapshot",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_pricePerShare",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "totalSupply",
                  "type": "uint256"
                },
                {
                  "name": "pricePerShare",
                  "type": "uint256"
                },
                {
                  "name": "lastUpdate",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setSnapShotPriceConfig",
          "inputs": [
            {
              "name": "_config",
              "type": "tuple",
              "components": [
                {
                  "name": "minSnapshotDelay",
                  "type": "uint256"
                },
                {
                  "name": "maxNumSnapshots",
                  "type": "uint256"
                },
                {
                  "name": "maxUpsideDeviation",
                  "type": "uint256"
                },
                {
                  "name": "staleTime",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidPriceConfig",
          "inputs": [
            {
              "name": "_config",
              "type": "tuple",
              "components": [
                {
                  "name": "minSnapshotDelay",
                  "type": "uint256"
                },
                {
                  "name": "maxNumSnapshots",
                  "type": "uint256"
                },
                {
                  "name": "maxUpsideDeviation",
                  "type": "uint256"
                },
                {
                  "name": "staleTime",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "vaultToAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "underlyingAsset",
                  "type": "address"
                },
                {
                  "name": "decimals",
                  "type": "uint256"
                },
                {
                  "name": "lastAveragePricePerShare",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assetOpportunities",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAssetOpportunity",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssetOpportunities",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assets",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "snapShotData",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "lastSnapShot",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "totalSupply",
                      "type": "uint256"
                    },
                    {
                      "name": "pricePerShare",
                      "type": "uint256"
                    },
                    {
                      "name": "lastUpdate",
                      "type": "uint256"
                    }
                  ]
                },
                {
                  "name": "nextIndex",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "snapShots",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "totalSupply",
                  "type": "uint256"
                },
                {
                  "name": "pricePerShare",
                  "type": "uint256"
                },
                {
                  "name": "lastUpdate",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "snapShotPriceConfig",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "minSnapshotDelay",
                  "type": "uint256"
                },
                {
                  "name": "maxNumSnapshots",
                  "type": "uint256"
                },
                {
                  "name": "maxUpsideDeviation",
                  "type": "uint256"
                },
                {
                  "name": "staleTime",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isPaused",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasCapability",
          "inputs": [
            {
              "name": "_action",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRegistries",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isYieldLego",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isDexLego",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAsset",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingBalances",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenBalance",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAmount",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAmountSafe",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenBalance",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingData",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingData",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            },
            {
              "name": "_appraiser",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValueOfVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValueOfVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            },
            {
              "name": "_appraiser",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isRebasing",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPricePerShare",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPricePerShare",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_decimals",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getVaultTokenAmount",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_assetAmount",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isEligibleVaultForTrialFunds",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_underlyingAsset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isEligibleForYieldBonus",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalAssets",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalBorrows",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canRegisterVaultToken",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "registerVaultTokenLocally",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "underlyingAsset",
                  "type": "address"
                },
                {
                  "name": "decimals",
                  "type": "uint256"
                },
                {
                  "name": "lastAveragePricePerShare",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "deregisterVaultTokenLocally",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addPriceSnapshot",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositForYield",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositForYield",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawFromYield",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawFromYield",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasClaimableRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAccessForLego",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_action",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "string"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_tokenPath",
              "type": "address[]"
            },
            {
              "name": "_poolPath",
              "type": "address[]"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_tokenPath",
              "type": "address[]"
            },
            {
              "name": "_poolPath",
              "type": "address[]"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_tokenInAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_tokenInAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmMintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmMintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_borrowAsset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_borrowAsset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_paymentAsset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_paymentAsset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_undyHq",
              "type": "address"
            },
            {
              "name": "_ripeToken",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "interfaces/WalletStructs.vyi": {
            "content": "# @version 0.4.3\n\nflag ActionType:\n    TRANSFER\n    EARN_DEPOSIT\n    EARN_WITHDRAW\n    EARN_REBALANCE\n    SWAP\n    MINT_REDEEM\n    CONFIRM_MINT_REDEEM\n    ADD_COLLATERAL\n    REMOVE_COLLATERAL\n    BORROW\n    REPAY_DEBT\n    REWARDS\n    ETH_TO_WETH\n    WETH_TO_ETH\n    ADD_LIQ\n    REMOVE_LIQ\n    ADD_LIQ_CONC\n    REMOVE_LIQ_CONC\n    PAY_CHEQUE\n\nstruct WalletAssetData:\n    assetBalance: uint256\n    usdValue: uint256\n    isYieldAsset: bool\n    lastPricePerShare: uint256\n\nstruct ActionData:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    billing: address\n    wallet: address\n    walletConfig: address\n    walletOwner: address\n    inEjectMode: bool\n    isFrozen: bool\n    lastTotalUsdValue: uint256\n    signer: address\n    isManager: bool\n    legoId: uint256\n    legoAddr: address\n    eth: address\n    weth: address\n\nstruct MiniAddys:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    appraiser: address",
            "sha256sum": "9a4b4f59b3a62043e51b425a665064aae419a3c0bd0514b6b29a9441ae364bb9"
          },
          "interfaces/LegoPartner.vyi": {
            "content": "# @version 0.4.3\n\nfrom interfaces import WalletStructs as ws\n\nMAX_TOKEN_PATH: constant(uint256) = 5\nMAX_RECOVER_ASSETS: constant(uint256) = 20\n\n@external\ndef addLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _tickLower: int24, _tickUpper: int24, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef addLiquidity(_pool: address, _tokenA: address, _tokenB: address, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _minLpAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (address, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef removeLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _liqToRemove: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef removeLiquidity(_pool: address, _tokenA: address, _tokenB: address, _lpToken: address, _lpAmount: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef mintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _tokenInAmount: uint256, _minAmountOut: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef swapTokens(_amountIn: uint256, _minAmountOut: uint256, _tokenPath: DynArray[address, MAX_TOKEN_PATH], _poolPath: DynArray[address, MAX_TOKEN_PATH - 1], _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256):\n    ...\n\n@external\ndef depositForYield(_asset: address, _amount: uint256, _vaultAddr: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef withdrawFromYield(_vaultToken: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef confirmMintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef borrow(_borrowAsset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef repayDebt(_paymentAsset: address, _paymentAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef claimRewards(_user: address, _rewardToken: address, _rewardAmount: uint256, _extraData: bytes32, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef removeCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef addCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@view\n@external\ndef getAccessForLego(_user: address, _action: ws.ActionType) -> (address, String[64], uint256):\n    ...\n\n@view\n@external\ndef hasCapability(_action: ws.ActionType) -> bool:\n    ...\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    ...\n\n@view\n@external\ndef isYieldLego() -> bool:\n    ...\n\n@view\n@external\ndef isDexLego() -> bool:\n    ...\n\n\n# common\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "81db71fe4440a3b4b563134c9b5caf1d5705772a5f291fe874c9b5fb3cfb1623"
          },
          "interfaces/LegoStructs.vyi": {
            "content": "# @version 0.4.3\n\nstruct VaultTokenInfo:\n    underlyingAsset: address\n    decimals: uint256\n    lastAveragePricePerShare: uint256\n\nstruct SnapShotPriceConfig:\n    minSnapshotDelay: uint256\n    maxNumSnapshots: uint256\n    maxUpsideDeviation: uint256\n    staleTime: uint256\n\nstruct SingleSnapShot:\n    totalSupply: uint256\n    pricePerShare: uint256\n    lastUpdate: uint256\n\nstruct SnapShotData:\n    lastSnapShot: SingleSnapShot\n    nextIndex: uint256\n",
            "sha256sum": "8ae48be17d812d57fbd671bbf0593e8abf175ad0924e47c5997823cac19ec806"
          },
          "interfaces/YieldLego.vyi": {
            "content": "# @version 0.4.3\n\nfrom interfaces import LegoStructs as ls\n\n\n###################\n# Underlying Data #\n###################\n\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    ...\n\n\n@view\n@external\ndef getUnderlyingBalances(_vaultToken: address, _vaultTokenBalance: uint256) -> (uint256, uint256):\n    ...\n\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    ...\n\n\n@view\n@external\ndef getUnderlyingAmountSafe(_vaultToken: address, _vaultTokenBalance: uint256) -> uint256:\n    ...\n\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> (address, uint256, uint256):\n    ...\n\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> uint256:\n    ...\n\n\n###############\n# Other Utils #\n###############\n\n\n@view\n@external\ndef isRebasing() -> bool:\n    ...\n\n\n@view\n@external\ndef getPricePerShare(_vaultToken: address, _decimals: uint256 = 0) -> uint256:\n    ...\n\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef canRegisterVaultToken(_asset: address, _vaultToken: address) -> bool:\n    ...\n\n\n@view\n@external\ndef isEligibleVaultForTrialFunds(_vaultToken: address, _underlyingAsset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef isEligibleForYieldBonus(_asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    ...\n\n\n###################\n# Yield Lego Data #\n###################\n\n\n@view\n@external\ndef isLegoAsset(_asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, 40]:\n    ...\n\n\n@view\n@external\ndef getAssets() -> DynArray[address, 20]:\n    ...\n\n\n@view\n@external\ndef isAssetOpportunity(_asset: address, _vaultAddr: address) -> bool:\n    ...\n\n\n@view\n@external\ndef getNumLegoAssets() -> uint256:\n    ...\n\n\n@view\n@external\ndef assets(_index: uint256) -> address:\n    ...\n\n\n@view\n@external\ndef indexOfAsset(_asset: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef numAssets() -> uint256:\n    ...\n\n\n@view\n@external\ndef assetOpportunities(_asset: address, _index: uint256) -> address:\n    ...\n\n\n@view\n@external\ndef indexOfAssetOpportunity(_asset: address, _vaultAddr: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef numAssetOpportunities(_asset: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef vaultToAsset(_vaultAddr: address) -> ls.VaultTokenInfo:\n    ...\n\n\n# price snapshots\n\n\n@external\ndef addPriceSnapshot(_vaultToken: address) -> bool:\n    ...\n\n\n@view\n@external\ndef snapShotPriceConfig() -> ls.SnapShotPriceConfig:\n    ...\n\n\n@view\n@external\ndef snapShotData(_vaultToken: address) -> ls.SnapShotData:\n    ...\n\n\n@view\n@external\ndef snapShots(_vaultToken: address, _index: uint256) -> ls.SingleSnapShot:\n    ...\n\n\n@view\n@external\ndef getWeightedPricePerShare(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef getLatestSnapshot(_vaultToken: address, _pricePerShare: uint256) -> ls.SingleSnapShot:\n    ...\n\n\n@external\ndef setSnapShotPriceConfig(_config: ls.SnapShotPriceConfig):\n    ...\n",
            "sha256sum": "045a6bbd3d556234cf4fe925a303002dc0ac3c482d344ffbaf4bc52a7e6ad2df"
          },
          "contracts/modules/Addys.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\ninterface UndyHq:\n    def isValidAddr(_addr: address) -> bool: view\n    def getAddr(_regId: uint256) -> address: view\n    def undyToken() -> address: view\n\ninterface Switchboard:\n    def isSwitchboardAddr(_addr: address) -> bool: view\n\ninterface LegoBook:\n    def isLegoAddr(_addr: address) -> bool: view\n\nstruct Addys:\n    hq: address\n    undyToken: address\n    ledger: address\n    missionControl: address\n    legoBook: address\n    switchboard: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    walletBackpack: address\n    billing: address\n    vaultRegistry: address\n\n# hq\nUNDY_HQ_FOR_ADDYS: immutable(address)\n\n# core addys\nLEDGER_ID: constant(uint256) = 1\nMISSION_CONTROL_ID: constant(uint256) = 2\nLEGO_BOOK_ID: constant(uint256) = 3\nSWITCHBOARD_ID: constant(uint256) = 4\nHATCHERY_ID: constant(uint256) = 5\nLOOT_DISTRIBUTOR_ID: constant(uint256) = 6\nAPPRAISER_ID: constant(uint256) = 7\nWALLET_BACKPACK_ID: constant(uint256) = 8\nBILLING_ID: constant(uint256) = 9\nVAULT_REGISTRY_ID: constant(uint256) = 10\n\n\n@deploy\ndef __init__(_undyHq: address):\n    assert _undyHq != empty(address) # dev: invalid undy hq\n    UNDY_HQ_FOR_ADDYS = _undyHq\n\n\n########\n# Core #\n########\n\n\n@view\n@external\ndef getAddys() -> Addys:\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _getAddys(_addys: Addys = empty(Addys)) -> Addys:\n    if _addys.hq != empty(address):\n        return _addys\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _generateAddys() -> Addys:\n    hq: address = UNDY_HQ_FOR_ADDYS\n    return Addys(\n        hq = hq,\n        undyToken = staticcall UndyHq(hq).undyToken(),\n        ledger = staticcall UndyHq(hq).getAddr(LEDGER_ID),\n        missionControl = staticcall UndyHq(hq).getAddr(MISSION_CONTROL_ID),\n        legoBook = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID),\n        switchboard = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID),\n        hatchery = staticcall UndyHq(hq).getAddr(HATCHERY_ID),\n        lootDistributor = staticcall UndyHq(hq).getAddr(LOOT_DISTRIBUTOR_ID),\n        appraiser = staticcall UndyHq(hq).getAddr(APPRAISER_ID),\n        walletBackpack = staticcall UndyHq(hq).getAddr(WALLET_BACKPACK_ID),\n        billing = staticcall UndyHq(hq).getAddr(BILLING_ID),\n        vaultRegistry = staticcall UndyHq(hq).getAddr(VAULT_REGISTRY_ID),\n    )\n\n\n##########\n# Tokens #\n##########\n\n\n@view\n@internal\ndef _getUndyToken() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).undyToken()\n\n\n###########\n# Helpers #\n###########\n\n\n# undy hq\n\n\n@view\n@external\ndef getUndyHq() -> address:\n    return self._getUndyHq()\n\n\n@view\n@internal\ndef _getUndyHq() -> address:\n    return UNDY_HQ_FOR_ADDYS\n\n\n# utils\n\n\n@view\n@internal\ndef _isValidUndyAddr(_addr: address, _hq: address = empty(address)) -> bool:\n    hq: address = _hq\n    if _hq == empty(address):\n        hq = UNDY_HQ_FOR_ADDYS\n    \n    # core departments\n    if staticcall UndyHq(hq).isValidAddr(_addr):\n        return True\n\n    # lego book\n    legoBook: address = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID)\n    if legoBook != empty(address) and staticcall LegoBook(legoBook).isLegoAddr(_addr):\n        return True\n\n    # switchboard config\n    switchboard: address = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID)\n    if switchboard != empty(address) and staticcall Switchboard(switchboard).isSwitchboardAddr(_addr):\n        return True\n\n    return False\n\n\n@view\n@internal\ndef _isSwitchboardAddr(_addr: address) -> bool:\n    switchboard: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n    if switchboard == empty(address):\n        return False\n    return staticcall Switchboard(switchboard).isSwitchboardAddr(_addr)\n\n\n@view\n@internal\ndef _isLegoBookAddr(_addr: address) -> bool:\n    legoBook: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n    if legoBook == empty(address):\n        return False\n    return staticcall LegoBook(legoBook).isLegoAddr(_addr)\n\n\n###############\n# Departments #\n###############\n\n\n# ledger\n\n\n@view\n@internal\ndef _getLedgerId() -> uint256:\n    return LEDGER_ID\n\n\n@view\n@internal\ndef _getLedgerAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEDGER_ID)\n\n\n# mission control\n\n\n@view\n@internal\ndef _getMissionControlId() -> uint256:\n    return MISSION_CONTROL_ID\n\n\n@view\n@internal\ndef _getMissionControlAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(MISSION_CONTROL_ID)\n\n\n# lego book\n\n\n@view\n@internal\ndef _getLegoBookId() -> uint256:\n    return LEGO_BOOK_ID\n\n\n@view\n@internal\ndef _getLegoBookAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n\n\n# switchboard\n\n\n@view\n@internal\ndef _getSwitchboardId() -> uint256:\n    return SWITCHBOARD_ID\n\n\n@view\n@internal\ndef _getSwitchboardAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n\n\n# hatchery\n\n\n@view\n@internal\ndef _getHatcheryId() -> uint256:\n    return HATCHERY_ID\n\n\n@view\n@internal\ndef _getHatcheryAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(HATCHERY_ID)\n\n\n# loot distributor\n\n\n@view\n@internal\ndef _getLootDistributorId() -> uint256:\n    return LOOT_DISTRIBUTOR_ID\n\n\n@view\n@internal\ndef _getLootDistributorAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LOOT_DISTRIBUTOR_ID)\n\n\n# appraiser\n\n\n@view\n@internal\ndef _getAppraiserId() -> uint256:\n    return APPRAISER_ID\n\n\n@view\n@internal\ndef _getAppraiserAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(APPRAISER_ID)\n\n\n# wallet backpack\n\n\n@view\n@internal\ndef _getWalletBackpackId() -> uint256:\n    return WALLET_BACKPACK_ID\n\n\n@view\n@internal\ndef _getWalletBackpackAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(WALLET_BACKPACK_ID)\n\n\n# billing\n\n\n@view\n@internal\ndef _getBillingId() -> uint256:\n    return BILLING_ID\n\n\n@view\n@internal\ndef _getBillingAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(BILLING_ID)\n\n\n# vault registry\n\n\n@view\n@internal\ndef _getVaultRegistryId() -> uint256:\n    return VAULT_REGISTRY_ID\n\n\n@view\n@internal\ndef _getVaultRegistryAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(VAULT_REGISTRY_ID)",
            "sha256sum": "4df6b72db9bb417d1af81660175be1450cfb7b3575f3d17a5b8a130bff87b781"
          },
          "contracts/modules/YieldLegoData.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nuses: addys\n\nimport contracts.modules.Addys as addys\n\nfrom interfaces import WalletStructs as ws\nfrom interfaces import LegoStructs as ls\nfrom ethereum.ercs import IERC20\nfrom ethereum.ercs import IERC20Detailed\n\nevent AssetOpportunityAdded:\n    asset: indexed(address)\n    vaultAddr: indexed(address)\n\nevent AssetOpportunityRemoved:\n    asset: indexed(address)\n    vaultAddr: indexed(address)\n\nevent LegoPauseModified:\n    isPaused: bool\n\nevent LegoFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    balance: uint256\n\nevent PricePerShareSnapShotAdded:\n    vaultToken: indexed(address)\n    totalSupply: uint256\n    pricePerShare: uint256\n\nevent SnapShotPriceConfigSet:\n    minSnapshotDelay: uint256\n    maxNumSnapshots: uint256\n    maxUpsideDeviation: uint256\n    staleTime: uint256\n\n# core\nvaultToAsset: public(HashMap[address, ls.VaultTokenInfo]) # vault addr -> data\n\n# asset opportunities\nassetOpportunities: public(HashMap[address, HashMap[uint256, address]]) # asset -> index -> vault addr\nindexOfAssetOpportunity: public(HashMap[address, HashMap[address, uint256]]) # asset -> vault addr -> index\nnumAssetOpportunities: public(HashMap[address, uint256]) # asset -> number of opportunities\n\n# lego assets (iterable)\nassets: public(HashMap[uint256, address]) # index -> asset\nindexOfAsset: public(HashMap[address, uint256]) # asset -> index\nnumAssets: public(uint256) # num assets\n\n# price snapshots\nsnapShotData: public(HashMap[address, ls.SnapShotData]) # vault token -> data\nsnapShots: public(HashMap[address, HashMap[uint256, ls.SingleSnapShot]]) # vault token -> index -> snapshot\nsnapShotPriceConfig: public(ls.SnapShotPriceConfig) # config\n\nisPaused: public(bool)\n\nMAX_VAULTS: constant(uint256) = 40\nMAX_ASSETS: constant(uint256) = 20\nMAX_RECOVER_ASSETS: constant(uint256) = 20\nONE_DAY_SECONDS: constant(uint256) = 60 * 60 * 24\nONE_WEEK_SECONDS: constant(uint256) = ONE_DAY_SECONDS * 7\nHUNDRED_PERCENT: constant(uint256) = 100_00\n\n\n@deploy\ndef __init__(_shouldPause: bool):\n    self.isPaused = _shouldPause\n    self.numAssets = 1 # not using 0 index\n\n    # default snapshot price config\n    self.snapShotPriceConfig = ls.SnapShotPriceConfig(\n        minSnapshotDelay = 60 * 10, # 10 minutes\n        maxNumSnapshots = 20,\n        maxUpsideDeviation = 10_00, # 10%\n        staleTime = 3 * ONE_DAY_SECONDS, # 3 days\n    )\n\n\n#########\n# Views #\n#########\n\n\n# is lego asset\n\n\n@view\n@external\ndef isLegoAsset(_asset: address) -> bool:\n    return self._isLegoAsset(_asset)\n\n\n@view\n@internal\ndef _isLegoAsset(_asset: address) -> bool:\n    return self.indexOfAsset[_asset] != 0\n\n\n# vault opportunities\n\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, MAX_VAULTS]:\n    numOpportunities: uint256 = self.numAssetOpportunities[_asset]\n    if numOpportunities == 0:\n        return []\n    opportunities: DynArray[address, MAX_VAULTS] = []\n    for i: uint256 in range(1, numOpportunities, bound=MAX_VAULTS):\n        opportunities.append(self.assetOpportunities[_asset][i])\n    return opportunities\n\n\n# all assets registered\n\n\n@view\n@external\ndef getAssets() -> DynArray[address, MAX_ASSETS]:\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return []\n    assets: DynArray[address, MAX_ASSETS] = []\n    for i: uint256 in range(1, numAssets, bound=MAX_ASSETS):\n        assets.append(self.assets[i])\n    return assets\n\n\n################\n# Registration #\n################\n\n\n@view\n@external\ndef isAssetOpportunity(_asset: address, _vaultAddr: address) -> bool:\n    return self._isAssetOpportunity(_asset, _vaultAddr)\n\n\n@view\n@internal\ndef _isAssetOpportunity(_asset: address, _vaultAddr: address) -> bool:\n    return self.indexOfAssetOpportunity[_asset][_vaultAddr] != 0\n\n\n# add asset opportunity\n\n\n@internal\ndef _addAssetOpportunity(_asset: address, _vaultAddr: address) -> ls.VaultTokenInfo:\n    if self.indexOfAssetOpportunity[_asset][_vaultAddr] != 0:\n        return self.vaultToAsset[_vaultAddr]\n\n    if empty(address) in [_asset, _vaultAddr]:\n        return empty(ls.VaultTokenInfo)\n\n    # add asset opportunity\n    aid: uint256 = self.numAssetOpportunities[_asset]\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.assetOpportunities[_asset][aid] = _vaultAddr\n    self.indexOfAssetOpportunity[_asset][_vaultAddr] = aid\n    self.numAssetOpportunities[_asset] = aid + 1\n\n    # add mapping\n    vaultInfo: ls.VaultTokenInfo = ls.VaultTokenInfo(\n        underlyingAsset = _asset,\n        decimals = convert(staticcall IERC20Detailed(_vaultAddr).decimals(), uint256),\n        lastAveragePricePerShare = 0,\n    )\n    self.vaultToAsset[_vaultAddr] = vaultInfo\n\n    # add asset\n    self._addAsset(_asset)\n\n    log AssetOpportunityAdded(asset=_asset, vaultAddr=_vaultAddr)\n    return vaultInfo\n\n\n# remove asset opportunity\n\n\n@internal\ndef _removeAssetOpportunity(_asset: address, _vaultAddr: address):\n    numOpportunities: uint256 = self.numAssetOpportunities[_asset]\n    if numOpportunities == 0:\n        return\n\n    targetIndex: uint256 = self.indexOfAssetOpportunity[_asset][_vaultAddr]\n    if targetIndex == 0:\n        return\n\n    # update data\n    lastIndex: uint256 = numOpportunities - 1\n    self.numAssetOpportunities[_asset] = lastIndex\n    self.indexOfAssetOpportunity[_asset][_vaultAddr] = 0\n\n    self.vaultToAsset[_vaultAddr] = empty(ls.VaultTokenInfo)\n\n    # shift to replace the removed one\n    if targetIndex != lastIndex:\n        lastVaultAddr: address = self.assetOpportunities[_asset][lastIndex]\n        self.assetOpportunities[_asset][targetIndex] = lastVaultAddr\n        self.indexOfAssetOpportunity[_asset][lastVaultAddr] = targetIndex\n\n    # remove asset\n    if lastIndex <= 1:\n        self._removeAsset(_asset)\n\n    log AssetOpportunityRemoved(asset=_asset, vaultAddr=_vaultAddr)\n\n\n# add asset\n\n\n@internal\ndef _addAsset(_asset: address):\n    if self.indexOfAsset[_asset] != 0:\n        return\n\n    aid: uint256 = self.numAssets\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.assets[aid] = _asset\n    self.indexOfAsset[_asset] = aid\n    self.numAssets = aid + 1\n\n\n# remove asset\n\n\n@internal\ndef _removeAsset(_asset: address):\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return\n\n    targetIndex: uint256 = self.indexOfAsset[_asset]\n    if targetIndex == 0:\n        return\n\n    # update data\n    lastIndex: uint256 = numAssets - 1\n    self.numAssets = lastIndex\n    self.indexOfAsset[_asset] = 0\n\n    # shift to replace the removed one\n    if targetIndex != lastIndex:\n        lastAsset: address = self.assets[lastIndex]\n        self.assets[targetIndex] = lastAsset\n        self.indexOfAsset[lastAsset] = targetIndex\n\n\n# num lego assets (true number, use `numAssets` for iteration)\n\n\n@view\n@external\ndef getNumLegoAssets() -> uint256:\n    return self._getNumLegoAssets()\n\n\n@view\n@internal\ndef _getNumLegoAssets() -> uint256:\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return 0\n    return numAssets - 1\n\n\n###########\n# General #\n###########\n\n\n# fill mini addys\n\n\n@view\n@internal\ndef _getMiniAddys(_miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> ws.MiniAddys:\n    if _miniAddys.ledger != empty(address):\n        return _miniAddys\n    return ws.MiniAddys(\n        ledger = addys._getLedgerAddr(),\n        missionControl = addys._getMissionControlAddr(),\n        legoBook = addys._getLegoBookAddr(),\n        appraiser = addys._getAppraiserAddr(),\n    )\n\n\n# activate\n\n\n@external\ndef pause(_shouldPause: bool):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert _shouldPause != self.isPaused # dev: no change\n    self.isPaused = _shouldPause\n    log LegoPauseModified(isPaused=_shouldPause)\n\n\n# recover funds\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    self._recoverFunds(_recipient, _asset)\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, MAX_RECOVER_ASSETS]):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    for a: address in _assets:\n        self._recoverFunds(_recipient, a)\n\n\n@internal\ndef _recoverFunds(_recipient: address, _asset: address):\n    assert empty(address) not in [_recipient, _asset] # dev: invalid recipient or asset\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    assert balance != 0 # dev: nothing to recover\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log LegoFundsRecovered(asset=_asset, recipient=_recipient, balance=balance)\n\n\n###################\n# Price Snapshots #\n###################\n\n\n# add price snapshot\n\n\n@internal\ndef _addPriceSnapshot(_vaultToken: address, _pricePerShare: uint256, _vaultTokenDecimals: uint256) -> bool:\n    config: ls.SnapShotPriceConfig = self.snapShotPriceConfig\n    if config.maxNumSnapshots == 0:\n        return False\n\n    data: ls.SnapShotData = self.snapShotData[_vaultToken]\n\n    # already have snapshot for this time\n    if data.lastSnapShot.lastUpdate == block.timestamp:\n        return False\n\n    # check if snapshot is too recent\n    if data.lastSnapShot.lastUpdate + config.minSnapshotDelay > block.timestamp:\n        return False\n\n    # create and store new snapshot\n    newSnapshot: ls.SingleSnapShot = self._getLatestSnapshot(_vaultToken, _pricePerShare, _vaultTokenDecimals, data.lastSnapShot, config)\n    data.lastSnapShot = newSnapshot\n    self.snapShots[_vaultToken][data.nextIndex] = newSnapshot\n\n    # update index\n    data.nextIndex += 1\n    if data.nextIndex >= config.maxNumSnapshots:\n        data.nextIndex = 0\n\n    # save snap shot data\n    self.snapShotData[_vaultToken] = data\n\n    # update cached weighted average price per share\n    self.vaultToAsset[_vaultToken].lastAveragePricePerShare = self._getWeightedPricePerShare(_vaultToken, _pricePerShare)\n\n    log PricePerShareSnapShotAdded(\n        vaultToken = _vaultToken,\n        totalSupply = newSnapshot.totalSupply,\n        pricePerShare = newSnapshot.pricePerShare,\n    )\n    return True\n\n\n# weighted price per share\n\n\n@view\n@external\ndef getWeightedPricePerShare(_vaultToken: address) -> uint256:\n    data: ls.SnapShotData = self.snapShotData[_vaultToken]\n    return self._getWeightedPricePerShare(_vaultToken, data.lastSnapShot.pricePerShare)\n\n\n@view\n@internal\ndef _getWeightedPricePerShare(_vaultToken: address, _lastPricePerShare: uint256) -> uint256:\n    config: ls.SnapShotPriceConfig = self.snapShotPriceConfig\n    if config.maxNumSnapshots == 0:\n        return 0\n\n    # calculate weighted average price using all valid snapshots\n    numerator: uint256 = 0\n    denominator: uint256 = 0\n    for i: uint256 in range(config.maxNumSnapshots, bound=max_value(uint256)):\n\n        snapShot: ls.SingleSnapShot = self.snapShots[_vaultToken][i]\n        if snapShot.pricePerShare == 0 or snapShot.totalSupply == 0 or snapShot.lastUpdate == 0:\n            continue\n\n        # too stale, skip\n        if config.staleTime != 0 and block.timestamp > snapShot.lastUpdate + config.staleTime:\n            continue\n\n        numerator += (snapShot.totalSupply * snapShot.pricePerShare)\n        denominator += snapShot.totalSupply\n\n    # weighted price per share\n    weightedPricePerShare: uint256 = 0\n    if numerator != 0:\n        weightedPricePerShare = numerator // denominator\n    else:\n        weightedPricePerShare = _lastPricePerShare\n\n    return weightedPricePerShare\n\n\n# latest snapshot\n\n\n@view\n@external\ndef getLatestSnapshot(_vaultToken: address, _pricePerShare: uint256) -> ls.SingleSnapShot:\n    data: ls.SnapShotData = self.snapShotData[_vaultToken]\n    config: ls.SnapShotPriceConfig = self.snapShotPriceConfig\n    vaultTokenDecimals: uint256 = self.vaultToAsset[_vaultToken].decimals\n    return self._getLatestSnapshot(_vaultToken, _pricePerShare, vaultTokenDecimals, data.lastSnapShot, config)\n\n\n@view\n@internal\ndef _getLatestSnapshot(\n    _vaultToken: address,\n    _pricePerShare: uint256,\n    _vaultTokenDecimals: uint256,\n    _lastSnapShot: ls.SingleSnapShot,\n    _config: ls.SnapShotPriceConfig,\n) -> ls.SingleSnapShot:\n\n    # total supply (adjusted)\n    totalSupply: uint256 = staticcall IERC20(_vaultToken).totalSupply() // (10 ** _vaultTokenDecimals)\n    if totalSupply == 0:\n        totalSupply = 1\n\n    # throttle upside (extra safety check)\n    pricePerShare: uint256 = self._throttleUpside(_pricePerShare, _lastSnapShot.pricePerShare, _config.maxUpsideDeviation)\n\n    return ls.SingleSnapShot(\n        totalSupply = totalSupply,\n        pricePerShare = pricePerShare,\n        lastUpdate = block.timestamp,\n    )\n\n\n@view\n@internal\ndef _throttleUpside(_newValue: uint256, _prevValue: uint256, _maxUpside: uint256) -> uint256:\n    if _maxUpside == 0 or _prevValue == 0 or _newValue == 0:\n        return _newValue\n    maxPricePerShare: uint256 = _prevValue + (_prevValue * _maxUpside // HUNDRED_PERCENT)\n    return min(_newValue, maxPricePerShare)\n\n\n# snapshot price config\n\n\n@external\ndef setSnapShotPriceConfig(_config: ls.SnapShotPriceConfig):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert self._isValidPriceConfig(_config) # dev: invalid config\n    self.snapShotPriceConfig = _config\n    log SnapShotPriceConfigSet(\n        minSnapshotDelay=_config.minSnapshotDelay,\n        maxNumSnapshots=_config.maxNumSnapshots,\n        maxUpsideDeviation=_config.maxUpsideDeviation,\n        staleTime=_config.staleTime\n    )\n\n\n@view\n@external\ndef isValidPriceConfig(_config: ls.SnapShotPriceConfig) -> bool:\n    return self._isValidPriceConfig(_config)\n\n\n@view\n@internal\ndef _isValidPriceConfig(_config: ls.SnapShotPriceConfig) -> bool:\n    if _config.minSnapshotDelay > ONE_WEEK_SECONDS:\n        return False\n    if _config.maxNumSnapshots == 0 or _config.maxNumSnapshots > 25:\n        return False\n    if _config.maxUpsideDeviation > HUNDRED_PERCENT:\n        return False\n    return _config.staleTime < ONE_WEEK_SECONDS",
            "sha256sum": "d695c6d3998cf2ed318a0da6f4f7918abf97661e10eb510ed996d815e65927e0"
          },
          "contracts/legos/UnderscoreLego.vy": {
            "content": "#     __   __ ___ _______ ___     ______       ___     _______ _______ _______ \n#    |  | |  |   |       |   |   |      |     |   |   |       |       |       |\n#    |  |_|  |   |    ___|   |   |  _    |    |   |   |    ___|    ___|   _   |\n#    |       |   |   |___|   |   | | |   |    |   |   |   |___|   | __|  | |  |\n#    |_     _|   |    ___|   |___| |_|   |    |   |___|    ___|   ||  |  |_|  |\n#      |   | |   |   |___|       |       |    |       |   |___|   |_| |       |\n#      |___| |___|_______|_______|______|     |_______|_______|_______|_______|\n#                                                                       \n#     \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n#     \u2551  ** Underscore Lego **                    \u2551\n#     \u2551  Integration with Underscore Protocol     \u2551\n#     \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n#\n#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nimplements: Lego\nimplements: YieldLego\n\nexports: addys.__interface__\nexports: yld.__interface__\n\ninitializes: addys\ninitializes: yld[addys := addys]\n\nfrom interfaces import LegoPartner as Lego\nfrom interfaces import YieldLego as YieldLego\nfrom interfaces import WalletStructs as ws\nfrom interfaces import LegoStructs as ls\n\nimport contracts.modules.Addys as addys\nimport contracts.modules.YieldLegoData as yld\n\nfrom ethereum.ercs import IERC20\nfrom ethereum.ercs import IERC4626\n\ninterface LootDistributor:\n    def claimRevShareAndBonusLoot(_user: address) -> uint256: nonpayable\n    def getClaimableDepositRewards(_user: address) -> uint256: view\n    def claimDepositRewards(_user: address) -> uint256: nonpayable\n    def getTotalClaimableAssets(_user: address) -> uint256: view\n\ninterface Ledger:\n    def setVaultToken(_vaultToken: address, _legoId: uint256, _underlyingAsset: address, _decimals: uint256, _isRebasing: bool): nonpayable\n    def isRegisteredVaultToken(_vaultToken: address) -> bool: view\n    def isUserWallet(_user: address) -> bool: view\n\ninterface Appraiser:\n    def getUsdValue(_asset: address, _amount: uint256, _missionControl: address = empty(address), _legoBook: address = empty(address), _ledger: address = empty(address)) -> uint256: view\n    def updatePriceAndGetUsdValue(_asset: address, _amount: uint256, _missionControl: address = empty(address), _legoBook: address = empty(address)) -> uint256: nonpayable\n\ninterface VaultRegistry:\n    def isEarnVault(_vaultAddr: address) -> bool: view\n\ninterface Registry:\n    def getRegId(_addr: address) -> uint256: view\n\nevent UnderscoreEarnVaultDeposit:\n    sender: indexed(address)\n    asset: indexed(address)\n    vaultToken: indexed(address)\n    assetAmountDeposited: uint256\n    usdValue: uint256\n    vaultTokenAmountReceived: uint256\n    recipient: address\n\nevent UnderscoreEarnVaultWithdrawal:\n    sender: indexed(address)\n    asset: indexed(address)\n    vaultToken: indexed(address)\n    assetAmountReceived: uint256\n    usdValue: uint256\n    vaultTokenAmountBurned: uint256\n    recipient: address\n\nRIPE_TOKEN: immutable(address)\n\nMAX_TOKEN_PATH: constant(uint256) = 5\n\n\n@deploy\ndef __init__(_undyHq: address, _ripeToken: address):\n    addys.__init__(_undyHq)\n    yld.__init__(False)\n\n    assert _ripeToken != empty(address) # dev: invalid addrs\n    RIPE_TOKEN = _ripeToken\n\n\n@view\n@external\ndef hasCapability(_action: ws.ActionType) -> bool:\n    return _action in (\n        ws.ActionType.EARN_DEPOSIT | \n        ws.ActionType.EARN_WITHDRAW |\n        ws.ActionType.REWARDS\n    )\n\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    return [addys._getVaultRegistryAddr()]\n\n\n@view\n@external\ndef isYieldLego() -> bool:\n    return True\n\n\n@view\n@external\ndef isDexLego() -> bool:\n    return False\n\n\n###################\n# Underlying Data #\n###################\n\n\n# underlying asset\n\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    return self._getUnderlyingAsset(_vaultToken)\n\n\n@view\n@internal\ndef _getUnderlyingAsset(_vaultToken: address) -> address:\n    return yld.vaultToAsset[_vaultToken].underlyingAsset\n\n\n# underlying balances (both true and safe)\n\n\n@view\n@external\ndef getUnderlyingBalances(_vaultToken: address, _vaultTokenBalance: uint256) -> (uint256, uint256):\n    if _vaultTokenBalance == 0:\n        return 0, 0\n\n    trueUnderlying: uint256 = self._getUnderlyingAmount(_vaultToken, _vaultTokenBalance)\n    safeUnderlying: uint256 = self._getUnderlyingAmountSafe(_vaultToken, _vaultTokenBalance)\n    if safeUnderlying == 0:\n        safeUnderlying = trueUnderlying\n\n    return trueUnderlying, min(trueUnderlying, safeUnderlying)\n\n\n# underlying amount (true)\n\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    return self._getUnderlyingAmount(_vaultToken, _vaultTokenAmount)\n\n\n@view\n@internal\ndef _getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    return staticcall IERC4626(_vaultToken).convertToAssets(_vaultTokenAmount)\n\n\n# underlying amount (safe)\n\n\n@view\n@external\ndef getUnderlyingAmountSafe(_vaultToken: address, _vaultTokenBalance: uint256) -> uint256:\n    return self._getUnderlyingAmountSafe(_vaultToken, _vaultTokenBalance)\n\n\n@view\n@internal\ndef _getUnderlyingAmountSafe(_vaultToken: address, _vaultTokenBalance: uint256) -> uint256:\n    vaultInfo: ls.VaultTokenInfo = yld.vaultToAsset[_vaultToken]\n    if vaultInfo.decimals == 0:\n        return 0 # not registered\n\n    # safe underlying amount (using cached weighted average from snapshots)\n    return _vaultTokenBalance * vaultInfo.lastAveragePricePerShare // (10 ** vaultInfo.decimals)\n\n\n# underlying data (combined)\n\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> (address, uint256, uint256):\n    return self._getUnderlyingData(_vaultToken, _vaultTokenAmount, _appraiser)\n\n\n@view\n@internal\ndef _getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address) -> (address, uint256, uint256):\n    asset: address = self._getUnderlyingAsset(_vaultToken)\n    if asset == empty(address):\n        return empty(address), 0, 0 # invalid vault token\n    underlyingAmount: uint256 = self._getUnderlyingAmount(_vaultToken, _vaultTokenAmount)\n    usdValue: uint256 = self._getUsdValue(asset, underlyingAmount, _appraiser)\n    return asset, underlyingAmount, usdValue\n\n\n# usd value\n\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> uint256:\n    return self._getUsdValueOfVaultToken(_vaultToken, _vaultTokenAmount, _appraiser)\n\n\n@view\n@internal\ndef _getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address) -> uint256:\n    return self._getUnderlyingData(_vaultToken, _vaultTokenAmount, _appraiser)[2]\n\n\n@view\n@internal\ndef _getUsdValue(_asset: address, _amount: uint256, _appraiser: address) -> uint256:\n    appraiser: address = _appraiser\n    if _appraiser == empty(address):\n        appraiser = addys._getAppraiserAddr()\n    return staticcall Appraiser(appraiser).getUsdValue(_asset, _amount)\n\n\n###############\n# Other Utils #\n###############\n\n\n# basics\n\n\n@view\n@external\ndef isRebasing() -> bool:\n    return self._isRebasing()\n\n\n@view\n@internal\ndef _isRebasing() -> bool:\n    return False\n\n\n# price per share\n\n\n@view\n@external\ndef getPricePerShare(_vaultToken: address, _decimals: uint256 = 0) -> uint256:\n    decimals: uint256 = _decimals\n    if decimals == 0:\n        decimals = yld.vaultToAsset[_vaultToken].decimals\n    if decimals == 0:\n        return 0 # not registered\n    return self._getPricePerShare(_vaultToken, decimals)\n\n\n@view\n@internal\ndef _getPricePerShare(_vaultToken: address, _decimals: uint256) -> uint256:\n    return staticcall IERC4626(_vaultToken).convertToAssets(10 ** _decimals)\n\n\n# vault token amount\n\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    return staticcall IERC4626(_vaultToken).convertToShares(_assetAmount)\n\n\n# extras\n\n\n@view\n@external\ndef isEligibleVaultForTrialFunds(_vaultToken: address, _underlyingAsset: address) -> bool:\n    return False\n\n\n@view\n@external\ndef isEligibleForYieldBonus(_asset: address) -> bool:\n    return True # !\n\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    return staticcall IERC4626(_vaultToken).totalAssets()\n\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    # TODO: implement\n    return 0\n\n\n################\n# Registration #\n################\n\n\n# can vault be registered\n\n\n@view\n@external\ndef canRegisterVaultToken(_asset: address, _vaultToken: address) -> bool:\n    return self._canRegisterVaultToken(_asset, _vaultToken)\n\n\n@view\n@internal\ndef _canRegisterVaultToken(_asset: address, _vaultToken: address) -> bool:\n    if empty(address) in [_asset, _vaultToken]:\n        return False\n    if staticcall IERC4626(_vaultToken).asset() != _asset:\n        return False\n    return staticcall VaultRegistry(addys._getVaultRegistryAddr()).isEarnVault(_vaultToken)\n\n\n# register vault token locally\n\n\n@external\ndef registerVaultTokenLocally(_asset: address, _vaultAddr: address) -> ls.VaultTokenInfo:\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert self._canRegisterVaultToken(_asset, _vaultAddr) # dev: cannot register vault token\n    assert not yld._isAssetOpportunity(_asset, _vaultAddr) # dev: already registered\n    vaultInfo: ls.VaultTokenInfo = self._registerVaultTokenLocally(_asset, _vaultAddr)\n    self._registerVaultTokenGlobally(_asset, _vaultAddr, vaultInfo.decimals, addys._getLedgerAddr(), addys._getLegoBookAddr())\n    return vaultInfo\n\n\n@internal\ndef _registerVaultTokenLocally(_asset: address, _vaultAddr: address) -> ls.VaultTokenInfo:\n    assert extcall IERC20(_asset).approve(_vaultAddr, max_value(uint256), default_return_value=True) # dev: max approval failed\n    vaultInfo: ls.VaultTokenInfo = yld._addAssetOpportunity(_asset, _vaultAddr)\n    assert vaultInfo.decimals != 0 # dev: invalid vault token\n    return vaultInfo\n\n\n# remove vault token locally\n\n\n@external\ndef deregisterVaultTokenLocally(_asset: address, _vaultAddr: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert yld._isAssetOpportunity(_asset, _vaultAddr) # dev: already registered\n    self._deregisterVaultTokenLocally(_asset, _vaultAddr)\n\n\n@internal\ndef _deregisterVaultTokenLocally(_asset: address, _vaultAddr: address):\n    assert extcall IERC20(_asset).approve(_vaultAddr, 0, default_return_value=True) # dev: max approval failed\n    yld._removeAssetOpportunity(_asset, _vaultAddr)\n\n\n# ledger registration\n\n\n@internal\ndef _registerVaultTokenGlobally(_underlyingAsset: address, _vaultToken: address, _decimals: uint256, _ledger: address, _legoBook: address):\n    if not staticcall Ledger(_ledger).isRegisteredVaultToken(_vaultToken):\n        legoId: uint256 = staticcall Registry(_legoBook).getRegId(self)\n        extcall Ledger(_ledger).setVaultToken(_vaultToken, legoId, _underlyingAsset, _decimals, self._isRebasing())\n\n\n#################\n# Yield Actions #\n#################\n\n\n# add price snapshot\n\n\n@external\ndef addPriceSnapshot(_vaultToken: address) -> bool:\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    vaultInfo: ls.VaultTokenInfo = yld.vaultToAsset[_vaultToken]\n    assert vaultInfo.decimals != 0 # dev: not registered\n    pricePerShare: uint256 = self._getPricePerShare(_vaultToken, vaultInfo.decimals)\n    return yld._addPriceSnapshot(_vaultToken, pricePerShare, vaultInfo.decimals)\n\n\n# deposit\n\n\n@external\ndef depositForYield(\n    _asset: address,\n    _amount: uint256,\n    _vaultAddr: address,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, address, uint256, uint256):\n    assert not yld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = yld._getMiniAddys(_miniAddys)\n    vaultInfo: ls.VaultTokenInfo = self._getVaultInfoOnDeposit(_asset, _vaultAddr, miniAddys.ledger, miniAddys.legoBook)\n\n    # pre balances\n    preLegoBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n\n    # transfer deposit asset to this contract\n    depositAmount: uint256 = min(_amount, staticcall IERC20(_asset).balanceOf(msg.sender))\n    assert depositAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_asset).transferFrom(msg.sender, self, depositAmount, default_return_value=True) # dev: transfer failed\n\n    # deposit assets into lego partner\n    vaultTokenAmountReceived: uint256 = extcall IERC4626(_vaultAddr).deposit(depositAmount, _recipient)\n    assert vaultTokenAmountReceived != 0 # dev: no vault tokens received\n\n    # refund if full deposit didn't get through\n    currentLegoBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    refundAssetAmount: uint256 = 0\n    if currentLegoBalance > preLegoBalance:\n        refundAssetAmount = currentLegoBalance - preLegoBalance\n        assert extcall IERC20(_asset).transfer(msg.sender, refundAssetAmount, default_return_value=True) # dev: transfer failed\n        depositAmount -= refundAssetAmount\n\n    usdValue: uint256 = extcall Appraiser(miniAddys.appraiser).updatePriceAndGetUsdValue(_asset, depositAmount, miniAddys.missionControl, miniAddys.legoBook)\n    log UnderscoreEarnVaultDeposit(\n        sender = msg.sender,\n        asset = _asset,\n        vaultToken = _vaultAddr,\n        assetAmountDeposited = depositAmount,\n        usdValue = usdValue,\n        vaultTokenAmountReceived = vaultTokenAmountReceived,\n        recipient = _recipient,\n    )\n\n    # add price snapshot\n    pricePerShare: uint256 = self._getPricePerShare(_vaultAddr, vaultInfo.decimals)\n    yld._addPriceSnapshot(_vaultAddr, pricePerShare, vaultInfo.decimals)\n\n    return depositAmount, _vaultAddr, vaultTokenAmountReceived, usdValue\n\n\n# vault info on deposit\n\n\n@internal\ndef _getVaultInfoOnDeposit(_asset: address, _vaultAddr: address, _ledger: address, _legoBook: address) -> ls.VaultTokenInfo:\n    vaultInfo: ls.VaultTokenInfo = yld.vaultToAsset[_vaultAddr]\n    if vaultInfo.decimals == 0:\n        assert self._canRegisterVaultToken(_asset, _vaultAddr) # dev: cannot register vault token\n        vaultInfo = self._registerVaultTokenLocally(_asset, _vaultAddr)\n        self._registerVaultTokenGlobally(_asset, _vaultAddr, vaultInfo.decimals, _ledger, _legoBook)\n    else:\n        assert vaultInfo.underlyingAsset == _asset # dev: asset mismatch\n    return vaultInfo\n\n\n# withdraw\n\n\n@external\ndef withdrawFromYield(\n    _vaultToken: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, address, uint256, uint256):\n    assert not yld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = yld._getMiniAddys(_miniAddys)\n    vaultInfo: ls.VaultTokenInfo = self._getVaultInfoOnWithdrawal(_vaultToken, miniAddys.ledger, miniAddys.legoBook)\n\n    # pre balances\n    preLegoVaultBalance: uint256 = staticcall IERC20(_vaultToken).balanceOf(self)\n\n    # transfer vaults tokens to this contract\n    vaultTokenAmount: uint256 = min(_amount, staticcall IERC20(_vaultToken).balanceOf(msg.sender))\n    assert vaultTokenAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_vaultToken).transferFrom(msg.sender, self, vaultTokenAmount, default_return_value=True) # dev: transfer failed\n\n    # withdraw assets from lego partner\n    assetAmountReceived: uint256 = extcall IERC4626(_vaultToken).redeem(vaultTokenAmount, _recipient, self)\n    assert assetAmountReceived != 0 # dev: no asset amount received\n\n    # refund if full withdrawal didn't happen\n    currentLegoVaultBalance: uint256 = staticcall IERC20(_vaultToken).balanceOf(self)\n    refundVaultTokenAmount: uint256 = 0\n    if currentLegoVaultBalance > preLegoVaultBalance:\n        refundVaultTokenAmount = currentLegoVaultBalance - preLegoVaultBalance\n        assert extcall IERC20(_vaultToken).transfer(msg.sender, refundVaultTokenAmount, default_return_value=True) # dev: transfer failed\n        vaultTokenAmount -= refundVaultTokenAmount\n\n    usdValue: uint256 = extcall Appraiser(miniAddys.appraiser).updatePriceAndGetUsdValue(vaultInfo.underlyingAsset, assetAmountReceived, miniAddys.missionControl, miniAddys.legoBook)\n    log UnderscoreEarnVaultWithdrawal(\n        sender = msg.sender,\n        asset = vaultInfo.underlyingAsset,\n        vaultToken = _vaultToken,\n        assetAmountReceived = assetAmountReceived,\n        usdValue = usdValue,\n        vaultTokenAmountBurned = vaultTokenAmount,\n        recipient = _recipient,\n    )\n\n    # add price snapshot\n    pricePerShare: uint256 = self._getPricePerShare(_vaultToken, vaultInfo.decimals)\n    yld._addPriceSnapshot(_vaultToken, pricePerShare, vaultInfo.decimals)\n\n    return vaultTokenAmount, vaultInfo.underlyingAsset, assetAmountReceived, usdValue\n\n\n# vault info on withdrawal\n\n\n@internal\ndef _getVaultInfoOnWithdrawal(_vaultAddr: address, _ledger: address, _legoBook: address) -> ls.VaultTokenInfo:\n    vaultInfo: ls.VaultTokenInfo = yld.vaultToAsset[_vaultAddr]\n    if vaultInfo.decimals == 0:\n        asset: address = staticcall IERC4626(_vaultAddr).asset()\n        assert self._canRegisterVaultToken(asset, _vaultAddr) # dev: cannot register vault token\n        vaultInfo = self._registerVaultTokenLocally(asset, _vaultAddr)\n        self._registerVaultTokenGlobally(asset, _vaultAddr, vaultInfo.decimals, _ledger, _legoBook)\n    return vaultInfo\n\n\n##############\n# Claim Loot #\n##############\n\n\n@external\ndef claimRewards(\n    _user: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _extraData: bytes32,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    assert staticcall Ledger(addys._getLedgerAddr()).isUserWallet(msg.sender) # dev: not a user wallet\n    assert msg.sender == _user # dev: recipient must be caller\n\n    lootDistributor: address = addys._getLootDistributorAddr()\n\n    # rev share and loot bonus\n    totalClaimableAssets: uint256 = staticcall LootDistributor(lootDistributor).getTotalClaimableAssets(_user)\n    if totalClaimableAssets != 0:\n        extcall LootDistributor(lootDistributor).claimRevShareAndBonusLoot(_user)\n\n    # deposit rewards\n    depositRewards: uint256 = staticcall LootDistributor(lootDistributor).getClaimableDepositRewards(_user)\n    if depositRewards != 0:\n        depositRewards = extcall LootDistributor(lootDistributor).claimDepositRewards(_user)\n\n    usdValue: uint256 = extcall Appraiser(addys._getAppraiserAddr()).updatePriceAndGetUsdValue(_rewardToken, depositRewards)\n    if _rewardToken == RIPE_TOKEN:\n        return 0, usdValue\n    return depositRewards, usdValue\n\n\n@view\n@external\ndef hasClaimableRewards(_user: address) -> bool:\n    lootDistributor: address = addys._getLootDistributorAddr()\n    totalClaimableAssets: uint256 = staticcall LootDistributor(lootDistributor).getTotalClaimableAssets(_user)\n    if totalClaimableAssets != 0:\n        return True\n    depositRewards: uint256 = staticcall LootDistributor(lootDistributor).getClaimableDepositRewards(_user)\n    return depositRewards != 0\n\n\n#########\n# Other #\n#########\n\n\n@view\n@external\ndef getAccessForLego(_user: address, _action: ws.ActionType) -> (address, String[64], uint256):\n    return empty(address), empty(String[64]), 0\n\n\n@external\ndef swapTokens(\n    _amountIn: uint256,\n    _minAmountOut: uint256,\n    _tokenPath: DynArray[address, MAX_TOKEN_PATH],\n    _poolPath: DynArray[address, MAX_TOKEN_PATH - 1],\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256):\n    return 0, 0, 0\n\n\n@external\ndef mintOrRedeemAsset(\n    _tokenIn: address,\n    _tokenOut: address,\n    _tokenInAmount: uint256,\n    _minAmountOut: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, bool, uint256):\n    return 0, 0, False, 0\n\n\n@external\ndef confirmMintOrRedeemAsset(\n    _tokenIn: address,\n    _tokenOut: address,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef addCollateral(\n    _asset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef removeCollateral(\n    _asset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef borrow(\n    _borrowAsset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef repayDebt(\n    _paymentAsset: address,\n    _paymentAmount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef addLiquidity(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _amountA: uint256,\n    _amountB: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _minLpAmount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (address, uint256, uint256, uint256, uint256):\n    return empty(address), 0, 0, 0, 0\n\n\n@external\ndef removeLiquidity(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpToken: address,\n    _lpAmount: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, uint256):\n    return 0, 0, 0, 0\n\n\n@external\ndef addLiquidityConcentrated(\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _tickLower: int24,\n    _tickUpper: int24,\n    _amountA: uint256,\n    _amountB: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, uint256, uint256):\n    return 0, 0, 0, 0, 0\n\n\n@external\ndef removeLiquidityConcentrated(\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _liqToRemove: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, bool, uint256):\n    return 0, 0, 0, False, 0",
            "sha256sum": "f64b6e48410b5903f6d1ca94a29f51bac3215dcea0c41d026f44469ba43dd255"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/legos/UnderscoreLego.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.3+commit.bff19ea2",
        "integrity": "58027a8da664bf3150c548d706365ac82824f03dad49f7ca13b581d14bc50539"
      },
      "args": "00000000000000000000000044cf3c4f000dfd76a35d03298049d37be688d6f90000000000000000000000002a0a59d6b975828e781ecac125dba40d7ee5ddc0",
      "file": "contracts/legos/UnderscoreLego.vy"
    },
    "40Acres": {
      "address": "0x5F100f56C8A0560425B5983677309A21d15d5Fcd",
      "abi": [
        {
          "name": "FortyAcresDeposit",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountDeposited",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultTokenAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "FortyAcresWithdrawal",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultTokenAmountBurned",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LegoPauseModified",
          "inputs": [
            {
              "name": "isPaused",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LegoFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "balance",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "SnapShotPriceConfigSet",
          "inputs": [
            {
              "name": "minSnapshotDelay",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "maxNumSnapshots",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "maxUpsideDeviation",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "staleTime",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetOpportunityAdded",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultAddr",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetOpportunityRemoved",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultAddr",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PricePerShareSnapShotAdded",
          "inputs": [
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "totalSupply",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "pricePerShare",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddys",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "undyToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "hatchery",
                  "type": "address"
                },
                {
                  "name": "lootDistributor",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                },
                {
                  "name": "walletBackpack",
                  "type": "address"
                },
                {
                  "name": "billing",
                  "type": "address"
                },
                {
                  "name": "vaultRegistry",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUndyHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isLegoAsset",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssetOpportunities",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isAssetOpportunity",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getNumLegoAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pause",
          "inputs": [
            {
              "name": "_shouldPause",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFundsMany",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_assets",
              "type": "address[]"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getWeightedPricePerShare",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLatestSnapshot",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_pricePerShare",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "totalSupply",
                  "type": "uint256"
                },
                {
                  "name": "pricePerShare",
                  "type": "uint256"
                },
                {
                  "name": "lastUpdate",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setSnapShotPriceConfig",
          "inputs": [
            {
              "name": "_config",
              "type": "tuple",
              "components": [
                {
                  "name": "minSnapshotDelay",
                  "type": "uint256"
                },
                {
                  "name": "maxNumSnapshots",
                  "type": "uint256"
                },
                {
                  "name": "maxUpsideDeviation",
                  "type": "uint256"
                },
                {
                  "name": "staleTime",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidPriceConfig",
          "inputs": [
            {
              "name": "_config",
              "type": "tuple",
              "components": [
                {
                  "name": "minSnapshotDelay",
                  "type": "uint256"
                },
                {
                  "name": "maxNumSnapshots",
                  "type": "uint256"
                },
                {
                  "name": "maxUpsideDeviation",
                  "type": "uint256"
                },
                {
                  "name": "staleTime",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "vaultToAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "underlyingAsset",
                  "type": "address"
                },
                {
                  "name": "decimals",
                  "type": "uint256"
                },
                {
                  "name": "lastAveragePricePerShare",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assetOpportunities",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAssetOpportunity",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssetOpportunities",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assets",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "snapShotData",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "lastSnapShot",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "totalSupply",
                      "type": "uint256"
                    },
                    {
                      "name": "pricePerShare",
                      "type": "uint256"
                    },
                    {
                      "name": "lastUpdate",
                      "type": "uint256"
                    }
                  ]
                },
                {
                  "name": "nextIndex",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "snapShots",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "totalSupply",
                  "type": "uint256"
                },
                {
                  "name": "pricePerShare",
                  "type": "uint256"
                },
                {
                  "name": "lastUpdate",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "snapShotPriceConfig",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "minSnapshotDelay",
                  "type": "uint256"
                },
                {
                  "name": "maxNumSnapshots",
                  "type": "uint256"
                },
                {
                  "name": "maxUpsideDeviation",
                  "type": "uint256"
                },
                {
                  "name": "staleTime",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isPaused",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasCapability",
          "inputs": [
            {
              "name": "_action",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRegistries",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isYieldLego",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isDexLego",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAsset",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingBalances",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenBalance",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAmount",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAmountSafe",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenBalance",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingData",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingData",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            },
            {
              "name": "_appraiser",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValueOfVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValueOfVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            },
            {
              "name": "_appraiser",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isRebasing",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPricePerShare",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPricePerShare",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_decimals",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getVaultTokenAmount",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_assetAmount",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isEligibleVaultForTrialFunds",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_underlyingAsset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isEligibleForYieldBonus",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalAssets",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalBorrows",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canRegisterVaultToken",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "registerVaultTokenLocally",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "underlyingAsset",
                  "type": "address"
                },
                {
                  "name": "decimals",
                  "type": "uint256"
                },
                {
                  "name": "lastAveragePricePerShare",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "deregisterVaultTokenLocally",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addPriceSnapshot",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositForYield",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositForYield",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawFromYield",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawFromYield",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAccessForLego",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_action",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "string"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasClaimableRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_tokenPath",
              "type": "address[]"
            },
            {
              "name": "_poolPath",
              "type": "address[]"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_tokenPath",
              "type": "address[]"
            },
            {
              "name": "_poolPath",
              "type": "address[]"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_tokenInAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_tokenInAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmMintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmMintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_borrowAsset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_borrowAsset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_paymentAsset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_paymentAsset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "FORTY_ACRES_USDC_VAULT",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_undyHq",
              "type": "address"
            },
            {
              "name": "_fortyAcresVault",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "interfaces/WalletStructs.vyi": {
            "content": "# @version 0.4.3\n\nflag ActionType:\n    TRANSFER\n    EARN_DEPOSIT\n    EARN_WITHDRAW\n    EARN_REBALANCE\n    SWAP\n    MINT_REDEEM\n    CONFIRM_MINT_REDEEM\n    ADD_COLLATERAL\n    REMOVE_COLLATERAL\n    BORROW\n    REPAY_DEBT\n    REWARDS\n    ETH_TO_WETH\n    WETH_TO_ETH\n    ADD_LIQ\n    REMOVE_LIQ\n    ADD_LIQ_CONC\n    REMOVE_LIQ_CONC\n    PAY_CHEQUE\n\nstruct WalletAssetData:\n    assetBalance: uint256\n    usdValue: uint256\n    isYieldAsset: bool\n    lastPricePerShare: uint256\n\nstruct ActionData:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    billing: address\n    wallet: address\n    walletConfig: address\n    walletOwner: address\n    inEjectMode: bool\n    isFrozen: bool\n    lastTotalUsdValue: uint256\n    signer: address\n    isManager: bool\n    legoId: uint256\n    legoAddr: address\n    eth: address\n    weth: address\n\nstruct MiniAddys:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    appraiser: address",
            "sha256sum": "9a4b4f59b3a62043e51b425a665064aae419a3c0bd0514b6b29a9441ae364bb9"
          },
          "interfaces/LegoPartner.vyi": {
            "content": "# @version 0.4.3\n\nfrom interfaces import WalletStructs as ws\n\nMAX_TOKEN_PATH: constant(uint256) = 5\nMAX_RECOVER_ASSETS: constant(uint256) = 20\n\n@external\ndef addLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _tickLower: int24, _tickUpper: int24, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef addLiquidity(_pool: address, _tokenA: address, _tokenB: address, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _minLpAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (address, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef removeLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _liqToRemove: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef removeLiquidity(_pool: address, _tokenA: address, _tokenB: address, _lpToken: address, _lpAmount: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef mintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _tokenInAmount: uint256, _minAmountOut: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef swapTokens(_amountIn: uint256, _minAmountOut: uint256, _tokenPath: DynArray[address, MAX_TOKEN_PATH], _poolPath: DynArray[address, MAX_TOKEN_PATH - 1], _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256):\n    ...\n\n@external\ndef depositForYield(_asset: address, _amount: uint256, _vaultAddr: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef withdrawFromYield(_vaultToken: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef confirmMintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef borrow(_borrowAsset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef repayDebt(_paymentAsset: address, _paymentAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef claimRewards(_user: address, _rewardToken: address, _rewardAmount: uint256, _extraData: bytes32, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef removeCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef addCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@view\n@external\ndef getAccessForLego(_user: address, _action: ws.ActionType) -> (address, String[64], uint256):\n    ...\n\n@view\n@external\ndef hasCapability(_action: ws.ActionType) -> bool:\n    ...\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    ...\n\n@view\n@external\ndef isYieldLego() -> bool:\n    ...\n\n@view\n@external\ndef isDexLego() -> bool:\n    ...\n\n\n# common\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "81db71fe4440a3b4b563134c9b5caf1d5705772a5f291fe874c9b5fb3cfb1623"
          },
          "interfaces/LegoStructs.vyi": {
            "content": "# @version 0.4.3\n\nstruct VaultTokenInfo:\n    underlyingAsset: address\n    decimals: uint256\n    lastAveragePricePerShare: uint256\n\nstruct SnapShotPriceConfig:\n    minSnapshotDelay: uint256\n    maxNumSnapshots: uint256\n    maxUpsideDeviation: uint256\n    staleTime: uint256\n\nstruct SingleSnapShot:\n    totalSupply: uint256\n    pricePerShare: uint256\n    lastUpdate: uint256\n\nstruct SnapShotData:\n    lastSnapShot: SingleSnapShot\n    nextIndex: uint256\n",
            "sha256sum": "8ae48be17d812d57fbd671bbf0593e8abf175ad0924e47c5997823cac19ec806"
          },
          "interfaces/YieldLego.vyi": {
            "content": "# @version 0.4.3\n\nfrom interfaces import LegoStructs as ls\n\n\n###################\n# Underlying Data #\n###################\n\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    ...\n\n\n@view\n@external\ndef getUnderlyingBalances(_vaultToken: address, _vaultTokenBalance: uint256) -> (uint256, uint256):\n    ...\n\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    ...\n\n\n@view\n@external\ndef getUnderlyingAmountSafe(_vaultToken: address, _vaultTokenBalance: uint256) -> uint256:\n    ...\n\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> (address, uint256, uint256):\n    ...\n\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> uint256:\n    ...\n\n\n###############\n# Other Utils #\n###############\n\n\n@view\n@external\ndef isRebasing() -> bool:\n    ...\n\n\n@view\n@external\ndef getPricePerShare(_vaultToken: address, _decimals: uint256 = 0) -> uint256:\n    ...\n\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef canRegisterVaultToken(_asset: address, _vaultToken: address) -> bool:\n    ...\n\n\n@view\n@external\ndef isEligibleVaultForTrialFunds(_vaultToken: address, _underlyingAsset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef isEligibleForYieldBonus(_asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    ...\n\n\n###################\n# Yield Lego Data #\n###################\n\n\n@view\n@external\ndef isLegoAsset(_asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, 40]:\n    ...\n\n\n@view\n@external\ndef getAssets() -> DynArray[address, 20]:\n    ...\n\n\n@view\n@external\ndef isAssetOpportunity(_asset: address, _vaultAddr: address) -> bool:\n    ...\n\n\n@view\n@external\ndef getNumLegoAssets() -> uint256:\n    ...\n\n\n@view\n@external\ndef assets(_index: uint256) -> address:\n    ...\n\n\n@view\n@external\ndef indexOfAsset(_asset: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef numAssets() -> uint256:\n    ...\n\n\n@view\n@external\ndef assetOpportunities(_asset: address, _index: uint256) -> address:\n    ...\n\n\n@view\n@external\ndef indexOfAssetOpportunity(_asset: address, _vaultAddr: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef numAssetOpportunities(_asset: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef vaultToAsset(_vaultAddr: address) -> ls.VaultTokenInfo:\n    ...\n\n\n# price snapshots\n\n\n@external\ndef addPriceSnapshot(_vaultToken: address) -> bool:\n    ...\n\n\n@view\n@external\ndef snapShotPriceConfig() -> ls.SnapShotPriceConfig:\n    ...\n\n\n@view\n@external\ndef snapShotData(_vaultToken: address) -> ls.SnapShotData:\n    ...\n\n\n@view\n@external\ndef snapShots(_vaultToken: address, _index: uint256) -> ls.SingleSnapShot:\n    ...\n\n\n@view\n@external\ndef getWeightedPricePerShare(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef getLatestSnapshot(_vaultToken: address, _pricePerShare: uint256) -> ls.SingleSnapShot:\n    ...\n\n\n@external\ndef setSnapShotPriceConfig(_config: ls.SnapShotPriceConfig):\n    ...\n",
            "sha256sum": "045a6bbd3d556234cf4fe925a303002dc0ac3c482d344ffbaf4bc52a7e6ad2df"
          },
          "contracts/modules/Addys.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\ninterface UndyHq:\n    def isValidAddr(_addr: address) -> bool: view\n    def getAddr(_regId: uint256) -> address: view\n    def undyToken() -> address: view\n\ninterface Switchboard:\n    def isSwitchboardAddr(_addr: address) -> bool: view\n\ninterface LegoBook:\n    def isLegoAddr(_addr: address) -> bool: view\n\nstruct Addys:\n    hq: address\n    undyToken: address\n    ledger: address\n    missionControl: address\n    legoBook: address\n    switchboard: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    walletBackpack: address\n    billing: address\n    vaultRegistry: address\n\n# hq\nUNDY_HQ_FOR_ADDYS: immutable(address)\n\n# core addys\nLEDGER_ID: constant(uint256) = 1\nMISSION_CONTROL_ID: constant(uint256) = 2\nLEGO_BOOK_ID: constant(uint256) = 3\nSWITCHBOARD_ID: constant(uint256) = 4\nHATCHERY_ID: constant(uint256) = 5\nLOOT_DISTRIBUTOR_ID: constant(uint256) = 6\nAPPRAISER_ID: constant(uint256) = 7\nWALLET_BACKPACK_ID: constant(uint256) = 8\nBILLING_ID: constant(uint256) = 9\nVAULT_REGISTRY_ID: constant(uint256) = 10\n\n\n@deploy\ndef __init__(_undyHq: address):\n    assert _undyHq != empty(address) # dev: invalid undy hq\n    UNDY_HQ_FOR_ADDYS = _undyHq\n\n\n########\n# Core #\n########\n\n\n@view\n@external\ndef getAddys() -> Addys:\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _getAddys(_addys: Addys = empty(Addys)) -> Addys:\n    if _addys.hq != empty(address):\n        return _addys\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _generateAddys() -> Addys:\n    hq: address = UNDY_HQ_FOR_ADDYS\n    return Addys(\n        hq = hq,\n        undyToken = staticcall UndyHq(hq).undyToken(),\n        ledger = staticcall UndyHq(hq).getAddr(LEDGER_ID),\n        missionControl = staticcall UndyHq(hq).getAddr(MISSION_CONTROL_ID),\n        legoBook = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID),\n        switchboard = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID),\n        hatchery = staticcall UndyHq(hq).getAddr(HATCHERY_ID),\n        lootDistributor = staticcall UndyHq(hq).getAddr(LOOT_DISTRIBUTOR_ID),\n        appraiser = staticcall UndyHq(hq).getAddr(APPRAISER_ID),\n        walletBackpack = staticcall UndyHq(hq).getAddr(WALLET_BACKPACK_ID),\n        billing = staticcall UndyHq(hq).getAddr(BILLING_ID),\n        vaultRegistry = staticcall UndyHq(hq).getAddr(VAULT_REGISTRY_ID),\n    )\n\n\n##########\n# Tokens #\n##########\n\n\n@view\n@internal\ndef _getUndyToken() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).undyToken()\n\n\n###########\n# Helpers #\n###########\n\n\n# undy hq\n\n\n@view\n@external\ndef getUndyHq() -> address:\n    return self._getUndyHq()\n\n\n@view\n@internal\ndef _getUndyHq() -> address:\n    return UNDY_HQ_FOR_ADDYS\n\n\n# utils\n\n\n@view\n@internal\ndef _isValidUndyAddr(_addr: address, _hq: address = empty(address)) -> bool:\n    hq: address = _hq\n    if _hq == empty(address):\n        hq = UNDY_HQ_FOR_ADDYS\n    \n    # core departments\n    if staticcall UndyHq(hq).isValidAddr(_addr):\n        return True\n\n    # lego book\n    legoBook: address = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID)\n    if legoBook != empty(address) and staticcall LegoBook(legoBook).isLegoAddr(_addr):\n        return True\n\n    # switchboard config\n    switchboard: address = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID)\n    if switchboard != empty(address) and staticcall Switchboard(switchboard).isSwitchboardAddr(_addr):\n        return True\n\n    return False\n\n\n@view\n@internal\ndef _isSwitchboardAddr(_addr: address) -> bool:\n    switchboard: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n    if switchboard == empty(address):\n        return False\n    return staticcall Switchboard(switchboard).isSwitchboardAddr(_addr)\n\n\n@view\n@internal\ndef _isLegoBookAddr(_addr: address) -> bool:\n    legoBook: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n    if legoBook == empty(address):\n        return False\n    return staticcall LegoBook(legoBook).isLegoAddr(_addr)\n\n\n###############\n# Departments #\n###############\n\n\n# ledger\n\n\n@view\n@internal\ndef _getLedgerId() -> uint256:\n    return LEDGER_ID\n\n\n@view\n@internal\ndef _getLedgerAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEDGER_ID)\n\n\n# mission control\n\n\n@view\n@internal\ndef _getMissionControlId() -> uint256:\n    return MISSION_CONTROL_ID\n\n\n@view\n@internal\ndef _getMissionControlAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(MISSION_CONTROL_ID)\n\n\n# lego book\n\n\n@view\n@internal\ndef _getLegoBookId() -> uint256:\n    return LEGO_BOOK_ID\n\n\n@view\n@internal\ndef _getLegoBookAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n\n\n# switchboard\n\n\n@view\n@internal\ndef _getSwitchboardId() -> uint256:\n    return SWITCHBOARD_ID\n\n\n@view\n@internal\ndef _getSwitchboardAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n\n\n# hatchery\n\n\n@view\n@internal\ndef _getHatcheryId() -> uint256:\n    return HATCHERY_ID\n\n\n@view\n@internal\ndef _getHatcheryAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(HATCHERY_ID)\n\n\n# loot distributor\n\n\n@view\n@internal\ndef _getLootDistributorId() -> uint256:\n    return LOOT_DISTRIBUTOR_ID\n\n\n@view\n@internal\ndef _getLootDistributorAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LOOT_DISTRIBUTOR_ID)\n\n\n# appraiser\n\n\n@view\n@internal\ndef _getAppraiserId() -> uint256:\n    return APPRAISER_ID\n\n\n@view\n@internal\ndef _getAppraiserAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(APPRAISER_ID)\n\n\n# wallet backpack\n\n\n@view\n@internal\ndef _getWalletBackpackId() -> uint256:\n    return WALLET_BACKPACK_ID\n\n\n@view\n@internal\ndef _getWalletBackpackAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(WALLET_BACKPACK_ID)\n\n\n# billing\n\n\n@view\n@internal\ndef _getBillingId() -> uint256:\n    return BILLING_ID\n\n\n@view\n@internal\ndef _getBillingAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(BILLING_ID)\n\n\n# vault registry\n\n\n@view\n@internal\ndef _getVaultRegistryId() -> uint256:\n    return VAULT_REGISTRY_ID\n\n\n@view\n@internal\ndef _getVaultRegistryAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(VAULT_REGISTRY_ID)",
            "sha256sum": "4df6b72db9bb417d1af81660175be1450cfb7b3575f3d17a5b8a130bff87b781"
          },
          "contracts/modules/YieldLegoData.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nuses: addys\n\nimport contracts.modules.Addys as addys\n\nfrom interfaces import WalletStructs as ws\nfrom interfaces import LegoStructs as ls\nfrom ethereum.ercs import IERC20\nfrom ethereum.ercs import IERC20Detailed\n\nevent AssetOpportunityAdded:\n    asset: indexed(address)\n    vaultAddr: indexed(address)\n\nevent AssetOpportunityRemoved:\n    asset: indexed(address)\n    vaultAddr: indexed(address)\n\nevent LegoPauseModified:\n    isPaused: bool\n\nevent LegoFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    balance: uint256\n\nevent PricePerShareSnapShotAdded:\n    vaultToken: indexed(address)\n    totalSupply: uint256\n    pricePerShare: uint256\n\nevent SnapShotPriceConfigSet:\n    minSnapshotDelay: uint256\n    maxNumSnapshots: uint256\n    maxUpsideDeviation: uint256\n    staleTime: uint256\n\n# core\nvaultToAsset: public(HashMap[address, ls.VaultTokenInfo]) # vault addr -> data\n\n# asset opportunities\nassetOpportunities: public(HashMap[address, HashMap[uint256, address]]) # asset -> index -> vault addr\nindexOfAssetOpportunity: public(HashMap[address, HashMap[address, uint256]]) # asset -> vault addr -> index\nnumAssetOpportunities: public(HashMap[address, uint256]) # asset -> number of opportunities\n\n# lego assets (iterable)\nassets: public(HashMap[uint256, address]) # index -> asset\nindexOfAsset: public(HashMap[address, uint256]) # asset -> index\nnumAssets: public(uint256) # num assets\n\n# price snapshots\nsnapShotData: public(HashMap[address, ls.SnapShotData]) # vault token -> data\nsnapShots: public(HashMap[address, HashMap[uint256, ls.SingleSnapShot]]) # vault token -> index -> snapshot\nsnapShotPriceConfig: public(ls.SnapShotPriceConfig) # config\n\nisPaused: public(bool)\n\nMAX_VAULTS: constant(uint256) = 40\nMAX_ASSETS: constant(uint256) = 20\nMAX_RECOVER_ASSETS: constant(uint256) = 20\nONE_DAY_SECONDS: constant(uint256) = 60 * 60 * 24\nONE_WEEK_SECONDS: constant(uint256) = ONE_DAY_SECONDS * 7\nHUNDRED_PERCENT: constant(uint256) = 100_00\n\n\n@deploy\ndef __init__(_shouldPause: bool):\n    self.isPaused = _shouldPause\n    self.numAssets = 1 # not using 0 index\n\n    # default snapshot price config\n    self.snapShotPriceConfig = ls.SnapShotPriceConfig(\n        minSnapshotDelay = 60 * 10, # 10 minutes\n        maxNumSnapshots = 20,\n        maxUpsideDeviation = 10_00, # 10%\n        staleTime = 3 * ONE_DAY_SECONDS, # 3 days\n    )\n\n\n#########\n# Views #\n#########\n\n\n# is lego asset\n\n\n@view\n@external\ndef isLegoAsset(_asset: address) -> bool:\n    return self._isLegoAsset(_asset)\n\n\n@view\n@internal\ndef _isLegoAsset(_asset: address) -> bool:\n    return self.indexOfAsset[_asset] != 0\n\n\n# vault opportunities\n\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, MAX_VAULTS]:\n    numOpportunities: uint256 = self.numAssetOpportunities[_asset]\n    if numOpportunities == 0:\n        return []\n    opportunities: DynArray[address, MAX_VAULTS] = []\n    for i: uint256 in range(1, numOpportunities, bound=MAX_VAULTS):\n        opportunities.append(self.assetOpportunities[_asset][i])\n    return opportunities\n\n\n# all assets registered\n\n\n@view\n@external\ndef getAssets() -> DynArray[address, MAX_ASSETS]:\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return []\n    assets: DynArray[address, MAX_ASSETS] = []\n    for i: uint256 in range(1, numAssets, bound=MAX_ASSETS):\n        assets.append(self.assets[i])\n    return assets\n\n\n################\n# Registration #\n################\n\n\n@view\n@external\ndef isAssetOpportunity(_asset: address, _vaultAddr: address) -> bool:\n    return self._isAssetOpportunity(_asset, _vaultAddr)\n\n\n@view\n@internal\ndef _isAssetOpportunity(_asset: address, _vaultAddr: address) -> bool:\n    return self.indexOfAssetOpportunity[_asset][_vaultAddr] != 0\n\n\n# add asset opportunity\n\n\n@internal\ndef _addAssetOpportunity(_asset: address, _vaultAddr: address) -> ls.VaultTokenInfo:\n    if self.indexOfAssetOpportunity[_asset][_vaultAddr] != 0:\n        return self.vaultToAsset[_vaultAddr]\n\n    if empty(address) in [_asset, _vaultAddr]:\n        return empty(ls.VaultTokenInfo)\n\n    # add asset opportunity\n    aid: uint256 = self.numAssetOpportunities[_asset]\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.assetOpportunities[_asset][aid] = _vaultAddr\n    self.indexOfAssetOpportunity[_asset][_vaultAddr] = aid\n    self.numAssetOpportunities[_asset] = aid + 1\n\n    # add mapping\n    vaultInfo: ls.VaultTokenInfo = ls.VaultTokenInfo(\n        underlyingAsset = _asset,\n        decimals = convert(staticcall IERC20Detailed(_vaultAddr).decimals(), uint256),\n        lastAveragePricePerShare = 0,\n    )\n    self.vaultToAsset[_vaultAddr] = vaultInfo\n\n    # add asset\n    self._addAsset(_asset)\n\n    log AssetOpportunityAdded(asset=_asset, vaultAddr=_vaultAddr)\n    return vaultInfo\n\n\n# remove asset opportunity\n\n\n@internal\ndef _removeAssetOpportunity(_asset: address, _vaultAddr: address):\n    numOpportunities: uint256 = self.numAssetOpportunities[_asset]\n    if numOpportunities == 0:\n        return\n\n    targetIndex: uint256 = self.indexOfAssetOpportunity[_asset][_vaultAddr]\n    if targetIndex == 0:\n        return\n\n    # update data\n    lastIndex: uint256 = numOpportunities - 1\n    self.numAssetOpportunities[_asset] = lastIndex\n    self.indexOfAssetOpportunity[_asset][_vaultAddr] = 0\n\n    self.vaultToAsset[_vaultAddr] = empty(ls.VaultTokenInfo)\n\n    # shift to replace the removed one\n    if targetIndex != lastIndex:\n        lastVaultAddr: address = self.assetOpportunities[_asset][lastIndex]\n        self.assetOpportunities[_asset][targetIndex] = lastVaultAddr\n        self.indexOfAssetOpportunity[_asset][lastVaultAddr] = targetIndex\n\n    # remove asset\n    if lastIndex <= 1:\n        self._removeAsset(_asset)\n\n    log AssetOpportunityRemoved(asset=_asset, vaultAddr=_vaultAddr)\n\n\n# add asset\n\n\n@internal\ndef _addAsset(_asset: address):\n    if self.indexOfAsset[_asset] != 0:\n        return\n\n    aid: uint256 = self.numAssets\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.assets[aid] = _asset\n    self.indexOfAsset[_asset] = aid\n    self.numAssets = aid + 1\n\n\n# remove asset\n\n\n@internal\ndef _removeAsset(_asset: address):\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return\n\n    targetIndex: uint256 = self.indexOfAsset[_asset]\n    if targetIndex == 0:\n        return\n\n    # update data\n    lastIndex: uint256 = numAssets - 1\n    self.numAssets = lastIndex\n    self.indexOfAsset[_asset] = 0\n\n    # shift to replace the removed one\n    if targetIndex != lastIndex:\n        lastAsset: address = self.assets[lastIndex]\n        self.assets[targetIndex] = lastAsset\n        self.indexOfAsset[lastAsset] = targetIndex\n\n\n# num lego assets (true number, use `numAssets` for iteration)\n\n\n@view\n@external\ndef getNumLegoAssets() -> uint256:\n    return self._getNumLegoAssets()\n\n\n@view\n@internal\ndef _getNumLegoAssets() -> uint256:\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return 0\n    return numAssets - 1\n\n\n###########\n# General #\n###########\n\n\n# fill mini addys\n\n\n@view\n@internal\ndef _getMiniAddys(_miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> ws.MiniAddys:\n    if _miniAddys.ledger != empty(address):\n        return _miniAddys\n    return ws.MiniAddys(\n        ledger = addys._getLedgerAddr(),\n        missionControl = addys._getMissionControlAddr(),\n        legoBook = addys._getLegoBookAddr(),\n        appraiser = addys._getAppraiserAddr(),\n    )\n\n\n# activate\n\n\n@external\ndef pause(_shouldPause: bool):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert _shouldPause != self.isPaused # dev: no change\n    self.isPaused = _shouldPause\n    log LegoPauseModified(isPaused=_shouldPause)\n\n\n# recover funds\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    self._recoverFunds(_recipient, _asset)\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, MAX_RECOVER_ASSETS]):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    for a: address in _assets:\n        self._recoverFunds(_recipient, a)\n\n\n@internal\ndef _recoverFunds(_recipient: address, _asset: address):\n    assert empty(address) not in [_recipient, _asset] # dev: invalid recipient or asset\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    assert balance != 0 # dev: nothing to recover\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log LegoFundsRecovered(asset=_asset, recipient=_recipient, balance=balance)\n\n\n###################\n# Price Snapshots #\n###################\n\n\n# add price snapshot\n\n\n@internal\ndef _addPriceSnapshot(_vaultToken: address, _pricePerShare: uint256, _vaultTokenDecimals: uint256) -> bool:\n    config: ls.SnapShotPriceConfig = self.snapShotPriceConfig\n    if config.maxNumSnapshots == 0:\n        return False\n\n    data: ls.SnapShotData = self.snapShotData[_vaultToken]\n\n    # already have snapshot for this time\n    if data.lastSnapShot.lastUpdate == block.timestamp:\n        return False\n\n    # check if snapshot is too recent\n    if data.lastSnapShot.lastUpdate + config.minSnapshotDelay > block.timestamp:\n        return False\n\n    # create and store new snapshot\n    newSnapshot: ls.SingleSnapShot = self._getLatestSnapshot(_vaultToken, _pricePerShare, _vaultTokenDecimals, data.lastSnapShot, config)\n    data.lastSnapShot = newSnapshot\n    self.snapShots[_vaultToken][data.nextIndex] = newSnapshot\n\n    # update index\n    data.nextIndex += 1\n    if data.nextIndex >= config.maxNumSnapshots:\n        data.nextIndex = 0\n\n    # save snap shot data\n    self.snapShotData[_vaultToken] = data\n\n    # update cached weighted average price per share\n    self.vaultToAsset[_vaultToken].lastAveragePricePerShare = self._getWeightedPricePerShare(_vaultToken, _pricePerShare)\n\n    log PricePerShareSnapShotAdded(\n        vaultToken = _vaultToken,\n        totalSupply = newSnapshot.totalSupply,\n        pricePerShare = newSnapshot.pricePerShare,\n    )\n    return True\n\n\n# weighted price per share\n\n\n@view\n@external\ndef getWeightedPricePerShare(_vaultToken: address) -> uint256:\n    data: ls.SnapShotData = self.snapShotData[_vaultToken]\n    return self._getWeightedPricePerShare(_vaultToken, data.lastSnapShot.pricePerShare)\n\n\n@view\n@internal\ndef _getWeightedPricePerShare(_vaultToken: address, _lastPricePerShare: uint256) -> uint256:\n    config: ls.SnapShotPriceConfig = self.snapShotPriceConfig\n    if config.maxNumSnapshots == 0:\n        return 0\n\n    # calculate weighted average price using all valid snapshots\n    numerator: uint256 = 0\n    denominator: uint256 = 0\n    for i: uint256 in range(config.maxNumSnapshots, bound=max_value(uint256)):\n\n        snapShot: ls.SingleSnapShot = self.snapShots[_vaultToken][i]\n        if snapShot.pricePerShare == 0 or snapShot.totalSupply == 0 or snapShot.lastUpdate == 0:\n            continue\n\n        # too stale, skip\n        if config.staleTime != 0 and block.timestamp > snapShot.lastUpdate + config.staleTime:\n            continue\n\n        numerator += (snapShot.totalSupply * snapShot.pricePerShare)\n        denominator += snapShot.totalSupply\n\n    # weighted price per share\n    weightedPricePerShare: uint256 = 0\n    if numerator != 0:\n        weightedPricePerShare = numerator // denominator\n    else:\n        weightedPricePerShare = _lastPricePerShare\n\n    return weightedPricePerShare\n\n\n# latest snapshot\n\n\n@view\n@external\ndef getLatestSnapshot(_vaultToken: address, _pricePerShare: uint256) -> ls.SingleSnapShot:\n    data: ls.SnapShotData = self.snapShotData[_vaultToken]\n    config: ls.SnapShotPriceConfig = self.snapShotPriceConfig\n    vaultTokenDecimals: uint256 = self.vaultToAsset[_vaultToken].decimals\n    return self._getLatestSnapshot(_vaultToken, _pricePerShare, vaultTokenDecimals, data.lastSnapShot, config)\n\n\n@view\n@internal\ndef _getLatestSnapshot(\n    _vaultToken: address,\n    _pricePerShare: uint256,\n    _vaultTokenDecimals: uint256,\n    _lastSnapShot: ls.SingleSnapShot,\n    _config: ls.SnapShotPriceConfig,\n) -> ls.SingleSnapShot:\n\n    # total supply (adjusted)\n    totalSupply: uint256 = staticcall IERC20(_vaultToken).totalSupply() // (10 ** _vaultTokenDecimals)\n    if totalSupply == 0:\n        totalSupply = 1\n\n    # throttle upside (extra safety check)\n    pricePerShare: uint256 = self._throttleUpside(_pricePerShare, _lastSnapShot.pricePerShare, _config.maxUpsideDeviation)\n\n    return ls.SingleSnapShot(\n        totalSupply = totalSupply,\n        pricePerShare = pricePerShare,\n        lastUpdate = block.timestamp,\n    )\n\n\n@view\n@internal\ndef _throttleUpside(_newValue: uint256, _prevValue: uint256, _maxUpside: uint256) -> uint256:\n    if _maxUpside == 0 or _prevValue == 0 or _newValue == 0:\n        return _newValue\n    maxPricePerShare: uint256 = _prevValue + (_prevValue * _maxUpside // HUNDRED_PERCENT)\n    return min(_newValue, maxPricePerShare)\n\n\n# snapshot price config\n\n\n@external\ndef setSnapShotPriceConfig(_config: ls.SnapShotPriceConfig):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert self._isValidPriceConfig(_config) # dev: invalid config\n    self.snapShotPriceConfig = _config\n    log SnapShotPriceConfigSet(\n        minSnapshotDelay=_config.minSnapshotDelay,\n        maxNumSnapshots=_config.maxNumSnapshots,\n        maxUpsideDeviation=_config.maxUpsideDeviation,\n        staleTime=_config.staleTime\n    )\n\n\n@view\n@external\ndef isValidPriceConfig(_config: ls.SnapShotPriceConfig) -> bool:\n    return self._isValidPriceConfig(_config)\n\n\n@view\n@internal\ndef _isValidPriceConfig(_config: ls.SnapShotPriceConfig) -> bool:\n    if _config.minSnapshotDelay > ONE_WEEK_SECONDS:\n        return False\n    if _config.maxNumSnapshots == 0 or _config.maxNumSnapshots > 25:\n        return False\n    if _config.maxUpsideDeviation > HUNDRED_PERCENT:\n        return False\n    return _config.staleTime < ONE_WEEK_SECONDS",
            "sha256sum": "d695c6d3998cf2ed318a0da6f4f7918abf97661e10eb510ed996d815e65927e0"
          },
          "contracts/legos/yield/40Acres.vy": {
            "content": "#     __   __ ___ _______ ___     ______       ___     _______ _______ _______ \n#    |  | |  |   |       |   |   |      |     |   |   |       |       |       |\n#    |  |_|  |   |    ___|   |   |  _    |    |   |   |    ___|    ___|   _   |\n#    |       |   |   |___|   |   | | |   |    |   |   |   |___|   | __|  | |  |\n#    |_     _|   |    ___|   |___| |_|   |    |   |___|    ___|   ||  |  |_|  |\n#      |   | |   |   |___|       |       |    |       |   |___|   |_| |       |\n#      |___| |___|_______|_______|______|     |_______|_______|_______|_______|\n#                                                                       \n#     \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n#     \u2551  ** 40 Acres **                     \u2551\n#     \u2551  Integration with 40 Acres Protocol.\u2551\n#     \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n#\n#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nimplements: Lego\nimplements: YieldLego\n\nexports: addys.__interface__\nexports: yld.__interface__\n\ninitializes: addys\ninitializes: yld[addys := addys]\n\nfrom interfaces import LegoPartner as Lego\nfrom interfaces import YieldLego as YieldLego\nfrom interfaces import WalletStructs as ws\nfrom interfaces import LegoStructs as ls\n\nimport contracts.modules.Addys as addys\nimport contracts.modules.YieldLegoData as yld\n\nfrom ethereum.ercs import IERC20\nfrom ethereum.ercs import IERC4626\n\ninterface Appraiser:\n    def getUsdValue(_asset: address, _amount: uint256, _missionControl: address = empty(address), _legoBook: address = empty(address), _ledger: address = empty(address)) -> uint256: view\n    def updatePriceAndGetUsdValue(_asset: address, _amount: uint256, _missionControl: address = empty(address), _legoBook: address = empty(address)) -> uint256: nonpayable\n\ninterface Ledger:\n    def setVaultToken(_vaultToken: address, _legoId: uint256, _underlyingAsset: address, _decimals: uint256, _isRebasing: bool): nonpayable\n    def isRegisteredVaultToken(_vaultToken: address) -> bool: view\n\ninterface Registry:\n    def getRegId(_addr: address) -> uint256: view\n\nevent FortyAcresDeposit:\n    sender: indexed(address)\n    asset: indexed(address)\n    vaultToken: indexed(address)\n    assetAmountDeposited: uint256\n    usdValue: uint256\n    vaultTokenAmountReceived: uint256\n    recipient: address\n\nevent FortyAcresWithdrawal:\n    sender: indexed(address)\n    asset: indexed(address)\n    vaultToken: indexed(address)\n    assetAmountReceived: uint256\n    usdValue: uint256\n    vaultTokenAmountBurned: uint256\n    recipient: address\n\nFORTY_ACRES_USDC_VAULT: public(immutable(address))\nMAX_TOKEN_PATH: constant(uint256) = 5\n\n\n@deploy\ndef __init__(_undyHq: address, _fortyAcresVault: address):\n    addys.__init__(_undyHq)\n    yld.__init__(False)\n\n    assert _fortyAcresVault != empty(address) # dev: invalid addr\n    FORTY_ACRES_USDC_VAULT = _fortyAcresVault\n\n\n@view\n@external\ndef hasCapability(_action: ws.ActionType) -> bool:\n    return _action in (\n        ws.ActionType.EARN_DEPOSIT | \n        ws.ActionType.EARN_WITHDRAW\n    )\n\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    return []\n\n\n@view\n@external\ndef isYieldLego() -> bool:\n    return True\n\n\n@view\n@external\ndef isDexLego() -> bool:\n    return False\n\n\n###################\n# Underlying Data #\n###################\n\n\n# underlying asset\n\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    return self._getUnderlyingAsset(_vaultToken)\n\n\n@view\n@internal\ndef _getUnderlyingAsset(_vaultToken: address) -> address:\n    return yld.vaultToAsset[_vaultToken].underlyingAsset\n\n\n# underlying balances (both true and safe)\n\n\n@view\n@external\ndef getUnderlyingBalances(_vaultToken: address, _vaultTokenBalance: uint256) -> (uint256, uint256):\n    if _vaultTokenBalance == 0:\n        return 0, 0\n\n    trueUnderlying: uint256 = self._getUnderlyingAmount(_vaultToken, _vaultTokenBalance)\n    safeUnderlying: uint256 = self._getUnderlyingAmountSafe(_vaultToken, _vaultTokenBalance)\n    if safeUnderlying == 0:\n        safeUnderlying = trueUnderlying\n\n    return trueUnderlying, min(trueUnderlying, safeUnderlying)\n\n\n# underlying amount (true)\n\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    return self._getUnderlyingAmount(_vaultToken, _vaultTokenAmount)\n\n\n@view\n@internal\ndef _getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    return staticcall IERC4626(_vaultToken).convertToAssets(_vaultTokenAmount)\n\n\n# underlying amount (safe)\n\n\n@view\n@external\ndef getUnderlyingAmountSafe(_vaultToken: address, _vaultTokenBalance: uint256) -> uint256:\n    return self._getUnderlyingAmountSafe(_vaultToken, _vaultTokenBalance)\n\n\n@view\n@internal\ndef _getUnderlyingAmountSafe(_vaultToken: address, _vaultTokenBalance: uint256) -> uint256:\n    vaultInfo: ls.VaultTokenInfo = yld.vaultToAsset[_vaultToken]\n    if vaultInfo.decimals == 0:\n        return 0 # not registered\n\n    # safe underlying amount (using cached weighted average from snapshots)\n    return _vaultTokenBalance * vaultInfo.lastAveragePricePerShare // (10 ** vaultInfo.decimals)\n\n\n# underlying data (combined)\n\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> (address, uint256, uint256):\n    return self._getUnderlyingData(_vaultToken, _vaultTokenAmount, _appraiser)\n\n\n@view\n@internal\ndef _getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address) -> (address, uint256, uint256):\n    asset: address = self._getUnderlyingAsset(_vaultToken)\n    if asset == empty(address):\n        return empty(address), 0, 0 # invalid vault token\n    underlyingAmount: uint256 = self._getUnderlyingAmount(_vaultToken, _vaultTokenAmount)\n    usdValue: uint256 = self._getUsdValue(asset, underlyingAmount, _appraiser)\n    return asset, underlyingAmount, usdValue\n\n\n# usd value\n\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> uint256:\n    return self._getUsdValueOfVaultToken(_vaultToken, _vaultTokenAmount, _appraiser)\n\n\n@view\n@internal\ndef _getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address) -> uint256:\n    return self._getUnderlyingData(_vaultToken, _vaultTokenAmount, _appraiser)[2]\n\n\n@view\n@internal\ndef _getUsdValue(_asset: address, _amount: uint256, _appraiser: address) -> uint256:\n    appraiser: address = _appraiser\n    if _appraiser == empty(address):\n        appraiser = addys._getAppraiserAddr()\n    return staticcall Appraiser(appraiser).getUsdValue(_asset, _amount)\n\n\n###############\n# Other Utils #\n###############\n\n\n# basics\n\n\n@view\n@external\ndef isRebasing() -> bool:\n    return self._isRebasing()\n\n\n@view\n@internal\ndef _isRebasing() -> bool:\n    return False\n\n\n# price per share\n\n\n@view\n@external\ndef getPricePerShare(_vaultToken: address, _decimals: uint256 = 0) -> uint256:\n    decimals: uint256 = _decimals\n    if decimals == 0:\n        decimals = yld.vaultToAsset[_vaultToken].decimals\n    if decimals == 0:\n        return 0 # not registered\n    return self._getPricePerShare(_vaultToken, decimals)\n\n\n@view\n@internal\ndef _getPricePerShare(_vaultToken: address, _decimals: uint256) -> uint256:\n    return staticcall IERC4626(_vaultToken).convertToAssets(10 ** _decimals)\n\n\n# vault token amount\n\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    return staticcall IERC4626(_vaultToken).convertToShares(_assetAmount)\n\n\n# extras\n\n\n@view\n@external\ndef isEligibleVaultForTrialFunds(_vaultToken: address, _underlyingAsset: address) -> bool:\n    return False\n\n\n@view\n@external\ndef isEligibleForYieldBonus(_asset: address) -> bool:\n    return False\n\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    return staticcall IERC4626(_vaultToken).totalAssets()\n\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    # TODO: implement\n    return 0\n\n\n################\n# Registration #\n################\n\n\n# can vault be registered\n\n\n@view\n@external\ndef canRegisterVaultToken(_asset: address, _vaultToken: address) -> bool:\n    return self._canRegisterVaultToken(_asset, _vaultToken)\n\n\n@view\n@internal\ndef _canRegisterVaultToken(_asset: address, _vaultToken: address) -> bool:\n    if empty(address) in [_asset, _vaultToken]:\n        return False\n    return staticcall IERC4626(_vaultToken).asset() == _asset and _vaultToken == FORTY_ACRES_USDC_VAULT\n\n\n# register vault token locally\n\n\n@external\ndef registerVaultTokenLocally(_asset: address, _vaultAddr: address) -> ls.VaultTokenInfo:\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert self._canRegisterVaultToken(_asset, _vaultAddr) # dev: cannot register vault token\n    assert not yld._isAssetOpportunity(_asset, _vaultAddr) # dev: already registered\n    vaultInfo: ls.VaultTokenInfo = self._registerVaultTokenLocally(_asset, _vaultAddr)\n    self._registerVaultTokenGlobally(_asset, _vaultAddr, vaultInfo.decimals, addys._getLedgerAddr(), addys._getLegoBookAddr())\n    return vaultInfo\n\n\n@internal\ndef _registerVaultTokenLocally(_asset: address, _vaultAddr: address) -> ls.VaultTokenInfo:\n    assert extcall IERC20(_asset).approve(_vaultAddr, max_value(uint256), default_return_value=True) # dev: max approval failed\n    vaultInfo: ls.VaultTokenInfo = yld._addAssetOpportunity(_asset, _vaultAddr)\n    assert vaultInfo.decimals != 0 # dev: invalid vault token\n    return vaultInfo\n\n\n# remove vault token locally\n\n\n@external\ndef deregisterVaultTokenLocally(_asset: address, _vaultAddr: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert yld._isAssetOpportunity(_asset, _vaultAddr) # dev: already registered\n    self._deregisterVaultTokenLocally(_asset, _vaultAddr)\n\n\n@internal\ndef _deregisterVaultTokenLocally(_asset: address, _vaultAddr: address):\n    assert extcall IERC20(_asset).approve(_vaultAddr, 0, default_return_value=True) # dev: max approval failed\n    yld._removeAssetOpportunity(_asset, _vaultAddr)\n\n\n# ledger registration\n\n\n@internal\ndef _registerVaultTokenGlobally(_underlyingAsset: address, _vaultToken: address, _decimals: uint256, _ledger: address, _legoBook: address):\n    if not staticcall Ledger(_ledger).isRegisteredVaultToken(_vaultToken):\n        legoId: uint256 = staticcall Registry(_legoBook).getRegId(self)\n        extcall Ledger(_ledger).setVaultToken(_vaultToken, legoId, _underlyingAsset, _decimals, self._isRebasing())\n\n\n#################\n# Yield Actions #\n#################\n\n\n# add price snapshot\n\n\n@external\ndef addPriceSnapshot(_vaultToken: address) -> bool:\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    vaultInfo: ls.VaultTokenInfo = yld.vaultToAsset[_vaultToken]\n    assert vaultInfo.decimals != 0 # dev: not registered\n    pricePerShare: uint256 = self._getPricePerShare(_vaultToken, vaultInfo.decimals)\n    return yld._addPriceSnapshot(_vaultToken, pricePerShare, vaultInfo.decimals)\n\n\n# deposit\n\n\n@external\ndef depositForYield(\n    _asset: address,\n    _amount: uint256,\n    _vaultAddr: address,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, address, uint256, uint256):\n    assert not yld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = yld._getMiniAddys(_miniAddys)\n    vaultInfo: ls.VaultTokenInfo = self._getVaultInfoOnDeposit(_asset, _vaultAddr, miniAddys.ledger, miniAddys.legoBook)\n\n    # pre balances\n    preLegoBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n\n    # transfer deposit asset to this contract\n    depositAmount: uint256 = min(_amount, staticcall IERC20(_asset).balanceOf(msg.sender))\n    assert depositAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_asset).transferFrom(msg.sender, self, depositAmount, default_return_value=True) # dev: transfer failed\n\n    # deposit assets into lego partner\n    vaultTokenAmountReceived: uint256 = extcall IERC4626(_vaultAddr).deposit(depositAmount, _recipient)\n    assert vaultTokenAmountReceived != 0 # dev: no vault tokens received\n\n    # refund if full deposit didn't get through\n    currentLegoBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    refundAssetAmount: uint256 = 0\n    if currentLegoBalance > preLegoBalance:\n        refundAssetAmount = currentLegoBalance - preLegoBalance\n        assert extcall IERC20(_asset).transfer(msg.sender, refundAssetAmount, default_return_value=True) # dev: transfer failed\n        depositAmount -= refundAssetAmount\n\n    usdValue: uint256 = extcall Appraiser(miniAddys.appraiser).updatePriceAndGetUsdValue(_asset, depositAmount, miniAddys.missionControl, miniAddys.legoBook)\n    log FortyAcresDeposit(\n        sender = msg.sender,\n        asset = _asset,\n        vaultToken = _vaultAddr,\n        assetAmountDeposited = depositAmount,\n        usdValue = usdValue,\n        vaultTokenAmountReceived = vaultTokenAmountReceived,\n        recipient = _recipient,\n    )\n\n    # add price snapshot\n    pricePerShare: uint256 = self._getPricePerShare(_vaultAddr, vaultInfo.decimals)\n    yld._addPriceSnapshot(_vaultAddr, pricePerShare, vaultInfo.decimals)\n\n    return depositAmount, _vaultAddr, vaultTokenAmountReceived, usdValue\n\n\n# vault info on deposit\n\n\n@internal\ndef _getVaultInfoOnDeposit(_asset: address, _vaultAddr: address, _ledger: address, _legoBook: address) -> ls.VaultTokenInfo:\n    vaultInfo: ls.VaultTokenInfo = yld.vaultToAsset[_vaultAddr]\n    if vaultInfo.decimals == 0:\n        assert self._canRegisterVaultToken(_asset, _vaultAddr) # dev: cannot register vault token\n        vaultInfo = self._registerVaultTokenLocally(_asset, _vaultAddr)\n        self._registerVaultTokenGlobally(_asset, _vaultAddr, vaultInfo.decimals, _ledger, _legoBook)\n    else:\n        assert vaultInfo.underlyingAsset == _asset # dev: asset mismatch\n    return vaultInfo\n\n\n# withdraw\n\n\n@external\ndef withdrawFromYield(\n    _vaultToken: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, address, uint256, uint256):\n    assert not yld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = yld._getMiniAddys(_miniAddys)\n    vaultInfo: ls.VaultTokenInfo = self._getVaultInfoOnWithdrawal(_vaultToken, miniAddys.ledger, miniAddys.legoBook)\n\n    # pre balances\n    preLegoVaultBalance: uint256 = staticcall IERC20(_vaultToken).balanceOf(self)\n\n    # transfer vaults tokens to this contract\n    vaultTokenAmount: uint256 = min(_amount, staticcall IERC20(_vaultToken).balanceOf(msg.sender))\n    assert vaultTokenAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_vaultToken).transferFrom(msg.sender, self, vaultTokenAmount, default_return_value=True) # dev: transfer failed\n\n    # withdraw assets from lego partner\n    assetAmountReceived: uint256 = extcall IERC4626(_vaultToken).redeem(vaultTokenAmount, _recipient, self)\n    assert assetAmountReceived != 0 # dev: no asset amount received\n\n    # refund if full withdrawal didn't happen\n    currentLegoVaultBalance: uint256 = staticcall IERC20(_vaultToken).balanceOf(self)\n    refundVaultTokenAmount: uint256 = 0\n    if currentLegoVaultBalance > preLegoVaultBalance:\n        refundVaultTokenAmount = currentLegoVaultBalance - preLegoVaultBalance\n        assert extcall IERC20(_vaultToken).transfer(msg.sender, refundVaultTokenAmount, default_return_value=True) # dev: transfer failed\n        vaultTokenAmount -= refundVaultTokenAmount\n\n    usdValue: uint256 = extcall Appraiser(miniAddys.appraiser).updatePriceAndGetUsdValue(vaultInfo.underlyingAsset, assetAmountReceived, miniAddys.missionControl, miniAddys.legoBook)\n    log FortyAcresWithdrawal(\n        sender = msg.sender,\n        asset = vaultInfo.underlyingAsset,\n        vaultToken = _vaultToken,\n        assetAmountReceived = assetAmountReceived,\n        usdValue = usdValue,\n        vaultTokenAmountBurned = vaultTokenAmount,\n        recipient = _recipient,\n    )\n\n    # add price snapshot\n    pricePerShare: uint256 = self._getPricePerShare(_vaultToken, vaultInfo.decimals)\n    yld._addPriceSnapshot(_vaultToken, pricePerShare, vaultInfo.decimals)\n\n    return vaultTokenAmount, vaultInfo.underlyingAsset, assetAmountReceived, usdValue\n\n\n# vault info on withdrawal\n\n\n@internal\ndef _getVaultInfoOnWithdrawal(_vaultAddr: address, _ledger: address, _legoBook: address) -> ls.VaultTokenInfo:\n    vaultInfo: ls.VaultTokenInfo = yld.vaultToAsset[_vaultAddr]\n    if vaultInfo.decimals == 0:\n        asset: address = staticcall IERC4626(_vaultAddr).asset()\n        assert self._canRegisterVaultToken(asset, _vaultAddr) # dev: cannot register vault token\n        vaultInfo = self._registerVaultTokenLocally(asset, _vaultAddr)\n        self._registerVaultTokenGlobally(asset, _vaultAddr, vaultInfo.decimals, _ledger, _legoBook)\n    return vaultInfo\n\n\n#########\n# Other #\n#########\n\n\n@view\n@external\ndef getAccessForLego(_user: address, _action: ws.ActionType) -> (address, String[64], uint256):\n    return empty(address), empty(String[64]), 0\n\n\n@external\ndef claimRewards(\n    _user: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _extraData: bytes32,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@view\n@external\ndef hasClaimableRewards(_user: address) -> bool:\n    return False\n\n\n@external\ndef swapTokens(\n    _amountIn: uint256,\n    _minAmountOut: uint256,\n    _tokenPath: DynArray[address, MAX_TOKEN_PATH],\n    _poolPath: DynArray[address, MAX_TOKEN_PATH - 1],\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256):\n    return 0, 0, 0\n\n\n@external\ndef mintOrRedeemAsset(\n    _tokenIn: address,\n    _tokenOut: address,\n    _tokenInAmount: uint256,\n    _minAmountOut: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, bool, uint256):\n    return 0, 0, False, 0\n\n\n@external\ndef confirmMintOrRedeemAsset(\n    _tokenIn: address,\n    _tokenOut: address,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef addCollateral(\n    _asset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef removeCollateral(\n    _asset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef borrow(\n    _borrowAsset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef repayDebt(\n    _paymentAsset: address,\n    _paymentAmount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef addLiquidity(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _amountA: uint256,\n    _amountB: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _minLpAmount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (address, uint256, uint256, uint256, uint256):\n    return empty(address), 0, 0, 0, 0\n\n\n@external\ndef removeLiquidity(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpToken: address,\n    _lpAmount: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, uint256):\n    return 0, 0, 0, 0\n\n\n@external\ndef addLiquidityConcentrated(\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _tickLower: int24,\n    _tickUpper: int24,\n    _amountA: uint256,\n    _amountB: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, uint256, uint256):\n    return 0, 0, 0, 0, 0\n\n\n@external\ndef removeLiquidityConcentrated(\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _liqToRemove: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, bool, uint256):\n    return 0, 0, 0, False, 0",
            "sha256sum": "f5daf0294926b737f34c0466ce33c422748c86c78ea2457254573b0033c4707c"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/legos/yield/40Acres.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.3+commit.bff19ea2",
        "integrity": "1f68109ffc7f98f12ef3a13ff8bc7b30c1bf97bb5d9e0816dd8348ca73134eaa"
      },
      "args": "00000000000000000000000044cf3c4f000dfd76a35d03298049d37be688d6f9000000000000000000000000b99b6df96d4d5448cc0a5b3e0ef7896df9507cf5",
      "file": "contracts/legos/yield/40Acres.vy"
    },
    "Wasabi": {
      "address": "0x1CB5Cc1dD714Bb2Aad9Ea6f6654Dd81e93Cd81C0",
      "abi": [
        {
          "name": "WasabiDeposit",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountDeposited",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultTokenAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "WasabiWithdrawal",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultTokenAmountBurned",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LegoPauseModified",
          "inputs": [
            {
              "name": "isPaused",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LegoFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "balance",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "SnapShotPriceConfigSet",
          "inputs": [
            {
              "name": "minSnapshotDelay",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "maxNumSnapshots",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "maxUpsideDeviation",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "staleTime",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetOpportunityAdded",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultAddr",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetOpportunityRemoved",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultAddr",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PricePerShareSnapShotAdded",
          "inputs": [
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "totalSupply",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "pricePerShare",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddys",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "undyToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "hatchery",
                  "type": "address"
                },
                {
                  "name": "lootDistributor",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                },
                {
                  "name": "walletBackpack",
                  "type": "address"
                },
                {
                  "name": "billing",
                  "type": "address"
                },
                {
                  "name": "vaultRegistry",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUndyHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isLegoAsset",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssetOpportunities",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isAssetOpportunity",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getNumLegoAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pause",
          "inputs": [
            {
              "name": "_shouldPause",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFundsMany",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_assets",
              "type": "address[]"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getWeightedPricePerShare",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLatestSnapshot",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_pricePerShare",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "totalSupply",
                  "type": "uint256"
                },
                {
                  "name": "pricePerShare",
                  "type": "uint256"
                },
                {
                  "name": "lastUpdate",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setSnapShotPriceConfig",
          "inputs": [
            {
              "name": "_config",
              "type": "tuple",
              "components": [
                {
                  "name": "minSnapshotDelay",
                  "type": "uint256"
                },
                {
                  "name": "maxNumSnapshots",
                  "type": "uint256"
                },
                {
                  "name": "maxUpsideDeviation",
                  "type": "uint256"
                },
                {
                  "name": "staleTime",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidPriceConfig",
          "inputs": [
            {
              "name": "_config",
              "type": "tuple",
              "components": [
                {
                  "name": "minSnapshotDelay",
                  "type": "uint256"
                },
                {
                  "name": "maxNumSnapshots",
                  "type": "uint256"
                },
                {
                  "name": "maxUpsideDeviation",
                  "type": "uint256"
                },
                {
                  "name": "staleTime",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "vaultToAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "underlyingAsset",
                  "type": "address"
                },
                {
                  "name": "decimals",
                  "type": "uint256"
                },
                {
                  "name": "lastAveragePricePerShare",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assetOpportunities",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAssetOpportunity",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssetOpportunities",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assets",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "snapShotData",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "lastSnapShot",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "totalSupply",
                      "type": "uint256"
                    },
                    {
                      "name": "pricePerShare",
                      "type": "uint256"
                    },
                    {
                      "name": "lastUpdate",
                      "type": "uint256"
                    }
                  ]
                },
                {
                  "name": "nextIndex",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "snapShots",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "totalSupply",
                  "type": "uint256"
                },
                {
                  "name": "pricePerShare",
                  "type": "uint256"
                },
                {
                  "name": "lastUpdate",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "snapShotPriceConfig",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "minSnapshotDelay",
                  "type": "uint256"
                },
                {
                  "name": "maxNumSnapshots",
                  "type": "uint256"
                },
                {
                  "name": "maxUpsideDeviation",
                  "type": "uint256"
                },
                {
                  "name": "staleTime",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isPaused",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasCapability",
          "inputs": [
            {
              "name": "_action",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRegistries",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isYieldLego",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isDexLego",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAsset",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingBalances",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenBalance",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAmount",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAmountSafe",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenBalance",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingData",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingData",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            },
            {
              "name": "_appraiser",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValueOfVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValueOfVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            },
            {
              "name": "_appraiser",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isRebasing",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPricePerShare",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPricePerShare",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_decimals",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getVaultTokenAmount",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_assetAmount",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isEligibleVaultForTrialFunds",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_underlyingAsset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isEligibleForYieldBonus",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalAssets",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalBorrows",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canRegisterVaultToken",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "registerVaultTokenLocally",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "underlyingAsset",
                  "type": "address"
                },
                {
                  "name": "decimals",
                  "type": "uint256"
                },
                {
                  "name": "lastAveragePricePerShare",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "deregisterVaultTokenLocally",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addPriceSnapshot",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositForYield",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositForYield",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawFromYield",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawFromYield",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAccessForLego",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_action",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "string"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasClaimableRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_tokenPath",
              "type": "address[]"
            },
            {
              "name": "_poolPath",
              "type": "address[]"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_tokenPath",
              "type": "address[]"
            },
            {
              "name": "_poolPath",
              "type": "address[]"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_tokenInAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_tokenInAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmMintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmMintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_borrowAsset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_borrowAsset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_paymentAsset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_paymentAsset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "WASABI_LONG_POOL",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "WASABI_SHORT_POOL",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_undyHq",
              "type": "address"
            },
            {
              "name": "_wasabiLongPool",
              "type": "address"
            },
            {
              "name": "_wasabiShortPool",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "interfaces/WalletStructs.vyi": {
            "content": "# @version 0.4.3\n\nflag ActionType:\n    TRANSFER\n    EARN_DEPOSIT\n    EARN_WITHDRAW\n    EARN_REBALANCE\n    SWAP\n    MINT_REDEEM\n    CONFIRM_MINT_REDEEM\n    ADD_COLLATERAL\n    REMOVE_COLLATERAL\n    BORROW\n    REPAY_DEBT\n    REWARDS\n    ETH_TO_WETH\n    WETH_TO_ETH\n    ADD_LIQ\n    REMOVE_LIQ\n    ADD_LIQ_CONC\n    REMOVE_LIQ_CONC\n    PAY_CHEQUE\n\nstruct WalletAssetData:\n    assetBalance: uint256\n    usdValue: uint256\n    isYieldAsset: bool\n    lastPricePerShare: uint256\n\nstruct ActionData:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    billing: address\n    wallet: address\n    walletConfig: address\n    walletOwner: address\n    inEjectMode: bool\n    isFrozen: bool\n    lastTotalUsdValue: uint256\n    signer: address\n    isManager: bool\n    legoId: uint256\n    legoAddr: address\n    eth: address\n    weth: address\n\nstruct MiniAddys:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    appraiser: address",
            "sha256sum": "9a4b4f59b3a62043e51b425a665064aae419a3c0bd0514b6b29a9441ae364bb9"
          },
          "interfaces/LegoPartner.vyi": {
            "content": "# @version 0.4.3\n\nfrom interfaces import WalletStructs as ws\n\nMAX_TOKEN_PATH: constant(uint256) = 5\nMAX_RECOVER_ASSETS: constant(uint256) = 20\n\n@external\ndef addLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _tickLower: int24, _tickUpper: int24, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef addLiquidity(_pool: address, _tokenA: address, _tokenB: address, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _minLpAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (address, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef removeLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _liqToRemove: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef removeLiquidity(_pool: address, _tokenA: address, _tokenB: address, _lpToken: address, _lpAmount: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef mintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _tokenInAmount: uint256, _minAmountOut: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef swapTokens(_amountIn: uint256, _minAmountOut: uint256, _tokenPath: DynArray[address, MAX_TOKEN_PATH], _poolPath: DynArray[address, MAX_TOKEN_PATH - 1], _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256):\n    ...\n\n@external\ndef depositForYield(_asset: address, _amount: uint256, _vaultAddr: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef withdrawFromYield(_vaultToken: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef confirmMintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef borrow(_borrowAsset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef repayDebt(_paymentAsset: address, _paymentAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef claimRewards(_user: address, _rewardToken: address, _rewardAmount: uint256, _extraData: bytes32, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef removeCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef addCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@view\n@external\ndef getAccessForLego(_user: address, _action: ws.ActionType) -> (address, String[64], uint256):\n    ...\n\n@view\n@external\ndef hasCapability(_action: ws.ActionType) -> bool:\n    ...\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    ...\n\n@view\n@external\ndef isYieldLego() -> bool:\n    ...\n\n@view\n@external\ndef isDexLego() -> bool:\n    ...\n\n\n# common\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "81db71fe4440a3b4b563134c9b5caf1d5705772a5f291fe874c9b5fb3cfb1623"
          },
          "interfaces/LegoStructs.vyi": {
            "content": "# @version 0.4.3\n\nstruct VaultTokenInfo:\n    underlyingAsset: address\n    decimals: uint256\n    lastAveragePricePerShare: uint256\n\nstruct SnapShotPriceConfig:\n    minSnapshotDelay: uint256\n    maxNumSnapshots: uint256\n    maxUpsideDeviation: uint256\n    staleTime: uint256\n\nstruct SingleSnapShot:\n    totalSupply: uint256\n    pricePerShare: uint256\n    lastUpdate: uint256\n\nstruct SnapShotData:\n    lastSnapShot: SingleSnapShot\n    nextIndex: uint256\n",
            "sha256sum": "8ae48be17d812d57fbd671bbf0593e8abf175ad0924e47c5997823cac19ec806"
          },
          "interfaces/YieldLego.vyi": {
            "content": "# @version 0.4.3\n\nfrom interfaces import LegoStructs as ls\n\n\n###################\n# Underlying Data #\n###################\n\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    ...\n\n\n@view\n@external\ndef getUnderlyingBalances(_vaultToken: address, _vaultTokenBalance: uint256) -> (uint256, uint256):\n    ...\n\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    ...\n\n\n@view\n@external\ndef getUnderlyingAmountSafe(_vaultToken: address, _vaultTokenBalance: uint256) -> uint256:\n    ...\n\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> (address, uint256, uint256):\n    ...\n\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> uint256:\n    ...\n\n\n###############\n# Other Utils #\n###############\n\n\n@view\n@external\ndef isRebasing() -> bool:\n    ...\n\n\n@view\n@external\ndef getPricePerShare(_vaultToken: address, _decimals: uint256 = 0) -> uint256:\n    ...\n\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef canRegisterVaultToken(_asset: address, _vaultToken: address) -> bool:\n    ...\n\n\n@view\n@external\ndef isEligibleVaultForTrialFunds(_vaultToken: address, _underlyingAsset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef isEligibleForYieldBonus(_asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    ...\n\n\n###################\n# Yield Lego Data #\n###################\n\n\n@view\n@external\ndef isLegoAsset(_asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, 40]:\n    ...\n\n\n@view\n@external\ndef getAssets() -> DynArray[address, 20]:\n    ...\n\n\n@view\n@external\ndef isAssetOpportunity(_asset: address, _vaultAddr: address) -> bool:\n    ...\n\n\n@view\n@external\ndef getNumLegoAssets() -> uint256:\n    ...\n\n\n@view\n@external\ndef assets(_index: uint256) -> address:\n    ...\n\n\n@view\n@external\ndef indexOfAsset(_asset: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef numAssets() -> uint256:\n    ...\n\n\n@view\n@external\ndef assetOpportunities(_asset: address, _index: uint256) -> address:\n    ...\n\n\n@view\n@external\ndef indexOfAssetOpportunity(_asset: address, _vaultAddr: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef numAssetOpportunities(_asset: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef vaultToAsset(_vaultAddr: address) -> ls.VaultTokenInfo:\n    ...\n\n\n# price snapshots\n\n\n@external\ndef addPriceSnapshot(_vaultToken: address) -> bool:\n    ...\n\n\n@view\n@external\ndef snapShotPriceConfig() -> ls.SnapShotPriceConfig:\n    ...\n\n\n@view\n@external\ndef snapShotData(_vaultToken: address) -> ls.SnapShotData:\n    ...\n\n\n@view\n@external\ndef snapShots(_vaultToken: address, _index: uint256) -> ls.SingleSnapShot:\n    ...\n\n\n@view\n@external\ndef getWeightedPricePerShare(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef getLatestSnapshot(_vaultToken: address, _pricePerShare: uint256) -> ls.SingleSnapShot:\n    ...\n\n\n@external\ndef setSnapShotPriceConfig(_config: ls.SnapShotPriceConfig):\n    ...\n",
            "sha256sum": "045a6bbd3d556234cf4fe925a303002dc0ac3c482d344ffbaf4bc52a7e6ad2df"
          },
          "contracts/modules/Addys.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\ninterface UndyHq:\n    def isValidAddr(_addr: address) -> bool: view\n    def getAddr(_regId: uint256) -> address: view\n    def undyToken() -> address: view\n\ninterface Switchboard:\n    def isSwitchboardAddr(_addr: address) -> bool: view\n\ninterface LegoBook:\n    def isLegoAddr(_addr: address) -> bool: view\n\nstruct Addys:\n    hq: address\n    undyToken: address\n    ledger: address\n    missionControl: address\n    legoBook: address\n    switchboard: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    walletBackpack: address\n    billing: address\n    vaultRegistry: address\n\n# hq\nUNDY_HQ_FOR_ADDYS: immutable(address)\n\n# core addys\nLEDGER_ID: constant(uint256) = 1\nMISSION_CONTROL_ID: constant(uint256) = 2\nLEGO_BOOK_ID: constant(uint256) = 3\nSWITCHBOARD_ID: constant(uint256) = 4\nHATCHERY_ID: constant(uint256) = 5\nLOOT_DISTRIBUTOR_ID: constant(uint256) = 6\nAPPRAISER_ID: constant(uint256) = 7\nWALLET_BACKPACK_ID: constant(uint256) = 8\nBILLING_ID: constant(uint256) = 9\nVAULT_REGISTRY_ID: constant(uint256) = 10\n\n\n@deploy\ndef __init__(_undyHq: address):\n    assert _undyHq != empty(address) # dev: invalid undy hq\n    UNDY_HQ_FOR_ADDYS = _undyHq\n\n\n########\n# Core #\n########\n\n\n@view\n@external\ndef getAddys() -> Addys:\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _getAddys(_addys: Addys = empty(Addys)) -> Addys:\n    if _addys.hq != empty(address):\n        return _addys\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _generateAddys() -> Addys:\n    hq: address = UNDY_HQ_FOR_ADDYS\n    return Addys(\n        hq = hq,\n        undyToken = staticcall UndyHq(hq).undyToken(),\n        ledger = staticcall UndyHq(hq).getAddr(LEDGER_ID),\n        missionControl = staticcall UndyHq(hq).getAddr(MISSION_CONTROL_ID),\n        legoBook = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID),\n        switchboard = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID),\n        hatchery = staticcall UndyHq(hq).getAddr(HATCHERY_ID),\n        lootDistributor = staticcall UndyHq(hq).getAddr(LOOT_DISTRIBUTOR_ID),\n        appraiser = staticcall UndyHq(hq).getAddr(APPRAISER_ID),\n        walletBackpack = staticcall UndyHq(hq).getAddr(WALLET_BACKPACK_ID),\n        billing = staticcall UndyHq(hq).getAddr(BILLING_ID),\n        vaultRegistry = staticcall UndyHq(hq).getAddr(VAULT_REGISTRY_ID),\n    )\n\n\n##########\n# Tokens #\n##########\n\n\n@view\n@internal\ndef _getUndyToken() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).undyToken()\n\n\n###########\n# Helpers #\n###########\n\n\n# undy hq\n\n\n@view\n@external\ndef getUndyHq() -> address:\n    return self._getUndyHq()\n\n\n@view\n@internal\ndef _getUndyHq() -> address:\n    return UNDY_HQ_FOR_ADDYS\n\n\n# utils\n\n\n@view\n@internal\ndef _isValidUndyAddr(_addr: address, _hq: address = empty(address)) -> bool:\n    hq: address = _hq\n    if _hq == empty(address):\n        hq = UNDY_HQ_FOR_ADDYS\n    \n    # core departments\n    if staticcall UndyHq(hq).isValidAddr(_addr):\n        return True\n\n    # lego book\n    legoBook: address = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID)\n    if legoBook != empty(address) and staticcall LegoBook(legoBook).isLegoAddr(_addr):\n        return True\n\n    # switchboard config\n    switchboard: address = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID)\n    if switchboard != empty(address) and staticcall Switchboard(switchboard).isSwitchboardAddr(_addr):\n        return True\n\n    return False\n\n\n@view\n@internal\ndef _isSwitchboardAddr(_addr: address) -> bool:\n    switchboard: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n    if switchboard == empty(address):\n        return False\n    return staticcall Switchboard(switchboard).isSwitchboardAddr(_addr)\n\n\n@view\n@internal\ndef _isLegoBookAddr(_addr: address) -> bool:\n    legoBook: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n    if legoBook == empty(address):\n        return False\n    return staticcall LegoBook(legoBook).isLegoAddr(_addr)\n\n\n###############\n# Departments #\n###############\n\n\n# ledger\n\n\n@view\n@internal\ndef _getLedgerId() -> uint256:\n    return LEDGER_ID\n\n\n@view\n@internal\ndef _getLedgerAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEDGER_ID)\n\n\n# mission control\n\n\n@view\n@internal\ndef _getMissionControlId() -> uint256:\n    return MISSION_CONTROL_ID\n\n\n@view\n@internal\ndef _getMissionControlAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(MISSION_CONTROL_ID)\n\n\n# lego book\n\n\n@view\n@internal\ndef _getLegoBookId() -> uint256:\n    return LEGO_BOOK_ID\n\n\n@view\n@internal\ndef _getLegoBookAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n\n\n# switchboard\n\n\n@view\n@internal\ndef _getSwitchboardId() -> uint256:\n    return SWITCHBOARD_ID\n\n\n@view\n@internal\ndef _getSwitchboardAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n\n\n# hatchery\n\n\n@view\n@internal\ndef _getHatcheryId() -> uint256:\n    return HATCHERY_ID\n\n\n@view\n@internal\ndef _getHatcheryAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(HATCHERY_ID)\n\n\n# loot distributor\n\n\n@view\n@internal\ndef _getLootDistributorId() -> uint256:\n    return LOOT_DISTRIBUTOR_ID\n\n\n@view\n@internal\ndef _getLootDistributorAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LOOT_DISTRIBUTOR_ID)\n\n\n# appraiser\n\n\n@view\n@internal\ndef _getAppraiserId() -> uint256:\n    return APPRAISER_ID\n\n\n@view\n@internal\ndef _getAppraiserAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(APPRAISER_ID)\n\n\n# wallet backpack\n\n\n@view\n@internal\ndef _getWalletBackpackId() -> uint256:\n    return WALLET_BACKPACK_ID\n\n\n@view\n@internal\ndef _getWalletBackpackAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(WALLET_BACKPACK_ID)\n\n\n# billing\n\n\n@view\n@internal\ndef _getBillingId() -> uint256:\n    return BILLING_ID\n\n\n@view\n@internal\ndef _getBillingAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(BILLING_ID)\n\n\n# vault registry\n\n\n@view\n@internal\ndef _getVaultRegistryId() -> uint256:\n    return VAULT_REGISTRY_ID\n\n\n@view\n@internal\ndef _getVaultRegistryAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(VAULT_REGISTRY_ID)",
            "sha256sum": "4df6b72db9bb417d1af81660175be1450cfb7b3575f3d17a5b8a130bff87b781"
          },
          "contracts/modules/YieldLegoData.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nuses: addys\n\nimport contracts.modules.Addys as addys\n\nfrom interfaces import WalletStructs as ws\nfrom interfaces import LegoStructs as ls\nfrom ethereum.ercs import IERC20\nfrom ethereum.ercs import IERC20Detailed\n\nevent AssetOpportunityAdded:\n    asset: indexed(address)\n    vaultAddr: indexed(address)\n\nevent AssetOpportunityRemoved:\n    asset: indexed(address)\n    vaultAddr: indexed(address)\n\nevent LegoPauseModified:\n    isPaused: bool\n\nevent LegoFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    balance: uint256\n\nevent PricePerShareSnapShotAdded:\n    vaultToken: indexed(address)\n    totalSupply: uint256\n    pricePerShare: uint256\n\nevent SnapShotPriceConfigSet:\n    minSnapshotDelay: uint256\n    maxNumSnapshots: uint256\n    maxUpsideDeviation: uint256\n    staleTime: uint256\n\n# core\nvaultToAsset: public(HashMap[address, ls.VaultTokenInfo]) # vault addr -> data\n\n# asset opportunities\nassetOpportunities: public(HashMap[address, HashMap[uint256, address]]) # asset -> index -> vault addr\nindexOfAssetOpportunity: public(HashMap[address, HashMap[address, uint256]]) # asset -> vault addr -> index\nnumAssetOpportunities: public(HashMap[address, uint256]) # asset -> number of opportunities\n\n# lego assets (iterable)\nassets: public(HashMap[uint256, address]) # index -> asset\nindexOfAsset: public(HashMap[address, uint256]) # asset -> index\nnumAssets: public(uint256) # num assets\n\n# price snapshots\nsnapShotData: public(HashMap[address, ls.SnapShotData]) # vault token -> data\nsnapShots: public(HashMap[address, HashMap[uint256, ls.SingleSnapShot]]) # vault token -> index -> snapshot\nsnapShotPriceConfig: public(ls.SnapShotPriceConfig) # config\n\nisPaused: public(bool)\n\nMAX_VAULTS: constant(uint256) = 40\nMAX_ASSETS: constant(uint256) = 20\nMAX_RECOVER_ASSETS: constant(uint256) = 20\nONE_DAY_SECONDS: constant(uint256) = 60 * 60 * 24\nONE_WEEK_SECONDS: constant(uint256) = ONE_DAY_SECONDS * 7\nHUNDRED_PERCENT: constant(uint256) = 100_00\n\n\n@deploy\ndef __init__(_shouldPause: bool):\n    self.isPaused = _shouldPause\n    self.numAssets = 1 # not using 0 index\n\n    # default snapshot price config\n    self.snapShotPriceConfig = ls.SnapShotPriceConfig(\n        minSnapshotDelay = 60 * 10, # 10 minutes\n        maxNumSnapshots = 20,\n        maxUpsideDeviation = 10_00, # 10%\n        staleTime = 3 * ONE_DAY_SECONDS, # 3 days\n    )\n\n\n#########\n# Views #\n#########\n\n\n# is lego asset\n\n\n@view\n@external\ndef isLegoAsset(_asset: address) -> bool:\n    return self._isLegoAsset(_asset)\n\n\n@view\n@internal\ndef _isLegoAsset(_asset: address) -> bool:\n    return self.indexOfAsset[_asset] != 0\n\n\n# vault opportunities\n\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, MAX_VAULTS]:\n    numOpportunities: uint256 = self.numAssetOpportunities[_asset]\n    if numOpportunities == 0:\n        return []\n    opportunities: DynArray[address, MAX_VAULTS] = []\n    for i: uint256 in range(1, numOpportunities, bound=MAX_VAULTS):\n        opportunities.append(self.assetOpportunities[_asset][i])\n    return opportunities\n\n\n# all assets registered\n\n\n@view\n@external\ndef getAssets() -> DynArray[address, MAX_ASSETS]:\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return []\n    assets: DynArray[address, MAX_ASSETS] = []\n    for i: uint256 in range(1, numAssets, bound=MAX_ASSETS):\n        assets.append(self.assets[i])\n    return assets\n\n\n################\n# Registration #\n################\n\n\n@view\n@external\ndef isAssetOpportunity(_asset: address, _vaultAddr: address) -> bool:\n    return self._isAssetOpportunity(_asset, _vaultAddr)\n\n\n@view\n@internal\ndef _isAssetOpportunity(_asset: address, _vaultAddr: address) -> bool:\n    return self.indexOfAssetOpportunity[_asset][_vaultAddr] != 0\n\n\n# add asset opportunity\n\n\n@internal\ndef _addAssetOpportunity(_asset: address, _vaultAddr: address) -> ls.VaultTokenInfo:\n    if self.indexOfAssetOpportunity[_asset][_vaultAddr] != 0:\n        return self.vaultToAsset[_vaultAddr]\n\n    if empty(address) in [_asset, _vaultAddr]:\n        return empty(ls.VaultTokenInfo)\n\n    # add asset opportunity\n    aid: uint256 = self.numAssetOpportunities[_asset]\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.assetOpportunities[_asset][aid] = _vaultAddr\n    self.indexOfAssetOpportunity[_asset][_vaultAddr] = aid\n    self.numAssetOpportunities[_asset] = aid + 1\n\n    # add mapping\n    vaultInfo: ls.VaultTokenInfo = ls.VaultTokenInfo(\n        underlyingAsset = _asset,\n        decimals = convert(staticcall IERC20Detailed(_vaultAddr).decimals(), uint256),\n        lastAveragePricePerShare = 0,\n    )\n    self.vaultToAsset[_vaultAddr] = vaultInfo\n\n    # add asset\n    self._addAsset(_asset)\n\n    log AssetOpportunityAdded(asset=_asset, vaultAddr=_vaultAddr)\n    return vaultInfo\n\n\n# remove asset opportunity\n\n\n@internal\ndef _removeAssetOpportunity(_asset: address, _vaultAddr: address):\n    numOpportunities: uint256 = self.numAssetOpportunities[_asset]\n    if numOpportunities == 0:\n        return\n\n    targetIndex: uint256 = self.indexOfAssetOpportunity[_asset][_vaultAddr]\n    if targetIndex == 0:\n        return\n\n    # update data\n    lastIndex: uint256 = numOpportunities - 1\n    self.numAssetOpportunities[_asset] = lastIndex\n    self.indexOfAssetOpportunity[_asset][_vaultAddr] = 0\n\n    self.vaultToAsset[_vaultAddr] = empty(ls.VaultTokenInfo)\n\n    # shift to replace the removed one\n    if targetIndex != lastIndex:\n        lastVaultAddr: address = self.assetOpportunities[_asset][lastIndex]\n        self.assetOpportunities[_asset][targetIndex] = lastVaultAddr\n        self.indexOfAssetOpportunity[_asset][lastVaultAddr] = targetIndex\n\n    # remove asset\n    if lastIndex <= 1:\n        self._removeAsset(_asset)\n\n    log AssetOpportunityRemoved(asset=_asset, vaultAddr=_vaultAddr)\n\n\n# add asset\n\n\n@internal\ndef _addAsset(_asset: address):\n    if self.indexOfAsset[_asset] != 0:\n        return\n\n    aid: uint256 = self.numAssets\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.assets[aid] = _asset\n    self.indexOfAsset[_asset] = aid\n    self.numAssets = aid + 1\n\n\n# remove asset\n\n\n@internal\ndef _removeAsset(_asset: address):\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return\n\n    targetIndex: uint256 = self.indexOfAsset[_asset]\n    if targetIndex == 0:\n        return\n\n    # update data\n    lastIndex: uint256 = numAssets - 1\n    self.numAssets = lastIndex\n    self.indexOfAsset[_asset] = 0\n\n    # shift to replace the removed one\n    if targetIndex != lastIndex:\n        lastAsset: address = self.assets[lastIndex]\n        self.assets[targetIndex] = lastAsset\n        self.indexOfAsset[lastAsset] = targetIndex\n\n\n# num lego assets (true number, use `numAssets` for iteration)\n\n\n@view\n@external\ndef getNumLegoAssets() -> uint256:\n    return self._getNumLegoAssets()\n\n\n@view\n@internal\ndef _getNumLegoAssets() -> uint256:\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return 0\n    return numAssets - 1\n\n\n###########\n# General #\n###########\n\n\n# fill mini addys\n\n\n@view\n@internal\ndef _getMiniAddys(_miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> ws.MiniAddys:\n    if _miniAddys.ledger != empty(address):\n        return _miniAddys\n    return ws.MiniAddys(\n        ledger = addys._getLedgerAddr(),\n        missionControl = addys._getMissionControlAddr(),\n        legoBook = addys._getLegoBookAddr(),\n        appraiser = addys._getAppraiserAddr(),\n    )\n\n\n# activate\n\n\n@external\ndef pause(_shouldPause: bool):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert _shouldPause != self.isPaused # dev: no change\n    self.isPaused = _shouldPause\n    log LegoPauseModified(isPaused=_shouldPause)\n\n\n# recover funds\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    self._recoverFunds(_recipient, _asset)\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, MAX_RECOVER_ASSETS]):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    for a: address in _assets:\n        self._recoverFunds(_recipient, a)\n\n\n@internal\ndef _recoverFunds(_recipient: address, _asset: address):\n    assert empty(address) not in [_recipient, _asset] # dev: invalid recipient or asset\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    assert balance != 0 # dev: nothing to recover\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log LegoFundsRecovered(asset=_asset, recipient=_recipient, balance=balance)\n\n\n###################\n# Price Snapshots #\n###################\n\n\n# add price snapshot\n\n\n@internal\ndef _addPriceSnapshot(_vaultToken: address, _pricePerShare: uint256, _vaultTokenDecimals: uint256) -> bool:\n    config: ls.SnapShotPriceConfig = self.snapShotPriceConfig\n    if config.maxNumSnapshots == 0:\n        return False\n\n    data: ls.SnapShotData = self.snapShotData[_vaultToken]\n\n    # already have snapshot for this time\n    if data.lastSnapShot.lastUpdate == block.timestamp:\n        return False\n\n    # check if snapshot is too recent\n    if data.lastSnapShot.lastUpdate + config.minSnapshotDelay > block.timestamp:\n        return False\n\n    # create and store new snapshot\n    newSnapshot: ls.SingleSnapShot = self._getLatestSnapshot(_vaultToken, _pricePerShare, _vaultTokenDecimals, data.lastSnapShot, config)\n    data.lastSnapShot = newSnapshot\n    self.snapShots[_vaultToken][data.nextIndex] = newSnapshot\n\n    # update index\n    data.nextIndex += 1\n    if data.nextIndex >= config.maxNumSnapshots:\n        data.nextIndex = 0\n\n    # save snap shot data\n    self.snapShotData[_vaultToken] = data\n\n    # update cached weighted average price per share\n    self.vaultToAsset[_vaultToken].lastAveragePricePerShare = self._getWeightedPricePerShare(_vaultToken, _pricePerShare)\n\n    log PricePerShareSnapShotAdded(\n        vaultToken = _vaultToken,\n        totalSupply = newSnapshot.totalSupply,\n        pricePerShare = newSnapshot.pricePerShare,\n    )\n    return True\n\n\n# weighted price per share\n\n\n@view\n@external\ndef getWeightedPricePerShare(_vaultToken: address) -> uint256:\n    data: ls.SnapShotData = self.snapShotData[_vaultToken]\n    return self._getWeightedPricePerShare(_vaultToken, data.lastSnapShot.pricePerShare)\n\n\n@view\n@internal\ndef _getWeightedPricePerShare(_vaultToken: address, _lastPricePerShare: uint256) -> uint256:\n    config: ls.SnapShotPriceConfig = self.snapShotPriceConfig\n    if config.maxNumSnapshots == 0:\n        return 0\n\n    # calculate weighted average price using all valid snapshots\n    numerator: uint256 = 0\n    denominator: uint256 = 0\n    for i: uint256 in range(config.maxNumSnapshots, bound=max_value(uint256)):\n\n        snapShot: ls.SingleSnapShot = self.snapShots[_vaultToken][i]\n        if snapShot.pricePerShare == 0 or snapShot.totalSupply == 0 or snapShot.lastUpdate == 0:\n            continue\n\n        # too stale, skip\n        if config.staleTime != 0 and block.timestamp > snapShot.lastUpdate + config.staleTime:\n            continue\n\n        numerator += (snapShot.totalSupply * snapShot.pricePerShare)\n        denominator += snapShot.totalSupply\n\n    # weighted price per share\n    weightedPricePerShare: uint256 = 0\n    if numerator != 0:\n        weightedPricePerShare = numerator // denominator\n    else:\n        weightedPricePerShare = _lastPricePerShare\n\n    return weightedPricePerShare\n\n\n# latest snapshot\n\n\n@view\n@external\ndef getLatestSnapshot(_vaultToken: address, _pricePerShare: uint256) -> ls.SingleSnapShot:\n    data: ls.SnapShotData = self.snapShotData[_vaultToken]\n    config: ls.SnapShotPriceConfig = self.snapShotPriceConfig\n    vaultTokenDecimals: uint256 = self.vaultToAsset[_vaultToken].decimals\n    return self._getLatestSnapshot(_vaultToken, _pricePerShare, vaultTokenDecimals, data.lastSnapShot, config)\n\n\n@view\n@internal\ndef _getLatestSnapshot(\n    _vaultToken: address,\n    _pricePerShare: uint256,\n    _vaultTokenDecimals: uint256,\n    _lastSnapShot: ls.SingleSnapShot,\n    _config: ls.SnapShotPriceConfig,\n) -> ls.SingleSnapShot:\n\n    # total supply (adjusted)\n    totalSupply: uint256 = staticcall IERC20(_vaultToken).totalSupply() // (10 ** _vaultTokenDecimals)\n    if totalSupply == 0:\n        totalSupply = 1\n\n    # throttle upside (extra safety check)\n    pricePerShare: uint256 = self._throttleUpside(_pricePerShare, _lastSnapShot.pricePerShare, _config.maxUpsideDeviation)\n\n    return ls.SingleSnapShot(\n        totalSupply = totalSupply,\n        pricePerShare = pricePerShare,\n        lastUpdate = block.timestamp,\n    )\n\n\n@view\n@internal\ndef _throttleUpside(_newValue: uint256, _prevValue: uint256, _maxUpside: uint256) -> uint256:\n    if _maxUpside == 0 or _prevValue == 0 or _newValue == 0:\n        return _newValue\n    maxPricePerShare: uint256 = _prevValue + (_prevValue * _maxUpside // HUNDRED_PERCENT)\n    return min(_newValue, maxPricePerShare)\n\n\n# snapshot price config\n\n\n@external\ndef setSnapShotPriceConfig(_config: ls.SnapShotPriceConfig):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert self._isValidPriceConfig(_config) # dev: invalid config\n    self.snapShotPriceConfig = _config\n    log SnapShotPriceConfigSet(\n        minSnapshotDelay=_config.minSnapshotDelay,\n        maxNumSnapshots=_config.maxNumSnapshots,\n        maxUpsideDeviation=_config.maxUpsideDeviation,\n        staleTime=_config.staleTime\n    )\n\n\n@view\n@external\ndef isValidPriceConfig(_config: ls.SnapShotPriceConfig) -> bool:\n    return self._isValidPriceConfig(_config)\n\n\n@view\n@internal\ndef _isValidPriceConfig(_config: ls.SnapShotPriceConfig) -> bool:\n    if _config.minSnapshotDelay > ONE_WEEK_SECONDS:\n        return False\n    if _config.maxNumSnapshots == 0 or _config.maxNumSnapshots > 25:\n        return False\n    if _config.maxUpsideDeviation > HUNDRED_PERCENT:\n        return False\n    return _config.staleTime < ONE_WEEK_SECONDS",
            "sha256sum": "d695c6d3998cf2ed318a0da6f4f7918abf97661e10eb510ed996d815e65927e0"
          },
          "contracts/legos/yield/Wasabi.vy": {
            "content": "#     __   __ ___ _______ ___     ______       ___     _______ _______ _______ \n#    |  | |  |   |       |   |   |      |     |   |   |       |       |       |\n#    |  |_|  |   |    ___|   |   |  _    |    |   |   |    ___|    ___|   _   |\n#    |       |   |   |___|   |   | | |   |    |   |   |   |___|   | __|  | |  |\n#    |_     _|   |    ___|   |___| |_|   |    |   |___|    ___|   ||  |  |_|  |\n#      |   | |   |   |___|       |       |    |       |   |___|   |_| |       |\n#      |___| |___|_______|_______|______|     |_______|_______|_______|_______|\n#                                                                       \n#     \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n#     \u2551  ** Wasabi Protocol **              \u2551\n#     \u2551  Integration with Wasabi Protocol.  \u2551\n#     \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n#\n#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nimplements: Lego\nimplements: YieldLego\n\nexports: addys.__interface__\nexports: yld.__interface__\n\ninitializes: addys\ninitializes: yld[addys := addys]\n\nfrom interfaces import LegoPartner as Lego\nfrom interfaces import YieldLego as YieldLego\nfrom interfaces import WalletStructs as ws\nfrom interfaces import LegoStructs as ls\n\nimport contracts.modules.Addys as addys\nimport contracts.modules.YieldLegoData as yld\n\nfrom ethereum.ercs import IERC20\nfrom ethereum.ercs import IERC4626\n\ninterface Appraiser:\n    def getUsdValue(_asset: address, _amount: uint256, _missionControl: address = empty(address), _legoBook: address = empty(address), _ledger: address = empty(address)) -> uint256: view\n    def updatePriceAndGetUsdValue(_asset: address, _amount: uint256, _missionControl: address = empty(address), _legoBook: address = empty(address)) -> uint256: nonpayable\n\ninterface Ledger:\n    def setVaultToken(_vaultToken: address, _legoId: uint256, _underlyingAsset: address, _decimals: uint256, _isRebasing: bool): nonpayable\n    def isRegisteredVaultToken(_vaultToken: address) -> bool: view\n\ninterface WasabiRegistry:\n    def getVault(_asset: address) -> address: view\n\ninterface Registry:\n    def getRegId(_addr: address) -> uint256: view\n\nevent WasabiDeposit:\n    sender: indexed(address)\n    asset: indexed(address)\n    vaultToken: indexed(address)\n    assetAmountDeposited: uint256\n    usdValue: uint256\n    vaultTokenAmountReceived: uint256\n    recipient: address\n\nevent WasabiWithdrawal:\n    sender: indexed(address)\n    asset: indexed(address)\n    vaultToken: indexed(address)\n    assetAmountReceived: uint256\n    usdValue: uint256\n    vaultTokenAmountBurned: uint256\n    recipient: address\n\n# wasabi\nWASABI_LONG_POOL: public(immutable(address))\nWASABI_SHORT_POOL: public(immutable(address))\n\nMAX_TOKEN_PATH: constant(uint256) = 5\n\n\n@deploy\ndef __init__(_undyHq: address, _wasabiLongPool: address, _wasabiShortPool: address):\n    addys.__init__(_undyHq)\n    yld.__init__(False)\n\n    assert empty(address) not in [_wasabiLongPool, _wasabiShortPool] # dev: invalid addrs\n    WASABI_LONG_POOL = _wasabiLongPool\n    WASABI_SHORT_POOL = _wasabiShortPool\n\n\n@view\n@external\ndef hasCapability(_action: ws.ActionType) -> bool:\n    return _action in (\n        ws.ActionType.EARN_DEPOSIT | \n        ws.ActionType.EARN_WITHDRAW\n    )\n\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    return [WASABI_LONG_POOL, WASABI_SHORT_POOL]\n\n\n@view\n@external\ndef isYieldLego() -> bool:\n    return True\n\n\n@view\n@external\ndef isDexLego() -> bool:\n    return False\n\n\n###################\n# Underlying Data #\n###################\n\n\n# underlying asset\n\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    return self._getUnderlyingAsset(_vaultToken)\n\n\n@view\n@internal\ndef _getUnderlyingAsset(_vaultToken: address) -> address:\n    return yld.vaultToAsset[_vaultToken].underlyingAsset\n\n\n# underlying balances (both true and safe)\n\n\n@view\n@external\ndef getUnderlyingBalances(_vaultToken: address, _vaultTokenBalance: uint256) -> (uint256, uint256):\n    if _vaultTokenBalance == 0:\n        return 0, 0\n\n    trueUnderlying: uint256 = self._getUnderlyingAmount(_vaultToken, _vaultTokenBalance)\n    safeUnderlying: uint256 = self._getUnderlyingAmountSafe(_vaultToken, _vaultTokenBalance)\n    if safeUnderlying == 0:\n        safeUnderlying = trueUnderlying\n\n    return trueUnderlying, min(trueUnderlying, safeUnderlying)\n\n\n# underlying amount (true)\n\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    return self._getUnderlyingAmount(_vaultToken, _vaultTokenAmount)\n\n\n@view\n@internal\ndef _getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    return staticcall IERC4626(_vaultToken).convertToAssets(_vaultTokenAmount)\n\n\n# underlying amount (safe)\n\n\n@view\n@external\ndef getUnderlyingAmountSafe(_vaultToken: address, _vaultTokenBalance: uint256) -> uint256:\n    return self._getUnderlyingAmountSafe(_vaultToken, _vaultTokenBalance)\n\n\n@view\n@internal\ndef _getUnderlyingAmountSafe(_vaultToken: address, _vaultTokenBalance: uint256) -> uint256:\n    vaultInfo: ls.VaultTokenInfo = yld.vaultToAsset[_vaultToken]\n    if vaultInfo.decimals == 0:\n        return 0 # not registered\n\n    # safe underlying amount (using cached weighted average from snapshots)\n    return _vaultTokenBalance * vaultInfo.lastAveragePricePerShare // (10 ** vaultInfo.decimals)\n\n\n# underlying data (combined)\n\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> (address, uint256, uint256):\n    return self._getUnderlyingData(_vaultToken, _vaultTokenAmount, _appraiser)\n\n\n@view\n@internal\ndef _getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address) -> (address, uint256, uint256):\n    asset: address = self._getUnderlyingAsset(_vaultToken)\n    if asset == empty(address):\n        return empty(address), 0, 0 # invalid vault token\n    underlyingAmount: uint256 = self._getUnderlyingAmount(_vaultToken, _vaultTokenAmount)\n    usdValue: uint256 = self._getUsdValue(asset, underlyingAmount, _appraiser)\n    return asset, underlyingAmount, usdValue\n\n\n# usd value\n\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> uint256:\n    return self._getUsdValueOfVaultToken(_vaultToken, _vaultTokenAmount, _appraiser)\n\n\n@view\n@internal\ndef _getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address) -> uint256:\n    return self._getUnderlyingData(_vaultToken, _vaultTokenAmount, _appraiser)[2]\n\n\n@view\n@internal\ndef _getUsdValue(_asset: address, _amount: uint256, _appraiser: address) -> uint256:\n    appraiser: address = _appraiser\n    if _appraiser == empty(address):\n        appraiser = addys._getAppraiserAddr()\n    return staticcall Appraiser(appraiser).getUsdValue(_asset, _amount)\n\n\n###############\n# Other Utils #\n###############\n\n\n# basics\n\n\n@view\n@external\ndef isRebasing() -> bool:\n    return self._isRebasing()\n\n\n@view\n@internal\ndef _isRebasing() -> bool:\n    return False\n\n\n# price per share\n\n\n@view\n@external\ndef getPricePerShare(_vaultToken: address, _decimals: uint256 = 0) -> uint256:\n    decimals: uint256 = _decimals\n    if decimals == 0:\n        decimals = yld.vaultToAsset[_vaultToken].decimals\n    if decimals == 0:\n        return 0 # not registered\n    return self._getPricePerShare(_vaultToken, decimals)\n\n\n@view\n@internal\ndef _getPricePerShare(_vaultToken: address, _decimals: uint256) -> uint256:\n    return staticcall IERC4626(_vaultToken).convertToAssets(10 ** _decimals)\n\n\n# vault token amount\n\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    return staticcall IERC4626(_vaultToken).convertToShares(_assetAmount)\n\n\n# extras\n\n\n@view\n@external\ndef isEligibleVaultForTrialFunds(_vaultToken: address, _underlyingAsset: address) -> bool:\n    return False\n\n\n@view\n@external\ndef isEligibleForYieldBonus(_asset: address) -> bool:\n    return False\n\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    return staticcall IERC4626(_vaultToken).totalAssets()\n\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    # TODO: implement\n    return 0\n\n\n################\n# Registration #\n################\n\n\n# can vault be registered\n\n\n@view\n@external\ndef canRegisterVaultToken(_asset: address, _vaultToken: address) -> bool:\n    return self._canRegisterVaultToken(_asset, _vaultToken)\n\n\n@view\n@internal\ndef _canRegisterVaultToken(_asset: address, _vaultToken: address) -> bool:\n    if empty(address) in [_asset, _vaultToken]:\n        return False\n    if staticcall IERC4626(_vaultToken).asset() != _asset:\n        return False\n    return staticcall WasabiRegistry(WASABI_LONG_POOL).getVault(_asset) == _vaultToken or staticcall WasabiRegistry(WASABI_SHORT_POOL).getVault(_asset) == _vaultToken\n\n\n# register vault token locally\n\n\n@external\ndef registerVaultTokenLocally(_asset: address, _vaultAddr: address) -> ls.VaultTokenInfo:\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert self._canRegisterVaultToken(_asset, _vaultAddr) # dev: cannot register vault token\n    assert not yld._isAssetOpportunity(_asset, _vaultAddr) # dev: already registered\n    vaultInfo: ls.VaultTokenInfo = self._registerVaultTokenLocally(_asset, _vaultAddr)\n    self._registerVaultTokenGlobally(_asset, _vaultAddr, vaultInfo.decimals, addys._getLedgerAddr(), addys._getLegoBookAddr())\n    return vaultInfo\n\n\n@internal\ndef _registerVaultTokenLocally(_asset: address, _vaultAddr: address) -> ls.VaultTokenInfo:\n    assert extcall IERC20(_asset).approve(_vaultAddr, max_value(uint256), default_return_value=True) # dev: max approval failed\n    vaultInfo: ls.VaultTokenInfo = yld._addAssetOpportunity(_asset, _vaultAddr)\n    assert vaultInfo.decimals != 0 # dev: invalid vault token\n    return vaultInfo\n\n\n# remove vault token locally\n\n\n@external\ndef deregisterVaultTokenLocally(_asset: address, _vaultAddr: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert yld._isAssetOpportunity(_asset, _vaultAddr) # dev: already registered\n    self._deregisterVaultTokenLocally(_asset, _vaultAddr)\n\n\n@internal\ndef _deregisterVaultTokenLocally(_asset: address, _vaultAddr: address):\n    assert extcall IERC20(_asset).approve(_vaultAddr, 0, default_return_value=True) # dev: max approval failed\n    yld._removeAssetOpportunity(_asset, _vaultAddr)\n\n\n# ledger registration\n\n\n@internal\ndef _registerVaultTokenGlobally(_underlyingAsset: address, _vaultToken: address, _decimals: uint256, _ledger: address, _legoBook: address):\n    if not staticcall Ledger(_ledger).isRegisteredVaultToken(_vaultToken):\n        legoId: uint256 = staticcall Registry(_legoBook).getRegId(self)\n        extcall Ledger(_ledger).setVaultToken(_vaultToken, legoId, _underlyingAsset, _decimals, self._isRebasing())\n\n\n#################\n# Yield Actions #\n#################\n\n\n# add price snapshot\n\n\n@external\ndef addPriceSnapshot(_vaultToken: address) -> bool:\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    vaultInfo: ls.VaultTokenInfo = yld.vaultToAsset[_vaultToken]\n    assert vaultInfo.decimals != 0 # dev: not registered\n    pricePerShare: uint256 = self._getPricePerShare(_vaultToken, vaultInfo.decimals)\n    return yld._addPriceSnapshot(_vaultToken, pricePerShare, vaultInfo.decimals)\n\n\n# deposit\n\n\n@external\ndef depositForYield(\n    _asset: address,\n    _amount: uint256,\n    _vaultAddr: address,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, address, uint256, uint256):\n    assert not yld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = yld._getMiniAddys(_miniAddys)\n    vaultInfo: ls.VaultTokenInfo = self._getVaultInfoOnDeposit(_asset, _vaultAddr, miniAddys.ledger, miniAddys.legoBook)\n\n    # pre balances\n    preLegoBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n\n    # transfer deposit asset to this contract\n    depositAmount: uint256 = min(_amount, staticcall IERC20(_asset).balanceOf(msg.sender))\n    assert depositAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_asset).transferFrom(msg.sender, self, depositAmount, default_return_value=True) # dev: transfer failed\n\n    # deposit assets into lego partner\n    vaultTokenAmountReceived: uint256 = extcall IERC4626(_vaultAddr).deposit(depositAmount, _recipient)\n    assert vaultTokenAmountReceived != 0 # dev: no vault tokens received\n\n    # refund if full deposit didn't get through\n    currentLegoBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    refundAssetAmount: uint256 = 0\n    if currentLegoBalance > preLegoBalance:\n        refundAssetAmount = currentLegoBalance - preLegoBalance\n        assert extcall IERC20(_asset).transfer(msg.sender, refundAssetAmount, default_return_value=True) # dev: transfer failed\n        depositAmount -= refundAssetAmount\n\n    usdValue: uint256 = extcall Appraiser(miniAddys.appraiser).updatePriceAndGetUsdValue(_asset, depositAmount, miniAddys.missionControl, miniAddys.legoBook)\n    log WasabiDeposit(\n        sender = msg.sender,\n        asset = _asset,\n        vaultToken = _vaultAddr,\n        assetAmountDeposited = depositAmount,\n        usdValue = usdValue,\n        vaultTokenAmountReceived = vaultTokenAmountReceived,\n        recipient = _recipient,\n    )\n\n    # add price snapshot\n    pricePerShare: uint256 = self._getPricePerShare(_vaultAddr, vaultInfo.decimals)\n    yld._addPriceSnapshot(_vaultAddr, pricePerShare, vaultInfo.decimals)\n\n    return depositAmount, _vaultAddr, vaultTokenAmountReceived, usdValue\n\n\n# vault info on deposit\n\n\n@internal\ndef _getVaultInfoOnDeposit(_asset: address, _vaultAddr: address, _ledger: address, _legoBook: address) -> ls.VaultTokenInfo:\n    vaultInfo: ls.VaultTokenInfo = yld.vaultToAsset[_vaultAddr]\n    if vaultInfo.decimals == 0:\n        assert self._canRegisterVaultToken(_asset, _vaultAddr) # dev: cannot register vault token\n        vaultInfo = self._registerVaultTokenLocally(_asset, _vaultAddr)\n        self._registerVaultTokenGlobally(_asset, _vaultAddr, vaultInfo.decimals, _ledger, _legoBook)\n    else:\n        assert vaultInfo.underlyingAsset == _asset # dev: asset mismatch\n    return vaultInfo\n\n\n# withdraw\n\n\n@external\ndef withdrawFromYield(\n    _vaultToken: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, address, uint256, uint256):\n    assert not yld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = yld._getMiniAddys(_miniAddys)\n    vaultInfo: ls.VaultTokenInfo = self._getVaultInfoOnWithdrawal(_vaultToken, miniAddys.ledger, miniAddys.legoBook)\n\n    # pre balances\n    preLegoVaultBalance: uint256 = staticcall IERC20(_vaultToken).balanceOf(self)\n\n    # transfer vaults tokens to this contract\n    vaultTokenAmount: uint256 = min(_amount, staticcall IERC20(_vaultToken).balanceOf(msg.sender))\n    assert vaultTokenAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_vaultToken).transferFrom(msg.sender, self, vaultTokenAmount, default_return_value=True) # dev: transfer failed\n\n    # withdraw assets from lego partner\n    assetAmountReceived: uint256 = extcall IERC4626(_vaultToken).redeem(vaultTokenAmount, _recipient, self)\n    assert assetAmountReceived != 0 # dev: no asset amount received\n\n    # refund if full withdrawal didn't happen\n    currentLegoVaultBalance: uint256 = staticcall IERC20(_vaultToken).balanceOf(self)\n    refundVaultTokenAmount: uint256 = 0\n    if currentLegoVaultBalance > preLegoVaultBalance:\n        refundVaultTokenAmount = currentLegoVaultBalance - preLegoVaultBalance\n        assert extcall IERC20(_vaultToken).transfer(msg.sender, refundVaultTokenAmount, default_return_value=True) # dev: transfer failed\n        vaultTokenAmount -= refundVaultTokenAmount\n\n    usdValue: uint256 = extcall Appraiser(miniAddys.appraiser).updatePriceAndGetUsdValue(vaultInfo.underlyingAsset, assetAmountReceived, miniAddys.missionControl, miniAddys.legoBook)\n    log WasabiWithdrawal(\n        sender = msg.sender,\n        asset = vaultInfo.underlyingAsset,\n        vaultToken = _vaultToken,\n        assetAmountReceived = assetAmountReceived,\n        usdValue = usdValue,\n        vaultTokenAmountBurned = vaultTokenAmount,\n        recipient = _recipient,\n    )\n\n    # add price snapshot\n    pricePerShare: uint256 = self._getPricePerShare(_vaultToken, vaultInfo.decimals)\n    yld._addPriceSnapshot(_vaultToken, pricePerShare, vaultInfo.decimals)\n\n    return vaultTokenAmount, vaultInfo.underlyingAsset, assetAmountReceived, usdValue\n\n\n# vault info on withdrawal\n\n\n@internal\ndef _getVaultInfoOnWithdrawal(_vaultAddr: address, _ledger: address, _legoBook: address) -> ls.VaultTokenInfo:\n    vaultInfo: ls.VaultTokenInfo = yld.vaultToAsset[_vaultAddr]\n    if vaultInfo.decimals == 0:\n        asset: address = staticcall IERC4626(_vaultAddr).asset()\n        assert self._canRegisterVaultToken(asset, _vaultAddr) # dev: cannot register vault token\n        vaultInfo = self._registerVaultTokenLocally(asset, _vaultAddr)\n        self._registerVaultTokenGlobally(asset, _vaultAddr, vaultInfo.decimals, _ledger, _legoBook)\n    return vaultInfo\n\n\n#########\n# Other #\n#########\n\n\n@view\n@external\ndef getAccessForLego(_user: address, _action: ws.ActionType) -> (address, String[64], uint256):\n    return empty(address), empty(String[64]), 0\n\n\n@external\ndef claimRewards(\n    _user: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _extraData: bytes32,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@view\n@external\ndef hasClaimableRewards(_user: address) -> bool:\n    return False\n\n\n@external\ndef swapTokens(\n    _amountIn: uint256,\n    _minAmountOut: uint256,\n    _tokenPath: DynArray[address, MAX_TOKEN_PATH],\n    _poolPath: DynArray[address, MAX_TOKEN_PATH - 1],\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256):\n    return 0, 0, 0\n\n\n@external\ndef mintOrRedeemAsset(\n    _tokenIn: address,\n    _tokenOut: address,\n    _tokenInAmount: uint256,\n    _minAmountOut: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, bool, uint256):\n    return 0, 0, False, 0\n\n\n@external\ndef confirmMintOrRedeemAsset(\n    _tokenIn: address,\n    _tokenOut: address,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef addCollateral(\n    _asset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef removeCollateral(\n    _asset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef borrow(\n    _borrowAsset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef repayDebt(\n    _paymentAsset: address,\n    _paymentAmount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef addLiquidity(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _amountA: uint256,\n    _amountB: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _minLpAmount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (address, uint256, uint256, uint256, uint256):\n    return empty(address), 0, 0, 0, 0\n\n\n@external\ndef removeLiquidity(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpToken: address,\n    _lpAmount: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, uint256):\n    return 0, 0, 0, 0\n\n\n@external\ndef addLiquidityConcentrated(\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _tickLower: int24,\n    _tickUpper: int24,\n    _amountA: uint256,\n    _amountB: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, uint256, uint256):\n    return 0, 0, 0, 0, 0\n\n\n@external\ndef removeLiquidityConcentrated(\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _liqToRemove: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, bool, uint256):\n    return 0, 0, 0, False, 0",
            "sha256sum": "51a1c7a05d4acf8d4ac3c6958776f510399121b5556eaa9d1e52050e04e64616"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/legos/yield/Wasabi.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.3+commit.bff19ea2",
        "integrity": "beb5e91be2aafd313f98c2f9f3d522ce474b1cdef9a8ae3b40a83350ca341373"
      },
      "args": "00000000000000000000000044cf3c4f000dfd76a35d03298049d37be688d6f9000000000000000000000000bdae5df498a45c5f058e3a09afe9ba4da7b248aa000000000000000000000000a456c77d358c9c89f4dfb294fa2a47470b7da37c",
      "file": "contracts/legos/yield/Wasabi.vy"
    },
    "Avantis": {
      "address": "0x0892aaCd679acEe2D840E3602E574cb906B84D42",
      "abi": [
        {
          "name": "AvantisDeposit",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountDeposited",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultTokenAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AvantisWithdrawal",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultTokenAmountBurned",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LegoPauseModified",
          "inputs": [
            {
              "name": "isPaused",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LegoFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "balance",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "SnapShotPriceConfigSet",
          "inputs": [
            {
              "name": "minSnapshotDelay",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "maxNumSnapshots",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "maxUpsideDeviation",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "staleTime",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetOpportunityAdded",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultAddr",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetOpportunityRemoved",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultAddr",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PricePerShareSnapShotAdded",
          "inputs": [
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "totalSupply",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "pricePerShare",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddys",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "undyToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "hatchery",
                  "type": "address"
                },
                {
                  "name": "lootDistributor",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                },
                {
                  "name": "walletBackpack",
                  "type": "address"
                },
                {
                  "name": "billing",
                  "type": "address"
                },
                {
                  "name": "vaultRegistry",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUndyHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isLegoAsset",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssetOpportunities",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isAssetOpportunity",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getNumLegoAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pause",
          "inputs": [
            {
              "name": "_shouldPause",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFundsMany",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_assets",
              "type": "address[]"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getWeightedPricePerShare",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLatestSnapshot",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_pricePerShare",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "totalSupply",
                  "type": "uint256"
                },
                {
                  "name": "pricePerShare",
                  "type": "uint256"
                },
                {
                  "name": "lastUpdate",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setSnapShotPriceConfig",
          "inputs": [
            {
              "name": "_config",
              "type": "tuple",
              "components": [
                {
                  "name": "minSnapshotDelay",
                  "type": "uint256"
                },
                {
                  "name": "maxNumSnapshots",
                  "type": "uint256"
                },
                {
                  "name": "maxUpsideDeviation",
                  "type": "uint256"
                },
                {
                  "name": "staleTime",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidPriceConfig",
          "inputs": [
            {
              "name": "_config",
              "type": "tuple",
              "components": [
                {
                  "name": "minSnapshotDelay",
                  "type": "uint256"
                },
                {
                  "name": "maxNumSnapshots",
                  "type": "uint256"
                },
                {
                  "name": "maxUpsideDeviation",
                  "type": "uint256"
                },
                {
                  "name": "staleTime",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "vaultToAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "underlyingAsset",
                  "type": "address"
                },
                {
                  "name": "decimals",
                  "type": "uint256"
                },
                {
                  "name": "lastAveragePricePerShare",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assetOpportunities",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAssetOpportunity",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssetOpportunities",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assets",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "snapShotData",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "lastSnapShot",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "totalSupply",
                      "type": "uint256"
                    },
                    {
                      "name": "pricePerShare",
                      "type": "uint256"
                    },
                    {
                      "name": "lastUpdate",
                      "type": "uint256"
                    }
                  ]
                },
                {
                  "name": "nextIndex",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "snapShots",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "totalSupply",
                  "type": "uint256"
                },
                {
                  "name": "pricePerShare",
                  "type": "uint256"
                },
                {
                  "name": "lastUpdate",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "snapShotPriceConfig",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "minSnapshotDelay",
                  "type": "uint256"
                },
                {
                  "name": "maxNumSnapshots",
                  "type": "uint256"
                },
                {
                  "name": "maxUpsideDeviation",
                  "type": "uint256"
                },
                {
                  "name": "staleTime",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isPaused",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasCapability",
          "inputs": [
            {
              "name": "_action",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRegistries",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isYieldLego",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isDexLego",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAsset",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingBalances",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenBalance",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAmount",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAmountSafe",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenBalance",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingData",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingData",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            },
            {
              "name": "_appraiser",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValueOfVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValueOfVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            },
            {
              "name": "_appraiser",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isRebasing",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPricePerShare",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPricePerShare",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_decimals",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getVaultTokenAmount",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_assetAmount",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isEligibleVaultForTrialFunds",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_underlyingAsset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isEligibleForYieldBonus",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalAssets",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalBorrows",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canRegisterVaultToken",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "registerVaultTokenLocally",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "underlyingAsset",
                  "type": "address"
                },
                {
                  "name": "decimals",
                  "type": "uint256"
                },
                {
                  "name": "lastAveragePricePerShare",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "deregisterVaultTokenLocally",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addPriceSnapshot",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositForYield",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositForYield",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawFromYield",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawFromYield",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAccessForLego",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_action",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "string"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasClaimableRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_tokenPath",
              "type": "address[]"
            },
            {
              "name": "_poolPath",
              "type": "address[]"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_tokenPath",
              "type": "address[]"
            },
            {
              "name": "_poolPath",
              "type": "address[]"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_tokenInAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_tokenInAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmMintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmMintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_borrowAsset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_borrowAsset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_paymentAsset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_paymentAsset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "AVANTIS_USDC_VAULT",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_undyHq",
              "type": "address"
            },
            {
              "name": "_avantisUsdcVault",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "interfaces/WalletStructs.vyi": {
            "content": "# @version 0.4.3\n\nflag ActionType:\n    TRANSFER\n    EARN_DEPOSIT\n    EARN_WITHDRAW\n    EARN_REBALANCE\n    SWAP\n    MINT_REDEEM\n    CONFIRM_MINT_REDEEM\n    ADD_COLLATERAL\n    REMOVE_COLLATERAL\n    BORROW\n    REPAY_DEBT\n    REWARDS\n    ETH_TO_WETH\n    WETH_TO_ETH\n    ADD_LIQ\n    REMOVE_LIQ\n    ADD_LIQ_CONC\n    REMOVE_LIQ_CONC\n    PAY_CHEQUE\n\nstruct WalletAssetData:\n    assetBalance: uint256\n    usdValue: uint256\n    isYieldAsset: bool\n    lastPricePerShare: uint256\n\nstruct ActionData:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    billing: address\n    wallet: address\n    walletConfig: address\n    walletOwner: address\n    inEjectMode: bool\n    isFrozen: bool\n    lastTotalUsdValue: uint256\n    signer: address\n    isManager: bool\n    legoId: uint256\n    legoAddr: address\n    eth: address\n    weth: address\n\nstruct MiniAddys:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    appraiser: address",
            "sha256sum": "9a4b4f59b3a62043e51b425a665064aae419a3c0bd0514b6b29a9441ae364bb9"
          },
          "interfaces/LegoPartner.vyi": {
            "content": "# @version 0.4.3\n\nfrom interfaces import WalletStructs as ws\n\nMAX_TOKEN_PATH: constant(uint256) = 5\nMAX_RECOVER_ASSETS: constant(uint256) = 20\n\n@external\ndef addLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _tickLower: int24, _tickUpper: int24, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef addLiquidity(_pool: address, _tokenA: address, _tokenB: address, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _minLpAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (address, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef removeLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _liqToRemove: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef removeLiquidity(_pool: address, _tokenA: address, _tokenB: address, _lpToken: address, _lpAmount: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef mintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _tokenInAmount: uint256, _minAmountOut: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef swapTokens(_amountIn: uint256, _minAmountOut: uint256, _tokenPath: DynArray[address, MAX_TOKEN_PATH], _poolPath: DynArray[address, MAX_TOKEN_PATH - 1], _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256):\n    ...\n\n@external\ndef depositForYield(_asset: address, _amount: uint256, _vaultAddr: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef withdrawFromYield(_vaultToken: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef confirmMintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef borrow(_borrowAsset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef repayDebt(_paymentAsset: address, _paymentAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef claimRewards(_user: address, _rewardToken: address, _rewardAmount: uint256, _extraData: bytes32, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef removeCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef addCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@view\n@external\ndef getAccessForLego(_user: address, _action: ws.ActionType) -> (address, String[64], uint256):\n    ...\n\n@view\n@external\ndef hasCapability(_action: ws.ActionType) -> bool:\n    ...\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    ...\n\n@view\n@external\ndef isYieldLego() -> bool:\n    ...\n\n@view\n@external\ndef isDexLego() -> bool:\n    ...\n\n\n# common\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "81db71fe4440a3b4b563134c9b5caf1d5705772a5f291fe874c9b5fb3cfb1623"
          },
          "interfaces/LegoStructs.vyi": {
            "content": "# @version 0.4.3\n\nstruct VaultTokenInfo:\n    underlyingAsset: address\n    decimals: uint256\n    lastAveragePricePerShare: uint256\n\nstruct SnapShotPriceConfig:\n    minSnapshotDelay: uint256\n    maxNumSnapshots: uint256\n    maxUpsideDeviation: uint256\n    staleTime: uint256\n\nstruct SingleSnapShot:\n    totalSupply: uint256\n    pricePerShare: uint256\n    lastUpdate: uint256\n\nstruct SnapShotData:\n    lastSnapShot: SingleSnapShot\n    nextIndex: uint256\n",
            "sha256sum": "8ae48be17d812d57fbd671bbf0593e8abf175ad0924e47c5997823cac19ec806"
          },
          "interfaces/YieldLego.vyi": {
            "content": "# @version 0.4.3\n\nfrom interfaces import LegoStructs as ls\n\n\n###################\n# Underlying Data #\n###################\n\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    ...\n\n\n@view\n@external\ndef getUnderlyingBalances(_vaultToken: address, _vaultTokenBalance: uint256) -> (uint256, uint256):\n    ...\n\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    ...\n\n\n@view\n@external\ndef getUnderlyingAmountSafe(_vaultToken: address, _vaultTokenBalance: uint256) -> uint256:\n    ...\n\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> (address, uint256, uint256):\n    ...\n\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> uint256:\n    ...\n\n\n###############\n# Other Utils #\n###############\n\n\n@view\n@external\ndef isRebasing() -> bool:\n    ...\n\n\n@view\n@external\ndef getPricePerShare(_vaultToken: address, _decimals: uint256 = 0) -> uint256:\n    ...\n\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef canRegisterVaultToken(_asset: address, _vaultToken: address) -> bool:\n    ...\n\n\n@view\n@external\ndef isEligibleVaultForTrialFunds(_vaultToken: address, _underlyingAsset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef isEligibleForYieldBonus(_asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    ...\n\n\n###################\n# Yield Lego Data #\n###################\n\n\n@view\n@external\ndef isLegoAsset(_asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, 40]:\n    ...\n\n\n@view\n@external\ndef getAssets() -> DynArray[address, 20]:\n    ...\n\n\n@view\n@external\ndef isAssetOpportunity(_asset: address, _vaultAddr: address) -> bool:\n    ...\n\n\n@view\n@external\ndef getNumLegoAssets() -> uint256:\n    ...\n\n\n@view\n@external\ndef assets(_index: uint256) -> address:\n    ...\n\n\n@view\n@external\ndef indexOfAsset(_asset: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef numAssets() -> uint256:\n    ...\n\n\n@view\n@external\ndef assetOpportunities(_asset: address, _index: uint256) -> address:\n    ...\n\n\n@view\n@external\ndef indexOfAssetOpportunity(_asset: address, _vaultAddr: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef numAssetOpportunities(_asset: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef vaultToAsset(_vaultAddr: address) -> ls.VaultTokenInfo:\n    ...\n\n\n# price snapshots\n\n\n@external\ndef addPriceSnapshot(_vaultToken: address) -> bool:\n    ...\n\n\n@view\n@external\ndef snapShotPriceConfig() -> ls.SnapShotPriceConfig:\n    ...\n\n\n@view\n@external\ndef snapShotData(_vaultToken: address) -> ls.SnapShotData:\n    ...\n\n\n@view\n@external\ndef snapShots(_vaultToken: address, _index: uint256) -> ls.SingleSnapShot:\n    ...\n\n\n@view\n@external\ndef getWeightedPricePerShare(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef getLatestSnapshot(_vaultToken: address, _pricePerShare: uint256) -> ls.SingleSnapShot:\n    ...\n\n\n@external\ndef setSnapShotPriceConfig(_config: ls.SnapShotPriceConfig):\n    ...\n",
            "sha256sum": "045a6bbd3d556234cf4fe925a303002dc0ac3c482d344ffbaf4bc52a7e6ad2df"
          },
          "contracts/modules/Addys.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\ninterface UndyHq:\n    def isValidAddr(_addr: address) -> bool: view\n    def getAddr(_regId: uint256) -> address: view\n    def undyToken() -> address: view\n\ninterface Switchboard:\n    def isSwitchboardAddr(_addr: address) -> bool: view\n\ninterface LegoBook:\n    def isLegoAddr(_addr: address) -> bool: view\n\nstruct Addys:\n    hq: address\n    undyToken: address\n    ledger: address\n    missionControl: address\n    legoBook: address\n    switchboard: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    walletBackpack: address\n    billing: address\n    vaultRegistry: address\n\n# hq\nUNDY_HQ_FOR_ADDYS: immutable(address)\n\n# core addys\nLEDGER_ID: constant(uint256) = 1\nMISSION_CONTROL_ID: constant(uint256) = 2\nLEGO_BOOK_ID: constant(uint256) = 3\nSWITCHBOARD_ID: constant(uint256) = 4\nHATCHERY_ID: constant(uint256) = 5\nLOOT_DISTRIBUTOR_ID: constant(uint256) = 6\nAPPRAISER_ID: constant(uint256) = 7\nWALLET_BACKPACK_ID: constant(uint256) = 8\nBILLING_ID: constant(uint256) = 9\nVAULT_REGISTRY_ID: constant(uint256) = 10\n\n\n@deploy\ndef __init__(_undyHq: address):\n    assert _undyHq != empty(address) # dev: invalid undy hq\n    UNDY_HQ_FOR_ADDYS = _undyHq\n\n\n########\n# Core #\n########\n\n\n@view\n@external\ndef getAddys() -> Addys:\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _getAddys(_addys: Addys = empty(Addys)) -> Addys:\n    if _addys.hq != empty(address):\n        return _addys\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _generateAddys() -> Addys:\n    hq: address = UNDY_HQ_FOR_ADDYS\n    return Addys(\n        hq = hq,\n        undyToken = staticcall UndyHq(hq).undyToken(),\n        ledger = staticcall UndyHq(hq).getAddr(LEDGER_ID),\n        missionControl = staticcall UndyHq(hq).getAddr(MISSION_CONTROL_ID),\n        legoBook = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID),\n        switchboard = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID),\n        hatchery = staticcall UndyHq(hq).getAddr(HATCHERY_ID),\n        lootDistributor = staticcall UndyHq(hq).getAddr(LOOT_DISTRIBUTOR_ID),\n        appraiser = staticcall UndyHq(hq).getAddr(APPRAISER_ID),\n        walletBackpack = staticcall UndyHq(hq).getAddr(WALLET_BACKPACK_ID),\n        billing = staticcall UndyHq(hq).getAddr(BILLING_ID),\n        vaultRegistry = staticcall UndyHq(hq).getAddr(VAULT_REGISTRY_ID),\n    )\n\n\n##########\n# Tokens #\n##########\n\n\n@view\n@internal\ndef _getUndyToken() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).undyToken()\n\n\n###########\n# Helpers #\n###########\n\n\n# undy hq\n\n\n@view\n@external\ndef getUndyHq() -> address:\n    return self._getUndyHq()\n\n\n@view\n@internal\ndef _getUndyHq() -> address:\n    return UNDY_HQ_FOR_ADDYS\n\n\n# utils\n\n\n@view\n@internal\ndef _isValidUndyAddr(_addr: address, _hq: address = empty(address)) -> bool:\n    hq: address = _hq\n    if _hq == empty(address):\n        hq = UNDY_HQ_FOR_ADDYS\n    \n    # core departments\n    if staticcall UndyHq(hq).isValidAddr(_addr):\n        return True\n\n    # lego book\n    legoBook: address = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID)\n    if legoBook != empty(address) and staticcall LegoBook(legoBook).isLegoAddr(_addr):\n        return True\n\n    # switchboard config\n    switchboard: address = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID)\n    if switchboard != empty(address) and staticcall Switchboard(switchboard).isSwitchboardAddr(_addr):\n        return True\n\n    return False\n\n\n@view\n@internal\ndef _isSwitchboardAddr(_addr: address) -> bool:\n    switchboard: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n    if switchboard == empty(address):\n        return False\n    return staticcall Switchboard(switchboard).isSwitchboardAddr(_addr)\n\n\n@view\n@internal\ndef _isLegoBookAddr(_addr: address) -> bool:\n    legoBook: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n    if legoBook == empty(address):\n        return False\n    return staticcall LegoBook(legoBook).isLegoAddr(_addr)\n\n\n###############\n# Departments #\n###############\n\n\n# ledger\n\n\n@view\n@internal\ndef _getLedgerId() -> uint256:\n    return LEDGER_ID\n\n\n@view\n@internal\ndef _getLedgerAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEDGER_ID)\n\n\n# mission control\n\n\n@view\n@internal\ndef _getMissionControlId() -> uint256:\n    return MISSION_CONTROL_ID\n\n\n@view\n@internal\ndef _getMissionControlAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(MISSION_CONTROL_ID)\n\n\n# lego book\n\n\n@view\n@internal\ndef _getLegoBookId() -> uint256:\n    return LEGO_BOOK_ID\n\n\n@view\n@internal\ndef _getLegoBookAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n\n\n# switchboard\n\n\n@view\n@internal\ndef _getSwitchboardId() -> uint256:\n    return SWITCHBOARD_ID\n\n\n@view\n@internal\ndef _getSwitchboardAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n\n\n# hatchery\n\n\n@view\n@internal\ndef _getHatcheryId() -> uint256:\n    return HATCHERY_ID\n\n\n@view\n@internal\ndef _getHatcheryAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(HATCHERY_ID)\n\n\n# loot distributor\n\n\n@view\n@internal\ndef _getLootDistributorId() -> uint256:\n    return LOOT_DISTRIBUTOR_ID\n\n\n@view\n@internal\ndef _getLootDistributorAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LOOT_DISTRIBUTOR_ID)\n\n\n# appraiser\n\n\n@view\n@internal\ndef _getAppraiserId() -> uint256:\n    return APPRAISER_ID\n\n\n@view\n@internal\ndef _getAppraiserAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(APPRAISER_ID)\n\n\n# wallet backpack\n\n\n@view\n@internal\ndef _getWalletBackpackId() -> uint256:\n    return WALLET_BACKPACK_ID\n\n\n@view\n@internal\ndef _getWalletBackpackAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(WALLET_BACKPACK_ID)\n\n\n# billing\n\n\n@view\n@internal\ndef _getBillingId() -> uint256:\n    return BILLING_ID\n\n\n@view\n@internal\ndef _getBillingAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(BILLING_ID)\n\n\n# vault registry\n\n\n@view\n@internal\ndef _getVaultRegistryId() -> uint256:\n    return VAULT_REGISTRY_ID\n\n\n@view\n@internal\ndef _getVaultRegistryAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(VAULT_REGISTRY_ID)",
            "sha256sum": "4df6b72db9bb417d1af81660175be1450cfb7b3575f3d17a5b8a130bff87b781"
          },
          "contracts/modules/YieldLegoData.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nuses: addys\n\nimport contracts.modules.Addys as addys\n\nfrom interfaces import WalletStructs as ws\nfrom interfaces import LegoStructs as ls\nfrom ethereum.ercs import IERC20\nfrom ethereum.ercs import IERC20Detailed\n\nevent AssetOpportunityAdded:\n    asset: indexed(address)\n    vaultAddr: indexed(address)\n\nevent AssetOpportunityRemoved:\n    asset: indexed(address)\n    vaultAddr: indexed(address)\n\nevent LegoPauseModified:\n    isPaused: bool\n\nevent LegoFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    balance: uint256\n\nevent PricePerShareSnapShotAdded:\n    vaultToken: indexed(address)\n    totalSupply: uint256\n    pricePerShare: uint256\n\nevent SnapShotPriceConfigSet:\n    minSnapshotDelay: uint256\n    maxNumSnapshots: uint256\n    maxUpsideDeviation: uint256\n    staleTime: uint256\n\n# core\nvaultToAsset: public(HashMap[address, ls.VaultTokenInfo]) # vault addr -> data\n\n# asset opportunities\nassetOpportunities: public(HashMap[address, HashMap[uint256, address]]) # asset -> index -> vault addr\nindexOfAssetOpportunity: public(HashMap[address, HashMap[address, uint256]]) # asset -> vault addr -> index\nnumAssetOpportunities: public(HashMap[address, uint256]) # asset -> number of opportunities\n\n# lego assets (iterable)\nassets: public(HashMap[uint256, address]) # index -> asset\nindexOfAsset: public(HashMap[address, uint256]) # asset -> index\nnumAssets: public(uint256) # num assets\n\n# price snapshots\nsnapShotData: public(HashMap[address, ls.SnapShotData]) # vault token -> data\nsnapShots: public(HashMap[address, HashMap[uint256, ls.SingleSnapShot]]) # vault token -> index -> snapshot\nsnapShotPriceConfig: public(ls.SnapShotPriceConfig) # config\n\nisPaused: public(bool)\n\nMAX_VAULTS: constant(uint256) = 40\nMAX_ASSETS: constant(uint256) = 20\nMAX_RECOVER_ASSETS: constant(uint256) = 20\nONE_DAY_SECONDS: constant(uint256) = 60 * 60 * 24\nONE_WEEK_SECONDS: constant(uint256) = ONE_DAY_SECONDS * 7\nHUNDRED_PERCENT: constant(uint256) = 100_00\n\n\n@deploy\ndef __init__(_shouldPause: bool):\n    self.isPaused = _shouldPause\n    self.numAssets = 1 # not using 0 index\n\n    # default snapshot price config\n    self.snapShotPriceConfig = ls.SnapShotPriceConfig(\n        minSnapshotDelay = 60 * 10, # 10 minutes\n        maxNumSnapshots = 20,\n        maxUpsideDeviation = 10_00, # 10%\n        staleTime = 3 * ONE_DAY_SECONDS, # 3 days\n    )\n\n\n#########\n# Views #\n#########\n\n\n# is lego asset\n\n\n@view\n@external\ndef isLegoAsset(_asset: address) -> bool:\n    return self._isLegoAsset(_asset)\n\n\n@view\n@internal\ndef _isLegoAsset(_asset: address) -> bool:\n    return self.indexOfAsset[_asset] != 0\n\n\n# vault opportunities\n\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, MAX_VAULTS]:\n    numOpportunities: uint256 = self.numAssetOpportunities[_asset]\n    if numOpportunities == 0:\n        return []\n    opportunities: DynArray[address, MAX_VAULTS] = []\n    for i: uint256 in range(1, numOpportunities, bound=MAX_VAULTS):\n        opportunities.append(self.assetOpportunities[_asset][i])\n    return opportunities\n\n\n# all assets registered\n\n\n@view\n@external\ndef getAssets() -> DynArray[address, MAX_ASSETS]:\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return []\n    assets: DynArray[address, MAX_ASSETS] = []\n    for i: uint256 in range(1, numAssets, bound=MAX_ASSETS):\n        assets.append(self.assets[i])\n    return assets\n\n\n################\n# Registration #\n################\n\n\n@view\n@external\ndef isAssetOpportunity(_asset: address, _vaultAddr: address) -> bool:\n    return self._isAssetOpportunity(_asset, _vaultAddr)\n\n\n@view\n@internal\ndef _isAssetOpportunity(_asset: address, _vaultAddr: address) -> bool:\n    return self.indexOfAssetOpportunity[_asset][_vaultAddr] != 0\n\n\n# add asset opportunity\n\n\n@internal\ndef _addAssetOpportunity(_asset: address, _vaultAddr: address) -> ls.VaultTokenInfo:\n    if self.indexOfAssetOpportunity[_asset][_vaultAddr] != 0:\n        return self.vaultToAsset[_vaultAddr]\n\n    if empty(address) in [_asset, _vaultAddr]:\n        return empty(ls.VaultTokenInfo)\n\n    # add asset opportunity\n    aid: uint256 = self.numAssetOpportunities[_asset]\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.assetOpportunities[_asset][aid] = _vaultAddr\n    self.indexOfAssetOpportunity[_asset][_vaultAddr] = aid\n    self.numAssetOpportunities[_asset] = aid + 1\n\n    # add mapping\n    vaultInfo: ls.VaultTokenInfo = ls.VaultTokenInfo(\n        underlyingAsset = _asset,\n        decimals = convert(staticcall IERC20Detailed(_vaultAddr).decimals(), uint256),\n        lastAveragePricePerShare = 0,\n    )\n    self.vaultToAsset[_vaultAddr] = vaultInfo\n\n    # add asset\n    self._addAsset(_asset)\n\n    log AssetOpportunityAdded(asset=_asset, vaultAddr=_vaultAddr)\n    return vaultInfo\n\n\n# remove asset opportunity\n\n\n@internal\ndef _removeAssetOpportunity(_asset: address, _vaultAddr: address):\n    numOpportunities: uint256 = self.numAssetOpportunities[_asset]\n    if numOpportunities == 0:\n        return\n\n    targetIndex: uint256 = self.indexOfAssetOpportunity[_asset][_vaultAddr]\n    if targetIndex == 0:\n        return\n\n    # update data\n    lastIndex: uint256 = numOpportunities - 1\n    self.numAssetOpportunities[_asset] = lastIndex\n    self.indexOfAssetOpportunity[_asset][_vaultAddr] = 0\n\n    self.vaultToAsset[_vaultAddr] = empty(ls.VaultTokenInfo)\n\n    # shift to replace the removed one\n    if targetIndex != lastIndex:\n        lastVaultAddr: address = self.assetOpportunities[_asset][lastIndex]\n        self.assetOpportunities[_asset][targetIndex] = lastVaultAddr\n        self.indexOfAssetOpportunity[_asset][lastVaultAddr] = targetIndex\n\n    # remove asset\n    if lastIndex <= 1:\n        self._removeAsset(_asset)\n\n    log AssetOpportunityRemoved(asset=_asset, vaultAddr=_vaultAddr)\n\n\n# add asset\n\n\n@internal\ndef _addAsset(_asset: address):\n    if self.indexOfAsset[_asset] != 0:\n        return\n\n    aid: uint256 = self.numAssets\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.assets[aid] = _asset\n    self.indexOfAsset[_asset] = aid\n    self.numAssets = aid + 1\n\n\n# remove asset\n\n\n@internal\ndef _removeAsset(_asset: address):\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return\n\n    targetIndex: uint256 = self.indexOfAsset[_asset]\n    if targetIndex == 0:\n        return\n\n    # update data\n    lastIndex: uint256 = numAssets - 1\n    self.numAssets = lastIndex\n    self.indexOfAsset[_asset] = 0\n\n    # shift to replace the removed one\n    if targetIndex != lastIndex:\n        lastAsset: address = self.assets[lastIndex]\n        self.assets[targetIndex] = lastAsset\n        self.indexOfAsset[lastAsset] = targetIndex\n\n\n# num lego assets (true number, use `numAssets` for iteration)\n\n\n@view\n@external\ndef getNumLegoAssets() -> uint256:\n    return self._getNumLegoAssets()\n\n\n@view\n@internal\ndef _getNumLegoAssets() -> uint256:\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return 0\n    return numAssets - 1\n\n\n###########\n# General #\n###########\n\n\n# fill mini addys\n\n\n@view\n@internal\ndef _getMiniAddys(_miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> ws.MiniAddys:\n    if _miniAddys.ledger != empty(address):\n        return _miniAddys\n    return ws.MiniAddys(\n        ledger = addys._getLedgerAddr(),\n        missionControl = addys._getMissionControlAddr(),\n        legoBook = addys._getLegoBookAddr(),\n        appraiser = addys._getAppraiserAddr(),\n    )\n\n\n# activate\n\n\n@external\ndef pause(_shouldPause: bool):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert _shouldPause != self.isPaused # dev: no change\n    self.isPaused = _shouldPause\n    log LegoPauseModified(isPaused=_shouldPause)\n\n\n# recover funds\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    self._recoverFunds(_recipient, _asset)\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, MAX_RECOVER_ASSETS]):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    for a: address in _assets:\n        self._recoverFunds(_recipient, a)\n\n\n@internal\ndef _recoverFunds(_recipient: address, _asset: address):\n    assert empty(address) not in [_recipient, _asset] # dev: invalid recipient or asset\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    assert balance != 0 # dev: nothing to recover\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log LegoFundsRecovered(asset=_asset, recipient=_recipient, balance=balance)\n\n\n###################\n# Price Snapshots #\n###################\n\n\n# add price snapshot\n\n\n@internal\ndef _addPriceSnapshot(_vaultToken: address, _pricePerShare: uint256, _vaultTokenDecimals: uint256) -> bool:\n    config: ls.SnapShotPriceConfig = self.snapShotPriceConfig\n    if config.maxNumSnapshots == 0:\n        return False\n\n    data: ls.SnapShotData = self.snapShotData[_vaultToken]\n\n    # already have snapshot for this time\n    if data.lastSnapShot.lastUpdate == block.timestamp:\n        return False\n\n    # check if snapshot is too recent\n    if data.lastSnapShot.lastUpdate + config.minSnapshotDelay > block.timestamp:\n        return False\n\n    # create and store new snapshot\n    newSnapshot: ls.SingleSnapShot = self._getLatestSnapshot(_vaultToken, _pricePerShare, _vaultTokenDecimals, data.lastSnapShot, config)\n    data.lastSnapShot = newSnapshot\n    self.snapShots[_vaultToken][data.nextIndex] = newSnapshot\n\n    # update index\n    data.nextIndex += 1\n    if data.nextIndex >= config.maxNumSnapshots:\n        data.nextIndex = 0\n\n    # save snap shot data\n    self.snapShotData[_vaultToken] = data\n\n    # update cached weighted average price per share\n    self.vaultToAsset[_vaultToken].lastAveragePricePerShare = self._getWeightedPricePerShare(_vaultToken, _pricePerShare)\n\n    log PricePerShareSnapShotAdded(\n        vaultToken = _vaultToken,\n        totalSupply = newSnapshot.totalSupply,\n        pricePerShare = newSnapshot.pricePerShare,\n    )\n    return True\n\n\n# weighted price per share\n\n\n@view\n@external\ndef getWeightedPricePerShare(_vaultToken: address) -> uint256:\n    data: ls.SnapShotData = self.snapShotData[_vaultToken]\n    return self._getWeightedPricePerShare(_vaultToken, data.lastSnapShot.pricePerShare)\n\n\n@view\n@internal\ndef _getWeightedPricePerShare(_vaultToken: address, _lastPricePerShare: uint256) -> uint256:\n    config: ls.SnapShotPriceConfig = self.snapShotPriceConfig\n    if config.maxNumSnapshots == 0:\n        return 0\n\n    # calculate weighted average price using all valid snapshots\n    numerator: uint256 = 0\n    denominator: uint256 = 0\n    for i: uint256 in range(config.maxNumSnapshots, bound=max_value(uint256)):\n\n        snapShot: ls.SingleSnapShot = self.snapShots[_vaultToken][i]\n        if snapShot.pricePerShare == 0 or snapShot.totalSupply == 0 or snapShot.lastUpdate == 0:\n            continue\n\n        # too stale, skip\n        if config.staleTime != 0 and block.timestamp > snapShot.lastUpdate + config.staleTime:\n            continue\n\n        numerator += (snapShot.totalSupply * snapShot.pricePerShare)\n        denominator += snapShot.totalSupply\n\n    # weighted price per share\n    weightedPricePerShare: uint256 = 0\n    if numerator != 0:\n        weightedPricePerShare = numerator // denominator\n    else:\n        weightedPricePerShare = _lastPricePerShare\n\n    return weightedPricePerShare\n\n\n# latest snapshot\n\n\n@view\n@external\ndef getLatestSnapshot(_vaultToken: address, _pricePerShare: uint256) -> ls.SingleSnapShot:\n    data: ls.SnapShotData = self.snapShotData[_vaultToken]\n    config: ls.SnapShotPriceConfig = self.snapShotPriceConfig\n    vaultTokenDecimals: uint256 = self.vaultToAsset[_vaultToken].decimals\n    return self._getLatestSnapshot(_vaultToken, _pricePerShare, vaultTokenDecimals, data.lastSnapShot, config)\n\n\n@view\n@internal\ndef _getLatestSnapshot(\n    _vaultToken: address,\n    _pricePerShare: uint256,\n    _vaultTokenDecimals: uint256,\n    _lastSnapShot: ls.SingleSnapShot,\n    _config: ls.SnapShotPriceConfig,\n) -> ls.SingleSnapShot:\n\n    # total supply (adjusted)\n    totalSupply: uint256 = staticcall IERC20(_vaultToken).totalSupply() // (10 ** _vaultTokenDecimals)\n    if totalSupply == 0:\n        totalSupply = 1\n\n    # throttle upside (extra safety check)\n    pricePerShare: uint256 = self._throttleUpside(_pricePerShare, _lastSnapShot.pricePerShare, _config.maxUpsideDeviation)\n\n    return ls.SingleSnapShot(\n        totalSupply = totalSupply,\n        pricePerShare = pricePerShare,\n        lastUpdate = block.timestamp,\n    )\n\n\n@view\n@internal\ndef _throttleUpside(_newValue: uint256, _prevValue: uint256, _maxUpside: uint256) -> uint256:\n    if _maxUpside == 0 or _prevValue == 0 or _newValue == 0:\n        return _newValue\n    maxPricePerShare: uint256 = _prevValue + (_prevValue * _maxUpside // HUNDRED_PERCENT)\n    return min(_newValue, maxPricePerShare)\n\n\n# snapshot price config\n\n\n@external\ndef setSnapShotPriceConfig(_config: ls.SnapShotPriceConfig):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert self._isValidPriceConfig(_config) # dev: invalid config\n    self.snapShotPriceConfig = _config\n    log SnapShotPriceConfigSet(\n        minSnapshotDelay=_config.minSnapshotDelay,\n        maxNumSnapshots=_config.maxNumSnapshots,\n        maxUpsideDeviation=_config.maxUpsideDeviation,\n        staleTime=_config.staleTime\n    )\n\n\n@view\n@external\ndef isValidPriceConfig(_config: ls.SnapShotPriceConfig) -> bool:\n    return self._isValidPriceConfig(_config)\n\n\n@view\n@internal\ndef _isValidPriceConfig(_config: ls.SnapShotPriceConfig) -> bool:\n    if _config.minSnapshotDelay > ONE_WEEK_SECONDS:\n        return False\n    if _config.maxNumSnapshots == 0 or _config.maxNumSnapshots > 25:\n        return False\n    if _config.maxUpsideDeviation > HUNDRED_PERCENT:\n        return False\n    return _config.staleTime < ONE_WEEK_SECONDS",
            "sha256sum": "d695c6d3998cf2ed318a0da6f4f7918abf97661e10eb510ed996d815e65927e0"
          },
          "contracts/legos/yield/Avantis.vy": {
            "content": "#     __   __ ___ _______ ___     ______       ___     _______ _______ _______ \n#    |  | |  |   |       |   |   |      |     |   |   |       |       |       |\n#    |  |_|  |   |    ___|   |   |  _    |    |   |   |    ___|    ___|   _   |\n#    |       |   |   |___|   |   | | |   |    |   |   |   |___|   | __|  | |  |\n#    |_     _|   |    ___|   |___| |_|   |    |   |___|    ___|   ||  |  |_|  |\n#      |   | |   |   |___|       |       |    |       |   |___|   |_| |       |\n#      |___| |___|_______|_______|______|     |_______|_______|_______|_______|\n#                                                                       \n#     \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n#     \u2551  ** Avantis **                      \u2551\n#     \u2551  Integration with Avantis Protocol. \u2551\n#     \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n#\n#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nimplements: Lego\nimplements: YieldLego\n\nexports: addys.__interface__\nexports: yld.__interface__\n\ninitializes: addys\ninitializes: yld[addys := addys]\n\nfrom interfaces import LegoPartner as Lego\nfrom interfaces import YieldLego as YieldLego\nfrom interfaces import WalletStructs as ws\nfrom interfaces import LegoStructs as ls\n\nimport contracts.modules.Addys as addys\nimport contracts.modules.YieldLegoData as yld\n\nfrom ethereum.ercs import IERC20\nfrom ethereum.ercs import IERC4626\n\ninterface Appraiser:\n    def getUsdValue(_asset: address, _amount: uint256, _missionControl: address = empty(address), _legoBook: address = empty(address), _ledger: address = empty(address)) -> uint256: view\n    def updatePriceAndGetUsdValue(_asset: address, _amount: uint256, _missionControl: address = empty(address), _legoBook: address = empty(address)) -> uint256: nonpayable\n\ninterface Ledger:\n    def setVaultToken(_vaultToken: address, _legoId: uint256, _underlyingAsset: address, _decimals: uint256, _isRebasing: bool): nonpayable\n    def isRegisteredVaultToken(_vaultToken: address) -> bool: view\n\ninterface Registry:\n    def getRegId(_addr: address) -> uint256: view\n\nevent AvantisDeposit:\n    sender: indexed(address)\n    asset: indexed(address)\n    vaultToken: indexed(address)\n    assetAmountDeposited: uint256\n    usdValue: uint256\n    vaultTokenAmountReceived: uint256\n    recipient: address\n\nevent AvantisWithdrawal:\n    sender: indexed(address)\n    asset: indexed(address)\n    vaultToken: indexed(address)\n    assetAmountReceived: uint256\n    usdValue: uint256\n    vaultTokenAmountBurned: uint256\n    recipient: address\n\nAVANTIS_USDC_VAULT: public(immutable(address))\nMAX_TOKEN_PATH: constant(uint256) = 5\n\n\n@deploy\ndef __init__(_undyHq: address, _avantisUsdcVault: address):\n    addys.__init__(_undyHq)\n    yld.__init__(False)\n\n    assert _avantisUsdcVault != empty(address) # dev: invalid addr\n    AVANTIS_USDC_VAULT = _avantisUsdcVault\n\n\n@view\n@external\ndef hasCapability(_action: ws.ActionType) -> bool:\n    return _action in (\n        ws.ActionType.EARN_DEPOSIT | \n        ws.ActionType.EARN_WITHDRAW\n    )\n\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    return []\n\n\n@view\n@external\ndef isYieldLego() -> bool:\n    return True\n\n\n@view\n@external\ndef isDexLego() -> bool:\n    return False\n\n\n###################\n# Underlying Data #\n###################\n\n\n# underlying asset\n\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    return self._getUnderlyingAsset(_vaultToken)\n\n\n@view\n@internal\ndef _getUnderlyingAsset(_vaultToken: address) -> address:\n    return yld.vaultToAsset[_vaultToken].underlyingAsset\n\n\n# underlying balances (both true and safe)\n\n\n@view\n@external\ndef getUnderlyingBalances(_vaultToken: address, _vaultTokenBalance: uint256) -> (uint256, uint256):\n    if _vaultTokenBalance == 0:\n        return 0, 0\n\n    trueUnderlying: uint256 = self._getUnderlyingAmount(_vaultToken, _vaultTokenBalance)\n    safeUnderlying: uint256 = self._getUnderlyingAmountSafe(_vaultToken, _vaultTokenBalance)\n    if safeUnderlying == 0:\n        safeUnderlying = trueUnderlying\n\n    return trueUnderlying, min(trueUnderlying, safeUnderlying)\n\n\n# underlying amount (true)\n\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    return self._getUnderlyingAmount(_vaultToken, _vaultTokenAmount)\n\n\n@view\n@internal\ndef _getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    return staticcall IERC4626(_vaultToken).convertToAssets(_vaultTokenAmount)\n\n\n# underlying amount (safe)\n\n\n@view\n@external\ndef getUnderlyingAmountSafe(_vaultToken: address, _vaultTokenBalance: uint256) -> uint256:\n    return self._getUnderlyingAmountSafe(_vaultToken, _vaultTokenBalance)\n\n\n@view\n@internal\ndef _getUnderlyingAmountSafe(_vaultToken: address, _vaultTokenBalance: uint256) -> uint256:\n    vaultInfo: ls.VaultTokenInfo = yld.vaultToAsset[_vaultToken]\n    if vaultInfo.decimals == 0:\n        return 0 # not registered\n\n    # safe underlying amount (using cached weighted average from snapshots)\n    return _vaultTokenBalance * vaultInfo.lastAveragePricePerShare // (10 ** vaultInfo.decimals)\n\n\n# underlying data (combined)\n\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> (address, uint256, uint256):\n    return self._getUnderlyingData(_vaultToken, _vaultTokenAmount, _appraiser)\n\n\n@view\n@internal\ndef _getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address) -> (address, uint256, uint256):\n    asset: address = self._getUnderlyingAsset(_vaultToken)\n    if asset == empty(address):\n        return empty(address), 0, 0 # invalid vault token\n    underlyingAmount: uint256 = self._getUnderlyingAmount(_vaultToken, _vaultTokenAmount)\n    usdValue: uint256 = self._getUsdValue(asset, underlyingAmount, _appraiser)\n    return asset, underlyingAmount, usdValue\n\n\n# usd value\n\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> uint256:\n    return self._getUsdValueOfVaultToken(_vaultToken, _vaultTokenAmount, _appraiser)\n\n\n@view\n@internal\ndef _getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address) -> uint256:\n    return self._getUnderlyingData(_vaultToken, _vaultTokenAmount, _appraiser)[2]\n\n\n@view\n@internal\ndef _getUsdValue(_asset: address, _amount: uint256, _appraiser: address) -> uint256:\n    appraiser: address = _appraiser\n    if _appraiser == empty(address):\n        appraiser = addys._getAppraiserAddr()\n    return staticcall Appraiser(appraiser).getUsdValue(_asset, _amount)\n\n\n###############\n# Other Utils #\n###############\n\n\n# basics\n\n\n@view\n@external\ndef isRebasing() -> bool:\n    return self._isRebasing()\n\n\n@view\n@internal\ndef _isRebasing() -> bool:\n    return False\n\n\n# price per share\n\n\n@view\n@external\ndef getPricePerShare(_vaultToken: address, _decimals: uint256 = 0) -> uint256:\n    decimals: uint256 = _decimals\n    if decimals == 0:\n        decimals = yld.vaultToAsset[_vaultToken].decimals\n    if decimals == 0:\n        return 0 # not registered\n    return self._getPricePerShare(_vaultToken, decimals)\n\n\n@view\n@internal\ndef _getPricePerShare(_vaultToken: address, _decimals: uint256) -> uint256:\n    return staticcall IERC4626(_vaultToken).convertToAssets(10 ** _decimals)\n\n\n# vault token amount\n\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    return staticcall IERC4626(_vaultToken).convertToShares(_assetAmount)\n\n\n# extras\n\n\n@view\n@external\ndef isEligibleVaultForTrialFunds(_vaultToken: address, _underlyingAsset: address) -> bool:\n    return False\n\n\n@view\n@external\ndef isEligibleForYieldBonus(_asset: address) -> bool:\n    return False\n\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    return staticcall IERC4626(_vaultToken).totalAssets()\n\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    # TODO: implement\n    return 0\n\n\n################\n# Registration #\n################\n\n\n# can vault be registered\n\n\n@view\n@external\ndef canRegisterVaultToken(_asset: address, _vaultToken: address) -> bool:\n    return self._canRegisterVaultToken(_asset, _vaultToken)\n\n\n@view\n@internal\ndef _canRegisterVaultToken(_asset: address, _vaultToken: address) -> bool:\n    if empty(address) in [_asset, _vaultToken]:\n        return False\n    return staticcall IERC4626(_vaultToken).asset() == _asset and _vaultToken == AVANTIS_USDC_VAULT\n\n\n# register vault token locally\n\n\n@external\ndef registerVaultTokenLocally(_asset: address, _vaultAddr: address) -> ls.VaultTokenInfo:\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert self._canRegisterVaultToken(_asset, _vaultAddr) # dev: cannot register vault token\n    assert not yld._isAssetOpportunity(_asset, _vaultAddr) # dev: already registered\n    vaultInfo: ls.VaultTokenInfo = self._registerVaultTokenLocally(_asset, _vaultAddr)\n    self._registerVaultTokenGlobally(_asset, _vaultAddr, vaultInfo.decimals, addys._getLedgerAddr(), addys._getLegoBookAddr())\n    return vaultInfo\n\n\n@internal\ndef _registerVaultTokenLocally(_asset: address, _vaultAddr: address) -> ls.VaultTokenInfo:\n    assert extcall IERC20(_asset).approve(_vaultAddr, max_value(uint256), default_return_value=True) # dev: max approval failed\n    vaultInfo: ls.VaultTokenInfo = yld._addAssetOpportunity(_asset, _vaultAddr)\n    assert vaultInfo.decimals != 0 # dev: invalid vault token\n    return vaultInfo\n\n\n# remove vault token locally\n\n\n@external\ndef deregisterVaultTokenLocally(_asset: address, _vaultAddr: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert yld._isAssetOpportunity(_asset, _vaultAddr) # dev: already registered\n    self._deregisterVaultTokenLocally(_asset, _vaultAddr)\n\n\n@internal\ndef _deregisterVaultTokenLocally(_asset: address, _vaultAddr: address):\n    assert extcall IERC20(_asset).approve(_vaultAddr, 0, default_return_value=True) # dev: max approval failed\n    yld._removeAssetOpportunity(_asset, _vaultAddr)\n\n\n# ledger registration\n\n\n@internal\ndef _registerVaultTokenGlobally(_underlyingAsset: address, _vaultToken: address, _decimals: uint256, _ledger: address, _legoBook: address):\n    if not staticcall Ledger(_ledger).isRegisteredVaultToken(_vaultToken):\n        legoId: uint256 = staticcall Registry(_legoBook).getRegId(self)\n        extcall Ledger(_ledger).setVaultToken(_vaultToken, legoId, _underlyingAsset, _decimals, self._isRebasing())\n\n\n#################\n# Yield Actions #\n#################\n\n\n# add price snapshot\n\n\n@external\ndef addPriceSnapshot(_vaultToken: address) -> bool:\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    vaultInfo: ls.VaultTokenInfo = yld.vaultToAsset[_vaultToken]\n    assert vaultInfo.decimals != 0 # dev: not registered\n    pricePerShare: uint256 = self._getPricePerShare(_vaultToken, vaultInfo.decimals)\n    return yld._addPriceSnapshot(_vaultToken, pricePerShare, vaultInfo.decimals)\n\n\n# deposit\n\n\n@external\ndef depositForYield(\n    _asset: address,\n    _amount: uint256,\n    _vaultAddr: address,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, address, uint256, uint256):\n    assert not yld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = yld._getMiniAddys(_miniAddys)\n    vaultInfo: ls.VaultTokenInfo = self._getVaultInfoOnDeposit(_asset, _vaultAddr, miniAddys.ledger, miniAddys.legoBook)\n\n    # pre balances\n    preLegoBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n\n    # transfer deposit asset to this contract\n    depositAmount: uint256 = min(_amount, staticcall IERC20(_asset).balanceOf(msg.sender))\n    assert depositAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_asset).transferFrom(msg.sender, self, depositAmount, default_return_value=True) # dev: transfer failed\n\n    # deposit assets into lego partner\n    vaultTokenAmountReceived: uint256 = extcall IERC4626(_vaultAddr).deposit(depositAmount, _recipient)\n    assert vaultTokenAmountReceived != 0 # dev: no vault tokens received\n\n    # refund if full deposit didn't get through\n    currentLegoBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    refundAssetAmount: uint256 = 0\n    if currentLegoBalance > preLegoBalance:\n        refundAssetAmount = currentLegoBalance - preLegoBalance\n        assert extcall IERC20(_asset).transfer(msg.sender, refundAssetAmount, default_return_value=True) # dev: transfer failed\n        depositAmount -= refundAssetAmount\n\n    usdValue: uint256 = extcall Appraiser(miniAddys.appraiser).updatePriceAndGetUsdValue(_asset, depositAmount, miniAddys.missionControl, miniAddys.legoBook)\n    log AvantisDeposit(\n        sender = msg.sender,\n        asset = _asset,\n        vaultToken = _vaultAddr,\n        assetAmountDeposited = depositAmount,\n        usdValue = usdValue,\n        vaultTokenAmountReceived = vaultTokenAmountReceived,\n        recipient = _recipient,\n    )\n\n    # add price snapshot\n    pricePerShare: uint256 = self._getPricePerShare(_vaultAddr, vaultInfo.decimals)\n    yld._addPriceSnapshot(_vaultAddr, pricePerShare, vaultInfo.decimals)\n\n    return depositAmount, _vaultAddr, vaultTokenAmountReceived, usdValue\n\n\n# vault info on deposit\n\n\n@internal\ndef _getVaultInfoOnDeposit(_asset: address, _vaultAddr: address, _ledger: address, _legoBook: address) -> ls.VaultTokenInfo:\n    vaultInfo: ls.VaultTokenInfo = yld.vaultToAsset[_vaultAddr]\n    if vaultInfo.decimals == 0:\n        assert self._canRegisterVaultToken(_asset, _vaultAddr) # dev: cannot register vault token\n        vaultInfo = self._registerVaultTokenLocally(_asset, _vaultAddr)\n        self._registerVaultTokenGlobally(_asset, _vaultAddr, vaultInfo.decimals, _ledger, _legoBook)\n    else:\n        assert vaultInfo.underlyingAsset == _asset # dev: asset mismatch\n    return vaultInfo\n\n\n# withdraw\n\n\n@external\ndef withdrawFromYield(\n    _vaultToken: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, address, uint256, uint256):\n    assert not yld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = yld._getMiniAddys(_miniAddys)\n    vaultInfo: ls.VaultTokenInfo = self._getVaultInfoOnWithdrawal(_vaultToken, miniAddys.ledger, miniAddys.legoBook)\n\n    # pre balances\n    preLegoVaultBalance: uint256 = staticcall IERC20(_vaultToken).balanceOf(self)\n\n    # transfer vaults tokens to this contract\n    vaultTokenAmount: uint256 = min(_amount, staticcall IERC20(_vaultToken).balanceOf(msg.sender))\n    assert vaultTokenAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_vaultToken).transferFrom(msg.sender, self, vaultTokenAmount, default_return_value=True) # dev: transfer failed\n\n    # withdraw assets from lego partner\n    assetAmountReceived: uint256 = extcall IERC4626(_vaultToken).redeem(vaultTokenAmount, _recipient, self)\n    assert assetAmountReceived != 0 # dev: no asset amount received\n\n    # refund if full withdrawal didn't happen\n    currentLegoVaultBalance: uint256 = staticcall IERC20(_vaultToken).balanceOf(self)\n    refundVaultTokenAmount: uint256 = 0\n    if currentLegoVaultBalance > preLegoVaultBalance:\n        refundVaultTokenAmount = currentLegoVaultBalance - preLegoVaultBalance\n        assert extcall IERC20(_vaultToken).transfer(msg.sender, refundVaultTokenAmount, default_return_value=True) # dev: transfer failed\n        vaultTokenAmount -= refundVaultTokenAmount\n\n    usdValue: uint256 = extcall Appraiser(miniAddys.appraiser).updatePriceAndGetUsdValue(vaultInfo.underlyingAsset, assetAmountReceived, miniAddys.missionControl, miniAddys.legoBook)\n    log AvantisWithdrawal(\n        sender = msg.sender,\n        asset = vaultInfo.underlyingAsset,\n        vaultToken = _vaultToken,\n        assetAmountReceived = assetAmountReceived,\n        usdValue = usdValue,\n        vaultTokenAmountBurned = vaultTokenAmount,\n        recipient = _recipient,\n    )\n\n    # add price snapshot\n    pricePerShare: uint256 = self._getPricePerShare(_vaultToken, vaultInfo.decimals)\n    yld._addPriceSnapshot(_vaultToken, pricePerShare, vaultInfo.decimals)\n\n    return vaultTokenAmount, vaultInfo.underlyingAsset, assetAmountReceived, usdValue\n\n\n# vault info on withdrawal\n\n\n@internal\ndef _getVaultInfoOnWithdrawal(_vaultAddr: address, _ledger: address, _legoBook: address) -> ls.VaultTokenInfo:\n    vaultInfo: ls.VaultTokenInfo = yld.vaultToAsset[_vaultAddr]\n    if vaultInfo.decimals == 0:\n        asset: address = staticcall IERC4626(_vaultAddr).asset()\n        assert self._canRegisterVaultToken(asset, _vaultAddr) # dev: cannot register vault token\n        vaultInfo = self._registerVaultTokenLocally(asset, _vaultAddr)\n        self._registerVaultTokenGlobally(asset, _vaultAddr, vaultInfo.decimals, _ledger, _legoBook)\n    return vaultInfo\n\n\n#########\n# Other #\n#########\n\n\n@view\n@external\ndef getAccessForLego(_user: address, _action: ws.ActionType) -> (address, String[64], uint256):\n    return empty(address), empty(String[64]), 0\n\n\n@external\ndef claimRewards(\n    _user: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _extraData: bytes32,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@view\n@external\ndef hasClaimableRewards(_user: address) -> bool:\n    return False\n\n\n@external\ndef swapTokens(\n    _amountIn: uint256,\n    _minAmountOut: uint256,\n    _tokenPath: DynArray[address, MAX_TOKEN_PATH],\n    _poolPath: DynArray[address, MAX_TOKEN_PATH - 1],\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256):\n    return 0, 0, 0\n\n\n@external\ndef mintOrRedeemAsset(\n    _tokenIn: address,\n    _tokenOut: address,\n    _tokenInAmount: uint256,\n    _minAmountOut: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, bool, uint256):\n    return 0, 0, False, 0\n\n\n@external\ndef confirmMintOrRedeemAsset(\n    _tokenIn: address,\n    _tokenOut: address,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef addCollateral(\n    _asset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef removeCollateral(\n    _asset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef borrow(\n    _borrowAsset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef repayDebt(\n    _paymentAsset: address,\n    _paymentAmount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef addLiquidity(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _amountA: uint256,\n    _amountB: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _minLpAmount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (address, uint256, uint256, uint256, uint256):\n    return empty(address), 0, 0, 0, 0\n\n\n@external\ndef removeLiquidity(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpToken: address,\n    _lpAmount: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, uint256):\n    return 0, 0, 0, 0\n\n\n@external\ndef addLiquidityConcentrated(\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _tickLower: int24,\n    _tickUpper: int24,\n    _amountA: uint256,\n    _amountB: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, uint256, uint256):\n    return 0, 0, 0, 0, 0\n\n\n@external\ndef removeLiquidityConcentrated(\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _liqToRemove: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, bool, uint256):\n    return 0, 0, 0, False, 0",
            "sha256sum": "a05a38194b245cfc11e9f982e116b3506c6d8b70794f0b23d3ae618c2c56f1ba"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/legos/yield/Avantis.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.3+commit.bff19ea2",
        "integrity": "efb6a8711489339c05786dab8ac557cc66529cb20ac5a4ec51091e7c27757bfb"
      },
      "args": "00000000000000000000000044cf3c4f000dfd76a35d03298049d37be688d6f9000000000000000000000000944766f715b51967e56afde5f0aa76ceacc9e7f9",
      "file": "contracts/legos/yield/Avantis.vy"
    },
    "SkyPsm": {
      "address": "0x31C79e85549E55a038CE90B5470F173a1eD0784f",
      "abi": [
        {
          "name": "SkyPsmDeposit",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountDeposited",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultTokenAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "SkyPsmWithdrawal",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultTokenAmountBurned",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "SlippageSet",
          "inputs": [
            {
              "name": "slippage",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LegoPauseModified",
          "inputs": [
            {
              "name": "isPaused",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LegoFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "balance",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "SnapShotPriceConfigSet",
          "inputs": [
            {
              "name": "minSnapshotDelay",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "maxNumSnapshots",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "maxUpsideDeviation",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "staleTime",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetOpportunityAdded",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultAddr",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetOpportunityRemoved",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultAddr",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PricePerShareSnapShotAdded",
          "inputs": [
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "totalSupply",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "pricePerShare",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddys",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "undyToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "hatchery",
                  "type": "address"
                },
                {
                  "name": "lootDistributor",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                },
                {
                  "name": "walletBackpack",
                  "type": "address"
                },
                {
                  "name": "billing",
                  "type": "address"
                },
                {
                  "name": "vaultRegistry",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUndyHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isLegoAsset",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssetOpportunities",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isAssetOpportunity",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getNumLegoAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pause",
          "inputs": [
            {
              "name": "_shouldPause",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFundsMany",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_assets",
              "type": "address[]"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getWeightedPricePerShare",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLatestSnapshot",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_pricePerShare",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "totalSupply",
                  "type": "uint256"
                },
                {
                  "name": "pricePerShare",
                  "type": "uint256"
                },
                {
                  "name": "lastUpdate",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setSnapShotPriceConfig",
          "inputs": [
            {
              "name": "_config",
              "type": "tuple",
              "components": [
                {
                  "name": "minSnapshotDelay",
                  "type": "uint256"
                },
                {
                  "name": "maxNumSnapshots",
                  "type": "uint256"
                },
                {
                  "name": "maxUpsideDeviation",
                  "type": "uint256"
                },
                {
                  "name": "staleTime",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidPriceConfig",
          "inputs": [
            {
              "name": "_config",
              "type": "tuple",
              "components": [
                {
                  "name": "minSnapshotDelay",
                  "type": "uint256"
                },
                {
                  "name": "maxNumSnapshots",
                  "type": "uint256"
                },
                {
                  "name": "maxUpsideDeviation",
                  "type": "uint256"
                },
                {
                  "name": "staleTime",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "vaultToAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "underlyingAsset",
                  "type": "address"
                },
                {
                  "name": "decimals",
                  "type": "uint256"
                },
                {
                  "name": "lastAveragePricePerShare",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assetOpportunities",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAssetOpportunity",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssetOpportunities",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assets",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "snapShotData",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "lastSnapShot",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "totalSupply",
                      "type": "uint256"
                    },
                    {
                      "name": "pricePerShare",
                      "type": "uint256"
                    },
                    {
                      "name": "lastUpdate",
                      "type": "uint256"
                    }
                  ]
                },
                {
                  "name": "nextIndex",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "snapShots",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "totalSupply",
                  "type": "uint256"
                },
                {
                  "name": "pricePerShare",
                  "type": "uint256"
                },
                {
                  "name": "lastUpdate",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "snapShotPriceConfig",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "minSnapshotDelay",
                  "type": "uint256"
                },
                {
                  "name": "maxNumSnapshots",
                  "type": "uint256"
                },
                {
                  "name": "maxUpsideDeviation",
                  "type": "uint256"
                },
                {
                  "name": "staleTime",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isPaused",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasCapability",
          "inputs": [
            {
              "name": "_action",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRegistries",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isYieldLego",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isDexLego",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAsset",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingBalances",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenBalance",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAmount",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAmountSafe",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenBalance",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingData",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingData",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            },
            {
              "name": "_appraiser",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValueOfVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValueOfVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            },
            {
              "name": "_appraiser",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isRebasing",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPricePerShare",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPricePerShare",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_decimals",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getVaultTokenAmount",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_assetAmount",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isEligibleVaultForTrialFunds",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_underlyingAsset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isEligibleForYieldBonus",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalAssets",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalBorrows",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canRegisterVaultToken",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "registerVaultTokenLocally",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "underlyingAsset",
                  "type": "address"
                },
                {
                  "name": "decimals",
                  "type": "uint256"
                },
                {
                  "name": "lastAveragePricePerShare",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "deregisterVaultTokenLocally",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addPriceSnapshot",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositForYield",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositForYield",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawFromYield",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawFromYield",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setSlippage",
          "inputs": [
            {
              "name": "_slippage",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAccessForLego",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_action",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "string"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasClaimableRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_tokenPath",
              "type": "address[]"
            },
            {
              "name": "_poolPath",
              "type": "address[]"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_tokenPath",
              "type": "address[]"
            },
            {
              "name": "_poolPath",
              "type": "address[]"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_tokenInAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_tokenInAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmMintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmMintOrRedeemAsset",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeCollateral",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_borrowAsset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_borrowAsset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_paymentAsset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_paymentAsset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidityConcentrated",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_extraData",
              "type": "bytes32"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_miniAddys",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "slippage",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "SKY_PSM",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "USDS",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "SUSDS",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_undyHq",
              "type": "address"
            },
            {
              "name": "_skyPsm",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "interfaces/WalletStructs.vyi": {
            "content": "# @version 0.4.3\n\nflag ActionType:\n    TRANSFER\n    EARN_DEPOSIT\n    EARN_WITHDRAW\n    EARN_REBALANCE\n    SWAP\n    MINT_REDEEM\n    CONFIRM_MINT_REDEEM\n    ADD_COLLATERAL\n    REMOVE_COLLATERAL\n    BORROW\n    REPAY_DEBT\n    REWARDS\n    ETH_TO_WETH\n    WETH_TO_ETH\n    ADD_LIQ\n    REMOVE_LIQ\n    ADD_LIQ_CONC\n    REMOVE_LIQ_CONC\n    PAY_CHEQUE\n\nstruct WalletAssetData:\n    assetBalance: uint256\n    usdValue: uint256\n    isYieldAsset: bool\n    lastPricePerShare: uint256\n\nstruct ActionData:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    billing: address\n    wallet: address\n    walletConfig: address\n    walletOwner: address\n    inEjectMode: bool\n    isFrozen: bool\n    lastTotalUsdValue: uint256\n    signer: address\n    isManager: bool\n    legoId: uint256\n    legoAddr: address\n    eth: address\n    weth: address\n\nstruct MiniAddys:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    appraiser: address",
            "sha256sum": "9a4b4f59b3a62043e51b425a665064aae419a3c0bd0514b6b29a9441ae364bb9"
          },
          "interfaces/LegoPartner.vyi": {
            "content": "# @version 0.4.3\n\nfrom interfaces import WalletStructs as ws\n\nMAX_TOKEN_PATH: constant(uint256) = 5\nMAX_RECOVER_ASSETS: constant(uint256) = 20\n\n@external\ndef addLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _tickLower: int24, _tickUpper: int24, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef addLiquidity(_pool: address, _tokenA: address, _tokenB: address, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _minLpAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (address, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef removeLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _liqToRemove: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef removeLiquidity(_pool: address, _tokenA: address, _tokenB: address, _lpToken: address, _lpAmount: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef mintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _tokenInAmount: uint256, _minAmountOut: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef swapTokens(_amountIn: uint256, _minAmountOut: uint256, _tokenPath: DynArray[address, MAX_TOKEN_PATH], _poolPath: DynArray[address, MAX_TOKEN_PATH - 1], _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256):\n    ...\n\n@external\ndef depositForYield(_asset: address, _amount: uint256, _vaultAddr: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef withdrawFromYield(_vaultToken: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef confirmMintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef borrow(_borrowAsset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef repayDebt(_paymentAsset: address, _paymentAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef claimRewards(_user: address, _rewardToken: address, _rewardAmount: uint256, _extraData: bytes32, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef removeCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef addCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@view\n@external\ndef getAccessForLego(_user: address, _action: ws.ActionType) -> (address, String[64], uint256):\n    ...\n\n@view\n@external\ndef hasCapability(_action: ws.ActionType) -> bool:\n    ...\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    ...\n\n@view\n@external\ndef isYieldLego() -> bool:\n    ...\n\n@view\n@external\ndef isDexLego() -> bool:\n    ...\n\n\n# common\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "81db71fe4440a3b4b563134c9b5caf1d5705772a5f291fe874c9b5fb3cfb1623"
          },
          "interfaces/LegoStructs.vyi": {
            "content": "# @version 0.4.3\n\nstruct VaultTokenInfo:\n    underlyingAsset: address\n    decimals: uint256\n    lastAveragePricePerShare: uint256\n\nstruct SnapShotPriceConfig:\n    minSnapshotDelay: uint256\n    maxNumSnapshots: uint256\n    maxUpsideDeviation: uint256\n    staleTime: uint256\n\nstruct SingleSnapShot:\n    totalSupply: uint256\n    pricePerShare: uint256\n    lastUpdate: uint256\n\nstruct SnapShotData:\n    lastSnapShot: SingleSnapShot\n    nextIndex: uint256\n",
            "sha256sum": "8ae48be17d812d57fbd671bbf0593e8abf175ad0924e47c5997823cac19ec806"
          },
          "interfaces/YieldLego.vyi": {
            "content": "# @version 0.4.3\n\nfrom interfaces import LegoStructs as ls\n\n\n###################\n# Underlying Data #\n###################\n\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    ...\n\n\n@view\n@external\ndef getUnderlyingBalances(_vaultToken: address, _vaultTokenBalance: uint256) -> (uint256, uint256):\n    ...\n\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    ...\n\n\n@view\n@external\ndef getUnderlyingAmountSafe(_vaultToken: address, _vaultTokenBalance: uint256) -> uint256:\n    ...\n\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> (address, uint256, uint256):\n    ...\n\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> uint256:\n    ...\n\n\n###############\n# Other Utils #\n###############\n\n\n@view\n@external\ndef isRebasing() -> bool:\n    ...\n\n\n@view\n@external\ndef getPricePerShare(_vaultToken: address, _decimals: uint256 = 0) -> uint256:\n    ...\n\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef canRegisterVaultToken(_asset: address, _vaultToken: address) -> bool:\n    ...\n\n\n@view\n@external\ndef isEligibleVaultForTrialFunds(_vaultToken: address, _underlyingAsset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef isEligibleForYieldBonus(_asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    ...\n\n\n###################\n# Yield Lego Data #\n###################\n\n\n@view\n@external\ndef isLegoAsset(_asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, 40]:\n    ...\n\n\n@view\n@external\ndef getAssets() -> DynArray[address, 20]:\n    ...\n\n\n@view\n@external\ndef isAssetOpportunity(_asset: address, _vaultAddr: address) -> bool:\n    ...\n\n\n@view\n@external\ndef getNumLegoAssets() -> uint256:\n    ...\n\n\n@view\n@external\ndef assets(_index: uint256) -> address:\n    ...\n\n\n@view\n@external\ndef indexOfAsset(_asset: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef numAssets() -> uint256:\n    ...\n\n\n@view\n@external\ndef assetOpportunities(_asset: address, _index: uint256) -> address:\n    ...\n\n\n@view\n@external\ndef indexOfAssetOpportunity(_asset: address, _vaultAddr: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef numAssetOpportunities(_asset: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef vaultToAsset(_vaultAddr: address) -> ls.VaultTokenInfo:\n    ...\n\n\n# price snapshots\n\n\n@external\ndef addPriceSnapshot(_vaultToken: address) -> bool:\n    ...\n\n\n@view\n@external\ndef snapShotPriceConfig() -> ls.SnapShotPriceConfig:\n    ...\n\n\n@view\n@external\ndef snapShotData(_vaultToken: address) -> ls.SnapShotData:\n    ...\n\n\n@view\n@external\ndef snapShots(_vaultToken: address, _index: uint256) -> ls.SingleSnapShot:\n    ...\n\n\n@view\n@external\ndef getWeightedPricePerShare(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef getLatestSnapshot(_vaultToken: address, _pricePerShare: uint256) -> ls.SingleSnapShot:\n    ...\n\n\n@external\ndef setSnapShotPriceConfig(_config: ls.SnapShotPriceConfig):\n    ...\n",
            "sha256sum": "045a6bbd3d556234cf4fe925a303002dc0ac3c482d344ffbaf4bc52a7e6ad2df"
          },
          "contracts/modules/Addys.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\ninterface UndyHq:\n    def isValidAddr(_addr: address) -> bool: view\n    def getAddr(_regId: uint256) -> address: view\n    def undyToken() -> address: view\n\ninterface Switchboard:\n    def isSwitchboardAddr(_addr: address) -> bool: view\n\ninterface LegoBook:\n    def isLegoAddr(_addr: address) -> bool: view\n\nstruct Addys:\n    hq: address\n    undyToken: address\n    ledger: address\n    missionControl: address\n    legoBook: address\n    switchboard: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    walletBackpack: address\n    billing: address\n    vaultRegistry: address\n\n# hq\nUNDY_HQ_FOR_ADDYS: immutable(address)\n\n# core addys\nLEDGER_ID: constant(uint256) = 1\nMISSION_CONTROL_ID: constant(uint256) = 2\nLEGO_BOOK_ID: constant(uint256) = 3\nSWITCHBOARD_ID: constant(uint256) = 4\nHATCHERY_ID: constant(uint256) = 5\nLOOT_DISTRIBUTOR_ID: constant(uint256) = 6\nAPPRAISER_ID: constant(uint256) = 7\nWALLET_BACKPACK_ID: constant(uint256) = 8\nBILLING_ID: constant(uint256) = 9\nVAULT_REGISTRY_ID: constant(uint256) = 10\n\n\n@deploy\ndef __init__(_undyHq: address):\n    assert _undyHq != empty(address) # dev: invalid undy hq\n    UNDY_HQ_FOR_ADDYS = _undyHq\n\n\n########\n# Core #\n########\n\n\n@view\n@external\ndef getAddys() -> Addys:\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _getAddys(_addys: Addys = empty(Addys)) -> Addys:\n    if _addys.hq != empty(address):\n        return _addys\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _generateAddys() -> Addys:\n    hq: address = UNDY_HQ_FOR_ADDYS\n    return Addys(\n        hq = hq,\n        undyToken = staticcall UndyHq(hq).undyToken(),\n        ledger = staticcall UndyHq(hq).getAddr(LEDGER_ID),\n        missionControl = staticcall UndyHq(hq).getAddr(MISSION_CONTROL_ID),\n        legoBook = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID),\n        switchboard = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID),\n        hatchery = staticcall UndyHq(hq).getAddr(HATCHERY_ID),\n        lootDistributor = staticcall UndyHq(hq).getAddr(LOOT_DISTRIBUTOR_ID),\n        appraiser = staticcall UndyHq(hq).getAddr(APPRAISER_ID),\n        walletBackpack = staticcall UndyHq(hq).getAddr(WALLET_BACKPACK_ID),\n        billing = staticcall UndyHq(hq).getAddr(BILLING_ID),\n        vaultRegistry = staticcall UndyHq(hq).getAddr(VAULT_REGISTRY_ID),\n    )\n\n\n##########\n# Tokens #\n##########\n\n\n@view\n@internal\ndef _getUndyToken() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).undyToken()\n\n\n###########\n# Helpers #\n###########\n\n\n# undy hq\n\n\n@view\n@external\ndef getUndyHq() -> address:\n    return self._getUndyHq()\n\n\n@view\n@internal\ndef _getUndyHq() -> address:\n    return UNDY_HQ_FOR_ADDYS\n\n\n# utils\n\n\n@view\n@internal\ndef _isValidUndyAddr(_addr: address, _hq: address = empty(address)) -> bool:\n    hq: address = _hq\n    if _hq == empty(address):\n        hq = UNDY_HQ_FOR_ADDYS\n    \n    # core departments\n    if staticcall UndyHq(hq).isValidAddr(_addr):\n        return True\n\n    # lego book\n    legoBook: address = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID)\n    if legoBook != empty(address) and staticcall LegoBook(legoBook).isLegoAddr(_addr):\n        return True\n\n    # switchboard config\n    switchboard: address = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID)\n    if switchboard != empty(address) and staticcall Switchboard(switchboard).isSwitchboardAddr(_addr):\n        return True\n\n    return False\n\n\n@view\n@internal\ndef _isSwitchboardAddr(_addr: address) -> bool:\n    switchboard: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n    if switchboard == empty(address):\n        return False\n    return staticcall Switchboard(switchboard).isSwitchboardAddr(_addr)\n\n\n@view\n@internal\ndef _isLegoBookAddr(_addr: address) -> bool:\n    legoBook: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n    if legoBook == empty(address):\n        return False\n    return staticcall LegoBook(legoBook).isLegoAddr(_addr)\n\n\n###############\n# Departments #\n###############\n\n\n# ledger\n\n\n@view\n@internal\ndef _getLedgerId() -> uint256:\n    return LEDGER_ID\n\n\n@view\n@internal\ndef _getLedgerAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEDGER_ID)\n\n\n# mission control\n\n\n@view\n@internal\ndef _getMissionControlId() -> uint256:\n    return MISSION_CONTROL_ID\n\n\n@view\n@internal\ndef _getMissionControlAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(MISSION_CONTROL_ID)\n\n\n# lego book\n\n\n@view\n@internal\ndef _getLegoBookId() -> uint256:\n    return LEGO_BOOK_ID\n\n\n@view\n@internal\ndef _getLegoBookAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n\n\n# switchboard\n\n\n@view\n@internal\ndef _getSwitchboardId() -> uint256:\n    return SWITCHBOARD_ID\n\n\n@view\n@internal\ndef _getSwitchboardAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n\n\n# hatchery\n\n\n@view\n@internal\ndef _getHatcheryId() -> uint256:\n    return HATCHERY_ID\n\n\n@view\n@internal\ndef _getHatcheryAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(HATCHERY_ID)\n\n\n# loot distributor\n\n\n@view\n@internal\ndef _getLootDistributorId() -> uint256:\n    return LOOT_DISTRIBUTOR_ID\n\n\n@view\n@internal\ndef _getLootDistributorAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LOOT_DISTRIBUTOR_ID)\n\n\n# appraiser\n\n\n@view\n@internal\ndef _getAppraiserId() -> uint256:\n    return APPRAISER_ID\n\n\n@view\n@internal\ndef _getAppraiserAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(APPRAISER_ID)\n\n\n# wallet backpack\n\n\n@view\n@internal\ndef _getWalletBackpackId() -> uint256:\n    return WALLET_BACKPACK_ID\n\n\n@view\n@internal\ndef _getWalletBackpackAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(WALLET_BACKPACK_ID)\n\n\n# billing\n\n\n@view\n@internal\ndef _getBillingId() -> uint256:\n    return BILLING_ID\n\n\n@view\n@internal\ndef _getBillingAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(BILLING_ID)\n\n\n# vault registry\n\n\n@view\n@internal\ndef _getVaultRegistryId() -> uint256:\n    return VAULT_REGISTRY_ID\n\n\n@view\n@internal\ndef _getVaultRegistryAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(VAULT_REGISTRY_ID)",
            "sha256sum": "4df6b72db9bb417d1af81660175be1450cfb7b3575f3d17a5b8a130bff87b781"
          },
          "contracts/modules/YieldLegoData.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nuses: addys\n\nimport contracts.modules.Addys as addys\n\nfrom interfaces import WalletStructs as ws\nfrom interfaces import LegoStructs as ls\nfrom ethereum.ercs import IERC20\nfrom ethereum.ercs import IERC20Detailed\n\nevent AssetOpportunityAdded:\n    asset: indexed(address)\n    vaultAddr: indexed(address)\n\nevent AssetOpportunityRemoved:\n    asset: indexed(address)\n    vaultAddr: indexed(address)\n\nevent LegoPauseModified:\n    isPaused: bool\n\nevent LegoFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    balance: uint256\n\nevent PricePerShareSnapShotAdded:\n    vaultToken: indexed(address)\n    totalSupply: uint256\n    pricePerShare: uint256\n\nevent SnapShotPriceConfigSet:\n    minSnapshotDelay: uint256\n    maxNumSnapshots: uint256\n    maxUpsideDeviation: uint256\n    staleTime: uint256\n\n# core\nvaultToAsset: public(HashMap[address, ls.VaultTokenInfo]) # vault addr -> data\n\n# asset opportunities\nassetOpportunities: public(HashMap[address, HashMap[uint256, address]]) # asset -> index -> vault addr\nindexOfAssetOpportunity: public(HashMap[address, HashMap[address, uint256]]) # asset -> vault addr -> index\nnumAssetOpportunities: public(HashMap[address, uint256]) # asset -> number of opportunities\n\n# lego assets (iterable)\nassets: public(HashMap[uint256, address]) # index -> asset\nindexOfAsset: public(HashMap[address, uint256]) # asset -> index\nnumAssets: public(uint256) # num assets\n\n# price snapshots\nsnapShotData: public(HashMap[address, ls.SnapShotData]) # vault token -> data\nsnapShots: public(HashMap[address, HashMap[uint256, ls.SingleSnapShot]]) # vault token -> index -> snapshot\nsnapShotPriceConfig: public(ls.SnapShotPriceConfig) # config\n\nisPaused: public(bool)\n\nMAX_VAULTS: constant(uint256) = 40\nMAX_ASSETS: constant(uint256) = 20\nMAX_RECOVER_ASSETS: constant(uint256) = 20\nONE_DAY_SECONDS: constant(uint256) = 60 * 60 * 24\nONE_WEEK_SECONDS: constant(uint256) = ONE_DAY_SECONDS * 7\nHUNDRED_PERCENT: constant(uint256) = 100_00\n\n\n@deploy\ndef __init__(_shouldPause: bool):\n    self.isPaused = _shouldPause\n    self.numAssets = 1 # not using 0 index\n\n    # default snapshot price config\n    self.snapShotPriceConfig = ls.SnapShotPriceConfig(\n        minSnapshotDelay = 60 * 10, # 10 minutes\n        maxNumSnapshots = 20,\n        maxUpsideDeviation = 10_00, # 10%\n        staleTime = 3 * ONE_DAY_SECONDS, # 3 days\n    )\n\n\n#########\n# Views #\n#########\n\n\n# is lego asset\n\n\n@view\n@external\ndef isLegoAsset(_asset: address) -> bool:\n    return self._isLegoAsset(_asset)\n\n\n@view\n@internal\ndef _isLegoAsset(_asset: address) -> bool:\n    return self.indexOfAsset[_asset] != 0\n\n\n# vault opportunities\n\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, MAX_VAULTS]:\n    numOpportunities: uint256 = self.numAssetOpportunities[_asset]\n    if numOpportunities == 0:\n        return []\n    opportunities: DynArray[address, MAX_VAULTS] = []\n    for i: uint256 in range(1, numOpportunities, bound=MAX_VAULTS):\n        opportunities.append(self.assetOpportunities[_asset][i])\n    return opportunities\n\n\n# all assets registered\n\n\n@view\n@external\ndef getAssets() -> DynArray[address, MAX_ASSETS]:\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return []\n    assets: DynArray[address, MAX_ASSETS] = []\n    for i: uint256 in range(1, numAssets, bound=MAX_ASSETS):\n        assets.append(self.assets[i])\n    return assets\n\n\n################\n# Registration #\n################\n\n\n@view\n@external\ndef isAssetOpportunity(_asset: address, _vaultAddr: address) -> bool:\n    return self._isAssetOpportunity(_asset, _vaultAddr)\n\n\n@view\n@internal\ndef _isAssetOpportunity(_asset: address, _vaultAddr: address) -> bool:\n    return self.indexOfAssetOpportunity[_asset][_vaultAddr] != 0\n\n\n# add asset opportunity\n\n\n@internal\ndef _addAssetOpportunity(_asset: address, _vaultAddr: address) -> ls.VaultTokenInfo:\n    if self.indexOfAssetOpportunity[_asset][_vaultAddr] != 0:\n        return self.vaultToAsset[_vaultAddr]\n\n    if empty(address) in [_asset, _vaultAddr]:\n        return empty(ls.VaultTokenInfo)\n\n    # add asset opportunity\n    aid: uint256 = self.numAssetOpportunities[_asset]\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.assetOpportunities[_asset][aid] = _vaultAddr\n    self.indexOfAssetOpportunity[_asset][_vaultAddr] = aid\n    self.numAssetOpportunities[_asset] = aid + 1\n\n    # add mapping\n    vaultInfo: ls.VaultTokenInfo = ls.VaultTokenInfo(\n        underlyingAsset = _asset,\n        decimals = convert(staticcall IERC20Detailed(_vaultAddr).decimals(), uint256),\n        lastAveragePricePerShare = 0,\n    )\n    self.vaultToAsset[_vaultAddr] = vaultInfo\n\n    # add asset\n    self._addAsset(_asset)\n\n    log AssetOpportunityAdded(asset=_asset, vaultAddr=_vaultAddr)\n    return vaultInfo\n\n\n# remove asset opportunity\n\n\n@internal\ndef _removeAssetOpportunity(_asset: address, _vaultAddr: address):\n    numOpportunities: uint256 = self.numAssetOpportunities[_asset]\n    if numOpportunities == 0:\n        return\n\n    targetIndex: uint256 = self.indexOfAssetOpportunity[_asset][_vaultAddr]\n    if targetIndex == 0:\n        return\n\n    # update data\n    lastIndex: uint256 = numOpportunities - 1\n    self.numAssetOpportunities[_asset] = lastIndex\n    self.indexOfAssetOpportunity[_asset][_vaultAddr] = 0\n\n    self.vaultToAsset[_vaultAddr] = empty(ls.VaultTokenInfo)\n\n    # shift to replace the removed one\n    if targetIndex != lastIndex:\n        lastVaultAddr: address = self.assetOpportunities[_asset][lastIndex]\n        self.assetOpportunities[_asset][targetIndex] = lastVaultAddr\n        self.indexOfAssetOpportunity[_asset][lastVaultAddr] = targetIndex\n\n    # remove asset\n    if lastIndex <= 1:\n        self._removeAsset(_asset)\n\n    log AssetOpportunityRemoved(asset=_asset, vaultAddr=_vaultAddr)\n\n\n# add asset\n\n\n@internal\ndef _addAsset(_asset: address):\n    if self.indexOfAsset[_asset] != 0:\n        return\n\n    aid: uint256 = self.numAssets\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.assets[aid] = _asset\n    self.indexOfAsset[_asset] = aid\n    self.numAssets = aid + 1\n\n\n# remove asset\n\n\n@internal\ndef _removeAsset(_asset: address):\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return\n\n    targetIndex: uint256 = self.indexOfAsset[_asset]\n    if targetIndex == 0:\n        return\n\n    # update data\n    lastIndex: uint256 = numAssets - 1\n    self.numAssets = lastIndex\n    self.indexOfAsset[_asset] = 0\n\n    # shift to replace the removed one\n    if targetIndex != lastIndex:\n        lastAsset: address = self.assets[lastIndex]\n        self.assets[targetIndex] = lastAsset\n        self.indexOfAsset[lastAsset] = targetIndex\n\n\n# num lego assets (true number, use `numAssets` for iteration)\n\n\n@view\n@external\ndef getNumLegoAssets() -> uint256:\n    return self._getNumLegoAssets()\n\n\n@view\n@internal\ndef _getNumLegoAssets() -> uint256:\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return 0\n    return numAssets - 1\n\n\n###########\n# General #\n###########\n\n\n# fill mini addys\n\n\n@view\n@internal\ndef _getMiniAddys(_miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> ws.MiniAddys:\n    if _miniAddys.ledger != empty(address):\n        return _miniAddys\n    return ws.MiniAddys(\n        ledger = addys._getLedgerAddr(),\n        missionControl = addys._getMissionControlAddr(),\n        legoBook = addys._getLegoBookAddr(),\n        appraiser = addys._getAppraiserAddr(),\n    )\n\n\n# activate\n\n\n@external\ndef pause(_shouldPause: bool):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert _shouldPause != self.isPaused # dev: no change\n    self.isPaused = _shouldPause\n    log LegoPauseModified(isPaused=_shouldPause)\n\n\n# recover funds\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    self._recoverFunds(_recipient, _asset)\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, MAX_RECOVER_ASSETS]):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    for a: address in _assets:\n        self._recoverFunds(_recipient, a)\n\n\n@internal\ndef _recoverFunds(_recipient: address, _asset: address):\n    assert empty(address) not in [_recipient, _asset] # dev: invalid recipient or asset\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    assert balance != 0 # dev: nothing to recover\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log LegoFundsRecovered(asset=_asset, recipient=_recipient, balance=balance)\n\n\n###################\n# Price Snapshots #\n###################\n\n\n# add price snapshot\n\n\n@internal\ndef _addPriceSnapshot(_vaultToken: address, _pricePerShare: uint256, _vaultTokenDecimals: uint256) -> bool:\n    config: ls.SnapShotPriceConfig = self.snapShotPriceConfig\n    if config.maxNumSnapshots == 0:\n        return False\n\n    data: ls.SnapShotData = self.snapShotData[_vaultToken]\n\n    # already have snapshot for this time\n    if data.lastSnapShot.lastUpdate == block.timestamp:\n        return False\n\n    # check if snapshot is too recent\n    if data.lastSnapShot.lastUpdate + config.minSnapshotDelay > block.timestamp:\n        return False\n\n    # create and store new snapshot\n    newSnapshot: ls.SingleSnapShot = self._getLatestSnapshot(_vaultToken, _pricePerShare, _vaultTokenDecimals, data.lastSnapShot, config)\n    data.lastSnapShot = newSnapshot\n    self.snapShots[_vaultToken][data.nextIndex] = newSnapshot\n\n    # update index\n    data.nextIndex += 1\n    if data.nextIndex >= config.maxNumSnapshots:\n        data.nextIndex = 0\n\n    # save snap shot data\n    self.snapShotData[_vaultToken] = data\n\n    # update cached weighted average price per share\n    self.vaultToAsset[_vaultToken].lastAveragePricePerShare = self._getWeightedPricePerShare(_vaultToken, _pricePerShare)\n\n    log PricePerShareSnapShotAdded(\n        vaultToken = _vaultToken,\n        totalSupply = newSnapshot.totalSupply,\n        pricePerShare = newSnapshot.pricePerShare,\n    )\n    return True\n\n\n# weighted price per share\n\n\n@view\n@external\ndef getWeightedPricePerShare(_vaultToken: address) -> uint256:\n    data: ls.SnapShotData = self.snapShotData[_vaultToken]\n    return self._getWeightedPricePerShare(_vaultToken, data.lastSnapShot.pricePerShare)\n\n\n@view\n@internal\ndef _getWeightedPricePerShare(_vaultToken: address, _lastPricePerShare: uint256) -> uint256:\n    config: ls.SnapShotPriceConfig = self.snapShotPriceConfig\n    if config.maxNumSnapshots == 0:\n        return 0\n\n    # calculate weighted average price using all valid snapshots\n    numerator: uint256 = 0\n    denominator: uint256 = 0\n    for i: uint256 in range(config.maxNumSnapshots, bound=max_value(uint256)):\n\n        snapShot: ls.SingleSnapShot = self.snapShots[_vaultToken][i]\n        if snapShot.pricePerShare == 0 or snapShot.totalSupply == 0 or snapShot.lastUpdate == 0:\n            continue\n\n        # too stale, skip\n        if config.staleTime != 0 and block.timestamp > snapShot.lastUpdate + config.staleTime:\n            continue\n\n        numerator += (snapShot.totalSupply * snapShot.pricePerShare)\n        denominator += snapShot.totalSupply\n\n    # weighted price per share\n    weightedPricePerShare: uint256 = 0\n    if numerator != 0:\n        weightedPricePerShare = numerator // denominator\n    else:\n        weightedPricePerShare = _lastPricePerShare\n\n    return weightedPricePerShare\n\n\n# latest snapshot\n\n\n@view\n@external\ndef getLatestSnapshot(_vaultToken: address, _pricePerShare: uint256) -> ls.SingleSnapShot:\n    data: ls.SnapShotData = self.snapShotData[_vaultToken]\n    config: ls.SnapShotPriceConfig = self.snapShotPriceConfig\n    vaultTokenDecimals: uint256 = self.vaultToAsset[_vaultToken].decimals\n    return self._getLatestSnapshot(_vaultToken, _pricePerShare, vaultTokenDecimals, data.lastSnapShot, config)\n\n\n@view\n@internal\ndef _getLatestSnapshot(\n    _vaultToken: address,\n    _pricePerShare: uint256,\n    _vaultTokenDecimals: uint256,\n    _lastSnapShot: ls.SingleSnapShot,\n    _config: ls.SnapShotPriceConfig,\n) -> ls.SingleSnapShot:\n\n    # total supply (adjusted)\n    totalSupply: uint256 = staticcall IERC20(_vaultToken).totalSupply() // (10 ** _vaultTokenDecimals)\n    if totalSupply == 0:\n        totalSupply = 1\n\n    # throttle upside (extra safety check)\n    pricePerShare: uint256 = self._throttleUpside(_pricePerShare, _lastSnapShot.pricePerShare, _config.maxUpsideDeviation)\n\n    return ls.SingleSnapShot(\n        totalSupply = totalSupply,\n        pricePerShare = pricePerShare,\n        lastUpdate = block.timestamp,\n    )\n\n\n@view\n@internal\ndef _throttleUpside(_newValue: uint256, _prevValue: uint256, _maxUpside: uint256) -> uint256:\n    if _maxUpside == 0 or _prevValue == 0 or _newValue == 0:\n        return _newValue\n    maxPricePerShare: uint256 = _prevValue + (_prevValue * _maxUpside // HUNDRED_PERCENT)\n    return min(_newValue, maxPricePerShare)\n\n\n# snapshot price config\n\n\n@external\ndef setSnapShotPriceConfig(_config: ls.SnapShotPriceConfig):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert self._isValidPriceConfig(_config) # dev: invalid config\n    self.snapShotPriceConfig = _config\n    log SnapShotPriceConfigSet(\n        minSnapshotDelay=_config.minSnapshotDelay,\n        maxNumSnapshots=_config.maxNumSnapshots,\n        maxUpsideDeviation=_config.maxUpsideDeviation,\n        staleTime=_config.staleTime\n    )\n\n\n@view\n@external\ndef isValidPriceConfig(_config: ls.SnapShotPriceConfig) -> bool:\n    return self._isValidPriceConfig(_config)\n\n\n@view\n@internal\ndef _isValidPriceConfig(_config: ls.SnapShotPriceConfig) -> bool:\n    if _config.minSnapshotDelay > ONE_WEEK_SECONDS:\n        return False\n    if _config.maxNumSnapshots == 0 or _config.maxNumSnapshots > 25:\n        return False\n    if _config.maxUpsideDeviation > HUNDRED_PERCENT:\n        return False\n    return _config.staleTime < ONE_WEEK_SECONDS",
            "sha256sum": "d695c6d3998cf2ed318a0da6f4f7918abf97661e10eb510ed996d815e65927e0"
          },
          "contracts/legos/yield/SkyPsm.vy": {
            "content": "#     __   __ ___ _______ ___     ______       ___     _______ _______ _______ \n#    |  | |  |   |       |   |   |      |     |   |   |       |       |       |\n#    |  |_|  |   |    ___|   |   |  _    |    |   |   |    ___|    ___|   _   |\n#    |       |   |   |___|   |   | | |   |    |   |   |   |___|   | __|  | |  |\n#    |_     _|   |    ___|   |___| |_|   |    |   |___|    ___|   ||  |  |_|  |\n#      |   | |   |   |___|       |       |    |       |   |___|   |_| |       |\n#      |___| |___|_______|_______|______|     |_______|_______|_______|_______|\n#                                                                       \n#     \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n#     \u2551  ** Sky Psm **                    \u2551\n#     \u2551  Integration with Sky Protocol.   \u2551\n#     \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n#\n#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nimplements: Lego\nimplements: YieldLego\n\nexports: addys.__interface__\nexports: yld.__interface__\n\ninitializes: addys\ninitializes: yld[addys := addys]\n\nfrom interfaces import LegoPartner as Lego\nfrom interfaces import YieldLego as YieldLego\nfrom interfaces import WalletStructs as ws\nfrom interfaces import LegoStructs as ls\n\nimport contracts.modules.Addys as addys\nimport contracts.modules.YieldLegoData as yld\n\nfrom ethereum.ercs import IERC20\n\ninterface SkyPsm:\n    def swapExactIn(_assetIn: address, _assetOut: address, _amountIn: uint256, _minAmountOut: uint256, _receiver: address, _referralCode: uint256) -> uint256: nonpayable\n    def previewSwapExactIn(_assetIn: address, _assetOut: address, _amountIn: uint256) -> uint256: view\n    def totalAssets() -> uint256: view\n    def susds() -> address: view\n    def usds() -> address: view\n\ninterface Appraiser:\n    def getUsdValue(_asset: address, _amount: uint256, _missionControl: address = empty(address), _legoBook: address = empty(address), _ledger: address = empty(address)) -> uint256: view\n    def updatePriceAndGetUsdValue(_asset: address, _amount: uint256, _missionControl: address = empty(address), _legoBook: address = empty(address)) -> uint256: nonpayable\n\ninterface Ledger:\n    def setVaultToken(_vaultToken: address, _legoId: uint256, _underlyingAsset: address, _decimals: uint256, _isRebasing: bool): nonpayable\n    def isRegisteredVaultToken(_vaultToken: address) -> bool: view\n\ninterface Registry:\n    def getRegId(_addr: address) -> uint256: view\n\nevent SkyPsmDeposit:\n    sender: indexed(address)\n    asset: indexed(address)\n    vaultToken: indexed(address)\n    assetAmountDeposited: uint256\n    usdValue: uint256\n    vaultTokenAmountReceived: uint256\n    recipient: address\n\nevent SkyPsmWithdrawal:\n    sender: indexed(address)\n    asset: indexed(address)\n    vaultToken: indexed(address)\n    assetAmountReceived: uint256\n    usdValue: uint256\n    vaultTokenAmountBurned: uint256\n    recipient: address\n\nevent SlippageSet:\n    slippage: uint256\n\nslippage: public(uint256)\n\nMAX_TOKEN_PATH: constant(uint256) = 5\nHUNDRED_PERCENT: constant(uint256) = 100_00 # 100.00%\n\nSKY_PSM: public(immutable(address))\nUSDS: public(immutable(address))\nSUSDS: public(immutable(address))\n\n\n@deploy\ndef __init__(_undyHq: address, _skyPsm: address):\n    addys.__init__(_undyHq)\n    yld.__init__(False)\n\n    self.slippage = 50 # 0.50%\n\n    assert _skyPsm != empty(address) # dev: invalid addrs\n    SKY_PSM = _skyPsm\n    USDS = staticcall SkyPsm(_skyPsm).usds()\n    SUSDS = staticcall SkyPsm(_skyPsm).susds()\n\n\n@view\n@external\ndef hasCapability(_action: ws.ActionType) -> bool:\n    return _action in (\n        ws.ActionType.EARN_DEPOSIT | \n        ws.ActionType.EARN_WITHDRAW\n    )\n\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    return [SKY_PSM]\n\n\n@view\n@external\ndef isYieldLego() -> bool:\n    return True\n\n\n@view\n@external\ndef isDexLego() -> bool:\n    return False\n\n\n###################\n# Underlying Data #\n###################\n\n\n# underlying asset\n\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    return self._getUnderlyingAsset(_vaultToken)\n\n\n@view\n@internal\ndef _getUnderlyingAsset(_vaultToken: address) -> address:\n    return yld.vaultToAsset[_vaultToken].underlyingAsset\n\n\n# underlying balances (both true and safe)\n\n\n@view\n@external\ndef getUnderlyingBalances(_vaultToken: address, _vaultTokenBalance: uint256) -> (uint256, uint256):\n    if _vaultTokenBalance == 0:\n        return 0, 0\n\n    trueUnderlying: uint256 = self._getUnderlyingAmount(_vaultToken, _vaultTokenBalance)\n    safeUnderlying: uint256 = self._getUnderlyingAmountSafe(_vaultToken, _vaultTokenBalance)\n    if safeUnderlying == 0:\n        safeUnderlying = trueUnderlying\n\n    return trueUnderlying, min(trueUnderlying, safeUnderlying)\n\n\n# underlying amount (true)\n\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    return self._getUnderlyingAmount(_vaultToken, _vaultTokenAmount)\n\n\n@view\n@internal\ndef _getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    asset: address = self._getUnderlyingAsset(_vaultToken)\n    if asset == empty(address):\n        return 0 # invalid vault token\n    return staticcall SkyPsm(SKY_PSM).previewSwapExactIn(_vaultToken, asset, _vaultTokenAmount)\n\n\n# underlying amount (safe)\n\n\n@view\n@external\ndef getUnderlyingAmountSafe(_vaultToken: address, _vaultTokenBalance: uint256) -> uint256:\n    return self._getUnderlyingAmountSafe(_vaultToken, _vaultTokenBalance)\n\n\n@view\n@internal\ndef _getUnderlyingAmountSafe(_vaultToken: address, _vaultTokenBalance: uint256) -> uint256:\n    vaultInfo: ls.VaultTokenInfo = yld.vaultToAsset[_vaultToken]\n    if vaultInfo.decimals == 0:\n        return 0 # not registered\n\n    # safe underlying amount (using cached weighted average from snapshots)\n    return _vaultTokenBalance * vaultInfo.lastAveragePricePerShare // (10 ** vaultInfo.decimals)\n\n\n# underlying data (combined)\n\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> (address, uint256, uint256):\n    return self._getUnderlyingData(_vaultToken, _vaultTokenAmount, _appraiser)\n\n\n@view\n@internal\ndef _getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address) -> (address, uint256, uint256):\n    asset: address = self._getUnderlyingAsset(_vaultToken)\n    if asset == empty(address):\n        return empty(address), 0, 0 # invalid vault token\n    underlyingAmount: uint256 = self._getUnderlyingAmount(_vaultToken, _vaultTokenAmount)\n    usdValue: uint256 = self._getUsdValue(asset, underlyingAmount, _appraiser)\n    return asset, underlyingAmount, usdValue\n\n\n# usd value\n\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> uint256:\n    return self._getUsdValueOfVaultToken(_vaultToken, _vaultTokenAmount, _appraiser)\n\n\n@view\n@internal\ndef _getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address) -> uint256:\n    return self._getUnderlyingData(_vaultToken, _vaultTokenAmount, _appraiser)[2]\n\n\n@view\n@internal\ndef _getUsdValue(_asset: address, _amount: uint256, _appraiser: address) -> uint256:\n    appraiser: address = _appraiser\n    if _appraiser == empty(address):\n        appraiser = addys._getAppraiserAddr()\n    return staticcall Appraiser(appraiser).getUsdValue(_asset, _amount)\n\n\n###############\n# Other Utils #\n###############\n\n\n# basics\n\n\n@view\n@external\ndef isRebasing() -> bool:\n    return self._isRebasing()\n\n\n@view\n@internal\ndef _isRebasing() -> bool:\n    return False\n\n\n# price per share\n\n\n@view\n@external\ndef getPricePerShare(_vaultToken: address, _decimals: uint256 = 0) -> uint256:\n    decimals: uint256 = _decimals\n    if decimals == 0:\n        decimals = yld.vaultToAsset[_vaultToken].decimals\n    if decimals == 0:\n        return 0 # not registered\n    return self._getPricePerShare(_vaultToken, decimals)\n\n\n@view\n@internal\ndef _getPricePerShare(_vaultToken: address, _decimals: uint256) -> uint256:\n    return staticcall SkyPsm(SKY_PSM).previewSwapExactIn(_vaultToken, USDS, 10 ** _decimals)\n\n\n# vault token amount\n\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    return staticcall SkyPsm(SKY_PSM).previewSwapExactIn(_asset, _vaultToken, _assetAmount)\n\n\n# extras\n\n\n@view\n@external\ndef isEligibleVaultForTrialFunds(_vaultToken: address, _underlyingAsset: address) -> bool:\n    return False\n\n\n@view\n@external\ndef isEligibleForYieldBonus(_asset: address) -> bool:\n    return False\n\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    return staticcall SkyPsm(SKY_PSM).totalAssets()\n\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    # TODO: implement\n    return 0\n\n\n################\n# Registration #\n################\n\n\n# can vault be registered\n\n\n@view\n@external\ndef canRegisterVaultToken(_asset: address, _vaultToken: address) -> bool:\n    return self._canRegisterVaultToken(_asset, _vaultToken)\n\n\n@view\n@internal\ndef _canRegisterVaultToken(_asset: address, _vaultToken: address) -> bool:\n    if empty(address) in [_asset, _vaultToken]:\n        return False\n    return _asset == USDS and _vaultToken == SUSDS\n\n\n# register vault token locally\n\n\n@external\ndef registerVaultTokenLocally(_asset: address, _vaultAddr: address) -> ls.VaultTokenInfo:\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert self._canRegisterVaultToken(_asset, _vaultAddr) # dev: cannot register vault token\n    assert not yld._isAssetOpportunity(_asset, _vaultAddr) # dev: already registered\n    vaultInfo: ls.VaultTokenInfo = self._registerVaultTokenLocally(_asset, _vaultAddr)\n    self._registerVaultTokenGlobally(_asset, _vaultAddr, vaultInfo.decimals, addys._getLedgerAddr(), addys._getLegoBookAddr())\n    return vaultInfo\n\n\n@internal\ndef _registerVaultTokenLocally(_asset: address, _vaultAddr: address) -> ls.VaultTokenInfo:\n    skyPsm: address = SKY_PSM\n    assert extcall IERC20(_asset).approve(skyPsm, max_value(uint256), default_return_value=True) # dev: max approval failed\n    assert extcall IERC20(_vaultAddr).approve(skyPsm, max_value(uint256), default_return_value=True) # dev: max approval failed\n    vaultInfo: ls.VaultTokenInfo = yld._addAssetOpportunity(_asset, _vaultAddr)\n    assert vaultInfo.decimals != 0 # dev: invalid vault token\n    return vaultInfo\n\n\n# remove vault token locally\n\n\n@external\ndef deregisterVaultTokenLocally(_asset: address, _vaultAddr: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert yld._isAssetOpportunity(_asset, _vaultAddr) # dev: already registered\n    self._deregisterVaultTokenLocally(_asset, _vaultAddr)\n\n\n@internal\ndef _deregisterVaultTokenLocally(_asset: address, _vaultAddr: address):\n    skyPsm: address = SKY_PSM\n    assert extcall IERC20(_asset).approve(skyPsm, 0, default_return_value=True) # dev: max approval failed\n    assert extcall IERC20(_vaultAddr).approve(skyPsm, 0, default_return_value=True) # dev: max approval failed\n    yld._removeAssetOpportunity(_asset, _vaultAddr)\n\n\n# ledger registration\n\n\n@internal\ndef _registerVaultTokenGlobally(_underlyingAsset: address, _vaultToken: address, _decimals: uint256, _ledger: address, _legoBook: address):\n    if not staticcall Ledger(_ledger).isRegisteredVaultToken(_vaultToken):\n        legoId: uint256 = staticcall Registry(_legoBook).getRegId(self)\n        extcall Ledger(_ledger).setVaultToken(_vaultToken, legoId, _underlyingAsset, _decimals, self._isRebasing())\n\n\n#################\n# Yield Actions #\n#################\n\n\n# add price snapshot\n\n\n@external\ndef addPriceSnapshot(_vaultToken: address) -> bool:\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    vaultInfo: ls.VaultTokenInfo = yld.vaultToAsset[_vaultToken]\n    assert vaultInfo.decimals != 0 # dev: not registered\n    pricePerShare: uint256 = self._getPricePerShare(_vaultToken, vaultInfo.decimals)\n    return yld._addPriceSnapshot(_vaultToken, pricePerShare, vaultInfo.decimals)\n\n\n# deposit\n\n\n@external\ndef depositForYield(\n    _asset: address,\n    _amount: uint256,\n    _vaultAddr: address,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, address, uint256, uint256):\n    assert not yld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = yld._getMiniAddys(_miniAddys)\n    vaultInfo: ls.VaultTokenInfo = self._getVaultInfoOnDeposit(_asset, _vaultAddr, miniAddys.ledger, miniAddys.legoBook)\n\n    # pre balances\n    preLegoBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n\n    # transfer deposit asset to this contract\n    depositAmount: uint256 = min(_amount, staticcall IERC20(_asset).balanceOf(msg.sender))\n    assert depositAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_asset).transferFrom(msg.sender, self, depositAmount, default_return_value=True) # dev: transfer failed\n\n    # deposit assets into lego partner\n    skyPsm: address = SKY_PSM\n    expectedVaultTokenAmount: uint256 = staticcall SkyPsm(skyPsm).previewSwapExactIn(_asset, _vaultAddr, depositAmount)\n    minAmountOut: uint256 = expectedVaultTokenAmount * (HUNDRED_PERCENT - self.slippage) // HUNDRED_PERCENT\n    vaultTokenAmountReceived: uint256 = extcall SkyPsm(skyPsm).swapExactIn(_asset, _vaultAddr, depositAmount, minAmountOut, _recipient, 0)\n    assert vaultTokenAmountReceived != 0 # dev: no vault tokens received\n\n    # refund if full deposit didn't get through\n    currentLegoBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    refundAssetAmount: uint256 = 0\n    if currentLegoBalance > preLegoBalance:\n        refundAssetAmount = currentLegoBalance - preLegoBalance\n        assert extcall IERC20(_asset).transfer(msg.sender, refundAssetAmount, default_return_value=True) # dev: transfer failed\n        depositAmount -= refundAssetAmount\n\n    usdValue: uint256 = extcall Appraiser(miniAddys.appraiser).updatePriceAndGetUsdValue(_asset, depositAmount, miniAddys.missionControl, miniAddys.legoBook)\n    log SkyPsmDeposit(\n        sender = msg.sender,\n        asset = _asset,\n        vaultToken = _vaultAddr,\n        assetAmountDeposited = depositAmount,\n        usdValue = usdValue,\n        vaultTokenAmountReceived = vaultTokenAmountReceived,\n        recipient = _recipient,\n    )\n\n    # add price snapshot\n    pricePerShare: uint256 = self._getPricePerShare(_vaultAddr, vaultInfo.decimals)\n    yld._addPriceSnapshot(_vaultAddr, pricePerShare, vaultInfo.decimals)\n\n    return depositAmount, _vaultAddr, vaultTokenAmountReceived, usdValue\n\n\n# vault info on deposit\n\n\n@internal\ndef _getVaultInfoOnDeposit(_asset: address, _vaultAddr: address, _ledger: address, _legoBook: address) -> ls.VaultTokenInfo:\n    vaultInfo: ls.VaultTokenInfo = yld.vaultToAsset[_vaultAddr]\n    if vaultInfo.decimals == 0:\n        assert self._canRegisterVaultToken(_asset, _vaultAddr) # dev: cannot register vault token\n        vaultInfo = self._registerVaultTokenLocally(_asset, _vaultAddr)\n        self._registerVaultTokenGlobally(_asset, _vaultAddr, vaultInfo.decimals, _ledger, _legoBook)\n    else:\n        assert vaultInfo.underlyingAsset == _asset # dev: asset mismatch\n    return vaultInfo\n\n\n# withdraw\n\n\n@external\ndef withdrawFromYield(\n    _vaultToken: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, address, uint256, uint256):\n    assert not yld.isPaused # dev: paused\n    miniAddys: ws.MiniAddys = yld._getMiniAddys(_miniAddys)\n    vaultInfo: ls.VaultTokenInfo = self._getVaultInfoOnWithdrawal(_vaultToken, miniAddys.ledger, miniAddys.legoBook)\n\n    # pre balances\n    preLegoVaultBalance: uint256 = staticcall IERC20(_vaultToken).balanceOf(self)\n\n    # transfer vaults tokens to this contract\n    vaultTokenAmount: uint256 = min(_amount, staticcall IERC20(_vaultToken).balanceOf(msg.sender))\n    assert vaultTokenAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_vaultToken).transferFrom(msg.sender, self, vaultTokenAmount, default_return_value=True) # dev: transfer failed\n\n    # withdraw assets from lego partner\n    skyPsm: address = SKY_PSM\n    expectedAssetAmount: uint256 = staticcall SkyPsm(skyPsm).previewSwapExactIn(_vaultToken, vaultInfo.underlyingAsset, vaultTokenAmount)\n    minAmountOut: uint256 = expectedAssetAmount * (HUNDRED_PERCENT - self.slippage) // HUNDRED_PERCENT\n    assetAmountReceived: uint256 = extcall SkyPsm(skyPsm).swapExactIn(_vaultToken, vaultInfo.underlyingAsset, vaultTokenAmount, minAmountOut, _recipient, 0)\n    assert assetAmountReceived != 0 # dev: no asset amount received\n\n    # refund if full withdrawal didn't happen\n    currentLegoVaultBalance: uint256 = staticcall IERC20(_vaultToken).balanceOf(self)\n    refundVaultTokenAmount: uint256 = 0\n    if currentLegoVaultBalance > preLegoVaultBalance:\n        refundVaultTokenAmount = currentLegoVaultBalance - preLegoVaultBalance\n        assert extcall IERC20(_vaultToken).transfer(msg.sender, refundVaultTokenAmount, default_return_value=True) # dev: transfer failed\n        vaultTokenAmount -= refundVaultTokenAmount\n\n    usdValue: uint256 = extcall Appraiser(miniAddys.appraiser).updatePriceAndGetUsdValue(vaultInfo.underlyingAsset, assetAmountReceived, miniAddys.missionControl, miniAddys.legoBook)\n    log SkyPsmWithdrawal(\n        sender = msg.sender,\n        asset = vaultInfo.underlyingAsset,\n        vaultToken = _vaultToken,\n        assetAmountReceived = assetAmountReceived,\n        usdValue = usdValue,\n        vaultTokenAmountBurned = vaultTokenAmount,\n        recipient = _recipient,\n    )\n\n    # add price snapshot\n    pricePerShare: uint256 = self._getPricePerShare(_vaultToken, vaultInfo.decimals)\n    yld._addPriceSnapshot(_vaultToken, pricePerShare, vaultInfo.decimals)\n\n    return vaultTokenAmount, vaultInfo.underlyingAsset, assetAmountReceived, usdValue\n\n\n# vault info on withdrawal\n\n\n@internal\ndef _getVaultInfoOnWithdrawal(_vaultAddr: address, _ledger: address, _legoBook: address) -> ls.VaultTokenInfo:\n    vaultInfo: ls.VaultTokenInfo = yld.vaultToAsset[_vaultAddr]\n    if vaultInfo.decimals == 0:\n        asset: address = USDS\n        assert self._canRegisterVaultToken(asset, _vaultAddr) # dev: cannot register vault token\n        vaultInfo = self._registerVaultTokenLocally(asset, _vaultAddr)\n        self._registerVaultTokenGlobally(asset, _vaultAddr, vaultInfo.decimals, _ledger, _legoBook)\n    return vaultInfo\n\n\n# set slippage\n\n\n@external\ndef setSlippage(_slippage: uint256) -> bool:\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert _slippage != 0 and _slippage < HUNDRED_PERCENT # dev: invalid slippage\n    self.slippage = _slippage\n    log SlippageSet(slippage=_slippage)\n    return True\n\n\n#########\n# Other #\n#########\n\n\n@view\n@external\ndef getAccessForLego(_user: address, _action: ws.ActionType) -> (address, String[64], uint256):\n    return empty(address), empty(String[64]), 0\n\n\n@external\ndef claimRewards(\n    _user: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _extraData: bytes32,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@view\n@external\ndef hasClaimableRewards(_user: address) -> bool:\n    return False\n\n\n@external\ndef swapTokens(\n    _amountIn: uint256,\n    _minAmountOut: uint256,\n    _tokenPath: DynArray[address, MAX_TOKEN_PATH],\n    _poolPath: DynArray[address, MAX_TOKEN_PATH - 1],\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256):\n    return 0, 0, 0\n\n\n@external\ndef mintOrRedeemAsset(\n    _tokenIn: address,\n    _tokenOut: address,\n    _tokenInAmount: uint256,\n    _minAmountOut: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, bool, uint256):\n    return 0, 0, False, 0\n\n\n@external\ndef confirmMintOrRedeemAsset(\n    _tokenIn: address,\n    _tokenOut: address,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef addCollateral(\n    _asset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef removeCollateral(\n    _asset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef borrow(\n    _borrowAsset: address,\n    _amount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef repayDebt(\n    _paymentAsset: address,\n    _paymentAmount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256):\n    return 0, 0\n\n\n@external\ndef addLiquidity(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _amountA: uint256,\n    _amountB: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _minLpAmount: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (address, uint256, uint256, uint256, uint256):\n    return empty(address), 0, 0, 0, 0\n\n\n@external\ndef removeLiquidity(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpToken: address,\n    _lpAmount: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, uint256):\n    return 0, 0, 0, 0\n\n\n@external\ndef addLiquidityConcentrated(\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _tickLower: int24,\n    _tickUpper: int24,\n    _amountA: uint256,\n    _amountB: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, uint256, uint256):\n    return 0, 0, 0, 0, 0\n\n\n@external\ndef removeLiquidityConcentrated(\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _liqToRemove: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _extraData: bytes32,\n    _recipient: address,\n    _miniAddys: ws.MiniAddys = empty(ws.MiniAddys),\n) -> (uint256, uint256, uint256, bool, uint256):\n    return 0, 0, 0, False, 0",
            "sha256sum": "4b307e47eeb2619bc2032824664c68c4da0b74aeff31bfe7b1e55a0cc95e4b29"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/legos/yield/SkyPsm.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.3+commit.bff19ea2",
        "integrity": "4988baa767327558b870535829c2f6b7575601a20de9b1c7365b5e95a9250e39"
      },
      "args": "00000000000000000000000044cf3c4f000dfd76a35d03298049d37be688d6f90000000000000000000000001601843c5e9bc251a3272907010afa41fa18347e",
      "file": "contracts/legos/yield/SkyPsm.vy"
    }
  }
}