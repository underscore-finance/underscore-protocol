{
  "contracts": {
    "LegoBook": {
      "address": "0x9788f0D9D1A6577F685972B066b4Db2D73fEd8e3",
      "abi": [
        {
          "name": "LegoToolsSet",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeTimeLockModified",
          "inputs": [
            {
              "name": "prevTimeLock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "newTimeLock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "RegistryTimeLockModified",
          "inputs": [
            {
              "name": "newTimeLock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "prevTimeLock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeStarted",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeConfirmed",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeCancelled",
          "inputs": [
            {
              "name": "cancelledGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovRelinquished",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UndyHqSetupFinished",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "timeLock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "DepartmentPauseModified",
          "inputs": [
            {
              "name": "isPaused",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "DepartmentFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "balance",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "NewAddressPending",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "NewAddressConfirmed",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "regId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "NewAddressCancelled",
          "inputs": [
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddressUpdatePending",
          "inputs": [
            {
              "name": "regId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "newAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "prevAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "version",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddressUpdateConfirmed",
          "inputs": [
            {
              "name": "regId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "newAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "prevAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "version",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddressUpdateCancelled",
          "inputs": [
            {
              "name": "regId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "newAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "prevAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddressDisablePending",
          "inputs": [
            {
              "name": "regId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "version",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddressDisableConfirmed",
          "inputs": [
            {
              "name": "regId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "version",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddressDisableCancelled",
          "inputs": [
            {
              "name": "regId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUndyHqFromGov",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canGovern",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getGovernors",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPendingGovChange",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "startGovernanceChange",
          "inputs": [
            {
              "name": "_newGov",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "relinquishGov",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setGovTimeLock",
          "inputs": [
            {
              "name": "_numBlocks",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidGovTimeLock",
          "inputs": [
            {
              "name": "_newTimeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "minGovChangeTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "maxGovChangeTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "finishUndyHqSetup",
          "inputs": [
            {
              "name": "_newGov",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "finishUndyHqSetup",
          "inputs": [
            {
              "name": "_newGov",
              "type": "address"
            },
            {
              "name": "_timeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "governance",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingGov",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "newGov",
                  "type": "address"
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numGovChanges",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "govChangeTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRegistryDescription",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "string"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidNewAddress",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidAddressUpdate",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            },
            {
              "name": "_newAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidAddressDisable",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setRegistryTimeLock",
          "inputs": [
            {
              "name": "_numBlocks",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidRegistryTimeLock",
          "inputs": [
            {
              "name": "_numBlocks",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setRegistryTimeLockAfterSetup",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setRegistryTimeLockAfterSetup",
          "inputs": [
            {
              "name": "_numBlocks",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "minRegistryTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "maxRegistryTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidAddr",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidRegId",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRegId",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddr",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddrInfo",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "addr",
                  "type": "address"
                },
                {
                  "name": "version",
                  "type": "uint256"
                },
                {
                  "name": "lastModified",
                  "type": "uint256"
                },
                {
                  "name": "description",
                  "type": "string"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddrDescription",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "string"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getNumAddrs",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLastAddr",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLastRegId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "registryChangeTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "addrInfo",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "addr",
                  "type": "address"
                },
                {
                  "name": "version",
                  "type": "uint256"
                },
                {
                  "name": "lastModified",
                  "type": "uint256"
                },
                {
                  "name": "description",
                  "type": "string"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "addrToRegId",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAddrs",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingNewAddr",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "description",
                  "type": "string"
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingAddrUpdate",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "newAddr",
                  "type": "address"
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingAddrDisable",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddys",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "undyToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "hatchery",
                  "type": "address"
                },
                {
                  "name": "lootDistributor",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                },
                {
                  "name": "walletBackpack",
                  "type": "address"
                },
                {
                  "name": "billing",
                  "type": "address"
                },
                {
                  "name": "vaultRegistry",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUndyHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canMintUndy",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pause",
          "inputs": [
            {
              "name": "_shouldPause",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFundsMany",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_assets",
              "type": "address[]"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isPaused",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isLegoAddr",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "startAddNewAddressToRegistry",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            },
            {
              "name": "_description",
              "type": "string"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmNewAddressToRegistry",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelNewAddressToRegistry",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "startAddressUpdateToRegistry",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            },
            {
              "name": "_newAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmAddressUpdateToRegistry",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelAddressUpdateToRegistry",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "startAddressDisableInRegistry",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmAddressDisableInRegistry",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelAddressDisableInRegistry",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setLegoTools",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidLegoTools",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "legoTools",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_undyHq",
              "type": "address"
            },
            {
              "name": "_initialGov",
              "type": "address"
            },
            {
              "name": "_minRegistryTimeLock",
              "type": "uint256"
            },
            {
              "name": "_maxRegistryTimeLock",
              "type": "uint256"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/modules/LocalGov.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\ninterface UndyHq:\n    def minGovChangeTimeLock() -> uint256: view\n    def maxGovChangeTimeLock() -> uint256: view\n    def governance() -> address: view\n\nstruct PendingGovernance:\n    newGov: address\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeStarted:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    confirmBlock: uint256\n\nevent GovChangeConfirmed:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeCancelled:\n    cancelledGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovRelinquished:\n    prevGov: indexed(address)\n\nevent GovChangeTimeLockModified:\n    prevTimeLock: uint256\n    newTimeLock: uint256\n\nevent UndyHqSetupFinished:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    timeLock: uint256\n\n# governance\ngovernance: public(address)\npendingGov: public(PendingGovernance)\nnumGovChanges: public(uint256)\n\n# time lock\ngovChangeTimeLock: public(uint256)\n\n# config\nUNDY_HQ_FOR_GOV: immutable(address)\nMIN_GOV_TIME_LOCK: immutable(uint256)\nMAX_GOV_TIME_LOCK: immutable(uint256)\n\n\n@deploy\ndef __init__(\n    _undyHq: address,\n    _initialGov: address,\n    _minTimeLock: uint256,\n    _maxTimeLock: uint256,\n    _initialTimeLock: uint256,\n):\n    UNDY_HQ_FOR_GOV = _undyHq\n    self.governance = _initialGov\n\n    # undy hq\n    if _undyHq == empty(address):\n        assert _initialGov != empty(address) # dev: undy hq must have gov\n\n    # local gov (department, other smart contracts)\n    else:\n        hqGov: address = staticcall UndyHq(_undyHq).governance()\n        assert hqGov != empty(address) # dev: undy hq must have gov\n        assert _initialGov != hqGov # dev: undy hq cannot set same gov\n\n    # time locks\n    minTimeLock: uint256 = _minTimeLock\n    maxTimeLock: uint256 = _maxTimeLock\n    if minTimeLock == 0 or maxTimeLock == 0:\n        assert _undyHq != empty(address) # dev: need undy hq if no time locks\n        minTimeLock = staticcall UndyHq(_undyHq).minGovChangeTimeLock()\n        maxTimeLock = staticcall UndyHq(_undyHq).maxGovChangeTimeLock()\n\n    # set min and max time locks\n    assert minTimeLock < maxTimeLock # dev: invalid time lock\n    assert minTimeLock != 0 and maxTimeLock != max_value(uint256) # dev: invalid time lock\n    MIN_GOV_TIME_LOCK = minTimeLock\n    MAX_GOV_TIME_LOCK = maxTimeLock\n\n    # this contract is top level governance from Undy HQ -- not setting initial time lock during setup\n    if _undyHq == empty(address):\n        return\n\n    # set initial time lock (for local gov)\n    initialTimeLock: uint256 = max(minTimeLock, _initialTimeLock)\n    assert self._setGovTimeLock(initialTimeLock) # dev: invalid time lock\n\n\n@view\n@external\ndef getUndyHqFromGov() -> address:\n    return self._getUndyHqFromGov()\n\n\n@view\n@internal\ndef _getUndyHqFromGov() -> address:\n    return UNDY_HQ_FOR_GOV\n\n\n##############\n# Gov Access #\n##############\n\n\n@view\n@external\ndef canGovern(_addr: address) -> bool:\n    return self._canGovern(_addr)\n\n\n@view\n@internal\ndef _canGovern(_addr: address) -> bool:\n    if _addr == empty(address):\n        return False\n    return _addr in self._getGovernors()\n\n\n@view\n@external\ndef getGovernors() -> DynArray[address, 2]:\n    return self._getGovernors()\n\n\n@view\n@internal\ndef _getGovernors() -> DynArray[address, 2]:\n    governors: DynArray[address, 2] = []\n\n    # local governance\n    localGov: address = self.governance\n    if localGov != empty(address):\n        governors.append(localGov)\n\n    # undy hq governance\n    undyHq: address = UNDY_HQ_FOR_GOV\n    if undyHq == empty(address):\n        return governors\n\n    hqGov: address = staticcall UndyHq(undyHq).governance()\n    if hqGov != empty(address):\n        governors.append(hqGov)\n\n    return governors\n\n\n######################\n# Governance Changes #\n######################\n\n\n@view\n@external\ndef hasPendingGovChange() -> bool:\n    return self.pendingGov.confirmBlock != 0\n\n\n@view\n@internal\ndef _isUndyHq() -> bool:\n    return UNDY_HQ_FOR_GOV == empty(address)\n\n\n# start gov change\n\n\n@external\ndef startGovernanceChange(_newGov: address):\n    governors: DynArray[address, 2] = self._getGovernors()\n    assert msg.sender in governors # dev: no perms\n\n    # validation\n    if _newGov != empty(address):\n        assert _newGov not in governors # dev: invalid _newGov\n        assert _newGov.is_contract # dev: _newGov must be a contract\n    else:\n        assert not self._isUndyHq() # dev: undy hq cannot set 0x0\n\n    confirmBlock: uint256 = block.number + self.govChangeTimeLock\n    self.pendingGov = PendingGovernance(\n        newGov= _newGov,\n        initiatedBlock= block.number,\n        confirmBlock= confirmBlock,\n    )\n    log GovChangeStarted(prevGov=self.governance, newGov=_newGov, confirmBlock=confirmBlock)\n\n\n# confirm gov change\n\n\n@external\ndef confirmGovernanceChange():\n    data: PendingGovernance = self.pendingGov\n    assert data.confirmBlock != 0 and block.number >= data.confirmBlock # dev: time lock not reached\n\n    # check permissions\n    if data.newGov != empty(address):\n        assert msg.sender == data.newGov # dev: only new gov can confirm\n    else:\n        assert self._canGovern(msg.sender) # dev: no perms\n        assert not self._isUndyHq() # dev: undy hq cannot set 0x0\n\n    # set new governance\n    prevGov: address = self.governance\n    self.governance = data.newGov\n    self.numGovChanges += 1\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeConfirmed(prevGov=prevGov, newGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n# cancel gov change\n\n\n@external\ndef cancelGovernanceChange():\n    assert self._canGovern(msg.sender) # dev: no perms\n    data: PendingGovernance = self.pendingGov\n    assert data.confirmBlock != 0 # dev: no pending change\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeCancelled(cancelledGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n# relinquish gov (only for local gov)\n\n\n@external\ndef relinquishGov():\n    assert msg.sender == self.governance # dev: no perms\n    assert not self._isUndyHq() # dev: undy hq cannot relinquish gov\n\n    self.governance = empty(address)\n    self.numGovChanges += 1\n    log GovRelinquished(prevGov=msg.sender)\n\n\n####################\n# Time Lock Config #\n####################\n\n\n# set time lock\n\n\n@external\ndef setGovTimeLock(_numBlocks: uint256) -> bool:\n    assert self._canGovern(msg.sender) # dev: no perms\n    return self._setGovTimeLock(_numBlocks)\n\n\n@internal\ndef _setGovTimeLock(_numBlocks: uint256) -> bool:\n    prevTimeLock: uint256 = self.govChangeTimeLock\n    assert self._isValidGovTimeLock(_numBlocks, prevTimeLock) # dev: invalid time lock\n    self.govChangeTimeLock = _numBlocks\n    log GovChangeTimeLockModified(prevTimeLock=prevTimeLock, newTimeLock=_numBlocks)\n    return True\n\n\n# validation\n\n\n@view\n@external\ndef isValidGovTimeLock(_newTimeLock: uint256) -> bool:\n    return self._isValidGovTimeLock(_newTimeLock, self.govChangeTimeLock)\n\n\n@view\n@internal\ndef _isValidGovTimeLock(_newTimeLock: uint256, _prevTimeLock: uint256) -> bool:\n    if _newTimeLock == _prevTimeLock:\n        return False # no change\n    if self.pendingGov.confirmBlock != 0:\n        return False # cannot change while pending gov change\n    return _newTimeLock >= MIN_GOV_TIME_LOCK and _newTimeLock <= MAX_GOV_TIME_LOCK\n\n\n# utils\n\n\n@view\n@external\ndef minGovChangeTimeLock() -> uint256:\n    return MIN_GOV_TIME_LOCK\n\n\n@view\n@external\ndef maxGovChangeTimeLock() -> uint256:\n    return MAX_GOV_TIME_LOCK\n\n\n#################\n# Undy Hq Setup #\n#################\n\n\n@external\ndef finishUndyHqSetup(_newGov: address, _timeLock: uint256 = 0) -> bool:\n    assert self._isUndyHq() # dev: only undy hq\n    assert msg.sender == self.governance # dev: no perms\n    assert self.numGovChanges == 0 # dev: already changed gov\n\n    # validation\n    assert _newGov != empty(address) and _newGov.is_contract # dev: invalid _newGov\n    prevGov: address = self.governance\n\n    # set new gov\n    self.governance = _newGov\n    self.numGovChanges += 1\n\n    # set time lock\n    timeLock: uint256 = _timeLock\n    if timeLock == 0:\n        timeLock = MIN_GOV_TIME_LOCK\n    assert self._setGovTimeLock(timeLock) # dev: invalid time lock\n\n    log UndyHqSetupFinished(prevGov=prevGov, newGov=_newGov, timeLock=timeLock)\n    return True",
            "sha256sum": "c41aa3e0d0d96b512171813377ea277e2c7da690c3cd9b4662733b3f11f705b0"
          },
          "contracts/modules/AddressRegistry.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nuses: gov\nimport contracts.modules.LocalGov as gov\n\nstruct AddressInfo:\n    addr: address\n    version: uint256\n    lastModified: uint256\n    description: String[64]\n\nstruct PendingNewAddress:\n    description: String[64]\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nstruct PendingAddressUpdate:\n    newAddr: address\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nstruct PendingAddressDisable:\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent NewAddressPending:\n    addr: indexed(address)\n    description: String[64]\n    confirmBlock: uint256\n    registry: String[28]\n\nevent NewAddressConfirmed:\n    addr: indexed(address)\n    regId: uint256\n    description: String[64]\n    registry: String[28]\n\nevent NewAddressCancelled:\n    description: String[64]\n    addr: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n    registry: String[28]\n\nevent AddressUpdatePending:\n    regId: uint256\n    description: String[64]\n    newAddr: indexed(address)\n    prevAddr: indexed(address)\n    version: uint256\n    confirmBlock: uint256\n    registry: String[28]\n\nevent AddressUpdateConfirmed:\n    regId: uint256\n    description: String[64]\n    newAddr: indexed(address)\n    prevAddr: indexed(address)\n    version: uint256\n    registry: String[28]\n\nevent AddressUpdateCancelled:\n    regId: uint256\n    description: String[64]\n    newAddr: indexed(address)\n    prevAddr: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n    registry: String[28]\n\nevent AddressDisablePending:\n    regId: uint256\n    description: String[64]\n    addr: indexed(address)\n    version: uint256\n    confirmBlock: uint256\n    registry: String[28]\n\nevent AddressDisableConfirmed:\n    regId: uint256\n    description: String[64]\n    addr: indexed(address)\n    version: uint256\n    registry: String[28]\n\nevent AddressDisableCancelled:\n    regId: uint256\n    description: String[64]\n    addr: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n    registry: String[28]\n\nevent RegistryTimeLockModified:\n    newTimeLock: uint256\n    prevTimeLock: uint256\n    registry: String[28]\n\n# time lock\nregistryChangeTimeLock: public(uint256)\n\n# core data (address registry)\naddrInfo: public(HashMap[uint256, AddressInfo]) # regId -> address info\naddrToRegId: public(HashMap[address, uint256]) # addr -> regId\nnumAddrs: public(uint256) # number of addrs in registry\n\n# pending changes\npendingNewAddr: public(HashMap[address, PendingNewAddress]) # addr -> pending new addr\npendingAddrUpdate: public(HashMap[uint256, PendingAddressUpdate]) # regId -> pending addr update\npendingAddrDisable: public(HashMap[uint256, PendingAddressDisable]) # regId -> pending addr disable\n\nREGISTRY_STR: immutable(String[28])\nMIN_REG_TIME_LOCK: immutable(uint256)\nMAX_REG_TIME_LOCK: immutable(uint256)\n\n\n@deploy\ndef __init__(\n    _minTimeLock: uint256,\n    _maxTimeLock: uint256,\n    _initialTimeLock: uint256,\n    _registryStr: String[28],\n):\n    REGISTRY_STR = _registryStr\n\n    assert _minTimeLock < _maxTimeLock # dev: invalid time lock\n    assert _minTimeLock != 0 and _maxTimeLock != max_value(uint256) # dev: invalid time lock\n    MIN_REG_TIME_LOCK = _minTimeLock\n    MAX_REG_TIME_LOCK = _maxTimeLock\n\n    # set initial time lock -- this may be zero during inital setup of registry\n    if _initialTimeLock != 0:\n        assert self._setRegistryTimeLock(_initialTimeLock) # dev: invalid time lock\n\n    # start at 1 index\n    self.numAddrs = 1\n\n\n@view\n@external\ndef getRegistryDescription() -> String[28]:\n    return REGISTRY_STR\n\n\n###############\n# New Address #\n###############\n\n\n# register new address\n\n\n@internal\ndef _startAddNewAddressToRegistry(_addr: address, _description: String[64]) -> bool:\n    assert self._isValidNewAddress(_addr) # dev: invalid addy\n\n    confirmBlock: uint256 = block.number + self.registryChangeTimeLock\n    self.pendingNewAddr[_addr] = PendingNewAddress(\n        description=_description,\n        initiatedBlock=block.number,\n        confirmBlock=confirmBlock,\n    )\n\n    log NewAddressPending(addr=_addr, description=_description, confirmBlock=confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n# confirm new address\n\n\n@internal\ndef _confirmNewAddressToRegistry(_addr: address) -> uint256:\n    data: PendingNewAddress = self.pendingNewAddr[_addr]\n    assert data.confirmBlock != 0 and block.number >= data.confirmBlock # dev: time lock not reached\n\n    if not self._isValidNewAddress(_addr):\n        self.pendingNewAddr[_addr] = empty(PendingNewAddress) # clear pending\n        return 0\n\n    # register new addy\n    regId: uint256 = self.numAddrs\n    self.addrToRegId[_addr] = regId\n    self.numAddrs = regId + 1\n    self.addrInfo[regId] = AddressInfo(\n        addr=_addr,\n        version=1,\n        lastModified=block.timestamp,\n        description=data.description,\n    )\n\n    # clear pending\n    self.pendingNewAddr[_addr] = empty(PendingNewAddress)\n\n    log NewAddressConfirmed(addr=_addr, regId=regId, description=data.description, registry=REGISTRY_STR)\n    return regId\n\n\n# cancel new address\n\n\n@internal\ndef _cancelNewAddressToRegistry(_addr: address) -> bool:\n    data: PendingNewAddress = self.pendingNewAddr[_addr]\n    assert data.confirmBlock != 0 # dev: no pending\n\n    self.pendingNewAddr[_addr] = empty(PendingNewAddress)\n    log NewAddressCancelled(description=data.description, addr=_addr, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n# validation\n\n\n@view\n@external\ndef isValidNewAddress(_addr: address) -> bool:\n    return self._isValidNewAddress(_addr)\n\n\n@view\n@internal\ndef _isValidNewAddress(_addr: address) -> bool:\n    if _addr == empty(address) or not _addr.is_contract:\n        return False\n    return self.addrToRegId[_addr] == 0\n\n\n###################\n# Address Updates #\n###################\n\n\n# update address\n\n\n@internal\ndef _startAddressUpdateToRegistry(_regId: uint256, _newAddr: address) -> bool:\n    data: AddressInfo = self.addrInfo[_regId]\n    assert self._isValidAddressUpdate(_regId, _newAddr, data.addr) # dev: invalid update\n\n    # set pending\n    confirmBlock: uint256 = block.number + self.registryChangeTimeLock\n    self.pendingAddrUpdate[_regId] = PendingAddressUpdate(\n        newAddr=_newAddr,\n        initiatedBlock=block.number,\n        confirmBlock=confirmBlock,\n    )\n\n    log AddressUpdatePending(regId=_regId, description=data.description, newAddr=_newAddr, prevAddr=data.addr, version=data.version, confirmBlock=confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n# confirm update address\n\n\n@internal\ndef _confirmAddressUpdateToRegistry(_regId: uint256) -> bool:\n    newData: PendingAddressUpdate = self.pendingAddrUpdate[_regId]\n    assert newData.confirmBlock != 0 and block.number >= newData.confirmBlock # dev: time lock not reached\n\n    data: AddressInfo = self.addrInfo[_regId]\n    prevAddr: address = data.addr # needed for later\n    if not self._isValidAddressUpdate(_regId, newData.newAddr, prevAddr):\n        self.pendingAddrUpdate[_regId] = empty(PendingAddressUpdate) # clear pending\n        return False\n\n    # update addy data\n    data.addr = newData.newAddr\n    data.lastModified = block.timestamp\n    data.version += 1\n    self.addrInfo[_regId] = data\n    self.addrToRegId[newData.newAddr] = _regId\n\n    # handle previous addr\n    if prevAddr != empty(address):\n        self.addrToRegId[prevAddr] = 0\n\n    # clear pending\n    self.pendingAddrUpdate[_regId] = empty(PendingAddressUpdate)\n\n    log AddressUpdateConfirmed(regId=_regId, description=data.description, newAddr=newData.newAddr, prevAddr=prevAddr, version=data.version, registry=REGISTRY_STR)\n    return True\n\n\n# cancel update address\n\n\n@internal\ndef _cancelAddressUpdateToRegistry(_regId: uint256) -> bool:\n    data: PendingAddressUpdate = self.pendingAddrUpdate[_regId]\n    assert data.confirmBlock != 0 # dev: no pending\n\n    self.pendingAddrUpdate[_regId] = empty(PendingAddressUpdate)\n    prevData: AddressInfo = self.addrInfo[_regId]\n    log AddressUpdateCancelled(regId=_regId, description=prevData.description, newAddr=data.newAddr, prevAddr=prevData.addr, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n# validation\n\n\n@view\n@external\ndef isValidAddressUpdate(_regId: uint256, _newAddr: address) -> bool:\n    return self._isValidAddressUpdate(_regId, _newAddr, self.addrInfo[_regId].addr)\n\n\n@view\n@internal\ndef _isValidAddressUpdate(_regId: uint256, _newAddr: address, _prevAddr: address) -> bool:\n    if not self._isValidRegId(_regId):\n        return False\n    if not self._isValidNewAddress(_newAddr):\n        return False\n    return _newAddr != _prevAddr\n\n\n###################\n# Disable Address #\n###################\n\n\n# start disable address\n\n\n@internal\ndef _startAddressDisableInRegistry(_regId: uint256) -> bool:\n    data: AddressInfo = self.addrInfo[_regId]\n    assert self._isValidAddressDisable(_regId, data.addr) # dev: invalid disable\n\n    # set pending\n    confirmBlock: uint256 = block.number + self.registryChangeTimeLock\n    self.pendingAddrDisable[_regId] = PendingAddressDisable(\n        initiatedBlock=block.number,\n        confirmBlock=confirmBlock,\n    )\n\n    log AddressDisablePending(regId=_regId, description=data.description, addr=data.addr, version=data.version, confirmBlock=confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n# confirm disable address\n\n\n@internal\ndef _confirmAddressDisableInRegistry(_regId: uint256) -> bool:\n    newData: PendingAddressDisable = self.pendingAddrDisable[_regId]\n    assert newData.confirmBlock != 0 and block.number >= newData.confirmBlock # dev: time lock not reached\n\n    data: AddressInfo = self.addrInfo[_regId]\n    prevAddr: address = data.addr # needed for later\n    if not self._isValidAddressDisable(_regId, prevAddr):\n        self.pendingAddrDisable[_regId] = empty(PendingAddressDisable) # clear pending\n        return False\n\n    # disable addy\n    data.addr = empty(address)\n    data.lastModified = block.timestamp\n    data.version += 1\n    self.addrInfo[_regId] = data\n    self.addrToRegId[prevAddr] = 0\n\n    # clear pending\n    self.pendingAddrDisable[_regId] = empty(PendingAddressDisable)\n\n    log AddressDisableConfirmed(regId=_regId, description=data.description, addr=prevAddr, version=data.version, registry=REGISTRY_STR)\n    return True\n\n\n# cancel disable address\n\n\n@internal\ndef _cancelAddressDisableInRegistry(_regId: uint256) -> bool:\n    data: PendingAddressDisable = self.pendingAddrDisable[_regId]\n    assert data.confirmBlock != 0 # dev: no pending\n\n    self.pendingAddrDisable[_regId] = empty(PendingAddressDisable)\n    prevData: AddressInfo = self.addrInfo[_regId]\n    log AddressDisableCancelled(regId=_regId, description=prevData.description, addr=prevData.addr, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n# validation\n\n\n@view\n@external\ndef isValidAddressDisable(_regId: uint256) -> bool:\n    return self._isValidAddressDisable(_regId, self.addrInfo[_regId].addr)\n\n\n@view\n@internal\ndef _isValidAddressDisable(_regId: uint256, _prevAddr: address) -> bool:\n    if not self._isValidRegId(_regId):\n        return False\n    return _prevAddr != empty(address)\n\n\n####################\n# Time Lock Config #\n####################\n\n\n@external\ndef setRegistryTimeLock(_numBlocks: uint256) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return self._setRegistryTimeLock(_numBlocks)\n\n\n@internal\ndef _setRegistryTimeLock(_numBlocks: uint256) -> bool:\n    prevTimeLock: uint256 = self.registryChangeTimeLock\n    assert self._isValidRegistryTimeLock(_numBlocks, prevTimeLock) # dev: invalid time lock\n    self.registryChangeTimeLock = _numBlocks\n    log RegistryTimeLockModified(newTimeLock=_numBlocks, prevTimeLock=prevTimeLock, registry=REGISTRY_STR)\n    return True\n\n\n# validation\n\n\n@view\n@external\ndef isValidRegistryTimeLock(_numBlocks: uint256) -> bool:\n    return self._isValidRegistryTimeLock(_numBlocks, self.registryChangeTimeLock)\n\n\n@view\n@internal\ndef _isValidRegistryTimeLock(_newTimeLock: uint256, _prevTimeLock: uint256) -> bool:\n    if _newTimeLock == _prevTimeLock:\n        return False\n    return _newTimeLock >= MIN_REG_TIME_LOCK and _newTimeLock <= MAX_REG_TIME_LOCK\n\n\n# finish setup\n\n\n@external\ndef setRegistryTimeLockAfterSetup(_numBlocks: uint256 = 0) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert self.registryChangeTimeLock == 0 # dev: already set\n\n    timeLock: uint256 = _numBlocks\n    if timeLock == 0:\n        timeLock = MIN_REG_TIME_LOCK\n    return self._setRegistryTimeLock(timeLock)\n\n\n# utils\n\n\n@view\n@external\ndef minRegistryTimeLock() -> uint256:\n    return MIN_REG_TIME_LOCK\n\n\n@view\n@external\ndef maxRegistryTimeLock() -> uint256:\n    return MAX_REG_TIME_LOCK\n\n\n#################\n# Views / Utils #\n#################\n\n\n# is valid addr\n\n\n@view\n@external\ndef isValidAddr(_addr: address) -> bool:\n    return self._isValidAddr(_addr)\n\n\n@view\n@internal\ndef _isValidAddr(_addr: address) -> bool:\n    return self.addrToRegId[_addr] != 0\n\n\n# is valid addr id\n\n\n@view\n@external\ndef isValidRegId(_regId: uint256) -> bool:\n    return self._isValidRegId(_regId)\n\n\n@view\n@internal\ndef _isValidRegId(_regId: uint256) -> bool:\n    return _regId != 0 and _regId < self.numAddrs\n\n\n# get reg id\n\n\n@view\n@external\ndef getRegId(_addr: address) -> uint256:\n    return self._getRegId(_addr)\n\n\n@view\n@internal\ndef _getRegId(_addr: address) -> uint256:\n    return self.addrToRegId[_addr]\n\n\n# get addr\n\n\n@view\n@external\ndef getAddr(_regId: uint256) -> address:\n    return self._getAddr(_regId)\n\n\n@view\n@internal\ndef _getAddr(_regId: uint256) -> address:\n    return self.addrInfo[_regId].addr\n\n\n# get addr info\n\n\n@view\n@external\ndef getAddrInfo(_regId: uint256) -> AddressInfo:\n    return self._getAddrInfo(_regId)\n\n\n@view\n@internal\ndef _getAddrInfo(_regId: uint256) -> AddressInfo:\n    return self.addrInfo[_regId]\n\n\n# get addr description\n\n\n@view\n@external\ndef getAddrDescription(_regId: uint256) -> String[64]:\n    return self._getAddrDescription(_regId)\n\n\n@view\n@internal\ndef _getAddrDescription(_regId: uint256) -> String[64]:\n    return self.addrInfo[_regId].description\n\n\n# get num addrs\n\n\n@view\n@external\ndef getNumAddrs() -> uint256:\n    return self._getNumAddrs()\n\n\n@view\n@internal\ndef _getNumAddrs() -> uint256:\n    return self.numAddrs - 1\n\n\n# get last addr\n\n\n@view\n@external\ndef getLastAddr() -> address:\n    return self._getLastAddr()\n\n\n@view\n@internal\ndef _getLastAddr() -> address:\n    lastRegId: uint256 = self.numAddrs - 1\n    return self.addrInfo[lastRegId].addr\n\n\n# get last reg id\n\n\n@view\n@external\ndef getLastRegId() -> uint256:\n    return self._getLastRegId()\n\n\n@view\n@internal\ndef _getLastRegId() -> uint256:\n    return self.numAddrs - 1\n",
            "sha256sum": "b88f6fc85ae3cd815c5a476c620b2fb5494b4dec5f1ce738878eded11c46396b"
          },
          "contracts/modules/Addys.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\ninterface UndyHq:\n    def isValidAddr(_addr: address) -> bool: view\n    def getAddr(_regId: uint256) -> address: view\n    def undyToken() -> address: view\n\ninterface Switchboard:\n    def isSwitchboardAddr(_addr: address) -> bool: view\n\ninterface LegoBook:\n    def isLegoAddr(_addr: address) -> bool: view\n\nstruct Addys:\n    hq: address\n    undyToken: address\n    ledger: address\n    missionControl: address\n    legoBook: address\n    switchboard: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    walletBackpack: address\n    billing: address\n    vaultRegistry: address\n\n# hq\nUNDY_HQ_FOR_ADDYS: immutable(address)\n\n# core addys\nLEDGER_ID: constant(uint256) = 1\nMISSION_CONTROL_ID: constant(uint256) = 2\nLEGO_BOOK_ID: constant(uint256) = 3\nSWITCHBOARD_ID: constant(uint256) = 4\nHATCHERY_ID: constant(uint256) = 5\nLOOT_DISTRIBUTOR_ID: constant(uint256) = 6\nAPPRAISER_ID: constant(uint256) = 7\nWALLET_BACKPACK_ID: constant(uint256) = 8\nBILLING_ID: constant(uint256) = 9\nVAULT_REGISTRY_ID: constant(uint256) = 10\n\n\n@deploy\ndef __init__(_undyHq: address):\n    assert _undyHq != empty(address) # dev: invalid undy hq\n    UNDY_HQ_FOR_ADDYS = _undyHq\n\n\n########\n# Core #\n########\n\n\n@view\n@external\ndef getAddys() -> Addys:\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _getAddys(_addys: Addys = empty(Addys)) -> Addys:\n    if _addys.hq != empty(address):\n        return _addys\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _generateAddys() -> Addys:\n    hq: address = UNDY_HQ_FOR_ADDYS\n    return Addys(\n        hq = hq,\n        undyToken = staticcall UndyHq(hq).undyToken(),\n        ledger = staticcall UndyHq(hq).getAddr(LEDGER_ID),\n        missionControl = staticcall UndyHq(hq).getAddr(MISSION_CONTROL_ID),\n        legoBook = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID),\n        switchboard = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID),\n        hatchery = staticcall UndyHq(hq).getAddr(HATCHERY_ID),\n        lootDistributor = staticcall UndyHq(hq).getAddr(LOOT_DISTRIBUTOR_ID),\n        appraiser = staticcall UndyHq(hq).getAddr(APPRAISER_ID),\n        walletBackpack = staticcall UndyHq(hq).getAddr(WALLET_BACKPACK_ID),\n        billing = staticcall UndyHq(hq).getAddr(BILLING_ID),\n        vaultRegistry = staticcall UndyHq(hq).getAddr(VAULT_REGISTRY_ID),\n    )\n\n\n##########\n# Tokens #\n##########\n\n\n@view\n@internal\ndef _getUndyToken() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).undyToken()\n\n\n###########\n# Helpers #\n###########\n\n\n# undy hq\n\n\n@view\n@external\ndef getUndyHq() -> address:\n    return self._getUndyHq()\n\n\n@view\n@internal\ndef _getUndyHq() -> address:\n    return UNDY_HQ_FOR_ADDYS\n\n\n# utils\n\n\n@view\n@internal\ndef _isValidUndyAddr(_addr: address, _hq: address = empty(address)) -> bool:\n    hq: address = _hq\n    if _hq == empty(address):\n        hq = UNDY_HQ_FOR_ADDYS\n    \n    # core departments\n    if staticcall UndyHq(hq).isValidAddr(_addr):\n        return True\n\n    # lego book\n    legoBook: address = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID)\n    if legoBook != empty(address) and staticcall LegoBook(legoBook).isLegoAddr(_addr):\n        return True\n\n    # switchboard config\n    switchboard: address = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID)\n    if switchboard != empty(address) and staticcall Switchboard(switchboard).isSwitchboardAddr(_addr):\n        return True\n\n    return False\n\n\n@view\n@internal\ndef _isSwitchboardAddr(_addr: address) -> bool:\n    switchboard: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n    if switchboard == empty(address):\n        return False\n    return staticcall Switchboard(switchboard).isSwitchboardAddr(_addr)\n\n\n@view\n@internal\ndef _isLegoBookAddr(_addr: address) -> bool:\n    legoBook: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n    if legoBook == empty(address):\n        return False\n    return staticcall LegoBook(legoBook).isLegoAddr(_addr)\n\n\n###############\n# Departments #\n###############\n\n\n# ledger\n\n\n@view\n@internal\ndef _getLedgerId() -> uint256:\n    return LEDGER_ID\n\n\n@view\n@internal\ndef _getLedgerAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEDGER_ID)\n\n\n# mission control\n\n\n@view\n@internal\ndef _getMissionControlId() -> uint256:\n    return MISSION_CONTROL_ID\n\n\n@view\n@internal\ndef _getMissionControlAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(MISSION_CONTROL_ID)\n\n\n# lego book\n\n\n@view\n@internal\ndef _getLegoBookId() -> uint256:\n    return LEGO_BOOK_ID\n\n\n@view\n@internal\ndef _getLegoBookAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n\n\n# switchboard\n\n\n@view\n@internal\ndef _getSwitchboardId() -> uint256:\n    return SWITCHBOARD_ID\n\n\n@view\n@internal\ndef _getSwitchboardAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n\n\n# hatchery\n\n\n@view\n@internal\ndef _getHatcheryId() -> uint256:\n    return HATCHERY_ID\n\n\n@view\n@internal\ndef _getHatcheryAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(HATCHERY_ID)\n\n\n# loot distributor\n\n\n@view\n@internal\ndef _getLootDistributorId() -> uint256:\n    return LOOT_DISTRIBUTOR_ID\n\n\n@view\n@internal\ndef _getLootDistributorAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LOOT_DISTRIBUTOR_ID)\n\n\n# appraiser\n\n\n@view\n@internal\ndef _getAppraiserId() -> uint256:\n    return APPRAISER_ID\n\n\n@view\n@internal\ndef _getAppraiserAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(APPRAISER_ID)\n\n\n# wallet backpack\n\n\n@view\n@internal\ndef _getWalletBackpackId() -> uint256:\n    return WALLET_BACKPACK_ID\n\n\n@view\n@internal\ndef _getWalletBackpackAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(WALLET_BACKPACK_ID)\n\n\n# billing\n\n\n@view\n@internal\ndef _getBillingId() -> uint256:\n    return BILLING_ID\n\n\n@view\n@internal\ndef _getBillingAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(BILLING_ID)\n\n\n# vault registry\n\n\n@view\n@internal\ndef _getVaultRegistryId() -> uint256:\n    return VAULT_REGISTRY_ID\n\n\n@view\n@internal\ndef _getVaultRegistryAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(VAULT_REGISTRY_ID)",
            "sha256sum": "4df6b72db9bb417d1af81660175be1450cfb7b3575f3d17a5b8a130bff87b781"
          },
          "interfaces/Department.vyi": {
            "content": "# @version 0.4.3\n\n\n###########\n# Minting #\n###########\n\n\n@view\n@external\ndef canMintUndy() -> bool:\n    # used in UndyHq.vy\n    ...\n\n\n########\n# Undy #\n########\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "53e48da591c4ee36045a8950c9d3a01458456b471b797df536e9a9f54404e721"
          },
          "contracts/modules/DeptBasics.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nuses: addys\nimplements: dept\n\nimport contracts.modules.Addys as addys\nimport interfaces.Department as dept\nfrom ethereum.ercs import IERC20\n\nevent DepartmentPauseModified:\n    isPaused: bool\n\nevent DepartmentFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    balance: uint256\n\nisPaused: public(bool)\n\nCAN_MINT_UNDY: immutable(bool)\nMAX_RECOVER_ASSETS: constant(uint256) = 20\n\n\n@deploy\ndef __init__(_shouldPause: bool, _canMintUndy: bool):\n    self.isPaused = _shouldPause\n    CAN_MINT_UNDY = _canMintUndy\n\n\n###########\n# Minting #\n###########\n\n\n@view\n@external\ndef canMintUndy() -> bool:\n    return CAN_MINT_UNDY\n\n\n########\n# Undy #\n########\n\n\n# activate\n\n\n@external\ndef pause(_shouldPause: bool):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert _shouldPause != self.isPaused # dev: no change\n    self.isPaused = _shouldPause\n    log DepartmentPauseModified(isPaused=_shouldPause)\n\n\n# recover funds\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    self._recoverFunds(_recipient, _asset)\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, MAX_RECOVER_ASSETS]):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    for a: address in _assets:\n        self._recoverFunds(_recipient, a)\n\n\n@internal\ndef _recoverFunds(_recipient: address, _asset: address):\n    assert empty(address) not in [_recipient, _asset] # dev: invalid recipient or asset\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    assert balance != 0 # dev: nothing to recover\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log DepartmentFundsRecovered(asset=_asset, recipient=_recipient, balance=balance)\n",
            "sha256sum": "976a50a3807bcf71f3f1c57de5cd7a59fe4e8f27b4d4560e774073962f44d1ac"
          },
          "interfaces/WalletStructs.vyi": {
            "content": "# @version 0.4.3\n\nflag ActionType:\n    TRANSFER\n    EARN_DEPOSIT\n    EARN_WITHDRAW\n    EARN_REBALANCE\n    SWAP\n    MINT_REDEEM\n    CONFIRM_MINT_REDEEM\n    ADD_COLLATERAL\n    REMOVE_COLLATERAL\n    BORROW\n    REPAY_DEBT\n    REWARDS\n    ETH_TO_WETH\n    WETH_TO_ETH\n    ADD_LIQ\n    REMOVE_LIQ\n    ADD_LIQ_CONC\n    REMOVE_LIQ_CONC\n    PAY_CHEQUE\n\nstruct WalletAssetData:\n    assetBalance: uint256\n    usdValue: uint256\n    isYieldAsset: bool\n    lastPricePerShare: uint256\n\nstruct ActionData:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    billing: address\n    wallet: address\n    walletConfig: address\n    walletOwner: address\n    inEjectMode: bool\n    isFrozen: bool\n    lastTotalUsdValue: uint256\n    signer: address\n    isManager: bool\n    legoId: uint256\n    legoAddr: address\n    eth: address\n    weth: address\n\nstruct MiniAddys:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    appraiser: address",
            "sha256sum": "9a4b4f59b3a62043e51b425a665064aae419a3c0bd0514b6b29a9441ae364bb9"
          },
          "interfaces/LegoPartner.vyi": {
            "content": "# @version 0.4.3\n\nfrom interfaces import WalletStructs as ws\n\nMAX_TOKEN_PATH: constant(uint256) = 5\nMAX_RECOVER_ASSETS: constant(uint256) = 20\n\n@external\ndef addLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _tickLower: int24, _tickUpper: int24, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef addLiquidity(_pool: address, _tokenA: address, _tokenB: address, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _minLpAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (address, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef removeLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _liqToRemove: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef removeLiquidity(_pool: address, _tokenA: address, _tokenB: address, _lpToken: address, _lpAmount: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef mintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _tokenInAmount: uint256, _minAmountOut: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef swapTokens(_amountIn: uint256, _minAmountOut: uint256, _tokenPath: DynArray[address, MAX_TOKEN_PATH], _poolPath: DynArray[address, MAX_TOKEN_PATH - 1], _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256):\n    ...\n\n@external\ndef depositForYield(_asset: address, _amount: uint256, _vaultAddr: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef withdrawFromYield(_vaultToken: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef confirmMintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef borrow(_borrowAsset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef repayDebt(_paymentAsset: address, _paymentAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef claimRewards(_user: address, _rewardToken: address, _rewardAmount: uint256, _extraData: bytes32, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef removeCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef addCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@view\n@external\ndef getAccessForLego(_user: address, _action: ws.ActionType) -> (address, String[64], uint256):\n    ...\n\n@view\n@external\ndef hasCapability(_action: ws.ActionType) -> bool:\n    ...\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    ...\n\n@view\n@external\ndef isYieldLego() -> bool:\n    ...\n\n@view\n@external\ndef isDexLego() -> bool:\n    ...\n\n\n# common\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "81db71fe4440a3b4b563134c9b5caf1d5705772a5f291fe874c9b5fb3cfb1623"
          },
          "contracts/registries/LegoBook.vy": {
            "content": "#          ___       ___           ___           ___                ___           ___           ___           ___     \n#         /\\__\\     /\\  \\         /\\  \\         /\\  \\              /\\  \\         /\\  \\         /\\  \\         /\\__\\    \n#        /:/  /    /::\\  \\       /::\\  \\       /::\\  \\            /::\\  \\       /::\\  \\       /::\\  \\       /:/  /    \n#       /:/  /    /:/\\:\\  \\     /:/\\:\\  \\     /:/\\:\\  \\          /:/\\:\\  \\     /:/\\:\\  \\     /:/\\:\\  \\     /:/__/     \n#      /:/  /    /::\\~\\:\\  \\   /:/  \\:\\  \\   /:/  \\:\\  \\        /::\\~\\:\\__\\   /:/  \\:\\  \\   /:/  \\:\\  \\   /::\\__\\____ \n#     /:/__/    /:/\\:\\ \\:\\__\\ /:/__/_\\:\\__\\ /:/__/ \\:\\__\\      /:/\\:\\ \\:|__| /:/__/ \\:\\__\\ /:/__/ \\:\\__\\ /:/\\:::::\\__\\\n#     \\:\\  \\    \\:\\~\\:\\ \\/__/ \\:\\  /\\ \\/__/ \\:\\  \\ /:/  /      \\:\\~\\:\\/:/  / \\:\\  \\ /:/  / \\:\\  \\ /:/  / \\/_|:|~~|~   \n#      \\:\\  \\    \\:\\ \\:\\__\\    \\:\\ \\:\\__\\    \\:\\  /:/  /        \\:\\ \\::/  /   \\:\\  /:/  /   \\:\\  /:/  /     |:|  |    \n#       \\:\\  \\    \\:\\ \\/__/     \\:\\/:/  /     \\:\\/:/  /          \\:\\/:/  /     \\:\\/:/  /     \\:\\/:/  /      |:|  |    \n#        \\:\\__\\    \\:\\__\\        \\::/  /       \\::/  /            \\::/__/       \\::/  /       \\::/  /       |:|  |    \n#         \\/__/     \\/__/         \\/__/         \\/__/              ~~            \\/__/         \\/__/         \\|__|    \n#\n#     \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n#     \u2551  ** Lego Book **                                                               \u2551\n#     \u2551  Address registry for Legos (DeFi integrations -- yield protocols, DEXs, etc). \u2551\n#     \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n#\n#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nimplements: Department\n\nexports: gov.__interface__\nexports: registry.__interface__\nexports: addys.__interface__\nexports: deptBasics.__interface__\n\ninitializes: gov\ninitializes: registry[gov := gov]\ninitializes: addys\ninitializes: deptBasics[addys := addys]\n\nimport contracts.modules.LocalGov as gov\nimport contracts.modules.AddressRegistry as registry\nimport contracts.modules.Addys as addys\nimport contracts.modules.DeptBasics as deptBasics\n\nfrom interfaces import LegoPartner as Lego\nfrom interfaces import Department\n\nevent LegoToolsSet:\n    addr: indexed(address)\n\nlegoTools: public(address)\n\n\n@deploy\ndef __init__(\n    _undyHq: address,\n    _initialGov: address,\n    _minRegistryTimeLock: uint256,\n    _maxRegistryTimeLock: uint256,\n):\n    gov.__init__(_undyHq, _initialGov, 0, 0, 0)\n    registry.__init__(_minRegistryTimeLock, _maxRegistryTimeLock, 0, \"LegoBook.vy\")\n    addys.__init__(_undyHq)\n    deptBasics.__init__(False, False)\n\n\n@view\n@external\ndef isLegoAddr(_addr: address) -> bool:\n    return registry._isValidAddr(_addr)\n\n\n############\n# Registry #\n############\n\n\n# new address\n\n\n@external\ndef startAddNewAddressToRegistry(_addr: address, _description: String[64]) -> bool:\n    assert self._canPerformAction(msg.sender) # dev: no perms\n    return registry._startAddNewAddressToRegistry(_addr, _description)\n\n\n@external\ndef confirmNewAddressToRegistry(_addr: address) -> uint256:\n    assert self._canPerformAction(msg.sender) # dev: no perms\n    return registry._confirmNewAddressToRegistry(_addr)\n\n\n@external\ndef cancelNewAddressToRegistry(_addr: address) -> bool:\n    assert self._canPerformAction(msg.sender) # dev: no perms\n    return registry._cancelNewAddressToRegistry(_addr)\n\n\n# address update\n\n\n@external\ndef startAddressUpdateToRegistry(_regId: uint256, _newAddr: address) -> bool:\n    assert self._canPerformAction(msg.sender) # dev: no perms\n    return registry._startAddressUpdateToRegistry(_regId, _newAddr)\n\n\n@external\ndef confirmAddressUpdateToRegistry(_regId: uint256) -> bool:\n    assert self._canPerformAction(msg.sender) # dev: no perms\n    return registry._confirmAddressUpdateToRegistry(_regId)\n\n\n@external\ndef cancelAddressUpdateToRegistry(_regId: uint256) -> bool:\n    assert self._canPerformAction(msg.sender) # dev: no perms\n    return registry._cancelAddressUpdateToRegistry(_regId)\n\n\n# address disable\n\n\n@external\ndef startAddressDisableInRegistry(_regId: uint256) -> bool:\n    assert self._canPerformAction(msg.sender) # dev: no perms\n    return registry._startAddressDisableInRegistry(_regId)\n\n\n@external\ndef confirmAddressDisableInRegistry(_regId: uint256) -> bool:\n    assert self._canPerformAction(msg.sender) # dev: no perms\n    return registry._confirmAddressDisableInRegistry(_regId)\n\n\n@external\ndef cancelAddressDisableInRegistry(_regId: uint256) -> bool:\n    assert self._canPerformAction(msg.sender) # dev: no perms\n    return registry._cancelAddressDisableInRegistry(_regId)\n\n\n##############\n# Lego Tools #\n##############\n\n\n@external\ndef setLegoTools(_addr: address) -> bool:\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    if not self._isValidLegoTools(_addr):\n        return False\n    self.legoTools = _addr\n    log LegoToolsSet(addr = _addr)\n    return True\n\n\n@view\n@external \ndef isValidLegoTools(_addr: address) -> bool:\n    return self._isValidLegoTools(_addr)\n\n\n@view\n@internal \ndef _isValidLegoTools(_addr: address) -> bool:\n    if not _addr.is_contract or _addr == empty(address):\n        return False\n    return _addr != self.legoTools\n\n\n#############\n# Utilities #\n#############\n\n\n@view\n@internal\ndef _canPerformAction(_caller: address) -> bool:\n    return gov._canGovern(_caller) and not deptBasics.isPaused",
            "sha256sum": "df672ba936fd221a5ad1de20d19aa251e5d9b6e70bd871e30e16d971e0559332"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/registries/LegoBook.vy": ["*"]
          },
          "search_paths": ["."]
        },
        "compiler_version": "v0.4.3+commit.bff19ea2",
        "integrity": "39cdc4de51473e07fc6e05b98117e91ba9321d5a675e4edce51486d1b64ad007"
      },
      "args": "00000000000000000000000044cf3c4f000dfd76a35d03298049d37be688d6f90000000000000000000000003ed8174065c00fe511a91850cf8f45d161e8ee150000000000000000000000000000000000000000000000000000000000000e10000000000000000000000000000000000000000000000000000000000013c680",
      "file": "contracts/registries/LegoBook.vy"
    },
    "Appraiser": {
      "address": "0x212652d44EA7A1642c4F8c9De6F7F3a62ff639E5",
      "abi": [
        {
          "name": "DepartmentPauseModified",
          "inputs": [
            {
              "name": "isPaused",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "DepartmentFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "balance",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddys",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "undyToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "hatchery",
                  "type": "address"
                },
                {
                  "name": "lootDistributor",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                },
                {
                  "name": "walletBackpack",
                  "type": "address"
                },
                {
                  "name": "billing",
                  "type": "address"
                },
                {
                  "name": "vaultRegistry",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUndyHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canMintUndy",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pause",
          "inputs": [
            {
              "name": "_shouldPause",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFundsMany",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_assets",
              "type": "address[]"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isPaused",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "calculateYieldProfits",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_currentBalance",
              "type": "uint256"
            },
            {
              "name": "_lastBalance",
              "type": "uint256"
            },
            {
              "name": "_lastPricePerShare",
              "type": "uint256"
            },
            {
              "name": "_missionControl",
              "type": "address"
            },
            {
              "name": "_legoBook",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "calculateYieldProfitsNoUpdate",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_underlyingAsset",
              "type": "address"
            },
            {
              "name": "_currentBalance",
              "type": "uint256"
            },
            {
              "name": "_lastBalance",
              "type": "uint256"
            },
            {
              "name": "_lastPricePerShare",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValue",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValue",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_missionControl",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValue",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_missionControl",
              "type": "address"
            },
            {
              "name": "_legoBook",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValue",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_missionControl",
              "type": "address"
            },
            {
              "name": "_legoBook",
              "type": "address"
            },
            {
              "name": "_ledger",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPrice",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPrice",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_missionControl",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPrice",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_missionControl",
              "type": "address"
            },
            {
              "name": "_legoBook",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPrice",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_missionControl",
              "type": "address"
            },
            {
              "name": "_legoBook",
              "type": "address"
            },
            {
              "name": "_ledger",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "updatePriceAndGetUsdValue",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "updatePriceAndGetUsdValue",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_missionControl",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "updatePriceAndGetUsdValue",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_missionControl",
              "type": "address"
            },
            {
              "name": "_legoBook",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "updatePriceAndGetUsdValueAndIsYieldAsset",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "updatePriceAndGetUsdValueAndIsYieldAsset",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_missionControl",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "updatePriceAndGetUsdValueAndIsYieldAsset",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_missionControl",
              "type": "address"
            },
            {
              "name": "_legoBook",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getNormalAssetPrice",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getNormalAssetPrice",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_missionControl",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getNormalAssetPrice",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_missionControl",
              "type": "address"
            },
            {
              "name": "_legoBook",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getNormalAssetPrice",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_missionControl",
              "type": "address"
            },
            {
              "name": "_legoBook",
              "type": "address"
            },
            {
              "name": "_ledger",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "updateAndGetNormalAssetPrice",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "updateAndGetNormalAssetPrice",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_missionControl",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "updateAndGetNormalAssetPrice",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_missionControl",
              "type": "address"
            },
            {
              "name": "_legoBook",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPricePerShare",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPricePerShare",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_missionControl",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPricePerShare",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_missionControl",
              "type": "address"
            },
            {
              "name": "_legoBook",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPricePerShare",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_missionControl",
              "type": "address"
            },
            {
              "name": "_legoBook",
              "type": "address"
            },
            {
              "name": "_ledger",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPricePerShareWithConfig",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_legoAddr",
              "type": "address"
            },
            {
              "name": "_staleBlocks",
              "type": "uint256"
            },
            {
              "name": "_decimals",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "updateAndGetPricePerShare",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "updateAndGetPricePerShare",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_missionControl",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "updateAndGetPricePerShare",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_missionControl",
              "type": "address"
            },
            {
              "name": "_legoBook",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRipePrice",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getProfitCalcConfig",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "legoAddr",
                  "type": "address"
                },
                {
                  "name": "decimals",
                  "type": "uint256"
                },
                {
                  "name": "staleBlocks",
                  "type": "uint256"
                },
                {
                  "name": "isYieldAsset",
                  "type": "bool"
                },
                {
                  "name": "isRebasing",
                  "type": "bool"
                },
                {
                  "name": "underlyingAsset",
                  "type": "address"
                },
                {
                  "name": "maxYieldIncrease",
                  "type": "uint256"
                },
                {
                  "name": "performanceFee",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssetUsdValueConfig",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "legoAddr",
                  "type": "address"
                },
                {
                  "name": "decimals",
                  "type": "uint256"
                },
                {
                  "name": "staleBlocks",
                  "type": "uint256"
                },
                {
                  "name": "isYieldAsset",
                  "type": "bool"
                },
                {
                  "name": "underlyingAsset",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "lastPrice",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "price",
                  "type": "uint256"
                },
                {
                  "name": "lastUpdate",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "lastPricePerShare",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "pricePerShare",
                  "type": "uint256"
                },
                {
                  "name": "lastUpdate",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "WETH",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ETH",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_undyHq",
              "type": "address"
            },
            {
              "name": "_ripeHq",
              "type": "address"
            },
            {
              "name": "_wethAddr",
              "type": "address"
            },
            {
              "name": "_ethAddr",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/modules/Addys.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\ninterface UndyHq:\n    def isValidAddr(_addr: address) -> bool: view\n    def getAddr(_regId: uint256) -> address: view\n    def undyToken() -> address: view\n\ninterface Switchboard:\n    def isSwitchboardAddr(_addr: address) -> bool: view\n\ninterface LegoBook:\n    def isLegoAddr(_addr: address) -> bool: view\n\nstruct Addys:\n    hq: address\n    undyToken: address\n    ledger: address\n    missionControl: address\n    legoBook: address\n    switchboard: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    walletBackpack: address\n    billing: address\n    vaultRegistry: address\n\n# hq\nUNDY_HQ_FOR_ADDYS: immutable(address)\n\n# core addys\nLEDGER_ID: constant(uint256) = 1\nMISSION_CONTROL_ID: constant(uint256) = 2\nLEGO_BOOK_ID: constant(uint256) = 3\nSWITCHBOARD_ID: constant(uint256) = 4\nHATCHERY_ID: constant(uint256) = 5\nLOOT_DISTRIBUTOR_ID: constant(uint256) = 6\nAPPRAISER_ID: constant(uint256) = 7\nWALLET_BACKPACK_ID: constant(uint256) = 8\nBILLING_ID: constant(uint256) = 9\nVAULT_REGISTRY_ID: constant(uint256) = 10\n\n\n@deploy\ndef __init__(_undyHq: address):\n    assert _undyHq != empty(address) # dev: invalid undy hq\n    UNDY_HQ_FOR_ADDYS = _undyHq\n\n\n########\n# Core #\n########\n\n\n@view\n@external\ndef getAddys() -> Addys:\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _getAddys(_addys: Addys = empty(Addys)) -> Addys:\n    if _addys.hq != empty(address):\n        return _addys\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _generateAddys() -> Addys:\n    hq: address = UNDY_HQ_FOR_ADDYS\n    return Addys(\n        hq = hq,\n        undyToken = staticcall UndyHq(hq).undyToken(),\n        ledger = staticcall UndyHq(hq).getAddr(LEDGER_ID),\n        missionControl = staticcall UndyHq(hq).getAddr(MISSION_CONTROL_ID),\n        legoBook = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID),\n        switchboard = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID),\n        hatchery = staticcall UndyHq(hq).getAddr(HATCHERY_ID),\n        lootDistributor = staticcall UndyHq(hq).getAddr(LOOT_DISTRIBUTOR_ID),\n        appraiser = staticcall UndyHq(hq).getAddr(APPRAISER_ID),\n        walletBackpack = staticcall UndyHq(hq).getAddr(WALLET_BACKPACK_ID),\n        billing = staticcall UndyHq(hq).getAddr(BILLING_ID),\n        vaultRegistry = staticcall UndyHq(hq).getAddr(VAULT_REGISTRY_ID),\n    )\n\n\n##########\n# Tokens #\n##########\n\n\n@view\n@internal\ndef _getUndyToken() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).undyToken()\n\n\n###########\n# Helpers #\n###########\n\n\n# undy hq\n\n\n@view\n@external\ndef getUndyHq() -> address:\n    return self._getUndyHq()\n\n\n@view\n@internal\ndef _getUndyHq() -> address:\n    return UNDY_HQ_FOR_ADDYS\n\n\n# utils\n\n\n@view\n@internal\ndef _isValidUndyAddr(_addr: address, _hq: address = empty(address)) -> bool:\n    hq: address = _hq\n    if _hq == empty(address):\n        hq = UNDY_HQ_FOR_ADDYS\n    \n    # core departments\n    if staticcall UndyHq(hq).isValidAddr(_addr):\n        return True\n\n    # lego book\n    legoBook: address = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID)\n    if legoBook != empty(address) and staticcall LegoBook(legoBook).isLegoAddr(_addr):\n        return True\n\n    # switchboard config\n    switchboard: address = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID)\n    if switchboard != empty(address) and staticcall Switchboard(switchboard).isSwitchboardAddr(_addr):\n        return True\n\n    return False\n\n\n@view\n@internal\ndef _isSwitchboardAddr(_addr: address) -> bool:\n    switchboard: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n    if switchboard == empty(address):\n        return False\n    return staticcall Switchboard(switchboard).isSwitchboardAddr(_addr)\n\n\n@view\n@internal\ndef _isLegoBookAddr(_addr: address) -> bool:\n    legoBook: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n    if legoBook == empty(address):\n        return False\n    return staticcall LegoBook(legoBook).isLegoAddr(_addr)\n\n\n###############\n# Departments #\n###############\n\n\n# ledger\n\n\n@view\n@internal\ndef _getLedgerId() -> uint256:\n    return LEDGER_ID\n\n\n@view\n@internal\ndef _getLedgerAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEDGER_ID)\n\n\n# mission control\n\n\n@view\n@internal\ndef _getMissionControlId() -> uint256:\n    return MISSION_CONTROL_ID\n\n\n@view\n@internal\ndef _getMissionControlAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(MISSION_CONTROL_ID)\n\n\n# lego book\n\n\n@view\n@internal\ndef _getLegoBookId() -> uint256:\n    return LEGO_BOOK_ID\n\n\n@view\n@internal\ndef _getLegoBookAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n\n\n# switchboard\n\n\n@view\n@internal\ndef _getSwitchboardId() -> uint256:\n    return SWITCHBOARD_ID\n\n\n@view\n@internal\ndef _getSwitchboardAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n\n\n# hatchery\n\n\n@view\n@internal\ndef _getHatcheryId() -> uint256:\n    return HATCHERY_ID\n\n\n@view\n@internal\ndef _getHatcheryAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(HATCHERY_ID)\n\n\n# loot distributor\n\n\n@view\n@internal\ndef _getLootDistributorId() -> uint256:\n    return LOOT_DISTRIBUTOR_ID\n\n\n@view\n@internal\ndef _getLootDistributorAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LOOT_DISTRIBUTOR_ID)\n\n\n# appraiser\n\n\n@view\n@internal\ndef _getAppraiserId() -> uint256:\n    return APPRAISER_ID\n\n\n@view\n@internal\ndef _getAppraiserAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(APPRAISER_ID)\n\n\n# wallet backpack\n\n\n@view\n@internal\ndef _getWalletBackpackId() -> uint256:\n    return WALLET_BACKPACK_ID\n\n\n@view\n@internal\ndef _getWalletBackpackAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(WALLET_BACKPACK_ID)\n\n\n# billing\n\n\n@view\n@internal\ndef _getBillingId() -> uint256:\n    return BILLING_ID\n\n\n@view\n@internal\ndef _getBillingAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(BILLING_ID)\n\n\n# vault registry\n\n\n@view\n@internal\ndef _getVaultRegistryId() -> uint256:\n    return VAULT_REGISTRY_ID\n\n\n@view\n@internal\ndef _getVaultRegistryAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(VAULT_REGISTRY_ID)",
            "sha256sum": "4df6b72db9bb417d1af81660175be1450cfb7b3575f3d17a5b8a130bff87b781"
          },
          "interfaces/Department.vyi": {
            "content": "# @version 0.4.3\n\n\n###########\n# Minting #\n###########\n\n\n@view\n@external\ndef canMintUndy() -> bool:\n    # used in UndyHq.vy\n    ...\n\n\n########\n# Undy #\n########\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "53e48da591c4ee36045a8950c9d3a01458456b471b797df536e9a9f54404e721"
          },
          "contracts/modules/DeptBasics.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nuses: addys\nimplements: dept\n\nimport contracts.modules.Addys as addys\nimport interfaces.Department as dept\nfrom ethereum.ercs import IERC20\n\nevent DepartmentPauseModified:\n    isPaused: bool\n\nevent DepartmentFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    balance: uint256\n\nisPaused: public(bool)\n\nCAN_MINT_UNDY: immutable(bool)\nMAX_RECOVER_ASSETS: constant(uint256) = 20\n\n\n@deploy\ndef __init__(_shouldPause: bool, _canMintUndy: bool):\n    self.isPaused = _shouldPause\n    CAN_MINT_UNDY = _canMintUndy\n\n\n###########\n# Minting #\n###########\n\n\n@view\n@external\ndef canMintUndy() -> bool:\n    return CAN_MINT_UNDY\n\n\n########\n# Undy #\n########\n\n\n# activate\n\n\n@external\ndef pause(_shouldPause: bool):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert _shouldPause != self.isPaused # dev: no change\n    self.isPaused = _shouldPause\n    log DepartmentPauseModified(isPaused=_shouldPause)\n\n\n# recover funds\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    self._recoverFunds(_recipient, _asset)\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, MAX_RECOVER_ASSETS]):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    for a: address in _assets:\n        self._recoverFunds(_recipient, a)\n\n\n@internal\ndef _recoverFunds(_recipient: address, _asset: address):\n    assert empty(address) not in [_recipient, _asset] # dev: invalid recipient or asset\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    assert balance != 0 # dev: nothing to recover\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log DepartmentFundsRecovered(asset=_asset, recipient=_recipient, balance=balance)\n",
            "sha256sum": "976a50a3807bcf71f3f1c57de5cd7a59fe4e8f27b4d4560e774073962f44d1ac"
          },
          "interfaces/WalletStructs.vyi": {
            "content": "# @version 0.4.3\n\nflag ActionType:\n    TRANSFER\n    EARN_DEPOSIT\n    EARN_WITHDRAW\n    EARN_REBALANCE\n    SWAP\n    MINT_REDEEM\n    CONFIRM_MINT_REDEEM\n    ADD_COLLATERAL\n    REMOVE_COLLATERAL\n    BORROW\n    REPAY_DEBT\n    REWARDS\n    ETH_TO_WETH\n    WETH_TO_ETH\n    ADD_LIQ\n    REMOVE_LIQ\n    ADD_LIQ_CONC\n    REMOVE_LIQ_CONC\n    PAY_CHEQUE\n\nstruct WalletAssetData:\n    assetBalance: uint256\n    usdValue: uint256\n    isYieldAsset: bool\n    lastPricePerShare: uint256\n\nstruct ActionData:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    billing: address\n    wallet: address\n    walletConfig: address\n    walletOwner: address\n    inEjectMode: bool\n    isFrozen: bool\n    lastTotalUsdValue: uint256\n    signer: address\n    isManager: bool\n    legoId: uint256\n    legoAddr: address\n    eth: address\n    weth: address\n\nstruct MiniAddys:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    appraiser: address",
            "sha256sum": "9a4b4f59b3a62043e51b425a665064aae419a3c0bd0514b6b29a9441ae364bb9"
          },
          "interfaces/LegoPartner.vyi": {
            "content": "# @version 0.4.3\n\nfrom interfaces import WalletStructs as ws\n\nMAX_TOKEN_PATH: constant(uint256) = 5\nMAX_RECOVER_ASSETS: constant(uint256) = 20\n\n@external\ndef addLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _tickLower: int24, _tickUpper: int24, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef addLiquidity(_pool: address, _tokenA: address, _tokenB: address, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _minLpAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (address, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef removeLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _liqToRemove: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef removeLiquidity(_pool: address, _tokenA: address, _tokenB: address, _lpToken: address, _lpAmount: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef mintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _tokenInAmount: uint256, _minAmountOut: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef swapTokens(_amountIn: uint256, _minAmountOut: uint256, _tokenPath: DynArray[address, MAX_TOKEN_PATH], _poolPath: DynArray[address, MAX_TOKEN_PATH - 1], _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256, uint256):\n    ...\n\n@external\ndef depositForYield(_asset: address, _amount: uint256, _vaultAddr: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef withdrawFromYield(_vaultToken: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef confirmMintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef borrow(_borrowAsset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef repayDebt(_paymentAsset: address, _paymentAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef claimRewards(_user: address, _rewardToken: address, _rewardAmount: uint256, _extraData: bytes32, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef removeCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef addCollateral(_asset: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: ws.MiniAddys = empty(ws.MiniAddys)) -> (uint256, uint256):\n    ...\n\n@view\n@external\ndef getAccessForLego(_user: address, _action: ws.ActionType) -> (address, String[64], uint256):\n    ...\n\n@view\n@external\ndef hasCapability(_action: ws.ActionType) -> bool:\n    ...\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    ...\n\n@view\n@external\ndef isYieldLego() -> bool:\n    ...\n\n@view\n@external\ndef isDexLego() -> bool:\n    ...\n\n@view\n@external\ndef getPricePerShare(_asset: address, _decimals: uint256) -> uint256:\n    ...\n\n@view\n@external\ndef getPrice(_asset: address, _decimals: uint256) -> uint256:\n    ...\n\n\n# common\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "2513e379aa74d0a8120114a5078a4c1a0900165a1c3f24419bb811d173b56453"
          },
          "contracts/core/Appraiser.vy": {
            "content": "#     ________   ______   ______   ______    ________    ________  ______   ______   ______       \n#    /_______/\\ /_____/\\ /_____/\\ /_____/\\  /_______/\\  /_______/\\/_____/\\ /_____/\\ /_____/\\      \n#    \\::: _  \\ \\\\:::_ \\ \\\\:::_ \\ \\\\:::_ \\ \\ \\::: _  \\ \\ \\__.::._\\/\\::::_\\/_\\::::_\\/_\\:::_ \\ \\     \n#     \\::(_)  \\ \\\\:(_) \\ \\\\:(_) \\ \\\\:(_) ) )_\\::(_)  \\ \\   \\::\\ \\  \\:\\/___/\\\\:\\/___/\\\\:(_) ) )_   \n#      \\:: __  \\ \\\\: ___\\/ \\: ___\\/ \\: __ `\\ \\\\:: __  \\ \\  _\\::\\ \\__\\_::._\\:\\\\::___\\/_\\: __ `\\ \\  \n#       \\:.\\ \\  \\ \\\\ \\ \\    \\ \\ \\    \\ \\ `\\ \\ \\\\:.\\ \\  \\ \\/__\\::\\__/\\ /____\\:\\\\:\\____/\\\\ \\ `\\ \\ \\ \n#        \\__\\/\\__\\/ \\_\\/     \\_\\/     \\_\\/ \\_\\/ \\__\\/\\__\\/\\________\\/ \\_____\\/ \\_____\\/ \\_\\/ \\_\\/ \n#\n#     \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n#     \u2551  ** Appraiser **                               \u2551\n#     \u2551  Handles price calculations for the protocol.  \u2551\n#     \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n#\n#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nimplements: Department\n\nexports: addys.__interface__\nexports: deptBasics.__interface__\n\ninitializes: addys\ninitializes: deptBasics[addys := addys]\n\nimport contracts.modules.Addys as addys\nimport contracts.modules.DeptBasics as deptBasics\nfrom interfaces import Department\nfrom interfaces import DexLego as DexLego\nfrom interfaces import YieldLego as YieldLego\n\nfrom ethereum.ercs import IERC20Detailed\n\ninterface Ledger:\n    def isRegisteredBackpackItem(_user: address) -> bool: view\n    def vaultTokens(_vaultToken: address) -> VaultToken: view\n    def isUserWallet(_user: address) -> bool: view\n\ninterface MissionControl:\n    def getAssetUsdValueConfig(_asset: address) -> AssetUsdValueConfig: view\n    def getProfitCalcConfig(_asset: address) -> ProfitCalcConfig: view\n\ninterface RipePriceDesk:\n    def getPrice(_asset: address, _shouldRaise: bool = False) -> uint256: view\n    def addPriceSnapshot(_asset: address) -> bool: nonpayable\n\ninterface Registry:\n    def getAddr(_regId: uint256) -> address: view\n\ninterface Lego:\n    def isDexLego() -> bool: view\n\nstruct LastPrice:\n    price: uint256\n    lastUpdate: uint256\n\nstruct LastPricePerShare:\n    pricePerShare: uint256\n    lastUpdate: uint256\n\nstruct VaultToken:\n    legoId: uint256\n    underlyingAsset: address\n    decimals: uint256\n    isRebasing: bool\n\n# helpers\n\nstruct AssetUsdValueConfig:\n    legoId: uint256\n    legoAddr: address\n    decimals: uint256\n    staleBlocks: uint256\n    isYieldAsset: bool\n    underlyingAsset: address\n\nstruct ProfitCalcConfig:\n    legoId: uint256\n    legoAddr: address\n    decimals: uint256\n    staleBlocks: uint256\n    isYieldAsset: bool\n    isRebasing: bool\n    underlyingAsset: address\n    maxYieldIncrease: uint256\n    performanceFee: uint256\n\n# price cache\nlastPrice: public(HashMap[address, LastPrice]) # asset -> last price\nlastPricePerShare: public(HashMap[address, LastPricePerShare]) # asset -> last price per share\n\nHUNDRED_PERCENT: constant(uint256) = 100_00 # 100.00%\n\n# ripe\nRIPE_HQ: immutable(address)\nRIPE_PRICE_DESK_ID: constant(uint256) = 7\n\nWETH: public(immutable(address))\nETH: public(immutable(address))\n\n\n@deploy\ndef __init__(\n    _undyHq: address,\n    _ripeHq: address,\n    _wethAddr: address,\n    _ethAddr: address,\n):\n    addys.__init__(_undyHq)\n    deptBasics.__init__(False, False) # no minting\n\n    assert _ripeHq != empty(address) # dev: invalid ripe hq\n    RIPE_HQ = _ripeHq\n\n    WETH = _wethAddr\n    ETH = _ethAddr\n\n\n##################\n# Yield Handling #\n##################\n\n\n@external\ndef calculateYieldProfits(\n    _asset: address,\n    _currentBalance: uint256,\n    _lastBalance: uint256,\n    _lastPricePerShare: uint256,\n    _missionControl: address,\n    _legoBook: address,\n) -> (uint256, uint256, uint256):\n    ledger: address = addys._getLedgerAddr() # cannot allow this to be passed in as param\n    assert staticcall Ledger(ledger).isUserWallet(msg.sender) # dev: no perms\n\n    # if paused, fail gracefully\n    if deptBasics.isPaused:\n        return 0, 0, 0\n\n    # get addresses if not provided\n    missionControl: address = _missionControl\n    if _missionControl == empty(address):\n        missionControl = addys._getMissionControlAddr()\n    legoBook: address = _legoBook\n    if _legoBook == empty(address):\n        legoBook = addys._getLegoBookAddr()\n\n    config: ProfitCalcConfig = self._getProfitCalcConfig(_asset, missionControl, legoBook, ledger)\n    if not config.isYieldAsset:\n        return 0, 0, 0\n\n    if config.isRebasing:\n        return self._handleRebaseYieldAsset(_currentBalance, _lastBalance, config.maxYieldIncrease, config.performanceFee)\n    else:\n        currentPricePerShare: uint256 = self._updateAndGetPricePerShare(_asset, config.legoAddr, config.staleBlocks, config.decimals)\n        return self._handleNormalYieldAsset(_currentBalance, _lastBalance, _lastPricePerShare, currentPricePerShare, config)\n\n\n@view\n@external\ndef calculateYieldProfitsNoUpdate(\n    _legoId: uint256,\n    _asset: address,\n    _underlyingAsset: address,\n    _currentBalance: uint256,\n    _lastBalance: uint256,\n    _lastPricePerShare: uint256,\n) -> (uint256, uint256, uint256):\n    config: ProfitCalcConfig = self._getProfitCalcConfig(_asset, addys._getMissionControlAddr(), addys._getLegoBookAddr(), addys._getLedgerAddr())\n    if not config.isYieldAsset:\n        return 0, 0, 0\n\n    if config.isRebasing:\n        return self._handleRebaseYieldAsset(_currentBalance, _lastBalance, config.maxYieldIncrease, config.performanceFee)\n    else:\n        currentPricePerShare: uint256 = self._getPricePerShare(_asset, config.legoAddr, config.staleBlocks, config.decimals)\n        return self._handleNormalYieldAsset(_currentBalance, _lastBalance, _lastPricePerShare, currentPricePerShare, config)\n\n\n# rebasing assets\n\n\n@view\n@internal\ndef _handleRebaseYieldAsset(\n    _currentBalance: uint256,\n    _lastBalance: uint256,\n    _maxYieldIncrease: uint256,\n    _performanceFee: uint256,\n) -> (uint256, uint256, uint256):\n\n    # no profits if balance decreased or stayed the same\n    if _lastBalance == 0 or _currentBalance <= _lastBalance:\n        return 0, 0, 0\n\n    # calculate the actual profit\n    uncappedProfit: uint256 = _currentBalance - _lastBalance\n    actualProfit: uint256 = uncappedProfit\n\n    # apply max yield increase cap if configured\n    if _maxYieldIncrease != 0:\n        maxAllowedProfit: uint256 = _lastBalance * _maxYieldIncrease // HUNDRED_PERCENT\n        actualProfit = min(uncappedProfit, maxAllowedProfit)\n\n    return 0, actualProfit, _performanceFee\n\n\n# normal yield assets\n\n\n@view\n@internal\ndef _handleNormalYieldAsset(\n    _currentBalance: uint256,\n    _lastBalance: uint256,\n    _lastPricePerShare: uint256,\n    _currentPricePerShare: uint256,\n    _config: ProfitCalcConfig,\n) -> (uint256, uint256, uint256):\n\n    # first time saving it, no profits\n    if _lastPricePerShare == 0:\n        return _currentPricePerShare, 0, 0\n\n    # nothing to do if price decreased or stayed the same\n    if _currentPricePerShare == 0 or _currentPricePerShare <= _lastPricePerShare:\n        return 0, 0, 0\n\n    trackedBalance: uint256 = min(_currentBalance, _lastBalance)\n\n    # calculate underlying amounts\n    prevUnderlyingAmount: uint256 = trackedBalance * _lastPricePerShare // (10 ** _config.decimals)\n    currentUnderlyingAmount: uint256 = trackedBalance * _currentPricePerShare // (10 ** _config.decimals)\n\n    # calculate profit in underlying tokens\n    profitInUnderlying: uint256 = currentUnderlyingAmount - prevUnderlyingAmount\n\n    # apply max yield increase cap if configured\n    if _config.maxYieldIncrease != 0:\n        maxProfit: uint256 = prevUnderlyingAmount * _config.maxYieldIncrease // HUNDRED_PERCENT\n        profitInUnderlying = min(profitInUnderlying, maxProfit)\n\n    profitInVaultTokens: uint256 = profitInUnderlying * (10 ** _config.decimals) // _currentPricePerShare   \n    return _currentPricePerShare, profitInVaultTokens, _config.performanceFee\n\n\n#######################\n# Prices - High Level #\n#######################\n\n\n# get usd value\n\n\n@view\n@external\ndef getUsdValue(\n    _asset: address,\n    _amount: uint256,\n    _missionControl: address = empty(address),\n    _legoBook: address = empty(address),\n    _ledger: address = empty(address),\n) -> uint256:\n    price: uint256 = 0\n    decimals: uint256 = 0\n    price, decimals = self._getPrice(_asset, _missionControl, _legoBook, _ledger)\n    return price * _amount // (10 ** decimals)\n\n\n# get price\n\n\n@view\n@external\ndef getPrice(\n    _asset: address,\n    _missionControl: address = empty(address),\n    _legoBook: address = empty(address),\n    _ledger: address = empty(address),\n) -> uint256:\n    price: uint256 = 0\n    na: uint256 = 0\n    price, na = self._getPrice(_asset, _missionControl, _legoBook, _ledger)\n    return price\n\n\n@view\n@internal\ndef _getPrice(\n    _asset: address,\n    _missionControl: address,\n    _legoBook: address,\n    _ledger: address,\n) -> (uint256, uint256):\n\n    # get addresses if not provided\n    missionControl: address = _missionControl\n    if _missionControl == empty(address):\n        missionControl = addys._getMissionControlAddr()\n    legoBook: address = _legoBook\n    if _legoBook == empty(address):\n        legoBook = addys._getLegoBookAddr()\n    ledger: address = _ledger\n    if _ledger == empty(address):\n        ledger = addys._getLedgerAddr()\n\n    # config\n    config: AssetUsdValueConfig = self._getAssetUsdValueConfig(_asset, missionControl, legoBook, ledger)\n\n    # normal price\n    price: uint256 = 0\n    if not config.isYieldAsset:\n        price = self._getNormalAssetPrice(_asset, config.legoAddr, config.staleBlocks, config.decimals)\n\n    # yield price\n    else:\n        pricePerShare: uint256 = self._getPricePerShare(_asset, config.legoAddr, config.staleBlocks, config.decimals)\n\n        # for yield assets, need to check if it has underlying asset\n        price = pricePerShare\n        if config.underlyingAsset != empty(address):\n            underlyingConfig: AssetUsdValueConfig = self._getAssetUsdValueConfig(config.underlyingAsset, missionControl, legoBook, ledger)\n            underlyingPrice: uint256 = self._getNormalAssetPrice(config.underlyingAsset, underlyingConfig.legoAddr, underlyingConfig.staleBlocks, underlyingConfig.decimals)\n            price = underlyingPrice * pricePerShare // (10 ** underlyingConfig.decimals)\n\n    return price, config.decimals\n\n\n# update prices (and get usd value)\n\n\n@external\ndef updatePriceAndGetUsdValue(\n    _asset: address,\n    _amount: uint256,\n    _missionControl: address = empty(address),\n    _legoBook: address = empty(address),\n) -> uint256:\n    ledger: address = addys._getLedgerAddr() # cannot allow this to be passed in as param\n    if not staticcall Ledger(ledger).isUserWallet(msg.sender) and not addys._isValidUndyAddr(msg.sender):\n        assert staticcall Ledger(ledger).isRegisteredBackpackItem(msg.sender) # dev: no perms\n\n    # if paused, fail gracefully\n    if deptBasics.isPaused:\n        return 0\n\n    usdValue: uint256 = 0\n    na: bool = False\n    usdValue, na = self._updatePriceAndGetUsdValue(_asset, _amount, _missionControl, _legoBook, ledger)\n    return usdValue\n\n\n@external\ndef updatePriceAndGetUsdValueAndIsYieldAsset(\n    _asset: address,\n    _amount: uint256,\n    _missionControl: address = empty(address),\n    _legoBook: address = empty(address),\n) -> (uint256, bool):\n    ledger: address = addys._getLedgerAddr() # cannot allow this to be passed in as param\n    if not staticcall Ledger(ledger).isUserWallet(msg.sender):\n        assert addys._isValidUndyAddr(msg.sender) # dev: no perms\n\n    # if paused, fail gracefully\n    if deptBasics.isPaused:\n        return 0, False\n\n    return self._updatePriceAndGetUsdValue(_asset, _amount, _missionControl, _legoBook, ledger)\n\n\n@internal\ndef _updatePriceAndGetUsdValue(\n    _asset: address,\n    _amount: uint256,\n    _missionControl: address,\n    _legoBook: address,\n    _ledger: address,\n) -> (uint256, bool):\n\n    # get addresses if not provided\n    missionControl: address = _missionControl\n    if _missionControl == empty(address):\n        missionControl = addys._getMissionControlAddr()\n    legoBook: address = _legoBook\n    if _legoBook == empty(address):\n        legoBook = addys._getLegoBookAddr()\n    ledger: address = _ledger\n    if _ledger == empty(address):\n        ledger = addys._getLedgerAddr()\n\n    # config\n    config: AssetUsdValueConfig = self._getAssetUsdValueConfig(_asset, missionControl, legoBook, ledger)\n\n    # normal price\n    price: uint256 = 0\n    if not config.isYieldAsset:\n        price = self._updateAndGetNormalAssetPrice(_asset, config.legoAddr, config.staleBlocks, config.decimals)\n\n    # yield price\n    else:\n        pricePerShare: uint256 = self._updateAndGetPricePerShare(_asset, config.legoAddr, config.staleBlocks, config.decimals)\n\n        # for yield assets, need to check if it has underlying asset\n        price = pricePerShare\n        if config.underlyingAsset != empty(address):\n            underlyingConfig: AssetUsdValueConfig = self._getAssetUsdValueConfig(config.underlyingAsset, missionControl, legoBook, ledger)\n            underlyingPrice: uint256 = self._updateAndGetNormalAssetPrice(config.underlyingAsset, underlyingConfig.legoAddr, underlyingConfig.staleBlocks, underlyingConfig.decimals)\n            price = underlyingPrice * pricePerShare // (10 ** underlyingConfig.decimals)\n\n    usdValue: uint256 = price * _amount // (10 ** config.decimals)\n    return usdValue, config.isYieldAsset\n\n\n########################\n# Normal Asset - Price #\n########################\n\n\n# get price\n\n\n@view\n@external\ndef getNormalAssetPrice(\n    _asset: address,\n    _missionControl: address = empty(address),\n    _legoBook: address = empty(address),\n    _ledger: address = empty(address),\n) -> uint256:\n\n    # get addresses if not provided\n    missionControl: address = _missionControl\n    if _missionControl == empty(address):\n        missionControl = addys._getMissionControlAddr()\n    legoBook: address = _legoBook\n    if _legoBook == empty(address):\n        legoBook = addys._getLegoBookAddr()\n    ledger: address = _ledger\n    if _ledger == empty(address):\n        ledger = addys._getLedgerAddr()\n\n    config: AssetUsdValueConfig = self._getAssetUsdValueConfig(_asset, missionControl, legoBook, ledger)\n    if config.isYieldAsset:\n        return 0 # cannot get yield price here\n    return self._getNormalAssetPrice(_asset, config.legoAddr, config.staleBlocks, config.decimals)\n\n\n@view\n@internal\ndef _getNormalAssetPrice(\n    _asset: address,\n    _legoAddr: address,\n    _staleBlocks: uint256,\n    _decimals: uint256,\n) -> uint256:\n    data: LastPrice = empty(LastPrice)\n    na: bool = False\n    data, na = self._getNormalAssetPriceAndDidUpdate(_asset, _legoAddr, _staleBlocks, _decimals)\n    return data.price\n\n\n@view\n@internal\ndef _getNormalAssetPriceAndDidUpdate(\n    _asset: address,\n    _legoAddr: address,\n    _staleBlocks: uint256,\n    _decimals: uint256,\n) -> (LastPrice, bool):\n    data: LastPrice = self.lastPrice[_asset]\n\n    # same block, return cached price\n    if data.lastUpdate == block.number:\n        return data, False\n\n    # check if recent price is good enough\n    if _staleBlocks != 0 and data.lastUpdate != 0:\n        if data.lastUpdate + _staleBlocks > block.number:\n            return data, False\n\n    prevPrice: uint256 = data.price\n\n    # first, check with Ripe\n    data.price = self._getRipePrice(_asset)\n\n    # back up plan, check with Lego\n    if data.price == 0 and _legoAddr != empty(address) and staticcall Lego(_legoAddr).isDexLego():\n        data.price = staticcall DexLego(_legoAddr).getPrice(_asset, _decimals)\n\n    # check if changed\n    didPriceChange: bool = False\n    if data.price != prevPrice:\n        didPriceChange = True\n\n    data.lastUpdate = block.number\n    return data, didPriceChange\n\n\n# update and get price\n\n\n@external\ndef updateAndGetNormalAssetPrice(\n    _asset: address,\n    _missionControl: address = empty(address),\n    _legoBook: address = empty(address),\n) -> uint256:\n    ledger: address = addys._getLedgerAddr() # cannot allow this to be passed in as param\n    if not staticcall Ledger(ledger).isUserWallet(msg.sender):\n        assert addys._isValidUndyAddr(msg.sender) # dev: no perms\n\n    # if paused, fail gracefully\n    if deptBasics.isPaused:\n        return 0\n\n    # get addresses if not provided\n    missionControl: address = _missionControl\n    if _missionControl == empty(address):\n        missionControl = addys._getMissionControlAddr()\n    legoBook: address = _legoBook\n    if _legoBook == empty(address):\n        legoBook = addys._getLegoBookAddr()\n\n    config: AssetUsdValueConfig = self._getAssetUsdValueConfig(_asset, missionControl, legoBook, ledger)\n    if config.isYieldAsset:\n        return 0 # cannot get yield price here\n    return self._updateAndGetNormalAssetPrice(_asset, config.legoAddr, config.staleBlocks, config.decimals)\n\n\n@internal\ndef _updateAndGetNormalAssetPrice(\n    _asset: address,\n    _legoAddr: address,\n    _staleBlocks: uint256,\n    _decimals: uint256,\n) -> uint256:\n    data: LastPrice = empty(LastPrice)\n    didPriceChange: bool = False\n    data, didPriceChange = self._getNormalAssetPriceAndDidUpdate(_asset, _legoAddr, _staleBlocks, _decimals)\n    if didPriceChange:\n        self.lastPrice[_asset] = data\n    return data.price\n\n\n#################################\n# Yield Asset - Price Per Share #\n#################################\n\n\n# get price per share\n\n\n@view\n@external\ndef getPricePerShare(\n    _asset: address,\n    _missionControl: address = empty(address),\n    _legoBook: address = empty(address),\n    _ledger: address = empty(address),\n) -> uint256:\n\n    # get addresses if not provided\n    missionControl: address = _missionControl\n    if _missionControl == empty(address):\n        missionControl = addys._getMissionControlAddr()\n    legoBook: address = _legoBook\n    if _legoBook == empty(address):\n        legoBook = addys._getLegoBookAddr()\n    ledger: address = _ledger\n    if _ledger == empty(address):\n        ledger = addys._getLedgerAddr()\n\n    config: AssetUsdValueConfig = self._getAssetUsdValueConfig(_asset, missionControl, legoBook, ledger)\n    return self._getPricePerShare(_asset, config.legoAddr, config.staleBlocks, config.decimals)\n\n\n@view\n@external\ndef getPricePerShareWithConfig(\n    _asset: address,\n    _legoAddr: address,\n    _staleBlocks: uint256,\n    _decimals: uint256,\n) -> uint256:\n    return self._getPricePerShare(_asset, _legoAddr, _staleBlocks, _decimals)\n\n\n@view\n@internal\ndef _getPricePerShare(\n    _asset: address,\n    _legoAddr: address,\n    _staleBlocks: uint256,\n    _decimals: uint256,\n) -> uint256:\n    data: LastPricePerShare = empty(LastPricePerShare)\n    na: bool = False\n    data, na = self._getPricePerShareAndDidUpdate(_asset, _legoAddr, _staleBlocks, _decimals)\n    return data.pricePerShare\n\n\n@view\n@internal\ndef _getPricePerShareAndDidUpdate(\n    _asset: address,\n    _legoAddr: address,\n    _staleBlocks: uint256,\n    _decimals: uint256,\n) -> (LastPricePerShare, bool):\n    data: LastPricePerShare = self.lastPricePerShare[_asset]\n\n    # same block, return cached pricePerShare\n    if data.lastUpdate == block.number:\n        return data, False\n\n    # check if recent pricePerShare is good enough\n    if _staleBlocks != 0 and data.lastUpdate != 0:\n        if data.lastUpdate + _staleBlocks > block.number:\n            return data, False\n\n    prevPricePerShare: uint256 = data.pricePerShare\n\n    # first, check with Lego\n    if _legoAddr != empty(address):\n        data.pricePerShare = staticcall YieldLego(_legoAddr).getPricePerShare(_asset, _decimals)\n\n    # back up plan, check with Ripe\n    if data.pricePerShare == 0:\n        data.pricePerShare = self._getRipePrice(_asset)\n\n    # check if changed\n    didPriceChange: bool = False\n    if data.pricePerShare != prevPricePerShare:\n        didPriceChange = True\n\n    data.lastUpdate = block.number\n    return data, didPriceChange\n\n\n# update and get price per share\n\n\n@external\ndef updateAndGetPricePerShare(\n    _asset: address,\n    _missionControl: address = empty(address),\n    _legoBook: address = empty(address),\n) -> uint256:\n    ledger: address = addys._getLedgerAddr() # cannot allow this to be passed in as param\n    if not staticcall Ledger(ledger).isUserWallet(msg.sender):\n        assert addys._isValidUndyAddr(msg.sender) # dev: no perms\n\n    # if paused, fail gracefully\n    if deptBasics.isPaused:\n        return 0\n\n    # get addresses if not provided\n    missionControl: address = _missionControl\n    if _missionControl == empty(address):\n        missionControl = addys._getMissionControlAddr()\n    legoBook: address = _legoBook\n    if _legoBook == empty(address):\n        legoBook = addys._getLegoBookAddr()\n\n    config: AssetUsdValueConfig = self._getAssetUsdValueConfig(_asset, missionControl, legoBook, ledger)\n    if not config.isYieldAsset:\n        return 0 # cannot get normal price here\n    return self._updateAndGetPricePerShare(_asset, config.legoAddr, config.staleBlocks, config.decimals)\n\n\n@internal\ndef _updateAndGetPricePerShare(\n    _asset: address,\n    _legoAddr: address,\n    _staleBlocks: uint256,\n    _decimals: uint256,\n) -> uint256:\n    data: LastPricePerShare = empty(LastPricePerShare)\n    didPriceChange: bool = False\n    data, didPriceChange = self._getPricePerShareAndDidUpdate(_asset, _legoAddr, _staleBlocks, _decimals)\n    if didPriceChange:\n        self.lastPricePerShare[_asset] = data\n\n        # tell Ripe to update snapshot (for weighted average for borrowers)\n        self._updateRipeSnapshot(_asset)\n\n    return data.pricePerShare\n\n\n####################\n# Ripe Integration #\n####################\n\n\n@view\n@external\ndef getRipePrice(_asset: address) -> uint256:\n    return self._getRipePrice(_asset)\n\n\n@view\n@internal\ndef _getRipePrice(_asset: address) -> uint256:\n    ripePriceDesk: address = staticcall Registry(RIPE_HQ).getAddr(RIPE_PRICE_DESK_ID)\n    if ripePriceDesk == empty(address):\n        return 0\n    return staticcall RipePriceDesk(ripePriceDesk).getPrice(_asset, False)\n\n\n@internal\ndef _updateRipeSnapshot(_asset: address):\n    ripePriceDesk: address = staticcall Registry(RIPE_HQ).getAddr(RIPE_PRICE_DESK_ID)\n    if ripePriceDesk == empty(address):\n        return\n    # extcall RipePriceDesk(ripePriceDesk).addPriceSnapshot(_asset)\n\n\n#########\n# Utils #\n#########\n\n\n# get profit calc config\n\n\n@view\n@external\ndef getProfitCalcConfig(_asset: address) -> ProfitCalcConfig:\n    a: addys.Addys = addys._getAddys()\n    return self._getProfitCalcConfig(_asset, a.missionControl, a.legoBook, a.ledger)\n\n\n@view\n@internal\ndef _getProfitCalcConfig(\n    _asset: address,\n    _missionControl: address,\n    _legoBook: address,\n    _ledger: address,\n) -> ProfitCalcConfig:\n    config: ProfitCalcConfig = staticcall MissionControl(_missionControl).getProfitCalcConfig(_asset)\n\n    # if no specific config, fallback to vault token registration\n    if config.decimals == 0:\n        vaultToken: VaultToken = staticcall Ledger(_ledger).vaultTokens(_asset)\n        if vaultToken.underlyingAsset != empty(address):\n            config.legoId = vaultToken.legoId\n            config.decimals = vaultToken.decimals\n            config.isYieldAsset = True\n            config.isRebasing = vaultToken.isRebasing\n            config.underlyingAsset = vaultToken.underlyingAsset\n\n    # get lego addr if needed\n    if config.legoId != 0 and config.legoAddr == empty(address):\n        config.legoAddr = staticcall Registry(_legoBook).getAddr(config.legoId)\n\n    # get decimals if needed\n    if config.isYieldAsset and config.decimals == 0:\n        config.decimals = self._getDecimals(_asset)\n\n    return config\n\n\n# get asset usd value config\n\n\n@view\n@external\ndef getAssetUsdValueConfig(_asset: address) -> AssetUsdValueConfig:\n    a: addys.Addys = addys._getAddys()\n    return self._getAssetUsdValueConfig(_asset, a.missionControl, a.legoBook, a.ledger)\n\n\n@view\n@internal\ndef _getAssetUsdValueConfig(\n    _asset: address,\n    _missionControl: address,\n    _legoBook: address,\n    _ledger: address,\n) -> AssetUsdValueConfig:\n    config: AssetUsdValueConfig = staticcall MissionControl(_missionControl).getAssetUsdValueConfig(_asset)\n\n    # if no specific config, fallback to vault token registration\n    if config.decimals == 0:\n        vaultToken: VaultToken = staticcall Ledger(_ledger).vaultTokens(_asset)\n        if vaultToken.underlyingAsset != empty(address):\n            config.legoId = vaultToken.legoId\n            config.decimals = vaultToken.decimals\n            config.isYieldAsset = True\n            config.underlyingAsset = vaultToken.underlyingAsset\n\n    # get lego addr if needed\n    if config.legoId != 0 and config.legoAddr == empty(address):\n        config.legoAddr = staticcall Registry(_legoBook).getAddr(config.legoId)\n\n    # get decimals if needed\n    if config.decimals == 0:\n        config.decimals = self._getDecimals(_asset)\n\n    return config\n\n\n# get decimals\n\n\n@view\n@internal\ndef _getDecimals(_asset: address) -> uint256:\n    if _asset in [WETH, ETH]:\n        return 18\n    return convert(staticcall IERC20Detailed(_asset).decimals(), uint256)\n",
            "sha256sum": "4c3837cc29af4c6ce687d8610bea148a05615453560b862a72438ee545a8d644"
          },
          "interfaces/DexLego.vyi": {
            "content": "# @version 0.4.3\n\n# used in smart contracts\n\n\n@view\n@external\ndef getLpToken(_pool: address) -> address:\n    ...\n\n\n# helper functions for server\n\n\n@view\n@external\ndef getPoolForLpToken(_lpToken: address) -> address:\n    ...\n\n\n@view\n@external\ndef getSwapAmountOut(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n) -> uint256:\n    ...\n\n\n@view\n@external\ndef getSwapAmountIn(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountOut: uint256,\n) -> uint256:\n    ...\n\n\n@view\n@external\ndef getAddLiqAmountsIn(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _availAmountA: uint256,\n    _availAmountB: uint256,\n) -> (uint256, uint256, uint256):\n    ...\n\n\n@view\n@external\ndef getRemoveLiqAmountsOut(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpAmount: uint256,\n) -> (uint256, uint256):\n    ...\n\n\n@view\n@external\ndef getPriceUnsafe(_pool: address, _targetToken: address, _appraiser: address = empty(address)) -> uint256:\n    ...\n\n\n@view\n@external\ndef getBestSwapAmountOut(_tokenIn: address, _tokenOut: address, _amountIn: uint256) -> (address, uint256):\n    ...\n\n\n@view\n@external\ndef getBestSwapAmountIn(_tokenIn: address, _tokenOut: address, _amountOut: uint256) -> (address, uint256):\n    ...\n\n\n@view\n@external\ndef getCoreRouterPool() -> address:\n    ...\n\n\n@view\n@external\ndef getPrice(_asset: address, _decimals: uint256) -> uint256:\n    ...\n",
            "sha256sum": "6248ad46926f00481cb3469bfc7af8fe36669c2ca0dd98e9a0befdda0fc43fd7"
          },
          "interfaces/LegoStructs.vyi": {
            "content": "# @version 0.4.3\n\nstruct VaultTokenInfo:\n    underlyingAsset: address\n    decimals: uint256\n    lastAveragePricePerShare: uint256\n\nstruct SnapShotPriceConfig:\n    minSnapshotDelay: uint256\n    maxNumSnapshots: uint256\n    maxUpsideDeviation: uint256\n    staleTime: uint256\n\nstruct SingleSnapShot:\n    totalSupply: uint256\n    pricePerShare: uint256\n    lastUpdate: uint256\n\nstruct SnapShotData:\n    lastSnapShot: SingleSnapShot\n    nextIndex: uint256\n",
            "sha256sum": "8ae48be17d812d57fbd671bbf0593e8abf175ad0924e47c5997823cac19ec806"
          },
          "interfaces/YieldLego.vyi": {
            "content": "# @version 0.4.3\n\nfrom interfaces import LegoStructs as ls\n\n\n###################\n# Underlying Data #\n###################\n\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    ...\n\n\n@view\n@external\ndef getUnderlyingBalances(_vaultToken: address, _vaultTokenBalance: uint256) -> (uint256, uint256):\n    ...\n\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    ...\n\n\n@view\n@external\ndef getUnderlyingAmountSafe(_vaultToken: address, _vaultTokenBalance: uint256) -> uint256:\n    ...\n\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> (address, uint256, uint256):\n    ...\n\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _appraiser: address = empty(address)) -> uint256:\n    ...\n\n\n###############\n# Other Utils #\n###############\n\n\n@view\n@external\ndef isRebasing() -> bool:\n    ...\n\n\n@view\n@external\ndef getPricePerShare(_vaultToken: address, _decimals: uint256 = 0) -> uint256:\n    ...\n\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef canRegisterVaultToken(_asset: address, _vaultToken: address) -> bool:\n    ...\n\n\n@view\n@external\ndef isEligibleVaultForTrialFunds(_vaultToken: address, _underlyingAsset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef isEligibleForYieldBonus(_asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    ...\n\n\n###################\n# Yield Lego Data #\n###################\n\n\n@view\n@external\ndef isLegoAsset(_asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, 40]:\n    ...\n\n\n@view\n@external\ndef getAssets() -> DynArray[address, 20]:\n    ...\n\n\n@view\n@external\ndef isAssetOpportunity(_asset: address, _vaultAddr: address) -> bool:\n    ...\n\n\n@view\n@external\ndef getNumLegoAssets() -> uint256:\n    ...\n\n\n@view\n@external\ndef assets(_index: uint256) -> address:\n    ...\n\n\n@view\n@external\ndef indexOfAsset(_asset: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef numAssets() -> uint256:\n    ...\n\n\n@view\n@external\ndef assetOpportunities(_asset: address, _index: uint256) -> address:\n    ...\n\n\n@view\n@external\ndef indexOfAssetOpportunity(_asset: address, _vaultAddr: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef numAssetOpportunities(_asset: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef vaultToAsset(_vaultAddr: address) -> ls.VaultTokenInfo:\n    ...\n\n\n# price snapshots\n\n\n@external\ndef addPriceSnapshot(_vaultToken: address) -> bool:\n    ...\n\n\n@view\n@external\ndef snapShotPriceConfig() -> ls.SnapShotPriceConfig:\n    ...\n\n\n@view\n@external\ndef snapShotData(_vaultToken: address) -> ls.SnapShotData:\n    ...\n\n\n@view\n@external\ndef snapShots(_vaultToken: address, _index: uint256) -> ls.SingleSnapShot:\n    ...\n\n\n@view\n@external\ndef getWeightedPricePerShare(_vaultToken: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef getLatestSnapshot(_vaultToken: address, _pricePerShare: uint256) -> ls.SingleSnapShot:\n    ...\n\n\n@external\ndef setSnapShotPriceConfig(_config: ls.SnapShotPriceConfig):\n    ...\n",
            "sha256sum": "045a6bbd3d556234cf4fe925a303002dc0ac3c482d344ffbaf4bc52a7e6ad2df"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/core/Appraiser.vy": ["*"]
          },
          "search_paths": ["."]
        },
        "compiler_version": "v0.4.3+commit.bff19ea2",
        "integrity": "1f5729b5ba49161e49da49547fd85bce75d4d11b71adf5b8f61eedb48f37d801"
      },
      "args": "00000000000000000000000044cf3c4f000dfd76a35d03298049d37be688d6f90000000000000000000000006162df1b329e157479f8f1407e888260e0ec3d2b0000000000000000000000004200000000000000000000000000000000000006000000000000000000000000eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee",
      "file": "contracts/core/Appraiser.vy"
    },
    "SwitchboardCharlie": {
      "address": "0x2258662cA2AF19846b9e62A74b803009f5770417",
      "abi": [
        {
          "name": "PendingRedemptionBufferChange",
          "inputs": [
            {
              "name": "vaultAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "buffer",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "RedemptionBufferSet",
          "inputs": [
            {
              "name": "vaultAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "buffer",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PendingMinYieldWithdrawAmountChange",
          "inputs": [
            {
              "name": "vaultAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "MinYieldWithdrawAmountSet",
          "inputs": [
            {
              "name": "vaultAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PendingSnapShotPriceConfigChange",
          "inputs": [
            {
              "name": "legoId",
              "type": "uint256",
              "indexed": true
            },
            {
              "name": "minSnapshotDelay",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "maxNumSnapshots",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "maxUpsideDeviation",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "staleTime",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "SnapShotPriceConfigSet",
          "inputs": [
            {
              "name": "legoId",
              "type": "uint256",
              "indexed": true
            },
            {
              "name": "legoAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "minSnapshotDelay",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "maxNumSnapshots",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "maxUpsideDeviation",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "staleTime",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PendingApprovedVaultTokenChange",
          "inputs": [
            {
              "name": "vaultAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "isApproved",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "ApprovedVaultTokenSet",
          "inputs": [
            {
              "name": "vaultAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "isApproved",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PendingPerformanceFeeChange",
          "inputs": [
            {
              "name": "vaultAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "performanceFee",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PerformanceFeeSet",
          "inputs": [
            {
              "name": "vaultAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "performanceFee",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PendingDefaultTargetVaultTokenChange",
          "inputs": [
            {
              "name": "vaultAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "targetVaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "DefaultTargetVaultTokenSet",
          "inputs": [
            {
              "name": "vaultAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "targetVaultToken",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PendingMaxDepositAmountChange",
          "inputs": [
            {
              "name": "vaultAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "maxDepositAmount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "MaxDepositAmountSet",
          "inputs": [
            {
              "name": "vaultAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "maxDepositAmount",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "CanDepositSet",
          "inputs": [
            {
              "name": "vaultAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "canDeposit",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "caller",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "CanWithdrawSet",
          "inputs": [
            {
              "name": "vaultAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "canWithdraw",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "caller",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "VaultOpsFrozenSet",
          "inputs": [
            {
              "name": "vaultAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "isFrozen",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "caller",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "ShouldAutoDepositSet",
          "inputs": [
            {
              "name": "vaultAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "shouldAutoDeposit",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "caller",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeTimeLockModified",
          "inputs": [
            {
              "name": "prevTimeLock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "newTimeLock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "ExpirationSet",
          "inputs": [
            {
              "name": "expiration",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "ActionTimeLockSet",
          "inputs": [
            {
              "name": "newTimeLock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "prevTimeLock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeStarted",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeConfirmed",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeCancelled",
          "inputs": [
            {
              "name": "cancelledGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovRelinquished",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UndyHqSetupFinished",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "timeLock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddys",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "undyToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "hatchery",
                  "type": "address"
                },
                {
                  "name": "lootDistributor",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                },
                {
                  "name": "walletBackpack",
                  "type": "address"
                },
                {
                  "name": "billing",
                  "type": "address"
                },
                {
                  "name": "vaultRegistry",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUndyHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUndyHqFromGov",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canGovern",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getGovernors",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPendingGovChange",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "startGovernanceChange",
          "inputs": [
            {
              "name": "_newGov",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "relinquishGov",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setGovTimeLock",
          "inputs": [
            {
              "name": "_numBlocks",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidGovTimeLock",
          "inputs": [
            {
              "name": "_newTimeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "minGovChangeTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "maxGovChangeTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "finishUndyHqSetup",
          "inputs": [
            {
              "name": "_newGov",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "finishUndyHqSetup",
          "inputs": [
            {
              "name": "_newGov",
              "type": "address"
            },
            {
              "name": "_timeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "governance",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingGov",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "newGov",
                  "type": "address"
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numGovChanges",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "govChangeTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canConfirmAction",
          "inputs": [
            {
              "name": "_actionId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isExpired",
          "inputs": [
            {
              "name": "_actionId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPendingAction",
          "inputs": [
            {
              "name": "_actionId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getActionConfirmationBlock",
          "inputs": [
            {
              "name": "_actionId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setActionTimeLock",
          "inputs": [
            {
              "name": "_newTimeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidActionTimeLock",
          "inputs": [
            {
              "name": "_newTimeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "minActionTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "maxActionTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setExpiration",
          "inputs": [
            {
              "name": "_expiration",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setActionTimeLockAfterSetup",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setActionTimeLockAfterSetup",
          "inputs": [
            {
              "name": "_newTimeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingActions",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                },
                {
                  "name": "expiration",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "actionId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "actionTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "expiration",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setCanDeposit",
          "inputs": [
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_canDeposit",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setCanWithdraw",
          "inputs": [
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_canWithdraw",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setVaultOpsFrozen",
          "inputs": [
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_isFrozen",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setShouldAutoDeposit",
          "inputs": [
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_shouldAutoDeposit",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setRedemptionBuffer",
          "inputs": [
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_buffer",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setMinYieldWithdrawAmount",
          "inputs": [
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setSnapShotPriceConfig",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_minSnapshotDelay",
              "type": "uint256"
            },
            {
              "name": "_maxNumSnapshots",
              "type": "uint256"
            },
            {
              "name": "_maxUpsideDeviation",
              "type": "uint256"
            },
            {
              "name": "_staleTime",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setApprovedVaultToken",
          "inputs": [
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_isApproved",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setPerformanceFee",
          "inputs": [
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_performanceFee",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setDefaultTargetVaultToken",
          "inputs": [
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_targetVaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setMaxDepositAmount",
          "inputs": [
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_maxDepositAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "executePendingAction",
          "inputs": [
            {
              "name": "_aid",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelPendingAction",
          "inputs": [
            {
              "name": "_aid",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "actionType",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingRedemptionBuffer",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "vaultAddr",
                  "type": "address"
                },
                {
                  "name": "buffer",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingMinYieldWithdrawAmount",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "vaultAddr",
                  "type": "address"
                },
                {
                  "name": "amount",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingSnapShotPriceConfig",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "config",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "minSnapshotDelay",
                      "type": "uint256"
                    },
                    {
                      "name": "maxNumSnapshots",
                      "type": "uint256"
                    },
                    {
                      "name": "maxUpsideDeviation",
                      "type": "uint256"
                    },
                    {
                      "name": "staleTime",
                      "type": "uint256"
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingApprovedVaultToken",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "vaultAddr",
                  "type": "address"
                },
                {
                  "name": "vaultToken",
                  "type": "address"
                },
                {
                  "name": "isApproved",
                  "type": "bool"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingPerformanceFee",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "vaultAddr",
                  "type": "address"
                },
                {
                  "name": "performanceFee",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingDefaultTargetVaultToken",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "vaultAddr",
                  "type": "address"
                },
                {
                  "name": "targetVaultToken",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingMaxDepositAmount",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "vaultAddr",
                  "type": "address"
                },
                {
                  "name": "maxDepositAmount",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_undyHq",
              "type": "address"
            },
            {
              "name": "_tempGov",
              "type": "address"
            },
            {
              "name": "_minConfigTimeLock",
              "type": "uint256"
            },
            {
              "name": "_maxConfigTimeLock",
              "type": "uint256"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/modules/Addys.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\ninterface UndyHq:\n    def isValidAddr(_addr: address) -> bool: view\n    def getAddr(_regId: uint256) -> address: view\n    def undyToken() -> address: view\n\ninterface Switchboard:\n    def isSwitchboardAddr(_addr: address) -> bool: view\n\ninterface LegoBook:\n    def isLegoAddr(_addr: address) -> bool: view\n\nstruct Addys:\n    hq: address\n    undyToken: address\n    ledger: address\n    missionControl: address\n    legoBook: address\n    switchboard: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    walletBackpack: address\n    billing: address\n    vaultRegistry: address\n\n# hq\nUNDY_HQ_FOR_ADDYS: immutable(address)\n\n# core addys\nLEDGER_ID: constant(uint256) = 1\nMISSION_CONTROL_ID: constant(uint256) = 2\nLEGO_BOOK_ID: constant(uint256) = 3\nSWITCHBOARD_ID: constant(uint256) = 4\nHATCHERY_ID: constant(uint256) = 5\nLOOT_DISTRIBUTOR_ID: constant(uint256) = 6\nAPPRAISER_ID: constant(uint256) = 7\nWALLET_BACKPACK_ID: constant(uint256) = 8\nBILLING_ID: constant(uint256) = 9\nVAULT_REGISTRY_ID: constant(uint256) = 10\n\n\n@deploy\ndef __init__(_undyHq: address):\n    assert _undyHq != empty(address) # dev: invalid undy hq\n    UNDY_HQ_FOR_ADDYS = _undyHq\n\n\n########\n# Core #\n########\n\n\n@view\n@external\ndef getAddys() -> Addys:\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _getAddys(_addys: Addys = empty(Addys)) -> Addys:\n    if _addys.hq != empty(address):\n        return _addys\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _generateAddys() -> Addys:\n    hq: address = UNDY_HQ_FOR_ADDYS\n    return Addys(\n        hq = hq,\n        undyToken = staticcall UndyHq(hq).undyToken(),\n        ledger = staticcall UndyHq(hq).getAddr(LEDGER_ID),\n        missionControl = staticcall UndyHq(hq).getAddr(MISSION_CONTROL_ID),\n        legoBook = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID),\n        switchboard = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID),\n        hatchery = staticcall UndyHq(hq).getAddr(HATCHERY_ID),\n        lootDistributor = staticcall UndyHq(hq).getAddr(LOOT_DISTRIBUTOR_ID),\n        appraiser = staticcall UndyHq(hq).getAddr(APPRAISER_ID),\n        walletBackpack = staticcall UndyHq(hq).getAddr(WALLET_BACKPACK_ID),\n        billing = staticcall UndyHq(hq).getAddr(BILLING_ID),\n        vaultRegistry = staticcall UndyHq(hq).getAddr(VAULT_REGISTRY_ID),\n    )\n\n\n##########\n# Tokens #\n##########\n\n\n@view\n@internal\ndef _getUndyToken() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).undyToken()\n\n\n###########\n# Helpers #\n###########\n\n\n# undy hq\n\n\n@view\n@external\ndef getUndyHq() -> address:\n    return self._getUndyHq()\n\n\n@view\n@internal\ndef _getUndyHq() -> address:\n    return UNDY_HQ_FOR_ADDYS\n\n\n# utils\n\n\n@view\n@internal\ndef _isValidUndyAddr(_addr: address, _hq: address = empty(address)) -> bool:\n    hq: address = _hq\n    if _hq == empty(address):\n        hq = UNDY_HQ_FOR_ADDYS\n    \n    # core departments\n    if staticcall UndyHq(hq).isValidAddr(_addr):\n        return True\n\n    # lego book\n    legoBook: address = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID)\n    if legoBook != empty(address) and staticcall LegoBook(legoBook).isLegoAddr(_addr):\n        return True\n\n    # switchboard config\n    switchboard: address = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID)\n    if switchboard != empty(address) and staticcall Switchboard(switchboard).isSwitchboardAddr(_addr):\n        return True\n\n    return False\n\n\n@view\n@internal\ndef _isSwitchboardAddr(_addr: address) -> bool:\n    switchboard: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n    if switchboard == empty(address):\n        return False\n    return staticcall Switchboard(switchboard).isSwitchboardAddr(_addr)\n\n\n@view\n@internal\ndef _isLegoBookAddr(_addr: address) -> bool:\n    legoBook: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n    if legoBook == empty(address):\n        return False\n    return staticcall LegoBook(legoBook).isLegoAddr(_addr)\n\n\n###############\n# Departments #\n###############\n\n\n# ledger\n\n\n@view\n@internal\ndef _getLedgerId() -> uint256:\n    return LEDGER_ID\n\n\n@view\n@internal\ndef _getLedgerAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEDGER_ID)\n\n\n# mission control\n\n\n@view\n@internal\ndef _getMissionControlId() -> uint256:\n    return MISSION_CONTROL_ID\n\n\n@view\n@internal\ndef _getMissionControlAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(MISSION_CONTROL_ID)\n\n\n# lego book\n\n\n@view\n@internal\ndef _getLegoBookId() -> uint256:\n    return LEGO_BOOK_ID\n\n\n@view\n@internal\ndef _getLegoBookAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n\n\n# switchboard\n\n\n@view\n@internal\ndef _getSwitchboardId() -> uint256:\n    return SWITCHBOARD_ID\n\n\n@view\n@internal\ndef _getSwitchboardAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n\n\n# hatchery\n\n\n@view\n@internal\ndef _getHatcheryId() -> uint256:\n    return HATCHERY_ID\n\n\n@view\n@internal\ndef _getHatcheryAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(HATCHERY_ID)\n\n\n# loot distributor\n\n\n@view\n@internal\ndef _getLootDistributorId() -> uint256:\n    return LOOT_DISTRIBUTOR_ID\n\n\n@view\n@internal\ndef _getLootDistributorAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LOOT_DISTRIBUTOR_ID)\n\n\n# appraiser\n\n\n@view\n@internal\ndef _getAppraiserId() -> uint256:\n    return APPRAISER_ID\n\n\n@view\n@internal\ndef _getAppraiserAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(APPRAISER_ID)\n\n\n# wallet backpack\n\n\n@view\n@internal\ndef _getWalletBackpackId() -> uint256:\n    return WALLET_BACKPACK_ID\n\n\n@view\n@internal\ndef _getWalletBackpackAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(WALLET_BACKPACK_ID)\n\n\n# billing\n\n\n@view\n@internal\ndef _getBillingId() -> uint256:\n    return BILLING_ID\n\n\n@view\n@internal\ndef _getBillingAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(BILLING_ID)\n\n\n# vault registry\n\n\n@view\n@internal\ndef _getVaultRegistryId() -> uint256:\n    return VAULT_REGISTRY_ID\n\n\n@view\n@internal\ndef _getVaultRegistryAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(VAULT_REGISTRY_ID)",
            "sha256sum": "4df6b72db9bb417d1af81660175be1450cfb7b3575f3d17a5b8a130bff87b781"
          },
          "contracts/modules/LocalGov.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\ninterface UndyHq:\n    def minGovChangeTimeLock() -> uint256: view\n    def maxGovChangeTimeLock() -> uint256: view\n    def governance() -> address: view\n\nstruct PendingGovernance:\n    newGov: address\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeStarted:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    confirmBlock: uint256\n\nevent GovChangeConfirmed:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeCancelled:\n    cancelledGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovRelinquished:\n    prevGov: indexed(address)\n\nevent GovChangeTimeLockModified:\n    prevTimeLock: uint256\n    newTimeLock: uint256\n\nevent UndyHqSetupFinished:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    timeLock: uint256\n\n# governance\ngovernance: public(address)\npendingGov: public(PendingGovernance)\nnumGovChanges: public(uint256)\n\n# time lock\ngovChangeTimeLock: public(uint256)\n\n# config\nUNDY_HQ_FOR_GOV: immutable(address)\nMIN_GOV_TIME_LOCK: immutable(uint256)\nMAX_GOV_TIME_LOCK: immutable(uint256)\n\n\n@deploy\ndef __init__(\n    _undyHq: address,\n    _initialGov: address,\n    _minTimeLock: uint256,\n    _maxTimeLock: uint256,\n    _initialTimeLock: uint256,\n):\n    UNDY_HQ_FOR_GOV = _undyHq\n    self.governance = _initialGov\n\n    # undy hq\n    if _undyHq == empty(address):\n        assert _initialGov != empty(address) # dev: undy hq must have gov\n\n    # local gov (department, other smart contracts)\n    else:\n        hqGov: address = staticcall UndyHq(_undyHq).governance()\n        assert hqGov != empty(address) # dev: undy hq must have gov\n        assert _initialGov != hqGov # dev: undy hq cannot set same gov\n\n    # time locks\n    minTimeLock: uint256 = _minTimeLock\n    maxTimeLock: uint256 = _maxTimeLock\n    if minTimeLock == 0 or maxTimeLock == 0:\n        assert _undyHq != empty(address) # dev: need undy hq if no time locks\n        minTimeLock = staticcall UndyHq(_undyHq).minGovChangeTimeLock()\n        maxTimeLock = staticcall UndyHq(_undyHq).maxGovChangeTimeLock()\n\n    # set min and max time locks\n    assert minTimeLock < maxTimeLock # dev: invalid time lock\n    assert minTimeLock != 0 and maxTimeLock != max_value(uint256) # dev: invalid time lock\n    MIN_GOV_TIME_LOCK = minTimeLock\n    MAX_GOV_TIME_LOCK = maxTimeLock\n\n    # this contract is top level governance from Undy HQ -- not setting initial time lock during setup\n    if _undyHq == empty(address):\n        return\n\n    # set initial time lock (for local gov)\n    initialTimeLock: uint256 = max(minTimeLock, _initialTimeLock)\n    assert self._setGovTimeLock(initialTimeLock) # dev: invalid time lock\n\n\n@view\n@external\ndef getUndyHqFromGov() -> address:\n    return self._getUndyHqFromGov()\n\n\n@view\n@internal\ndef _getUndyHqFromGov() -> address:\n    return UNDY_HQ_FOR_GOV\n\n\n##############\n# Gov Access #\n##############\n\n\n@view\n@external\ndef canGovern(_addr: address) -> bool:\n    return self._canGovern(_addr)\n\n\n@view\n@internal\ndef _canGovern(_addr: address) -> bool:\n    if _addr == empty(address):\n        return False\n    return _addr in self._getGovernors()\n\n\n@view\n@external\ndef getGovernors() -> DynArray[address, 2]:\n    return self._getGovernors()\n\n\n@view\n@internal\ndef _getGovernors() -> DynArray[address, 2]:\n    governors: DynArray[address, 2] = []\n\n    # local governance\n    localGov: address = self.governance\n    if localGov != empty(address):\n        governors.append(localGov)\n\n    # undy hq governance\n    undyHq: address = UNDY_HQ_FOR_GOV\n    if undyHq == empty(address):\n        return governors\n\n    hqGov: address = staticcall UndyHq(undyHq).governance()\n    if hqGov != empty(address):\n        governors.append(hqGov)\n\n    return governors\n\n\n######################\n# Governance Changes #\n######################\n\n\n@view\n@external\ndef hasPendingGovChange() -> bool:\n    return self.pendingGov.confirmBlock != 0\n\n\n@view\n@internal\ndef _isUndyHq() -> bool:\n    return UNDY_HQ_FOR_GOV == empty(address)\n\n\n# start gov change\n\n\n@external\ndef startGovernanceChange(_newGov: address):\n    governors: DynArray[address, 2] = self._getGovernors()\n    assert msg.sender in governors # dev: no perms\n\n    # validation\n    if _newGov != empty(address):\n        assert _newGov not in governors # dev: invalid _newGov\n        assert _newGov.is_contract # dev: _newGov must be a contract\n    else:\n        assert not self._isUndyHq() # dev: undy hq cannot set 0x0\n\n    confirmBlock: uint256 = block.number + self.govChangeTimeLock\n    self.pendingGov = PendingGovernance(\n        newGov= _newGov,\n        initiatedBlock= block.number,\n        confirmBlock= confirmBlock,\n    )\n    log GovChangeStarted(prevGov=self.governance, newGov=_newGov, confirmBlock=confirmBlock)\n\n\n# confirm gov change\n\n\n@external\ndef confirmGovernanceChange():\n    data: PendingGovernance = self.pendingGov\n    assert data.confirmBlock != 0 and block.number >= data.confirmBlock # dev: time lock not reached\n\n    # check permissions\n    if data.newGov != empty(address):\n        assert msg.sender == data.newGov # dev: only new gov can confirm\n    else:\n        assert self._canGovern(msg.sender) # dev: no perms\n        assert not self._isUndyHq() # dev: undy hq cannot set 0x0\n\n    # set new governance\n    prevGov: address = self.governance\n    self.governance = data.newGov\n    self.numGovChanges += 1\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeConfirmed(prevGov=prevGov, newGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n# cancel gov change\n\n\n@external\ndef cancelGovernanceChange():\n    assert self._canGovern(msg.sender) # dev: no perms\n    data: PendingGovernance = self.pendingGov\n    assert data.confirmBlock != 0 # dev: no pending change\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeCancelled(cancelledGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n# relinquish gov (only for local gov)\n\n\n@external\ndef relinquishGov():\n    assert msg.sender == self.governance # dev: no perms\n    assert not self._isUndyHq() # dev: undy hq cannot relinquish gov\n\n    self.governance = empty(address)\n    self.numGovChanges += 1\n    log GovRelinquished(prevGov=msg.sender)\n\n\n####################\n# Time Lock Config #\n####################\n\n\n# set time lock\n\n\n@external\ndef setGovTimeLock(_numBlocks: uint256) -> bool:\n    assert self._canGovern(msg.sender) # dev: no perms\n    return self._setGovTimeLock(_numBlocks)\n\n\n@internal\ndef _setGovTimeLock(_numBlocks: uint256) -> bool:\n    prevTimeLock: uint256 = self.govChangeTimeLock\n    assert self._isValidGovTimeLock(_numBlocks, prevTimeLock) # dev: invalid time lock\n    self.govChangeTimeLock = _numBlocks\n    log GovChangeTimeLockModified(prevTimeLock=prevTimeLock, newTimeLock=_numBlocks)\n    return True\n\n\n# validation\n\n\n@view\n@external\ndef isValidGovTimeLock(_newTimeLock: uint256) -> bool:\n    return self._isValidGovTimeLock(_newTimeLock, self.govChangeTimeLock)\n\n\n@view\n@internal\ndef _isValidGovTimeLock(_newTimeLock: uint256, _prevTimeLock: uint256) -> bool:\n    if _newTimeLock == _prevTimeLock:\n        return False # no change\n    if self.pendingGov.confirmBlock != 0:\n        return False # cannot change while pending gov change\n    return _newTimeLock >= MIN_GOV_TIME_LOCK and _newTimeLock <= MAX_GOV_TIME_LOCK\n\n\n# utils\n\n\n@view\n@external\ndef minGovChangeTimeLock() -> uint256:\n    return MIN_GOV_TIME_LOCK\n\n\n@view\n@external\ndef maxGovChangeTimeLock() -> uint256:\n    return MAX_GOV_TIME_LOCK\n\n\n#################\n# Undy Hq Setup #\n#################\n\n\n@external\ndef finishUndyHqSetup(_newGov: address, _timeLock: uint256 = 0) -> bool:\n    assert self._isUndyHq() # dev: only undy hq\n    assert msg.sender == self.governance # dev: no perms\n    assert self.numGovChanges == 0 # dev: already changed gov\n\n    # validation\n    assert _newGov != empty(address) and _newGov.is_contract # dev: invalid _newGov\n    prevGov: address = self.governance\n\n    # set new gov\n    self.governance = _newGov\n    self.numGovChanges += 1\n\n    # set time lock\n    timeLock: uint256 = _timeLock\n    if timeLock == 0:\n        timeLock = MIN_GOV_TIME_LOCK\n    assert self._setGovTimeLock(timeLock) # dev: invalid time lock\n\n    log UndyHqSetupFinished(prevGov=prevGov, newGov=_newGov, timeLock=timeLock)\n    return True",
            "sha256sum": "c41aa3e0d0d96b512171813377ea277e2c7da690c3cd9b4662733b3f11f705b0"
          },
          "contracts/modules/TimeLock.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nuses: gov\nimport contracts.modules.LocalGov as gov\n\nstruct PendingAction:\n    initiatedBlock: uint256\n    confirmBlock: uint256\n    expiration: uint256\n\nevent ActionTimeLockSet:\n    newTimeLock: uint256\n    prevTimeLock: uint256\n\nevent ExpirationSet:\n    expiration: uint256\n\n# core data\npendingActions: public(HashMap[uint256, PendingAction])\nactionId: public(uint256)\n\n# config\nactionTimeLock: public(uint256)\nexpiration: public(uint256)\n\nMIN_ACTION_TIMELOCK: immutable(uint256)\nMAX_ACTION_TIMELOCK: immutable(uint256)\n\n\n@deploy\ndef __init__(\n    _minActionTimeLock: uint256,\n    _maxActionTimeLock: uint256,\n    _initialTimeLock: uint256,\n    _expiration: uint256,\n):\n    # start at 1 index\n    self.actionId = 1\n\n    # set time lock boundaries\n    assert _minActionTimeLock < _maxActionTimeLock # dev: invalid time lock boundaries\n    assert _minActionTimeLock != 0 and _maxActionTimeLock != max_value(uint256) # dev: invalid time lock boundaries\n    MIN_ACTION_TIMELOCK = _minActionTimeLock\n    MAX_ACTION_TIMELOCK = _maxActionTimeLock\n\n    # set expiration time\n    self._setExpiration(_expiration, _initialTimeLock)\n\n    # set initial time lock\n    if _initialTimeLock != 0:\n        assert self._setActionTimeLock(_initialTimeLock, 0) # dev: failed to set initial time lock\n\n\n########\n# Core #\n########\n\n\n# initiate\n\n\n@internal\ndef _initiateAction() -> uint256:\n    actionId: uint256 = self.actionId\n    confirmBlock: uint256 = block.number + self.actionTimeLock\n    self.pendingActions[actionId] = PendingAction(\n        initiatedBlock= block.number,\n        confirmBlock= confirmBlock,\n        expiration= confirmBlock + self.expiration,\n    )\n    self.actionId += 1\n    return actionId\n\n\n# confirm\n\n\n@internal\ndef _confirmAction(_actionId: uint256) -> bool:\n    if not self._canConfirmAction(_actionId):\n        return False\n    self.pendingActions[_actionId] = empty(PendingAction)\n    return True\n\n\n# cancel\n\n\n@internal\ndef _cancelAction(_actionId: uint256) -> bool:\n    data: PendingAction = self.pendingActions[_actionId]\n    if data.confirmBlock == 0:\n        return False\n    self.pendingActions[_actionId] = empty(PendingAction)\n    return True\n\n\n#########\n# Utils #\n#########\n\n\n# can confirm\n\n\n@view\n@external\ndef canConfirmAction(_actionId: uint256) -> bool:\n    return self._canConfirmAction(_actionId)\n\n\n@view\n@internal\ndef _canConfirmAction(_actionId: uint256) -> bool:\n    data: PendingAction = self.pendingActions[_actionId]\n    if data.confirmBlock == 0 or block.number < data.confirmBlock:\n        return False\n    if block.number >= data.expiration:\n        return False\n    return True\n\n\n# is expired\n\n\n@view\n@external\ndef isExpired(_actionId: uint256) -> bool:\n    return self._isExpired(_actionId)\n\n\n@view\n@internal\ndef _isExpired(_actionId: uint256) -> bool:\n    data: PendingAction = self.pendingActions[_actionId]\n    if data.confirmBlock == 0:\n        return False\n    return block.number >= data.expiration\n\n\n# pending action\n\n\n@view\n@external\ndef hasPendingAction(_actionId: uint256) -> bool:\n    return self._hasPendingAction(_actionId)\n\n\n@view\n@internal\ndef _hasPendingAction(_actionId: uint256) -> bool:\n    return self.pendingActions[_actionId].confirmBlock != 0\n\n\n# confirmation block\n\n\n@view\n@external\ndef getActionConfirmationBlock(_actionId: uint256) -> uint256:\n    return self._getActionConfirmationBlock(_actionId)\n\n\n@view\n@internal\ndef _getActionConfirmationBlock(_actionId: uint256) -> uint256:\n    return self.pendingActions[_actionId].confirmBlock\n\n\n######################\n# Config - Time Lock #\n######################\n\n\n@external\ndef setActionTimeLock(_newTimeLock: uint256) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return self._setActionTimeLock(_newTimeLock, self.actionTimeLock)\n\n\n@internal\ndef _setActionTimeLock(_newTimeLock: uint256, _prevTimeLock: uint256) -> bool:\n    assert self._isValidActionTimeLock(_newTimeLock, _prevTimeLock) # dev: invalid time lock\n    self.actionTimeLock = _newTimeLock\n    log ActionTimeLockSet(newTimeLock=_newTimeLock, prevTimeLock=_prevTimeLock)\n    return True\n\n\n# validation\n\n\n@view\n@external\ndef isValidActionTimeLock(_newTimeLock: uint256) -> bool:\n    return self._isValidActionTimeLock(_newTimeLock, self.actionTimeLock)\n\n\n@view\n@internal\ndef _isValidActionTimeLock(_newTimeLock: uint256, _prevTimeLock: uint256) -> bool:\n    if _newTimeLock == _prevTimeLock:\n        return False # no change\n    return _newTimeLock >= MIN_ACTION_TIMELOCK and _newTimeLock <= MAX_ACTION_TIMELOCK\n\n\n# utils\n\n\n@view\n@external\ndef minActionTimeLock() -> uint256:\n    return MIN_ACTION_TIMELOCK\n\n\n@view\n@external\ndef maxActionTimeLock() -> uint256:\n    return MAX_ACTION_TIMELOCK\n\n\n#######################\n# Config - Expiration #\n#######################\n\n\n@external\ndef setExpiration(_expiration: uint256) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return self._setExpiration(_expiration, self.actionTimeLock)\n\n\n@internal\ndef _setExpiration(_expiration: uint256, _timeLock: uint256) -> bool:\n    assert self._isValidExpiration(_expiration, _timeLock) # dev: invalid expiration\n    self.expiration = _expiration\n    log ExpirationSet(expiration=_expiration)\n    return True\n\n\n# validation\n\n\n@view\n@internal\ndef _isValidExpiration(_expiration: uint256, _timeLock: uint256) -> bool:\n    if _expiration == 0 or _expiration == max_value(uint256):\n        return False\n    if _expiration < _timeLock:\n        return False\n    return True\n\n\n################\n# Finish Setup #\n################\n\n\n@external\ndef setActionTimeLockAfterSetup(_newTimeLock: uint256 = 0) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    prevTimeLock: uint256 = self.actionTimeLock\n    assert prevTimeLock == 0 # dev: already set\n\n    timeLock: uint256 = _newTimeLock\n    if timeLock == 0:\n        timeLock = MIN_ACTION_TIMELOCK\n    return self._setActionTimeLock(timeLock, prevTimeLock)",
            "sha256sum": "80ec25619b21a5ac9791a94ca96d5ee38a887cb59d0e9368e23ea4a2de75da8e"
          },
          "contracts/config/SwitchboardCharlie.vy": {
            "content": "#        ______   __     __   __   ______  ______   __  __   ______   ______   ______   ______   _____    \n#       /\\  ___\\ /\\ \\  _ \\ \\ /\\ \\ /\\__  _\\/\\  ___\\ /\\ \\_\\ \\ /\\  == \\ /\\  __ \\ /\\  __ \\ /\\  == \\ /\\  __-.  \n#       \\ \\___  \\\\ \\ \\/ \".\\ \\\\ \\ \\\\/_/\\ \\/\\ \\ \\____\\ \\  __ \\\\ \\  __< \\ \\ \\/\\ \\\\ \\  __ \\\\ \\  __< \\ \\ \\/\\ \\ \n#        \\/\\_____\\\\ \\__/\".~\\_\\\\ \\_\\  \\ \\_\\ \\ \\_____\\\\ \\_\\ \\_\\\\ \\_____\\\\ \\_____\\\\ \\_\\ \\_\\\\ \\_\\ \\_\\\\ \\____- \n#         \\/_____/ \\/_/   \\/_/ \\/_/   \\/_/  \\/_____/ \\/_/\\/_/ \\/_____/ \\/_____/ \\/_/\\/_/ \\/_/ /_/ \\/____/ \n#                                                    \u250f\u2513\u2513     \u2513\u2022  \n#                                                    \u2503 \u2523\u2513\u250f\u2513\u250f\u2513\u2503\u2513\u250f\u2513\n#                                                    \u2517\u251b\u251b\u2517\u2517\u253b\u251b \u2517\u2517\u2517 \n#\n#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nexports: addys.__interface__\nexports: gov.__interface__\nexports: timeLock.__interface__\n\ninitializes: addys\ninitializes: gov\ninitializes: timeLock[gov := gov]\n\nimport contracts.modules.Addys as addys\nimport contracts.modules.LocalGov as gov\nimport contracts.modules.TimeLock as timeLock\n\nfrom interfaces import LegoStructs as ls\n\ninterface VaultRegistry:\n    def setApprovedVaultToken(_vaultAddr: address, _vaultToken: address, _isApproved: bool): nonpayable\n    def setDefaultTargetVaultToken(_vaultAddr: address, _targetVaultToken: address): nonpayable\n    def setMaxDepositAmount(_vaultAddr: address, _maxDepositAmount: uint256): nonpayable\n    def setShouldAutoDeposit(_vaultAddr: address, _shouldAutoDeposit: bool): nonpayable\n    def isApprovedVaultToken(_vaultAddr: address, _vaultToken: address) -> bool: view\n    def setPerformanceFee(_vaultAddr: address, _performanceFee: uint256): nonpayable\n    def setMinYieldWithdrawAmount(_vaultAddr: address, _amount: uint256): nonpayable\n    def setRedemptionBuffer(_vaultAddr: address, _buffer: uint256): nonpayable\n    def setVaultOpsFrozen(_vaultAddr: address, _isFrozen: bool): nonpayable\n    def setCanWithdraw(_vaultAddr: address, _canWithdraw: bool): nonpayable\n    def setCanDeposit(_vaultAddr: address, _canDeposit: bool): nonpayable\n    def isValidPerformanceFee(_performanceFee: uint256) -> bool: view\n    def isValidRedemptionBuffer(_buffer: uint256) -> bool: view\n    def isValidVaultToken(_vaultToken: address) -> bool: view\n    def isEarnVault(_vaultAddr: address) -> bool: view\n\ninterface MissionControl:\n    def canPerformSecurityAction(_signer: address) -> bool: view\n\ninterface YieldLego:\n    def setSnapShotPriceConfig(_config: ls.SnapShotPriceConfig): nonpayable\n    def isValidPriceConfig(_config: ls.SnapShotPriceConfig) -> bool: view\n\ninterface Registry:\n    def getAddr(_regId: uint256) -> address: view\n\nflag ActionType:\n    REDEMPTION_BUFFER\n    MIN_YIELD_WITHDRAW_AMOUNT\n    SNAPSHOT_PRICE_CONFIG\n    APPROVED_VAULT_TOKEN\n    PERFORMANCE_FEE\n    DEFAULT_TARGET_VAULT_TOKEN\n    MAX_DEPOSIT_AMOUNT\n\nstruct PendingRedemptionBuffer:\n    vaultAddr: address\n    buffer: uint256\n\nstruct PendingMinYieldWithdrawAmount:\n    vaultAddr: address\n    amount: uint256\n\nstruct PendingSnapShotPriceConfig:\n    legoId: uint256\n    config: ls.SnapShotPriceConfig\n\nstruct PendingApprovedVaultToken:\n    vaultAddr: address\n    vaultToken: address\n    isApproved: bool\n\nstruct PendingPerformanceFee:\n    vaultAddr: address\n    performanceFee: uint256\n\nstruct PendingDefaultTargetVaultToken:\n    vaultAddr: address\n    targetVaultToken: address\n\nstruct PendingMaxDepositAmount:\n    vaultAddr: address\n    maxDepositAmount: uint256\n\nevent PendingRedemptionBufferChange:\n    vaultAddr: indexed(address)\n    buffer: uint256\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent RedemptionBufferSet:\n    vaultAddr: indexed(address)\n    buffer: uint256\n\nevent PendingMinYieldWithdrawAmountChange:\n    vaultAddr: indexed(address)\n    amount: uint256\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent MinYieldWithdrawAmountSet:\n    vaultAddr: indexed(address)\n    amount: uint256\n\nevent PendingSnapShotPriceConfigChange:\n    legoId: indexed(uint256)\n    minSnapshotDelay: uint256\n    maxNumSnapshots: uint256\n    maxUpsideDeviation: uint256\n    staleTime: uint256\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent SnapShotPriceConfigSet:\n    legoId: indexed(uint256)\n    legoAddr: indexed(address)\n    minSnapshotDelay: uint256\n    maxNumSnapshots: uint256\n    maxUpsideDeviation: uint256\n    staleTime: uint256\n\nevent PendingApprovedVaultTokenChange:\n    vaultAddr: indexed(address)\n    vaultToken: indexed(address)\n    isApproved: bool\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent ApprovedVaultTokenSet:\n    vaultAddr: indexed(address)\n    vaultToken: indexed(address)\n    isApproved: bool\n\nevent PendingPerformanceFeeChange:\n    vaultAddr: indexed(address)\n    performanceFee: uint256\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent PerformanceFeeSet:\n    vaultAddr: indexed(address)\n    performanceFee: uint256\n\nevent PendingDefaultTargetVaultTokenChange:\n    vaultAddr: indexed(address)\n    targetVaultToken: indexed(address)\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent DefaultTargetVaultTokenSet:\n    vaultAddr: indexed(address)\n    targetVaultToken: indexed(address)\n\nevent PendingMaxDepositAmountChange:\n    vaultAddr: indexed(address)\n    maxDepositAmount: uint256\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent MaxDepositAmountSet:\n    vaultAddr: indexed(address)\n    maxDepositAmount: uint256\n\nevent CanDepositSet:\n    vaultAddr: indexed(address)\n    canDeposit: bool\n    caller: indexed(address)\n\nevent CanWithdrawSet:\n    vaultAddr: indexed(address)\n    canWithdraw: bool\n    caller: indexed(address)\n\nevent VaultOpsFrozenSet:\n    vaultAddr: indexed(address)\n    isFrozen: bool\n    caller: indexed(address)\n\nevent ShouldAutoDepositSet:\n    vaultAddr: indexed(address)\n    shouldAutoDeposit: bool\n    caller: indexed(address)\n\n# pending config changes\nactionType: public(HashMap[uint256, ActionType]) # aid -> type\npendingRedemptionBuffer: public(HashMap[uint256, PendingRedemptionBuffer]) # aid -> config\npendingMinYieldWithdrawAmount: public(HashMap[uint256, PendingMinYieldWithdrawAmount]) # aid -> config\npendingSnapShotPriceConfig: public(HashMap[uint256, PendingSnapShotPriceConfig]) # aid -> config\npendingApprovedVaultToken: public(HashMap[uint256, PendingApprovedVaultToken]) # aid -> config\npendingPerformanceFee: public(HashMap[uint256, PendingPerformanceFee]) # aid -> config\npendingDefaultTargetVaultToken: public(HashMap[uint256, PendingDefaultTargetVaultToken]) # aid -> config\npendingMaxDepositAmount: public(HashMap[uint256, PendingMaxDepositAmount]) # aid -> config\n\n\n@deploy\ndef __init__(\n    _undyHq: address,\n    _tempGov: address,\n    _minConfigTimeLock: uint256,\n    _maxConfigTimeLock: uint256,\n):\n    addys.__init__(_undyHq)\n    gov.__init__(_undyHq, _tempGov, 0, 0, 0)\n    timeLock.__init__(_minConfigTimeLock, _maxConfigTimeLock, 0, _maxConfigTimeLock)\n\n\n# access control\n\n\n@view\n@internal\ndef _hasPermsToFreeze(_caller: address, _shouldFreeze: bool) -> bool:\n    if gov._canGovern(_caller):\n        return True\n    if _shouldFreeze:\n        return staticcall MissionControl(addys._getMissionControlAddr()).canPerformSecurityAction(_caller)\n    return False\n\n\n#####################\n# Immediate Actions #\n#####################\n\n\n# can deposit\n\n\n@external\ndef setCanDeposit(_vaultAddr: address, _canDeposit: bool):\n    assert self._hasPermsToFreeze(msg.sender, not _canDeposit) # dev: no perms\n    extcall VaultRegistry(addys._getVaultRegistryAddr()).setCanDeposit(_vaultAddr, _canDeposit)\n    log CanDepositSet(vaultAddr=_vaultAddr, canDeposit=_canDeposit, caller=msg.sender)\n\n\n# can withdraw\n\n\n@external\ndef setCanWithdraw(_vaultAddr: address, _canWithdraw: bool):\n    assert self._hasPermsToFreeze(msg.sender, not _canWithdraw) # dev: no perms\n    extcall VaultRegistry(addys._getVaultRegistryAddr()).setCanWithdraw(_vaultAddr, _canWithdraw)\n    log CanWithdrawSet(vaultAddr=_vaultAddr, canWithdraw=_canWithdraw, caller=msg.sender)\n\n\n# vault ops frozen\n\n\n@external\ndef setVaultOpsFrozen(_vaultAddr: address, _isFrozen: bool):\n    assert self._hasPermsToFreeze(msg.sender, _isFrozen) # dev: no perms\n    extcall VaultRegistry(addys._getVaultRegistryAddr()).setVaultOpsFrozen(_vaultAddr, _isFrozen)\n    log VaultOpsFrozenSet(vaultAddr=_vaultAddr, isFrozen=_isFrozen, caller=msg.sender)\n\n\n# should auto deposit\n\n\n@external\ndef setShouldAutoDeposit(_vaultAddr: address, _shouldAutoDeposit: bool):\n    assert self._hasPermsToFreeze(msg.sender, not _shouldAutoDeposit) # dev: no perms\n    extcall VaultRegistry(addys._getVaultRegistryAddr()).setShouldAutoDeposit(_vaultAddr, _shouldAutoDeposit)\n    log ShouldAutoDepositSet(vaultAddr=_vaultAddr, shouldAutoDeposit=_shouldAutoDeposit, caller=msg.sender)\n\n\n##############\n# Timelocked #\n##############\n\n\n# redemption buffer\n\n\n@external\ndef setRedemptionBuffer(_vaultAddr: address, _buffer: uint256) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    vr: address = addys._getVaultRegistryAddr()\n    assert staticcall VaultRegistry(vr).isEarnVault(_vaultAddr) # dev: invalid vault addr\n    assert staticcall VaultRegistry(vr).isValidRedemptionBuffer(_buffer) # dev: invalid redemption buffer\n\n    aid: uint256 = timeLock._initiateAction()\n    self.actionType[aid] = ActionType.REDEMPTION_BUFFER\n    self.pendingRedemptionBuffer[aid] = PendingRedemptionBuffer(\n        vaultAddr=_vaultAddr,\n        buffer=_buffer\n    )\n    confirmationBlock: uint256 = timeLock._getActionConfirmationBlock(aid)\n    log PendingRedemptionBufferChange(\n        vaultAddr=_vaultAddr,\n        buffer=_buffer,\n        confirmationBlock=confirmationBlock,\n        actionId=aid\n    )\n    return aid\n\n\n# min yield withdraw amount\n\n\n@external\ndef setMinYieldWithdrawAmount(_vaultAddr: address, _amount: uint256) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert staticcall VaultRegistry(addys._getVaultRegistryAddr()).isEarnVault(_vaultAddr) # dev: invalid vault addr\n\n    aid: uint256 = timeLock._initiateAction()\n    self.actionType[aid] = ActionType.MIN_YIELD_WITHDRAW_AMOUNT\n    self.pendingMinYieldWithdrawAmount[aid] = PendingMinYieldWithdrawAmount(\n        vaultAddr=_vaultAddr,\n        amount=_amount\n    )\n    confirmationBlock: uint256 = timeLock._getActionConfirmationBlock(aid)\n    log PendingMinYieldWithdrawAmountChange(\n        vaultAddr=_vaultAddr,\n        amount=_amount,\n        confirmationBlock=confirmationBlock,\n        actionId=aid\n    )\n    return aid\n\n\n# snapshot price config\n\n\n@external\ndef setSnapShotPriceConfig(\n    _legoId: uint256,\n    _minSnapshotDelay: uint256,\n    _maxNumSnapshots: uint256,\n    _maxUpsideDeviation: uint256,\n    _staleTime: uint256,\n) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    # validation - get lego address from lego book\n    legoBook: address = addys._getLegoBookAddr()\n    legoAddr: address = staticcall Registry(legoBook).getAddr(_legoId)\n    assert legoAddr != empty(address) # dev: invalid lego id\n\n    config: ls.SnapShotPriceConfig = ls.SnapShotPriceConfig(\n        minSnapshotDelay=_minSnapshotDelay,\n        maxNumSnapshots=_maxNumSnapshots,\n        maxUpsideDeviation=_maxUpsideDeviation,\n        staleTime=_staleTime,\n    )\n    assert staticcall YieldLego(legoAddr).isValidPriceConfig(config) # dev: invalid price config\n\n    aid: uint256 = timeLock._initiateAction()\n    self.actionType[aid] = ActionType.SNAPSHOT_PRICE_CONFIG\n    self.pendingSnapShotPriceConfig[aid] = PendingSnapShotPriceConfig(\n        legoId=_legoId,\n        config=config\n    )\n    confirmationBlock: uint256 = timeLock._getActionConfirmationBlock(aid)\n    log PendingSnapShotPriceConfigChange(\n        legoId=_legoId,\n        minSnapshotDelay=config.minSnapshotDelay,\n        maxNumSnapshots=config.maxNumSnapshots,\n        maxUpsideDeviation=config.maxUpsideDeviation,\n        staleTime=config.staleTime,\n        confirmationBlock=confirmationBlock,\n        actionId=aid\n    )\n    return aid\n\n\n# approved vault token\n\n\n@external\ndef setApprovedVaultToken(_vaultAddr: address, _vaultToken: address, _isApproved: bool) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    vr: address = addys._getVaultRegistryAddr()\n    assert staticcall VaultRegistry(vr).isEarnVault(_vaultAddr) # dev: invalid vault addr\n    assert staticcall VaultRegistry(vr).isValidVaultToken(_vaultToken) # dev: invalid vault token\n\n    aid: uint256 = timeLock._initiateAction()\n    self.actionType[aid] = ActionType.APPROVED_VAULT_TOKEN\n    self.pendingApprovedVaultToken[aid] = PendingApprovedVaultToken(\n        vaultAddr=_vaultAddr,\n        vaultToken=_vaultToken,\n        isApproved=_isApproved\n    )\n    confirmationBlock: uint256 = timeLock._getActionConfirmationBlock(aid)\n    log PendingApprovedVaultTokenChange(\n        vaultAddr=_vaultAddr,\n        vaultToken=_vaultToken,\n        isApproved=_isApproved,\n        confirmationBlock=confirmationBlock,\n        actionId=aid\n    )\n    return aid\n\n\n# performance fee\n\n\n@external\ndef setPerformanceFee(_vaultAddr: address, _performanceFee: uint256) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    vr: address = addys._getVaultRegistryAddr()\n    assert staticcall VaultRegistry(vr).isEarnVault(_vaultAddr) # dev: invalid vault addr\n    assert staticcall VaultRegistry(vr).isValidPerformanceFee(_performanceFee) # dev: invalid performance fee\n\n    aid: uint256 = timeLock._initiateAction()\n    self.actionType[aid] = ActionType.PERFORMANCE_FEE\n    self.pendingPerformanceFee[aid] = PendingPerformanceFee(\n        vaultAddr=_vaultAddr,\n        performanceFee=_performanceFee\n    )\n    confirmationBlock: uint256 = timeLock._getActionConfirmationBlock(aid)\n    log PendingPerformanceFeeChange(\n        vaultAddr=_vaultAddr,\n        performanceFee=_performanceFee,\n        confirmationBlock=confirmationBlock,\n        actionId=aid\n    )\n    return aid\n\n\n# default target vault token\n\n\n@external\ndef setDefaultTargetVaultToken(_vaultAddr: address, _targetVaultToken: address) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    vr: address = addys._getVaultRegistryAddr()\n    assert staticcall VaultRegistry(vr).isEarnVault(_vaultAddr) # dev: invalid vault addr\n    assert not staticcall VaultRegistry(vr).isApprovedVaultToken(_vaultAddr, _targetVaultToken) # dev: vault token already approved\n\n    aid: uint256 = timeLock._initiateAction()\n    self.actionType[aid] = ActionType.DEFAULT_TARGET_VAULT_TOKEN\n    self.pendingDefaultTargetVaultToken[aid] = PendingDefaultTargetVaultToken(\n        vaultAddr=_vaultAddr,\n        targetVaultToken=_targetVaultToken\n    )\n    confirmationBlock: uint256 = timeLock._getActionConfirmationBlock(aid)\n    log PendingDefaultTargetVaultTokenChange(\n        vaultAddr=_vaultAddr,\n        targetVaultToken=_targetVaultToken,\n        confirmationBlock=confirmationBlock,\n        actionId=aid\n    )\n    return aid\n\n\n# max deposit amount\n\n\n@external\ndef setMaxDepositAmount(_vaultAddr: address, _maxDepositAmount: uint256) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    vr: address = addys._getVaultRegistryAddr()\n    assert staticcall VaultRegistry(vr).isEarnVault(_vaultAddr) # dev: invalid vault addr\n\n    aid: uint256 = timeLock._initiateAction()\n    self.actionType[aid] = ActionType.MAX_DEPOSIT_AMOUNT\n    self.pendingMaxDepositAmount[aid] = PendingMaxDepositAmount(\n        vaultAddr=_vaultAddr,\n        maxDepositAmount=_maxDepositAmount\n    )\n    confirmationBlock: uint256 = timeLock._getActionConfirmationBlock(aid)\n    log PendingMaxDepositAmountChange(\n        vaultAddr=_vaultAddr,\n        maxDepositAmount=_maxDepositAmount,\n        confirmationBlock=confirmationBlock,\n        actionId=aid\n    )\n    return aid\n\n\n#############\n# Execution #\n#############\n\n\n@external\ndef executePendingAction(_aid: uint256) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    # check time lock\n    if not timeLock._confirmAction(_aid):\n        if timeLock._isExpired(_aid):\n            self._cancelPendingAction(_aid)\n        return False\n\n    actionType: ActionType = self.actionType[_aid]\n    vr: address = addys._getVaultRegistryAddr()\n\n    if actionType == ActionType.REDEMPTION_BUFFER:\n        p: PendingRedemptionBuffer = self.pendingRedemptionBuffer[_aid]\n        extcall VaultRegistry(vr).setRedemptionBuffer(p.vaultAddr, p.buffer)\n        log RedemptionBufferSet(vaultAddr=p.vaultAddr, buffer=p.buffer)\n\n    elif actionType == ActionType.MIN_YIELD_WITHDRAW_AMOUNT:\n        p: PendingMinYieldWithdrawAmount = self.pendingMinYieldWithdrawAmount[_aid]\n        extcall VaultRegistry(vr).setMinYieldWithdrawAmount(p.vaultAddr, p.amount)\n        log MinYieldWithdrawAmountSet(vaultAddr=p.vaultAddr, amount=p.amount)\n\n    elif actionType == ActionType.SNAPSHOT_PRICE_CONFIG:\n        p: PendingSnapShotPriceConfig = self.pendingSnapShotPriceConfig[_aid]\n        # get lego address from lego book\n        legoBook: address = addys._getLegoBookAddr()\n        legoAddr: address = staticcall Registry(legoBook).getAddr(p.legoId)\n        # set config on the lego\n        extcall YieldLego(legoAddr).setSnapShotPriceConfig(p.config)\n        log SnapShotPriceConfigSet(\n            legoId=p.legoId,\n            legoAddr=legoAddr,\n            minSnapshotDelay=p.config.minSnapshotDelay,\n            maxNumSnapshots=p.config.maxNumSnapshots,\n            maxUpsideDeviation=p.config.maxUpsideDeviation,\n            staleTime=p.config.staleTime\n        )\n\n    elif actionType == ActionType.APPROVED_VAULT_TOKEN:\n        p: PendingApprovedVaultToken = self.pendingApprovedVaultToken[_aid]\n        extcall VaultRegistry(vr).setApprovedVaultToken(p.vaultAddr, p.vaultToken, p.isApproved)\n        log ApprovedVaultTokenSet(vaultAddr=p.vaultAddr, vaultToken=p.vaultToken, isApproved=p.isApproved)\n\n    elif actionType == ActionType.PERFORMANCE_FEE:\n        p: PendingPerformanceFee = self.pendingPerformanceFee[_aid]\n        extcall VaultRegistry(vr).setPerformanceFee(p.vaultAddr, p.performanceFee)\n        log PerformanceFeeSet(vaultAddr=p.vaultAddr, performanceFee=p.performanceFee)\n\n    elif actionType == ActionType.DEFAULT_TARGET_VAULT_TOKEN:\n        p: PendingDefaultTargetVaultToken = self.pendingDefaultTargetVaultToken[_aid]\n        extcall VaultRegistry(vr).setDefaultTargetVaultToken(p.vaultAddr, p.targetVaultToken)\n        log DefaultTargetVaultTokenSet(vaultAddr=p.vaultAddr, targetVaultToken=p.targetVaultToken)\n\n    elif actionType == ActionType.MAX_DEPOSIT_AMOUNT:\n        p: PendingMaxDepositAmount = self.pendingMaxDepositAmount[_aid]\n        extcall VaultRegistry(vr).setMaxDepositAmount(p.vaultAddr, p.maxDepositAmount)\n        log MaxDepositAmountSet(vaultAddr=p.vaultAddr, maxDepositAmount=p.maxDepositAmount)\n\n    self.actionType[_aid] = empty(ActionType)\n    return True\n\n\n# cancel action\n\n\n@external\ndef cancelPendingAction(_aid: uint256) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    self._cancelPendingAction(_aid)\n    return True\n\n\n@internal\ndef _cancelPendingAction(_aid: uint256):\n    assert timeLock._cancelAction(_aid) # dev: cannot cancel action\n    self.actionType[_aid] = empty(ActionType)\n",
            "sha256sum": "85cbb38930ca0c348db0a2d64c6b6478a85dd136c1f10713cf4ac1ba61d36ce4"
          },
          "interfaces/LegoStructs.vyi": {
            "content": "# @version 0.4.3\n\nstruct VaultTokenInfo:\n    underlyingAsset: address\n    decimals: uint256\n    lastAveragePricePerShare: uint256\n\nstruct SnapShotPriceConfig:\n    minSnapshotDelay: uint256\n    maxNumSnapshots: uint256\n    maxUpsideDeviation: uint256\n    staleTime: uint256\n\nstruct SingleSnapShot:\n    totalSupply: uint256\n    pricePerShare: uint256\n    lastUpdate: uint256\n\nstruct SnapShotData:\n    lastSnapShot: SingleSnapShot\n    nextIndex: uint256\n",
            "sha256sum": "8ae48be17d812d57fbd671bbf0593e8abf175ad0924e47c5997823cac19ec806"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/config/SwitchboardCharlie.vy": ["*"]
          },
          "search_paths": ["."]
        },
        "compiler_version": "v0.4.3+commit.bff19ea2",
        "integrity": "d2ab0a5393bf448255bdb484176e4663f9846c96aef4d7a7bdcacbdc5d36b4b9"
      },
      "args": "00000000000000000000000044cf3c4f000dfd76a35d03298049d37be688d6f90000000000000000000000003ed8174065c00fe511a91850cf8f45d161e8ee150000000000000000000000000000000000000000000000000000000000000e10000000000000000000000000000000000000000000000000000000000013c680",
      "file": "contracts/config/SwitchboardCharlie.vy"
    },
    "VaultRegistry": {
      "address": "0x73388bD7f17CeCA0679604405A5d2C418Db2b702",
      "abi": [
        {
          "name": "CanDepositSet",
          "inputs": [
            {
              "name": "vaultAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "canDeposit",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "CanWithdrawSet",
          "inputs": [
            {
              "name": "vaultAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "canWithdraw",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "MaxDepositAmountSet",
          "inputs": [
            {
              "name": "vaultAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "maxDepositAmount",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "VaultOpsFrozenSet",
          "inputs": [
            {
              "name": "vaultAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "isFrozen",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "RedemptionBufferSet",
          "inputs": [
            {
              "name": "vaultAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "buffer",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "MinYieldWithdrawAmountSet",
          "inputs": [
            {
              "name": "vaultAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PerformanceFeeSet",
          "inputs": [
            {
              "name": "vaultAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "performanceFee",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "DefaultTargetVaultTokenSet",
          "inputs": [
            {
              "name": "vaultAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "targetVaultToken",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "ShouldAutoDepositSet",
          "inputs": [
            {
              "name": "vaultAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "shouldAutoDeposit",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "ApprovedVaultTokenSet",
          "inputs": [
            {
              "name": "vaultAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "isApproved",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeTimeLockModified",
          "inputs": [
            {
              "name": "prevTimeLock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "newTimeLock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "RegistryTimeLockModified",
          "inputs": [
            {
              "name": "newTimeLock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "prevTimeLock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeStarted",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeConfirmed",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeCancelled",
          "inputs": [
            {
              "name": "cancelledGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovRelinquished",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UndyHqSetupFinished",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "timeLock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "DepartmentPauseModified",
          "inputs": [
            {
              "name": "isPaused",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "DepartmentFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "balance",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "NewAddressPending",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "NewAddressConfirmed",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "regId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "NewAddressCancelled",
          "inputs": [
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUndyHqFromGov",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canGovern",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getGovernors",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPendingGovChange",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "startGovernanceChange",
          "inputs": [
            {
              "name": "_newGov",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "relinquishGov",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setGovTimeLock",
          "inputs": [
            {
              "name": "_numBlocks",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidGovTimeLock",
          "inputs": [
            {
              "name": "_newTimeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "minGovChangeTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "maxGovChangeTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "finishUndyHqSetup",
          "inputs": [
            {
              "name": "_newGov",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "finishUndyHqSetup",
          "inputs": [
            {
              "name": "_newGov",
              "type": "address"
            },
            {
              "name": "_timeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "governance",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingGov",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "newGov",
                  "type": "address"
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numGovChanges",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "govChangeTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRegistryDescription",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "string"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidNewAddress",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidAddressUpdate",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            },
            {
              "name": "_newAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidAddressDisable",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setRegistryTimeLock",
          "inputs": [
            {
              "name": "_numBlocks",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidRegistryTimeLock",
          "inputs": [
            {
              "name": "_numBlocks",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setRegistryTimeLockAfterSetup",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setRegistryTimeLockAfterSetup",
          "inputs": [
            {
              "name": "_numBlocks",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "minRegistryTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "maxRegistryTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidAddr",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidRegId",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRegId",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddr",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddrInfo",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "addr",
                  "type": "address"
                },
                {
                  "name": "version",
                  "type": "uint256"
                },
                {
                  "name": "lastModified",
                  "type": "uint256"
                },
                {
                  "name": "description",
                  "type": "string"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddrDescription",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "string"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getNumAddrs",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLastAddr",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLastRegId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "registryChangeTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "addrInfo",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "addr",
                  "type": "address"
                },
                {
                  "name": "version",
                  "type": "uint256"
                },
                {
                  "name": "lastModified",
                  "type": "uint256"
                },
                {
                  "name": "description",
                  "type": "string"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "addrToRegId",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAddrs",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingNewAddr",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "description",
                  "type": "string"
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingAddrUpdate",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "newAddr",
                  "type": "address"
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingAddrDisable",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddys",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "undyToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "hatchery",
                  "type": "address"
                },
                {
                  "name": "lootDistributor",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                },
                {
                  "name": "walletBackpack",
                  "type": "address"
                },
                {
                  "name": "billing",
                  "type": "address"
                },
                {
                  "name": "vaultRegistry",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUndyHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canMintUndy",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pause",
          "inputs": [
            {
              "name": "_shouldPause",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFundsMany",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_assets",
              "type": "address[]"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isPaused",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isEarnVault",
          "inputs": [
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "startAddNewAddressToRegistry",
          "inputs": [
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_description",
              "type": "string"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmNewAddressToRegistry",
          "inputs": [
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmNewAddressToRegistry",
          "inputs": [
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_approvedVaultTokens",
              "type": "address[]"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmNewAddressToRegistry",
          "inputs": [
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_approvedVaultTokens",
              "type": "address[]"
            },
            {
              "name": "_maxDepositAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmNewAddressToRegistry",
          "inputs": [
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_approvedVaultTokens",
              "type": "address[]"
            },
            {
              "name": "_maxDepositAmount",
              "type": "uint256"
            },
            {
              "name": "_minYieldWithdrawAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmNewAddressToRegistry",
          "inputs": [
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_approvedVaultTokens",
              "type": "address[]"
            },
            {
              "name": "_maxDepositAmount",
              "type": "uint256"
            },
            {
              "name": "_minYieldWithdrawAmount",
              "type": "uint256"
            },
            {
              "name": "_performanceFee",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmNewAddressToRegistry",
          "inputs": [
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_approvedVaultTokens",
              "type": "address[]"
            },
            {
              "name": "_maxDepositAmount",
              "type": "uint256"
            },
            {
              "name": "_minYieldWithdrawAmount",
              "type": "uint256"
            },
            {
              "name": "_performanceFee",
              "type": "uint256"
            },
            {
              "name": "_defaultTargetVaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmNewAddressToRegistry",
          "inputs": [
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_approvedVaultTokens",
              "type": "address[]"
            },
            {
              "name": "_maxDepositAmount",
              "type": "uint256"
            },
            {
              "name": "_minYieldWithdrawAmount",
              "type": "uint256"
            },
            {
              "name": "_performanceFee",
              "type": "uint256"
            },
            {
              "name": "_defaultTargetVaultToken",
              "type": "address"
            },
            {
              "name": "_shouldAutoDeposit",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmNewAddressToRegistry",
          "inputs": [
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_approvedVaultTokens",
              "type": "address[]"
            },
            {
              "name": "_maxDepositAmount",
              "type": "uint256"
            },
            {
              "name": "_minYieldWithdrawAmount",
              "type": "uint256"
            },
            {
              "name": "_performanceFee",
              "type": "uint256"
            },
            {
              "name": "_defaultTargetVaultToken",
              "type": "address"
            },
            {
              "name": "_shouldAutoDeposit",
              "type": "bool"
            },
            {
              "name": "_canDeposit",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmNewAddressToRegistry",
          "inputs": [
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_approvedVaultTokens",
              "type": "address[]"
            },
            {
              "name": "_maxDepositAmount",
              "type": "uint256"
            },
            {
              "name": "_minYieldWithdrawAmount",
              "type": "uint256"
            },
            {
              "name": "_performanceFee",
              "type": "uint256"
            },
            {
              "name": "_defaultTargetVaultToken",
              "type": "address"
            },
            {
              "name": "_shouldAutoDeposit",
              "type": "bool"
            },
            {
              "name": "_canDeposit",
              "type": "bool"
            },
            {
              "name": "_canWithdraw",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmNewAddressToRegistry",
          "inputs": [
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_approvedVaultTokens",
              "type": "address[]"
            },
            {
              "name": "_maxDepositAmount",
              "type": "uint256"
            },
            {
              "name": "_minYieldWithdrawAmount",
              "type": "uint256"
            },
            {
              "name": "_performanceFee",
              "type": "uint256"
            },
            {
              "name": "_defaultTargetVaultToken",
              "type": "address"
            },
            {
              "name": "_shouldAutoDeposit",
              "type": "bool"
            },
            {
              "name": "_canDeposit",
              "type": "bool"
            },
            {
              "name": "_canWithdraw",
              "type": "bool"
            },
            {
              "name": "_isVaultOpsFrozen",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmNewAddressToRegistry",
          "inputs": [
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_approvedVaultTokens",
              "type": "address[]"
            },
            {
              "name": "_maxDepositAmount",
              "type": "uint256"
            },
            {
              "name": "_minYieldWithdrawAmount",
              "type": "uint256"
            },
            {
              "name": "_performanceFee",
              "type": "uint256"
            },
            {
              "name": "_defaultTargetVaultToken",
              "type": "address"
            },
            {
              "name": "_shouldAutoDeposit",
              "type": "bool"
            },
            {
              "name": "_canDeposit",
              "type": "bool"
            },
            {
              "name": "_canWithdraw",
              "type": "bool"
            },
            {
              "name": "_isVaultOpsFrozen",
              "type": "bool"
            },
            {
              "name": "_redemptionBuffer",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelNewAddressToRegistry",
          "inputs": [
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setCanDeposit",
          "inputs": [
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_canDeposit",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setCanWithdraw",
          "inputs": [
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_canWithdraw",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setMaxDepositAmount",
          "inputs": [
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_maxDepositAmount",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setVaultOpsFrozen",
          "inputs": [
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_isFrozen",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setShouldAutoDeposit",
          "inputs": [
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_shouldAutoDeposit",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setMinYieldWithdrawAmount",
          "inputs": [
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setApprovedVaultToken",
          "inputs": [
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_isApproved",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setDefaultTargetVaultToken",
          "inputs": [
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_targetVaultToken",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidDefaultTargetVaultToken",
          "inputs": [
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_targetVaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setPerformanceFee",
          "inputs": [
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_performanceFee",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidPerformanceFee",
          "inputs": [
            {
              "name": "_performanceFee",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setRedemptionBuffer",
          "inputs": [
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_buffer",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidRedemptionBuffer",
          "inputs": [
            {
              "name": "_buffer",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canDeposit",
          "inputs": [
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canWithdraw",
          "inputs": [
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "maxDepositAmount",
          "inputs": [
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isVaultOpsFrozen",
          "inputs": [
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "redemptionBuffer",
          "inputs": [
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "minYieldWithdrawAmount",
          "inputs": [
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "redemptionConfig",
          "inputs": [
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPerformanceFee",
          "inputs": [
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getDefaultTargetVaultToken",
          "inputs": [
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "shouldAutoDeposit",
          "inputs": [
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isApprovedVaultTokenByAddr",
          "inputs": [
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "checkVaultApprovals",
          "inputs": [
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getVaultConfig",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "canDeposit",
                  "type": "bool"
                },
                {
                  "name": "canWithdraw",
                  "type": "bool"
                },
                {
                  "name": "maxDepositAmount",
                  "type": "uint256"
                },
                {
                  "name": "isVaultOpsFrozen",
                  "type": "bool"
                },
                {
                  "name": "redemptionBuffer",
                  "type": "uint256"
                },
                {
                  "name": "minYieldWithdrawAmount",
                  "type": "uint256"
                },
                {
                  "name": "performanceFee",
                  "type": "uint256"
                },
                {
                  "name": "shouldAutoDeposit",
                  "type": "bool"
                },
                {
                  "name": "defaultTargetVaultToken",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getVaultConfigByAddr",
          "inputs": [
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "canDeposit",
                  "type": "bool"
                },
                {
                  "name": "canWithdraw",
                  "type": "bool"
                },
                {
                  "name": "maxDepositAmount",
                  "type": "uint256"
                },
                {
                  "name": "isVaultOpsFrozen",
                  "type": "bool"
                },
                {
                  "name": "redemptionBuffer",
                  "type": "uint256"
                },
                {
                  "name": "minYieldWithdrawAmount",
                  "type": "uint256"
                },
                {
                  "name": "performanceFee",
                  "type": "uint256"
                },
                {
                  "name": "shouldAutoDeposit",
                  "type": "bool"
                },
                {
                  "name": "defaultTargetVaultToken",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getVaultActionDataBundle",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_signer",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                },
                {
                  "name": "vaultRegistry",
                  "type": "address"
                },
                {
                  "name": "vaultAsset",
                  "type": "address"
                },
                {
                  "name": "signer",
                  "type": "address"
                },
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "legoAddr",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getVaultActionDataWithFrozenStatus",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_signer",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "legoBook",
                  "type": "address"
                },
                {
                  "name": "appraiser",
                  "type": "address"
                },
                {
                  "name": "vaultRegistry",
                  "type": "address"
                },
                {
                  "name": "vaultAsset",
                  "type": "address"
                },
                {
                  "name": "signer",
                  "type": "address"
                },
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "legoAddr",
                  "type": "address"
                }
              ]
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLegoDataFromVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLegoAddrFromVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getDepositConfig",
          "inputs": [
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "vaultConfigs",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "canDeposit",
                  "type": "bool"
                },
                {
                  "name": "canWithdraw",
                  "type": "bool"
                },
                {
                  "name": "maxDepositAmount",
                  "type": "uint256"
                },
                {
                  "name": "isVaultOpsFrozen",
                  "type": "bool"
                },
                {
                  "name": "redemptionBuffer",
                  "type": "uint256"
                },
                {
                  "name": "minYieldWithdrawAmount",
                  "type": "uint256"
                },
                {
                  "name": "performanceFee",
                  "type": "uint256"
                },
                {
                  "name": "shouldAutoDeposit",
                  "type": "bool"
                },
                {
                  "name": "defaultTargetVaultToken",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isApprovedVaultToken",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_undyHq",
              "type": "address"
            },
            {
              "name": "_tempGov",
              "type": "address"
            },
            {
              "name": "_minRegistryTimeLock",
              "type": "uint256"
            },
            {
              "name": "_maxRegistryTimeLock",
              "type": "uint256"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/modules/LocalGov.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\ninterface UndyHq:\n    def minGovChangeTimeLock() -> uint256: view\n    def maxGovChangeTimeLock() -> uint256: view\n    def governance() -> address: view\n\nstruct PendingGovernance:\n    newGov: address\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeStarted:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    confirmBlock: uint256\n\nevent GovChangeConfirmed:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeCancelled:\n    cancelledGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovRelinquished:\n    prevGov: indexed(address)\n\nevent GovChangeTimeLockModified:\n    prevTimeLock: uint256\n    newTimeLock: uint256\n\nevent UndyHqSetupFinished:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    timeLock: uint256\n\n# governance\ngovernance: public(address)\npendingGov: public(PendingGovernance)\nnumGovChanges: public(uint256)\n\n# time lock\ngovChangeTimeLock: public(uint256)\n\n# config\nUNDY_HQ_FOR_GOV: immutable(address)\nMIN_GOV_TIME_LOCK: immutable(uint256)\nMAX_GOV_TIME_LOCK: immutable(uint256)\n\n\n@deploy\ndef __init__(\n    _undyHq: address,\n    _initialGov: address,\n    _minTimeLock: uint256,\n    _maxTimeLock: uint256,\n    _initialTimeLock: uint256,\n):\n    UNDY_HQ_FOR_GOV = _undyHq\n    self.governance = _initialGov\n\n    # undy hq\n    if _undyHq == empty(address):\n        assert _initialGov != empty(address) # dev: undy hq must have gov\n\n    # local gov (department, other smart contracts)\n    else:\n        hqGov: address = staticcall UndyHq(_undyHq).governance()\n        assert hqGov != empty(address) # dev: undy hq must have gov\n        assert _initialGov != hqGov # dev: undy hq cannot set same gov\n\n    # time locks\n    minTimeLock: uint256 = _minTimeLock\n    maxTimeLock: uint256 = _maxTimeLock\n    if minTimeLock == 0 or maxTimeLock == 0:\n        assert _undyHq != empty(address) # dev: need undy hq if no time locks\n        minTimeLock = staticcall UndyHq(_undyHq).minGovChangeTimeLock()\n        maxTimeLock = staticcall UndyHq(_undyHq).maxGovChangeTimeLock()\n\n    # set min and max time locks\n    assert minTimeLock < maxTimeLock # dev: invalid time lock\n    assert minTimeLock != 0 and maxTimeLock != max_value(uint256) # dev: invalid time lock\n    MIN_GOV_TIME_LOCK = minTimeLock\n    MAX_GOV_TIME_LOCK = maxTimeLock\n\n    # this contract is top level governance from Undy HQ -- not setting initial time lock during setup\n    if _undyHq == empty(address):\n        return\n\n    # set initial time lock (for local gov)\n    initialTimeLock: uint256 = max(minTimeLock, _initialTimeLock)\n    assert self._setGovTimeLock(initialTimeLock) # dev: invalid time lock\n\n\n@view\n@external\ndef getUndyHqFromGov() -> address:\n    return self._getUndyHqFromGov()\n\n\n@view\n@internal\ndef _getUndyHqFromGov() -> address:\n    return UNDY_HQ_FOR_GOV\n\n\n##############\n# Gov Access #\n##############\n\n\n@view\n@external\ndef canGovern(_addr: address) -> bool:\n    return self._canGovern(_addr)\n\n\n@view\n@internal\ndef _canGovern(_addr: address) -> bool:\n    if _addr == empty(address):\n        return False\n    return _addr in self._getGovernors()\n\n\n@view\n@external\ndef getGovernors() -> DynArray[address, 2]:\n    return self._getGovernors()\n\n\n@view\n@internal\ndef _getGovernors() -> DynArray[address, 2]:\n    governors: DynArray[address, 2] = []\n\n    # local governance\n    localGov: address = self.governance\n    if localGov != empty(address):\n        governors.append(localGov)\n\n    # undy hq governance\n    undyHq: address = UNDY_HQ_FOR_GOV\n    if undyHq == empty(address):\n        return governors\n\n    hqGov: address = staticcall UndyHq(undyHq).governance()\n    if hqGov != empty(address):\n        governors.append(hqGov)\n\n    return governors\n\n\n######################\n# Governance Changes #\n######################\n\n\n@view\n@external\ndef hasPendingGovChange() -> bool:\n    return self.pendingGov.confirmBlock != 0\n\n\n@view\n@internal\ndef _isUndyHq() -> bool:\n    return UNDY_HQ_FOR_GOV == empty(address)\n\n\n# start gov change\n\n\n@external\ndef startGovernanceChange(_newGov: address):\n    governors: DynArray[address, 2] = self._getGovernors()\n    assert msg.sender in governors # dev: no perms\n\n    # validation\n    if _newGov != empty(address):\n        assert _newGov not in governors # dev: invalid _newGov\n        assert _newGov.is_contract # dev: _newGov must be a contract\n    else:\n        assert not self._isUndyHq() # dev: undy hq cannot set 0x0\n\n    confirmBlock: uint256 = block.number + self.govChangeTimeLock\n    self.pendingGov = PendingGovernance(\n        newGov= _newGov,\n        initiatedBlock= block.number,\n        confirmBlock= confirmBlock,\n    )\n    log GovChangeStarted(prevGov=self.governance, newGov=_newGov, confirmBlock=confirmBlock)\n\n\n# confirm gov change\n\n\n@external\ndef confirmGovernanceChange():\n    data: PendingGovernance = self.pendingGov\n    assert data.confirmBlock != 0 and block.number >= data.confirmBlock # dev: time lock not reached\n\n    # check permissions\n    if data.newGov != empty(address):\n        assert msg.sender == data.newGov # dev: only new gov can confirm\n    else:\n        assert self._canGovern(msg.sender) # dev: no perms\n        assert not self._isUndyHq() # dev: undy hq cannot set 0x0\n\n    # set new governance\n    prevGov: address = self.governance\n    self.governance = data.newGov\n    self.numGovChanges += 1\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeConfirmed(prevGov=prevGov, newGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n# cancel gov change\n\n\n@external\ndef cancelGovernanceChange():\n    assert self._canGovern(msg.sender) # dev: no perms\n    data: PendingGovernance = self.pendingGov\n    assert data.confirmBlock != 0 # dev: no pending change\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeCancelled(cancelledGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n# relinquish gov (only for local gov)\n\n\n@external\ndef relinquishGov():\n    assert msg.sender == self.governance # dev: no perms\n    assert not self._isUndyHq() # dev: undy hq cannot relinquish gov\n\n    self.governance = empty(address)\n    self.numGovChanges += 1\n    log GovRelinquished(prevGov=msg.sender)\n\n\n####################\n# Time Lock Config #\n####################\n\n\n# set time lock\n\n\n@external\ndef setGovTimeLock(_numBlocks: uint256) -> bool:\n    assert self._canGovern(msg.sender) # dev: no perms\n    return self._setGovTimeLock(_numBlocks)\n\n\n@internal\ndef _setGovTimeLock(_numBlocks: uint256) -> bool:\n    prevTimeLock: uint256 = self.govChangeTimeLock\n    assert self._isValidGovTimeLock(_numBlocks, prevTimeLock) # dev: invalid time lock\n    self.govChangeTimeLock = _numBlocks\n    log GovChangeTimeLockModified(prevTimeLock=prevTimeLock, newTimeLock=_numBlocks)\n    return True\n\n\n# validation\n\n\n@view\n@external\ndef isValidGovTimeLock(_newTimeLock: uint256) -> bool:\n    return self._isValidGovTimeLock(_newTimeLock, self.govChangeTimeLock)\n\n\n@view\n@internal\ndef _isValidGovTimeLock(_newTimeLock: uint256, _prevTimeLock: uint256) -> bool:\n    if _newTimeLock == _prevTimeLock:\n        return False # no change\n    if self.pendingGov.confirmBlock != 0:\n        return False # cannot change while pending gov change\n    return _newTimeLock >= MIN_GOV_TIME_LOCK and _newTimeLock <= MAX_GOV_TIME_LOCK\n\n\n# utils\n\n\n@view\n@external\ndef minGovChangeTimeLock() -> uint256:\n    return MIN_GOV_TIME_LOCK\n\n\n@view\n@external\ndef maxGovChangeTimeLock() -> uint256:\n    return MAX_GOV_TIME_LOCK\n\n\n#################\n# Undy Hq Setup #\n#################\n\n\n@external\ndef finishUndyHqSetup(_newGov: address, _timeLock: uint256 = 0) -> bool:\n    assert self._isUndyHq() # dev: only undy hq\n    assert msg.sender == self.governance # dev: no perms\n    assert self.numGovChanges == 0 # dev: already changed gov\n\n    # validation\n    assert _newGov != empty(address) and _newGov.is_contract # dev: invalid _newGov\n    prevGov: address = self.governance\n\n    # set new gov\n    self.governance = _newGov\n    self.numGovChanges += 1\n\n    # set time lock\n    timeLock: uint256 = _timeLock\n    if timeLock == 0:\n        timeLock = MIN_GOV_TIME_LOCK\n    assert self._setGovTimeLock(timeLock) # dev: invalid time lock\n\n    log UndyHqSetupFinished(prevGov=prevGov, newGov=_newGov, timeLock=timeLock)\n    return True",
            "sha256sum": "c41aa3e0d0d96b512171813377ea277e2c7da690c3cd9b4662733b3f11f705b0"
          },
          "contracts/modules/AddressRegistry.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nuses: gov\nimport contracts.modules.LocalGov as gov\n\nstruct AddressInfo:\n    addr: address\n    version: uint256\n    lastModified: uint256\n    description: String[64]\n\nstruct PendingNewAddress:\n    description: String[64]\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nstruct PendingAddressUpdate:\n    newAddr: address\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nstruct PendingAddressDisable:\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent NewAddressPending:\n    addr: indexed(address)\n    description: String[64]\n    confirmBlock: uint256\n    registry: String[28]\n\nevent NewAddressConfirmed:\n    addr: indexed(address)\n    regId: uint256\n    description: String[64]\n    registry: String[28]\n\nevent NewAddressCancelled:\n    description: String[64]\n    addr: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n    registry: String[28]\n\nevent AddressUpdatePending:\n    regId: uint256\n    description: String[64]\n    newAddr: indexed(address)\n    prevAddr: indexed(address)\n    version: uint256\n    confirmBlock: uint256\n    registry: String[28]\n\nevent AddressUpdateConfirmed:\n    regId: uint256\n    description: String[64]\n    newAddr: indexed(address)\n    prevAddr: indexed(address)\n    version: uint256\n    registry: String[28]\n\nevent AddressUpdateCancelled:\n    regId: uint256\n    description: String[64]\n    newAddr: indexed(address)\n    prevAddr: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n    registry: String[28]\n\nevent AddressDisablePending:\n    regId: uint256\n    description: String[64]\n    addr: indexed(address)\n    version: uint256\n    confirmBlock: uint256\n    registry: String[28]\n\nevent AddressDisableConfirmed:\n    regId: uint256\n    description: String[64]\n    addr: indexed(address)\n    version: uint256\n    registry: String[28]\n\nevent AddressDisableCancelled:\n    regId: uint256\n    description: String[64]\n    addr: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n    registry: String[28]\n\nevent RegistryTimeLockModified:\n    newTimeLock: uint256\n    prevTimeLock: uint256\n    registry: String[28]\n\n# time lock\nregistryChangeTimeLock: public(uint256)\n\n# core data (address registry)\naddrInfo: public(HashMap[uint256, AddressInfo]) # regId -> address info\naddrToRegId: public(HashMap[address, uint256]) # addr -> regId\nnumAddrs: public(uint256) # number of addrs in registry\n\n# pending changes\npendingNewAddr: public(HashMap[address, PendingNewAddress]) # addr -> pending new addr\npendingAddrUpdate: public(HashMap[uint256, PendingAddressUpdate]) # regId -> pending addr update\npendingAddrDisable: public(HashMap[uint256, PendingAddressDisable]) # regId -> pending addr disable\n\nREGISTRY_STR: immutable(String[28])\nMIN_REG_TIME_LOCK: immutable(uint256)\nMAX_REG_TIME_LOCK: immutable(uint256)\n\n\n@deploy\ndef __init__(\n    _minTimeLock: uint256,\n    _maxTimeLock: uint256,\n    _initialTimeLock: uint256,\n    _registryStr: String[28],\n):\n    REGISTRY_STR = _registryStr\n\n    assert _minTimeLock < _maxTimeLock # dev: invalid time lock\n    assert _minTimeLock != 0 and _maxTimeLock != max_value(uint256) # dev: invalid time lock\n    MIN_REG_TIME_LOCK = _minTimeLock\n    MAX_REG_TIME_LOCK = _maxTimeLock\n\n    # set initial time lock -- this may be zero during inital setup of registry\n    if _initialTimeLock != 0:\n        assert self._setRegistryTimeLock(_initialTimeLock) # dev: invalid time lock\n\n    # start at 1 index\n    self.numAddrs = 1\n\n\n@view\n@external\ndef getRegistryDescription() -> String[28]:\n    return REGISTRY_STR\n\n\n###############\n# New Address #\n###############\n\n\n# register new address\n\n\n@internal\ndef _startAddNewAddressToRegistry(_addr: address, _description: String[64]) -> bool:\n    assert self._isValidNewAddress(_addr) # dev: invalid addy\n\n    confirmBlock: uint256 = block.number + self.registryChangeTimeLock\n    self.pendingNewAddr[_addr] = PendingNewAddress(\n        description=_description,\n        initiatedBlock=block.number,\n        confirmBlock=confirmBlock,\n    )\n\n    log NewAddressPending(addr=_addr, description=_description, confirmBlock=confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n# confirm new address\n\n\n@internal\ndef _confirmNewAddressToRegistry(_addr: address) -> uint256:\n    data: PendingNewAddress = self.pendingNewAddr[_addr]\n    assert data.confirmBlock != 0 and block.number >= data.confirmBlock # dev: time lock not reached\n\n    if not self._isValidNewAddress(_addr):\n        self.pendingNewAddr[_addr] = empty(PendingNewAddress) # clear pending\n        return 0\n\n    # register new addy\n    regId: uint256 = self.numAddrs\n    self.addrToRegId[_addr] = regId\n    self.numAddrs = regId + 1\n    self.addrInfo[regId] = AddressInfo(\n        addr=_addr,\n        version=1,\n        lastModified=block.timestamp,\n        description=data.description,\n    )\n\n    # clear pending\n    self.pendingNewAddr[_addr] = empty(PendingNewAddress)\n\n    log NewAddressConfirmed(addr=_addr, regId=regId, description=data.description, registry=REGISTRY_STR)\n    return regId\n\n\n# cancel new address\n\n\n@internal\ndef _cancelNewAddressToRegistry(_addr: address) -> bool:\n    data: PendingNewAddress = self.pendingNewAddr[_addr]\n    assert data.confirmBlock != 0 # dev: no pending\n\n    self.pendingNewAddr[_addr] = empty(PendingNewAddress)\n    log NewAddressCancelled(description=data.description, addr=_addr, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n# validation\n\n\n@view\n@external\ndef isValidNewAddress(_addr: address) -> bool:\n    return self._isValidNewAddress(_addr)\n\n\n@view\n@internal\ndef _isValidNewAddress(_addr: address) -> bool:\n    if _addr == empty(address) or not _addr.is_contract:\n        return False\n    return self.addrToRegId[_addr] == 0\n\n\n###################\n# Address Updates #\n###################\n\n\n# update address\n\n\n@internal\ndef _startAddressUpdateToRegistry(_regId: uint256, _newAddr: address) -> bool:\n    data: AddressInfo = self.addrInfo[_regId]\n    assert self._isValidAddressUpdate(_regId, _newAddr, data.addr) # dev: invalid update\n\n    # set pending\n    confirmBlock: uint256 = block.number + self.registryChangeTimeLock\n    self.pendingAddrUpdate[_regId] = PendingAddressUpdate(\n        newAddr=_newAddr,\n        initiatedBlock=block.number,\n        confirmBlock=confirmBlock,\n    )\n\n    log AddressUpdatePending(regId=_regId, description=data.description, newAddr=_newAddr, prevAddr=data.addr, version=data.version, confirmBlock=confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n# confirm update address\n\n\n@internal\ndef _confirmAddressUpdateToRegistry(_regId: uint256) -> bool:\n    newData: PendingAddressUpdate = self.pendingAddrUpdate[_regId]\n    assert newData.confirmBlock != 0 and block.number >= newData.confirmBlock # dev: time lock not reached\n\n    data: AddressInfo = self.addrInfo[_regId]\n    prevAddr: address = data.addr # needed for later\n    if not self._isValidAddressUpdate(_regId, newData.newAddr, prevAddr):\n        self.pendingAddrUpdate[_regId] = empty(PendingAddressUpdate) # clear pending\n        return False\n\n    # update addy data\n    data.addr = newData.newAddr\n    data.lastModified = block.timestamp\n    data.version += 1\n    self.addrInfo[_regId] = data\n    self.addrToRegId[newData.newAddr] = _regId\n\n    # handle previous addr\n    if prevAddr != empty(address):\n        self.addrToRegId[prevAddr] = 0\n\n    # clear pending\n    self.pendingAddrUpdate[_regId] = empty(PendingAddressUpdate)\n\n    log AddressUpdateConfirmed(regId=_regId, description=data.description, newAddr=newData.newAddr, prevAddr=prevAddr, version=data.version, registry=REGISTRY_STR)\n    return True\n\n\n# cancel update address\n\n\n@internal\ndef _cancelAddressUpdateToRegistry(_regId: uint256) -> bool:\n    data: PendingAddressUpdate = self.pendingAddrUpdate[_regId]\n    assert data.confirmBlock != 0 # dev: no pending\n\n    self.pendingAddrUpdate[_regId] = empty(PendingAddressUpdate)\n    prevData: AddressInfo = self.addrInfo[_regId]\n    log AddressUpdateCancelled(regId=_regId, description=prevData.description, newAddr=data.newAddr, prevAddr=prevData.addr, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n# validation\n\n\n@view\n@external\ndef isValidAddressUpdate(_regId: uint256, _newAddr: address) -> bool:\n    return self._isValidAddressUpdate(_regId, _newAddr, self.addrInfo[_regId].addr)\n\n\n@view\n@internal\ndef _isValidAddressUpdate(_regId: uint256, _newAddr: address, _prevAddr: address) -> bool:\n    if not self._isValidRegId(_regId):\n        return False\n    if not self._isValidNewAddress(_newAddr):\n        return False\n    return _newAddr != _prevAddr\n\n\n###################\n# Disable Address #\n###################\n\n\n# start disable address\n\n\n@internal\ndef _startAddressDisableInRegistry(_regId: uint256) -> bool:\n    data: AddressInfo = self.addrInfo[_regId]\n    assert self._isValidAddressDisable(_regId, data.addr) # dev: invalid disable\n\n    # set pending\n    confirmBlock: uint256 = block.number + self.registryChangeTimeLock\n    self.pendingAddrDisable[_regId] = PendingAddressDisable(\n        initiatedBlock=block.number,\n        confirmBlock=confirmBlock,\n    )\n\n    log AddressDisablePending(regId=_regId, description=data.description, addr=data.addr, version=data.version, confirmBlock=confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n# confirm disable address\n\n\n@internal\ndef _confirmAddressDisableInRegistry(_regId: uint256) -> bool:\n    newData: PendingAddressDisable = self.pendingAddrDisable[_regId]\n    assert newData.confirmBlock != 0 and block.number >= newData.confirmBlock # dev: time lock not reached\n\n    data: AddressInfo = self.addrInfo[_regId]\n    prevAddr: address = data.addr # needed for later\n    if not self._isValidAddressDisable(_regId, prevAddr):\n        self.pendingAddrDisable[_regId] = empty(PendingAddressDisable) # clear pending\n        return False\n\n    # disable addy\n    data.addr = empty(address)\n    data.lastModified = block.timestamp\n    data.version += 1\n    self.addrInfo[_regId] = data\n    self.addrToRegId[prevAddr] = 0\n\n    # clear pending\n    self.pendingAddrDisable[_regId] = empty(PendingAddressDisable)\n\n    log AddressDisableConfirmed(regId=_regId, description=data.description, addr=prevAddr, version=data.version, registry=REGISTRY_STR)\n    return True\n\n\n# cancel disable address\n\n\n@internal\ndef _cancelAddressDisableInRegistry(_regId: uint256) -> bool:\n    data: PendingAddressDisable = self.pendingAddrDisable[_regId]\n    assert data.confirmBlock != 0 # dev: no pending\n\n    self.pendingAddrDisable[_regId] = empty(PendingAddressDisable)\n    prevData: AddressInfo = self.addrInfo[_regId]\n    log AddressDisableCancelled(regId=_regId, description=prevData.description, addr=prevData.addr, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n# validation\n\n\n@view\n@external\ndef isValidAddressDisable(_regId: uint256) -> bool:\n    return self._isValidAddressDisable(_regId, self.addrInfo[_regId].addr)\n\n\n@view\n@internal\ndef _isValidAddressDisable(_regId: uint256, _prevAddr: address) -> bool:\n    if not self._isValidRegId(_regId):\n        return False\n    return _prevAddr != empty(address)\n\n\n####################\n# Time Lock Config #\n####################\n\n\n@external\ndef setRegistryTimeLock(_numBlocks: uint256) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return self._setRegistryTimeLock(_numBlocks)\n\n\n@internal\ndef _setRegistryTimeLock(_numBlocks: uint256) -> bool:\n    prevTimeLock: uint256 = self.registryChangeTimeLock\n    assert self._isValidRegistryTimeLock(_numBlocks, prevTimeLock) # dev: invalid time lock\n    self.registryChangeTimeLock = _numBlocks\n    log RegistryTimeLockModified(newTimeLock=_numBlocks, prevTimeLock=prevTimeLock, registry=REGISTRY_STR)\n    return True\n\n\n# validation\n\n\n@view\n@external\ndef isValidRegistryTimeLock(_numBlocks: uint256) -> bool:\n    return self._isValidRegistryTimeLock(_numBlocks, self.registryChangeTimeLock)\n\n\n@view\n@internal\ndef _isValidRegistryTimeLock(_newTimeLock: uint256, _prevTimeLock: uint256) -> bool:\n    if _newTimeLock == _prevTimeLock:\n        return False\n    return _newTimeLock >= MIN_REG_TIME_LOCK and _newTimeLock <= MAX_REG_TIME_LOCK\n\n\n# finish setup\n\n\n@external\ndef setRegistryTimeLockAfterSetup(_numBlocks: uint256 = 0) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert self.registryChangeTimeLock == 0 # dev: already set\n\n    timeLock: uint256 = _numBlocks\n    if timeLock == 0:\n        timeLock = MIN_REG_TIME_LOCK\n    return self._setRegistryTimeLock(timeLock)\n\n\n# utils\n\n\n@view\n@external\ndef minRegistryTimeLock() -> uint256:\n    return MIN_REG_TIME_LOCK\n\n\n@view\n@external\ndef maxRegistryTimeLock() -> uint256:\n    return MAX_REG_TIME_LOCK\n\n\n#################\n# Views / Utils #\n#################\n\n\n# is valid addr\n\n\n@view\n@external\ndef isValidAddr(_addr: address) -> bool:\n    return self._isValidAddr(_addr)\n\n\n@view\n@internal\ndef _isValidAddr(_addr: address) -> bool:\n    return self.addrToRegId[_addr] != 0\n\n\n# is valid addr id\n\n\n@view\n@external\ndef isValidRegId(_regId: uint256) -> bool:\n    return self._isValidRegId(_regId)\n\n\n@view\n@internal\ndef _isValidRegId(_regId: uint256) -> bool:\n    return _regId != 0 and _regId < self.numAddrs\n\n\n# get reg id\n\n\n@view\n@external\ndef getRegId(_addr: address) -> uint256:\n    return self._getRegId(_addr)\n\n\n@view\n@internal\ndef _getRegId(_addr: address) -> uint256:\n    return self.addrToRegId[_addr]\n\n\n# get addr\n\n\n@view\n@external\ndef getAddr(_regId: uint256) -> address:\n    return self._getAddr(_regId)\n\n\n@view\n@internal\ndef _getAddr(_regId: uint256) -> address:\n    return self.addrInfo[_regId].addr\n\n\n# get addr info\n\n\n@view\n@external\ndef getAddrInfo(_regId: uint256) -> AddressInfo:\n    return self._getAddrInfo(_regId)\n\n\n@view\n@internal\ndef _getAddrInfo(_regId: uint256) -> AddressInfo:\n    return self.addrInfo[_regId]\n\n\n# get addr description\n\n\n@view\n@external\ndef getAddrDescription(_regId: uint256) -> String[64]:\n    return self._getAddrDescription(_regId)\n\n\n@view\n@internal\ndef _getAddrDescription(_regId: uint256) -> String[64]:\n    return self.addrInfo[_regId].description\n\n\n# get num addrs\n\n\n@view\n@external\ndef getNumAddrs() -> uint256:\n    return self._getNumAddrs()\n\n\n@view\n@internal\ndef _getNumAddrs() -> uint256:\n    return self.numAddrs - 1\n\n\n# get last addr\n\n\n@view\n@external\ndef getLastAddr() -> address:\n    return self._getLastAddr()\n\n\n@view\n@internal\ndef _getLastAddr() -> address:\n    lastRegId: uint256 = self.numAddrs - 1\n    return self.addrInfo[lastRegId].addr\n\n\n# get last reg id\n\n\n@view\n@external\ndef getLastRegId() -> uint256:\n    return self._getLastRegId()\n\n\n@view\n@internal\ndef _getLastRegId() -> uint256:\n    return self.numAddrs - 1\n",
            "sha256sum": "b88f6fc85ae3cd815c5a476c620b2fb5494b4dec5f1ce738878eded11c46396b"
          },
          "contracts/modules/Addys.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\ninterface UndyHq:\n    def isValidAddr(_addr: address) -> bool: view\n    def getAddr(_regId: uint256) -> address: view\n    def undyToken() -> address: view\n\ninterface Switchboard:\n    def isSwitchboardAddr(_addr: address) -> bool: view\n\ninterface LegoBook:\n    def isLegoAddr(_addr: address) -> bool: view\n\nstruct Addys:\n    hq: address\n    undyToken: address\n    ledger: address\n    missionControl: address\n    legoBook: address\n    switchboard: address\n    hatchery: address\n    lootDistributor: address\n    appraiser: address\n    walletBackpack: address\n    billing: address\n    vaultRegistry: address\n\n# hq\nUNDY_HQ_FOR_ADDYS: immutable(address)\n\n# core addys\nLEDGER_ID: constant(uint256) = 1\nMISSION_CONTROL_ID: constant(uint256) = 2\nLEGO_BOOK_ID: constant(uint256) = 3\nSWITCHBOARD_ID: constant(uint256) = 4\nHATCHERY_ID: constant(uint256) = 5\nLOOT_DISTRIBUTOR_ID: constant(uint256) = 6\nAPPRAISER_ID: constant(uint256) = 7\nWALLET_BACKPACK_ID: constant(uint256) = 8\nBILLING_ID: constant(uint256) = 9\nVAULT_REGISTRY_ID: constant(uint256) = 10\n\n\n@deploy\ndef __init__(_undyHq: address):\n    assert _undyHq != empty(address) # dev: invalid undy hq\n    UNDY_HQ_FOR_ADDYS = _undyHq\n\n\n########\n# Core #\n########\n\n\n@view\n@external\ndef getAddys() -> Addys:\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _getAddys(_addys: Addys = empty(Addys)) -> Addys:\n    if _addys.hq != empty(address):\n        return _addys\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _generateAddys() -> Addys:\n    hq: address = UNDY_HQ_FOR_ADDYS\n    return Addys(\n        hq = hq,\n        undyToken = staticcall UndyHq(hq).undyToken(),\n        ledger = staticcall UndyHq(hq).getAddr(LEDGER_ID),\n        missionControl = staticcall UndyHq(hq).getAddr(MISSION_CONTROL_ID),\n        legoBook = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID),\n        switchboard = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID),\n        hatchery = staticcall UndyHq(hq).getAddr(HATCHERY_ID),\n        lootDistributor = staticcall UndyHq(hq).getAddr(LOOT_DISTRIBUTOR_ID),\n        appraiser = staticcall UndyHq(hq).getAddr(APPRAISER_ID),\n        walletBackpack = staticcall UndyHq(hq).getAddr(WALLET_BACKPACK_ID),\n        billing = staticcall UndyHq(hq).getAddr(BILLING_ID),\n        vaultRegistry = staticcall UndyHq(hq).getAddr(VAULT_REGISTRY_ID),\n    )\n\n\n##########\n# Tokens #\n##########\n\n\n@view\n@internal\ndef _getUndyToken() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).undyToken()\n\n\n###########\n# Helpers #\n###########\n\n\n# undy hq\n\n\n@view\n@external\ndef getUndyHq() -> address:\n    return self._getUndyHq()\n\n\n@view\n@internal\ndef _getUndyHq() -> address:\n    return UNDY_HQ_FOR_ADDYS\n\n\n# utils\n\n\n@view\n@internal\ndef _isValidUndyAddr(_addr: address, _hq: address = empty(address)) -> bool:\n    hq: address = _hq\n    if _hq == empty(address):\n        hq = UNDY_HQ_FOR_ADDYS\n    \n    # core departments\n    if staticcall UndyHq(hq).isValidAddr(_addr):\n        return True\n\n    # lego book\n    legoBook: address = staticcall UndyHq(hq).getAddr(LEGO_BOOK_ID)\n    if legoBook != empty(address) and staticcall LegoBook(legoBook).isLegoAddr(_addr):\n        return True\n\n    # switchboard config\n    switchboard: address = staticcall UndyHq(hq).getAddr(SWITCHBOARD_ID)\n    if switchboard != empty(address) and staticcall Switchboard(switchboard).isSwitchboardAddr(_addr):\n        return True\n\n    return False\n\n\n@view\n@internal\ndef _isSwitchboardAddr(_addr: address) -> bool:\n    switchboard: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n    if switchboard == empty(address):\n        return False\n    return staticcall Switchboard(switchboard).isSwitchboardAddr(_addr)\n\n\n@view\n@internal\ndef _isLegoBookAddr(_addr: address) -> bool:\n    legoBook: address = staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n    if legoBook == empty(address):\n        return False\n    return staticcall LegoBook(legoBook).isLegoAddr(_addr)\n\n\n###############\n# Departments #\n###############\n\n\n# ledger\n\n\n@view\n@internal\ndef _getLedgerId() -> uint256:\n    return LEDGER_ID\n\n\n@view\n@internal\ndef _getLedgerAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEDGER_ID)\n\n\n# mission control\n\n\n@view\n@internal\ndef _getMissionControlId() -> uint256:\n    return MISSION_CONTROL_ID\n\n\n@view\n@internal\ndef _getMissionControlAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(MISSION_CONTROL_ID)\n\n\n# lego book\n\n\n@view\n@internal\ndef _getLegoBookId() -> uint256:\n    return LEGO_BOOK_ID\n\n\n@view\n@internal\ndef _getLegoBookAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LEGO_BOOK_ID)\n\n\n# switchboard\n\n\n@view\n@internal\ndef _getSwitchboardId() -> uint256:\n    return SWITCHBOARD_ID\n\n\n@view\n@internal\ndef _getSwitchboardAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n\n\n# hatchery\n\n\n@view\n@internal\ndef _getHatcheryId() -> uint256:\n    return HATCHERY_ID\n\n\n@view\n@internal\ndef _getHatcheryAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(HATCHERY_ID)\n\n\n# loot distributor\n\n\n@view\n@internal\ndef _getLootDistributorId() -> uint256:\n    return LOOT_DISTRIBUTOR_ID\n\n\n@view\n@internal\ndef _getLootDistributorAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(LOOT_DISTRIBUTOR_ID)\n\n\n# appraiser\n\n\n@view\n@internal\ndef _getAppraiserId() -> uint256:\n    return APPRAISER_ID\n\n\n@view\n@internal\ndef _getAppraiserAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(APPRAISER_ID)\n\n\n# wallet backpack\n\n\n@view\n@internal\ndef _getWalletBackpackId() -> uint256:\n    return WALLET_BACKPACK_ID\n\n\n@view\n@internal\ndef _getWalletBackpackAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(WALLET_BACKPACK_ID)\n\n\n# billing\n\n\n@view\n@internal\ndef _getBillingId() -> uint256:\n    return BILLING_ID\n\n\n@view\n@internal\ndef _getBillingAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(BILLING_ID)\n\n\n# vault registry\n\n\n@view\n@internal\ndef _getVaultRegistryId() -> uint256:\n    return VAULT_REGISTRY_ID\n\n\n@view\n@internal\ndef _getVaultRegistryAddr() -> address:\n    return staticcall UndyHq(UNDY_HQ_FOR_ADDYS).getAddr(VAULT_REGISTRY_ID)",
            "sha256sum": "4df6b72db9bb417d1af81660175be1450cfb7b3575f3d17a5b8a130bff87b781"
          },
          "interfaces/Department.vyi": {
            "content": "# @version 0.4.3\n\n\n###########\n# Minting #\n###########\n\n\n@view\n@external\ndef canMintUndy() -> bool:\n    # used in UndyHq.vy\n    ...\n\n\n########\n# Undy #\n########\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "53e48da591c4ee36045a8950c9d3a01458456b471b797df536e9a9f54404e721"
          },
          "contracts/modules/DeptBasics.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nuses: addys\nimplements: dept\n\nimport contracts.modules.Addys as addys\nimport interfaces.Department as dept\nfrom ethereum.ercs import IERC20\n\nevent DepartmentPauseModified:\n    isPaused: bool\n\nevent DepartmentFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    balance: uint256\n\nisPaused: public(bool)\n\nCAN_MINT_UNDY: immutable(bool)\nMAX_RECOVER_ASSETS: constant(uint256) = 20\n\n\n@deploy\ndef __init__(_shouldPause: bool, _canMintUndy: bool):\n    self.isPaused = _shouldPause\n    CAN_MINT_UNDY = _canMintUndy\n\n\n###########\n# Minting #\n###########\n\n\n@view\n@external\ndef canMintUndy() -> bool:\n    return CAN_MINT_UNDY\n\n\n########\n# Undy #\n########\n\n\n# activate\n\n\n@external\ndef pause(_shouldPause: bool):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert _shouldPause != self.isPaused # dev: no change\n    self.isPaused = _shouldPause\n    log DepartmentPauseModified(isPaused=_shouldPause)\n\n\n# recover funds\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    self._recoverFunds(_recipient, _asset)\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, MAX_RECOVER_ASSETS]):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    for a: address in _assets:\n        self._recoverFunds(_recipient, a)\n\n\n@internal\ndef _recoverFunds(_recipient: address, _asset: address):\n    assert empty(address) not in [_recipient, _asset] # dev: invalid recipient or asset\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    assert balance != 0 # dev: nothing to recover\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log DepartmentFundsRecovered(asset=_asset, recipient=_recipient, balance=balance)\n",
            "sha256sum": "976a50a3807bcf71f3f1c57de5cd7a59fe4e8f27b4d4560e774073962f44d1ac"
          },
          "contracts/registries/VaultRegistry.vy": {
            "content": "#     Underscore Protocol License: https://github.com/underscore-finance/underscore-protocol/blob/master/LICENSE.md\n\n# @version 0.4.3\n\nimplements: Department\n\nexports: gov.__interface__\nexports: registry.__interface__\nexports: addys.__interface__\nexports: deptBasics.__interface__\n\ninitializes: gov\ninitializes: registry[gov := gov]\ninitializes: addys\ninitializes: deptBasics[addys := addys]\n\nimport contracts.modules.LocalGov as gov\nimport contracts.modules.AddressRegistry as registry\nimport contracts.modules.Addys as addys\nimport contracts.modules.DeptBasics as deptBasics\n\nfrom interfaces import Department\n\ninterface Ledger:\n    def vaultTokens(_vaultToken: address) -> VaultToken: view\n\ninterface Registry:\n    def getAddr(_regId: uint256) -> address: view\n\nstruct VaultConfig:\n    canDeposit: bool\n    canWithdraw: bool\n    maxDepositAmount: uint256\n    isVaultOpsFrozen: bool\n    redemptionBuffer: uint256\n    minYieldWithdrawAmount: uint256\n    performanceFee: uint256\n    shouldAutoDeposit: bool\n    defaultTargetVaultToken: address\n\nstruct VaultToken:\n    legoId: uint256\n    underlyingAsset: address\n    decimals: uint256\n    isRebasing: bool\n\nstruct VaultActionData:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    appraiser: address\n    vaultRegistry: address\n    vaultAsset: address\n    signer: address\n    legoId: uint256\n    legoAddr: address\n\nevent CanDepositSet:\n    vaultAddr: indexed(address)\n    canDeposit: bool\n\nevent CanWithdrawSet:\n    vaultAddr: indexed(address)\n    canWithdraw: bool\n\nevent MaxDepositAmountSet:\n    vaultAddr: indexed(address)\n    maxDepositAmount: uint256\n\nevent VaultOpsFrozenSet:\n    vaultAddr: indexed(address)\n    isFrozen: bool\n\nevent RedemptionBufferSet:\n    vaultAddr: indexed(address)\n    buffer: uint256\n\nevent MinYieldWithdrawAmountSet:\n    vaultAddr: indexed(address)\n    amount: uint256\n\nevent PerformanceFeeSet:\n    vaultAddr: indexed(address)\n    performanceFee: uint256\n\nevent DefaultTargetVaultTokenSet:\n    vaultAddr: indexed(address)\n    targetVaultToken: indexed(address)\n\nevent ShouldAutoDepositSet:\n    vaultAddr: indexed(address)\n    shouldAutoDeposit: bool\n\nevent ApprovedVaultTokenSet:\n    vaultAddr: indexed(address)\n    vaultToken: indexed(address)\n    isApproved: bool\n\n# config\nvaultConfigs: public(HashMap[address, VaultConfig]) # vault addr -> vault config\nisApprovedVaultToken: public(HashMap[address, HashMap[address, bool]]) # vault addr -> vault token -> is approved\n\nONE_WEEK_SECONDS: constant(uint256) = 60 * 60 * 24 * 7\nHUNDRED_PERCENT: constant(uint256) = 100_00\n\n\n@deploy\ndef __init__(\n    _undyHq: address,\n    _tempGov: address,\n    _minRegistryTimeLock: uint256,\n    _maxRegistryTimeLock: uint256,\n):\n    gov.__init__(_undyHq, _tempGov, 0, 0, 0)\n    registry.__init__(_minRegistryTimeLock, _maxRegistryTimeLock, 0, \"VaultRegistry.vy\")\n    addys.__init__(_undyHq)\n    deptBasics.__init__(False, False) # no minting\n\n\n# is earn vault\n\n\n@view\n@external\ndef isEarnVault(_vaultAddr: address) -> bool:\n    return registry._isValidAddr(_vaultAddr)\n\n\n# gov access\n\n\n@view\n@internal\ndef _canPerformAction(_caller: address) -> bool:\n    return gov._canGovern(_caller) and not deptBasics.isPaused\n\n\n############\n# Registry #\n############\n\n\n@external\ndef startAddNewAddressToRegistry(_vaultAddr: address, _description: String[64]) -> bool:\n    assert self._canPerformAction(msg.sender) # dev: no perms\n    return registry._startAddNewAddressToRegistry(_vaultAddr, _description)\n\n\n@external\ndef confirmNewAddressToRegistry(\n    _vaultAddr: address,\n    _approvedVaultTokens: DynArray[address, 25] = [],\n    _maxDepositAmount: uint256 = max_value(uint256),\n    _minYieldWithdrawAmount: uint256 = 0,\n    _performanceFee: uint256 = 20_00, # 20.00%\n    _defaultTargetVaultToken: address = empty(address),\n    _shouldAutoDeposit: bool = True,\n    _canDeposit: bool = True,\n    _canWithdraw: bool = True,\n    _isVaultOpsFrozen: bool = False,\n    _redemptionBuffer: uint256 = 2_00, # 2.00%\n) -> uint256:\n    assert self._canPerformAction(msg.sender) # dev: no perms\n    regId: uint256 = registry._confirmNewAddressToRegistry(_vaultAddr)\n    if regId != 0:\n        self._initializeVaultConfig(\n            _vaultAddr,\n            _maxDepositAmount,\n            _minYieldWithdrawAmount,\n            _approvedVaultTokens,\n            _performanceFee,\n            _defaultTargetVaultToken,\n            _shouldAutoDeposit,\n            _canDeposit,\n            _canWithdraw,\n            _isVaultOpsFrozen,\n            _redemptionBuffer,\n        )\n    return regId\n\n\n@external\ndef cancelNewAddressToRegistry(_vaultAddr: address) -> bool:\n    assert self._canPerformAction(msg.sender) # dev: no perms\n    return registry._cancelNewAddressToRegistry(_vaultAddr)\n\n\n# set vault config\n\n\n@internal\ndef _initializeVaultConfig(\n    _vaultAddr: address,\n    _maxDepositAmount: uint256,\n    _minYieldWithdrawAmount: uint256,\n    _approvedVaultTokens: DynArray[address, 25],\n    _performanceFee: uint256,\n    _defaultTargetVaultToken: address,\n    _shouldAutoDeposit: bool,\n    _canDeposit: bool,\n    _canWithdraw: bool,\n    _isVaultOpsFrozen: bool,\n    _redemptionBuffer: uint256,\n):\n    assert registry._isValidAddr(_vaultAddr) # dev: invalid vault addr\n\n    # validation\n    assert self._isValidRedemptionBuffer(_redemptionBuffer) # dev: invalid redemption buffer\n    assert self._isValidPerformanceFee(_performanceFee) # dev: invalid performance fee\n\n    # target token\n    if _defaultTargetVaultToken != empty(address):\n        assert _defaultTargetVaultToken in _approvedVaultTokens # dev: invalid target vault token\n\n    config: VaultConfig = VaultConfig(\n        canDeposit = _canDeposit,\n        canWithdraw = _canWithdraw,\n        maxDepositAmount = _maxDepositAmount,\n        isVaultOpsFrozen = _isVaultOpsFrozen,\n        redemptionBuffer = _redemptionBuffer,\n        minYieldWithdrawAmount = _minYieldWithdrawAmount,\n        performanceFee = _performanceFee,\n        shouldAutoDeposit = _shouldAutoDeposit,\n        defaultTargetVaultToken = _defaultTargetVaultToken,\n    )\n    self.vaultConfigs[_vaultAddr] = config\n\n    # approve vault tokens\n    for vaultToken: address in _approvedVaultTokens:\n        if vaultToken != empty(address):\n            self.isApprovedVaultToken[_vaultAddr][vaultToken] = True\n\n\n######################\n# Basic Vault Config #\n######################\n\n\n@external\ndef setCanDeposit(_vaultAddr: address, _canDeposit: bool):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert registry._isValidAddr(_vaultAddr) # dev: invalid vault addr\n\n    config: VaultConfig = self.vaultConfigs[_vaultAddr]\n    config.canDeposit = _canDeposit\n    self.vaultConfigs[_vaultAddr] = config\n    log CanDepositSet(vaultAddr=_vaultAddr, canDeposit=_canDeposit)\n\n\n@external\ndef setCanWithdraw(_vaultAddr: address, _canWithdraw: bool):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert registry._isValidAddr(_vaultAddr) # dev: invalid vault addr\n\n    config: VaultConfig = self.vaultConfigs[_vaultAddr]\n    config.canWithdraw = _canWithdraw\n    self.vaultConfigs[_vaultAddr] = config\n    log CanWithdrawSet(vaultAddr=_vaultAddr, canWithdraw=_canWithdraw)\n\n\n@external\ndef setMaxDepositAmount(_vaultAddr: address, _maxDepositAmount: uint256):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert registry._isValidAddr(_vaultAddr) # dev: invalid vault addr\n\n    config: VaultConfig = self.vaultConfigs[_vaultAddr]\n    config.maxDepositAmount = _maxDepositAmount\n    self.vaultConfigs[_vaultAddr] = config\n    log MaxDepositAmountSet(vaultAddr=_vaultAddr, maxDepositAmount=_maxDepositAmount)\n\n\n@external\ndef setVaultOpsFrozen(_vaultAddr: address, _isFrozen: bool):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert registry._isValidAddr(_vaultAddr) # dev: invalid vault addr\n\n    config: VaultConfig = self.vaultConfigs[_vaultAddr]\n    config.isVaultOpsFrozen = _isFrozen\n    self.vaultConfigs[_vaultAddr] = config\n    log VaultOpsFrozenSet(vaultAddr=_vaultAddr, isFrozen=_isFrozen)\n\n\n@external\ndef setShouldAutoDeposit(_vaultAddr: address, _shouldAutoDeposit: bool):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert registry._isValidAddr(_vaultAddr) # dev: invalid vault addr\n\n    config: VaultConfig = self.vaultConfigs[_vaultAddr]\n    config.shouldAutoDeposit = _shouldAutoDeposit\n    self.vaultConfigs[_vaultAddr] = config\n    log ShouldAutoDepositSet(vaultAddr=_vaultAddr, shouldAutoDeposit=_shouldAutoDeposit)\n\n\n@external\ndef setMinYieldWithdrawAmount(_vaultAddr: address, _amount: uint256):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert registry._isValidAddr(_vaultAddr) # dev: invalid vault addr\n\n    config: VaultConfig = self.vaultConfigs[_vaultAddr]\n    config.minYieldWithdrawAmount = _amount\n    self.vaultConfigs[_vaultAddr] = config\n    log MinYieldWithdrawAmountSet(vaultAddr=_vaultAddr, amount=_amount)\n\n\n############################\n# Approved Yield Positions #\n############################\n\n\n@external\ndef setApprovedVaultToken(_vaultAddr: address, _vaultToken: address, _isApproved: bool):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert registry._isValidAddr(_vaultAddr) # dev: invalid vault addr\n    assert self._isValidVaultToken(_vaultToken) # dev: invalid vault token\n\n    self.isApprovedVaultToken[_vaultAddr][_vaultToken] = _isApproved\n    log ApprovedVaultTokenSet(vaultAddr=_vaultAddr, vaultToken=_vaultToken, isApproved=_isApproved)\n\n\n@view\n@external\ndef isValidVaultToken(_vaultToken: address) -> bool:\n    return self._isValidVaultToken(_vaultToken)\n\n\n@view\n@internal\ndef _isValidVaultToken(_vaultToken: address) -> bool:\n    return _vaultToken != empty(address)\n\n\n######################\n# Target Vault Token #\n######################\n\n\n@external\ndef setDefaultTargetVaultToken(_vaultAddr: address, _targetVaultToken: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert registry._isValidAddr(_vaultAddr) # dev: invalid vault addr\n    assert self._isValidDefaultTargetVaultToken(_vaultAddr, _targetVaultToken) # dev: invalid default target vault token\n\n    config: VaultConfig = self.vaultConfigs[_vaultAddr]\n    config.defaultTargetVaultToken = _targetVaultToken\n    self.vaultConfigs[_vaultAddr] = config\n    log DefaultTargetVaultTokenSet(vaultAddr=_vaultAddr, targetVaultToken=_targetVaultToken)\n\n\n@view\n@external\ndef isValidDefaultTargetVaultToken(_vaultAddr: address, _targetVaultToken: address) -> bool:\n    return self._isValidDefaultTargetVaultToken(_vaultAddr, _targetVaultToken)\n\n\n@view\n@internal\ndef _isValidDefaultTargetVaultToken(_vaultAddr: address, _targetVaultToken: address) -> bool:\n    if _targetVaultToken == empty(address):\n        return True\n    return self.isApprovedVaultToken[_vaultAddr][_targetVaultToken]\n\n\n###################\n# Performance Fee #\n###################\n\n\n@external\ndef setPerformanceFee(_vaultAddr: address, _performanceFee: uint256):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert registry._isValidAddr(_vaultAddr) # dev: invalid vault addr\n    assert self._isValidPerformanceFee(_performanceFee) # dev: invalid performance fee\n\n    config: VaultConfig = self.vaultConfigs[_vaultAddr]\n    config.performanceFee = _performanceFee\n    self.vaultConfigs[_vaultAddr] = config\n    log PerformanceFeeSet(vaultAddr=_vaultAddr, performanceFee=_performanceFee)\n\n\n@view\n@external\ndef isValidPerformanceFee(_performanceFee: uint256) -> bool:\n    return self._isValidPerformanceFee(_performanceFee)\n\n\n@view\n@internal\ndef _isValidPerformanceFee(_performanceFee: uint256) -> bool:\n    return _performanceFee <= HUNDRED_PERCENT\n\n\n#####################\n# Redemption Buffer #\n#####################\n\n\n@external\ndef setRedemptionBuffer(_vaultAddr: address, _buffer: uint256):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert registry._isValidAddr(_vaultAddr) # dev: invalid vault addr\n    assert self._isValidRedemptionBuffer(_buffer) # dev: invalid redemption buffer\n\n    config: VaultConfig = self.vaultConfigs[_vaultAddr]\n    config.redemptionBuffer = _buffer\n    self.vaultConfigs[_vaultAddr] = config\n    log RedemptionBufferSet(vaultAddr=_vaultAddr, buffer=_buffer)\n\n\n@view\n@external\ndef isValidRedemptionBuffer(_buffer: uint256) -> bool:\n    return self._isValidRedemptionBuffer(_buffer)\n\n\n@view\n@internal\ndef _isValidRedemptionBuffer(_buffer: uint256) -> bool:\n    return _buffer <= 10_00\n\n\n######################\n# Vault Config Views #\n######################\n\n\n@view\n@external\ndef canDeposit(_vaultAddr: address) -> bool:\n    return self.vaultConfigs[_vaultAddr].canDeposit\n\n\n@view\n@external\ndef canWithdraw(_vaultAddr: address) -> bool:\n    return self.vaultConfigs[_vaultAddr].canWithdraw\n\n\n@view\n@external\ndef maxDepositAmount(_vaultAddr: address) -> uint256:\n    return self.vaultConfigs[_vaultAddr].maxDepositAmount\n\n\n@view\n@external\ndef isVaultOpsFrozen(_vaultAddr: address) -> bool:\n    return self.vaultConfigs[_vaultAddr].isVaultOpsFrozen\n\n\n@view\n@external\ndef redemptionBuffer(_vaultAddr: address) -> uint256:\n    return self.vaultConfigs[_vaultAddr].redemptionBuffer\n\n\n@view\n@external\ndef minYieldWithdrawAmount(_vaultAddr: address) -> uint256:\n    return self.vaultConfigs[_vaultAddr].minYieldWithdrawAmount\n\n\n@view\n@external\ndef redemptionConfig(_vaultAddr: address) -> (uint256, uint256):\n    config: VaultConfig = self.vaultConfigs[_vaultAddr]\n    return config.redemptionBuffer, config.minYieldWithdrawAmount\n\n\n@view\n@external\ndef getPerformanceFee(_vaultAddr: address) -> uint256:\n    return self.vaultConfigs[_vaultAddr].performanceFee\n\n\n@view\n@external\ndef getDefaultTargetVaultToken(_vaultAddr: address) -> address:\n    return self.vaultConfigs[_vaultAddr].defaultTargetVaultToken\n\n\n@view\n@external\ndef shouldAutoDeposit(_vaultAddr: address) -> bool:\n    return self.vaultConfigs[_vaultAddr].shouldAutoDeposit\n\n\n@view\n@external\ndef isApprovedVaultTokenByAddr(_vaultAddr: address, _vaultToken: address) -> bool:\n    return self.isApprovedVaultToken[_vaultAddr][_vaultToken]\n\n\n@view\n@external\ndef checkVaultApprovals(_vaultAddr: address, _vaultToken: address) -> bool:\n    return self.isApprovedVaultToken[_vaultAddr][_vaultToken]\n\n\n@view\n@external\ndef getVaultConfig(_regId: uint256) -> VaultConfig:\n    vaultAddr: address = registry._getAddr(_regId)\n    return self.vaultConfigs[vaultAddr]\n\n\n@view\n@external\ndef getVaultConfigByAddr(_vaultAddr: address) -> VaultConfig:\n    return self.vaultConfigs[_vaultAddr]\n\n\n@view\n@external\ndef getVaultActionDataBundle(_legoId: uint256, _signer: address) -> VaultActionData:\n    return self._getVaultActionDataBundle(_legoId, _signer)\n\n\n@view\n@internal\ndef _getVaultActionDataBundle(_legoId: uint256, _signer: address) -> VaultActionData:\n    a: addys.Addys = addys._getAddys()\n\n    legoAddr: address = empty(address)\n    if _legoId != 0:\n        legoAddr = staticcall Registry(a.legoBook).getAddr(_legoId)\n\n    return VaultActionData(\n        ledger = a.ledger,\n        missionControl = a.missionControl,\n        legoBook = a.legoBook,\n        appraiser = a.appraiser,\n        vaultRegistry = self,\n        vaultAsset = empty(address),\n        signer = _signer,\n        legoId = _legoId,\n        legoAddr = legoAddr,\n    )\n\n\n@view\n@external\ndef getVaultActionDataWithFrozenStatus(_legoId: uint256, _signer: address, _vaultAddr: address) -> (VaultActionData, bool):\n    return self._getVaultActionDataBundle(_legoId, _signer), self.vaultConfigs[_vaultAddr].isVaultOpsFrozen\n\n\n@view\n@external\ndef getLegoDataFromVaultToken(_vaultToken: address) -> (uint256, address):\n    return self._getLegoDataFromVaultToken(_vaultToken)\n\n\n@view\n@internal\ndef _getLegoDataFromVaultToken(_vaultToken: address) -> (uint256, address):\n    a: addys.Addys = addys._getAddys()\n    data: VaultToken = staticcall Ledger(a.ledger).vaultTokens(_vaultToken)\n    if data.legoId == 0:\n        return 0, empty(address)\n    return data.legoId, staticcall Registry(a.legoBook).getAddr(data.legoId)\n\n\n@view\n@external\ndef getLegoAddrFromVaultToken(_vaultToken: address) -> address:\n    return self._getLegoDataFromVaultToken(_vaultToken)[1]\n\n\n@view\n@external\ndef getDepositConfig(_vaultAddr: address) -> (bool, uint256, bool, address):\n    config: VaultConfig = self.vaultConfigs[_vaultAddr]\n    return config.canDeposit, config.maxDepositAmount, config.shouldAutoDeposit, config.defaultTargetVaultToken\n\n\n",
            "sha256sum": "561dacc67cb7fe8df43177418ffecfc00d34221bd7d1196f12ddde911f6facd0"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/registries/VaultRegistry.vy": ["*"]
          },
          "search_paths": ["."]
        },
        "compiler_version": "v0.4.3+commit.bff19ea2",
        "integrity": "2c01ea70daf61f52d909bd774689ef10952bed74bbf020b0e1876dfa428642b1"
      },
      "args": "00000000000000000000000044cf3c4f000dfd76a35d03298049d37be688d6f90000000000000000000000003ed8174065c00fe511a91850cf8f45d161e8ee150000000000000000000000000000000000000000000000000000000000000e10000000000000000000000000000000000000000000000000000000000013c680",
      "file": "contracts/registries/VaultRegistry.vy"
    }
  }
}
